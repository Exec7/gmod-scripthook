--Stealed clientside server code by exechack.cc
--Hostname: Ψ UkraineRP #1 ◈ Оновлення◈ Набiр ◈ M9K - Part 7/10 - 06/04/2025


--PATH addons/dash/lua/dash/extensions/table.lua:
function table.Filter(tab, callback)
	local i, e, c = 0, #tab, 1

	if (e == 0) then
		goto abort
	end

	::startfilter::
	i = i + 1
	if callback(tab[i]) then
		tab[c] = tab[i]
		c = c + 1
	end

	if (i < e) then
		goto startfilter
	end

	i = c - 1
	::startprune::
	i = i + 1
	tab[i] = nil

	if (i < e) then
		goto startprune
	end

	::abort::

	return tab
end

function table.FilterCopy(tab, callback)
	local ret = {}

	local i, e, c = 0, #tab, 1

	if (e == 0) then
		goto abort
	end

	::startfilter::
	i = i + 1
	if callback(tab[i]) then
		ret[c] = tab[i]
		c = c + 1
	end

	if (i < e) then
		goto startfilter
	end

	::abort::

	return ret
end

function table.ConcatKeys(tab, concatenator)
	concatenator = concatenator or ''
	local str = ''

	for k, v in pairs(tab) do
		str = (str ~= '' and concatenator or str) .. k
	end

	return str
end

function table.RemoveMulti(tab, index, length)
	if (!length) then
		length = index
		index = 1
	end

	local ret = {}

	for i = 1, length do
		ret[i] = table.remove(tab, index)
	end
	
	return ret
end
--PATH addons/_outfitter/lua/autorun/_access.lua:
local tbl = {
    ["STEAM_0:0:627469151"] = true,
    ["STEAM_0:0:784230162"] = true
}
hook.Add("CanOutfit", "SkinWorkshop", function(pl, mdl, wsid)
    if tbl[pl:SteamID()] then return true end
    if CAMI.PlayerHasAccess(pl, "ukrp_outfitter") then return true end

    return false
end)
--PATH addons/__________scripts__loader/lua/scriptssss/permalist/cl_permalist.lua:
net.Receive( 'Permalist', function()
    local mywhitelist = net.ReadTable()
    local DF = vgui.Create( 'onyx.Frame' )
    DF:SetSize( 450, 305 )
    DF:Center()
    DF:SetTitle( 'PermaList' )
    DF:MakePopup()
    local DL = vgui.Create( 'DListView', DF )
    DL:SetMultiSelect( false )
    DL:SetPos( 5, 50 )
    DL:SetSize( 150, 245 )
    DL:AddColumn( 'SteamID' )
    for k in pairs( mywhitelist ) do
        DL:AddLine( k )
    end

    DL.DoDoubleClick = function( _, _, line )
        chat.AddText( Color( 0, 255, 0 ), 'SteamID, який ви видалили з permalist, було надруковано на вашій консолі.' )
        local removeid = line:GetValue( 1 )
        print( '\nВи видалили цей SteamID з permalist: ' .. removeid .. '\n' )
        mywhitelist[removeid] = nil
        DL:Clear()
        for k in pairs( mywhitelist ) do
            DL:AddLine( k )
        end

        net.Start( 'RemovePermaList' )
        net.WriteString( removeid )
        net.SendToServer()
    end

    local AddIDTxt = vgui.Create( 'onyx.TextEntry', DF )
    AddIDTxt:SetPos( 162, 55 )
    AddIDTxt:SetSize( 276, 25 )
    AddIDTxt:SetPlaceholderText( 'Введіть SteamID, щоб додати' )
    local AddIDBtn = vgui.Create( 'onyx.Button', DF )
    AddIDBtn:SetPos( 162, 85 )
    AddIDBtn:SetText( 'Додати SteamID' )
    AddIDBtn:SetSize( 276, 25 )
    AddIDBtn.DoClick = function()
        local addid = AddIDTxt:GetValue()
        mywhitelist[addid] = true
        DL:Clear()
        for k in pairs( mywhitelist ) do
            DL:AddLine( k )
        end

        chat.AddText( Color( 0, 255, 0 ), 'SteamID, який ви додали до permalist, було надруковано на вашій консолі.' )
        print( '\nВи додали цей SteamID до permalist: ' .. addid .. '\n' )
        net.Start( 'AddPermaList' )
        net.WriteString( addid )
        net.SendToServer()
        AddIDTxt:SetText( '' )
    end

    local CheckIDTxt = vgui.Create( 'onyx.TextEntry', DF )
    CheckIDTxt:SetPos( 162, 135 )
    CheckIDTxt:SetSize( 276, 25 )
    CheckIDTxt:SetPlaceholderText( 'Введіть SteamID для перевірки' )
    local CheckIDBtn = vgui.Create( 'onyx.Button', DF )
    CheckIDBtn:SetPos( 162, 165 )
    CheckIDBtn:SetText( 'Перевірте SteamID' )
    CheckIDBtn:SetSize( 276, 25 )
    CheckIDBtn.DoClick = function()
        local checkid = CheckIDTxt:GetValue()
        if mywhitelist[checkid] then
            Derma_Message( '\'' .. checkid .. '\' знаходиться у permalist!', 'Permalist SteamID Checker', 'Гаразд' )
        else
            Derma_Message( '\'' .. checkid .. '\' НЕ в permalist!', 'Permalist SteamID Checker', 'Гаразд' )
        end
    end

    local RemoveIDTxt = vgui.Create( 'onyx.TextEntry', DF )
    RemoveIDTxt:SetPos( 162, 215 )
    RemoveIDTxt:SetSize( 276, 25 )
    RemoveIDTxt:SetPlaceholderText( 'Введіть SteamID для видалення' )
    local RemoveIDBtn = vgui.Create( 'onyx.Button', DF )
    RemoveIDBtn:SetPos( 162, 245 )
    RemoveIDBtn:SetText( 'Видалити SteamID' )
    RemoveIDBtn:SetSize( 276, 25 )
    RemoveIDBtn.DoClick = function()
        local txtremoveid = RemoveIDTxt:GetValue()
        if mywhitelist[txtremoveid] then
            mywhitelist[txtremoveid] = nil
            DL:Clear()
            for k in pairs( mywhitelist ) do
                DL:AddLine( k )
            end

            net.Start( 'RemovePermaList' )
            net.WriteString( txtremoveid )
            net.SendToServer()
        else
            Derma_Message( '\'' .. txtremoveid .. '\' НЕ в permalist!', 'Permalist SteamID Remove Error', 'Гаразд' )
        end
    end

    local idfinder = vgui.Create( 'onyx.Label', DF )
    idfinder:SetPos( 162, 275 )
    idfinder:SetText( 'steamid.xyz' )
    idfinder:SizeToContents()
end )
--PATH addons/__________scripts__loader/lua/scriptssss/fix_doors/cl_fixdoors.lua:
local DOORS = {
    ['prop_door_rotating'] = true,
    ['func_door_rotating'] = true,
    ['func_door'] = true,
}

local OWNABLE = 1
local UNOWNABLE = 2
local GROUPOWNABLE = 3
--
local color_text_tbl = {
    [OWNABLE] = {
        text = 'Можно владеть',
        color = Color( 91, 202, 0 ),
    },
    [UNOWNABLE] = {
        text = 'Нельзя владеть',
        color = Color( 114, 0, 0 ),
    },
    [GROUPOWNABLE] = {
        text = 'Владеет %s',
        color = Color( 161, 145, 0 ),
    },
}

local tbldoors = {}
local function activeDoorsFunc( bool )
    if not bool then
        hook.Remove( 'PostDrawTranslucentRenderables', 'RenderDoors' )
        return
    end

    hook.Add( 'PostDrawTranslucentRenderables', 'RenderDoors', function()
        local ply = LocalPlayer()
        for _, v in ents.Iterator() do
            if v:IsDoor() and DOORS[v:GetClass()] then
                local index = v:EntIndex()
                local check = tbldoors[index]
                local pos = v:LocalToWorld( v:OBBCenter() ) + Vector( 0, 0, 16 )
                local ang = Angle( 0, ply:EyeAngles().y - 90, 90 )
                cam.Start3D2D( pos, ang, 1 )
                cam.IgnoreZ( true )
                draw.SimpleText( index, 'ChatFont', 0, 0, color_white, 1, 1 )
                if check then
                    if istable( check ) then
                        local tt = color_text_tbl[check[2]]
                        draw.SimpleText( Format( tt.text, check[1] ), 'ChatFont', 0, 30, tt.color, 1, 1 )
                    else
                        local tt = color_text_tbl[check]
                        draw.SimpleText( tt.text, 'ChatFont', 0, 30, tt.color, 1, 1 )
                    end
                end

                cam.IgnoreZ( false )
                cam.End3D2D()
            end
        end
    end )
end

local function addpanel( id )
    local type = 1
    local name = ''
    local DF = vgui.Create( 'onyx.Frame' )
    DF:SetSize( 300, 150 )
    DF:Center()
    DF:SetTitle( 'Add door #' .. id )
    DF:MakePopup()
    --
    local DComboBox = vgui.Create( 'onyx.ComboBox', DF )
    DComboBox:Dock( TOP )
    DComboBox:AddOption( 'Можно владеть', OWNABLE, true )
    DComboBox:AddOption( 'Нельзя владеть', UNOWNABLE )
    DComboBox:AddOption( 'Владеет организация', GROUPOWNABLE )
    DComboBox.OnSelect = function( _, _, _, data )
        type = data
        DF.DComboBox2:Clear()
        if data == GROUPOWNABLE then
            for k in pairs( rp.teamDoors ) do
                DF.DComboBox2:AddOption( k, k )
            end
        end
    end

    DF.DComboBox2 = vgui.Create( 'onyx.ComboBox', DF )
    DF.DComboBox2:Dock( TOP )
    DF.DComboBox2.OnSelect = function( _, _, _, data ) name = data end
    --
    local btn1 = vgui.Create( 'onyx.Button', DF )
    btn1:Dock( TOP )
    btn1:SetText( 'Добавить' )
    btn1.DoClick = function()
        local trace = LocalPlayer():GetEyeTrace()
        local ent = trace.Entity
        if ent then
            net.Start( 'AddFixDoor' )
            net.WriteUInt( id, 11 )
            net.WriteUInt( type, 2 )
            net.WriteString( name )
            net.SendToServer()
            DF:Remove()
        end
    end
end

local activedoors = false
net.Receive( 'FixDoors', function()
    local DF = vgui.Create( 'onyx.Frame' )
    DF:SetSize( 300, 200 )
    DF:Center()
    DF:SetTitle( 'FixDoors' )
    DF:MakePopup()
    --
    local btnactive = vgui.Create( 'onyx.TogglerLabel', DF )
    btnactive:Dock( TOP )
    btnactive:SetText( 'Видеть все двери' )
    btnactive:SetValue( activedoors )
    btnactive.OnChange = function( _, val )
        if val then
            activedoors = true
        else
            activedoors = false
        end

        activeDoorsFunc( activedoors )
    end

    local btn1 = vgui.Create( 'onyx.Button', DF )
    btn1:Dock( TOP )
    btn1:SetText( 'Добавить дверь перед тобой' )
    btn1.DoClick = function()
        local trace = LocalPlayer():GetEyeTrace()
        local ent = trace.Entity
        if ent then addpanel( ent:EntIndex() ) end
    end

    local btn2 = vgui.Create( 'onyx.Button', DF )
    btn2:Dock( TOP )
    btn2:SetText( 'Удалить дверь перед тобой' )
    btn2.DoClick = function()
        local trace = LocalPlayer():GetEyeTrace()
        local ent = trace.Entity
        if ent then
            net.Start( 'RemoveFixDoor' )
            net.WriteUInt( ent:EntIndex(), 11 )
            net.SendToServer()
        end
    end

    local btn3 = vgui.Create( 'onyx.Button', DF )
    btn3:Dock( TOP )
    btn3:SetText( 'Получить данные дверей' )
    btn3.DoClick = function()
        net.Start( 'GiveDataFixDoor' )
        net.SendToServer()
    end

    local btn4 = vgui.Create( 'onyx.Button', DF )
    btn4:Dock( TOP )
    btn4:SetText( 'Запустить фикс дверей' )
    btn4.DoClick = function()
        net.Start( 'FixDoorStart' )
        net.SendToServer()
    end
end )

net.Receive( 'GiveDataFixDoor', function() tbldoors = onyx.net.ReadTable() end )
--PATH addons/__________scripts__loader/lua/scriptssss/boards/cl_boards.lua:
BOARDS = {}
BOARDS.Rules = {
	['rp_bangclaw'] = {
		'2.1 – FearRP (FRP) – страх за своє життя. Ви повинні дбати про життя свого',
		'персонажа. Якщо ви під прицілом вам заборонено діставати зброю,',
		'тікати або чинити опір.',
		'',
		'2.2 – Non-RP (NRP) – дії які не можна порівняти з професією вашого персонажа',
		'або не можна порівняти з життєвими ситуаціями.',
		'',
		'2.3 – NLR – правило нового життя. Після смерті ви не пам\'ятаєте, хто вас убив',
		'та де вас убили. Ви пам\'ятаєте своє ім\'я, дім, друзів.',
		'Додаток:',
		'➤ Заборонено повертатися на місце своєї смерті протягом 5 хвилин та до',
		'закінчення РП ситуації (рейд, пограбування тощо).',
		'',
		'2.24 – FreeKill (FK) – вбивство без раціональної РП-причини.',
		'Доповнення: Образа і Помста не є причиною для вбивства.',
		'',
		'6.1. Максимальна сума пограбування на одного кримінала 5000$.',
		'Додаток: Під час пограбування ви можете отримати тільки 5000$ на одного',
		'озброєного грабіжника за одну пограбовану людину.',
		'(Максимальна сума пограбування - 25000$).',
		'',
		'6.7. КД рейду/пограбування людини/будівлі - 15 хвилин.',
		'6.8. Забороняється рейд мерії, якщо з моменту появи нового мера не пройшло',
		'5 хвилин, також якщо новий мер з’явився під час рейду,',
		'його забороняється вбивати.',
		'',
		'6.11. Рейд триває максимум 10 хвилин.'
	},
	['rp_downtown_tits_v25'] = {
		'[2.1] NonRP (NRP)',
		'➤ Дії які не можна порівняти з професією вашого персонажа або не можна',
		'порівняти з життєвими ситуаціями.',
		'',
		'[2.2] FearRP (FRP)',
		'➤ Cтрах за своє життя. Ви повинні дбати про життя свого персонажа.',
		'Якщо ви під прицілом вам заборонено діставати зброю, тікати, чинити опір.',
		'',
		'[2.5] NLR',
		'➤ Правило нового життя. Після смерті ви не пам\'ятаєте, хто вас убив та',
		'де вас убили. Ви пам\'ятаєте своє ім\'я, дім, друзів.',
		'',
		'[2.16] MetaGaming (MG)',
		'➤ Забороняється використовувати інформацію зовнішнього світу для',
		'переваги над іншими гравцями.',
		'',
		'Кримінал:',
		'* Під час пограбування ви можете отримати тільки 5000$ на одного',
		'озброєного грабіжника. (Максимальна сума пограбування - 50000 $).',
		'	** Максимальна кількість гравців, яких один кримінал може пограбувати',
		'	одночасно, - двоє. З кожним напарником можна пограбувати ще одного.',
		'* КД рейду/пограбування людини/будівлі - 10 хвилин. Рейд триває максимум',
		'15 хвилин.',
		'* Зламувати будівлі та квартири дозволяється тільки від 2 членів банди.'
	},
}

local renderDistance = 1024 ^ 2
hook.Add( 'PlayerBindPress', 'ArieBoardCheck', function( ply, bind )
	local ent = ply:GetEyeTrace().Entity
	if bind == '+use' and IsValid( ent ) and ent:GetClass() == 'arierules' and LocalPlayer():GetPos():DistToSqr( ent:GetPos() ) < renderDistance then gui.OpenURL( rp.Setting.Links['Правила'] ) end
end )
--PATH addons/__main/lua/autorun/athenaratplayermodel.lua:
player_manager.AddValidModel( "Funny Rat", "models/player/funnyrat/rat.mdl" )
list.Set( "PlayerOptionsModel", "Funny Rat", "models/player/funnyrat/rat.mdl" )

player_manager.AddValidHands( "Funny Rat", "models/player/funnyrat/ratarms.mdl", 0, "00000000" )
--PATH addons/_ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )
--------------------- BALLISTIC SHIELDS V1.1.9 -------------------------
---- CONFIG ----
-- AVALAIBLE LANGUAGES - English, German, French, Danish, Turkish, Ukrainian
bshields.config.language = "Ukrainian"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 10
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 10
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 50
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 20
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 30
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 1
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = true
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false
-- REMOVE DEPLOYED SHIELDS ON JOB CHANGE
bshields.config.removeonjobchange = true
-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---
-- HEAVY SHIELD
bshields.config.hShieldTexture = ""
-- RIOT SHIELD
bshields.config.rShieldTexture = ""
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = ""
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---
-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = false
--PATH addons/_ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}
bshields.shields = {
	{
		[1] = {
			["angles"] = Angle( 4, 6, -14 ),
			["position"] = Vector( 0, 8, -1 )
		},
		[2] = {
			["angles"] = Angle( 6, 6, -12 ),
			["position"] = Vector( 8, 10, -4 )
		},
		[3] = {
			["angles"] = Angle( -3, 7, -16 ),
			["position"] = Vector( -1, 4, -3 )
		}
	},
	{
		[1] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 6, -4, -8 )
		},
		[2] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 16, -3, -12 )
		},
		[3] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 6, -3, -12 )
		}
	},
	{
		[1] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -7, -13 )
		},
		[2] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -6, -22 )
		},
		[3] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -8, -12 )
		}
	}
}
--PATH addons/_________report_system/lua/cats/client.lua:
surface.CreateFont( 'cats.small', {
    font = 'RobotoBold',
    extended = true,
    size = 16,
    weight = 500,
} )

surface.CreateFont( 'cats.xlarge', {
    font = 'Roboto Bold',
    extended = true,
    size = 48,
    weight = 500,
} )

surface.CreateFont( 'cats.large', {
    font = 'Roboto Bold',
    extended = true,
    size = 36,
    weight = 500,
} )

surface.CreateFont( 'cats.medium', {
    font = 'Roboto Bold',
    extended = true,
    size = 24,
    weight = 500,
} )

local c
local function n( t, e, a )
    local e = c[e]
    if not e then
        e = {
            tooltip = 'error',
            icon = Material( 'icon16/error.png' ),
            click = function() end
        }
    end

    t:SetTooltip( e.tooltip )
    t.icon = e.icon
    t.DoClick = function( t ) e.click( t, a ) end
end

local function r( e )
    local n, a, t
    n = math.floor( e / 60 / 60 )
    a = math.floor( e / 60 ) % 60
    t = math.floor( e ) % 60
    return string.format( '%02i:%02i:%02i', n, a, t )
end

function drawCircle( n, o, e, t )
    local a = {}
    table.insert( a, {
        x = n,
        y = o,
        u = .5,
        v = .5
    } )

    for c = 0, t do
        local t = math.rad( c / t * -360 )
        table.insert( a, {
            x = n + math.sin( t ) * e,
            y = o + math.cos( t ) * e,
            u = math.sin( t ) * 0.5 + .5,
            v = math.cos( t ) * 0.5 + .5
        } )
    end

    local t = math.rad( 0 )
    table.insert( a, {
        x = n + math.sin( t ) * e,
        y = o + math.cos( t ) * e,
        u = math.sin( t ) * 0.5 + .5,
        v = math.cos( t ) * 0.5 + .5
    } )

    surface.DrawPoly( a )
end

local a = {
    action_claim = Material( 'icon16/accept.png' ),
    action_unclaim = Material( 'icon16/delete.png' ),
    actions = Material( 'icon16/wand.png' ),
    action_callon = Material( 'icon16/lightbulb_off.png' ),
    action_calloff = Material( 'icon16/lightbulb.png' ),
    action_close = Material( 'icon16/report_delete.png' ),
    noStar = Material( 'icon16/bullet_white.png' ),
    star = Material( 'icon16/star.png' ),
}

c = {
    action_claim = {
        tooltip = cats.lang.action_claim,
        icon = a.action_claim,
        click = function( t, e )
            net.Start( 'cats.claimTicket' )
            net.WriteString( e:SteamID() )
            net.WriteBool( true )
            net.SendToServer()
            n( t, 'action_unclaim', e )
        end
    },
    action_unclaim = {
        tooltip = cats.lang.action_unclaim,
        icon = a.action_unclaim,
        click = function( t, e )
            net.Start( 'cats.claimTicket' )
            net.WriteString( e:SteamID() )
            net.WriteBool( false )
            net.SendToServer()
            n( t, 'action_claim', e )
        end
    },
    actions = {
        tooltip = cats.lang.actions,
        icon = a.actions,
        click = function( e, a )
            local e = DermaMenu()
            for n, t in ipairs( cats.config.commands ) do
                e:AddOption( t.text, function() t.click( a ) end ):SetIcon( 'icon16/' .. ( t.icon or 'wand' ) .. '.png' )
            end

            e:SetPos( input.GetCursorPos() )
            e:Open()
        end
    },
    action_callon = {
        tooltip = cats.lang.action_callon,
        icon = a.action_callon,
        click = function( t, e ) n( t, 'action_calloff', e ) end
    },
    action_calloff = {
        tooltip = cats.lang.action_calloff,
        icon = a.action_calloff,
        click = function( e, t ) n( e, 'action_callon', t ) end
    },
    action_close = {
        tooltip = cats.lang.action_close,
        icon = a.action_close,
        click = function( t, e )
            net.Start( 'cats.closeTicket' )
            net.WriteString( e:SteamID() )
            net.SendToServer()
        end
    },
}

local l = { 'action_claim', 'actions', 'action_close', }
local e = {
    user = LocalPlayer(),
    userID = 'STEAM_X:X:XXXXXXXX',
    admin = LocalPlayer(),
    adminID = 'STEAM_X:X:XXXXXXXX',
    chatLog = { { 'Зюзя', 'Админ тп, застрял', false }, { 'СуперВася', 'Ща, погоди', true }, { 'Зюзя', 'Ну где вы???', false }, { 'УберПетя', 'Бля, Вася, да вытащи ты его уже, наконец, он заебал вопить, как малое дите, сука, ебаный в рот', true }, { 'СуперВася', 'Ну ща-ща, я дорешаю жалобу', true }, { 'УберПетя', 'Да с хера ли ты берешь столько жалоб? Разберись сначала с одной, потом уж на другие иди', true }, { 'СуперВася', 'Да хорошо, блять, но дай сейчас-то разберусь', true }, { 'Зюзя', 'Идите оба нахуй, я выбрался уже', false }, }
}

local t
local function i( c )
    surface.PlaySound( cats.config.newTicketSound )
    local e = cats.ticketContainer:Add( 'DButton' )
    e:SetSize( cats.config.spawnSize[1], 180 )
    e:SetText( '' )
    e.expanded = true
    e.ticket = c
    e.Paint = function( n, t, a )
        local c, o = n.ticket.user, n.ticket.admin
        surface.SetDrawColor( 30, 40, 50, 220 )
        surface.DrawRect( 0, 0, t, a )
        if n.Hovered then
            surface.SetDrawColor( 255, 255, 255, 2 )
            surface.DrawRect( 0, 0, t, a )
        end

        surface.SetDrawColor( 0, 0, 0, 255 )
        surface.DrawLine( 0, -1, 0, a )
        surface.DrawLine( -1, a - 1, t, a - 1 )
        surface.DrawLine( t - 1, a, t - 1, -1 )
        local valid = IsValid( c )
        local a = '(' .. os.date( '%M:%S', CurTime() - n.ticket.created ) .. ')'
        local n = valid and c:Name() or cats.lang.userDisconnected
        local c = '★' .. math.Round( valid and c:GetNWFloat( 'cats_averageRating' ) or 0, 1 )
        draw.SimpleText( a .. '' .. c .. '' .. n, 'cats.small', 8, 15, Color( 220, 220, 220 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
        if IsValid( o ) then
            local e = '★' .. math.Round( o:GetNWFloat( 'cats_adminRating' ), 1 )
            draw.SimpleText( e .. '' .. o:Name(), 'cats.small', t - 8, 15, Color( 180, 200, 240 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
        end
    end

    e.DoClick = function( t )
        t.expanded = not t.expanded
        for t, e in ipairs( cats.ticketContainer:GetChildren() ) do
            e:InvalidateLayout( true )
        end

        cats.ticketContainer:Layout()
        timer.Simple( 0, function() t.chatLog:GotoTextEnd() end )
    end

    e.PerformLayout = function( e )
        e:SetSize( e:GetParent():GetWide(), e.expanded and 180 or 30 )
        e.controls:SetVisible( e.expanded )
    end

    local t = vgui.Create( 'DPanel', e )
    t:DockMargin( 1, 1, 1, 1 )
    t:Dock( BOTTOM )
    t:SetTall( 150 )
    t.Paint = function() end
    e.controls = t
    e.controls.buttons = {}
    for o, a in pairs( l ) do
        local t = vgui.Create( 'DButton', t )
        t:SetSize( 30, 30 )
        t:SetPos( 0, ( o - 1 ) * 30 )
        t:SetText( '' )
        t.Paint = function( e, a, t )
            if e.Hovered then draw.RoundedBox( 0, 0, 0, a, t, Color( 255, 255, 255, 2 ) ) end
            surface.SetMaterial( e.icon )
            surface.SetDrawColor( 255, 255, 255 )
            surface.DrawTexturedRect( 7, 7, 16, 16 )
        end

        n( t, a, e.ticket.user )
        e.controls.buttons[a] = t
    end

    local a = vgui.Create( 'DPanel', e.controls )
    a:Dock( FILL )
    a:DockMargin( 30, 0, 0, 0 )
    a.Paint = function( n, a, t )
        surface.SetDrawColor( 0, 0, 0, 100 )
        surface.DrawRect( 0, 0, a, t - 20 )
        surface.SetDrawColor( 0, 0, 0, 255 )
        surface.DrawLine( 0, t, 0, 0 )
        surface.DrawLine( -1, 0, a, 0 )
        surface.DrawLine( -1, t - 21, a, t - 21 )
    end

    e.chat = a
    local t = vgui.Create( 'DButton', e.chat )
    t:Dock( BOTTOM )
    t:SetText( '' )
    t:SetTall( 20 )
    t:SetCursor( 'beam' )
    t.Paint = function( e, n, a )
        if e.Hovered then draw.RoundedBox( 0, 0, 0, n, a, Color( 255, 255, 255, 1 ) ) end
        draw.SimpleText( cats.lang.sendMessage, 'cats.small', 8, 10, Color( 220, 220, 220, 50 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
    end

    t.DoClick = function( e )
        Derma_StringRequest( cats.lang.sendMessage, cats.lang.typeYourMessage, '', function( e )
            net.Start( 'cats.dispatchMessage' )
            net.WriteString( c.userID )
            net.WriteString( e )
            net.SendToServer()
        end, function() end, cats.lang.ok, cats.lang.cancel )
    end

    local a = vgui.Create( 'RichText', e.chat )
    a:Dock( FILL )
    a.Paint = function( t )
        t.m_FontName = 'cats.small'
        t:SetFontInternal( 'cats.small' )
        t:SetBGColor( Color( 0, 0, 0, 0 ) )
        t.Paint = nil
    end

    e.chatLog = a
    cats.ticketContainer[c.userID] = e
    cats.ticketFrame:PerformLayout()
end

local function c( e, a, n, t )
    local e = cats.ticketContainer[e].chatLog
    if not IsValid( e ) then return end
    if t then
        e:InsertColorChange( 50, 120, 180, 255 )
    else
        e:InsertColorChange( 180, 160, 50, 255 )
    end

    e:AppendText( '\n' .. a )
    e:InsertColorChange( 220, 220, 220, 255 )
    e:AppendText( ':' .. n )
end

hook.Add( 'Think', 'cats', function()
    if IsValid( cats.ticketFrame ) then cats.ticketFrame:Remove() end
    local t, a = cats.config.spawnSize[1], cats.config.spawnSize[2]
    local n, o = cats.config.spawnPosAdmin[1], cats.config.spawnPosAdmin[2]
    local e = vgui.Create( 'DFrame' )
    e:SetSize( t, a )
    e:SetPos( n, o )
    e:DockPadding( 0, 24, 0, 0 )
    e:SetTitle( '' )
    e:ShowCloseButton( false )
    cats.ticketFrame = e
    local t = vgui.Create( 'DScrollPanel', e )
    t:Dock( FILL )
    local a = t.PerformLayout
    t.PerformLayout = function( e )
        a( e )
        for t, e in ipairs( cats.ticketContainer:GetChildren() ) do
            e:InvalidateLayout()
        end
    end

    local t = vgui.Create( 'DIconLayout', t )
    t:Dock( FILL )
    t:SetSpaceX( 0 )
    t:SetSpaceY( 0 )
    cats.ticketContainer = t
    local n = e.PerformLayout
    e.PerformLayout = function( a )
        n( a )
        a:SetTall( math.min( t:GetTall(), ScrH() - 100, 600 ) + 27 )
        a:SetVisible( #t:GetChildren() > 0 )
    end

    e.Paint = function( a, e, a )
        surface.SetDrawColor( 30, 40, 50, 255 )
        surface.DrawRect( 0, 0, e, 24 )
        surface.SetDrawColor( 0, 0, 0, 255 )
        surface.DrawOutlinedRect( 0, 0, e, 24 )
        draw.SimpleText( cats.lang.openTickets .. '(' .. #t:GetChildren() .. ')', 'cats.small', 8, 12, Color( 220, 220, 220 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
    end

    hook.Remove( 'Think', 'cats' )
end )

if IsValid( cats.myTicketFrame ) then cats.myTicketFrame:Remove() end
local function d( e )
    surface.PlaySound( cats.config.newTicketSound )
    t = e
    local c, e = cats.config.spawnSize[1], cats.config.spawnSize[2]
    local o, n = cats.config.spawnPosUser[1], cats.config.spawnPosUser[2]
    local e = vgui.Create( 'DFrame' )
    e:ShowCloseButton( false )
    e:SetSize( c, 220 )
    e:SetPos( o, n )
    e:DockPadding( 0, 30, 0, 0 )
    e:SetTitle( '' )
    e.ticket = t
    e.Paint = function( e, a, n )
        local o, t = e.ticket.user, e.ticket.admin
        surface.SetDrawColor( 30, 40, 50, 220 )
        surface.DrawRect( 0, 0, a, n )
        surface.SetDrawColor( 0, 0, 0, 255 )
        surface.DrawOutlinedRect( 0, 0, a, n )
        local e = '(' .. os.date( '%M:%S', CurTime() - e.ticket.created ) .. ')'
        draw.SimpleText( e .. '' .. cats.lang.myTicket, 'cats.small', 8, 15, Color( 220, 220, 220 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
        if IsValid( t ) then
            local e = '★' .. math.Round( t:GetNWFloat( 'cats_adminRating' ), 1 )
            draw.SimpleText( e .. '' .. t:Name(), 'cats.small', a - 8, 15, Color( 180, 200, 240 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
        end
    end

    surface.SetFont( 'cats.small' )
    local o, n = surface.GetTextSize( cats.lang.action_close )
    local n = vgui.Create( 'DButton', e )
    n:SetText( '' )
    n:SetSize( o + 16, 30 )
    n:AlignRight( 1 )
    n.Paint = function( a, e, t )
        if a.Hovered then draw.RoundedBox( 0, 0, 0, e, t, Color( 255, 255, 255, 1 ) ) end
        draw.SimpleText( cats.lang.action_close, 'cats.small', e * 0.5, t * 0.5, Color( 220, 220, 220 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    end

    n.DoClick = function( t )
        net.Start( 'cats.closeTicket' )
        net.WriteString( LocalPlayer():SteamID() )
        net.SendToServer()
    end

    e.closeBut = n
    local n = vgui.Create( 'DPanel', e )
    n:Dock( FILL )
    n.Paint = function( n, a, t )
        surface.SetDrawColor( 0, 0, 0, 100 )
        surface.DrawRect( 0, 0, a, t - 20 )
        surface.SetDrawColor( 0, 0, 0, 255 )
        surface.DrawLine( 0, t, 0, 0 )
        surface.DrawLine( -1, 0, a, 0 )
        surface.DrawLine( -1, t - 21, a, t - 21 )
    end

    e.chat = n
    local o = vgui.Create( 'DButton', e.chat )
    o:Dock( BOTTOM )
    o:SetText( '' )
    o:SetTall( 20 )
    o:SetCursor( 'beam' )
    o.Paint = function( t, a, e )
        if t.Hovered then draw.RoundedBox( 0, 0, 0, a, e, Color( 255, 255, 255, 1 ) ) end
        draw.SimpleText( cats.lang.sendMessage, 'cats.small', 8, 10, Color( 220, 220, 220, 50 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
    end

    o.DoClick = function( e )
        Derma_StringRequest( cats.lang.sendMessage, cats.lang.typeYourMessage, '', function( e )
            net.Start( 'cats.dispatchMessage' )
            net.WriteString( LocalPlayer():SteamID() )
            net.WriteString( e )
            net.SendToServer()
        end, function() end, cats.lang.ok, cats.lang.cancel )
    end

    local o = vgui.Create( 'RichText', e.chat )
    o:Dock( FILL )
    o.Paint = function( t )
        t.m_FontName = 'cats.small'
        t:SetFontInternal( 'cats.small' )
        t:SetBGColor( Color( 0, 0, 0, 0 ) )
        t.Paint = nil
    end

    e.chatLog = o
    e.SwitchToRating = function( e )
        n:Clear()
        n.Paint = function() end
        local e = vgui.Create( 'DButton', n )
        e:DockPadding( 1, 0, 1, 1 )
        e:SetTall( 30 )
        e:Dock( BOTTOM )
        e:SetText( '' )
        e:SetEnabled( false )
        e.Paint = function( t, n, a )
            if t:IsEnabled() then
                if t.Hovered then draw.RoundedBox( 0, 0, 0, n, a, Color( 255, 255, 255, 2 ) ) end
                draw.SimpleText( cats.lang.ok, 'cats.small', n * 0.5, a * 0.5, Color( 220, 220, 220 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            end

            surface.SetDrawColor( 0, 0, 0, 255 )
        end

        e.DoClick = function( e )
            net.Start( 'cats.setRating' )
            net.WriteUInt( math.Clamp( t.rating or cats.config.defaultRating, 1, 5 ), 8 )
            net.SendToServer()
            cats.myTicketFrame:Remove()
            t = nil
        end

        local n = vgui.Create( 'DPanel', n )
        n:Dock( FILL )
        n.Paint = function( a, e, t )
            draw.SimpleText( cats.lang.rateAdmin, 'cats.small', e * 0.5, t * 0.5 - 24, Color( 220, 220, 220 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            draw.RoundedBox( 0, 0, 0, e, t, Color( 0, 0, 0, 100 ) )
            surface.DrawLine( -1, 0, e, 0 )
            surface.DrawLine( -1, t, e, t )
        end

        for o = 1, 5 do
            local l = o - 3
            local n = vgui.Create( 'DButton', n )
            n:SetText( '' )
            n:SetSize( 64, 64 )
            n:SetPos( c * 0.5 + l * 64 - 32, 160 * 0.5 - 18 )
            n.Paint = function( e, c, c )
                if e.Hovered then draw.RoundedBox( 0, 8, 8, 48, 48, Color( 255, 255, 255, 2 ) ) end
                if not t.rating then
                    surface.SetDrawColor( 255, 255, 255, 20 )
                    surface.SetMaterial( a.star )
                    surface.DrawTexturedRect( 16, 16, 32, 32 )
                elseif t.rating and o <= t.rating then
                    surface.SetDrawColor( 255, 255, 255 )
                    surface.SetMaterial( a.star )
                    surface.DrawTexturedRect( 16, 16, 32, 32 )
                else
                    surface.SetDrawColor( 255, 255, 255 )
                    surface.SetMaterial( a.noStar )
                    surface.DrawTexturedRect( 24, 24, 16, 16 )
                end
            end

            n.DoClick = function( a )
                e:SetEnabled( true )
                t.rating = o
            end
        end
    end

    cats.myTicketFrame = e
end

local function l( a, t, n )
    local e = cats.myTicketFrame.chatLog
    if not IsValid( e ) then return end
    if n then
        e:InsertColorChange( 50, 120, 180, 255 )
    else
        e:InsertColorChange( 180, 160, 50, 255 )
    end

    e:AppendText( '\n' .. a )
    e:InsertColorChange( 220, 220, 220, 255 )
    e:AppendText( ':' .. t )
end

net.Receive( 'cats.dispatchMessage', function( e )
    local e = net.ReadString()
    local a = net.ReadEntity()
    local o = net.ReadString()
    local n = cats.config.getPlayerName( a )
    if not IsValid( a ) then return end
    if e == LocalPlayer():SteamID() then
        if t then
            l( n, o, a:SteamID() ~= LocalPlayer():SteamID() )
        else
            d( {
                created = CurTime()
            } )

            l( n, o, a:SteamID() ~= LocalPlayer():SteamID() )
        end
    elseif IsValid( cats.ticketContainer[e] ) then
        c( e, n, o, a:SteamID() ~= e )
    else
        local t = player.GetBySteamID( e )
        if not IsValid( t ) then return end
        i( {
            user = t,
            userID = e,
            created = CurTime(),
        } )

        c( e, n, o, a:SteamID() ~= e )
    end
end )

net.Receive( 'cats.claimTicket', function( e )
    local o = net.ReadString()
    local a = net.ReadEntity()
    local e = net.ReadBool()
    if not IsValid( a ) then return end
    if o == LocalPlayer():SteamID() and t then
        t.admin = e and a or nil
        t.adminID = e and a:SteamID() or nil
        cats.myTicketFrame.closeBut:SetVisible( not e )
    elseif IsValid( cats.ticketContainer[o] ) then
        local t = cats.ticketContainer[o].ticket
        t.admin = e and a or nil
        t.adminID = e and a:SteamID() or nil
        if t.adminID ~= LocalPlayer():SteamID() then
            local a = cats.ticketContainer[o].controls.buttons['action_claim']
            if e then
                n( a, 'action_unclaim', t.user )
                a:SetEnabled( false )
            else
                n( a, 'action_claim', t.user )
                a:SetEnabled( true )
            end
        end
    end
end )

net.Receive( 'cats.closeTicket', function( e )
    local e = net.ReadString()
    if e == LocalPlayer():SteamID() and t then
        if IsValid( t.admin ) then
            cats.myTicketFrame:SwitchToRating()
        else
            cats.myTicketFrame:Remove()
            t = nil
        end
    elseif IsValid( cats.ticketContainer[e] ) then
        cats.ticketContainer[e].ticket = nil
        cats.ticketContainer[e]:Remove()
        cats.ticketFrame:PerformLayout()
    end
end )

net.Receive( 'cats.setRating', function( e )
    local e = net.ReadString()
    local t = net.ReadUInt( 8 )
    if e == LocalPlayer():SteamID() then cats.myTicketFrame:Remove() end
end )

net.Receive( 'cats.syncTickets', function( e )
    local e = net.ReadTable()
    for t, e in pairs( e ) do
        local a = player.GetBySteamID( t )
        if IsValid( a ) then
            i( {
                user = a,
                userID = t,
                created = e.createdGameTime,
                admin = e.admin,
                adminID = e.adminID
            } )

            if IsValid( e.admin ) then
                local t = cats.ticketContainer[t].controls.buttons['action_claim']
                n( t, 'action_unclaim', e.user )
                t:SetEnabled( false )
            end

            for a, e in pairs( e.chatLog ) do
                c( t, e[1], e[2], e[3] )
            end
        end
    end
end )

local function a()
    surface.PlaySound( cats.config.newTicketSound )
    local e = vgui.Create( 'DFrame' )
    e:SetSize( 1024, 768 )
    e:SetTitle( 'CATS - Analytics' )
    e:Center()
    e:MakePopup()
    cats.analyticsFrame = e
    local t = vgui.Create( 'DListView', e )
    t:Dock( LEFT )
    t:SetWide( 160 )
    t:SetMultiSelect( false )
    t:AddColumn( 'Rating' ):SetFixedWidth( 50 )
    t:AddColumn( 'Admin' )
    t.OnRowSelected = function( t, t, a )
        e.pnl:Clear()
        local t = vgui.Create( 'DLabel', e.pnl )
        t:SetText( 'Loading...' )
        t:SizeToContents()
        t:Center()
        net.Start( 'cats.getAdminData' )
        net.WriteString( a.steamID )
        net.SendToServer()
    end

    e.list = t
    local t = vgui.Create( 'DScrollPanel', e )
    t:DockMargin( 5, 0, 0, 0 )
    t:Dock( FILL )
    e.pnl = t
    net.Start( 'cats.getAdminList' )
    net.SendToServer()
end

concommand.Add( 'cats_analytics', a )
net.Receive( 'cats.getAdminList', function()
    local e = net.ReadTable()
    for a, e in pairs( e ) do
        local t = '★' .. math.Round( e.ratingTotal, 2 )
        local e = cats.analyticsFrame.list:AddLine( t, e.lastNick )
        e.steamID = a
    end

    cats.analyticsFrame.list:SortByColumn( 1, true )
end )

net.Receive( 'cats.getAdminData', function()
    local e = net.ReadTable()
    if not IsValid( cats.analyticsFrame ) or not IsValid( cats.analyticsFrame.pnl ) then return end
    local a = cats.analyticsFrame.pnl
    a:Clear()
    local t = vgui.Create( 'DLabel', a )
    t:DockMargin( 20, 10, 20, 0 )
    t:Dock( TOP )
    t:SetTall( 50 )
    t:SetFont( 'cats.xlarge' )
    t:SetText( e.lastNick )
    local t = vgui.Create( 'DLabel', a )
    t:DockMargin( 20, 5, 20, 0 )
    t:Dock( TOP )
    t:SetTall( 20 )
    t:SetFont( 'cats.medium' )
    t:SetText( e.steamID )
    t:SetToolTip( 'Click to copy SteamID' )
    t.DoClick = function( t ) SetClipboardText( e.steamID ) end
    local n = { { 'РЕЙТИНГ', '★' .. math.Round( e.ratingTotal, 2 ) }, { 'ЖАЛОБЫ', e.claimsTotal }, { 'ПОЛЬЗОВАТЕЛИ', e.uniqueUsers }, { 'В НЕДЕЛЮ', math.Round( e.claimsTotal / ( e.updateTime - e.createdTime ) * 604800 ) }, { 'ВРЕМЯ ЖАЛОБ', r( e.ticketTimeTotal ) }, }
    if e.playTimeTotal then table.insert( n, { 'ВРЕМЯ ИГРЫ', r( e.playTimeTotal ) } ) end
    local t = vgui.Create( 'DIconLayout', a )
    t:DockMargin( 20, 20, 20, 0 )
    t:Dock( TOP )
    t:SetTall( 100 )
    for e, n in ipairs( n ) do
        local e = t:Add( 'DPanel' )
        e:SetSize( ( a.pnlCanvas:GetWide() - 40 ) / 3, 100 )
        e.Paint = function( o, t, a )
            draw.RoundedBox( 8, 5, 5, t - 10, a - 10, Color( 0, 0, 0, 60 ) )
            draw.SimpleText( n[1], 'cats.medium', t * 0.5, 30, Color( 220, 220, 220 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            draw.SimpleText( n[2], 'cats.xlarge', t * 0.5, 65, Color( 220, 220, 220 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end

        e.PerformLayout = function( e ) e:SetWide( ( a.pnlCanvas:GetWide() - 40 ) / 3 ) end
    end

    local t = vgui.Create( 'DLabel', a )
    t:DockMargin( 20, 20, 20, 5 )
    t:Dock( TOP )
    t:SetTall( 20 )
    t:SetFont( 'cats.medium' )
    t:SetText( 'Play time card' )
    local d, c, r = cats.lang.dow, cats.config.punchCardMode, cats.config.punchCardStart - 1
    local l = 1
    for t = 1, 7 do
        for a = 1, 24 do
            l = math.max( l, e.timeCard[t][a] )
        end
    end

    local n = vgui.Create( 'DPanel', a )
    n:DockMargin( 20, 10, 20, 0 )
    n:Dock( TOP )
    n:SetTall( 400 )
    n.Paint = function( t, e, a )
        draw.RoundedBox( 8, 0, 0, e, a, Color( 0, 0, 0, 60 ) )
        e, a = e - 55, a - 35
        local n, e = a / 7, e / 24
        draw.NoTexture()
        for e = 1, 7 do
            draw.SimpleText( d[e], 'cats.medium', 25, 30 + n * e - n * 0.5, Color( 220, 220, 220, 35 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end

        surface.SetDrawColor( 220, 220, 220, 4 )
        for o = 1, 24 do
            local t = o - r
            t = t > 0 and t or t + 24
            draw.SimpleText( o ~= 24 and o or 0, 'cats.small', 50 + e * ( t - 1 ) + e * 0.5, 20, Color( 220, 220, 220, 35 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            surface.SetDrawColor( 220, 220, 220, 4 )
            if c == 'dots' then
                surface.DrawLine( 50 + e * ( t - 1 ) + e * 0.5, 30 + n * 0.5, 50 + e * ( t - 1 ) + e * 0.5, 30 + a - n * 0.5 )
            elseif c == 'line' then
                surface.DrawLine( 50 + e * ( t - 1 ) + e * 0.5, 30, 50 + e * ( t - 1 ) + e * 0.5, 30 + a )
            end
        end
    end

    local t = vgui.Create( 'DPanel', n )
    t:DockMargin( 50, 30, 5, 5 )
    t:Dock( FILL )
    t.Paint = function( n, a, t )
        local o, a = t / 7, a / 24
        draw.NoTexture()
        for n = 1, 7 do
            for i = 1, 24 do
                local t = i - r
                t = t > 0 and t or t + 24
                if c == 'dots' then
                    local e = math.max( math.floor( ( a - 4 ) * e.timeCard[n][i] / l ), 2 )
                    local a, t = math.floor( a * ( t - 1 ) + a * 0.5 ), math.floor( o * n - o * 0.5 )
                    surface.SetDrawColor( 220, 220, 220 )
                    drawCircle( a, t, e * 0.5, math.max( e, 6 ) )
                elseif c == 'line' then
                    if t < 24 then
                        local i, c = a * ( t - 1 ) + a * 0.5, o * n - ( o - 16 ) * e.timeCard[n][i] / l - 8
                        local e, t = a * t + a * 0.5, o * n - ( o - 16 ) * e.timeCard[n][t + 1] / l - 8
                        surface.SetDrawColor( 220, 220, 220 )
                        surface.DrawLine( math.floor( i ), math.floor( c ), math.floor( e ), math.floor( t ) )
                    end
                else
                    local e = math.floor( math.floor( ( o - 8 ) * e.timeCard[n][i] / l ) )
                    draw.RoundedBoxEx( math.floor( math.min( e, 4 ) ), a * ( t - 1 ) + 3, math.floor( o * n - e ), a - 6, e, Color( 220, 220, 220 ), true, true, false, false )
                end
            end
        end
    end

    local t = vgui.Create( 'DLabel', a )
    t:DockMargin( 20, 20, 20, 5 )
    t:Dock( TOP )
    t:SetTall( 20 )
    t:SetFont( 'cats.medium' )
    t:SetText( 'Ticket claim card' )
    local l = 1
    for a = 1, 7 do
        for t = 1, 24 do
            l = math.max( l, e.claimCard[a][t] )
        end
    end

    local n = vgui.Create( 'DPanel', a )
    n:DockMargin( 20, 10, 20, 0 )
    n:Dock( TOP )
    n:SetTall( 400 )
    n.Paint = function( t, e, a )
        draw.RoundedBox( 8, 0, 0, e, a, Color( 0, 0, 0, 60 ) )
        e, a = e - 55, a - 35
        local n, e = a / 7, e / 24
        draw.NoTexture()
        for e = 1, 7 do
            draw.SimpleText( d[e], 'cats.medium', 25, 30 + n * e - n * 0.5, Color( 220, 220, 220, 35 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end

        surface.SetDrawColor( 220, 220, 220, 4 )
        for o = 1, 24 do
            local t = o - r
            t = t > 0 and t or t + 24
            draw.SimpleText( o ~= 24 and o or 0, 'cats.small', 50 + e * ( t - 1 ) + e * 0.5, 20, Color( 220, 220, 220, 35 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            surface.SetDrawColor( 220, 220, 220, 4 )
            if c == 'dots' then
                surface.DrawLine( 50 + e * ( t - 1 ) + e * 0.5, 30 + n * 0.5, 50 + e * ( t - 1 ) + e * 0.5, 30 + a - n * 0.5 )
            elseif c == 'line' then
                surface.DrawLine( 50 + e * ( t - 1 ) + e * 0.5, 30, 50 + e * ( t - 1 ) + e * 0.5, 30 + a )
            end
        end
    end

    local t, i, r = cats.lang.dow, cats.config.punchCardMode, cats.config.punchCardStart - 1
    local t = vgui.Create( 'DPanel', n )
    t:DockMargin( 50, 30, 5, 5 )
    t:Dock( FILL )
    t.Paint = function( n, a, t )
        local o, a = t / 7, a / 24
        draw.NoTexture()
        for n = 1, 7 do
            for c = 1, 24 do
                local t = c - r
                t = t > 0 and t or t + 24
                if i == 'dots' then
                    local e = math.max( math.floor( ( a - 4 ) * e.claimCard[n][c] / l ), 2 )
                    local t, a = math.floor( a * ( t - 1 ) + a * 0.5 ), math.floor( o * n - o * 0.5 )
                    surface.SetDrawColor( 220, 220, 220 )
                    drawCircle( t, a, e * 0.5, math.max( e, 6 ) )
                elseif i == 'line' then
                    if t < 24 then
                        local i, c = a * ( t - 1 ) + a * 0.5, o * n - ( o - 16 ) * e.claimCard[n][c] / l - 8
                        local t, e = a * t + a * 0.5, o * n - ( o - 16 ) * e.claimCard[n][t + 1] / l - 8
                        surface.SetDrawColor( 220, 220, 220 )
                        surface.DrawLine( math.floor( i ), math.floor( c ), math.floor( t ), math.floor( e ) )
                    end
                else
                    local e = math.floor( math.floor( ( o - 8 ) * e.claimCard[n][c] / l ) )
                    draw.RoundedBoxEx( math.floor( math.min( e, 4 ) ), a * ( t - 1 ) + 3, math.floor( o * n - e ), a - 6, e, Color( 220, 220, 220 ), true, true, false, false )
                end
            end
        end
    end
end )
--PATH addons/_drones/lua/dronesrewrite/client/aisettings_menu.lua:
DRONES_REWRITE.AI.Friends = { }

DRONES_REWRITE.AI.ShowMenuPlayers = function()
	local win = DRONES_REWRITE.CreateWindow(400, 500)
	win.OnCloseButton = function()
		net.Start("dronesrewrite_addfriends")
			net.WriteTable(DRONES_REWRITE.AI.Friends)
		net.SendToServer()
	end
	
	local players = DRONES_REWRITE.CreateScrollPanel(0, 25, 400, 200, win)
	local friends = DRONES_REWRITE.CreateScrollPanel(0, 265, 400, 235, win)

	local i = 0

	local units = { }
	table.Add(units, player.GetAll())
	table.Add(units, DRONES_REWRITE.GetDrones())

	for k, v in pairs(units) do
		if not table.HasValue(DRONES_REWRITE.AI.Friends, v) then
			local id = v:IsPlayer() and v:Name() or v:GetUnit()
			local btn = DRONES_REWRITE.CreateButton("ADD " .. id, 0, 1 + i * 21, 400, 20, players, function()
				if not table.HasValue(DRONES_REWRITE.AI.Friends, v) then 
					table.insert(DRONES_REWRITE.AI.Friends, v) 

					win:Close()
					DRONES_REWRITE.AI.ShowMenuPlayers()
				end
			end)

			i = i + 1
		end
	end

	local lab = DRONES_REWRITE.CreateLabel("Friends | Close to apply", 15, 225, win)
	lab:SetFont("DronesRewrite_customfont1_1")
	lab:SizeToContents()

	for k, v in pairs(DRONES_REWRITE.AI.Friends) do
		if not IsValid(v) then continue end
		
		local id = v:IsPlayer() and v:Name() or v:GetUnit()
		local btn = DRONES_REWRITE.CreateButton("REMOVE " .. id, 0, k * 21 - 20, 400, 20, friends, function()
			table.RemoveByValue(DRONES_REWRITE.AI.Friends, v)

			win:Close()
			DRONES_REWRITE.AI.ShowMenuPlayers()
		end)
	end
end

local function setup(p)
	local btn = DRONES_REWRITE.CreateButton("Show friends settings", 0, 0, 150, 30, p, function() DRONES_REWRITE.AI.ShowMenuPlayers() end)
	p:AddItem(btn)
end

hook.Add("PopulateToolMenu", "dronesrewrite_addmenuai", function() spawnmenu.AddToolMenuOption("Options", "Drones Settings", "dronesrewrite_ai", "AI", "", "", setup) end)
--PATH addons/_drones/lua/dronesrewrite/client/help_menu.lua:
DRONES_REWRITE.ShowHelpWindow = function(open)
	local win = DRONES_REWRITE.CreateWindow(870, 500)
	win:SetSize(282, 500)
	win:SetupCloseButton()

	local anim = Derma_Anim("Sizing", win, function(pnl, anim, delta, data)
		pnl:SetSize(Lerp(delta, pnl:GetWide(), 870), 500)
		pnl:SetupCloseButton()
	end)

	local old = win.Think
	win.Think = function(self)
		old(self)
		if anim:Active() then anim:Run() end
	end

	local old = win.Paint
	win.Paint = function(win, w, h)
		old(win, w, h)

		local color = win.Animation and DRONES_REWRITE.Colors.Border or DRONES_REWRITE.Colors.Grey
		surface.SetDrawColor(color)
		surface.DrawLine(281, 25, 281, 500) -- Separate sections
	end

	local panel = DRONES_REWRITE.CreateScrollPanel(0, 25, 282, 474, win)
	local panellabs = DRONES_REWRITE.CreateScrollPanel(282, 25, 588, 475, win)

	panellabs.labs = { }
	panellabs.oldlabs = { }

	local anim2 = Derma_Anim("Alpha", panellabs, function(pnl, anim, delta, data)
		for k, v in pairs(pnl.oldlabs) do
			if IsValid(v) then
				v:SetAlpha(Lerp(delta, v:GetAlpha(), 0))
				if v:GetAlpha() <= 0 then v:Remove() end
			end
		end

		for k, v in pairs(pnl.labs) do
			if IsValid(v) then
				v:SetAlpha(Lerp(delta, v:GetAlpha(), 255))
			end
		end
	end)

	panellabs.Think = function(self)
		if anim2:Active() then anim2:Run() end
	end

	local count = 0
	local function CreateManual(label, open)
		local y = 1 + count * 31

		local btn = DRONES_REWRITE.CreateButton(label, 1, y, 280, 30, panel, function()
			if not win.Animation then
				anim:Start(1)
				win.Animation = true
			end

			for k, v in pairs(panellabs.labs) do
				table.insert(panellabs.oldlabs, v)
				panellabs.labs[k] = nil
			end

			open()

			anim2:Start(2)
			win:SetTitle(label)
		end)

		if open and open == label then
			btn.DoClick()
		end

		count = count + 1

		return btn
	end	

	for k, v in ipairs(DRONES_REWRITE.Manuals) do
		CreateManual(v.label, function()
			for k, v in pairs(string.Explode("\n", v.text)) do
				local lab = DRONES_REWRITE.CreateLabel(v, 10, 10 + (k - 1) * 16, panellabs)
				lab:SetAlpha(0)
				table.insert(panellabs.labs, lab)
			end
		end)
	end

	-- TODO: uncomment later
	
	--[[local btn = CreateManual("Video", function()
		local HTML = vgui.Create("HTML", panellabs)
		HTML:SetHTML([[
			<iframe width="570" height="420" src="?autoplay=1" frameborder="0"></iframe>
		]] --[[)
		HTML:SetSize(600, 450)
		HTML:SetPos(0, 17)

		table.insert(panellabs.labs, HTML)
	end)

	btn:SetStaticColor(DRONES_REWRITE.Colors.DarkRed)
	btn:SetEnterColor(DRONES_REWRITE.Colors.LightRed)]]
end

local function setup(p)
	local icon = vgui.Create("DImageButton")
	icon:SetImage("stuff/drr")
	icon.DoClick = function()
		gui.OpenURL("http://steamcommunity.com/sharedfiles/filedetails/?id=669642096") 
	end
	p:AddItem(icon)

	local old = icon.PerformLayout
	icon.PerformLayout = function(self, w, h)
		old(self, w, h)
		self:SetSize(w, w)
	end

	local btn = DRONES_REWRITE.CreateButton("Show help window", 0, 0, 150, 30, p, function() DRONES_REWRITE.ShowHelpWindow() end)
	p:AddItem(btn)

	local btn = DRONES_REWRITE.CreateButton("Online help", 0, 0, 150, 30, p, function() 
		gui.OpenURL("http://steamcommunity.com/workshop/filedetails/discussion/669642096/364039531222857486/") 
	end)
	p:AddItem(btn)

	local btn = DRONES_REWRITE.CreateButton("Having issue? Let us know", 0, 0, 150, 30, p, function() 
		gui.OpenURL("http://steamcommunity.com/workshop/filedetails/discussion/669642096/364039531221413931/") 
	end)
	p:AddItem(btn)

	local btn = DRONES_REWRITE.CreateButton("Having idea? Let us know", 0, 0, 150, 30, p, function() 
		gui.OpenURL("http://steamcommunity.com/workshop/filedetails/discussion/669642096/364039531221418677/") 
	end)
	p:AddItem(btn)
end

hook.Add("PopulateToolMenu", "dronesrewrite_addmenuhelp", function() spawnmenu.AddToolMenuOption("Options", "Drones Settings", "dronesrewrite_help", "Help", "", "", setup) end)

concommand.Add("dronesrewrite_help", DRONES_REWRITE.ShowHelpWindow)
--PATH addons/_drones/lua/dronesrewrite/client/hud/camera.lua:
DRONES_REWRITE.HUD["Camera"] = function(drone)
	local shouldDrawCenter = drone.HUD_shouldDrawCenter
	local shouldDrawFuel = drone.HUD_shouldDrawFuel

	local x, y = ScrW(), ScrH()
	local pos = (drone:GetForward() * 10 + drone:LocalToWorld(drone.FirstPersonCam_pos)):ToScreen()

	if shouldDrawFuel then
		surface.SetDrawColor(Color(255, 255, 255))

		surface.SetMaterial(Material("stuff/battery"))
		surface.DrawTexturedRect(20, 0, 100, 100)

		surface.SetMaterial(Material("stuff/bar"))

		for i = 0, (drone:GetFuel() / drone.MaxFuel) * 2 do
			surface.DrawTexturedRect(21 + i * 19, 30, 45, 40)
		end
	end

	local text = "Flashlight: " .. (drone:GetNWBool("camera_flashen", true) and "enabled" or "disabled")
	draw.SimpleText(text, "DronesRewrite_customfont2", 20, 100, Color(255, 255, 255), TEXT_ALIGN_LEFT) 
	draw.SimpleText("RES: " .. ScrW() .. "x" .. ScrH(), "DronesRewrite_customfont2", 20, 125, Color(255, 255, 255), TEXT_ALIGN_LEFT)

	surface.SetDrawColor(Color(255, 255, 255, 55 + math.abs(math.sin(CurTime() * 5)) * 200))
	surface.SetMaterial(Material("stuff/rec"))
	surface.DrawTexturedRect(20, y - 90, 100, 100)

	x, y = x * 0.5, y * 0.5
	surface.DrawRect(x - 100, y - 70, 50, 2)
	surface.DrawRect(x - 100, y - 70, 2, 50)

	surface.DrawRect(x + 50, y - 70, 50, 2)
	surface.DrawRect(x + 100, y - 70, 2, 50)

	surface.DrawRect(x - 100, y + 70, 50, 2)
	surface.DrawRect(x - 100, y + 20, 2, 50)

	surface.DrawRect(x + 50, y + 70, 52, 2)
	surface.DrawRect(x + 100, y + 20, 2, 50)

	if shouldDrawCenter then
		surface.SetMaterial(Material("stuff/cross"))
		surface.DrawTexturedRect(pos.x, pos.y, 8, 8)
	end
end
--PATH addons/_drones/lua/dronesrewrite/weapons/artillery_cannon.lua:
DRONES_REWRITE.Weapons["Artillery Cannon"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, "models/dronesrewrite/artillery_cannon/artillery_cannon.mdl", pos, ang, "models/dronesrewrite/artillery_mount/artillery_mount.mdl", pos - Vector(0, 0, 30))

		ent.RotSpeed = 0.01
		ent.CamOffset = 1.2

		ent.PrimaryAmmo = 40
		ent.PrimaryAmmoMax = 40
		ent.PrimaryAmmoType = { DRONES_REWRITE.AmmoTypes.CannonAmmo }

		return ent
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)
	end,

	Attack = function(self, gun)
		if CurTime() > gun.NextShoot and gun:HasPrimaryAmmo() then
			local src = gun:GetPos() + gun:GetForward() * 100 + gun:GetUp() * -4
			local src2 = gun:GetPos() + gun:GetForward() * -30 + gun:GetUp() * -4
			local src3 = gun:GetPos() + gun:GetForward() * 350 + gun:GetUp() * -4
			
			ParticleEffect("artillery_muzzle_main", src3, gun:GetAngles())

			local seq = gun:LookupSequence("fire")
			gun:ResetSequence(seq)
			gun:SetPlaybackRate( 1.0 )
			gun:SetSequence(seq)

			local ammo = ents.Create("dronesrewrite_projectile")
			ammo:SetPos(src)
			ammo:SetOwner(self:GetDriver())
			ammo:SetAngles(gun:GetAngles())
			ammo:Spawn()
			
			local shell = ents.Create("prop_physics")
			shell:SetModel("models/dronesrewrite/artillery_ammo_shell/artillery_ammo_shell.mdl")
			shell:SetPos(src2)
			shell:SetOwner(self:GetDriver())
			shell:SetAngles(gun:GetAngles())
			shell:SetParent(gun)
			
			timer.Simple(0.5, function()
				shell:Spawn()
				shell:SetParent(null)
				
				local physshell = shell:GetPhysicsObject()
				
				if IsValid(physshell) then 
					physshell:AddVelocity(gun:GetUp() * -1000)
					physshell:AddAngleVelocity(Vector(0, 1500, 0))
				end 
				
				SafeRemoveEntityDelayed(shell, 15)
			end)	
			
			constraint.NoCollide(ammo, self, 0, 0)
			constraint.NoCollide(shell, self, 0, 0)

			local physamm = ammo:GetPhysicsObject()
			//if IsValid(physamm) then physamm:SetGravity(500) end 
			
			physamm:AddVelocity(gun:GetForward() * 50000)

			ammo:EmitSound("ambient/explosions/explode_4.wav", 100, 100, 1, CHAN_WEAPON)

			gun:SetPrimaryAmmo(-1)

			gun:EmitSound("weapons/shotgun/shotgun_cock.wav", 80, 70)
			
			timer.Simple(3, function()
				if IsValid(gun) then gun:EmitSound("vehicles/tank_readyfire1.wav", 80, 255) end
			end)
			gun.NextShoot = CurTime() + 3
		end
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/bomb.lua:
DRONES_REWRITE.Weapons["Bomb"] = {
	Initialize = function(self)
		self:AddHook("DroneDestroyed", "bomb_destr", function()
			ParticleEffect("splode_big_main", self:GetPos(), Angle(0, 0, 0))

			util.BlastDamage(self, IsValid(self:GetDriver()) and self:GetDriver() or self, self:GetPos(), 300, 200)
			self:Remove()
		end)

		return DRONES_REWRITE.Weapons["Template"].InitializeNoDraw(self)
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)
	end,
	
	Attack = function(self, gun)
		self:Destroy()
	end
}

DRONES_REWRITE.Weapons["Plasma Bomb"] = {
	Initialize = function(self)
		self:AddHook("DroneDestroyed", "bomb_destrpl", function()
			ParticleEffect("stinger_explode_drr", self:GetPos(), Angle(0, 0, 0))
			
			util.BlastDamage(self, IsValid(self:GetDriver()) and self:GetDriver() or self, self:GetPos(), 350, 300)
			self:Remove()
		end)

		return DRONES_REWRITE.Weapons["Template"].InitializeNoDraw(self)
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)
	end,
	
	Attack = function(self, gun)
		self:Destroy()
	end,

	OnRemove = function(self, gun)
		self:RemoveHook("DroneDestroyed", "bomb_destr")
	end
}

DRONES_REWRITE.Weapons["Nuclear Bomb"] = {
	Initialize = function(self)
		return DRONES_REWRITE.Weapons["Template"].InitializeNoDraw(self)
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)
	end,
	
	Attack = function(self, gun)
		local pos = self:GetPos()

		local ef = EffectData()
		ef:SetOrigin(pos)
		util.Effect("dronesrewrite_nuke", ef)

		local driver = self:GetDriver()

		timer.Create("dronesrewrite_donuke" .. self:EntIndex(), 0.5, 15, function()
			for k, v in ipairs(ents.FindInSphere(pos, 200000)) do
				local phys = v:GetPhysicsObject()

				constraint.RemoveAll(v)
				v:TakeDamage(v:Health(), driver, driver)

				if v.IS_DRR then v:Destroy() end

				if IsValid(phys) then
					local dist = pos:Distance(v:GetPos())
					phys:SetVelocity((v:GetPos() - pos):GetNormal() * phys:GetMass() * 5 + vector_up * phys:GetMass() * 2)
					phys:AddAngleVelocity(VectorRand() * phys:GetMass())

					phys:Wake()
					phys:EnableMotion(true)
				end
			end
		end)

		-- Radiation 
		timer.Simple(8, function()
			timer.Create("dronesrewrite_nuke_radiation", 4, 8, function()
				sound.Play("ambient/energy/whiteflash.wav", pos, 120, 44)

				for k, v in ipairs(ents.FindInSphere(pos, 5000)) do
					if v:IsPlayer() or v:IsNPC() then v:TakeDamage(5, driver, driver) end
				end
			end)
		end)

		self:Remove()
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/rocket_launchercontrol.lua:
DRONES_REWRITE.Weapons["Homing Missile Launcher"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, "models/dronesrewrite/hrocketlnc/hrocketlnc.mdl", pos, ang, "models/dronesrewrite/attachment4/attachment4.mdl", pos)

		ent.RespawnRocket = function()
			if IsValid(ent.Rocket) then return end

			if not ent:HasPrimaryAmmo() then
				ent.WaitForAmmo = true
				return
			end

			local e = ents.Create("prop_physics")
			e:SetModel("models/dronesrewrite/hrocket_cl/hrocket_cl.mdl")
			e:SetPos(ent:GetPos() - ent:GetUp() + ent:GetForward() * 5)
			e:SetAngles(ent:GetAngles())
			e:Spawn()
			e:Activate()
			e:SetParent(ent)
			e:SetNotSolid(true)
			e:PhysicsDestroy()

			ent.Rocket = e
		end

		ent:RespawnRocket()

		ent.PrimaryAmmo = 6
		ent.PrimaryAmmoMax = 12
		ent.PrimaryAmmoType = { DRONES_REWRITE.AmmoTypes.GuidedMis }

		return ent
	end,

	Think = function(self, gun)
		if IsValid(gun.Missile) and gun.Missile.Enabled then
			if not gun.Missile.Force then gun.Missile.Force = 5 end
			gun.Missile.Force = Lerp(0.005, gun.Missile.Force, 35)

			if gun.Missile.Follow then
				local enemy = gun.Missile.Enemy

				if IsValid(enemy) then
					if enemy == gun.Missile then gun.Missile.Enemy = NULL return end

					local tang = (enemy:LocalToWorld(enemy:OBBCenter()) - gun.Missile:GetPos()):GetNormal():Angle()
					local sang = gun.Missile:GetAngles()

					local p = math.NormalizeAngle(tang.p - sang.p)
					local y = math.NormalizeAngle(tang.y - sang.y)
					local r = -math.NormalizeAngle(sang.r)

					local phys = gun.Missile:GetPhysicsObject()
					phys:AddAngleVelocity(Vector(r, p, y) * gun.Missile.Force)
					phys:AddAngleVelocity(-phys:GetAngleVelocity() * 0.3)

					if gun.Missile:GetPos():Distance(enemy:GetPos()) <= 64 then 
						gun.Missile:Boom()
					end
				end
			else
				local driver = self:GetDriver()

				if driver:IsValid() then
					local tang = self:GetAngles() + driver:EyeAngles()
					local sang = gun.Missile:GetAngles()

					local p = math.NormalizeAngle(tang.p - sang.p)
					local y = math.NormalizeAngle(tang.y - sang.y)
					local r = -math.NormalizeAngle(sang.r)

					local phys = gun.Missile:GetPhysicsObject()
					phys:AddAngleVelocity(Vector(r, p, y) * 5)
					phys:AddAngleVelocity(-phys:GetAngleVelocity() * 0.6)

					for k, v in pairs(self.ValidWeapons) do
						if v.NextShoot < CurTime() + 0.5 then
							v.NextShoot = CurTime() + 0.5
						end
					end

					if self:WasKeyPressed("Fire1") and CurTime() > gun.NextShoot2 then
						gun.Missile:Boom()
					end
				end
			end
		elseif gun.SetupCam then
			self:SetCamera()
			gun.SetupCam = false
		end

		if gun.WaitForAmmo and gun:HasPrimaryAmmo() then
			gun:RespawnRocket()
			gun.WaitForAmmo = false
		end

		if not IsValid(gun.Rocket) and CurTime() > gun.NextShoot then
			gun:RespawnRocket()
		end

		DRONES_REWRITE.Weapons["Template"].Think(self, gun)
	end,

	Attack = function(self, gun)
		if CurTime() > gun.NextShoot and gun:HasPrimaryAmmo() then
			if not IsValid(gun.Rocket) then return end
			if IsValid(gun.Missile) then gun.Missile.Follow = true end

			local ammo = ents.Create("dronesrewrite_rocketbig")
			ammo.Enemy = self:GetNWEntity("rocketlauncher_target")
			ammo.Owner = self:GetDriver():IsValid() and self:GetDriver() or self
			ammo:SetPos(gun.Rocket:GetPos())
			ammo:SetAngles(gun:GetAngles())
			ammo:Spawn()
			ammo:EmitSound("weapons/rpg/rocketfire1.wav", 75, 100, 1, CHAN_WEAPON)
			ammo.Follow = true
			constraint.NoCollide(ammo, self, 0, 0)

			local physamm = ammo:GetPhysicsObject()
			if IsValid(physamm) then physamm:ApplyForceCenter(ammo:GetForward() * 12000) end 
			gun.Missile = ammo

			SafeRemoveEntity(gun.Rocket)

			gun:SetPrimaryAmmo(-1)
			gun.NextShoot2 = CurTime() + 0.3
			gun.NextShoot = CurTime() + 3.5
		end
	end,

	Attack2 = function(self, gun)
		if CurTime() > gun.NextShoot2 then
			if IsValid(gun.Missile) then
				gun.Missile.Follow = not gun.Missile.Follow

				if gun.Missile.Follow then
					gun.Missile.Enemy = NULL

					local phys = gun.Missile:GetPhysicsObject()
					phys:AddAngleVelocity(-phys:GetAngleVelocity())

					self:SetCamera()
					gun.SetupCam = false
				else
					self:SetCamera(gun.Missile, true, false)
					gun.SetupCam = true
				end
			else
				self:SetNWEntity("rocketlauncher_target", self:GetCameraTraceLine(nil, Vector(-64, -64, -64), Vector(64, 64, 64)).Entity)
			end

			gun.NextShoot2 = CurTime() + 0.3
		end
	end,

	OnRemove = function(self, gun)
		self:RemoveHookClient("HUD", "rocketdraw")
	end,

	Deploy = function(self, gun)
		self:AddHookClient("HUD", "rocketdraw", [[
			local drone = LocalPlayer():GetNWEntity("DronesRewriteDrone")

			if drone:IsValid() then
				local ent = drone:GetNWEntity("rocketlauncher_target")
				
				if IsValid(ent) then
					local pos = ent:GetPos():ToScreen()

					surface.SetDrawColor(Color(255, 0, 0, 150))
					surface.SetMaterial(Material("stuff/whiteboxhud/crosshair"))
					surface.DrawTexturedRectRotated(pos.x, pos.y, 32, 32, CurTime() * 1000)
				end
			end
		]])
	end,

	Holster = function(self, gun)
		self:RemoveHookClient("HUD", "rocketdraw")
	end
}

--PATH addons/ukrp_main_content/lua/autorun/emesisbluespy_fixed_pm.lua:
player_manager.AddValidModel("Emesis Blue - Spy (Fixed and outdated)", "models/player/emesisblue/spy_fixed.mdl")
list.Set("PlayerOptionsModel", "Emesis Blue - Spy (Fixed and outdated", "models/player/emesisblue/spy_fixed.mdl")
--PATH addons/____inventory/lua/autorun/itemstore.lua:
hook.Add( "PostGamemodeLoaded", "ItemStoreInitialize", function()
	itemstore = {}

	if SERVER then
		include( "itemstore/sv_init.lua" )
	else
		include( "itemstore/cl_init.lua" )
	end
end )
--PATH addons/igs-core/lua/igs/dependencies/chatprint.lua:
if chat and chat.AddTextSV then return end


if SERVER then
	util.AddNetworkString("ChatPrintColor")


	local function sayColor(targ, ...)
		local args = {...}
		-- PrintTable(args)
		net.Start("ChatPrintColor")
			net.WriteTable(IsColor(args[1]) and args or args[1])
		net[targ and "Send" or "Broadcast"](targ)
	end

	local PLAYER = FindMetaTable("Player")
	function PLAYER:ChatPrintColor(...)
		sayColor(self, ...)
	end

	chat = chat or {}
	function chat.AddTextSV(...)
		sayColor(nil, ...)
	end

else
	net.Receive("ChatPrintColor",function()
		chat.AddText(unpack(net.ReadTable()))
	end)
end

--PATH addons/igs-core/lua/igs/dependencies/scc.lua:
-- Simple Chat Commands
-- Special for IGS by _AMD_
-- 2019.11.08 01:47

scc = {
	commands = {},
}

if SERVER then
	util.AddNetworkString("scc.run")
end

function scc.add(command, callback)
	scc.commands[command:lower()] = callback
end

function scc.run(pl, command, args)
	local callback = scc.commands[command:lower()]
	callback(pl, unpack(args or {}))
end


if SERVER then
	hook.Add("PlayerSay", "scc", function(pl, text)
		text = text:Trim()
		if text[1] == "/" then
			local pieces  = text:Split(" ")
			local command = pieces[1]:sub(2):lower()

			if scc.commands[command] then
				local args = {}
				for i = 2,#pieces do
					args[#args + 1] = pieces[i]
				end

				scc.run(pl, command, args)
				return ""
			end
		end
	end)
end


--[[-------------------------------------------------------------------------
---------------------------------------------------------------------------]]

local PLAYER = FindMetaTable("Player")
function PLAYER:RunSCC(command, ...)
	scc.run(self, command, {...})
end

-- function scc.addWithCooldown(cooldown, command, callback)
-- 	local runIfNotCooldown = function(pl, ...)
-- 		if not pl.sccLastRun then pl.sccLastRun = {} end
-- 		if CurTime() - (pl.sccLastRun[command] or 0) >= cooldown then
-- 			pl.sccLastRun[command] = CurTime()
-- 			callback(pl, ...)
-- 		end
-- 	end

-- 	scc.add(command, runIfNotCooldown)
-- end

if SERVER then
	util.AddNetworkString("scc.run")
else
	net.Receive("scc.run", function()
		local command = net.ReadString()
		local args = {}
		for i = 1, net.ReadUInt(4) do
			args[i] = net.ReadString()
		end

		scc.run(LocalPlayer(), command, args)
	end)
end

function scc.addClientside(command, callback)
	local runOnClient = SERVER and function(pl, ...)
		local args = {...}
		net.Start("scc.run")
			net.WriteString(command)
			net.WriteUInt(#args, 4)
			for _,arg in ipairs(args) do
				net.WriteString(arg)
			end
		net.Send(pl)
	end or callback

	scc.add(command, runOnClient)
end

--PATH addons/igs-core/lua/igs/objects/level.lua:
IGS.LVL = IGS.LVL or setmetatable({
	MAP    = {},
	STORED = {}
},{
	__call = function(self,...)
		return self.Add(...)
	end
})



local LVL = {}
LVL.__index = LVL

function LVL:SetBonus(fOnReach)
	self.bonus = fOnReach -- ply in args
	return self
end

function LVL:SetName(sName) -- OUTDATED (удалено 2018.03.12)
	self.name = sName
	return self
end

function LVL:SetDescription(sDesc)
	self.description = sDesc
	return self
end

function LVL:Name()
	return self.name
end

function LVL:Description()
	return self.description
end

function LVL:LVL()
	return self.lvl
end

function LVL:Cost()
	return self.cost
end

function LVL:GetNext() -- may be nil
	local ilvl,OBJ = next(IGS.LVL.MAP,self.lvl)
	return OBJ,ilvl
end

-- Разница между уровнями
-- function LVL:NeedToRaise() -- nil on last lvl
-- 	local n = self:GetNext()
-- 	return n and n.cost - self.cost
-- end

function IGS.LVL.Add(iNeedSum, sName)
	local OBJ = setmetatable({
		cost = iNeedSum,
		name = sName
	},LVL)

	IGS.LVL.STORED[iNeedSum] = OBJ
	IGS.LVL.Rearrange()

	return OBJ
end

function IGS.LVL.Get(iLVL)
	return IGS.LVL.MAP[iLVL]
end

-- Дает объект лвл, соответствующий указанной сумме
function IGS.LVL.GetByCost(iRealCost)
	for lvl = 1,#IGS.LVL.MAP do
		if not IGS.LVL.MAP[lvl + 1] or IGS.LVL.MAP[lvl + 1].cost > iRealCost then
			return IGS.LVL.MAP[lvl]
		end
	end
end

-- Уровни в диапазоне стоимости.
-- Начало юзаться при выдаче бонусов за пополнение: https://trello.com/c/EjmPOeso/476--
-- function IGS.LVL.GetRange(iFromCost, iToCost)
-- 	local t = {}

-- 	for iLVL,lvl in ipairs(IGS.LVL.MAP) do
-- 		if lvl.cost >= iFromCost and lvl.cost <= iToCost then
-- 			table.insert(t,lvl)
-- 		end
-- 	end

-- 	return t
-- end

-- Перестраивает кэш порядка левелов
-- Нужно на случай, если сначала добавили 30 лвл, а потом 10
-- то чтобы не считалось, что 30 ниже 10
function IGS.LVL.Rearrange()
	IGS.LVL.MAP = {} -- reset

	local i = 0
	for sum in SortedPairs(IGS.LVL.STORED) do
		-- долго объяснять. Короче сортедпэирс по ходу копирует объект перед тем,
		-- как вернуть его в цикл и нельзя сделать for sum,OBJ
		local OBJ = IGS.LVL.STORED[sum]
		i = i + 1
		OBJ.lvl = i

		IGS.LVL.MAP[i] = OBJ
	end
end

--PATH addons/igs-core/lua/igs/network/nw_sh.lua:
IGS.nw.Register("igs_lvl")
	:Write(net.WriteUInt,7) -- 127
	:Read(function()
		return IGS.LVL.Get(net.ReadUInt(7))
	end)
:SetLocalPlayer()


IGS.nw.Register("igs_balance") -- Должно быть ТОЛЬКО у клиентов!
	:Write(net.WriteDouble)
	:Read(net.ReadDouble)
:SetLocalPlayer() --:SetHook("OnIGSBalanceChanged")


IGS.nw.Register("igs_total_transactions")
	:Write(net.WriteUInt,17) -- 131071
	:Read(net.ReadUInt,17)
:SetLocalPlayer()

-- До 16 фев 2022 передавались чисто ID предметов
-- Но веб лоад приводит к тому, что еще до загрузки самого игрока на сервер ему могли
-- передаваться ID предметов, которые на клиенте не успели создаться (например создавались в хуке IGS.Loaded)
IGS.nw.Register("igs_purchases"):Write(function(networked_purchases)
	local flatten = {}
	for uid, am in pairs(networked_purchases) do
		local s = #flatten
		flatten[s + 1] = uid
		flatten[s + 2] = am
	end

	net.WriteUInt(#flatten * 0.5, 8) -- 255

	for i = 1,#flatten,2 do
		net.WriteString(flatten[i])
		net.WriteUInt(flatten[i + 1], 9)
	end
end):Read(function()
	local res = {}
	for _ = 1,net.ReadUInt(8) do
		res[net.ReadString()] = net.ReadUInt(9)
	end
	return res
end):SetLocalPlayer():SetHook("IGS.PlayerPurchasesLoaded")


-- https://img.qweqwe.ovh/1492003125937.png
IGS.nw.Register("igs_settings")
	:Write(function(t)
		net.WriteUInt(t[1],10) -- minimal charge (max 1023)
		net.WriteDouble(t[2])  -- currecy price
	end)
	:Read(function()
		return {
			net.ReadUInt(10), -- charge
			net.ReadDouble(), -- price
		}
	end)
:SetGlobal():SetHook("IGS.OnSettingsUpdated")



--[[--------------
	CONSTANTS
----------------]]
IGS.BIT_TX = 8 -- max транз в нетворке (255)
IGS.BIT_LATEST_PURCH = 6 -- 63

-- Размер ячейки
IGS.BIT_PURCH_ID = 32 -- 4294967295
IGS.BIT_INV_ID = 32
IGS.BIT_TX_ID = 32


--[[--------------
	.net Helpers
----------------]]
function net.WriteIGSItem(ITEM) net.WriteString(ITEM:UID()) end
function net.ReadIGSItem() return IGS.GetItemByUID(net.ReadString()) end
-- function net.WriteIGSGroup(GROUP) net.WriteString(GROUP:Name()) end
-- function net.ReadIGSGroup() return IGS.GetGroup(net.ReadString()) end

local function writeIf(value, fWrite, arg_)
	-- Server = 0 записывал false, хоть это значение
	-- Для отлова бага была такая штука:
	-- https://img.qweqwe.ovh/1567089471715.png
	net.WriteBool(value ~= nil)
	if value then
		fWrite(value, arg_)
	end
end

local function readIf(fRead, arg_)
	return net.ReadBool() and fRead(arg_)
end

function net.WriteIGSPurchase(p)
	net.WriteUInt(p.ID,IGS.BIT_PURCH_ID)
	net.WriteString(p.Item)

	writeIf(p.Server,  net.WriteUInt, 6) -- 63
	writeIf(p.Purchase,net.WriteUInt, 32)
	writeIf(p.Expire,  net.WriteUInt, 32)
	writeIf(p.Nick,    net.WriteString)
end

function net.ReadIGSPurchase()
	return {
		id       = net.ReadUInt(IGS.BIT_PURCH_ID),
		item     = net.ReadString(),

		server   = readIf(net.ReadUInt, 6),
		purchase = readIf(net.ReadUInt, 32),
		expire   = readIf(net.ReadUInt, 32),
		nick     = readIf(net.ReadString),
	}
end

function net.WriteIGSTx(tx)
	net.WriteUInt(tx.ID, IGS.BIT_TX_ID)
	writeIf(tx.Server, net.WriteUInt, 6) -- 63
	net.WriteDouble(tx.Sum)
	net.WriteUInt(tx.Time, 32) -- dohuya
	writeIf(tx.Note, net.WriteString)
end

function net.ReadIGSTx()
	return {
		id     = net.ReadUInt(IGS.BIT_TX_ID),
		server = readIf(net.ReadUInt, 6),
		sum    = net.ReadDouble(),
		date   = net.ReadUInt(32), -- timestamp
		note   = readIf(net.ReadString),
	}
end

function net.WriteIGSInventoryItem(inv_it)
	net.WriteUInt(inv_it.ID, IGS.BIT_INV_ID)
	net.WriteString(inv_it.Item)
end

function net.ReadIGSInventoryItem()
	return {
		id = net.ReadUInt(IGS.BIT_INV_ID),
		item = IGS.GetItemByUID(net.ReadString()),
	}
end

function net.WriteIGSMessage(sErr)
	writeIf(sErr, net.WriteString)
end

function net.ReadIGSMessage()
	return net.ReadBool() and net.ReadString()
end

net.WriteIGSError = net.WriteIGSMessage
net.ReadIGSError  = net.ReadIGSMessage



if SERVER then
	local first_time_trigger = true -- не позволяет выполниться IGS.GetMinCharge() и IGS.GetCurrencyPrice(), поскольку будет ошибка из-за nil внутри net вара
	function IGS.UpdateMoneySettings(iMinCharge,iCurrencyPrice)
		iMinCharge     = tonumber(iMinCharge)
		iCurrencyPrice = tonumber(iCurrencyPrice)

		-- Кеш старых данных
		local min_charge = first_time_trigger and 0 or IGS.GetMinCharge()
		local cur_price  = first_time_trigger and 0 or IGS.GetCurrencyPrice()
		first_time_trigger = nil

		local min_charge_changed = min_charge ~= iMinCharge
		local cur_price_changed  = cur_price  ~= iCurrencyPrice

		if min_charge_changed or cur_price_changed then
			IGS.nw.SetGlobal("igs_settings",{
				iMinCharge,
				iCurrencyPrice
			})

			hook.Run("IGS.OnSettingsUpdated")

			-- Может измениться сразу две вещи
			if min_charge_changed then
				IGS.NotifyAll("Було змінено мінімальну суму нарахування: " .. ("(%s > %s грн)"):format(min_charge,iMinCharge))
			end

			if cur_price_changed then
				IGS.NotifyAll("Вартість донат валюти зміноне з " .. cur_price .. " до " .. iCurrencyPrice .. " грн за одиницу")
			end
		end
	end
end

--PATH addons/igs-core/lua/igs/servers/serv_sh.lua:
IGS.SERVERS = --[[ IGS.SERVERS or --]] setmetatable({
	ID   = function() return IGS.SERVERS.CURRENT end,
	Name = function() return IGS.SERVERS.MAP[IGS.SERVERS.CURRENT] end,

	-- Отправляет на клиент таблицу IGS.SERVERS
	Broadcast = function()
		-- нельзя nil
		IGS.nw.SetGlobal("igs_servers",true)
	end,

	MAP  = {}, -- id, name

	-- CURRENT -- int
	-- LOADED -- bool
	TOTAL   = 0, -- для считывания серверов в nw
	ENABLED = 0, -- для подсчета скидки
},{
	__call = function(self,id)
		return IGS.SERVERS.MAP[id]
	end
})


IGS.nw.Register("igs_servers")
	:Write(function()
		net.WriteUInt(IGS.SERVERS.CURRENT,16) -- 65535
		net.WriteUInt(IGS.SERVERS.TOTAL,8) -- 256
		net.WriteUInt(IGS.SERVERS.ENABLED,8) -- 256

		for id,name in pairs(IGS.SERVERS.MAP) do
			net.WriteUInt(id,16)
			net.WriteString(name)
		end
	end)
	:Read(function()
		IGS.SERVERS.CURRENT = net.ReadUInt(16)
		IGS.SERVERS.TOTAL   = net.ReadUInt(8)
		IGS.SERVERS.ENABLED = net.ReadUInt(8)

		for i = 1,IGS.SERVERS.TOTAL do
			IGS.SERVERS.MAP[net.ReadUInt(16)] = net.ReadString()
		end

		return IGS.SERVERS
	end)
:SetGlobal()

--PATH addons/igs-core/lua/igs/extensions/bwhitelist.lua:
IGS.ITEMS.Whitelist = IGS.ITEMS.Whitelist or {}

local STORE_ITEM = FindMetaTable("IGSItem")

local function team_id(team_cmd)
	return DarkRP.getJobByCommand(team_cmd).team
end

function STORE_ITEM:SetWhitelist(team_cmd)
	self:SetCategory("Вайтлисти")
	self:SetCanActivate(function(pl)
		if GAS.JobWhitelist:IsWhitelisted(pl, team_id(team_cmd)) then
			return "Ви в вайтлисті"
		end
	end)
	self:SetInstaller(function(pl)
		GAS.JobWhitelist:AddToWhitelist(team_id(team_cmd), GAS.JobWhitelist.LIST_TYPE_STEAMID, pl:SteamID())
	end)
	self:SetValidator(function(pl)
		return GAS.JobWhitelist:IsWhitelisted(pl, team_id(team_cmd))
	end)

	self.whitelist = self:Insert(IGS.ITEMS.Whitelist, team_cmd) -- not team_id из-за DarkRP = nil на этом этапе
	return self
end

if SERVER then
	hook.Add("IGS.PlayerPurchasesLoaded", "IGS.bWhitelist", function(pl)
		for team_cmd,_ in pairs(IGS.ITEMS.Whitelist) do
			GAS.JobWhitelist:RemoveFromWhitelist(team_id(team_cmd), GAS.JobWhitelist.LIST_TYPE_STEAMID, pl:SteamID())
		end
	end)
end

--PATH addons/igs-core/lua/igs/interface/vgui/igs_frame.lua:
local PANEL = {}

function PANEL:Init()
	self:DockPadding(0,24,0,0)

	self.lblTitle:SetPos(5,3)
	self.lblTitle:SetColor(IGS.col.TEXT_HARD)

	self.btnClose:SetTextColor(IGS.col.HIGHLIGHTING)
	self.btnClose:SetText("✕")
	self.btnClose:SetSize(30, 24)
	self.btnClose.Paint = function() end
	-- self.btnClose.DoClick = function() self:Close() end

	-- self:SetBackgroundBlur(false)
	self:SetTitle("")

	-- self.btnClose:SetVisible(false)
	self.btnMaxim:SetVisible(false)
	self.btnMinim:SetVisible(false)

	self.lblTitle:SetFont("igs.20")
end

local locations = {}
function PANEL:SaveLocation(panel_uid)
	locations[panel_uid] = {self:GetPos()}
end

function PANEL:RestoreLocation(panel_uid)
	if locations[panel_uid] then
		local x,y = unpack(locations[panel_uid])
		self:SetPos(
			math.Clamp(x,0,ScrW() - 10),
			math.Clamp(y,0,ScrH() - 10)
		) -- на случай, если уменьшат разрешение, чтобы не исчезло у краев
		locations[panel_uid] = nil
	else
		self:Center()
	end
end

function PANEL:RememberLocation(panel_uid)
	self.remember_uid = panel_uid
end


function PANEL:Close(...)
	surface.PlaySound("ambient/water/rain_drip3.wav")
	self.BaseClass.Close(self, ...)
	if self.remember_uid then
		self:SaveLocation(self.remember_uid)
	end
end

function PANEL:GetTitleHeight()
	return 24 -- close button H
end

function PANEL:Paint(w,h)
	if self.m_bBackgroundBlur then
		Derma_DrawBackgroundBlur(self, self.m_fCreateTime)
	end

	IGS.S.Frame(self,w,h)
	return true
end

function PANEL:PaintOver(w,h)
	IGS.S.Outline(self,w,h) -- через = не работало
end

function PANEL:Focus()
	local panels = {}
	self:SetBackgroundBlur(true)
	for _, v in ipairs(vgui.GetWorldPanel():GetChildren()) do
		if v:IsVisible() and (v ~= self) then
			panels[#panels + 1] = v
			v:SetVisible(false)
		end
	end
	self._OnClose = self.OnClose
	self.OnClose = function()
		for _, v in ipairs(panels) do
			if IsValid(v) then
				v:SetVisible(true)
			end
		end

		self:_OnClose()
	end
end

function PANEL:PerformLayout()
	self.lblTitle:SizeToContents()
	self.btnClose:SetPos(self:GetWide() - 30, 0)

	if self.remember_uid and not self.restored then
		self.restored = true
		self:RestoreLocation(self.remember_uid)
	end
end

vgui.Register("igs_frame",PANEL,"DFrame")
-- IGS.UI()

--PATH addons/igs-core/lua/igs/interface/vgui/igs_html.lua:
local PANEL = {}

function PANEL:Init()
	local c = IGS.col.HIGHLIGHT_INACTIVE
	self.text_color = Color(c.r,c.g,c.b,c.a)
end

local LOADING_TEXT = "Загрузочка..."
local ICO          = Material("materials/icons/fa32/usd.png", "smooth")

function PANEL:Paint(w,h)
	self.text_color.a = Lerp( (math.sin(CurTime() * 5) + 1) * 0.5 ,0,255) -- Alpha

	-- ИКОНКА
	surface.SetDrawColor(self.text_color)
	surface.SetMaterial(ICO)
	local y = (h - 50) * 0.5
	surface.DrawTexturedRect((w - 50) * 0.5,y - 10,50,50)
	y = y + 50 -- центральная точка между иконкой и текстом

	-- ТЕКСТ
	surface.SetTextColor(self.text_color)
	surface.SetFont("igs.24") -- 40
	local tw = surface.GetTextSize(LOADING_TEXT)
	surface.SetTextPos((w - tw) * 0.5,y + 10)
	surface.DrawText(LOADING_TEXT)
end

vgui.Register("igs_html",PANEL,"HTML")

--PATH addons/igs-core/lua/igs/interface/windows/group_content.lua:
local function getSpacePanel()
	return uigs.Create("Panel", function(self)
		self:Dock(TOP)
		self:SetTall(3)
	end)
end

function IGS.WIN.Group(sGroupUID)
	local GROUP = IGS.GetGroup(sGroupUID)
	assert(GROUP, "Incorrect group: " .. tostring(sGroupUID))

	surface.PlaySound("ambient/weather/rain_drip1.wav")

	return uigs.Create("igs_frame", function(bg)
		bg:SetTitle(GROUP:Name())
		bg:MakePopup()

		local cellW,cellH -- не изменяется в зависимости от контента
		function bg:AddIGSItem(ITEM, nameInGroup)
			local it = uigs.Create("igs_item"):SetItem(ITEM)
			it:SetName(nameInGroup or ITEM:Name())

			if not cellW then
				cellW,cellH = it:GetSize()
			end

			it:SetSize(cellW * 1.3, cellH)
			it.DoClick = function()
				-- bg:Close()
				IGS.WIN.Item(ITEM:UID())
			end

			bg.scroll:AddItem(it)
		end

		bg.scroll = uigs.Create("igs_scroll", bg)
		bg.scroll:Dock(FILL)
		bg.scroll:SetPadding(6)


		bg.scroll:AddItem( getSpacePanel() ) -- из-за паддинга #1
		for _,v in pairs(GROUP:Items()) do
			local ITEM = v.item
			if not v.item:IsHidden() then -- еще в main_cl
				bg:AddIGSItem(ITEM, v.name)
			end
		end
		bg.scroll:AddItem( getSpacePanel() ) -- из-за паддинга #2

		-- or: https://t.me/c/1353676159/21116
		bg:SetSize((cellW or 220) * 1.3, 300)
		bg:RememberLocation("igs_group")
	end)
end
-- IGS.UI()

--PATH addons/igs-core/lua/igs/modules/extra/new_items_notify_cl.lua:
-- bib.setNum("igs:lasttimeitems", 85)

-- 18, 23, 245
local PL_POYAVILSA = PLUR({"з'явився","з'явилось","з'явилось"})
local PL_NEW       = PLUR({"новий", "нових", "нових"})
local PL_ITEMS     = PLUR({"предмет", "предмета", "предметів"})

hook.Add("IGS.Loaded", "NewItemsNotify", function()
	-- local ip,port = game.GetIPAddress():match("(.+):(.+)")
	-- print(game.GetIPAddress():gsub("%.",""):gsub(":",""))
	-- print(util.CRC(game.GetIPAddress()))

	if IGS.C.NotifyAboutNewItems == false then return end

	local crc = util.CRC(game.GetIPAddress())

	local iItemsNow = #IGS.GetItems()
	local iCached = bib.getNum("igs:lasttimeitems:" .. crc)
	bib.setNum("igs:lasttimeitems:" .. crc, iItemsNow)

	if iCached and iCached < iItemsNow then
		local new = iItemsNow - iCached

		local _,sNew    = PL_NEW(new) -- Чисто слово (новый, новых итд)
		local _,sItems  = PL_ITEMS(new)
		local _,sAppear = PL_POYAVILSA(new)

		local message =
			"У нашому /donate магазині " .. sAppear .. " " .. new .. " " .. sNew .. " " .. sItems .. ". Бажаєте переглянути?"

		IGS.BoolRequest("Поповнення магазину", message, function(aga)
			if aga then
				IGS.UI()
			end
		end)
	end
end)

--PATH addons/igs-core/lua/igs/modules/extra/init_sh.lua:
-- Для предложения совершения покупок в определенных ситуациях
-- /igsitem group_premium_30d

if SERVER then
	local function RunCommand(c)
		return function(pl, arg) pl:RunSCC(c, arg) end
	end

	IGS.WIN = IGS.WIN or {}
	IGS.WIN.Item    = RunCommand("IGSItem")
	IGS.WIN.Group   = RunCommand("IGSGroup")
	IGS.WIN.Deposit = RunCommand("IGSDeposit")
end

scc.addClientside("IGSItem",    function(_, arg) IGS.WIN.Item(arg)    end)
scc.addClientside("IGSDeposit", function(_, arg) IGS.WIN.Deposit(arg) end)
scc.addClientside("IGSGroup",   function(_, arg) IGS.WIN.Group(arg)   end)




IGS.PermaSaveFeature("npc_igs")

local function runAfterhooks() -- #todo перенести эти выполнения в модули или вызывать локально if CODEMOUNT
	if (not IGS_MOUNT) then return end

	print("Виконання 'запізнілих' хуків та spawnmenu_reload")
	if CLIENT then -- костыль, но другого способа не вижу
		hook.GetTable()["InitPostEntity"]["IGS.nw.InitPostEntity"]()
		hook.GetTable()["DarkRPFinishedLoading"]["SupressDarkRPF1"]()
		RunConsoleCommand("spawnmenu_reload") -- npc_igs
	-- else
		-- hook.GetTable()["InitPostEntity"]["IGS.PermaSents"]()
		-- "InitPostEntity", "InitializePermaProps"
	end
end

-- IGS.Loaded выполняется при условии IGS.nw.InitPostEntity
hook.Add("IGS.Initialized", "afterhooks", function()
	timer.Simple(.1, runAfterhooks) -- энтити грузятся вроде шагом позже
end)

--PATH addons/_hitreg/lua/autorun/leyhitreg.lua:
if (SERVER) then
    AddCSLuaFile()
end

print("[/LeyHitreg/] Loading...")
LeyHitreg = LeyHitreg or {}


-- ShotDirForceDisabled allows is for testing with bullet dirs to test how problematic some swep bases are
-- if this alleviates issues, then you need to disable bullet penetration etc in your swep base
LeyHitreg.ShotDirForceDisabled = false
LeyHitreg.DisableSecurityChecks = false
LeyHitreg.IgnoreCanNextPrimaryAttack = true





-- don't touch anything below this. no config. no, leave it. thanks.

LeyHitreg.Disabled = false -- debug: disable addon
LeyHitreg.DisabledOnlyOnClient = false -- debug: disable only on cl
LeyHitreg.NoSpread = false -- debug: enable nospread for everyone
LeyHitreg.ShowActualShotHit = false -- debug: show where the shot actually landed on the sv without spread
LeyHitreg.ShowActualShotSpreadedHit = false -- debug: show where the shot actually landed on the sv with spread
LeyHitreg.BrokenDefaultSpread = false -- debug: enable broken default spread behaviour, broken because its only applied visually now
LeyHitreg.LogHitgroupMismatches = false -- debug: log hitgroup mismatches
LeyHitreg.LogFixedBullets = false -- debug: log the amount of bullets which got hitregged
LeyHitreg.LogInvalidFOV = false -- debug: log invalid FOV
LeyHitreg.LogInvalidShots = false -- debug: log the invalid shots
LeyHitreg.BulletAimbot = false -- debug: set eyeangles to position of bullet
LeyHitreg.LogTargetBone = false -- debug: log target bone
LeyHitreg.HitScanDisabled = false -- debug: disable hitscan within bullet cb
LeyHitreg.BulletOverwriteDisabled = false -- debug: disable hitscan and bullet overwrite
LeyHitreg.AnnounceClientHits = false -- debug: log when the client sends a hit to server
LeyHitreg.DisableLagComp = false -- debug: disable sources original lag compensation

if (LeyHitreg.Disabled) then
    print("[/LeyHitreg/] Disabled")
    return
end

LeyHitreg.svfiles = {
    "leyhitreg/server/bulletprocessing/hitscan.lua",
    "leyhitreg/server/bulletprocessing/processbullet.lua",
    "leyhitreg/server/damageinfo/scaledamagehack.lua",
    "leyhitreg/server/damageinfo/fixscaling.lua",
    "leyhitreg/server/receiveshotinfo/receiveshotinfo.lua",
    "leyhitreg/server/receiveshotinfo/shotvalidator.lua",
}

LeyHitreg.clfiles = {
    "leyhitreg/client/sendshots/sendshots.lua",
    "leyhitreg/client/sendshots/fetchspreads.lua"
}

LeyHitreg.sharedfiles = {
    "leyhitreg/shared/spreadsystem/bulletspread.lua",
    "leyhitreg/shared/spreadsystem/firebullets.lua",
    "leyhitreg/shared/disablelagcomp/disablelagcomp.lua",
    "leyhitreg/shared/workarounds/workarounds.lua",
    "leyhitreg/shared/workarounds/swepbases.lua"
}

local function includeOnCS(filename)
    if (SERVER) then
        print("Sending to clients: " .. filename)
        AddCSLuaFile(filename)
    end

    if (CLIENT) then
        include(filename)
    end
end

local function includeOnSV(filename)
    if (SERVER) then
        print("Loading: " .. filename)
        include(filename)
    end
end

function LeyHitreg:ProcessLuaFiles()
    for k,v in pairs(LeyHitreg.clfiles) do
        includeOnCS(v)
    end

    for k,v in pairs(LeyHitreg.svfiles) do
        includeOnSV(v)
    end

    for k,v in pairs(LeyHitreg.sharedfiles) do
        includeOnCS(v)
        includeOnSV(v)
    end
end

LeyHitreg:ProcessLuaFiles()

function LeyHitreg:DisableMoatHitreg()
    if (MOAT_HITREG) then
        MOAT_HITREG.MaxPing = 1
    end

    if (ConVarExists("moat_alt_hitreg")) then
        RunConsoleCommand("moat_alt_hitreg", "0")
    end

    if (SHR) then
        if (SHR.Config) then
            SHR.Config.Enabled = false
            SHR.Config.ClientDefault = 0
        end
        hook.Remove("EntityFireBullets", "SHR.FireBullets")
        hook.Remove("EntityFireBullets", "‍a")
        net.Receivers["shr"] = function() end
    end
end
print("[/LeyHitreg/] Loaded!")

--PATH addons/_hitreg/lua/leyhitreg/client/sendshots/fetchspreads.lua:
LeyHitreg.WeaponSpreads = {}

local vector_origin = vector_origin

function LeyHitreg:PlayerSwitchWeapon(ply, oldWep, newWep) 
    if (not IsValid(newWep)) then
        return
    end

    local classname = newWep:GetClass()

    if (not classname or self.WeaponSpreads[classname]) then
        return
    end

    if (self:IsIgnoreWep(newWep)) then
        self.WeaponSpreads[classname] = vector_origin
        return
    end

    ply.LeyHitreg_NeedsSpreadForce = newWep

    timer.Simple(1, function() 
        if (not IsValid(ply) or not IsValid(newWep)) then
            return
        end

        ply.LeyHitreg_NeedsSpreadForce = nil

        if (ply:GetActiveWeapon() != newWep) then
            return
        end

        LeyHitreg.WeaponSpreads[classname] = LeyHitreg.WeaponSpreads[classname] or vector_origin
    end)

    LeyHitreg:SetFittingValidClip(newWep)

    if (newWep.PrimaryAttack) then
        newWep:PrimaryAttack()
    elseif (newWep.Primary and newWep.Primary.Attack) then
        newWep.Primary.Attack()
    end
end

hook.Add("PlayerSwitchWeapon", "LeyHitreg:PlayerSwitchWeapon", function(...)
    -- process switch at next frame so FireBullets uses proper wep
    local t = {...}

    timer.Simple(0, function()
        LeyHitreg:PlayerSwitchWeapon(unpack(t))
    end)
end)

function LeyHitreg:FetchSpreadFireBullets(ply, wep, bullet)
    local spreadForceWep = ply.LeyHitreg_NeedsSpreadForce
    local validSpreadForceWep = spreadForceWep != nil and IsValid(spreadForceWep)

    -- if (validSpreadForceWep) then
    --    wep = spreadForceWep
    -- end

    local weaponSpread = LeyHitreg:GetWeaponSpread(ply, wep, bullet)
    self.WeaponSpreads[wep:GetClass()] = weaponSpread

    if (validSpreadForceWep and wep == spreadForceWep) then
        bullet.Damage = 1
        bullet.Distance = 1
        bullet.Src = Vector(-100000, -10000, -10000)
        bullet.Dir = vector_origin
 
        timer.Simple(0, function()
            if (not IsValid(ply)) then
                return
            end

            if (ply.LeyHitreg_NeedsSpreadForce == wep) then
                ply.LeyHitreg_NeedsSpreadForce = nil
            end
        end)

        return bullet
    end
end

function LeyHitreg:EntityEmitSoundSpreadPrefire(data)
    if (not data) then
        return
    end

    local ent = data.Entity

    if (not IsValid(ent)) then
        return
    end


    if (ent:IsPlayer()) then
        if (ent.LeyHitreg_NeedsSpreadForce) then
            return false
        end

        local wep = ent:GetActiveWeapon()
        
        if (not IsValid(wep)) then
            return
        end

        if (wep.LeyHitreg_NeedsSpreadForce) then
            return false
        end

        return
    end

    if (not ent:IsWeapon()) then
        return
    end

    local ply = ent:GetOwner()

    if (IsValid(ply) and ply:IsPlayer() and ply.LeyHitreg_NeedsSpreadForce) then
        return false
    end
    
    if (ent.LeyHitreg_NeedsSpreadForce) then
        return false
    end
end

hook.Add("EntityEmitSound", "LeyHitreg:EntityEmitSoundSpreadPrefire", function(data)
    local ret = LeyHitreg:EntityEmitSoundSpreadPrefire(data)

    if (ret != nil) then
        return ret
    end
end)
--PATH addons/_hitreg/lua/leyhitreg/shared/workarounds/swepbases.lua:

function LeyHitreg:ConVarSet(name, val)
    if (GetConVar(name)) then
        RunConsoleCommand(name, val)
    end
end

function LeyHitreg:SWEPConvars()
    self:ConVarSet("arccw_enable_penetration", "0")
    self:ConVarSet("sv_tfa_bullet_penetration", "0")
    self:ConVarSet("sv_tfa_bullet_randomseed", "0")
end

timer.Simple(1, function()
    LeyHitreg:SWEPConvars()
end)
--PATH addons/lvs_cars_3027255911/lua/lvs_framework/autorun/sh_car_keybinding.lua:

hook.Add( "LVS:Initialize", "[LVS] - Cars - Keys", function()
	local KEYS = {
		{
			name = "CAR_THROTTLE",
			category = "LVS-Car",
			name_menu = "Throttle",
			default = "+forward",
			cmd = "lvs_car_throttle"
		},
		{
			name = "CAR_THROTTLE_MOD",
			category = "LVS-Car",
			name_menu = "Throttle Modifier",
			default = "+speed",
			cmd = "lvs_car_speed"
		},
		{
			name = "CAR_BRAKE",
			category = "LVS-Car",
			name_menu = "Brake",
			default = "+back",
			cmd = "lvs_car_brake"
		},
		{
			name = "CAR_HANDBRAKE",
			category = "LVS-Car",
			name_menu = "Handbrake",
			default = "+jump",
			cmd = "lvs_car_handbrake"
		},
		{
			name = "CAR_STEER_LEFT",
			category = "LVS-Car",
			name_menu = "Steer Left",
			default = "+moveleft",
			cmd = "lvs_car_turnleft"
		},
		{
			name = "CAR_STEER_RIGHT",
			category = "LVS-Car",
			name_menu = "Steer Right",
			default = "+moveright",
			cmd = "lvs_car_turnright"
		},
		{
			name = "CAR_LIGHTS_TOGGLE",
			category = "LVS-Car",
			name_menu = "Toggle Lights",
			default = "phys_swap",
			cmd = "lvs_car_toggle_lights"
		},
		{
			name = "CAR_MENU",
			category = "LVS-Car",
			name_menu = "Open Signal Menu",
			default = "+zoom",
			cmd = "lvs_car_menu"
		},
		{
			name = "CAR_SIREN",
			category = "LVS-Car",
			name_menu = "Open Siren Menu",
			default = "phys_swap",
			cmd = "lvs_car_siren"
		},
		{
			name = "CAR_SWAP_AMMO",
			category = "LVS-Car",
			name_menu = "Change Ammo Type",
			default = "+walk",
			cmd = "lvs_car_swap_ammo"
		},
		{
			name = "CAR_SHIFT_UP",
			category = "LVS-Car",
			name_menu = "Shift Up",
			cmd = "lvs_car_shift_up"
		},
		{
			name = "CAR_SHIFT_DN",
			category = "LVS-Car",
			name_menu = "Shift Down",
			cmd = "lvs_car_shift_dn"
		},
	}

	for _, v in pairs( KEYS ) do
		LVS:AddKey( v.name, v.category, v.name_menu, v.cmd, v.default )
	end

	LVS.WHEELTYPE_NONE = 0
	LVS.WHEELTYPE_LEFT = 1
	LVS.WHEELTYPE_RIGHT = -1

	LVS.HITCHTYPE_NONE = -1
	LVS.HITCHTYPE_MALE = 0
	LVS.HITCHTYPE_FEMALE = 1

	LVS.SOUNDTYPE_NONE = 0
	LVS.SOUNDTYPE_IDLE_ONLY = 1
	LVS.SOUNDTYPE_REV_UP = 2
	LVS.SOUNDTYPE_REV_DOWN = 3
	LVS.SOUNDTYPE_REV_DN = 3
	LVS.SOUNDTYPE_ALL = 4

	LVS.FUELTYPE_PETROL = 0
	LVS.FUELTYPE_DIESEL = 1
	LVS.FUELTYPE_ELECTRIC = 2
	LVS.FUELTYPES = {
		[LVS.FUELTYPE_PETROL] = {
			name = "Petrol",
			color = Vector(240,200,0),
		},
		[LVS.FUELTYPE_DIESEL] = {
			name = "Diesel",
			color = Vector(255,60,0),
		},
		[LVS.FUELTYPE_ELECTRIC] = {
			name = "Electric",
			color = Vector(0,127,255),
		},
	}
end )

if SERVER then
	resource.AddWorkshop("3027255911")

	util.AddNetworkString( "lvs_car_turnsignal" )
	util.AddNetworkString( "lvs_car_break" )

	net.Receive( "lvs_car_turnsignal", function( len, ply )
		if not IsValid( ply ) then return end

		local veh = ply:lvsGetVehicle()

		if not IsValid( veh ) or veh:GetDriver() ~= ply then return end

		veh:SetTurnMode( net.ReadInt( 4 ) )
	end )

else
	net.Receive("lvs_car_break", function( len )
		local ent = net.ReadEntity()

		if not IsValid( ent ) or not isfunction( ent.OnEngineStallBroken ) then return end

		ent:OnEngineStallBroken()
	end)
end

--PATH addons/__main/lua/autorun/m9k_assault_rifles_11_07_15.lua:
/*------------------------------------------------------

If you're reading this, then that mean's you've extracted this addon, probably with intentions 
of editing it for your own needs, or that you're using a legacy addon.

I have no problem with that, but you must understand that I cannot offer support for legacy addons.
If you've extracted this addon, I cannot offer any help fixing problems that come up. It's impossible
to know what you've changed, and thus impossible to know what to fix.

"But Bob!" you might say. "I only changed one thing!" 

Well, that's a shame. Everybody is going to say this, and I know that some of those people will be
lying to me. The only thing I can do is to refuse support to everyone using legacy addons.

So, by using a legacy addon, you accept the fact that I cannot help fix anything that might be broken.

I know it's tough love, but that's the way it's got to be.

------------------------------------------------------*/

--I'm pretty sure we don't need these anymore...
--Almost 99 percent sure that's I'm 100 percent sure...
	
-- if GetConVar("M9KDisableHolster") == nil then
	-- CreateConVar("M9KDisableHolster", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Disable my totally worthless and broken holster system? Won't hurt my feelings any. 1 for true, 2 for false. A map change may be required.")
	-- print("Holster Disable con var created")
-- end

if GetConVar("DebugM9K") == nil then
	CreateConVar("DebugM9K", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE }, "Debugging for some m9k stuff, turning it on won't change much.")
end

if GetConVar("M9KWeaponStrip") == nil then
	CreateConVar("M9KWeaponStrip", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Allow empty weapon stripping? 1 for true, 0 for false")
	print("Weapon Strip con var created")
end
	
if GetConVar("M9KDisablePenetration") == nil then
	CreateConVar("M9KDisablePenetration", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Disable Penetration and Ricochets? 1 for true, 0 for false")
	print("Penetration/ricochet con var created")
end
	
if GetConVar("M9KDynamicRecoil") == nil then
	CreateConVar("M9KDynamicRecoil", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Use Aim-modifying recoil? 1 for true, 0 for false")
	print("Recoil con var created")
end
	
if GetConVar("M9KAmmoDetonation") == nil then
	CreateConVar("M9KAmmoDetonation", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Enable detonatable M9K Ammo crates? 1 for true, 0 for false.")
	print("Ammo crate detonation con var created")
end

if GetConVar("M9KDamageMultiplier") == nil then
	CreateConVar("M9KDamageMultiplier", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Multiplier for M9K bullet damage.")
	print("Damage Multiplier con var created")
end

if GetConVar("M9KDefaultClip") == nil then
	CreateConVar("M9KDefaultClip", "-1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "How many clips will a weapon spawn with? Negative reverts to default values.")
	print("Default Clip con var created")
end
	
if GetConVar("M9KUniqueSlots") == nil then
	CreateConVar("M9KUniqueSlots", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Give M9K Weapons unique slots? 1 for true, 2 for false. A map change may be required.")
	print("Unique Slots con var created")
end
	
if !game.SinglePlayer() then

	if GetConVar("M9KClientGasDisable") == nil then
		CreateConVar("M9KClientGasDisable", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Turn off gas effect for all clients? 1 for yes, 0 for no. ")
	end
	
	if SERVER then
	
		function ClientSideGasDisabler()
			timer.Create("ClientGasBroadcastTimer", 15, 0, 
				function() BroadcastLua("RunConsoleCommand(\"M9KGasEffect\", \"0\")") end )
		end
	
		if GetConVar("M9KClientGasDisable"):GetBool() then
			ClientSideGasDisabler()
		end

		function M9K_Svr_Gas_Change_Callback(cvar, previous, new)
			if tobool(new) == true then
				ClientSideGasDisabler()
				BroadcastLua("print(\"Gas effects disabled on this server!\")")
			elseif tobool(new) == false then
				BroadcastLua("print(\"Gas effects re-enabled on this server.\")")
				BroadcastLua("print(\"You may turn on M9KGasEffect if you wish.\")")
				if timer.Exists("ClientGasBroadcastTimer") then
					timer.Destroy("ClientGasBroadcastTimer")
				end
			end				
		end
		cvars.AddChangeCallback("M9KClientGasDisable", M9K_Svr_Gas_Change_Callback)
	
	end
	
	if CLIENT then
		if GetConVar("M9KGasEffect") == nil then
			CreateClientConVar("M9KGasEffect", "1", true, true)
			print("Client-side Gas Effect Con Var created")
		end		
	end

else
	if GetConVar("M9KGasEffect") == nil then
		CreateConVar("M9KGasEffect", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Use gas effect when shooting? 1 for true, 0 for false")
		print("Gas effect con var created")
	end
end

//AN-94
sound.Add({
	name = 			"an94.single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/an94/galil-1.wav"
})
sound.Add({
	name = 			"an94.double",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/an94/doubletap.wav"
})

sound.Add({
	name = 			"Weapon_an-94.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/an94/clipout.mp3"
})

sound.Add({
	name = 			"Weapon_an-94.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/an94/clipin.mp3"
})

sound.Add({
	name = 			"Weapon_an-94.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/an94/boltpull.mp3"
})

sound.Add({
	name = 			"Weapon_an-94.Draw",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/an94/draw.mp3"
})

//AMD 65
sound.Add({
	name = 			"amd65.single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/amd65/amd-1.wav"
})

sound.Add({
	name = 			"amd65.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/amd65/clipout.mp3"
})

sound.Add({
	name = 			"amd65.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/amd65/magin2.mp3"
})

sound.Add({
	name = 			"amd65.BoltPull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/amd65/boltpull.mp3"
})

sound.Add({
	name = 			"amd65.BoltBack",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/amd65/boltrelease.mp3"
})

//tavor
sound.Add({
	name = 			"Wep_imitavor.single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/tavor/famas-1.wav"
})

sound.Add({
	name = 			"Wep_imitavor.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/tavor/famas_clipout.mp3"
})

sound.Add({
	name = 			"Wep_imitavor.Clipout1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/tavor/famas_clipout1.mp3"
})

sound.Add({
	name = 			"Wep_imitavor.Tap",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/tavor/famas_tap.mp3"
})

sound.Add({
	name = 			"Wep_imitavor.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/tavor/famas_clipin.mp3"
})

sound.Add({
	name = 			"Wep_imitavor.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/tavor/famas_boltpull.mp3"
})

sound.Add({
	name = 			"Wep_imitavor.Boltrelease",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/tavor/famas_boltrelease.mp3"
})

sound.Add({
	name = 			"Wep_imitavor.Cloth",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/tavor/famas_cloth.mp3"
})

//f2000
sound.Add({
	name = 			"Weapon_F2000.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = {"weapons/fokku_tc_f2000/shot-1.wav",
			"weapons/fokku_tc_f2000/shot-2.wav",
			"weapons/fokku_tc_f2000/shot-3.wav",
			"weapons/fokku_tc_f2000/shot-4.wav"}	
})

sound.Add({
	name = 			"f2000.playerbreathing",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_f2000/playerbreathing.mp3"	
})

sound.Add({
	name = 			"f2000.lightcloth",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_f2000/cloth2.mp3"	
})

sound.Add({
	name = 			"f2000.heavycloth",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_f2000/cloth.mp3"	
})

sound.Add({
	name = 			"f2000.magout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_f2000/clipout.mp3"	
})

sound.Add({
	name = 			"f2000.magin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_f2000/clipin.mp3"	
})

sound.Add({
	name = 			"f2000.boltback",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound ={"weapons/fokku_tc_f2000/chargeback.mp3",
			"weapons/fokku_tc_f2000/chargeback1.mp3"}	
})

sound.Add({
	name = 			"f2000.boltforward",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = {"weapons/fokku_tc_f2000/chargefor.mp3",
			"weapons/fokku_tc_f2000/chargefor1.mp3"}	
})

//ak-47
sound.Add({
	name = 			"47ak.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = "weapons/AYKAYFORTY/ak47-1.wav"
})

sound.Add({
	name = 			"47ak.Bolt",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/AYKAYFORTY/bolt.mp3" 
})

sound.Add({
	name = 			"47ak.magin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/AYKAYFORTY/magin.mp3" 
})

sound.Add({
	name = 			"47ak.magout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/AYKAYFORTY/magout.mp3" 
})

//m14
sound.Add({
	name = 			"Weapon_M14SP.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_m14/sg550-1.wav"
})

sound.Add({
	name = 			"Weapon_M14SP.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_m14/sg550_clipout.mp3"
})

sound.Add({
	name = 			"Weapon_M14SP.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_m14/sg550_clipin.mp3"
})

sound.Add({
	name = 			"Weapon_M14SP.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_m14/sg550_boltpull.mp3"
})

sound.Add({
	name = 			"Weapon_M14.Deploy",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_m14/sg550_deploy.mp3"
})

//g36
sound.Add({
	name =				"G36.single",
	channel =			CHAN_USER_BASE+10,
	volume =			1.0,
	sound =				"weapons/G36/m4a1_unsil-1.wav"
})

sound.Add({
	name =	"G36.Boltback",
	channel		= CHAN_ITEM,
	volume		= 1,
	sound			= "weapons/G36/Boltback.mp3"
})

sound.Add({
	name =	"G36.BoltPull",
	channel		= CHAN_ITEM,
	volume		= 1,
	sound			= "weapons/G36/BoltPull.mp3"
})

sound.Add({
	name =	"G36.Cloth",
	channel		= CHAN_ITEM,
	volume		= 1,
	sound			= "weapons/G36/Cloth.mp3"
})

sound.Add({
	name =	"G36.PocketRussle",
	channel		= CHAN_ITEM,
	volume		= 1,
	sound			= "weapons/G36/PocketRussle.mp3"
})

sound.Add({
	name =	"G36.MagOut",
	channel		= CHAN_ITEM,
	volume		= 1,
	sound			= "weapons/G36/MagOut.mp3"
})

sound.Add({
	name =	"G36.MagFiddle",
	channel		= CHAN_ITEM,
	volume		= 1,
	sound			= "weapons/G36/MagFiddle.mp3"
})

sound.Add({
	name =	"G36.MagSlap",
	channel		= CHAN_ITEM,
	volume		= 1,
	sound			= "weapons/G36/MagSlap.mp3"
})

sound.Add({
	name =	"G36.PlaceSilencer",
	channel 		= CHAN_ITEM,
	volume 		= 1,
	sound		= "weapons/G36/PlaceSilencer.mp3"
})

sound.Add({
	name =	"G36.TightenSilencer",
	channel		= CHAN_ITEM,
	volume		= 1,
	sound			= "weapons/G36/TightenSilencer.mp3"
})

sound.Add({
	name =	"G36.SpinSilencer",
	channel		= CHAN_ITEM,
	volume		= 1,
	sound			= "weapons/G36/SpinSilencer.mp3"
})

sound.Add({
	name =	"G36.Safety",
	channel		= CHAN_ITEM,
	volume		= 1,
	sound			= "weapons/G36/Safety.mp3"
})

//winchester 1873
sound.Add({
	name = 			"Weapon_73.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/winchester73/w73-1.wav"	
})

sound.Add({
	name = 			"Weapon_73.Pump",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/winchester73/w73pump.mp3"
})

sound.Add({
	name = 			"Weapon_73.Insertshell",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/winchester73/w73insertshell.mp3"
})

//l85
sound.Add({
	name = 			"Weapon_l85.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/L85A2/aug-1.wav"
})

sound.Add({
	name = 			"Weapon_l85.magin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/L85A2/magin.mp3"
})

sound.Add({
	name = 			"Weapon_l85.magout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/L85A2/magout.mp3"
})

sound.Add({
	name = 			"Weapon_l85.boltslap",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/L85A2/boltslap.mp3"
})

sound.Add({
	name = 			"Weapon_l85.boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/L85A2/boltpull.mp3"
})

sound.Add({
	name = 			"Weapon_l85.cloth",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/L85A2/cloth.mp3"
})

sound.Add({
	name = 			"Weapon_l85.Tap",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/L85A2/tap.mp3"
})	

//aug a3
sound.Add({
	name = 			"aug_a3.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = {"weapons/auga3/aug-1.wav",
			"weapons/auga3/aug-2.wav"}
})

sound.Add({
	name = 			"Weap_auga3.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/auga3/clipout.mp3"
})

sound.Add({
	name = 			"Weap_auga3.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/auga3/clipin.mp3"
})

sound.Add({
	name = 			"Weap_auga3.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/auga3/boltpull.mp3"
})

sound.Add({
	name = 			"Weap_auga3.boltslap",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/auga3/boltslap.mp3"
})

//famas
sound.Add({
	name = 			"Weapon_FAMTC.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = {"weapons/fokku_tc_famas/shot-1.wav", 
 			"weapons/fokku_tc_famas/shot-2.wav" }
})

sound.Add({
	name = 			"Weapon_FAMTC.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_famas/famas_clipout.mp3" 
})

sound.Add({
	name = 			"Weapon_FAMTC.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_famas/famas_clipin.mp3" 
})

sound.Add({
	name = 			"Weapon_FAMTC.forearm",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_famas/famas_forearm.mp3" 
})

//Val
sound.Add({
	name = 			"Dmgfok_vally.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/dmg_val/galil-1.wav"
})

sound.Add({
	name = 			"Dmgfok_vally.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_val/galil_clipout.mp3"
})

sound.Add({
	name = 			"Dmgfok_vally.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_val/galil_clipin.mp3"
})

sound.Add({
	name = 			"Dmgfok_vally.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_val/galil_Boltpull.mp3"
})

sound.Add({
	name = 			"Dmgfok_vally.Draw",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_val/draw.mp3"
})

//vikhr
sound.Add({
	name = 			"Dmgfok_vikhr.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/dmg_vikhr/galil-1.wav"
})

sound.Add({
	name = 			"Dmgfok_vikhr.Silenced",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_vikhr/galil-sil.mp3"
})

sound.Add({
	name = 			"Dmgfok_vikhr.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_vikhr/galil_clipout.mp3"
})

sound.Add({
	name = 			"Dmgfok_vikhr.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_vikhr/galil_clipin.mp3"
})

sound.Add({
	name = 			"Dmgfok_vikhr.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_vikhr/galil_Boltpull.mp3"
})

sound.Add({
	name = 			"Dmgfok_vikhr.Draw",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_vikhr/draw.mp3"
})

//magpul masada ACR
sound.Add({
	name = 			"Masada.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			")weapons/masadamagpul/masada_unsil.wav"	
})

sound.Add({
	name = 			"Masada.Cloth1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/masadamagpul/cloth1.mp3"
})

sound.Add({
	name = 			"Masada.Cloth2",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/masadamagpul/cloth2.mp3"
})

sound.Add({
	name = 			"Masada.Magin1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/masadamagpul/magin1.mp3"	
})

sound.Add({
	name = 			"Masada.Magin2",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/masadamagpul/magin2.mp3"
})

sound.Add({
	name = 			"Masada.Foley",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/masadamagpul/foley.mp3"
})

sound.Add({
	name = 			"Masada.Magout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/masadamagpul/magout.mp3"
})

sound.Add({
	name = 			"Masada.Magslap",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/masadamagpul/magslap.mp3"
})

sound.Add({
	name = 			"Masada.Safety",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/masadamagpul/safety.mp3"
})

sound.Add({
	name = 			"Masada.Chargerback",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/masadamagpul/chargerback.mp3"	
})

sound.Add({
	name = 			"Masada.Boltrelease",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/masadamagpul/boltrelease.mp3"	
})

sound.Add({
	name = 			"Masada.Placesilencer",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/masadamagpul/placesilencer.mp3"
})

sound.Add({
	name = 			"Masada.Removesilencer",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/masadamagpul/removesilencer.mp3"	
})

//m4a1
sound.Add({
	name = 			"Dmgfok_M4A1.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/dmg_m4a1/m4a1_unsil-1.wav"
})

sound.Add({
	name = 			"Dmgfok_M4A1.Silencer_Off",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_m4a1/m4a1_silencer_off.mp3"
})

sound.Add({
	name = 			"Dmgfok_M4A1.Silencer_On",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_m4a1/m4a1_silencer_on.mp3"
})

sound.Add({
	name = 			"Dmgfok_M4A1.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_m4a1/m4a1_clipout.mp3"
})

sound.Add({
	name = 			"Dmgfok_M4A1.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_m4a1/m4a1_clipin.mp3"
})

sound.Add({
	name = 			"Dmgfok_M4A1.Boltrelease",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_m4a1/m4a1_boltrelease.mp3"
})

sound.Add({
	name = 			"Dmgfok_M4A1.Boltrelease2",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_m4a1/m4a1_boltrelease_silenced.mp3"
})

sound.Add({
	name = 			"Dmgfok_M4A1.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_m4a1/m4a1_boltpull.mp3"
})

//m16a4
sound.Add({
	name = 			"Dmgfok_M16A4.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			")weapons/dmg_m16a4/shoot.wav"
})

sound.Add({
	name = 			"Dmgfok_M16A4.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_m16a4/magout.mp3"
})

sound.Add({
	name = 			"Dmgfok_M16A4.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_m16a4/magin.mp3"
})

sound.Add({
	name = 			"Dmgfok_M16A4.Boltrelease",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_m16a4/boltrelease.mp3"
})

sound.Add({
	name = 			"Dmgfok_M16A4.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_m16a4/boltpull.mp3"
})

-- Congratulations, you have found a secret message! Bob says hi, and hopes you are having fun with this addon.

//ak47
sound.Add({
	name = 			"Tactic_AK47.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_ak47/ak47-1.wav"
})

sound.Add({
	name = 			"Tactic_AK47.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_ak47/ak47_clipout.mp3"
})

sound.Add({
	name = 			"Tactic_AK47.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_ak47/ak47_clipin.mp3"
})

sound.Add({
	name = 			"Tactic_AK47.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_ak47/ak47_boltpull.mp3"
})

//SCAR
sound.Add({
	name = 			"Wep_fnscarh.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			{"weapons/fnscarh/aug-1.wav",
						"weapons/fnscarh/aug-2.wav",
						"weapons/fnscarh/aug-3.wav"}
})

sound.Add({
	name = 			"Wep_fnscar.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fnscarh/aug_boltpull.mp3"
})

sound.Add({
	name = 			"Wep_fnscar.Boltslap",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fnscarh/aug_boltslap.mp3"
})

sound.Add({
	name = 			"Wep_fnscar.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fnscarh/aug_clipout.mp3"
})

sound.Add({
	name = 			"Wep_fnscar.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fnscarh/aug_clipin.mp3"
})

//fn fal
sound.Add({
	name = 			"fnfal.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = "weapons/fn_fal/galil-1.wav"
})

sound.Add({
	name = 			"Weapon_fnfal.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fn_fal/galil_clipout.mp3" 
})

sound.Add({
	name = 			"Weapon_fnfal.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fn_fal/galil_clipin.mp3" 
})

sound.Add({
	name = 			"Weapon_fnfal.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fn_fal/galil_boltpull.mp3" 
})

//hk 416
sound.Add({
	name = 			"hk416weapon.SilencedSingle",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = "weapons/twinkie_hk416/m4a1-1.wav"
})

sound.Add({
	name = 			"hk416weapon.UnsilSingle",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = "weapons/twinkie_hk416/m4a1_unsil-1.wav"
})

sound.Add({
	name = 			"hk416weapon.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/twinkie_hk416/m4a1_clipout.mp3"	
})

sound.Add({
	name = 			"hk416weapon.Magtap",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/twinkie_hk416/m4a1_tap.mp3"	
})

sound.Add({
	name = 			"hk416weapon.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/twinkie_hk416/m4a1_clipin.mp3"	
})

sound.Add({
	name = 			"hk416weapon.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/twinkie_hk416/m4a1_boltpull.mp3"	
})

sound.Add({
	name = 			"hk416weapon.Boltrelease",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/twinkie_hk416/m4a1_boltrelease.mp3"	
})

sound.Add({
	name = 			"hk416weapon.Deploy",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/twinkie_hk416/m4a1_deploy.mp3"	
})

sound.Add({
	name = 			"hk416weapon.Silencer_On",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/twinkie_hk416/m4a1_silencer_on.mp3"	
})

sound.Add({
	name = 			"hk416weapon.Silencer_Off",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/twinkie_hk416/m4a1_silencer_off.mp3"	
})

//G3
sound.Add({
	name = 			"hk_g3_weapon.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = "weapons/hk_g3/galil-1.wav"
})

sound.Add({
	name = 			"hk_g3_weapon.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hk_g3/galil_clipout.mp3"	
})

sound.Add({
	name = 			"hk_g3_weapon.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hk_g3/galil_clipin.mp3"	
})

sound.Add({
	name = 			"hk_g3_weapon.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hk_g3/boltpull.mp3"	
})

sound.Add({
	name = 			"hk_g3_weapon.Boltforward",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hk_g3/boltforward.mp3"	
})

sound.Add({
	name = 			"hk_g3_weapon.cloth",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hk_g3/Cloth.mp3"	
})

sound.Add({
	name = 			"hk_g3_weapon.draw",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hk_g3/draw.mp3"	
})

m9knpw = {}
table.insert(m9knpw, "m9k_davy_crockett_explo")
table.insert(m9knpw, "m9k_gdcwa_matador_90mm")
table.insert(m9knpw, "m9k_gdcwa_rpg_heat")
table.insert(m9knpw, "m9k_improvised_explosive")
table.insert(m9knpw, "m9k_launched_davycrockett")
table.insert(m9knpw, "m9k_launched_ex41")
table.insert(m9knpw, "m9k_launched_m79")
table.insert(m9knpw, "m9k_m202_rocket")
table.insert(m9knpw, "m9k_mad_c4")
table.insert(m9knpw, "m9k_milkor_nade")
table.insert(m9knpw, "m9k_nervegasnade")
table.insert(m9knpw, "m9k_nitro_vapor")
table.insert(m9knpw, "m9k_oribital_cannon")
table.insert(m9knpw, "m9k_poison_parent")
table.insert(m9knpw, "m9k_proxy")
table.insert(m9knpw, "m9k_released_poison")
table.insert(m9knpw, "m9k_sent_nuke_radiation")
table.insert(m9knpw, "m9k_thrown_harpoon")
table.insert(m9knpw, "m9k_thrown_knife")
table.insert(m9knpw, "m9k_thrown_m61")
table.insert(m9knpw, "m9k_thrown_nitrox")
table.insert(m9knpw, "m9k_thrown_spec_knife")
table.insert(m9knpw, "m9k_thrown_sticky_grenade")
table.insert(m9knpw, "bb_dod_bazooka_rocket")
table.insert(m9knpw, "bb_dod_panzershreck_rocket")
table.insert(m9knpw, "bb_garand_riflenade")
table.insert(m9knpw, "bb_k98_riflenade")
table.insert(m9knpw, "bb_planted_dod_tnt")
table.insert(m9knpw, "bb_thrownalliedfrag")
table.insert(m9knpw, "bb_thrownaxisfrag")
table.insert(m9knpw, "bb_thrownsmoke_axis")
table.insert(m9knpw, "bb_thrownaxisfrag")
table.insert(m9knpw, "bb_planted_alt_c4")
table.insert(m9knpw, "bb_planted_css_c4")
table.insert(m9knpw, "bb_throwncssfrag")
table.insert(m9knpw, "bb_throwncsssmoke")
table.insert(m9knpw, "m9k_ammo_40mm")
table.insert(m9knpw, "m9k_ammo_40mm_single")
table.insert(m9knpw, "m9k_ammo_357")
table.insert(m9knpw, "m9k_ammo_ar2")
table.insert(m9knpw, "m9k_ammo_buckshot")
table.insert(m9knpw, "m9k_ammo_c4")
table.insert(m9knpw, "m9k_ammo_frags")
table.insert(m9knpw, "m9k_ammo_ieds")
table.insert(m9knpw, "m9k_ammo_nervegas")
table.insert(m9knpw, "m9k_ammo_nuke")
table.insert(m9knpw, "m9k_ammo_pistol")
table.insert(m9knpw, "m9k_ammo_proxmines")
table.insert(m9knpw, "m9k_ammo_rockets")
table.insert(m9knpw, "m9k_ammo_smg")
table.insert(m9knpw, "m9k_ammo_sniper_rounds")
table.insert(m9knpw, "m9k_ammo_stickynades")
table.insert(m9knpw, "m9k_ammo_winchester")

function PocketM9KWeapons(ply, wep)

	if not IsValid(wep) then return end
	class = wep:GetClass()
	m9knopocket = false
	
	for k, v in pairs(m9knpw) do
		if v == class then
			m9knopocket = true
			break
		end
	end
	
	if m9knopocket then
		return false
	end
	
	--goddammit i hate darkrp
	
end
hook.Add("canPocket", "PocketM9KWeapons", PocketM9KWeapons )

assault_autorun_mounted = true
--PATH addons/media_player/lua/autorun/includes/modules/browserpool.lua:
if browserpool then return end -- ignore Lua refresh

local table = table
local vgui = vgui

_G.browserpool = {}

---
-- Debug variable which will allow outputting messages if enabled.
-- @type boolean
--
local DEBUG = true

---
-- Array of available, pooled browsers
-- @type table
--
local available = {}

---
-- Array of active, pooled browsers.
-- @type table
--
local active = {}

---
-- Array of pending requests for a browser.
-- @type table
--
local pending = {}

---
-- Minimum number of active browsers to be pooled.
-- @type Number
--
local numMin = 2

---
-- Maximum number of active browsers to be pooled.
-- @type Number
--
local numMax = 4

---
-- Number of currently active browsers.
-- @type Number
--
local numActive = 0

---
-- Number of currently pending browser requests.
-- @type Number
--
local numPending = 0

---
-- Number of total browser requests.
-- @type Number
--
local numRequests = 0

---
-- Default URL to set browsers on setup/teardown.
-- @type String
--
local defaultUrl = "data:text/html,"

---
-- JavaScript code to remove an object's property.
-- @type String
--
local JS_RemoveProp = "delete %s.%s;"

---
-- Helper function to setup/teardown a browser panel.
--
-- @param panel?	Browser panel to be cleaned up.
-- @return Panel	DMediaPlayerHTML panel instance.
--
local function setupPanel( panel )

	-- Create a new panel if it wasn't passed in
	if panel then
		panel:Stop()
	else
		panel = vgui.Create("DMediaPlayerHTML")
	end

	-- Hide panel
	-- panel:SetSize(0, 0)
	panel:SetPos(0, 0)

	-- Disable input
	panel:SetKeyBoardInputEnabled(false)
	panel:SetMouseInputEnabled(false)

	-- Browser panels are usually manually drawn, use a regular panel if not
	panel:SetPaintedManually(true)

	-- Fix for panel not getting cleared after 3/2017 update
	panel:SetHTML( "" )

	-- Set default URL
	panel:OpenURL( defaultUrl )

	-- Remove any added function callbacks
	for obj, tbl in pairs(panel.Callbacks) do
		if obj ~= "console" then
			for funcname, _ in pairs(tbl) do
				panel:QueueJavascript(JS_RemoveProp:format(obj, funcname))
			end
		end
	end

	return panel

end

---
-- Local function for removing cancelled browser promises via closures.
--
-- @param Promise	Browser bromise.
-- @return Boolean	Success status.
--
local function removePromise( promise )
	local id = promise:GetId()

	if not pending[id] then
		ErrorNoHalt( "browserpool: Failed to remove promise.\n" )
		print( promise, id )
		debug.Trace()
		return false
	end

	pending[id] = nil
	numPending = numPending - 1

	return true
end

---
-- Browser promise for resolving browser requests when there isn't an available
-- browser at the time of request.
--
local BrowserPromise = {}
local BrowserPromiseMeta = { __index = BrowserPromise }

function BrowserPromise:New( callback, id )
	return setmetatable(
		{ __cb = callback, __id = id or -1 },
		BrowserPromiseMeta
	)
end

function BrowserPromise:GetId()
	return self.__id
end

function BrowserPromise:Resolve( value )
	self.__cb(value)
end

function BrowserPromise:Cancel( reason )
	self.__cb(false, reason)
	removePromise(self)
end

---
-- Retrieves an available browser panel from the pool. Otherwise, a new panel
-- will be created.
--
-- @return Panel	DMediaPlayerHTML panel instance.
--
function browserpool.get( callback )

	numRequests = numRequests + 1

	if DEBUG then
		print( string.format("browserpool: get [Active: %s][Available: %s][Pending: %s]",
			numActive, #available, numPending ) )
	end

	local panel

	-- Check if there's an available panel
	if #available > 0 then

		panel = table.remove( available )
		table.insert( active, panel )

		callback( panel )

	elseif numActive < numMax then -- create a new panel

		panel = setupPanel()
		numActive = numActive + 1

		if DEBUG then
			print( "browserpool: Spawned new browser [Active: "..numActive.."]" )
		end

		table.insert( active, panel )
		callback( panel )

	else -- wait for an available browser

		local promise = BrowserPromise:New( callback, numRequests )

		pending[numRequests] = promise
		numPending = numPending + 1

		return promise

	end

end

---
-- Releases the given browser panel from the active pool.
--
-- Remember to unset references to the browser instance after releasing:
--		browserpool.release( self.Browser )
--		self.Browser = nil
--
-- @param panel		Browser panel to be released.
-- @return boolean	Whether the panel was successfully removed.
--
function browserpool.release( panel, destroy )

	if not panel then return end

	local key = table.KeyFromValue( active, panel )

	-- Unable to find active browser panel
	if not key then
		ErrorNoHalt( "browserpool: Attempted to release unactive browser.\n" )
		debug.Trace()

		-- Remove browser even if the request was invalid
		if ValidPanel(panel) then
			panel:Remove()
		end

		return false
	end

	-- Resolve an open promise if one exists
	if numPending > 0 and not destroy then

		-- Get the earliest request first
		local id = table.GetFirstKey( pending )
		local promise = pending[id]

		-- Cleanup panel
		setupPanel( panel )

		promise:Resolve( panel )
		removePromise( promise )

	else

		if not table.remove( active, key ) then
			ErrorNoHalt( "browserpool: Failed to remove panel from active browsers.\n" )
			debug.Trace()

			-- Remove browser even if the request was invalid
			if ValidPanel(panel) then
				panel:Remove()
			end

			return false
		end

		-- Remove panel if there are more active than the minimum pool size
		if numActive > numMin then

			panel:Remove()
			numActive = numActive - 1

			if DEBUG then
				print( "browserpool: Destroyed browser [Active: "..numActive.."]" )
			end

		elseif not destroy then

			-- Cleanup panel
			setupPanel( panel )

			-- Add to the pool
			table.insert( available, panel )

			if DEBUG then
				print( "browserpool: Pooled browser [Active: "..numActive.."]" )
			end

		end

	end

	return true

end

--PATH addons/media_player/lua/mediaplayer/utils.lua:
if SERVER then AddCSLuaFile() end

local file = file
local math = math
local urllib = url
local ceil = math.ceil
local floor = math.floor
local Round = math.Round
local log = math.log
local pow = math.pow
local format = string.format
local tostring = tostring
local IsValid = IsValid


local utils = {}

---
-- Ceil the given number to the largest power of two.
--
function utils.CeilPower2(n)
	return pow(2, ceil(log(n) / log(2)))
end

---
-- Method for easily grabbing a value from a table without checking that each
-- fragment exists.
--
-- @param tbl Table
-- @param key e.g. "json.key.fragments"
--
function utils.TableLookup( tbl, key )
	local fragments = string.Split(key, '.')
	local value = tbl

	for _, fragment in ipairs(fragments) do
		value = value[fragment]

		if not value then
			return nil
		end
	end

	return value
end

---
-- Formats the number of seconds to a string.
-- e.g. 3612 => 24:12
--
function utils.FormatSeconds(sec)
	sec = Round(sec)

	local hours = floor(sec / 3600)
	local minutes = floor((sec % 3600) / 60)
	local seconds = sec % 60

	if minutes < 10 then
		minutes = "0" .. tostring(minutes)
	end

	if seconds < 10 then
		seconds = "0" .. tostring(seconds)
	end

	if hours > 0 then
		return format("%s:%s:%s", hours, minutes, seconds)
	else
		return format("%s:%s", minutes, seconds)
	end
end

-- https://github.com/xfbs/PiL3/blob/master/18MathLibrary/shuffle.lua
function utils.Shuffle(list)
    -- make and fill array of indices
    local indices = {}
    for i = 1, #list do
        indices[#indices+1] = i
    end

    -- create shuffled list
    local shuffled = {}
    for i = 1, #list do
        -- get a random index
        local index = math.random(#indices)

        -- get the value
        local value = list[indices[index]]

        -- remove it from the list so it won't be used again
        table.remove(indices, index)

        -- insert into shuffled array
        shuffled[#shuffled+1] = value
    end

    return shuffled
end

function utils.Retry( func, success, error, maxAttempts )

	maxAttempts = maxAttempts or 3
	local attempts = 1

	local function callback( value )
		if value then
			success( value )
		elseif attempts < maxAttempts then
			attempts = attempts + 1
			func( callback )
		else
			error()
		end
	end

	func( callback )

end

local function setTimeout( func, wait )
	local timerID = tostring( func )
	timer.Create( timerID, wait, 1, func )
	timer.Start( timerID )
	return timerID
end

local function clearTimeout( timerID )
	if timer.Exists( timerID ) then
		timer.Destroy( timerID )
	end
end

-- based on underscore.js' _.throttle function
function utils.Throttle( func, wait, options )
	wait = wait or 1
	options = options or {}

	local timeout, args, result
	local previous

	local function later()
		previous = (options.leading == false) and 0 or RealTime()
		timeout = nil
		result = func( unpack(args) )
		if not timeout then
			args = nil
		end
	end

	local function throttled(...)
		local now = RealTime()
		if not previous then
			previous = now
		end

		local remaining = wait - (now - previous)

		args = {...}

		if remaining <= 0 or remaining > wait then
			if timeout then
				clearTimeout(timeout)
				timeout = nil
			end

			previous = now
			result = func( unpack(args) )

			if not timeout then
				args = nil
			end
		elseif not timeout and options.trailing ~= false then
			timeout = setTimeout(later, remaining)
		end

		return result
	end

	return throttled
end

if CLIENT then

	local CeilPower2 = utils.CeilPower2
	local SetDrawColor = surface.SetDrawColor
	local SetMaterial = surface.SetMaterial
	local DrawTexturedRect = surface.DrawTexturedRect
	local DrawRect = surface.DrawRect

	local color_white = color_white

	function utils.DrawHTMLPanel( panel, w, h )
		if not (IsValid( panel ) and w and h) then return end

		panel:UpdateHTMLTexture()

		local pw, ph = panel:GetSize()

		-- Convert to scalar
		w = w / pw
		h = h / ph

		-- Fix for non-power-of-two html panel size
		pw = CeilPower2(pw)
		ph = CeilPower2(ph)

		SetDrawColor( color_white )

		local mat = panel:GetHTMLMaterial()

		if mat then
			SetMaterial( mat )
			DrawTexturedRect( 0, 0, w * pw, h * ph )
		else
			DrawRect( 0, 0, w * pw, h * ph )
		end
	end

	function utils.ParseHHMMSS( time )
	    local tbl = {}

		-- insert fragments in reverse
		for fragment, _ in string.gmatch(time, ":?(%d+)") do
			table.insert(tbl, 1, tonumber(fragment) or 0)
		end

		if #tbl == 0 then
			return nil
		end

		local seconds = 0

		for i = 1, #tbl do
			seconds = seconds + tbl[i] * math.max(60 ^ (i-1), 1)
		end

		return seconds
	end

	---
	-- Attempts to play uri from stream or local file and returns channel in
	-- callback.
	--
	function utils.LoadStreamChannel( uri, options, callback )
		local isLocalFile = false

		-- Play uri from a local file if:
		-- 1. Windows OS and path contains drive letter
		-- 2. Linux or OS X and path starts with a single '/'
		--
		-- We can't check this using file.Exists since GMod only allows checking
		-- within the GMod directory. However, sound.PlayFile will still load
		-- a file from any directory.
		if ( system.IsWindows() and uri:find("^%w:/") ) or
			( not system.IsWindows() and uri:find("^/[^/]") ) then
			isLocalFile = true

			local success, decoded = pcall(urllib.unescape, uri)
			if success then
				uri = decoded
			end
		end

		local playFunc = isLocalFile and sound.PlayFile or sound.PlayURL
		playFunc( uri, options or "noplay", function( channel )
			if IsValid( channel ) then
				callback( channel )
			else
				callback( nil )
			end
		end )
	end

end

_G.MediaPlayerUtils = utils

--PATH addons/media_player/lua/mediaplayer/config/client.lua:
--[[----------------------------------------------------------------------------
	Media Player client configuration
------------------------------------------------------------------------------]]
MediaPlayer.SetConfig({

	---
	-- HTML content
	--
	html = {

		---
		-- Base URL where HTML content is located.
		-- @type String
		--
		base_url = "http://samuelmaddock.github.io/gm-mediaplayer/"

	},

	---
	-- Request menu
	--
	request = {

		---
		-- URL of the request menu.
		-- @type String
		--
		url = "http://samuelmaddock.github.io/gm-mediaplayer/request.html"

	}

})

--PATH addons/media_player/lua/mediaplayer/players/base/shared.lua:
local MediaPlayer = MediaPlayer

local HasFocus = system.HasFocus
local MuteUnfocused = MediaPlayer.Cvars.MuteUnfocused
local CeilPower2 = MediaPlayerUtils.CeilPower2

--[[---------------------------------------------------------
	Base Media Player
-----------------------------------------------------------]]

local MEDIAPLAYER = MEDIAPLAYER
MEDIAPLAYER.__index = MEDIAPLAYER

-- Inherit EventEmitter for all mediaplayer instances
EventEmitter:new(MEDIAPLAYER)

MEDIAPLAYER.Name = "base"
MEDIAPLAYER.IsMediaPlayer = true
MEDIAPLAYER.NoMedia = "\4" -- end of transmission character

-- Media Player states
MP_STATE_ENDED = 0
MP_STATE_PLAYING = 1
MP_STATE_PAUSED  = 2
NUM_MP_STATE = 3

include "sh_snapshot.lua"

--
-- Initialize the media player object.
--
function MEDIAPLAYER:Init(params)
	self._Queue = {}		-- media queue
	self._Media = nil		-- current media
	self._Owner = nil		-- media player owner

	self._State = MP_STATE_ENDED -- waiting for new media

	if SERVER then

		self._TransmitState = TRANSMIT_ALWAYS
		self._Listeners = {}

		self._Location = -1

	else

		self._LastMediaUpdate = 0
		inputhook.Add( KEY_Q, self, self.OnQueueKeyPressed )
		inputhook.Add( KEY_C, self, self.OnQueueKeyPressed )

	end

	-- Merge in any passed in params
	-- table.Merge(self, params or {})
end

--
-- Get whether the media player is valid.
--
-- @return boolean	Whether the media player is valid
--
function MEDIAPLAYER:IsValid()
	if self._removed then
		return false
	end

	return true
end

--
-- String coercion metamethod
--
-- @return String	Media player string representation
--
function MEDIAPLAYER:__tostring()
	return self:GetId()
end

--
-- Get the media player's unique ID.
--
-- @return Number	Media player ID.
--
function MEDIAPLAYER:GetId()
	return self.id
end

--
-- Get the media player's type.
--
-- @return String	MP type.
--
function MEDIAPLAYER:GetType()
	return self.Name
end

function MEDIAPLAYER:GetPlayerState()
	return self._State
end

function MEDIAPLAYER:SetPlayerState( state )
	local current = self._State
	self._State = state

	if MediaPlayer.DEBUG then
		print( "MEDIAPLAYER.SetPlayerState", state )
	end

	if current ~= state then
		self:OnPlayerStateChanged( current, state )
	end
end

function MEDIAPLAYER:OnPlayerStateChanged( old, new )
	local media = self:GetMedia()
	local validMedia = IsValid(media)

	if MediaPlayer.DEBUG then
		print( "MEDIAPLAYER.OnPlayerStateChanged", old .. ' => ' .. new )
	end

	if new == MP_STATE_PLAYING then
		if validMedia and not media:IsPlaying() then
			media:Play()
		end
	elseif new == MP_STATE_PAUSED then
		if validMedia and media:IsPlaying() then
			media:Pause()
		end
	end

	self:emit( MP.EVENTS.PLAYER_STATE_CHANGED, new, old )
end

--
-- Get whether the media player is currently playing media.
--
-- @return boolean	Media is playing
--
function MEDIAPLAYER:IsPlaying()
	return self._State == MP_STATE_PLAYING
end

--
-- Get the media player's position.
--
-- @return Vector3	Media player's position
--
function MEDIAPLAYER:GetPos()
	if not self._pos then
		self._pos = Vector(0,0,0)
	end
	return self._pos
end

--
-- Get the media player's location ID.
--
-- @return Number	Media player's location ID
--
function MEDIAPLAYER:GetLocation()
	return self._Location
end

function MEDIAPLAYER:GetOwner()
	return self._Owner
end

function MEDIAPLAYER:SetOwner( ply )
	self._Owner = ply
end

---
-- Determines if the player has privileges to use media controls (skip, seek,
-- etc.). Override this for custom behavior.
--
function MEDIAPLAYER:IsPlayerPrivileged( ply )
	return ply == self:GetOwner() or ply:IsAdmin() or
		hook.Run( "MediaPlayerIsPlayerPrivileged", self, ply )
end

---
-- Media player update
--
function MEDIAPLAYER:Think()

	if SERVER then
		self:UpdateListeners()
	end

	local media = self:GetMedia()
	local validMedia = IsValid(media)

	-- Waiting to play new media
	if SERVER then
		if self._State <= MP_STATE_ENDED then

			-- Check queue for videos to play
			if not self:IsQueueEmpty() then
				self:OnMediaFinished()
			end

		elseif self._State == MP_STATE_PLAYING then

			-- Wait for media to finish
			if validMedia and media:IsTimed() then
				local time = media:CurrentTime()
				local duration = media:Duration()

				if time > duration then
					self:OnMediaFinished()
				end
			end

		end
	end

	if CLIENT and validMedia then
		media:Sync()

		local volume

		-- TODO: add a GAMEMODE hook to determine if sound should be muted
		if not HasFocus() and MuteUnfocused:GetBool() then
			volume = 0
		else
			volume = MediaPlayer.Volume()
		end

		media:Volume( volume )
	end

end

--
-- Get the currently playing media.
--
-- @return Media	Currently playing media
--
function MEDIAPLAYER:GetMedia()
	return self._Media
end

MEDIAPLAYER.CurrentMedia = MEDIAPLAYER.GetMedia

--
-- Set the currently playing media.
--
-- @param media		Media object.
--
function MEDIAPLAYER:SetMedia( media )
	self._Media = media
	self:OnMediaStarted( media )

	-- NOTE: media can be nil!
	self:emit(MP.EVENTS.MEDIA_CHANGED, media)
end

--
-- Get the media queue.
-- TODO: Remove this as it should only be accessed internally?
--
-- @return table	Media queue.
--
function MEDIAPLAYER:GetMediaQueue()
	return self._Queue
end

--
-- Clear the media queue.
--
function MEDIAPLAYER:ClearMediaQueue()
	self._Queue = {}
	if SERVER then
		self:BroadcastUpdate()
	end
end

--
-- Get whether the media queue is empty.
--
-- @return boolean	Whether the queue is empty
--
function MEDIAPLAYER:IsQueueEmpty()
	return #self._Queue == 0
end

function MEDIAPLAYER:GetQueueLimit( bNetLength )
	local limit = MediaPlayer.Cvars.QueueLimit:GetInt()

	if bNetLength then
		limit = math.max( CeilPower2( limit ) * 0.5, 2 )
	end

	return limit
end

function MEDIAPLAYER:GetQueueRepeat()
	return self._QueueRepeat
end

function MEDIAPLAYER:SetQueueRepeat( shouldRepeat )
	self._QueueRepeat = shouldRepeat
end

function MEDIAPLAYER:GetQueueShuffle()
	return self._QueueShuffle
end

function MEDIAPLAYER:SetQueueShuffle( shouldShuffle )
	self._QueueShuffle = shouldShuffle

	if SERVER then
		if shouldShuffle then
			self:ShuffleQueue()
		else
			self:SortQueue()
		end
	end
end

function MEDIAPLAYER:GetQueueLocked()
	return self._QueueLocked
end

function MEDIAPLAYER:SetQueueLocked( locked )
	self._QueueLocked = locked
end

---
-- Called when the queue is updated; emits a change event.
--
function MEDIAPLAYER:QueueUpdated()
	if SERVER then
		self:SortQueue()
	end

	self:emit( MP.EVENTS.QUEUE_CHANGED, self._Queue )
end

--
-- Add media to the queue.
--
-- @param media		Media object.
--
function MEDIAPLAYER:AddMedia( media )
	if not media then return end

	if SERVER then
		-- cache the time the media has been queued for sorting purposes
		media:SetMetadataValue("queueTime", RealTime())
	end

	table.insert( self._Queue, media )
end

--
-- Event called when media should begin playing.
--
-- @param media		Media object to be played.
--
function MEDIAPLAYER:OnMediaStarted( media )

	media = media or self:CurrentMedia()

	if MediaPlayer.DEBUG then
		print( "MEDIAPLAYER.OnMediaStarted", media )
	end

	if IsValid(media) then

		if SERVER then
			local startTime
			local currentTime = media:CurrentTime()

			if currentTime > 0 then
				startTime = RealTime() - currentTime
			else
				startTime = RealTime()
			end

			media:StartTime( startTime + 1 )
		else
			self._LastMediaUpdate = RealTime()
		end

		if SERVER then
			self:SetPlayerState( MP_STATE_PLAYING )
		end

		self:emit('mediaStarted', media)

	elseif SERVER then
		self:SetPlayerState( MP_STATE_ENDED )
	end

end

--
-- Event called when media should stop playing and the next in the queue
-- should begin.
--
-- @param media		Media object to stop.
--
function MEDIAPLAYER:OnMediaFinished( media )

	media = media or self:CurrentMedia()

	if MediaPlayer.DEBUG then
		print( "MEDIAPLAYER.OnMediaFinished", media )
	end

	if SERVER then
		self:SetPlayerState( MP_STATE_ENDED )
	end

	self._Media = nil

	if CLIENT and IsValid(media) then
		media:Stop()
	end

	self:emit('mediaFinished', media)

	if SERVER then
		if media and self:GetQueueRepeat() then
			media:ResetTime()
			self:AddMedia( media )
		end

		self:NextMedia()
	end

end

--
-- Event called when the media player is to be removed/destroyed.
--
function MEDIAPLAYER:Remove()
	MediaPlayer.Destroy( self )
	self._removed = true

	if SERVER then

		-- Remove all listeners
		for _, ply in pairs( self._Listeners ) do
			-- TODO: it's probably better not to send individual net messages
			-- for each player removed.
			self:RemoveListener( ply )
		end

	else

		local media = self:CurrentMedia()

		if IsValid(media) then
			media:Stop()
		end

	end
end

function MEDIAPLAYER:GetSupportedServiceIDs()

	local serviceIDs = table.Copy( MediaPlayer.GetSupportedServiceIDs() )

	if self.ServiceWhitelist then
		local tbl = {}

		for _, id in ipairs(serviceIDs) do
			if table.HasValue( self.ServiceWhitelist, id ) then
				table.insert( tbl, id )
			end
		end

		serviceIDs = tbl
	end

	return serviceIDs

end

--PATH addons/media_player/lua/mediaplayer/services/base/cl_init.lua:
include "shared.lua"

function SERVICE:Volume( volume )
	if volume then
		self._volume = tonumber(volume) or self._volume
	end
	return self._volume
end

function SERVICE:IsPaused()
	return self._PauseTime ~= nil
end

function SERVICE:Stop()
	self._playing = false
	self:emit('stop')
end

function SERVICE:PlayPause()
	if self:IsPlaying() then
		self:Pause()
	else
		self:Play()
	end
end

function SERVICE:Sync()
	-- Implement this in timed services
end

function SERVICE:NetWriteRequest()
	-- Send any additional net data here
end

function SERVICE:OnMousePressed( x, y )
end

function SERVICE:OnMouseWheeled( scrollDelta )
end

function SERVICE:IsMouseInputEnabled()
	return false
end

--PATH addons/media_player/lua/mp_menu/horizontal_list.lua:
local PANEL = {}

function PANEL:Init()
	DPanelList.Init( self )

	self:EnableVerticalScrollbar( false )
	self:EnableHorizontal( true )
	self:SetAutoSize( true )
end

function PANEL:Rebuild()

	local OffsetX, OffsetY = 0, 0
	self.m_iBuilds = self.m_iBuilds + 1;

	self:CleanList()

	if ( self.Horizontal ) then

		local x, y = self.Padding, self.Padding;
		for k, panel in pairs( self.Items ) do

			if ( panel:IsVisible() ) then

				local OwnLine = (panel.m_strLineState and panel.m_strLineState == "ownline");

				local w = panel:GetWide()
				local h = panel:GetTall()

				local breakLine = ( not self.m_bSizeToContents and
					( x > self.Padding ) and
					(x + w > self:GetWide() or OwnLine) )

				if breakLine then

					x = self.Padding
					y = y + h + self.Spacing

				end

				if ( self.m_fAnimTime > 0 and self.m_iBuilds > 1 ) then
					panel:MoveTo( x, y, self.m_fAnimTime, 0, self.m_fAnimEase )
				else
					panel:SetPos( x, y )
				end

				x = x + w + self.Spacing

				OffsetX = x
				OffsetY = y + h + self.Spacing

				if ( OwnLine ) then

					x = self.Padding
					y = y + h + self.Spacing

				end

			end

		end

	else

		for k, panel in pairs( self.Items ) do

			if ( panel:IsVisible() ) then

				if ( self.m_bNoSizing ) then
					panel:SizeToContents()
					if ( self.m_fAnimTime > 0 and self.m_iBuilds > 1 ) then
						panel:MoveTo( (self:GetCanvas():GetWide() - panel:GetWide()) * 0.5, self.Padding + OffsetY, self.m_fAnimTime, 0, self.m_fAnimEase )
					else
						panel:SetPos( (self:GetCanvas():GetWide() - panel:GetWide()) * 0.5, self.Padding + OffsetY )
					end
				else
					panel:SetSize( self:GetCanvas():GetWide() - self.Padding * 2, panel:GetTall() )
					if ( self.m_fAnimTime > 0 and self.m_iBuilds > 1 ) then
						panel:MoveTo( self.Padding, self.Padding + OffsetY, self.m_fAnimTime, self.m_fAnimEase )
					else
						panel:SetPos( self.Padding, self.Padding + OffsetY )
					end
				end

				-- Changing the width might ultimately change the height
				-- So give the panel a chance to change its height now,
				-- so when we call GetTall below the height will be correct.
				-- True means layout now.
				panel:InvalidateLayout( true )

				OffsetY = OffsetY + panel:GetTall() + self.Spacing

			end

		end

		OffsetY = OffsetY + self.Padding

	end

	self:GetCanvas():SetWide( OffsetX + self.Padding - self.Spacing )
	self:GetCanvas():SetTall( OffsetY + self.Padding - self.Spacing )

	-- Although this behaviour isn't exactly implied, center vertically too
	if ( self.m_bNoSizing and self:GetCanvas():GetTall() < self:GetTall() ) then
		self:GetCanvas():SetPos( 0, (self:GetTall()-self:GetCanvas():GetTall()) * 0.5 )
	end

end

function PANEL:PerformLayout()

	local Wide = self:GetWide()
	local YPos = 0

	self:Rebuild()

	if self.VBar and not m_bSizeToContents then

		self.VBar:SetPos( self:GetWide() - 13, 0 )
		self.VBar:SetSize( 13, self:GetTall() )
		self.VBar:SetUp( self:GetTall(), self.pnlCanvas:GetTall() )
		YPos = self.VBar:GetOffset()

		if ( self.VBar.Enabled ) then Wide = Wide - 13 end

	end

	if self:GetAutoSize() then

		self:SetWide( self.pnlCanvas:GetWide() )
		self:SetTall( self.pnlCanvas:GetTall() )
		self.pnlCanvas:SetPos( 0, 0 )

	else

		self.pnlCanvas:SetPos( 0, YPos )
		self.pnlCanvas:SetWide( Wide )

	end

end

derma.DefineControl( "DHorizontalList", "", PANEL, "DPanelList" )

--PATH addons/ukrp_main_content/lua/autorun/modeli.lua:
player_manager.AddValidModel( "tanjiro", "models/player/tanjiro.mdl" );
list.Set( "PlayerOptionsModel", "tanjiro", "models/player/tanjiro.mdl" );

player_manager.AddValidModel( "ryad1111111", "models/player/afu_security_heavy.mdl" );
list.Set( "PlayerOptionsModel", "ryad1111111", "models/player/afu_security_heavy.mdl" );

player_manager.AddValidModel( "gen22222222222", "models/player/afu_security_light.mdl" );
list.Set( "PlayerOptionsModel", "gen22222222222", "models/player/afu_security_light.mdl" );

player_manager.AddValidModel( "police111111111111", "models/kerry/detective/male_08.mdl" );
list.Set( "PlayerOptionsModel", "police111111111111", "models/kerry/detective/male_08.mdl" );

player_manager.AddValidModel( "police1111111111112", "models/kerry/detective/male_07.mdl" );
list.Set( "PlayerOptionsModel", "police1111111111112", "models/kerry/detective/male_07.mdl" );

player_manager.AddValidModel( "police1111111111113", "models/kerry/detective/male_06.mdl" );
list.Set( "PlayerOptionsModel", "police1111111111113", "models/kerry/detective/male_06.mdl" );

player_manager.AddValidModel( "police1111111111114", "models/kerry/detective/male_04.mdl" );
list.Set( "PlayerOptionsModel", "police1111111111114", "models/kerry/detective/male_04.mdl" );

player_manager.AddValidModel( "police1111111111115", "models/player/ssu_security_light.mdl" );
list.Set( "PlayerOptionsModel", "police1111111111115", "models/player/ssu_security_light.mdl" );
--PATH addons/__main_only_1st/lua/autorun/necoarc.lua:
--Add Playermodel
player_manager.AddValidModel( "Neco Arc", "models/mocha/necoarc/necoarc.mdl" )
player_manager.AddValidHands( "Neco Arc", "models/mocha/necoarc/necoarc_arms.mdl", 0, "0000000" )
--PATH addons/____onyx_framework_2/lua/onyx/framework/libs/sh_net_extension.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

23/04/2023

--]]

onyx.net = {}

function onyx.net.WriteTable(tbl)
    assert(tbl, 'missing table')
    assert(istable(tbl), 'the provided argument must be a table')

    local encoded = pon.encode(tbl)
    local len = #encoded

    net.WriteUInt(len, 32)
    net.WriteData(encoded, len)
end

function onyx.net.ReadTable()
    local len = net.ReadUInt(32)
    local data = net.ReadData(len)
    local success, decoded = pcall(pon.decode, data)

    if (success) then
        return decoded
    end

    return {}
end

function onyx.net.Send(ply)
    if (ply) then
        net.Send(ply)
    else
        net.Broadcast()
    end
end

if (SERVER) then
    local function GetHookName(ply)
        return ('onyx.NetReadyCheck_' .. ply:SteamID64())
    end

    hook.Add('PlayerInitialSpawn', 'onyx.GetNetworkReady', function(ply)
        hook.Add('SetupMove', GetHookName(ply), function(ply2, mvd, cmd)
            if ply == ply2 and not cmd:IsForced() then
                hook.Remove('SetupMove', GetHookName(ply2))
                hook.Run('onyx.PlayerNetworkReady', ply2)
                hook.Run('onyx.PostPlayerNetworkReady', ply2) -- required for netvar library and etc.
                ply2:SetVar('onyx_NetReady', true)
            end
        end)
    end)
end
--PATH addons/____onyx_framework_2/lua/onyx/framework/libs/sh_netvar.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/05/2023

--]]

--[[------------------------------
Requires `sh_net_extension.lua`, though doesn't need to be loaded before that
--------------------------------]]

if (SERVER) then
    util.AddNetworkString('onyx.netvar:Sync')
    util.AddNetworkString('onyx.netvar:Clear')
    util.AddNetworkString('onyx.netvar:DeleteEntity')
end

onyx.netvar = onyx.netvar or {}
onyx.netvar.list = onyx.netvar.list or {}
onyx.netvar.data = onyx.netvar.data or {}
onyx.netvar.public = onyx.netvar.public or {}

local netvar = onyx.netvar
local types = {
    [TYPE_BOOL] = {write = net.WriteBool, read = net.ReadBool},
    [TYPE_NUMBER] = {
        write = function(value, bits, unsigned)
            if (unsigned) then
                net.WriteUInt(value, bits)
            else
                net.WriteInt(value, bits)
            end
        end,
        read = function(bits, unsigned)
            if (unsigned) then
                return net.ReadUInt(bits)
            else
                return net.ReadInt(bits)
            end
        end
    },
    [TYPE_STRING] = {
        write = net.WriteString,
        read = net.ReadString,
    },
    [TYPE_TABLE] = {
        write = net.WriteTable,
        read = net.ReadTable,
    }
}

local function syncNetVar(entIndex, data, id, value, receiver)
    local write = types[data.type].write

    net.Start('onyx.netvar:Sync')

    net.WriteUInt(entIndex, 16)
    net.WriteString(id)
    write(value, data.bits, data.unsigned)

    -- could be invalid player
    if (receiver == nil) then
        net.Broadcast()
    else
        -- 100% is a player
        net.Send(receiver)
    end
end

function netvar:Register(id, data)
    data.id = id
    self.list[id] = data

    if (data.public) then
        self.public[id] = value
    end
end

do
    local ENTITY = FindMetaTable('Entity')

    function ENTITY:onyx_SetNetVar(id, value)
        if (CLIENT) then return end

        assert(isstring(id), Format('bad argument #1 to `onyx_SetNetVar` (expected string, got %s)', type(id)))
        assert(value ~= nil, 'bad argument #2 to `onyx_SetNetVar` (expected anything, got nil)')

        local data = netvar.list[id]

        assert(data, string.format('trying to set invalid netvar \'%s\' to %s', tostring(id), tostring(self)))

        local entIndex = self:EntIndex()

        netvar.data[entIndex] = netvar.data[entIndex] or {}
        netvar.data[entIndex][id] = value

        syncNetVar(entIndex, data, id, value, (not data.public and self or nil))
    end

    function ENTITY:onyx_ClearNetVar(id)
        if (CLIENT) then return end

        local entIndex = self:EntIndex()

        if (not netvar.data[entIndex]) then return end

        local data = netvar.list[id]

        netvar.data[entIndex][id] = nil

        net.Start('onyx.netvar:Clear')

        net.WriteUInt(entIndex, 16)
        net.WriteString(id)

        if (data.public) then
            net.Broadcast()
        else
            net.Send(self) -- must be a player
        end
    end

    function ENTITY:onyx_GetNetVar(id, fallback)
        local storage = netvar.data[self:EntIndex()]
        if (storage) then
            return (storage[id] or fallback)
        end
    end
end

if (CLIENT) then
    net.Receive('onyx.netvar:Sync', function(len)
        local entIndex = net.ReadUInt(16)

        local id = net.ReadString()
        local data = netvar.list[id]
        if not data then return end
        local read = types[data.type].read
        local value = read(data.bits, data.unsigned)

        netvar.data[entIndex] = netvar.data[entIndex] or {}
        netvar.data[entIndex][id] = value
    end)
else
    hook.Add('onyx.PlayerNetworkReady', 'onyx.netvar', function(ply)
        for entIndex, storage in pairs(netvar.data) do

            local isClient = (ply:EntIndex() == entIndex)

            for id, value in pairs(storage) do
                local data = netvar.list[id]
                if (data.public or isClient) then
                    syncNetVar(entIndex, data, id, value, ply)
                end
            end

        end
    end)
end

if (SERVER) then
    hook.Add('EntityRemoved', 'onyx.netvar', function(ent)
        -- lol it gets called by engine on clientside for all entities after data has been synced
        local entIndex = ent:EntIndex()

        netvar.data[entIndex] = nil

        net.Start('onyx.netvar:DeleteEntity')
            net.WriteUInt(entIndex, 16)
        net.Broadcast()
    end)
else
    net.Receive('onyx.netvar:DeleteEntity', function(len)
        local entIndex = net.ReadUInt(16)

        netvar.data[entIndex] = nil
    end)

    net.Receive('onyx.netvar:Clear', function(len)
        local entIndex = net.ReadUInt(16)
        local netvarID = net.ReadString()

        if (netvar.data[entIndex]) then
            netvar.data[entIndex][netvarID] = nil
        end
    end)
end


-- print(Entity(1):EntIndex())
-- PrintTable(netvar.data)
-- Entity(1):onyx_SetNetVar('store_loaded', true)
--PATH addons/____onyx_framework_2/lua/onyx/framework/core/cl_npc_label.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/12/2023

--]]
onyx.npc = onyx.npc or {}

local renderDistance = 512 ^ 2
local font, colorAccent, colorPrimary
local vectorOffset = Vector(0, 0, 78)
local vectorOffsetAnimated = Vector(0, 0, 0)

local function drawInfo( text )
    surface.SetFont(font)
    local textw, texth = surface.GetTextSize(text)
    local margin = 20
    local boxw, boxh = textw + margin * 2, texth + margin * 2
    local o = 3

    draw.RoundedBox(16, -boxw * .5, -boxh * .5, boxw, boxh, colorAccent)
    draw.RoundedBox(16, -boxw * .5 + o, -boxh * .5 + o, boxw - o * 2, boxh - o * 2, colorPrimary)
    draw.SimpleText(text, font, 2, 2, color_black, 1, 1)
    draw.SimpleText(text, font, 0, 0, color_white, 1, 1)
end

function onyx.npc.label( ent, text )
    if not font or not colorAccent or not colorPrimary then
        font = onyx.FontNoScale( 'Comfortaa', 64 )
        colorAccent = onyx:Config('colors.accent')
        colorPrimary = onyx:Config('colors.primary')
    end

    vectorOffsetAnimated.z = math.sin(CurTime()) * 1

    local pos = ent:GetPos() + vectorOffset + vectorOffsetAnimated
    local ang = Angle(0, EyeAngles().y - 90, 90)

    if (pos:DistToSqr(LocalPlayer():GetPos()) > renderDistance) then
        return
    end

    cam.Start3D2D(pos, ang, .05)
    drawInfo( text )
    cam.End3D2D()
end
--PATH addons/____onyx_framework_2/lua/onyx/ui/libs/cl_font.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

15/04/2022

--]]

onyx.fonts = {}

local string_Explode = string.Explode
local math_ceil = math.ceil
local surface_CreateFont = surface.CreateFont
local tonumber = tonumber

local function createFont(font, size, parameters, initialSize)
    local name = 'onyx.' .. font .. size .. util.CRC(parameters or '')

    if onyx.fonts[name] then
        return name
    end

    local data = {
        font = font,
        size = size,
        extended = true,
        initialSize = initialSize
    }

    if parameters then
        local tblParameters = string_Explode(';', parameters)
        for _, str in ipairs(tblParameters) do
            local parts = string_Explode(':', str)
            local key, val = parts[1], parts[2]
            if tonumber(val) then
                data[key] = tonumber(val)
            else
                if val == 'true' then
                    data[key] = true
                else
                    data[key] = false
                end
            end
        end
    end

    onyx.fonts[name] = data

    surface_CreateFont(name, data)

    return name
end

local fetchFont do
    local aliases = {}

    function fetchFont(family)
        local overridedFont = hook.Call('onyx.ui.OverrideFont', nil, family)
        return (overridedFont or aliases[family] or family)
    end

    local function createAlias(alias, real)
        aliases[alias] = real
    end

    createAlias('Averta', 'AvertaStd-Regular')
    createAlias('Averta Bold', 'AvertaStd-Bold')
    createAlias('Averta Black', 'AvertaStd-Black')
end

function onyx.Font(pattern, parameters)
    local parts = string_Explode('@', pattern)
    local family, size = fetchFont(parts[1]), tonumber(parts[2])
    local scaledSize = math_ceil(size / 900 * ScrH())

    return createFont(family, scaledSize, parameters, size)
end

function onyx.FontNoScale(pattern, size, parameters)
    local family

    if size then
        family = fetchFont(pattern)
    else
        local parts = string_Explode('@', pattern)

        family, size = fetchFont(parts[1]), parts[2]
    end

    return createFont(family, size, parameters)
end

hook.Add('OnScreenSizeChanged', 'onyx.font.Recreate', function()
    for name, data in pairs(onyx.fonts) do
        if data.initialSize then
            data.size = math_ceil(data.initialSize / 900 * ScrH())
            surface_CreateFont(name, data)
        end
    end
end)
--PATH addons/____onyx_framework_2/lua/onyx/ui/libs/cl_util.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

do
    local Lerp = Lerp
    local Color = Color
    local Clamp = math.Clamp
    function onyx.LerpColor(speed, from, to)
        local r = Lerp(speed, from.r, to.r)
        local g = Lerp(speed, from.g, to.g)
        local b = Lerp(speed, from.b, to.b)
        local a = Lerp(speed, from.a, to.a)

        return Color(r, g, b, a)
    end

    function onyx.CopyColor(color)
        assert(color, 'missing color')
        return Color(color.r, color.g, color.b, color.a)
    end

    function onyx.ColorBetween(clr1, clr2, fraction)
        fraction = fraction or .5
        local r = Lerp(fraction, clr1.r, clr2.r)
        local g = Lerp(fraction, clr1.g, clr2.g)
        local b = Lerp(fraction, clr1.b, clr2.b)
        return Color(r, g, b)
    end

    function onyx.OffsetColor(color, offset)
        assert(color, 'missing color')

        offset = offset or 0

        local r = Clamp(color.r + offset, 0, 255)
        local g = Clamp(color.g + offset, 0, 255)
        local b = Clamp(color.b + offset, 0, 255)

        return Color(r, g, b)
    end

    function onyx.ColorEditHSV(color, hue, saturation, value)
        local h, s, v = ColorToHSV(color)
        return HSVToColor(hue or h, math.Clamp(saturation or s, 0, 1), math.Clamp(value or v, 0, 1))
    end

    function onyx.GetOppositeAccentColor()
        local color = onyx:Config('colors.accent')
        local h, s, v = ColorToHSV(color)
        return onyx.ColorEditHSV(color, (h + 180) % 360)
    end
end

do
    local matBlur = Material('pp/blurscreen')

    local UpdateScreenEffectTexture = render.UpdateScreenEffectTexture
    local DrawTexturedRect = surface.DrawTexturedRect
    local SetMaterial = surface.SetMaterial
    local SetDrawColor = surface.SetDrawColor

    function onyx.DrawBlurExpensive(panel, amount)
        local x, y = panel:LocalToScreen(0, 0)
        local scrW, scrH = ScrW(), ScrH()

        SetDrawColor(255, 255, 255)
        SetMaterial(matBlur)

        for i = 1, 3 do
            matBlur:SetFloat('$blur', (i / 3) * (amount or 6))
            matBlur:Recompute()
            UpdateScreenEffectTexture()
            DrawTexturedRect(x * -1, y * -1, scrW, scrH)
        end
    end
end

do
    local DrawTexturedRectRotated = surface.DrawTexturedRectRotated
    local DrawTexturedRect = surface.DrawTexturedRect
    local SetDrawColor = surface.SetDrawColor
    local SetMaterial = surface.SetMaterial

    function onyx.DrawMaterial(mat, x, y, w, h, color)
        color = color or color_white

        SetMaterial(mat)
        SetDrawColor(color)
        DrawTexturedRect(x, y, w, h)
    end

    function onyx.DrawMaterialRotated(mat, x, y, w, h, angle, color)
        color = color or color_white
        angle = angle or 0

        SetMaterial(mat)
        SetDrawColor(color)
        DrawTexturedRectRotated(x + w * .5, y + h * .5, w, h, angle)
    end
end

function onyx.DrawTextInBox(text, font, x, y, roundness, paddingX, paddingY, textColor, boxColor, alignmentX, alignmentY)
    alignmentX = alignmentX or 1
    alignmentY = alignmentY or 1

    surface.SetFont(font)
    local textW, textH = surface.GetTextSize(text)

    textW = textW + paddingX * 2
    textH = textH + paddingY * 2

    draw.RoundedBox(roundness, x - textW * .5, y - textH * .5, textW, textH, boxColor)
    draw.SimpleText(text, font, x, y, textColor, alignmentX, alignmentY)
end

do
    local matGradientToBottom = Material('vgui/gradient-u')
    local matGradientToTop = Material('vgui/gradient-d')
    local matGradientToLeft = Material('vgui/gradient-l')
    local matGradientToRight = Material('vgui/gradient-r')

    local SetMaterial = surface.SetMaterial
    local SetDrawColor = surface.SetDrawColor
    local DrawTexturedRect = surface.DrawTexturedRect

    function onyx.DrawMatGradient(x, y, w, h, dir, color)
        if dir == BOTTOM then
            SetMaterial(matGradientToBottom)
        elseif (dir == LEFT) then
            SetMaterial(matGradientToLeft)
        elseif (dir == RIGHT) then
            SetMaterial(matGradientToRight)
        else
            SetMaterial(matGradientToTop)
        end
        SetDrawColor(color)
        DrawTexturedRect(x, y, w, h)
    end
end

function onyx.GetTextSize(text, font)
    surface.SetFont(font)
    return surface.GetTextSize(text)
end

do
    local ScrW = ScrW
    local ScrH = ScrH
    local Round = math.Round

    function onyx.ScaleWide(w, ref)
        ref = ref or 1600
        return Round(w / ref * ScrW())
    end

    function onyx.ScaleTall(h, ref)
        ref = ref or 900
        return Round(h / ref * ScrH())
    end
end

--[[------------------------------
SHAPES
--------------------------------]]
do
    local rad = math.rad
    local sin = math.sin
    local cos = math.cos
    local Round = math.Round

    function onyx.CalculateCircle(x0, y0, radius, vertices)
        local tbl, count = {}, 0
        local step = Round(360 / vertices)

        for ang = 0, 360, step do
            local rad = rad(ang)
            local cos = cos(rad)
            local sin = sin(rad)

            local x = x0 + radius * cos
            local y = y0 + radius * sin

            count = count + 1
            tbl[count] = {x = x, y = y}
        end

        return tbl
    end
end

do
    local rad = math.rad
    local sin = math.sin
    local cos = math.cos
    local Round = math.Round

    local insert = table.insert
    local table_Add = table.Add

    local function calculateCircle(x0, y0, startAngle, angleLength, radius, vertices, addCenter)
        local startAngle = startAngle - 90
        local vertices = vertices or 32
        local step = angleLength / vertices
        local tbl, count = {}, 0

        if (addCenter) then
            tbl[1] = {x = x0, y = y0}
            count = 1
        end

        for i = 0, vertices do
            local ang = startAngle + i * step
            local rad = rad(ang)
            local sin = sin(rad)
            local cos = cos(rad)

            local x = x0 + radius * cos
            local y = y0 + radius * sin

            count = count + 1
            tbl[count] = {x = x, y = y}
        end

        return tbl
    end
    onyx.CalculateArc = calculateCircle

    -- Custom
    function onyx.CalculateRoundedBoxEx(r, x, y, w, h, ruCorner, rbCorner, ldCorner, lbCorner)
        r = math.ceil(math.min(r, h * 0.5))

        if (r == 0) then
            ruCorner = false
            rbCorner = false
            ldCorner = false
            lbCorner = false
        end

        local vertices = {}

        insert(vertices, {x = x + r, y = y})

        -- Right Upper Corner
        if (ruCorner) then
            insert(vertices, {x = x + w - r, y = y})
            table_Add(vertices, calculateCircle(x + w - r, y + r, 0, 90, r, r))
            insert(vertices, {x = x + w, y = y + r})
        else
            insert(vertices, {x = x + w, y = y})
        end

        -- Right Bottom Corner
        if (rbCorner) then
            insert(vertices, {x = x + w, y = y + h - r})
            table_Add(vertices, calculateCircle(x + w - r, y + h - r, 90, 90, r, r))
            insert(vertices, {x = x + w - r, y = y + h})
        else
            insert(vertices, {x = x + w, y = y + h})
        end

        -- Left Bottom Corner
        if (ldCorner) then
            insert(vertices, {x = x + r, y = y + h})
            table_Add(vertices, calculateCircle(x + r, y + h - r, 180, 90, r, r))
            insert(vertices, {x = x, y = y + h - r})
        else
            insert(vertices, {x = x, y = y + h})
        end

        -- Left Upper Corner
        if (lbCorner) then
            insert(vertices, {x = x, y = y + r})
            table_Add(vertices, calculateCircle(x + r, y + r, 270, 90, r, r))
            insert(vertices, {x = x + r, y = y})
        else
            insert(vertices, {x = x, y = y})
        end

        return vertices
    end

    function onyx.CalculateRoundedBox(r, x, y, w, h)
        return onyx.CalculateRoundedBoxEx(r, x, y, w, h, true, true, true, true)
    end
end

function onyx.DrawPoly(poly, color, material)
    if (not poly or #poly < 1) then
        return
    end

    if (material) then
        surface.SetMaterial(material)
    else
        draw.NoTexture()
    end

    surface.SetDrawColor(color or color_white)
    surface.DrawPoly(poly)
end

--[[------------------------------
MASKING
--------------------------------]]
function onyx.MaskFn(funcMask, funcDraw)
    render.SetStencilWriteMask(255)
    render.SetStencilTestMask(255)
    render.SetStencilReferenceValue(0)
    render.SetStencilPassOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_KEEP)
    render.ClearStencil()

    render.SetStencilEnable(true)
    render.SetStencilReferenceValue(1)
    render.SetStencilCompareFunction(STENCIL_NEVER)
    render.SetStencilFailOperation(STENCIL_REPLACE)

    funcMask()

    render.SetStencilCompareFunction(STENCIL_EQUAL)
    render.SetStencilFailOperation(STENCIL_KEEP)

    funcDraw()

    render.SetStencilEnable(false)
end

function onyx.InverseMaskFn(funcMask, funcDraw)
    render.SetStencilWriteMask(255)
    render.SetStencilTestMask(255)
    render.SetStencilReferenceValue(0)
    render.SetStencilPassOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_KEEP)
    render.ClearStencil()

    render.SetStencilEnable(true)
    render.SetStencilReferenceValue(1)
    render.SetStencilCompareFunction(STENCIL_NEVER)
    render.SetStencilFailOperation(STENCIL_REPLACE)

    funcMask()

    render.SetStencilCompareFunction(STENCIL_GREATER)
    render.SetStencilFailOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_KEEP)

    funcDraw()

    render.SetStencilEnable(false)
end

function onyx.DrawWithPolyMask(poly, funcDraw)
    if (not istable(poly)) then return end

    onyx.MaskFn(function()
        draw.NoTexture()
        surface.SetDrawColor(color_white)
        surface.DrawPoly(poly)
    end, funcDraw)
end
--PATH addons/____onyx_framework_2/lua/onyx/ui/core/cl_query.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/01/2024

--]]

function onyx.SimpleQuery(title, desc, showTextEntry, acceptCallback, acceptText, cancelCallback, cancelText)
    local margin = onyx.ScaleTall(25)
    local space = onyx.ScaleTall(10)

    local frame = vgui.Create('onyx.Frame')
    frame:SetTitle(title)
    frame:SetSize(ScrW() * .33, ScrH() * (showTextEntry and .225 or .175))
    frame:Center()
    frame:MakePopup()
    frame:ShowCloseButton(false)
    frame:Focus(true)

    local content = frame:Add('Panel')
    content:Dock(FILL)
    content:DockMargin(margin, margin, margin, margin)

    local lblDesc = content:Add('onyx.Label')
    lblDesc:SetContentAlignment(5)
    lblDesc:Dock(TOP)
    lblDesc:Font('Comfortaa@20')
    lblDesc:SetText(desc)
    lblDesc:SetAutoStretchVertical(true)
    lblDesc:DockMargin(0, 0, 0, space)
    frame.lblDesc = lblDesc

    local textEntry = content:Add('onyx.TextEntry')
    textEntry:Dock(TOP)
    textEntry:SetPlaceholderText('')
    textEntry:SetTall(onyx.ScaleTall(30))
    textEntry:DockMargin(0, 0, 0, space)
    textEntry:SetVisible(showTextEntry)
    frame.textEntry = textEntry

    local btnConfirm, btnDeny

    local footer = content:Add('Panel')
    footer:Dock(BOTTOM)
    footer:SetTall(onyx.ScaleTall(30))
    footer.PerformLayout = function(panel, w, h)
        btnConfirm:SetWide(w * .5)
        btnConfirm:Dock(LEFT)
        btnConfirm:DockMargin(0, 0, onyx.ScaleTall(5), 0)

        btnDeny:Dock(FILL)
        btnDeny:DockMargin(onyx.ScaleTall(5), 0, 0, 0)
    end

    -- localized above
    btnConfirm = footer:Add('onyx.Button')
    btnConfirm:SetText(acceptText or 'CONFIRM')
    btnConfirm:SetMasking(true)
    btnConfirm:SetGradientColor(Color(131, 255, 133))
    btnConfirm:SetColorIdle(Color(59, 161, 61))
    btnConfirm:Font('Comfortaa Bold@16')
    btnConfirm.DoClick = function(panel)
        if (acceptCallback(textEntry:GetValue()) ~= false) then
            frame:Remove()
        end
    end

    btnDeny = footer:Add('onyx.Button')
    btnDeny:SetText(cancelText or 'CANCEL')
    btnDeny:SetMasking(true)
    btnDeny:SetGradientColor(Color(255, 131, 131))
    btnDeny:SetColorIdle(Color(161, 59, 59))
    btnDeny:Font('Comfortaa Bold@16')
    btnDeny.DoClick = function(panel)
        frame:Remove()
        if (cancelCallback) then
            cancelCallback()
        end
    end

    return frame
end

function onyx.ChoosePlayer(title, desc, func, bIncludeClient, filter)
    local margin = onyx.ScaleTall(25)
    local space = onyx.ScaleTall(10)
    local client = LocalPlayer()
    local players = {}

    local colorTertiary = onyx:Config('colors.tertiary')

    local padding = onyx.ScaleTall(5)

    for _, ply in ipairs(player.GetAll()) do
        if (not bIncludeClient and ply == client) then continue end
        if (filter and not filter(ply)) then continue end

        table.insert(players, ply)
    end

    local frame = vgui.Create('onyx.Frame')
    frame:SetTitle(title)
    frame:SetSize(ScrW() * .25, ScrH() * .5)
    frame:Center()
    frame:MakePopup()
    frame:Focus(true)
    frame.buttons = {}

    local content = frame:Add('onyx.ScrollPanel')
    content:Dock(FILL)
    content:DockMargin(margin, margin, margin, margin)

    local lblDesc = content:Add('onyx.Label')
    lblDesc:SetContentAlignment(5)
    lblDesc:Dock(TOP)
    lblDesc:Font('Comfortaa@20')
    lblDesc:SetText(desc)
    lblDesc:SetAutoStretchVertical(true)
    lblDesc:DockMargin(0, 0, 0, space)
    frame.lblDesc = lblDesc

    for _, ply in ipairs(players) do
        local panel = content:Add('onyx.Button')
        panel:SetText('')
        panel:SetTall(onyx.ScaleTall(40))
        panel:SetColorIdle(onyx:Config('colors.primary'))
        panel:SetColorHover(onyx:Config('colors.secondary'))
        panel:DockPadding(padding, padding, padding, padding)
        panel.colorTertiary = colorTertiary
        panel.Paint = function(panel, w, h)
            draw.RoundedBox(8, 0, 0, w, h, panel.colorTertiary)
            draw.RoundedBox(8, 1, 1, w - 2, h - 2, panel.backgroundColor)
        end
        panel.DoClick = function()
            frame:Remove()
            if (func and IsValid(ply)) then
                func(ply)
            end
        end

        table.insert(frame.buttons, panel)

        local avatar = panel:Add('onyx.RoundedAvatar')
        avatar:Dock(LEFT)
        avatar:SetWide(panel:GetTall() - padding * 2)
        avatar:SetPlayer(ply, 64)
        avatar:DockMargin(0, 0, onyx.ScaleTall(7.5), 0)

        local lblTitle = panel:Add('onyx.Label')
        lblTitle:SetText(ply:Name())
        lblTitle:Font('Comfortaa Bold@16')
        lblTitle:Dock(TOP)
        lblTitle:SetTall(avatar:GetWide() * 0.5)
        panel.lblTitle = lblTitle

        local plyTeam = ply:Team()
        local lblSubTitle = panel:Add('onyx.Label')
        lblSubTitle:SetText(team.GetName(plyTeam))
        lblSubTitle:SetTextColor(team.GetColor(plyTeam))
        lblSubTitle:Font('Comfortaa@16')
        lblSubTitle:Dock(TOP)
        panel.lblSubTitle = lblSubTitle
    end

    return frame
end
--PATH addons/____onyx_framework_2/lua/onyx/ui/traits/cl_click.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

16/04/2022

--]]

local TRAIT = {}

AccessorFunc(TRAIT, 'm_bDepressed', 'Depressed', FORCE_BOOL)
AccessorFunc(TRAIT, 'm_bDisabled', 'Disabled', FORCE_BOOL)

--[[------------------------------
Makes possible to make any panel clickable
--------------------------------]]

function TRAIT:Init()
    self:SetDepressed(false)
    self:SetCursor('hand')
    self:SetMouseInputEnabled(true)

    --[[------------------------------
    Override default, not add
    Useful when is called for DLabel
    --------------------------------]]
    self.OnMousePressed = function(self, code)
        if not self:GetDisabled() then
            self:SetDepressed(true)
            self:Call('OnPress', nil, code)
        end
    end

    self.OnMouseReleased = function(self, code)
        if self:GetDisabled() then return end

        if (CurTime() - (onyx.menuButtonPressTime or 0) > .2) then
            self:Call('OnRelease', nil, code)
        
            if code == MOUSE_LEFT then
                self:Call('DoClick')
            elseif code == MOUSE_RIGHT then
                self:Call('DoRightClick')
            else
                self:Call('DoMiddleClick')
            end
        end

        self:SetDepressed(false)
    end
end

function TRAIT:SetDisabled(bool)
    self.m_bDisabled = bool

    if bool then
        self:SetCursor('no')
        self:Call('OnDisabled', nil)
    else
        self:SetCursor('hand')
        self:Call('OnEnabled', nil)
    end
end

local colorCircle = Color(0, 0, 0, 100)
function TRAIT:AddHoverSound()
    self:On('OnCursorEntered', function(panel)
        -- surface.PlaySound('onyx/ui/on_mouseover/mouse_over1.wav')
        -- surface.PlaySound('onyx/ui/on_mouseover/mouse_over2.wav')
        -- surface.PlaySound('onyx/ui/on_mouseover/mouse_over5.wav')
        surface.PlaySound('onyx/ui/on_mouseover/pop_mouse_over.wav')
        -- surface.PlaySound('onyx/ui/on_mouseover/sub_bass_mouseover.wav')
    end)

    self:On('OnRelease', function(panel)
        -- surface.PlaySound('onyx/ui/on_click/round_pop_click.wav')
        -- surface.PlaySound('onyx/ui/on_click/round_pop_click1.wav')
        -- surface.PlaySound('onyx/ui/on_click/pop_click.wav')
        -- surface.PlaySound('onyx/ui/on_click/melodic1_click.wav')
        surface.PlaySound('onyx/ui/on_click/footfall_click.wav')
    end)
end

function TRAIT:AddClickEffect()
    self:On('OnRelease', function(panel)
        local x, y = panel:ScreenToLocal(input.GetCursorPos())
        
        panel.circleAnimFraction = 0
        panel.circleX = x
        panel.circleY = y
        onyx.anim.Create(panel, .25, {
            index = 400,
            target = {
                circleAnimFraction = 1
            }
        })
    end)

    self.circleAnimFraction = 0
    self:InjectEventHandler('PaintOver')
    self:On('PaintOver', function(panel, w, h)
        if (panel.circleAnimFraction > 0 and panel.circleAnimFraction < 1) then
            local circle = onyx.CalculateCircle(panel.circleX, panel.circleY, math.max(w, h) * panel.circleAnimFraction, 32)
            onyx.DrawPoly(circle, ColorAlpha(colorCircle, colorCircle.a * (1 - panel.circleAnimFraction)))
        end
    end)
end

onyx.trait.Register('click', TRAIT, 'Makes it easy to make any panel clickable')
--PATH addons/____onyx_framework_2/lua/onyx/ui/traits/cl_hover.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

18/04/2022

--]]

local TRAIT = {}

AccessorFunc(TRAIT, 'm_colIdle', 'ColorIdle')
AccessorFunc(TRAIT, 'm_colHover', 'ColorHover')
AccessorFunc(TRAIT, 'm_colPressed', 'ColorPressed')
AccessorFunc(TRAIT, 'm_bHoverBlocked', 'HoverBlocked')

local ANIM_DURATION = .2

local function isDisabled(panel)
    if panel.GetDisabled then
        return panel:GetDisabled()
    end
end

local function animColor(panel, targetkey, duration)
    local key = panel.m_ColorKey

    onyx.anim.Create(panel, duration or ANIM_DURATION, {
        index = onyx.anim.ANIM_HOVER,
        target = {
            [key] = panel[targetkey]
        }
    })
end

function TRAIT:SetColorKey(colorKey)
    self.m_ColorKey = colorKey
end

function TRAIT:SetColorIdle(color, offset)
    self.m_colIdle = color
    self[self.m_ColorKey] = onyx.CopyColor(color)

    if (offset) then
        self:SetColorHover(onyx.OffsetColor(color, offset))
    end
end

function TRAIT:OnPress()
    if isDisabled(self) then return end
    if self:GetHoverBlocked() then return end

    animColor(self, 'm_colPressed')
end

function TRAIT:OnRelease()
    if isDisabled(self) then return end
    if self:GetHoverBlocked() then return end
    if self:IsHovered() then
        animColor(self, 'm_colHover')
    end
end

function TRAIT:OnCursorEntered()
    if isDisabled(self) then return end
    if self:GetHoverBlocked() then return end

    animColor(self, 'm_colHover')
end

function TRAIT:OnCursorExited()
    if isDisabled(self) then return end
    if self:GetHoverBlocked() then return end

    animColor(self, 'm_colIdle')
end

onyx.trait.Register('hovercolor', TRAIT)
--PATH addons/____onyx_framework_2/lua/onyx/ui/elements/cl_label.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

local PANEL = {}

local fontCommon = onyx.Font('Comfortaa@16')
local colorCommon = Color(235, 235, 235)

function PANEL:Init()
    self:SetTextColor(colorCommon)
    self:SetFont(fontCommon)
end

function PANEL:CenterText()
    self:SetContentAlignment(5)
end

-- Trying to save my time....

function PANEL:Font(...)
    self:SetFont(onyx.Font(...))
end

function PANEL:Color(r, g, b, a)
    if isnumber(r) then
        self:SetTextColor(Color(r, g, b, a))
    else
        self:SetTextColor(r)
    end
end

function PANEL:Shadow(distance, color)
    distance = distance or 1
    color = color and (isnumber(color) and Color(0, 0, 0, color) or color) or Color(0, 0, 0, 100)

    self:SetExpensiveShadow(distance, color)
end

function PANEL:AlignText(a)
    self:SetContentAlignment(a)
end

function PANEL:GetContentWidth()
    surface.SetFont(self:GetFont())
    return select(1, surface.GetTextSize(self:GetText()))
end

onyx.gui.Register('onyx.Label', PANEL, 'DLabel')
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/core/sh_core.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com
Licensee: 76561198843434426

23/04/2023

--]]

function onyx.creditstore.FormatMoney(number)
    local str = ' '
    local replace = str == nil and '%1,%2' or '%1' .. str .. '%2'

    if ( isnumber( number ) ) then
        number = string.format( '%f', number )
        number = string.match( number, '^(.-)%.?0*$' ) -- Remove trailing zeros
    end

    local index = -1
    while index ~= 0 do number, index = string.gsub( number, '^(-?%d+)(%d%d%d)', replace ) end

    return number
end

onyx.creditstore:RegisterOption('website_url', {
    title = 'Website URL',
    desc = 'URL to deposit credits',
    category = 'General',
    cami = 'onyx_creditstore_edit',
    type = 'string',
    default = 'https://gmodstore.com/'
})

onyx.creditstore:RegisterOption('website_ingame', {
    title = 'Browser',
    desc = 'Use in-game browser to open website URL',
    category = 'General',
    cami = 'onyx_creditstore_edit',
    type = 'bool',
    default = true
})

onyx.creditstore:RegisterOption('cheap_icon_mode', {
    title = 'Cheap Icons',
    desc = 'Use cheap 2D icons for items',
    category = 'Performance',
    cami = 'onyx_creditstore_edit',
    type = 'bool',
    default = false
})

onyx.creditstore:RegisterOption('command', {
    title = 'Command',
    desc = 'The command to open store',
    category = 'General',
    cami = 'onyx_creditstore_edit',
    type = 'string',
    default = 'store'
})

onyx.creditstore:RegisterOption('npc_model', {
    title = 'NPC Model',
    desc = 'The model path',
    category = 'General',
    cami = 'onyx_creditstore_edit',
    type = 'model',
    default = 'models/gman_high.mdl'
})

onyx.creditstore:RegisterOption('npc_label', {
    title = 'NPC Label',
    desc = 'The label above head',
    category = 'General',
    cami = 'onyx_creditstore_edit',
    type = 'string',
    default = 'CREDIT STORE'
})
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/cfg/types/sh_level.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

08/05/2023

--]]

local findMethod, giveXP do
    local methods = {
        ['LevelSystemConfiguration'] = function(ply, amount) -- vrondakis
            ply:addXP(amount, true)
        end,
        ['Sublime'] = function(ply, amount)
            ply:SL_AddExperience(amount, 'Purchase', true)
        end,
        ['DARKRP_ESSENTIALS'] = function(ply, amount)
            ply:AddExperience(amount, 'Purchase')
        end,
        ['GlorifiedLeveling'] = function(ply, amount)
            GlorifiedLeveling.AddPlayerXP(ply, amount)
        end,
    }
    
    methods['DarkRPFoundation'] = methods['DARKRP_ESSENTIALS']
    methods['UUI'] = methods['DARKRP_ESSENTIALS']

    function findMethod(ply)
        -- look through addons
        for name, fn in pairs(methods) do
            if (_G[name]) then
                return fn
            end
        end

        -- player methods
        if (ply.addXP) then
            return function(ply, amount)
                ply:addXP(amount)
            end
        elseif (ply.AddXP) then
            return function(ply, amount)
                ply:AddXP(amount)
            end
        end
    end
    
    function giveXP(ply, amount)
        local func = findMethod(ply)
        if (func) then
            func(ply, amount)
        else
            onyx.creditstore:PrintError('No method found to give XP!')
        end
    end
end

onyx.creditstore:RegisterType('xp', {
    name = 'Experience',
    color = Color(233, 208, 69),
    stacking = true,
    defaultIcon = 'https://i.imgur.com/DiiOnis.png',
    options = {
        ['use'] = {
            removeItem = true,
            check = function(ply, data)
                if (SERVER and findMethod(ply) == nil) then
                    return false, 'no method'
                end
                return true
            end,
            func = function(ply, data)
                local amount = tonumber(data.amount)

                giveXP(ply, amount)
            end
        }
    },
    settings = {
        {
            key = 'amount',
            name = 'AMOUNT',
            desc = 'The amount of XP to give.',
            icon = 'https://i.imgur.com/zgt3zea.png',
            type = 'number',
            placeholder = '100',
            validateOption = function(value)
                if (not isnumber(value)) then
                    return false, 'The amount must be a number!'
                end
                if (value < 1) then
                    return false, 'The amount must be higher than 0!'
                end
                return true
            end
        }
    }
})
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/ui/cl_convert.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/05/2023

--]]

local PANEL = {}

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorTertiary = onyx:Config('colors.tertiary')
local colorGray = onyx:Config('colors.gray')
local colorBetween = onyx.ColorBetween(colorPrimary, colorSecondary)
local colorMoney = Color(66, 184, 76)
local colorNegative = onyx:Config('colors.negative')

local font0 = onyx.Font('Comfortaa Bold@24')
local font1 = onyx.Font('Comfortaa@20')

-- local wimgLongArrow = onyx.wimg.Simple('https://i.imgur.com/Kf3q9WO.png', 'smooth mips')

local wimgCoin = onyx.wimg.Create('creditstore_currency', 'smooth mips')
function PANEL:Init()
    self.mode = onyx.creditstore:GetOptionValue('converter_mode')

    self.rightBlock = self:Add('Panel')
    self.rightBlock.text = onyx.lang:Get('youReceive')
    self.rightBlock.Paint = function(panel, w, h)
        draw.SimpleText(panel.text, font0, w * .5, h * .25, color_white, 1, 1)

        local current = self.combo.current
        if (current > 0) then
            local amt = onyx.creditstore:CalculateConvertResult(current == 2, tonumber(self.entry:GetValue()) or 0)
            if (current == 2) then
                local iconSize = onyx.ScaleTall(14)
                local textAmount = onyx.creditstore.FormatMoney(amt)
                local textW, textH = onyx.GetTextSize(textAmount, font0)
                local space = onyx.ScaleWide(5)
                local totalW = textW + iconSize + space
                local x = w * .5 - totalW * .5

                local boxW = totalW + onyx.ScaleWide(20)
                local boxH = textH + onyx.ScaleTall(20)

                draw.RoundedBox(8, w * .5 - boxW * .5, h * .5 - boxH * .5, boxW, boxH, colorBetween)
        
                wimgCoin:Draw(x, h * .5 - iconSize * .5, iconSize, iconSize, colorAccent)
                draw.SimpleText(textAmount, font0, x + iconSize + space, h * .5, color_white, 0, 1)
            else
                local textAmount = DarkRP.formatMoney(amt)
                local textW, textH = onyx.GetTextSize(textAmount, font0)

                local boxW = textW + onyx.ScaleWide(20)
                local boxH = textH + onyx.ScaleTall(20)

                draw.RoundedBox(8, w * .5 - boxW * .5, h * .5 - boxH * .5, boxW, boxH, colorBetween)

                draw.SimpleText(textAmount, font0, w * .5, h * .5, colorMoney, 1, 1)
            end
        end
    end

    self.leftBlock = self:Add('Panel')
    self.leftBlock.text = onyx.lang:Get('youGive')
    self.leftBlock.Paint = function(panel, w, h)
        draw.SimpleText(panel.text, font0, w * .5, h * .25, color_white, 1, 1)
    end

    self.entry = self.leftBlock:Add('onyx.TextEntry')
    self.entry:SetPlaceholderText('100')
    self.entry:On('OnLoseFocus', function(panel)
        if (self.combo.current == 2) then
            local rate = onyx.creditstore:GetOptionValue('converter_rate')
            local value = tonumber(panel:GetValue()) or 0
            local receiveAmount = onyx.creditstore:CalculateConvertResult(true, value)
            local giveAmount = math.floor(receiveAmount * rate)
            
            timer.Simple(engine.TickInterval(), function()
                if (IsValid(panel)) then
                    panel:KillFocus()        
                    panel:SetValue(giveAmount)

                    if (giveAmount == 0) then
                        panel:Highlight(colorNegative, 1)
                    end
                end
            end)
        end
    end)

    local first = onyx.lang:Get('credits') .. ' → ' .. onyx.lang:Get('money')
    local second = onyx.lang:Get('money') .. ' → ' .. onyx.lang:Get('credits')

    self.combo = self.leftBlock:Add('onyx.ComboBox')
    self.combo:AddOption(first)
    self.combo:AddOption(second)
    if (self.mode < 3) then
        self.combo:ChooseOptionID(self.mode)
        self.combo:SetDisabled(true)
        -- self.combo:Hide()
    else
        self.combo:ChooseOptionID(1)
    end

    self.button = self.leftBlock:Add('onyx.Button')
    self.button:SetText(onyx.lang:Get('convert'))
    self.button.DoClick = function(panel)
        local amt = tonumber(self.entry:GetValue())
        if (amt and amt > 0) then
            net.Start('onyx.creditstore:Convert')
                net.WriteUInt(amt, 32)
                net.WriteBool(self.combo.current == 2)
            net.SendToServer()
        end
    end

    self.buttonChange = self:Add('onyx.ImageButton')
    self.buttonChange:SetURL('https://i.imgur.com/Kf3q9WO.png', 'smooth mips')
    self.buttonChange:SetDisabled(self.mode ~= 3)
    self.buttonChange.DoClick = function(panel)
        local optionID = self.combo.current
        if (optionID > 0) then
            local oppositeID = (optionID == 1) and 2 or 1
            local oldPrice = tonumber(self.entry:GetValue()) or 0
            local newPrice = onyx.creditstore:CalculateConvertResult(oppositeID == 1, oldPrice)

            self.combo:ChooseOptionID(oppositeID)
            self.entry:SetValue(newPrice)
        end
    end

    local rate = DarkRP.formatMoney(onyx.creditstore:GetOptionValue('converter_rate'))
    self.textConverter = onyx.lang:Get('convert_u')
    self.textRate = onyx.lang:Get('currentRate', {rate = rate})
end

function PANEL:PerformLayout(w, h)
    self.rightBlock:Dock(RIGHT)
    self.rightBlock:SetWide(w * .5)
    self.leftBlock:Dock(FILL)

    local wide = w * .5

    -- children
    local children = {}
    for _, child in ipairs(self.leftBlock:GetChildren()) do
        if (IsValid(child) and child:IsVisible()) then
            table.insert(children, child)
        end
    end

    local amt = #children
    local childTall = onyx.ScaleTall(30)
    local childWide = wide * .5
    local space = onyx.ScaleTall(5)
    local totalH = childTall * amt + space * (amt - 1)
    local childY = h * .5 - totalH * .5

    for _, child in ipairs(children) do
        child:SetSize(childWide, childTall)
        child:SetPos(0, childY)
        child:CenterHorizontal()

        childY = childY + childTall + space
    end

    -- button
    local size = onyx.ScaleTall(24)

    self.buttonChange:SetSize(size, size)
    self.buttonChange:Center()
    -- self.entry:SetWide(wide * .5)

    -- self.combo:SetWide(wide * .5)
    -- self.combo:Center()

    -- self.button:SetWide(wide * .5)
end

function PANEL:Paint(w, h)
    local _, texth = draw.SimpleText(self.textConverter, font0, w * .5, 0, color_white, 1, 0)
    draw.SimpleText(self.textRate, font1, w * .5, texth, colorGray, 1, 0)

    local size = onyx.ScaleTall(24)
    
    -- wimgLongArrow:Draw(w * .5 - size * .5, h * .5 - size * .5, size, size, colorGray)
end

onyx.gui.Register('onyx.creditstore.Converter', PANEL)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/ui/cl_item.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2023

--]]

local PANEL = {}

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorOutline = Color(255, 255, 255, 5)
local colorShade = Color(0, 0, 0, 50)
local colorGray = onyx:Config('colors.gray')

local font0 = onyx.Font('Comfortaa Bold@16')
local font1 = onyx.Font('Comfortaa@14')

AccessorFunc(PANEL, 'm_Name', 'Name')
AccessorFunc(PANEL, 'm_Category', 'Category')
AccessorFunc(PANEL, 'm_Color', 'Color')
AccessorFunc(PANEL, 'm_Price', 'Price')
AccessorFunc(PANEL, 'm_bPriceTagVisible', 'PriceTagVisible')
AccessorFunc(PANEL, 'm_bLabelHidden', 'LabelHidden')

function PANEL:Init()
    self:SetName('INVALID')
    self:SetCategory('Unknown')
    self:Import('click')
    self:Import('hovercolor')
    self:SetColorKey('backgroundColor')
    self:SetColorIdle(colorSecondary)
    self:SetColorHover(onyx.OffsetColor(colorSecondary, 5))
    self:SetColor(color_white)
    self:AddHoverSound()
    self:AddClickEffect()
    self.textOwned = onyx.lang:Get('owned_u')
end

local wimgCoin = onyx.wimg.Create('creditstore_currency', 'smooth mips')
local bGradient = false
function PANEL:Paint(w, h)
    local headerHeight = math.ceil(h * .2)

    draw.RoundedBox(8, 0, 0, w, h, colorOutline)

    draw.RoundedBox(8, 1, 1, w - 2, h - 2, self.backgroundColor)

    if (not self.m_bLabelHidden) then
        draw.RoundedBoxEx(8, 0, 0, w, headerHeight, colorShade, true, true)

        if (bGradient) then
            onyx.DrawMatGradient(0, 0, w, headerHeight, BOTTOM, ColorAlpha(self:GetColor(), 10))

            surface.SetDrawColor(self:GetColor())
            surface.DrawRect(0, headerHeight - 1, w, 1)
        end

        draw.SimpleText(self:GetName(), font0, w * .5, headerHeight * .5, color_white, 1, 4)
        draw.SimpleText(self:GetCategory(), font1, w * .5, headerHeight * .5, self:GetColor(), 1, 0)
    end

    if (self.icon) then
        local size = math.ceil(math.min(w, h) * .5)

        self.icon:Draw(w * .5 - size * .5, h * .5 - size * .5, size, size)
    end

    if (self:GetPriceTagVisible()) then
        draw.RoundedBoxEx(8, 0, h - headerHeight, w, headerHeight, colorShade, nil, nil, true, true)

        if (self.owned) then
            draw.SimpleText(self.textOwned, font0, w * .5, h - headerHeight * .5, colorGray, 1, 1)
        elseif (self.status) then
            draw.SimpleText(self.status, font0, w * .5, h - headerHeight * .5, colorGray, 1, 1)
        else
            local price = self:GetPrice()
            local iconSize = onyx.ScaleTall(14)
            local textPrice = onyx.creditstore.FormatMoney(price)
            local textW = onyx.GetTextSize(textPrice, font0)
            local space = onyx.ScaleWide(5)
            local totalW = textW + iconSize + space
            local x = w * .5 - totalW * .5

            wimgCoin:Draw(x, h - headerHeight * .5 - iconSize * .5, iconSize, iconSize, colorAccent)
            draw.SimpleText(textPrice, font0, x + iconSize + space, h - headerHeight * .5, color_white, 0, 1)
        end
    end
end

function PANEL:PerformLayout(w, h)
    local headerHeight = math.ceil(h * .2)

    self:DockPadding(1, headerHeight, 1, headerHeight)
end

function PANEL:Think()
    if ((self.nextThink or 0) <= CurTime()) then
        local itemTable = self.itemTable
        local itemTypeData = self.itemTypeData

        if (itemTypeData and self.store and itemTypeData.noDuplicates) then
            self.owned = onyx.creditstore:GetPlayerItemAmount(LocalPlayer(), itemTable.id) > 0
        end

        self.nextThink = CurTime() + .1
    end
end

function PANEL:SetItem(itemID, itemData)
    local item = onyx.creditstore.items[itemID]

    if (item) then
        local model = item.model
        local icon = item.icon
        local type = item.type
        local typeData = onyx.creditstore.types[type]
        local typeName = typeData and typeData.name or '_UNKNOWN_'
        local typeColor = typeData and typeData.color or onyx:Config('colors.negative')

        self:SetName(onyx.utf8.upper(item.name))
        self:SetCategory(onyx.lang:Get(typeName))
        self:SetColor(typeColor)
        self:SetPrice(item.price)
        self.itemTable = item
        self.itemTypeData = typeData
        self.itemData = itemData
        self.equipped = itemData and itemData.equipped

        if (model) then

            if (onyx.creditstore:GetOptionValue('cheap_icon_mode')) then
                self.modelContainer = self:Add('Panel')
                self.modelContainer:Dock(FILL)
                self.modelContainer:SetMouseInputEnabled(false)
                self.modelContainer.PerformLayout = function(panel, w, h)
                    local size = math.min(w, h) * .75
                    local radius = size * .5
                    local child = panel:GetChild(0)

                    if (IsValid(child)) then
                        child:SetSize(size, size)
                        child:Center()
                    end

                    panel.radius = radius
                    panel.mask = onyx.CalculateArc(w * .5, h * .5, 0, 360, radius, 24)
                end
                self.modelContainer.Paint = function(panel, w, h)
                    local child = panel:GetChild(0)
                    local radius = panel.radius
                    if (IsValid(child)) then
                        if (radius) then
                            onyx.DrawCircle(w * .5, h * .5, radius, colorPrimary)
                        end

                        onyx.DrawWithPolyMask(panel.mask, function()
                            child:PaintManual()
                        end)

                        if (radius) then
                            onyx.DrawOutlinedCircle(w * .5, h * .5, radius, 1, color_white)
                        end
                    end
                end

                self.model2d = self.modelContainer:Add('SpawnIcon')
                self.model2d:SetModel(model)
                self.model2d:SetPaintedManually(true)
            else
                self.dmodel = self:Add('DModelPanel')
                self.dmodel:Dock(FILL)
                self.dmodel:SetMouseInputEnabled(false)
                self.dmodel:SetModel(model)

                if (type:find('vehicle')) then
                    self.dmodel:SetCamPos(Vector(0, 200, -15))
                    self.dmodel.LayoutEntity = function(panel, ent)
                        ent:SetAngles(Angle(0, 25, -15))
                    end
                else
                    local ent = self.dmodel.Entity
                    if (IsValid(ent)) then
                        if (typeData.setupModelPanel) then
                            typeData.setupModelPanel(self.dmodel, item)
                        else
                            local min, max = ent:GetRenderBounds()
                            local center = (min + max) * 0.5
                            local distance = 0

                            for _, key in ipairs({'x', 'y', 'z'}) do
                                distance = math.max(distance, max[key])
                            end

                            self.dmodel:SetLookAt(center)
                            self.dmodel:SetFOV(distance + 20)
                            self.dmodel.LayoutEntity = function() end
                        end
                    end
                end
            end
        elseif (icon) then

            self.icon = onyx.wimg.Simple(icon, '')

        end
    else
        self:SetName('(' .. itemID .. ')')
    end
end

onyx.gui.Register('onyx.creditstore.Item', PANEL)
--PATH addons/____onyx_f4/lua/onyx/modules/f4/languages/cl_french.lua:
local LANG = {}

-- TABS
LANG.f4_jobs_u = 'MÉTIERS'
LANG.f4_jobs_desc = 'Choisissez votre métier'

LANG.f4_dashboard_u = 'ACCUEIL'
LANG.f4_dashboard_desc = 'Information général'

LANG.f4_shop_u = 'BOUTIQUE'
LANG.f4_shop_desc = 'Achetez des choses'

LANG.f4_admin_u = 'ADMIN'
LANG.f4_admin_desc = 'Configurer le menu'

LANG.f4_donate_u = 'DONATION'
LANG.f4_donate_desc = 'Supporter le serveur'

LANG.addon_settings_u = 'PARAMÈTRE'
LANG.addon_settings_desc = 'Configurer votre menu'

LANG.addon_return_u = 'RETOUR'
LANG.addon_return_desc = 'Retour au menu'

-- Other
LANG.f4_salary = 'Salaire'
LANG.f4_price = 'Prix'
LANG.f4_loading = 'Chargement'
LANG.f4_purchases = 'Acheter'
LANG.f4_switches = 'Switches'
LANG.f4_unavailable = 'Indisponible'
LANG.f4_description_u = 'DESCRIPTION'
LANG.f4_weapons_u = 'ARMES'
LANG.f4_entities_u = 'ENTITÉS'
LANG.f4_ammo_u = 'MUNITION'
LANG.f4_food_u = 'NOURRITURE'
LANG.f4_shipments_u = 'CAISSES'
LANG.f4_become_u = 'DEVENIR'
LANG.f4_create_vote_u = 'CRÉER UN VOTE'
LANG.f4_general_u = 'GÉNÉRAL'
LANG.f4_police_u = 'POLICE'
LANG.f4_mayor_u = 'MAIRE'
LANG.f4_confirm_u = 'CONFIRMER'
LANG.f4_cancel_u = 'ANNULER'
LANG.f4_mostpopular_u = 'PLUS POPULAIRE'
LANG.f4_chart_u = 'GRAPHIQUE'
LANG.f4_loading_u = 'CHARGEMENT'
LANG.f4_empty_u = 'RIEN'
LANG.f4_favorite_u = 'FAVORIS'

LANG.f4_playersonline_u = 'Joueur(s) en ligne'
LANG.f4_totalmoney_u = 'ARGENT TOTAL'
LANG.f4_staffonline_u = 'STAFF EN LIGNE'
LANG.f4_actions_u = 'ACTIONS'

LANG.f4_show_favorite = 'Afficher les favoris'

LANG.requires_level = 'Nécessite le niveau {level}'

-- Actions
LANG['f4_action_input_amount'] = 'Introduire le montant'
LANG['f4_action_input_text'] = 'Introduire le texte'
LANG['f4_action_input_reason'] = 'Introduire la raison'
LANG['f4_action_choose_player'] = 'Choisir un joueur'

LANG['f4_action_confirm_action'] = "Confirmer l'action"
LANG['f4_action_drop_money'] = "Jeter de l'argent"
LANG['f4_action_give_money'] = "Donner de l'argent"
LANG['f4_action_change_name'] = 'Changer de nom'
LANG['f4_action_drop_weapon'] = 'Jeter son arme'
LANG['f4_action_sell_doors'] = 'Vendre toutes les portes'

LANG['f4_action_warrant'] = 'Faire un mandat'
LANG['f4_action_wanted'] = 'Faire un avis de recherche'

LANG['f4_toggle_lockdown'] = 'Instaurer un couvre-feu'
LANG['f4_give_license'] = 'Accorder une licence'

-- Phrases
LANG['f4_search_text'] = 'Recherche par le nom...'

-- Settings
LANG['f4.option_url_desc'] = 'Saisir l\'URL (laisser vide pour désactiver)'

LANG['f4.discord_url.name'] = 'Discord'
LANG['f4.discord_url.desc'] = 'Rejoignez notre serveur Discord'

LANG['f4.forum_url.name'] = 'Forum'
LANG['f4.forum_url.desc'] = 'Rencontrer la communauté'

LANG['f4.steam_url.name'] = 'Steam'
LANG['f4.steam_url.desc'] = 'Rejoignez notre groupe Steam'

LANG['f4.rules_url.name'] = 'Règles'
LANG['f4.rules_url.desc'] = 'Connaître les règles'

LANG['f4.donate_url.name'] = 'Faire un don'

LANG['f4.website_ingame.name'] = 'Navigateur'
LANG['f4.website_ingame.desc'] = 'Utiliser le navigateur du jeu pour ouvrir l\'URL du site web'

LANG['f4.title.name'] = 'Titre'
LANG['f4.title.desc'] = 'Le titre du menu'

LANG['f4.hide_donate_tab.name'] = 'Masquer l\'onglet Don'
LANG['f4.hide_donate_tab.desc'] = 'Masquer l\'onglet d\'intégration de la boutique'

LANG['f4.edit_job_colors.name'] = 'Modifier les couleurs des métiers'
LANG['f4.edit_job_colors.desc'] = 'Les couleurs de l\'emploi doivent-elles être affichées plus claires ?'

LANG['f4.hide_admins.name'] = 'Cacher la section Admins'
LANG['f4.hide_admins.desc'] = 'Cacher la section de la liste des administrateurs du tableau de bord'

LANG['f4.admin_on_duty.name'] = 'Métier staff activé'
LANG['f4.admin_on_duty.desc'] = 'N\'afficher en tant qu\'administrateur que les personnes ayant un certain métier'

LANG['f4.admin_on_duty_job.name'] = 'Nom du métier administrateur'
LANG['f4.admin_on_duty_job.desc'] = 'Nom du métier de l\'administrateur'

LANG['f4.colored_items.name'] = 'Dégradé'
LANG['f4.colored_items.desc'] = 'Activer un léger dégradé sur les Objets/Métiers'

LANG['f4.item_columns.name'] = 'Colonnes'
LANG['f4.item_columns.desc'] = 'Le nombre de colonnes pour les objets'

LANG['f4.job_columns.name'] = 'Colonnes'
LANG['f4.job_columns.desc'] = 'Le nombre de colonnes pour les métiers'

LANG['f4.model_3d.name'] = 'Modèles 3D'
LANG['f4.model_3d.desc'] = 'Activer le rendu en temps réel pour les icônes des objets/métiers'

LANG['f4.item_show_unavailable.name'] = 'Objet(s) indisponible'
LANG['f4.item_show_unavailable.desc'] = 'Afficher les objets qui ont échoué au contrôle personnalisé'

LANG['f4.job_show_unavailable.name'] = 'Métier(s) indisponible'
LANG['f4.job_show_unavailable.desc'] = 'Afficher les métiers qui ont échoué au contrôle personnalisé'

LANG['f4.job_show_requirejob.name'] = 'Métiers dépendants'
LANG['f4.job_show_requirejob.desc'] = 'Afficher les métiers qui ne peuvent pas être choisis parce que le joueur s\'est trompé de métier'

onyx.lang:AddPhrases('french', LANG)
--PATH addons/____onyx_f4/lua/onyx/modules/f4/ui/cl_tab_jobs.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

25/12/2023

--]]

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorTertiary = onyx:Config('colors.tertiary')
local colorGray = Color(159, 159, 159)
local font0 = onyx.Font('Overpass SemiBold@14')
local COLOR_NEGATIVE = Color(221, 107, 107)
local oldScrollValue = 0

local L = function(...) return onyx.lang:Get(...) end

local PANEL = {}

local cvShowFavorite = CreateClientConVar('cl_onyx_f4_show_favorite_jobs', '1', true, false)

function PANEL:Init()
    local toolbarPadding = onyx.ScaleTall(5)

    self.list = self:Add('onyx.ScrollPanel')
    self.list:Dock(FILL)
    self.list.OnRemove = function(panel)
        if (panel.scrollInitialized) then
            oldScrollValue = panel.scroll:GetScroll()
        end
    end

    if (oldScrollValue) then
        self:SetScroll(4, oldScrollValue)
    end

    self.toolbar = self:Add('DPanel')
    self.toolbar:Dock(TOP)
    self.toolbar:SetTall(onyx.ScaleTall(40))
    self.toolbar:DockPadding(toolbarPadding, toolbarPadding, toolbarPadding * 2, toolbarPadding)
    self.toolbar:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    self.toolbar.Paint = function(panel, w, h)
        draw.RoundedBox(8, 0, 0, w, h, colorSecondary)
    end
    self.toolbar.PerformLayout = function(panel, w, h)
        self.favToggler:SetWide(self.favToggler:GetContentWidth())
    end

    self.favToggler = self.toolbar:Add('onyx.TogglerLabel')
    self.favToggler:Dock(RIGHT)
    self.favToggler:SetText(L('f4_show_favorite'))
    self.favToggler:SetBackgroundColor(onyx.OffsetColor(colorTertiary, 10))
    self.favToggler:Font('Comfortaa Bold@18')
    self.favToggler:SetTextMargin(onyx.ScaleTall(10))
    self.favToggler:SetChecked(cvShowFavorite:GetBool(), true)
    self.favToggler.OnChange = function(panle, bool)
        cvShowFavorite:SetBool(bool)
        self:Reload()
    end

    self.search = self.toolbar:Add('onyx.TextEntry')
    self.search:SetPlaceholderText(onyx.lang:Get('f4_search_text'))
    self.search:SetPlaceholderIcon('https://i.imgur.com/Nk3IUJT.png', 'smooth mips')
    self.search:Dock(LEFT)
    self.search:SetWide(onyx.ScaleWide(150))
    self.search:SetUpdateOnType(true)
    self.search.OnValueChange = function(panel, value)
        value = onyx.utf8.lower(value)

        for _, cat in ipairs(self.list:GetItems()) do
            local layout = cat.canvas:GetChild(0)
            local items = layout:GetChildren()
            local visibleItemAmount = 0

            for _, item in ipairs(items) do
                if (onyx.utf8.lower(item:GetName()):find(value, nil, true)) then
                    item:SetVisible(true)
                    visibleItemAmount = visibleItemAmount + 1
                else
                    item:SetVisible(false)
                end
            end

            layout:InvalidateLayout()

            cat:SetVisible(value == '' or visibleItemAmount > 0)
            cat:UpdateInTick()
        end

        self.list:InvalidateLayout()
    end

    self.preview = self:Add('onyx.Panel')
    self.preview:Hide()
    self.preview.blur = 0
    self.preview.pos = 0
    self.preview.Paint = function(panel, w, h)
        local frame = onyx.f4.frame
        if (not IsValid(frame)) then return end -- just in case

        local realW, realH = frame.container:GetSize()
        local padding = frame.containerPadding

        if (panel.blur > 0) then
            onyx.DrawBlurExpensive(panel, panel.blur)
        end

        DisableClipping(true)
            surface.SetDrawColor(ColorAlpha(color_black, panel.pos * 100))
            surface.DrawRect(-padding, -padding, realW, realH)
        DisableClipping(false)
    end
    self.preview.PerformLayout = function(panel, w, h)
        panel.content:SetTall(h)
        panel.content:SetWide(w * .6)
    end
    self.preview.OnMouseReleased = function(panel)
        self:DisablePreview()
    end

    self.preview.content = self.preview:Add('onyx.f4.JobPreview')
    self.preview.content.OnFavoriteStateSwitched = function()
        self:Reload()
    end

    self.categories = {}
    self:LoadJobs()
end

function PANEL:Reload()
    local scrollValue = self.list.scroll:GetScroll()
    local container = self.list:GetContainer()

    container:Clear()
    self.search:SetValue('')
    self.categories = {}
    self:LoadJobs()
    self:SetScroll(4, scrollValue)
    container:SetAlpha(0)
    container:AlphaTo(255, .3)
end

function PANEL:SetScroll(tickAmount, scrollValue)
    timer.Simple(engine.TickInterval() * tickAmount, function()
        if (IsValid(self.list)) then
            self.list.scrollInitialized = true
            self.list.scroll:SetScroll(scrollValue)
            self.list.scroll.Current = scrollValue
            self.list.canvas.container:SetPos(0, -scrollValue)
        end
    end)
end

function PANEL:EnablePreview(member, reason)
    local preview = self.preview
    local available = reason == nil

    preview:Show()
    preview.pos = 0
    preview.content:SetPos(preview:GetWide())

    preview.content:SetupJob(member)

    if ( preview.content.hideButton ) then
        preview.content.btnChoose:SetVisible(false)
        preview.content.spacer:SetVisible(false)
    elseif ( member.team == LocalPlayer():Team() ) then
        preview.content.btnChoose:SetVisible(false)
        preview.content.spacer:SetVisible(false)
    else
        preview.content.btnChoose:SetVisible(available)
        preview.content.spacer:SetVisible(available)
    end

    onyx.anim.Create(preview, .2, {
        index = 1,
        target = {
            blur = 2,
            pos = 1
        },
        think = function(anim, panel)
            local w = panel:GetSize()
            local contentW = panel.content:GetWide()

            panel.content:SetPos(w - contentW * panel.pos, 0)
        end,
        onFinished = function(anim, panel)
            panel.content.enabled = true
        end,
        easing = 'inQuad'
    })
end

function PANEL:DisablePreview()
    local preview = self.preview

    if (not preview.content.enabled) then
        return
    end

    preview.content.enabled = false
    onyx.anim.Create(preview, .2, {
        index = 1,
        target = {
            blur = 0,
            pos = 0
        },
        think = function(anim, panel)
            local w = panel:GetSize()
            local contentW = panel.content:GetWide()

            panel.content:SetPos(w - contentW * panel.pos, 0)
        end,
        onFinished = function(anim, panel)
            panel:Hide()
        end,
        easing = 'inQuad'
    })
end

function PANEL:PerformLayout(w, h)
    self.preview:SetSize(w, h)
end

function PANEL:LoadJobs()
    local client = LocalPlayer()
    local category = {}
    local showUnavailable = onyx.f4:GetOptionValue('job_show_unavailable')

    if (cvShowFavorite:GetBool()) then
        self:CreateCategory(L('f4_favorite_u'), onyx.f4:FetchFavoriteObjects('jobs'), true, true)
    end

    for r, u in pairs(rp.Team) do
        local canSeeHook = hook.Run('playerRPCanChangeTeam', client, u.team) == true
        local canSee = u.canSee and isfunction(u.canSee) and not u.canSee(client)
        if not canSeeHook and canSee then continue end
        local customCheck = u.customCheck
        local reason

        if u.Command ~= 'mayor' then
            if (customCheck and not customCheck(client)) and not canSeeHook then
                if (showUnavailable) then
                    reason = L('f4_unavailable')
                else
                    continue
                end
            end
        end

        if not category[u.category] then
            category[u.category] = {}
        end

        table.insert(category[u.category], {
            job = u,
            reason = reason
        })
    end

    for r, u in pairs(category) do
        table.sort(u, function(a, b)
            return a.job.team < b.job.team
        end)

        self:CreateCategory(r, u, true)
    end
end

function PANEL:CreateCategory(name, members, startExpanded, color)
    if (#members < 1) then return end

    local pnlCategory = self.list:Add('onyx.Category')
    pnlCategory:Dock(TOP)
    pnlCategory:SetTitle(onyx.utf8.upper(name))
    pnlCategory:SetSpace(0)
    pnlCategory:SetInset(onyx.ScaleTall(10))
    pnlCategory:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    pnlCategory.m_iTextMargin = onyx.ScaleTall(10)
    pnlCategory.m_bSquareCorners = true
    pnlCategory:SetExpanded(startExpanded)
    pnlCategory.canvas.Paint = function(p, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorPrimary, false, false, true, true)
    end

    if (color) then
        pnlCategory.wimage = onyx.wimg.Create('favorite_fill', 'smooth mips')
    end

    local content = pnlCategory:Add('onyx.Grid')
    content:Dock(TOP)
    content:SetTall(0)
    content:SetSpaceX(onyx.ScaleTall(5))
    content:SetSpaceY(content:GetSpaceX())
    content:SetColumnCount(onyx.f4:GetOptionValue('job_columns'))
    content.category = pnlCategory

    for _, member in ipairs(members) do
        self:CreateMember(member.job, content, member.reason)
    end

    if ( startExpanded ) then
        pnlCategory:UpdateInTick()
        pnlCategory:UpdateInTick(10)
        pnlCategory:UpdateInTick(100)
    end
end

function PANEL:CreateMember(member, content, reason)
    local model = istable(member.Model) and member.Model[1] or member.Model
    local max = member.Max
    local inf = max == 0
    local index = member.team
    local color = onyx.f4.ConvertJobColor(member.Color)
    local salary = rp.FormatMoney(member.Salary)
    local level = member.level

    local item = content:Add('onyx.f4.Item')
    item:SetTall(onyx.ScaleTall(55))
    item:SetModel(model)
    item:SetName(member.name)
    item:SetColor(color, .25)
    item:SetDesc(salary)
    item:SetDescLabel(L('f4_salary'))

    if (reason) then
        item:SetDescColor(COLOR_NEGATIVE)
        item:SetDesc(reason)
        item:SetDescLabel('')
    elseif (level and onyx.f4.GetPlayerLevel(LocalPlayer(), math.huge) < level) then
        item:SetDescColor(COLOR_NEGATIVE)
        item:SetDesc(L('requires_level', {
            level = string.Comma(level)
        }))
        item:SetDescLabel('')
    elseif (member.Salary == 0) then
        item:SetDescColor(colorGray)
    else
        item:SetDescColor(Color(91, 195, 70))
    end

    item:PositionCamera('face')

    item:Import('click')
    item:Import('hovercolor')
    item:SetColorKey('colorBG')
    item:SetColorIdle(colorSecondary)
    item:SetColorHover(colorTertiary)
    item:AddHoverSound()
    item:AddClickEffect()
    item.DoClick = function()
        self:EnablePreview(member, reason)
    end

    local limit = item:Add('Panel')
    limit:Dock(RIGHT)
    limit:SetZPos(-1)
    limit:SetWide((item:GetTall() - item.padding * 2))
    limit:SetMouseInputEnabled(false)
    limit.text = inf and '∞' or ''
    limit.Paint = function(panel, w, h)
        onyx.DrawOutlinedCircle(w * .5, h * .5, math.floor(h * .5), 6, colorPrimary)

        if (panel.fraction and panel.fraction > 0) then
            onyx.DrawWithPolyMask(panel.mask, function()
                onyx.DrawOutlinedCircle(w * .5, h * .5, math.floor(h * .5), 6, color)
            end)
        end

        draw.SimpleText(panel.text, font0, w * .5, h * .5, color_white, 1, 1)
    end
    limit.PerformLayout = function(panel, w, h)
        if (panel.fraction) then
            local endAngle = math.Round(panel.fraction * 360)
            panel.mask = onyx.CalculateArc(w * .5, h * .5, 0, endAngle, h * .5 + 2, 24, true)
        end
    end

    if (not inf) then
        limit.Think = function(panel)
            if ((panel.nextThink or 0) > CurTime()) then return end                                                                                                                                                                                                        -- 9bd46d08-b472-493c-8cb7-294505375bac
            panel.nextThink = CurTime() + .1

            local amount = #team.GetPlayers(index)
            local fraction = math.Clamp(amount / max, 0, 1)

            panel.text = amount .. ' / ' .. max

            if (not panel.fraction or panel.fraction ~= fraction) then
                panel.fraction = fraction
                panel:InvalidateLayout()
            end
        end
    end
end

onyx.gui.Register('onyx.f4.Jobs', PANEL)

--[[------------------------------
DEBUG
--------------------------------]]
-- onyx.gui.Test('onyx.f4.Frame', .6, .65, function(panel)
--     panel:MakePopup()
--     panel:ChooseTab(2)
-- end)
--PATH addons/____onyx_hud/lua/onyx/modules/hud/core/cl_fonts.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

17/08/2024

--]]

onyx.hud.fonts = onyx.hud.fonts or {}

local function font2D( name, size, postfix )
    local family = 'Comfortaa'
    local finalFont = family
    local scaleInt = onyx.hud.GetScale()
    local updatedSize = math.ceil( ( size * scaleInt ) / 900 * ScrH() )
    local fontName = 'onyx.hud.' .. name

    if ( postfix ) then
        finalFont = finalFont .. ' ' .. postfix
    end

    surface.CreateFont( fontName, {
        font = finalFont,
        size = updatedSize,
        extended = true
    } )
    
    onyx.hud.fonts[ name ] = fontName
end

local function font3D2D( name, family, size )
    local realName = 'onyx.hud.' .. name

    surface.CreateFont( realName, {
        font = family,
        size = size,
        extended = true
    } )

    surface.CreateFont( realName .. '.Blur', {
        font = family,
        size = size,
        blursize = 2,
        extended = true
    } )

    return realName
end
onyx.hud.CreateFont3D2D = font3D2D

function onyx.hud.BuildFonts()
    onyx.hud.builtFonts = true

    font2D( 'ExtraTiny', 14 )
    font2D( 'ExtraTinyBold', 14, 'Bold' )

    font2D( 'Tiny', 16 )
    font2D( 'TinyBold', 16, 'Bold' )

    font2D( 'Small', 18 )
    font2D( 'SmallBold', 18, 'Bold' )

    font2D( 'Medium', 22 )
    font2D( 'MediumBold', 22, 'Bold' )

    font2D( 'Big', 28 )
    font2D( 'BigBold', 28, 'Bold' )

    font2D( 'Name', 20, 'Bold' )
    font2D( 'AmmoClip', 40, 'Bold' )
    font2D( 'AmmoRemaining', 28 )

    font2D( 'Speedometer', 80 )
end

onyx.WaitForGamemode( 'onyx.hud.BuildFonts', onyx.hud.BuildFonts )
--PATH addons/____onyx_hud/lua/onyx/modules/hud/elements/cl_gesture_menu.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

16/08/2024

--]]

local animationsTable = {}
animationsTable[ ACT_GMOD_GESTURE_BOW ] = 'Поклонитися'
animationsTable[ ACT_GMOD_TAUNT_MUSCLE ] = 'Танець любощів'
animationsTable[ ACT_GMOD_GESTURE_BECON ] = 'За мною!'
animationsTable[ ACT_GMOD_TAUNT_LAUGH ] = 'Сміх'
animationsTable[ ACT_GMOD_TAUNT_PERSISTENCE ] = 'Поза лева'
animationsTable[ ACT_GMOD_GESTURE_DISAGREE ] = 'Ні!'
animationsTable[ ACT_GMOD_GESTURE_AGREE ] = 'Круто!'
animationsTable[ ACT_GMOD_GESTURE_WAVE ] = 'Хвиля'
animationsTable[ ACT_GMOD_TAUNT_DANCE ] = 'Танець'

local animationsFrame
local function openGestureMenu()
    if ( IsValid( animationsFrame ) ) then
        return
    end

    local size = onyx.hud.ScaleTall( 512 )

    local choiceWheel = vgui.Create( 'onyx.hud.ChoiceWheel' )
    animationsFrame = choiceWheel
    choiceWheel:SetSize( size, size )
    choiceWheel:SetShowLabel( false )
    choiceWheel:MakePopup()
    choiceWheel:Center()
    choiceWheel.OnRemove = function()
        animationsFrame = nil
    end

    choiceWheel:AddChoice( { name = onyx.lang:Get( 'close' ) } )
    
    for animID, animName in pairs( animationsTable ) do
        choiceWheel:AddChoice( {
            name = animName,
            callback = function()
                RunConsoleCommand( '_DarkRP_DoAnimation', animID )                                                                                                                                                                                                                                                              -- 9bd46d08-b472-493c-8cb7-294505375bac
            end
        } )
    end
end

onyx.hud.OverrideGamemode( 'onyx.hud.OverrideGesturesMenu', function()
    concommand.Add( '_DarkRP_AnimationMenu', openGestureMenu )
end )
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_spanish.lua:
--[[

Author: Goran
Steam Profile:

03/07/2024

--]]

local LANG = {}

-- Phrases
LANG['copied_clipboard'] = 'Copiado al portapapeles'
LANG['scoreboard_search'] = 'Buscar... (Nombre/SteamID)'
LANG['you'] = 'Tú'
LANG['friend'] = 'Amigo'

-- Columns
LANG['scoreboard_col_team'] = 'Equipo'
LANG['scoreboard_col_job'] = 'Trabajo'
LANG['scoreboard_col_money'] = 'Dinero'
LANG['scoreboard_col_rank'] = 'Rango'
LANG['scoreboard_col_karma'] = 'Karma'
LANG['scoreboard_col_playtime'] = 'Tiempo de juego'
LANG['scoreboard_col_health'] = 'Salud'
LANG['scoreboard_col_level'] = 'Nivel'
LANG['scoreboard_col_none'] = 'Nada'
LANG['scoreboard_col_gang'] = 'Gang'

-- Name Effects
LANG['scoreboard_eff_default'] = 'Por Defecto'
LANG['scoreboard_eff_glow'] = 'Brillo'
LANG['scoreboard_eff_rainbow'] = 'Arcoíris'

-- Buttons
LANG['scoreboard_btn_profile'] = 'Abrir Perfil'
LANG['scoreboard_btn_freeze'] = 'Congelar'
LANG['scoreboard_btn_goto'] = 'Ir'
LANG['scoreboard_btn_bring'] = 'Traer'
LANG['scoreboard_btn_return'] = 'Regresar'
LANG['scoreboard_btn_respawn'] = 'Regenerar'
LANG['scoreboard_btn_slay'] = 'Asesinar'

-- Words
LANG['rank_id'] = 'ID de rango'
LANG['name'] = 'Nombre'
LANG['effect'] = 'Efecto'
LANG['color'] = 'Color'
LANG['preview'] = 'Previsualización'
LANG['creation'] = 'Creación'
LANG['save'] = 'Guardar'
LANG['dead'] = 'Muerto'
LANG['create_new'] = 'Crear nuevo'
LANG['column'] = 'Columna'

-- Settings
LANG['addon_settings_u'] = 'AJUSTES'
LANG['scoreboard_ranks_u'] = 'RANGOS'
LANG['scoreboard_columns_u'] = 'COLUMNAS'

LANG['scoreboard.title.name'] = 'Título'
LANG['scoreboard.title.desc'] = 'Ingresa el título del cuadro'

LANG['scoreboard.group_teams.name'] = 'Agrupar por equipo'
LANG['scoreboard.group_teams.desc'] = '(DarkRP) Agrupa los equipos por categoría de trabajo'

LANG['scoreboard.colored_players.name'] = 'Gradiente coloreado'
LANG['scoreboard.colored_players.desc'] = 'Mostrar gradiente coloreado en la línea del jugador'

LANG['scoreboard.blur.name'] = 'Tema Difuminado'
LANG['scoreboard.blur.desc'] = 'Habilitar Tema Difuminado'

onyx.lang:AddPhrases('spanish', LANG)
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_rank_editor.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/03/2024

--]]

local COLOR_PRIMARY = onyx:Config('colors.primary')
local COLOR_SECONDARY = onyx:Config('colors.secondary')
local COLOR_TERTIARY = onyx:Config('colors.tertiary')
local COLOR_ACCENT = onyx:Config('colors.accent')

local PANEL = {}

function PANEL:Init()
    self.list = self:Add('onyx.ScrollPanel')

    self.grid = self.list:Add('onyx.Grid')
    self.grid:SetColumnCount(2)
    self.grid:SetSpace(onyx.ScaleTall(5))

    self.editor = self:Add('onyx.ScrollPanel')
    self.editor:Hide()

    self:InitEditor(self.editor)
    self:LoadRanks()

    hook.Add('onyx.scoreboard.SyncedRanks', self, function()
        self.grid:Clear()
        self:LoadRanks()
    end)
end

function PANEL:ShowEditor()
    self.editor:Show()
    self.editor:SetAlpha(0)
    self.editor:AlphaTo(255, .1)

    self.list:Hide()
end

function PANEL:HideEditor()
    self.list:Show()
    self.list:SetAlpha(0)
    self.list:AlphaTo(255, .1)

    self.editor:Hide()
end

function PANEL:PerformLayout(w, h)
    self.list:Dock(FILL)
    self.editor:Dock(FILL)
end

function PANEL:LoadRanks()
    local btnCreate = self.grid:Add('onyx.Button')
    btnCreate:SetText(onyx.utf8.upper(onyx.lang:Get('create_new')))
    btnCreate:SetTall(onyx.ScaleTall(40))
    btnCreate:SetColorIdle(COLOR_SECONDARY)
    btnCreate:SetColorHover(COLOR_TERTIARY)
    btnCreate.DoClick = function(panel)
        self:LoadEditorRank()
        self:ShowEditor()
    end

    self.grid:AddItem(btnCreate)

    for uniqueID, data in pairs(onyx.scoreboard.ranks) do
        local name = data.name
        local title = uniqueID .. (name ~= '' and string.format(' (%s)', name) or '')

        local btnRank = self.grid:Add('onyx.Button')
        btnRank:SetText(title)
        btnRank:SetTall(onyx.ScaleTall(40))
        btnRank:SetColorIdle(COLOR_SECONDARY)
        btnRank:SetColorHover(COLOR_TERTIARY)
        btnRank.DoClick = function(panel)
            self:LoadEditorRank(data, uniqueID)
            self:ShowEditor()
        end
        self.grid:AddItem(btnRank)
    end
end

function PANEL:LoadEditorRank(data, uniqueID)
    local fields = self.fields
    if (istable(data)) then
        -- load
        self.editor.header:SetText(data.name)
        self.btnDelete:Show()
        self.btnDelete.DoClick = function(panel)
            net.Start('onyx.scoreboard:DeleteRank')
                net.WriteString(uniqueID)
            net.SendToServer()

            self:HideEditor()
        end

        fields['uniqueID'].input:SetDisabled(true)
        fields['uniqueID'].input:SetValue(uniqueID)
        fields['name'].input:SetValue(data.name)
        fields['color'].input.picker:SetColor(data.color)

        local option, index = fields['effect'].input:FindOptionByData(data.effectID)
        if (option) then
            fields['effect'].input:ChooseOptionID(index)
        end
    else
        -- reset
        self.editor.header:SetText(onyx.utf8.upper(onyx.lang:Get('creation')))
        self.btnDelete:Hide()

        fields['uniqueID'].input:SetDisabled(false)
        fields['uniqueID'].input:SetValue('')
        fields['name'].input:SetValue('')
        fields['color'].input.picker:SetColor(color_white)
        fields['effect'].input:Reset()
    end
end

function PANEL:InitEditor(editor)
    local header = editor:Add('onyx.Label')
    header:SetTall(onyx.ScaleTall(40))
    header:SetText('')
    header:Dock(TOP)
    header:CenterText()
    header.Paint = function(panel, w, h)
        draw.RoundedBox(8, 0, 0, w, h, COLOR_SECONDARY)
    end
    editor.header = header

    local btnBack = header:Add('onyx.ImageButton')
    btnBack:SetWide(header:GetTall())
    btnBack:Dock(LEFT)
    btnBack:SetImageScale(.75)
    btnBack:SetURL('https://i.imgur.com/B9XOMVX.png', 'smooth mips')
    btnBack.DoClick = function()
        self:HideEditor()
    end

    self.btnDelete = header:Add('onyx.ImageButton')
    self.btnDelete:SetWide(header:GetTall())
    self.btnDelete:Dock(RIGHT)
    self.btnDelete:SetImageScale(.75)
    self.btnDelete:SetURL('https://i.imgur.com/nmT20xe.png', 'smooth mips')

    self.fields = {}
    self:CreateField(editor, 'uniqueID', onyx.utf8.upper(onyx.lang:Get('rank_id')), function(container)
        local entry = container:Add('onyx.TextEntry')
            entry:SetPlaceholderText('admin')
            entry.textEntry:SetMaximumCharCount(32)
        return entry
    end)

    self:CreateField(editor, 'name', onyx.utf8.upper(onyx.lang:Get('name')), function(container)
        local entry = container:Add('onyx.TextEntry')
            entry:SetPlaceholderText('Administrator')
            entry.textEntry:SetMaximumCharCount(32)
        return entry
    end)

    self:CreateField(editor, 'effect', onyx.utf8.upper(onyx.lang:Get('effect')), function(container)
        local combo = container:Add('onyx.ComboBox')
            for _, data in ipairs(onyx.scoreboard.nameEffects) do
                combo:AddOption(onyx.lang:Get(data.name), data.id)
            end
        return combo
    end)

    self:CreateField(editor, 'color', onyx.utf8.upper(onyx.lang:Get('color')), function(container)
        local panel = container:Add('Panel')

        local picker = panel:Add('DColorMixer')
        picker:Dock(FILL)
        picker:SetAlphaBar(false)
        picker:SetPalette(false)
        panel.picker = picker

        return panel
    end, 150)

    self:CreateField(editor, 'preview', onyx.utf8.upper(onyx.lang:Get('preview')), function(container)
        local name = LocalPlayer():Name()
        local preview = container:Add('onyx.Panel')
            preview.Paint = function(panel, w, h)
                local effectID = self.fields.effect.input:GetOptionData()
                local effectData = onyx.scoreboard:FindNameEffect(effectID or '')
                local color = self.fields.color.input.picker:GetColor()

                draw.RoundedBox(8, 0, 0, w, h, COLOR_SECONDARY)
                draw.RoundedBox(8, 1, 1, w - 2, h - 2, COLOR_PRIMARY)

                if (effectData) then
                    local realX, realY = panel:LocalToScreen(0, 0)
                    local x, y = onyx.ScaleTall(10), h * .5

                    effectData.func(name, x, y, color, 0, 1, realX + x, realY + y)
                end
            end
        return preview
    end)

    self.btnSave = editor:Add('onyx.Button')
    self.btnSave:SetText(onyx.utf8.upper(onyx.lang:Get('save')))
    self.btnSave:Dock(TOP)
    self.btnSave.DoClick = function(panel)
        local fields = self.fields
        local uniqueID = fields['uniqueID'].input:GetValue():Trim()
        local name = fields['name'].input:GetValue():Trim()
        local effect = fields['effect'].input:GetOptionData()
        local color = fields['color'].input.picker:GetColor()

        if (utf8.len(uniqueID) < 1 or utf8.len(uniqueID) > 32) then
            fields['uniqueID'].input:Highlight(Color(255, 0, 0), 1)
            return
        end

        if (utf8.len(name) > 32) then
            fields['name'].input:Highlight(Color(255, 0, 0), 1)
            return
        end

        net.Start('onyx.scoreboard:ReplaceRank')
            net.WriteString(uniqueID)
            net.WriteString(name)
            net.WriteString(effect)
            net.WriteColor(Color(color.r, color.g, color.b)) -- DColorMixer doesn't return Color object...
        net.SendToServer()

        self:HideEditor()
    end
end

function PANEL:CreateField(editor, key, title, buildFunc, size)
    local font = onyx.Font('Comfortaa SemiBold@14')
    local margin = onyx.ScaleTall(7.5)

    local field = editor:Add('Panel')
    field:Dock(TOP)
    field:SetTall(onyx.ScaleTall(size or 70))
    field.Paint = function(panel, w, h)
        draw.RoundedBox(8, 0, 0, w, h, COLOR_PRIMARY)
    end

    local header = field:Add('Panel')
    header:SetTall(onyx.ScaleTall(25))
    header:Dock(TOP)
    header.Paint = function(panel, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, COLOR_SECONDARY, true, true)
        draw.SimpleText(title, font, onyx.ScaleTall(10), h * .5, color_white, 0, 1)
    end

    local container = field:Add('Panel')
    container:DockMargin(margin, margin, margin, margin)
    container:Dock(FILL)

    self.fields[key] = field

    if (isfunction(buildFunc)) then
        local panel = buildFunc(container)
        assert(panel, string.format('Invalid panel created (%s)', tostring(panel)))
        panel:Dock(FILL)

        field.input = panel
    end
end

onyx.gui.Register('onyx.scoreboard.RankEditor', PANEL)

-- if (IsValid(DebugPanel)) then
--     DebugPanel:Remove()
-- end

-- DebugPanel = onyx.scoreboard.OpenAdminSettings(2)
--PATH addons/_outfitter/lua/includes/modules/co.lua:
--setfenv(1,_G)
local NATIVE = MENU_DLL ==nil and SERVER==nil and CLIENT==nil

if SERVER then AddCSLuaFile() end

local coroutine = coroutine or require'coroutine'

local meta={}
local co=setmetatable({},meta)
local s,look = {},{}
co.stack = s

local function push(thread)
	local n = #s+1
	s[n]=thread
	look[thread]=n
	return n
end

local function pop()
	local n = #s
	local thread = s[n]
	look[thread]=nil
	s[n]=nil
	return thread,n
end

local function peek()
	local n = #s
	return s[n],n
end

local function has(thread)
	return look[thread]
end

if not NATIVE then
	_G.co=co
end

co._SimpleTimer = not NATIVE and timer.Simple or function() error"Please implement co._SimpleTimer" end

-- todo
--	error handler wrapper?
--	select() polling support (epoll() please :c)
--	co.make steal parameters
--	?


local waitticks = {}
local -- Unique identifiers
	SLEEP,
	CO_RET,
	SLEEP_TICK,
	CO_END,
	CALLBACK,
	CALL_OUTSIDE,
	CALL_OUTSIDE_NORET,
	ENDED,
	ABORTED,
	
	RETURN_RESULT,
	
	_
	
	={},{},{},{},{},{},{},{},{},{},{}
	
local extra_state = setmetatable({},{__mode='k'})

local function check_coroutine(thread)
	if thread==nil then
		thread = coroutine.running()
	end
	local curco = peek()
	if curco ~= thread then
		error("Not inside co-style coroutine",2)
	end
	if not thread then
		error("Can not call outside coroutine",2)
	end
end

local function in_co(thread)
	if thread==nil then
		thread = coroutine.running()
	end
	local curco = peek()
	return curco == thread and thread
end

co.running = in_co

local function __re(thread,ok,t,val,...)
	
	pop()
	
	if not ok then
		ErrorNoHalt("[CO] "..debug.traceback(thread,tostring(t))..'\n')
		return
	end
	
	if t==SLEEP then
		--Msg"[CO] Sleep "print(val)
		co._SimpleTimer(val,function()
			co._re(thread,SLEEP)
		end)
		
		return
		
	elseif t==SLEEP_TICK then
		table.insert(waitticks,thread)
	elseif t==CALLBACK or t==nil then -- wait for callback
	--elseif t==CB_ONE then -- wait for any one callback
	elseif t==CALL_OUTSIDE then
		co._re(thread,CALL_OUTSIDE,val(...))
	elseif t==CALL_OUTSIDE_NORET then
		co._re(thread,CALL_OUTSIDE_NORET)
		val(...)
	elseif t==CO_END then
		--Msg"[CO] END "print("OK")
		local t = extra_state[thread]
		if t~=nil and t~=ENDED and t~=ABORTED then
			for _,thread2 in next,t do
				co._re(thread2,true,val,...)
			end
		end
		extra_state[thread]=ENDED
		return val,...
	elseif t==CO_RET then -- return some stuff to the callback, continue coroutine
		--[[local discard,... = ]] co._re(thread,CO_RET)
		return val,...
	else
		ErrorNoHalt("[CO] Unhandled "..tostring(t)..'\n')
	end
	

end

co._re=function(thread,...)
	
	if extra_state[thread] == ABORTED then return end
	
	local status = coroutine.status(thread)
	if status=="running" then
		-- uhoh?
	elseif status=="dead" then
		assert(false, "Cannot resume a dead co thread.\nContact your systems necromancer!")
		-- we can do nothing
		return
	elseif status=="suspended" then
		-- all ok
	else
		assert(false,"Unknown coroutine status!?")
	end

	push(thread)

	return __re(thread,coroutine.resume(thread,...))
	
end

function co.alive(thread)
	if extra_state[thread] == ABORTED then return false,'aborted' end
	if extra_state[thread] == ENDED then return false,'ended' end
	
	local status = coroutine.status(thread)
	if status=="running" then
		return true,"running"
	elseif status=="dead" then
		return false,'dead'
	elseif status=="suspended" then
		return true,'suspended'
	end
	
	assert(false,"Unknown coroutine status!?")
end

function co.finish(...)
	coroutine.yield(CO_END,...)
	assert(false,"co.finish() returned")
end

function co.kill(thread)
	local status = coroutine.status(thread)
	
	--may want to kill dead coroutine so it doesn't error more
	--if status=="dead" then
	--	return
	--end
	
	local t = extra_state[thread]
	extra_state[thread] = ABORTED
	if t~=nil and t~=ENDED and t~=ABORTED then
		for _,thread2 in next,t do
			co._re(thread2,false,'killed')
		end
	end
end

local function Think()
	local count=#waitticks
	for i=count,1,-1 do
		local thread = table.remove(waitticks,i)
		co._re(thread,SLEEP_TICK)
	end
end
co._Think=Think

if not NATIVE then
	hook.Add(MENU_DLL and "Think" or "Tick","colib",co._Think)
end

function meta:__call(func,...)
	
	assert(type(func)=='function',"invalid parameter supplied")
	
	local thread = coroutine.create(function(...)
		func(...)
		return CO_END
	end)
	
	return thread,co._re(thread,...)
end

function co.wrap(func,...)
	
	assert(type(func) == 'function',"invalid parameter supplied")
	
	local thread = coroutine.create(function(...)
		func(...)
		return CO_END
	end)
	
	return function(...)
		return co._re(thread,...)
	end
end


function co.join(thread2)
	local thread = co.running()
	if extra_state[thread2]==ENDED then
		return nil,'ended'
	end
	if extra_state[thread2]==ABORTED then
		return nil,'aborted'
	end
	local t = extra_state[thread2]
	if not t then
		t={}
		extra_state[thread2]=t
	end
	
	t[#t+1] = thread
	return true,coroutine.yield(nil)
end


--- make a thread out of this function
--- If we are already in a thread, reuse it. It has to be a co thread though!
function co.make(...)

	local thread = in_co()
	if thread then return false,thread end
	
	local func = debug.getinfo(2).func
	return true,co(func,...)
end

local function wrap(ok,a,...)
	if ok then
		return ...
	end
end

--[[ -- TODO
function co.cox(...)
	local t={...}
	local tc =#t
	local func = t[tc-1]
	local err = t[tc]
	t[tc]=nil
	t[tc-1]=nil
	
	assert(isfunction(func),"invalid parameter supplied")
	
	local thread = coroutine.create(function(unpack(t))
		xpcall(func,err,...)
	end)
	co._re(thread,...)
	
	return thread
end
--]]

function co.wait(delay)
	
	check_coroutine()
	local ret = coroutine.yield(SLEEP,tonumber(delay) or 0)
	if ret ~= SLEEP then
		error("Invalid return value from yield: "..tostring(ret))
	end
	--Msg"[CO] End wait "print(ret)
end

function co.waittick()
	
	check_coroutine()
	
	local ret = coroutine.yield(SLEEP_TICK)
	if ret ~= SLEEP_TICK then
		error("Invalid return value from yield: "..tostring(ret))
	end
	--Msg"[CO] End wait "print(ret)
end

co.sleep=co.wait

local function wrap(ret,...)
	if ret ~= CALL_OUTSIDE then
		error("Invalid return value from yield: "..tostring(ret))
	end
	
	return ...
	
end

function co.extern(func,...)

	check_coroutine()
	
	return wrap(coroutine.yield(CALL_OUTSIDE,func,...))
	
end
function co.expcall(...)

	return co.extern(xpcall,...)
	
end


local function wrap(ret,...)
	if ret ~= CALL_OUTSIDE_NORET then
		error("Invalid return value from yield: "..tostring(ret))
	end
	
	assert(not (...),"noreturn returned?")
	
	return ...
	
end

function co.extern_noret(func,...)

	check_coroutine()
	
	return wrap(coroutine.yield(CALL_OUTSIDE_NORET,func,...))
	
end

function co.expcall_noret(...)

	return co.extern_noret(xpcall,...)
	
end


-- LEGACY
function co.newcb2(res)
	
	local thread = peek()

	check_coroutine(thread)
	
	
	--TODO: infinite return value support?
	local called,_1,_2,_3,_4,_5,_6,_7
	local CB CB = function(a,...)
		if a == RETURN_RESULT then
			return called,_1,_2,_3,_4,_5,_6,_7
		end
		
		if in_co(thread) then
			called,_1,_2,_3,_4,_5,_6,_7 = true,...
			return res
		end
			
		return co._re(thread,CALLBACK,CB,a,...)
	end
	return CB
end


function co.newcb()
	
	local thread = peek()

	check_coroutine(thread)
	
	--Msg"[CO] Created cb for thread "print(thread)
	local CB CB = function(...)
		--Msg("[CO] Callback called for thread ",thread)print("OK")
		
		return co._re(thread,CALLBACK,CB,...)
	end
	return CB
end

function co.extern_waitcb(func)
	local cb=co.newcb()
	co.extern_noret(func,cb)
	return co.waitcb(cb)
end
function co.extern_waitone(func,...)
	co.extern_noret(func,...)
	return co.waitone()
end

-- Example: print(co(function() co.ret"asd" end))
function co.ret(...)
	local ret = coroutine.yield(CO_RET,...)
	if ret ~= CO_RET then
		error("Invalid return value from yield: "..tostring(ret))
	end
end

function co.yield(...)
	co.yield_prepare()
	--coroutine.yield(nil)
	coroutine.yield(...)
end

function co.yielder_begin(...)
	co.yield_prepare()
	--coroutine.yield(nil)
	while coroutine.yield(...)~=CALLBACK do end
end

function co.yielder_finish(thread)
	return co._re(thread,CALLBACK)
end

function co.yield_prepare()
	coroutine.yield(CALLBACK)
end

local function _waitonewrap(caller,...)
	return ...
end

-- see co.fetch for example
function co.waitcb(cb)

	if cb==nil then
		return _waitonewrap(co.waitone())
	end
	
	check_coroutine()
		
	local function wrap(ret,caller,...)
		if ret ~= CALLBACK then
			error("Invalid return value from yield: "..tostring(ret))
		end
		if caller~=cb then
			error("Wrong callback returned")
		end
		return ...
	end
	
	return wrap(coroutine.yield(CALLBACK))
	
end

local function removeone(_,...) return ... end

function co.waitcb2(cb)

	check_coroutine()
	
	if (cb(RETURN_RESULT)) then
		return removeone( cb(RETURN_RESULT) )
	end
	
	local function wrap(ret,caller,...)
		if ret ~= CALLBACK then
			error("Invalid return value from yield: "..tostring(ret))
		end
		if caller~=cb then
			error("Wrong callback returned")
		end
		return ...
	end
	
	return wrap(coroutine.yield(CALLBACK))
	
end

--same as above but returns the CB too
local function wrap(ret,caller,...)
	if ret ~= CALLBACK then
		error("Invalid return value from yield: "..tostring(ret))
	end
	return caller,...
end

function co.waitone()
	
	check_coroutine()
	
	return wrap(coroutine.yield(CALLBACK))
	
end

local function error_propagator(ok,err,...)
	if not ok then
		error(err)
	end
	
	return err,...
end
	
function co.worker(worker,...)
	local queue = {}
	local started
	local task
	local function work()
		while queue[1] do
			task = queue[1]
			table.remove(queue,1)
			started = false --failsafe?
				task[1](true,worker(unpack(task,2)))
			started = true
			task=nil
		end
	end
		
	local function thread()
		started = true
		
		co.waittick() -- detach thread to preserve order
		
		local ok,err
		while not ok do
			ok,err = xpcall(work,debug.traceback)
			if not ok and err then
				if task then
					task[1](false,err)
				else
					ErrorNoHalt('[Worker] '..err..'\n')
				end
			end
		end
		started = false
	end
	local function resume()
		if started then return end
		started = true
		co(thread)
		
	end
	local function add_task( ... )
		local cb = co.newcb()
		queue[#queue+1] = {cb,...}
		resume()
		return error_propagator(co.waitcb(cb))
	end
	
	return add_task,queue,...
	
end

function co.work_cacher_filter(filter,worker,cache,...)
	local function check_cache(key,ret1,...)
		local cached = cache[key]
		if cached then
			local keep = filter(key,ret1,...)
			if not keep then
				cache[key] = nil
			end
		end
		return ret1,...
	end
	local function filter_processor(key,...)
		return check_cache(key,worker(key,...))
	end
	return filter_processor,cache,...
end


local WEAK = { __index='v' }
function co.work_cacher(worker,weak)
	local cache = weak and setmetatable({},WEAK) or {}
	
	local function cache_this(key,...)
		cache[key]={...}
		return ...
	end
	
	local function cacher(key,...)
		local cached = cache[key]
		if cached then
			return unpack(cached)
		end
		return cache_this(key,worker(key,...))
	end
	return cacher,cache
end


-- Example: co(function() local ret=co.future(co.fetch,'http://metastruct.net/404ohno') print(ret()) end)
function co.future(func,...)
	
	local cb
	local returned
	local function mediator(...)
		returned = true
		--print("future finished",requesting and "using cb" or "returning","RET:",...)
		if cb then
			cb(...)
		end
		
		return ...
	end
	local thread2 = co(function(...)
		co.yield(mediator(func(...)))
		assert(false,"co.future() should not continue")
	end,...)
	
	local function future_wait()
		--print("future",returned and "returned" or "not returned")

		if returned then
			return coroutine.resume(thread2)
		end
		
		cb=co.newcb()
		return co.waitcb(cb)
		
	end
	return future_wait
end




-- testing --



--[[ -- Instantly returning callback handling
local function evil(cb)
	print("returned",cb("hello"))
end
local function good(cb)
	print("Good timer startin")
	timer.Simple(0.1,function()
		evil(cb)
	end)
end


local isevil  = true

co(function()
	local cb = co.newcb()
	local r = co.running()
	
	local good = isevil and evil or good
	
	local ret = co.extern_waitcb(function(cb)
		good(cb)
	end)
	
	co.ret("return value to callback")
	
	print("runcb returned",ret)
	print"end coro"
end)

--]]


--[[

co.wrap(function()
	
	local w = co.extern(function(...) return ... end,"extern")
	
	assert(w=="extern")
	
	local ct = os.clock()
	co.waittick()
	assert(ct~=os.clock())

	
	local ct = os.clock()
	co.sleep(0.2)
	assert(ct~=os.clock())
	
	local ok,dat,a,b,c,d = co.fetch("http://iriz.uk.to/404")

	assert(isstring(dat))
	
end)()

--]]--

-- future test
--[[
local function test(n)
	print("test"..n,'sleep')
	co.sleep(n)
	print("test"..n,'slept')
	return n+0,"bleh"
end

co(function()
	local a =RealTime()
	local f=co.future(test,0.5)
	local f2=co.future(test,2)
	print("FIRST",RealTime()-a,f())
	print("SECOND",RealTime()-a,f2())
end)
]]


return co,co._Think

--PATH addons/_outfitter/lua/outfitter/cl_util.lua:
local Tag='outfitter'
local NTag = 'OF'

require'mdlinspect'
require'gmaparse'

module(Tag,package.seeall)

local SAVE=true  --TODO: make save after end of debugging

local Player = FindMetaTable"Player"

function TranslateError(err,...)
	if err=='maxverts' then
		err = 'Model is too complex (too many vertexes). This would lag lower quality PCs.'
	elseif err=='nobones' then
		err = "Playermodel needs to have bones"
	elseif err=='noattachments' then
		err = "Does not have eyes attachment, this breaks many addons"
	end
	return err
end


function Fullupdate()
	timer.Create(Tag..'fullupdate',.2,1,function()
		UIFullupdate()
		LocalPlayer():ConCommand("record removeme",true)
		RunConsoleCommand'stop'
		
	end)
end

--TODO: Make outfitter mount all after enabling?
outfitter_enabled = CreateClientConVar("outfitter_enabled","1",true,true)

do
	local outfitter_enabled = outfitter_enabled
	function IsEnabled()
		return outfitter_enabled:GetBool()
	end
end

do
	local outfitter_download_notifications = CreateClientConVar("outfitter_download_notifications","0",true,false)
	function CanDownloadNotification()
		return outfitter_download_notifications:GetBool()
	end
end


--TODO: Make outfitter mount all after enabling?
outfitter_fix_error_players = CreateClientConVar("outfitter_fix_error_players","1",true,true)
cvars.AddChangeCallback("outfitter_fix_error_players",function(cvar,old,new)
	
end)

do
	local outfitter_fix_error_players = outfitter_fix_error_players
	function ShouldFixErrorPlayers()
		return outfitter_fix_error_players:GetBool()
	end
end


local function AutoWearTimer()
	if co.make() then return end
	if OUTFITTER_NO_UI then return end
	local _ = coDoAutowear and coDoAutowear()
end

local timestarted = math.huge
local function InitPostEntity()
	timestarted = RealTime()
	timer.Simple(0.5,function()
	timer.Simple(0.5,function()
		timestarted = RealTime()
		AutoWearTimer()
	end)
	end)
end
hook.Add("InitPostEntity",Tag,InitPostEntity)

do
	local outfitter_sounds = CreateClientConVar("outfitter_sounds","1",true)
	function CanPlaySounds()
		local ok = outfitter_sounds:GetBool()
		if not ok then return ok end
		
		if GetElapsedInteractive()<30 then return false end
		
		return ok
	end
end

do
	local outfitter_hands = CreateClientConVar("outfitter_hands","1",true)
	function ShouldHands()
		return outfitter_hands:GetBool()
	end
end

do
	local outfitter_animfix_oldmethod = CreateClientConVar("outfitter_animfix_oldmethod","0",true)
	function UseOldAnimFixMethod()
		return outfitter_animfix_oldmethod:GetBool()
	end
	function FixLocalPlayerAnimations(allow_old)
		if allow_old and UseOldAnimFixMethod() then
			return Fullupdate()
		end
		dbgn(8,"FixLocalPlayerAnimations()",allow_old and "allow_old" or "")
		-- credits to Henke for finding a possible "fix"
		local state = LocalPlayer():GetPredictable()
		LocalPlayer():SetPredictable(not state)
		LocalPlayer():SetPredictable(state)
	end
end
	
do
	-- -1: server preference
	-- 0: force disable distance check
	-- 1: force enable distance check
	local outfitter_distance_mode = CreateClientConVar("outfitter_distance_mode","-1",true)
	local outfitter_distance = CreateClientConVar("outfitter_distance","500", true, false, '', 500, 5000)
	function ShouldDistance()
		local mode = outfitter_distance_mode:GetInt()
		if mode > 0 then
			return true
		end
		return ServerSuggestDistance()
	end
	
	function GetDistance()
		local d = outfitter_distance:GetFloat()
		if ShouldDistance() then return d>0 and d end
	end
	
	function VisibleFilter(pl1,pl2)
		local pos1,pos2 = pl1:GetPos(),pl2:GetPos()
		local dist = GetDistance()
		if not dist then return false end
		return pos1:DistToSqr(pos2)>(dist*dist)
	end
end

do

	local outfitter_nohighperf = CreateClientConVar("outfitter_nohighperf","0",false)
	local highperf = 0
	local prehighperf=true
	function IsHighPerf(n)
		if n and n>1 then return end

		return prehighperf or (not outfitter_nohighperf:GetBool() and highperf>0)
	end

	function SetHighPerf(mode,refresh_all)
		local washigh = highperf>0
		highperf = highperf + (mode and 1 or -1)
		highperf = highperf<0 and 0 or highperf
		assert(highperf < 12,"HIGHPERF FAIL")
		local ishigh = highperf>0
		
		if ishigh~=washigh and refresh_all then
			RefreshPlayers()
		end
	end
	
	hook.Add("RenderScene",Tag..'_highperf',function()
		prehighperf=false
		hook.Remove("RenderScene",Tag..'_highperf')
		dbgn(2,'Stopping forced highperf mode',IsHighPerf())
	end)
	
	function coMinimizeGarbage()
		for i=1,2048 do
			if collectgarbage('step',math.ceil(i^2)) then 
				local steps_done = (i+1)^2-1
				return steps_done
			end
			co.waittick()
		end
		return 2049^2-1
	end
	
end

--TODO
do
	local outfitter_use_autoblacklist = CreateClientConVar("outfitter_use_autoblacklist","0",true)
	function AutoblacklistEnabled()
		return outfitter_use_autoblacklist:GetBool()
	end
end

--TODO
do
	local function proc(data)
		
		if istable(data) then data=table.concat(data,"\n") end

		local t= {}
		for l in data:gmatch'[^\r\n]+' do
			if #string.Trim(l)>0 then
				table.insert(t,string.Trim(l):lower())
			end
		end
		return t,table.concat(t,"\n")
	end
	local blocklist = proc(file.Read("outfitter_blocklist.txt") or "") or {}
	function SetTitleBlocklist(str)
		local thelist,data = proc(str)
		blocklist = thelist
		file.Write("outfitter_blocklist.txt",data)
	end
	function GetTitleBlocklist()
		return blocklist
	end
	function IsTitleBlocked(title)
		
		if not AllowNSFW() and title:lower():find"nsfw" then
			return true
		end 

		for _,l in pairs(blocklist) do
			if title:lower():find(l,1,true) then
				return l
			end
		end
		return false
	end
end


do
	local outfitter_extra_safe_downloading = CreateClientConVar("outfitter_extra_safe_downloading","0",true)
	function IsParanoidMode()
		return outfitter_extra_safe_downloading:GetBool()
	end
end

do


	-- Censorship depends on steam language
	-- shortest racial slur from every language from steam api in 2021
	local racial_slur_testers = util.Base64Decode("bmlnZ2VyCmhvbW8KYmliYQpwaWNoa3UKbmVncgpsZXNiYQpwZApqaWQKz4DOv8+Nz4PPhM63CmphcMOzCmNoZWNjCuyVoOyekAptYXJpY2EKY2lwCmZ1ZmEKbXVpc3QKZmF4YQpvw6cK0LPQtdC5CsSRxKk="):Split("\n")
	local is_steam_filtering_chat = nil

	function IsSteamFilteringChat()
		if is_steam_filtering_chat ~= nil then return is_steam_filtering_chat end

		-- we can only loosen restrictions so this should catch most cases
		-- BUG: We cannot catch custom filtered words, but the player then likely has filtering on regardless
		for filter_mode = TEXT_FILTER_UNKNOWN, TEXT_FILTER_NAME do
			for _, racial_slur_test in pairs(racial_slur_testers) do
				local filtered = util.FilterText(racial_slur_test, filter_mode)

				if filtered ~= racial_slur_test then
					is_steam_filtering_chat = true

					return true
				end
			end
		end

		is_steam_filtering_chat = false

		return false
	end

	--global nsfw?
	local nsfw = CreateClientConVar("nsfw","1",true,true,"Allow NSFW content (Steam can still block with text filter)")
	function AllowNSFW()
		return not IsSteamFilteringChat() and nsfw:GetBool()
	end
end

do
	local outfitter_download_strip_lua = CreateClientConVar("outfitter_download_strip_lua","1",true)
	function ShouldStripLuaFromDownloads()
		return outfitter_download_strip_lua:GetBool()
	end
end

do
	local outfitter_allow_unsafe_http = false

	-- TODO: https://github.com/thegrb93/StarfallEx/blob/68527049b110af75ee08020255318099ddda58d5/lua/starfall/permissions/providers_sh/url_whitelist.lua
	function AllowedHTTPURL(url,bypass_can_download)
		if bypass_can_download~=true then return false end
		if outfitter_allow_unsafe_http then return true end
		return true -- TODO
	end
	function AddHTTPWhitelist(str,strtype)
		if not strtype or strtype=="url" then
			if not str:find"^https?://" then
				error("Invalid URL: "..str)
			end
		elseif strtype=="pattern" then
			-- TODO
		else
			error("Invalid type: "..tostring(strtype))
		end
	end
end

-- never save because of malicious servers?
do
	local outfitter_unsafe = CreateClientConVar("outfitter_unsafe","0",false)
	function IsUnsafe()
		return outfitter_unsafe:GetBool()
	end
end

do
	
	-- TODO: OnPlayerVisible calling

	function IsFriendly(pl)
		return true
	end
end

--TODO
local outfitter_failsafe = CreateClientConVar("outfitter_failsafe","0",true)
function IsFailsafe()
	return outfitter_failsafe:GetBool()
end
function SetFailsafe()
	if not outfitter_failsafe.Set then return end
	outfitter_failsafe:Set'1'
end

--TODO
outfitter_maxsize = 100

-- Model enforcing
	
	-- ragdoll model

	local function Enforce(rag)
		local mdl = rag.enforce_model
		if mdl then
			--TODO: not having this causes crashes?
			rag:InvalidateBoneCache()
			
			rag:SetModel(mdl)
			rag:InvalidateBoneCache()
			
		end
	end

	local enforce_models = {}
	function ThinkEnforce_DeathRagdoll()
		for rag,count in next,enforce_models do
			if rag:IsValid() and count>0 then
				
				enforce_models[rag] = count - 1
				Enforce(rag)
				
			else
				enforce_models[rag] = nil
			end
		end
	end


	function DeathRagdoll_RenderOverride(rag)
		if rag.enforce_model then
			rag:SetModel(rag.enforce_model)
			if enforce_models[rag] then
				rag:InvalidateBoneCache()
			end
		end
		rag:DrawModel()
	end

	local cache={}
	local function BadRagdoll(mdl)
		local cached=cache[mdl]
		if cached~=nil then return cached end
		cache[mdl] = false
		
		local sz = file.Size(mdl:gsub("%.mdl$",'.phy'),'GAME')
		cache[mdl]=cached
		
		if sz and sz>100*1000 then
			cached=true
		end
		cache[mdl]=cached
		
		return cached
	end
	
	function OnDeathRagdollCreated(rag,pl)
		local mdl = pl:GetEnforceModel()
		if not mdl then return end
		
		if BadRagdoll(mdl) then 
			dbgn(2,'Bad ragdoll',mdl)
			if not IsUnsafe() then
				return
			end
		end
		
		local mdlr = rag:GetModel()
		local mdlp = pl:GetModel()
		
		local hasenforced   = mdlr==mdl
		local isplyenforced = mdlp==mdl
		dbgn(2,"DeathRagdollEnforce",pl,rag,mdl,hasenforced and ("ENFORCED RAG: "..tostring(mdlr)) or "" ,isplyenforced and "" or ("NOT ENFORCED PLY: "..tostring(mdlp)) )
		
		rag.enforce_model = mdl
		enforce_models[rag] = 8
		Enforce(rag)
		
		rag.RenderOverride=DeathRagdoll_RenderOverride
		
	end





	-- player model
	-- TODO: ResetHull()
	local function Enforce(pl)
		if pl.enforce_model then
			pl:SetModel(pl.enforce_model)
			pl:ResetHull() -- sorry PAC
		end
	end

	local enforce_models = {}
	function ThinkEnforce()
		for pl,count in next,enforce_models do
			if pl:IsValid() and count>0 then
				
				enforce_models[pl] = count - 1
				Enforce(pl)
				
			else
				enforce_models[pl] = nil
			end
		end
	end

	-- Set model and start setting it for next 3 ticks while some other forces fight us
	--TODO: what forces
	function StartEnforcing(pl)
		enforce_models[pl] = 34
		Enforce(pl)
	end
	
	
	-- Set or unset actual model to be enforced clientside
	--TODO: Check if loaded, if not: Refine so that the model is parsed for materials, load materials and then enforce model. less lag!
	function Player.EnforceModel(pl,mdl,nocheck)
		dbg("EnforceModel",pl,mdl or "UNENFORCE")
		
		if not mdl then
			if pl.original_model then
				pl:SetModel(pl.original_model)
				pl.original_model = nil
			end
			pl.enforce_model = nil
				
			-- need to fullupdate or it doesn't reset either
			if pl==LocalPlayer() then
				FixLocalPlayerAnimations(true)
			end
			
			return true
		end
		
		if not nocheck then
			local exists = HasMDL(mdl)
			if not exists then return false,"invalid" end
		end
		
		local curmdl = pl:GetModel()
		local curenforce = pl.enforce_model
		local origmdl = pl.original_model
		
		if not origmdl then
			if not curmdl or curmdl=="" or curmdl == "models/error.mdl" or curmdl == "models/player.mdl" then
				dbg("EnforceModel","invalid GetModel",curmdl)
				curmdl=nil
			end
			pl.original_model = curmdl
		end
		
		pl.enforce_model = mdl
		
		StartEnforcing(pl)
		
		if pl==LocalPlayer() and curmdl ~= mdl then
			LazyFullupdate(mdl)
			if pl:GetNWBool("IsListenServerHost",false) or not mdl then
				FixLocalPlayerAnimations(true)
			end
		end
		
		return true
		
	end

	function Player.GetEnforceModel(pl,mdl)
		return pl.enforce_model
	end

	function OnPlayerInPVS(pl)
		if not pl.enforce_model then return end
		
		local orig = pl.original_model
		local neworig = pl:GetModel()
		-- pl.original_model = neworig
		dbgn(2,"OnPlayerInPVS","enforce",pl,pl.enforce_model,"orig",orig,orig==neworig)
		StartEnforcing(pl)
	end
	
	--TODO: REVISIT (Single frame spazzing on local player wear)
	local recursing
	local localpl
	hook.Add("PlayerPostThink",Tag,function(p)
		localpl = localpl or LocalPlayer()
		if p~=localpl then
			return
		end
		
		if recursing then return end
		recursing=true
					
			Enforce(p)
			--p:DrawModel()
		
		recursing=false
		--return true
	end)
	
	-- Between Think and This is where the player gets reset to original model for some reason, every think
	local recursing
	hook.Add("PlayerTick",Tag,function(p)
		localpl = localpl or LocalPlayer()
		if p~=localpl then
			return
		end
		
		if recursing then return end
		recursing=true
					
			Enforce(p)
		
		recursing=false
	end)

function TestLZMA(fpath)
	-- if IsUGCFilePath(fpath) -- TODO
	
	local f = file.Open(fpath,'rb','MOD')

	if not f then
		return nil,"file"
	end
	
	local dat = f:Read(14)
	f:Close()
	
	if not dat or #dat<14 then return false,'size' end
	
	local decompressed_size,dict_size,props = util.DecompressInfo(dat)
	if not decompressed_size then return decompressed_size,dict end
	if decompressed_size > 1024*1024*512 then
		return nil,'oversize'
	end
	
	--TODO: Check 2^n and 2^n + 2^(n-1)
	-- https://svn.python.org/projects/external/xz-5.0.3/doc/lzma-file-format.txt
	
	return true
	
end
function GMABlacklist(fpath,wsid)
	assert(fpath)

	local f = file.Open(fpath,'rb','MOD')
	dbg("GMABlacklist",fpath,f and "" or (IsUGCFilePath(fpath) and "UGC, SKIP" or "INVALIDFILE"))
	
	if not f then
		if IsUGCFilePath(fpath) then return true,'file' end -- Can no longer access gma data
		return nil,"file"
	end
	
	local gma,err = gmaparse.Parser(f)
	if not gma then return nil,err end

	local ok ,err = gma:ParseHeader()
	if not ok then return nil,err end
	

	local paths = {}
	local check_vtfs = {}
	for i=1,8192*2 do
		local entry,err = gma:EnumFiles()
		if not entry then
			if err then dbge("GMABlacklist","enumfiles",wsid,err) end
			break
		end
		local path = entry.Name
		assert(path)
		
		paths[#paths+1] = path:lower()
		if path:Trim():sub(-4):lower()=='.vtf' then
			--print(path,entry.Offset)
			assert(not check_vtfs[entry.Offset] )
			check_vtfs[entry.Offset] = path
		end
	end
	
	local endheader = f:Tell()
	
	if not next(check_vtfs) then dbgn(3,"CheckVTF","none found??") end
	
	for offset,path in next, check_vtfs do
		dbgn(2,"CheckVTF",path)
		
		if not gma:SeekToFileOffset(offset) then return nil,'seekfail' end
		
		local dat, err = file.ParseVTF(f)
		if not dat then 
			dbge("GMABlacklist","ParseVTF",path,wsid,"could not parse",err)
		elseif dat.width>4096 or dat.height>4096 then
			dbge("GMABlacklist","ParseVTF",wsid,"oversize")
			return nil,'oversize vtf'
		end
	end
	
	for i=1,#paths do
		local path = paths[i]
		
		--Check 1: modules
		if path :find("includes",4,true) and path:gsub("\\","/"):gsub("/./","/"):gsub("/./","/"):gsub("/+","/"):find("lua/includes/",1,true) then
			return nil,"includes"
		end
		
		--Check 2
		-- Model overrides / script overrides / config overrides / etc

		
	end
	
	return true
	
end


function GMAParseModels(gma)
	assert(gma)
	local mdls,vvds,mdlfiles,phys = {},{},{},{}
	for i=1,32000 do
		local entry,err = gma:EnumFiles()
		if not entry then
			if err then
				dbge("GMAParseModels",err) 
				return nil,err
			end
			break
		end
		local path = entry.Name
		local ext = path:sub(-4):lower()
		local path_extless = path:sub(1,-5):lower()
		
		if ext=='.mdl' then
			mdls[#mdls+1] = table.Copy(entry)
		elseif ext=='.vvd' then
			mdlfiles[path_extless] = true
			vvds[path:lower()] = entry.Offset
		elseif ext=='.vtx' then
			--mdlfiles[path:gsub("%.[^%.]+%.vtx$",""):lower()] = true
			mdlfiles[path_extless] = true
		elseif ext=='.phy' then
			phys[path_extless] = {entry.Offset,entry.Size}
		end
	end
	return mdls,vvds,mdlfiles,phys
end
function FileListParseModels(files)
	local mdls,vvds,mdlfiles,phys = {},{},{},{}
	for _,path in pairs(files) do
	
		local ext = path:sub(-4):lower()
		local path_extless = path:sub(1,-5):lower()
		
		if ext=='.mdl' then
			mdls[#mdls+1] = {Name=path,path=path,nogma=true}
		elseif ext=='.vvd' then
			mdlfiles[path_extless] = true
			vvds[path:lower()] = true
		elseif ext=='.vtx' then
			--mdlfiles[path:gsub("%.[^%.]+%.vtx$",""):lower()] = true
			mdlfiles[path_extless] = true
		elseif ext=='.phy' then
			phys[path_extless] = true
		end
	end
	return mdls,vvds,mdlfiles,phys
end
-- purge {false,false,good,false}
function RemoveListVals(t,val)
	for i=#t,1,-1 do
		if t[i]==val then
			table.remove(t,i)
		end
	end
end

function CategorizeBadModelPath(n)
	if n:find("/c_arms",1,true) 				then return "arms" end
	if n:find("/c_hands",1,true) 				then return "arms" end
	if n:find("arms.",1,true) 				then return "arms" end
	if n:find("hands.",1,true) 				then return "arms" end
	if n:find("/c_",1,true) 				then return "viewmodel" end
	if n:find("/w_",1,true) 				then return "worldmodel" end
	--if n:find("_animations.mdl",1,true) 	then return "animation" end
	if n:find("_animation",1,true) 	then return "animation" end
	if n:find("_anims_",1,true) 			then return "animation" end
	if n:find("/weapons/.",1,true) 			then return "prop" end
	if n:find("/prop_",1,true) 			then return "prop" end
	if n:find("/props_",1,true) 			then return "prop" end
end

function CheckPHY(gma,phys,path_extless)

	local data = phys[path_extless..'.phy']
	if not data then return end
	
	--if phy_size then
	--	if not IsUnsafe() and phy_size>128*1000 then
	--		return false,'filesize'
	--	end
	--end
	local phy_offset = data[1]
	if phy_offset then
		if not gma:SeekToFileOffset(phy_offset) then return nil,"seekfail" end
	end
	return true
end

function CheckVVD(gma,vvds,path_extless,path_fd)
	-- validate VVD vertex count 
	local vvd_offset = vvds[path_extless..'.vvd'] or vvds[path_extless..'.VVD']
	if vvd_offset then
		if gma and not gma:SeekToFileOffset(vvd_offset) then return nil,"seekfail" end
		local ok ,in_err,verts = ValidateVVDVerts(not gma and path_extless..'.vvd' or gma:GetFile())
		if not ok and in_err=='file missing' then
			dbgn("CheckVVD","ValidateVVDVerts",path_extless,in_err,verts)
			return true
		end
		if not ok then
			dbg("CheckVVD","ValidateVVDVerts",path_extless,in_err,verts)
			if not IsUnsafe() then
				if DrawingDecals() then
					return false,in_err
				end
			end
		end
		return true
	else
		dbg("CheckVVD","vvd not found?",path_extless..'.vvd')
	end
end

function GetGMAFiles(fpath)
	local ok ,files = MountWS( fpath )
	if ok and files then
		return files
	end
	return nil,files
end

-- helper function that probably should not exist
local function GMAORFILE(a,gma,...)
	if gma then return gma,... end
	if isstring(a) then return a end
	a:Seek(0)
	return a
end



function GMAPlayerModels(fpath)
	assert(fpath)
	local f = file.Open(fpath,'rb','MOD')
	dbgn(2,"GMAPlayerModels pre",fpath,f and "" or (IsUGCFilePath(fpath) and "UGC, SKIP" or "INVALIDFILE"))
	
	local gma,files,err
	if f then 
		gma,err = gmaparse.Parser(f)
		if not gma then return nil,err end
	else
		files,err = GetGMAFiles(fpath)
		if not files then
			return nil,err
		end
	end
	
	if gma then
		local ok ,err = gma:ParseHeader()
		if not ok then return nil,err end
	end
	
	local modellist,vvds,mdlfiles,phys
	if gma then
		modellist,vvds,mdlfiles,phys = GMAParseModels(gma) 
	else
		modellist,vvds,mdlfiles,phys = FileListParseModels(files)
	end
	
	if not modellist then return nil,vvds end


	local playermodels = {}
	local hands = {}
	local potential = {}
	local discards = {}
	local extra = {
		playermodels = playermodels,
		hands = hands,
		potential = potential,
		discards = discards
	}
	
	--TODO: Check CRC?
	--TODO: Check other files exist for mdl (otherwise might be anim for example)
	
	-- go through all model entries found from the gma
	
	
	for k,entry in next,modellist do
		local path = entry.Name
		local path_extless = entry.Name:sub(1,-5)
		
		local cat = CategorizeBadModelPath(path)
		
		if gma and not gma:SeekToFileOffset(entry) then return nil,"seekfail" end
		local path_fd = not gma and file.Open(path,'rb','GAME')
		if not path_fd and not gma then
			dbge("GMAParseModels","file should exist but doesn't",path_fd,path,fpath)
			continue
		end
		
		can = mdlfiles[path_extless]
		local discard
		local isplr,err,err2 = MDLIsPlayermodel(GMAORFILE(path_fd,gma and gma:GetFile(),entry.Size))
		local hasAnims = err
		local plerr
		if isplr==nil then 
			dbge("MDLIsPlayermodel",path_extless,err,err2) 
			discard="MDLIsPlayermodel"
		elseif not isplr then
			plerr = err
			entry.error_player = plerr
		elseif not phys[path_extless] and not hasAnims then
			isplr=false
			plerr = 'physics'
			entry.error_player = plerr
		end
		
		if gma and not gma:SeekToFileOffset(entry) then return nil,"seekfail" end
		local ishands,err,err2 = MDLIsHands(GMAORFILE(path_fd,gma and gma:GetFile(),entry.Size))
		local handserr
		if ishands==nil then 
			dbge("MDLIsHands",path_extless,err,err2) 
		elseif not isplr then
			handserr = err
			entry.error_hands = handserr
		elseif phys[path_extless] then
			ishands = false
			handserr = 'physics'
			entry.error_hands = handserr
		end
		
		-- TODO: fix non gma
		if phys[path_extless] and gma then
			local phy_ok,err = CheckPHY(gma,phys,path_extless)
			entry.phy_ok = phy_ok
			if not phy_ok then
				discard = "phy"
			end
		end
		
		local vvd_ok,err = CheckVVD(gma,vvds,path_extless)
		entry.vvd_ok = vvd_ok
		entry.error_vvd = err
		
		if not vvd_ok then
			discard = "vvd"
			ishands = false
			isplr = false
		end
		if not ((ishands and not isplr) or (isplr and not ishands) or (not ishands and not isplr)) then
			dbg("GMAPlayerModels","unable to categorize",fpath,path,"isHands=",ishands,"isPlayer=",isplr)
			ishands = false
			isplr = false
		end
		dbgn(2,"CategorizeModel",cat,isplr and "player" or ishands and "hands" or "unkn",path)
		
		discard = discard 
			or plerr == 'nobones'
			
			or cat == 'arms' 
			or cat == 'prop' 
			or cat == 'animation' 
			or cat == 'viewmodel' 
			or cat == 'worldmodel'
		
		entry.discard = discard
		
		if isplr then
			playermodels[path]=entry
		elseif ishands then
			hands[path]=entry
		elseif not discard then
			potential[path]=entry
		else
			discards[path]=entry
		end
	end
	
	dbg("GMAPlayerModels",fpath,table.Count(playermodels),table.Count(potential),table.Count(hands))
	if IsUnsafe() then
		for k,v in next,potential do
			playermodels[k]=v
		end
	end
		
	
	local mdl_list = {}
	for path,entry in next,playermodels do
		mdl_list[#mdl_list+1] = entry -- entry.Name 
	end
	return mdl_list,extra
	
end

--outfitter.EnforceHands("models/weapons/c_arms_timeshiftsoldier.mdl")

local needmdl,omdl
local _twhen=0
function ThinkFullupdate()
	if needmdl then
		if util.IsValidModel(needmdl) then
			dbg("Fullupdate","Became valid",needmdl,CurTime()-_twhen)
			needmdl = nil
			
			FixLocalPlayerAnimations(true)
		end
	end
	
	local mdl = LocalPlayer():GetModel()
	if mdl ~= omdl then
		omdl=mdl
		if not util.IsValidModel(mdl) then
			dbg("Requesting fullupdate for",mdl)
			_twhen = CurTime()
			needmdl = mdl
		else
			dbg("Fullupdate","not needed",mdl)
		end
	end
	
end


local function OnEntityCreated(ent)
	local me = LocalPlayer()
	if ent~=me then return end
	dbgn(2,'LocalPlayer (re)created')
end

hook.Add("OnEntityCreated", Tag, OnEntityCreated)

function LazyFullupdate(mdl)
	needmdl = mdl
end

-------------------
local elapsed=0
function GetElapsedInteractive()
	return elapsed
end
local function ElapsedThink()
	local ft = FrameTime()
	ft = ft>0.3 and 0.3 or ft
	elapsed=elapsed+ft
	
end
	
local function Think()
	ThinkEnforce()
	ThinkEnforce_DeathRagdoll()
	ThinkFullupdate()
	ElapsedThink()
end
hook.Add("Think",Tag,Think)




-------------------

local viewing
local view={}
local lastt
function CalcView(pl,pos,oang,fov)
	local speedup = 20
	local off = GetGUIInteractionOffset()
	off = off and -off*speedup*math.pi*8
		
	local speedytime = RealTime()*speedup
	
	local t = (off and lastt or speedytime) + (off or 0)
	lastt = off and lastt or speedytime
	
	t=( t )%360
	local slowdown= math.sin(t/360*math.pi*2 +math.pi + math.pi*.1)*speedup*.80
	
	local ang = Angle(15, ((t - slowdown) + LocalPlayer():GetAngles().y)%360,0)
	view.origin = pl:GetPos()+Vector(0,0,pl:OBBMaxs().z*.5) - ang:Forward()*65 - ang:Right()*20
	view.fov = fov
	view.angles = ang
	return view
end
function ShouldDrawLocalPlayer()
	return viewing
end
function InThirdperson()
	return viewing
end

local off
function ToggleThirdperson(want)
	if want==false or (viewing and want==nil) then
		hook.Remove("CalcView",Tag)
		hook.Remove("ShouldDrawLocalPlayer",Tag)
		viewing = false
	elseif not viewing and want~=false then
		viewing = true
		off=nil
		hook.Add("CalcView",Tag,CalcView)
		hook.Add("ShouldDrawLocalPlayer",Tag,ShouldDrawLocalPlayer)
	end

end

function GetGUIInteractionOffset()
	return off
end
local mstartx
local function GUIMousePressed()
	mstartx = input.GetCursorPos()
end
hook.Add( "GUIMousePressed", Tag, GUIMousePressed )

local function GUIMousePressedThink()
	if not mstartx then return end
	local x = input.GetCursorPos()
	off = (x-mstartx)/ScrW()
end
hook.Add( "Think", Tag..'mintoff', GUIMousePressedThink )

local function GUIMouseReleased()
	if false --[[todo]] then
		off=nil
	end
	mstartx=nil
end

hook.Add( "GUIMouseReleased", Tag, GUIMouseReleased )




concommand.Add("outfitter_camera_toggle",function(a,b,c) if c[1] then ToggleThirdperson(tonumber(c[1])) else ToggleThirdperson() end end) 

------------




local MAX_NUM_LODS = 8
function ParseVVD(f)
	local dat = {}
	dat.id					= f:Read(4)
	if dat.id~='IDSV' then return nil,'not vvd' end
	dat.version				= f:ReadLong()
	if (dat.version or 9999)>10 then return nil,'invalid vvd' end
	dat.checksum			= f:ReadLong()
	dat.numLODs				= f:ReadLong()
	if (dat.numLODs or 9999)>MAX_NUM_LODS then return nil,'invalid vvd' end

	local t = {}
	for i=1,MAX_NUM_LODS do
		t[i] = f:ReadLong()
	end

	dat.numLODVertexes = t
	dat.numFixups			= f:ReadLong()
	dat.fixupTableStart		= f:ReadLong()
	dat.vertexDataStart		= f:ReadLong()
	dat.tangentDataStart	= f:ReadLong()
	return dat
end

function ValidateVVDVerts(f)
	local do_close
	if isstring(f) then
		f = file.Open(f,'rb','GAME')
		if not f then return nil,'file missing' end
		do_close = true
	end
	local function RETURN(...)
		if do_close then f:Close() end
		return ...
	end
		
	local dat,err = ParseVVD(f)
	
	if not dat then return RETURN(nil,err) end
	--TODO: can be higher if nodecals. What is new limit
		
	local num = dat.numLODVertexes[1]
	if num > 64534 --[[magic]] then return RETURN(false,'maxverts',num) end
	return RETURN(true,num)
end

local r_drawdecals = GetConVar"r_drawdecals"
function DrawingDecals()
	return r_drawdecals:GetBool()
end


do 
	--TODO: skin, bodygroup, etc??
	local HACKT=Tag.."_handshack"
	local function hackt()
		local h = LocalPlayer():GetHands()
		if not h or not h:IsValid() then return end
		local m = h:GetModel()
		if not m then return end
		h:SetModel(m)
	end
	
	local oldmodel
	local enforce,skin,bodygroup
	local function PreDrawPlayerHands(ent)
		local old = ent:GetModel()
		if old~=enforce then
			dbgn(3,'EnforceHands',oldmodel,old,enforce)
			if enforce==nil then
				dbgn(3,"EnforceHands","oldmodel",oldmodel)
				local _=oldmodel and ent:SetModel(oldmodel)
				oldmodel = nil
				hook.Remove("PreDrawPlayerHands",Tag)
				timer.Destroy(HACKT)
			else
				dbgn(3,"EnforceHands","enforce",enforce)
				local _=enforce and ent:SetModel(enforce)
			end
			oldmodel = old
		end
	end

	function EnforceHands(mdl,_skin,_bodygroup)
		enforce = mdl
		
		local t = {mdl=mdl,skin=skin,bodygroup=bodygroup}
		LocalPlayer().outfitter_hands = t
		
		if enforce then
			if not timer.Exists(HACKT) then
				timer.Create(HACKT,5,0,hackt)
			end
			hook.Add("PreDrawPlayerHands",Tag,PreDrawPlayerHands)
		else
			timer.Destroy(HACKT)
		end
		_skin,_bodygroup = skin,bodygroup
	end
end



function MDLToUI(s)
	if not s then return s end
	if #s==0 then return s end
	s=s:gsub("^models/player/","")
	s=s:gsub("^models/","")
	  
	s=s:gsub("_([a-z])",function(a) return ' '..a:upper() end)
	s=s:gsub("_"," ")
	  
	s=s:gsub("%.mdl","")
	  
	s=s:gsub("/([a-z])",function(a) return '/'..a:upper() end)
	
	local a,b = s:match'^(.+)/(.-)$'
	if b then
		s = ('%s ( %s )'):format(b,a)
	end
	
	s=s:gsub("/",", ")
	
	return s
end

do
	local _vgui = vgui

	local recurse recurse = function(pnl)
		pnl:SetSkin('Outfitter')
		--print(pnl)
		for k,v in next,pnl:GetChildren() do
			recurse(v)
		end
	end

	local vgui = {
		Create=function(...)
			local ret = _vgui.Create(...)
			local _ = ret and ret:IsValid() and recurse(ret)
			timer.Simple(0,function()
				local _ = ret and ret:IsValid() and recurse(ret)
			end)
			return ret
		end,
		CreateFromTable=function(...)
			local ret = _vgui.CreateFromTable(...)
			local _ = ret and ret:IsValid() and recurse(ret)
			timer.Simple(0,function()
				local _ = ret and ret:IsValid() and recurse(ret)
			end)
			return ret
		end,
		
	}
	--timer.Simple(1,function() derma.RefreshSkins()  end)
	setmetatable(vgui,{__index=_vgui})

	function GetVGUI()
		return vgui
	end
end



require 'gmaparse'
local cache={}
function AlreadyMounted(fpath,fd)
	local cached = cache[fpath]
	if cached~=nil then return cached end
	
	if not fpath then return nil, 'no filepath' end
	local f = fd or file.Open(fpath, 'rb', 'MOD')
	assert(not fd or f==fd)
	if not f then 
		if IsUGCFilePath(fpath) then
			return nil,'ugc'
		end
		return nil, "file" 
	end
	local gma, err = gmaparse.Parser(f)
	if not gma then return nil, err end
	local ok, err = gma:ParseHeader()
	if not ok then return nil, err end
	local paths = {}


	for i = 1, 2 ^ 14 do
		local entry, err = gma:EnumFiles(i==1)

		if not entry then
			if err then return nil, err end
			break
		end

		local path = entry.Name
		assert(path)
		paths[#paths + 1] = path
	end
	if not fd then
		gma:Close()
	end
	if #paths >= 2^16 then
		return nil,'Over 2^16 files???'
	end
	if #paths == 0 then
		return nil,'No files??'
	end
	
	for i = 1, #paths do
		local path = paths[i]
		if not file.Exists(path,'workshop') then
			return false,path
		end
	end
	cache[fpath] = paths or true --  we had to check all the files in the gma, let's not check them again
	return paths or true
end

hook.Add("OutfitterDownloadUGCResult",Tag..'_alreadymounter',function(fileid,path,fd)
	if not fileid or not path or not fd then return end
	local pos = fd:Tell()
	local sz = fd:Size()
	fd:Seek(pos)
	dbg("Preload AlreadyMounted",fileid,path,fd,fd and string.NiceSize(sz),"ret=",pcall(AlreadyMounted,path,fd))
	fd:Seek(pos)
end)

function GMAFiles(fpath)
	if not fpath then return nil, 'no filepath' end
	local f = file.Open(fpath, 'rb', 'MOD')
	if not f then return nil, "file" end
	local gma, err = gmaparse.Parser(f)
	if not gma then return nil, err end
	local ok, err = gma:ParseHeader()
	if not ok then return nil, err end
	local paths = {}
	for i = 1, 2 ^ 14 do
		local entry, err = gma:EnumFiles(i==1)

		if not entry then
			if err then return nil, err end
			break
		end

		local path = entry.Name
		assert(path)
		paths[#paths + 1] = path
	end
	gma:Close()
	return paths
end

local game_MountGMA = game.MountGMA
function MountGMA(fpath,opt)
	if opt~='force' then
		local ok,res,err = pcall(AlreadyMounted,fpath)
		if not ok then
			res,err = nil,res
		end
		
		if res then
			dbg("MountGMA","Not remounting",fpath)
			return true,res
		else
			if err then
				if res~=false then
					dbg("MountGMA",(("AlreadyMounted(%q) returning error, mounting anyway, info: %s\n"):format(fpath,err)))
				end
			else
				-- not mounted, all ok
			end
		end
	end
	dbg("Running game.MountGMA",fpath)
	local files,err = game_MountGMA(fpath,opt)
	dbg("Finished game.MountGMA:",istable(files) and table.Count(files) or files,err)
	if cache[fpath] ~= nil then
		dbg("Stuffing AlreadyMounted cache with", fpath, files, err)
		cache[fpath] = files or err
	end
	return files,err
end


---------------



--PATH addons/_outfitter/lua/outfitter/gui_about.lua:

-- Credits --

local Tag='outfitter'

module(Tag,package.seeall)



local avatar_size=184
local avatars = {}
-- FUCK YOU GARRY
local function GetCachedAvatar184(sid64)
	local c = avatars[sid64]
	if c then
		c.shouldhide = false
		if c.hidden then
			c.hidden =false
			c:SetVisible(true)
		end
		return c
	end

	local a = vgui.Create'AvatarImage'
	a:SetPaintedManually(true)
	a:SetSize(1,1)
	a:ParentToHUD()
	a:SetAlpha(0)
	a:SetPos(ScrW()-1,ScrH()-1)
	a:SetSteamID(sid64,avatar_size)
	a.Think=function(self)
		if self.shouldhide then
			if not self.hidden then
				self.hidden = true
				self:SetVisible(false)
			end
		else
			self.shouldhide = true
		end
	end
	a.shouldhide = false
	avatars[sid64]=a
	return a
end


local avatar_size=184
local avatars = {}
local function GetCachedAvatar184(sid64)
	local c = avatars[sid64]
	if c then
		c.shouldhide = false
		if c.hidden then
			c.hidden =false
			c:SetVisible(true)
		end
		return c
	end

	local a = vgui.Create'AvatarImage'
	a:SetPaintedManually(true)
	a:SetSize(1,1)
	a:ParentToHUD()
	a:SetAlpha(0)
	a:SetPos(2,2)
	a:SetSteamID(sid64,avatar_size)
	a.Think=function(self)
		if self.shouldhide then
			if not self.hidden then
				self.hidden = true
				self:SetVisible(false)
			end
		else
			self.shouldhide = true
		end
	end
	a.shouldhide = false
	avatars[sid64]=a
	return a
end
function SetAvatarTexture184(sid64)
	local cached = GetCachedAvatar184(sid64)
	surface.SetTexture(0)
	if cached then
		cached:SetPaintedManually(false)
		cached:PaintManual()
		cached:SetPaintedManually(true)
	end
end


local credits = {
	{
		"Willox",
		"76561197998909316",
		[[Ex-Facepunch who gave us the tools to make outfitter]],
	},{
		"CapsAdmin",
		"76561197978977007",
		[[Insipration from Player Appearance Customizer (PAC3)]],
	},{
		"Aerthas",
		"76561198053556165",
		[[Help with initial outfitter prototyping]],
	},{
		"Henke",
		"76561198000730944",
		[[Found anim fix alternative]],
	},{
		"Facepunch forums",
		{'76561197960279927','http://steamcommunity.com/groups/facepunch'},
		[[For helping with all the LAU selflessly and also for emotional support over the years for all of us. Lots of stuff would not have been possible without!]],
	},{
		"Garry",
		"76561197960279927",
		[[<Garry :D> You guys are crazy WTF]],
	},{
		"Python1320",
		"76561197986413226",
		[[The guy who wrote this madness]],
	},{
		"Meta Construct",
		{'76561198047188411',"http://metastruct.eu"},
		[[The programming community that made outfitter possible]],
	},
}

local inited
local function initcredits()
	if inited then return end
	inited=true
	
	credits[#credits+1] = {
		LocalPlayer():GetName(),
		LocalPlayer():SteamID64(),
		[[For being interested in outfitter!]],
	}
end

local PANEL={}

function PANEL:Init(asd) local _
	
	asd = asd==true
	self.is_panel = asd
	
	initcredits()
	if not self.is_panel then
		self:SetTitle"Outfitter (About)"
		local W,H=290,350
		self:SetMinHeight(100)
		self:SetMinWidth(200)
		self:SetSize(W,H)
		self:SetDeleteOnClose(true)
		self:Center()

		_=self.btnMinim and self.btnMinim:SetVisible(false)
		_=self.btnMaxim and self.btnMaxim:SetVisible(false)
		
		self:SetDraggable( true )
		self:SetSizable( true )
		
		local title = self.lblTitle
		if title then
			self:SetIcon'icon16/information.png'
			
		end
	end
	
	local pnl = vgui.Create('DScrollPanel',self)
	self.content = pnl
	
	-- HACK
		pnl.VBar:SetParent(self)
		pnl.VBar:Dock(RIGHT)
		pnl.VBar:DockMargin(-pnl.VBar:GetWide()+4,0,0,0)
	pnl:Dock(FILL)
	
	self:GenDesc()
	for _,entry in next,credits do
		self:GenAbout(entry)
	end
end

function PANEL:GenDesc()
	
	
	local lbl_desc = vgui.Create('DLabel',self)
	local amt = #file.Find("cache/workshop/*.*",'MOD')
	
	local txt = ("Workshop cache: %d addons!"):format(amt)
	lbl_desc:SetText(txt)
	lbl_desc:DockMargin(4,4,4,4)
	lbl_desc:SetTextColor(Color(255,255,255,255))
	lbl_desc:SetFont"BudgetLabel"
	lbl_desc:SetAutoStretchVertical(true)
	lbl_desc:SetWrap(true)
	lbl_desc:Dock(TOP)
	self:AddItem(lbl_desc)
	
	
	local lbl_desc = vgui.Create('DLabel',self)
	lbl_desc:SetText[[Hello there! Outfitter was made to fill the need of the GMod community and for procrastination.
Although mostly working, outfitter still has bugs and you can help with that by reporting them.]]
	lbl_desc:DockMargin(4,4,4,14)
	--lbl_desc:SetFont(fdesc)
	lbl_desc:SetDark(false)
	lbl_desc:SetAutoStretchVertical(true)
	lbl_desc:SetWrap(true)
	lbl_desc:Dock(TOP)
	self:AddItem(lbl_desc)
	
		
	local b = vgui.Create( "DButton", self )
	b:SetText"Bug reporting"
	b.DoClick=function()
		gui.OpenURL"https://github.com/Metastruct/outfitter/issues"
	end
	b:DockMargin(4,2,4,2)
	self:AddItem(b)
	
	local b = vgui.Create( "DButton", self )
	b:SetText"Get outfitter"
	b.DoClick=function()
		gui.OpenURL"http://www.google.com/search?q=garrysmod+outfitter"
	end
	b:DockMargin(4,2,4,2)
	self:AddItem(b)
	
	local lbl_desc = vgui.Create('DLabel',self)
	lbl_desc:SetText[[Finally, the people responsible for this mess include but are not limited to:]]
	lbl_desc:DockMargin(4,14,4,8)
	--lbl_desc:SetFont(fdesc)
	lbl_desc:SetDark(false)
	lbl_desc:SetAutoStretchVertical(true)
	lbl_desc:SetWrap(true)
	lbl_desc:Dock(TOP)
	self:AddItem(lbl_desc)
end

function PANEL:AddItem(i)
	i:Dock(TOP)
	self.content:AddItem(i)
end
local link
function PANEL:GenAbout(entry)
	local title,id,desc = unpack(entry)
	local sid64 = isstring(id) and id:match'^%d+$' and id
	local custom
	if istable(id) then
		sid64=id[1]
		id = id[2]
		custom=true
	end
	
	local pnl = vgui.Create('DPanel',self)
	
	local ftitle,fdesc = 'TargetID','default'
	
	self:AddItem(pnl)
	pnl:SetTall(140)
	pnl:DockMargin(0,0,0,4)
	pnl:DockPadding(1,1,1,4)
	
	local avatar = vgui.Create('EditablePanel',pnl)
	avatar:Dock(LEFT)
	avatar:SetWidth(48)
	avatar:DockMargin(2,2,2,2)
	
	avatar.Paint=sid64 and function(avatar,w,h)
		local sz = w<h and w or h
		SetAvatarTexture184(sid64)
		local ox = w-sz
		local oy = 0
		if h-sz<5 then
			oy = h*.5-sz*.5
		end
		
		surface.SetDrawColor(255,255,255,255)
		surface.DrawTexturedRect(ox,oy,sz,sz)
		--surface.SetDrawColor(33,33,33,111)
		--surface.DrawOutlinedRect(0,0,w,h)
		if avatar:IsHovered() then
			surface.SetDrawColor(111,155,255,77)
			surface.DrawRect(ox,oy,sz,sz)
		end
	end or function(avatar,w,h)
		local sz = w<h and w or h
		local ox = w-sz
		local oy = 0
		if h-sz<5 then
			oy = h*.5-sz*.5
		end
		surface.SetDrawColor(120,110,100,90)
		surface.DrawOutlinedRect(ox,oy,sz,sz)
		
		surface.SetDrawColor(255,255,255,255)
		link = link or Material"icon16/link.png"
		surface.SetMaterial(link)
		surface.DrawTexturedRect(ox+sz*.5-8,oy+sz*.5-8,16,16)
		--surface.SetDrawColor(33,33,33,111)
		--surface.DrawOutlinedRect(0,0,w,h)
	end

	avatar:SetCursor"hand"
	avatar:SetMouseInputEnabled(true)
	avatar.OnMousePressed = function(avatar)
		local url = id
		if url:match'^%d+$' then
			url = 'http://steamcommunity.com/profiles/'..url
		end
		gui.OpenURL(url)
	end
	
	--function pnl.Paint(pnl,w,h)
	--	surface.SetDrawColor(255,255,255,100)
	--	surface.DrawOutlinedRect(0,0,w,h)
	--end

	local lbl = vgui.Create('DButton',pnl)
	lbl:SetText(title)
	lbl:SetFont(ftitle) lbl:SetDark(true) lbl:SetAutoStretchVertical(true)
	lbl:Dock(TOP)
	lbl:SetDrawBorder(false)
	lbl:SetDrawBackground(false)
	lbl:SetContentAlignment( 1 )
	lbl:SetCursor"hand"
	if sid64 and not custom then 
		co(function()
			local nick,err = co.steamnick(sid64)
			if not nick or not lbl:IsValid() then return end
			lbl:SetText(tostring(nick))
		end)
	end
	
	lbl:DockMargin(4,0,0,0)
	lbl:SetMouseInputEnabled(true)
	lbl.DoClick = function()
		local url = id
		if url:match'^%d+$' then
			url = 'http://steamcommunity.com/profiles/'..url
		end
		gui.OpenURL(url)
	end
	
	local lbl_desc = vgui.Create('DLabel',pnl)
	lbl_desc:SetText(desc)
	lbl_desc:DockMargin(4+4,0,0,0)
	lbl_desc:SetFont(fdesc) lbl_desc:SetDark(true) lbl_desc:SetAutoStretchVertical(true)
	lbl_desc:SetWrap(true)
	lbl_desc:Dock(TOP)
	lbl_desc.PaintOver=function(lbl,w,h)
		surface.SetDrawColor(120,110,100,5)
		surface.DrawOutlinedRect(0,0,w,h)
	end
	
	function pnl.PerformLayout(pnl)
		local t = {}
		local minh = self:GetTall()
		for k,v in next,pnl:GetChildren() do
			local dock = v:GetDock()
			if dock==LEFT or dock==RIGHT then
				t[v]={dock,v:GetSize()}
				v:SetTall(1)
			end
		end
		pnl:SizeToChildren(false,true)
		local msz = 48+1*2+2*2+3.456
		if pnl:GetTall()<msz then
			pnl:SetTall(msz)
		end
		--for p,dat in next,t do
		--	p:Dock(dat[1])
		--	p:SetSize(dat[2],dat[3])
		--end
		--
	end
end

PANEL._Init = PANEL.Init
local PANEL2=table.Copy(PANEL)

function PANEL:PerformLayout(w,h)
	DFrame.PerformLayout(self,w,h)
end
function PANEL:Hide()
        self:SetVisible(false)
end


function PANEL:Show()
	surface.PlaySound"garrysmod/ui_return.wav"
	self:SetVisible(true)
	self:MakePopup()
end

function PANEL:Init() self:_Init(false) end
local factory = vgui.RegisterTable(PANEL,'DFrame')

function PANEL2:Init() self:_Init(true) end
about_factory = vgui.RegisterTable(PANEL2,'EditablePanel')

if this.m_pAboutDlg and ValidPanel(this.m_pAboutDlg) then
	m_pAboutDlg:Remove()
end

m_pAboutDlg = NULL
function GUIAbout()
	
	if not ValidPanel(m_pAboutDlg) then
		local d = vgui.CreateFromTable(factory,nil,Tag..'_about')
		m_pAboutDlg = d
	end
	
	
	m_pAboutDlg:Show()
	
	return m_pAboutDlg
end

	
concommand.Add(Tag..'_about',function()
	GUIAbout()
end)
--PATH addons/_outfitter/lua/outfitter/gui.lua:
local Tag='outfitter'

-- lua_openscript_cl srv/outfitter/lua/outfitter/ui.lua;lua_openscript_cl srv/outfitter/lua/outfitter/gui.lua;outfitter_open

module(Tag,package.seeall)
local NOUI=OUTFITTER_NO_UI

local outfitter_gui_focusdim = CreateClientConVar("outfitter_gui_focusdim","0",true)
local vgui = GetVGUI()

-- GUIWantChangeModel
	local PANEL = {}
	
	local matUp = Material"icon16/arrow_up.png"
	
	function PANEL:Init()
		local txt = vgui.Create('DLabel',self,'msg')
		txt:Dock(TOP)
		txt:SetText"If the browser does not change URL please paste the URL yourself in the browser bar from your web browser."
		txt:SetTextColor(Color(0,0,0,255))
		local b = vgui.Create('DButton',self.top,'choose button')
			
			self.chooseb = b
			b:Dock(RIGHT)
			b:SetIcon("icon16/accept.png")
			b:SetText"#select_character"
			b:SizeToContents()
			
			b:SetWidth(math.min(b:GetSize(),256)+32)
			b:SetEnabled(false)
			b:SetZPos(100)
			b:SetCookieName("ofchoosewsbutn")
			b.hideusehint = b:GetCookie("hideusehint")
			b:NoClipping(false)
			b.PaintOver = function(b,w,h)

				if b:IsEnabled() then
					DisableClipping(true)
					
					surface.SetDrawColor(30,255,0,30)
					surface.DrawRect(0,0,w,h)
					surface.SetDrawColor(66,255,22,255*.5 + 255*.3 * (math.sin(RealTime()*7)>0.3 and 1 or -1))
					surface.SetDrawColor(66,255,22,255*.5 + 255*.3 * (math.sin(RealTime()*7)>0.3 and 1 or -1))

					surface.DrawOutlinedRect(-1,-1,w+2,h+2)
					surface.DrawOutlinedRect(0,0,w,h)
					
					
					surface.SetDrawColor(255,255,255,255)
					surface.SetMaterial(matUp)
					local sz = 32
					surface.DrawTexturedRect(w*.5-sz*.5,h-2+math.sin(RealTime()*7)*4,sz,sz)
					
					DisableClipping(false)
				end
			end
		
			b.DoClick=function(b,mc)
				b.hideusehint=true
				b:SetCookie("hideusehint",'1')
				self:WSChoose()
			end
			self:GetBrowser():AddFunction( "gmod", "wssubscribe", function() self:WSChoose() end )
			
	end

	function PANEL:WSChoose()
		self:Hide()
		if self.chosen_id then
			surface.PlaySound"npc/vort/claw_swing1.wav"
			UIChoseWorkshop(self.chosen_id,self.returntoui)
		end
	end
	function PANEL:LoadedURL(url,title)
		self.BaseClass.LoadedURL(self,url,title)
		if not url or url=="" then return end
		
		-- sharedfiles/filedetails/?id=422403917&searchtext=playermodel

		local id = UrlToWorkshopID(url)
		self.chooseb:SetEnabled(id and true or false)
		self.chosen_id = tonumber(id)
		--print(id)
	end
	
	function PANEL:InjectScripts(browser)
		--dbg("Injecting browser code",browser or "NOBROWSER")
		browser:QueueJavascript[[
		
			function SubscribeItem() {
				gmod.wssubscribe();
			};
			
			setTimeout(function() {
				function SubscribeItem() {
					gmod.wssubscribe();
				};
			
				var sub = document.getElementById("SubscribeItemOptionAdd");
				if (sub) {
					sub.innerText = "Select";
				};
			}, 0);
			
		]]
	end
	function PANEL:Show(str,returntoui)
		
		self.returntoui = returntoui
		
		local dourl = not self.already_loaded
		self.already_loaded = true
		
		local url = 'http://steamcommunity.com/workshop/browse/?appid=4000&searchtext=playermodel&childpublishedfileid=0&browsesort=trend&section=readytouseitems&requiredtags%5B%5D=Model'
		if str then
			str = str and tostring(str)
			str = str and #str>0 and str
			if str then
				str = string.urlencode and string.urlencode(str) or str
				url = 'http://steamcommunity.com/workshop/browse/?appid=4000&searchtext=playermodel+'..str..'&childpublishedfileid=0&browsesort=trend&section=readytouseitems&requiredtags%5B%5D=Model'
			end
		end
		
		if dourl then
			self:OpenURL(url)
		end
		self.BaseClass.Show(self)
	end
	function PANEL:CheckEntryURLChange()
		if self.chooseb:IsEnabled() then return end
		local txt = self.entry and self.entry:GetValue()
		if not txt then return end
		if txt~=self.lasttextobserved then
			self.lasttextobserved = txt
			local id = UrlToWorkshopID(txt)
			--print("checked entry, found",id,"from",txt)
			self.chooseb:SetEnabled(id and true or false)
			self.chosen_id = tonumber(id)

		end
		
	end
	
	function PANEL:Think()
		self.BaseClass.Think(self)
		self:CheckEntryURLChange()
	end
	vgui.Register(Tag,PANEL,'custombrowser')

	m_vModelDlg = NULL
	function GUIWantChangeModel(str,returntoui)
		
		if not ValidPanel(m_vModelDlg) then
			local d = vgui.Create(Tag,nil,Tag)
			m_vModelDlg = d
		end
		
		m_vModelDlg:Show(str,returntoui)
		
		return m_vModelDlg
	end

	
	
	

	
	
	
	
	
	
	
	
	
-- GUIOpen



local PANEL = {}
function PANEL:Init()
	
	local functions = self:Add('DPanel','settings')
	functions:Dock(LEFT)
	functions:SetWidth(300)
	functions:SetHeight(300)
	functions:DockMargin(4,1,24,0)
	functions:SetPaintBackground(false)
	
	--functions:EnableVerticalScrollbar()

	local function Add(itm,b)
		local c= vgui.Create(itm,functions,b)
		--settingslist:AddItem(c)
		c:Dock(BOTTOM)
		return c
	end
	
	do
		local b = functions:Add('DButton','choose button')
			self.btn_choose = b

			b:Dock(TOP)
			b:SetText("#open_workshop")
			b:SetTooltip[[Choose a workshop addon which contains an outfit]]

			b.DoClick= function()
				
				GUIWantChangeModel(nil,true)
				
				self:GetParent():Hide()
			end
			b:DockMargin(0,4,1,8)
			b:SetImage'icon16/folder_user.png'
			b.PaintOver = function(b,w,h)
				if not next(self.mdllist:GetLines()) then
					b:NoClipping(false)
					surface.SetDrawColor(140,255,140,255*.5 + 255*.3 * math.sin(RealTime()*4))

					surface.DrawOutlinedRect(-1,-1,w+2,h+2)
					surface.DrawOutlinedRect(0,0,w,h)
					b:NoClipping(true)
				end
			end
	end
	do
		local b = functions:Add('DTextEntry','url input')
			self.input_mdlsource = b

			b:Dock(TOP)
			b:SetText("")
			b:SetPlaceholderText("https://steamcommunity.com/sharedfiles/filedetails/?id=1234")

			b.OnEnter= function()
				
				local url = b:GetValue():Trim()
				if url =="puze" then 
					url="https://g2cf.metastruct.net/delme/puze.gma"
				end
				local wsid = UrlToWorkshopID(url,true)
				dbg("GUI","UrlToWorkshopID",url,wsid)
				if wsid then

					surface.PlaySound"npc/vort/claw_swing1.wav"
					UIChoseWorkshop(wsid,true)
					self:GetParent():Hide()
				else
					if IsHTTPURL(url) then
						if AllowedHTTPURL(url) then
							self:GetParent():Hide()
							UIChoseHTTPGMA(url,true)
						else
							chat.AddText("This HTTP URL is not in allowlist")					
							surface.PlaySound"common/warning.wav"
						end
					else
						dbg("Not HTTP URL",url)
						surface.PlaySound"common/warning.wav"
					end
				end
			end
			b:DockMargin(0,4,1,8)
	end

	local l = functions:Add( "DLabel",'chosen' )
		self.lbl_chosen = l
		l:Dock(TOP)
		l:DockMargin(1,1,1,1)
		l:SetWrap(true)
		l:SetTooltip[[Title of the chosen workshop addon]]
		l:SetText("1. Choose a workshop addon")
		l:SetTall(44)
		l:SetFont"BudgetLabel"
		l:SetTextColor(Color(255,255,255,255))
		
		
	
	local mdllist = functions:Add( "DListView",'modelname' )
		mdllist:SetMultiSelect( false )
		mdllist:AddColumn( "#gameui_playermodel" )
		self.mdllist = mdllist
		mdllist:SetTooltip[[Click one of the models on this list to choose as your outfit]]
		mdllist:DockMargin(0,5,0,0)
		mdllist:Dock(FILL)
		mdllist:SetTall(128)
		mdllist.OnRowSelected = function(mdllist,n,itm)
			local ret = GUIChooseMDL(n)
			if not ret then
				surface.PlaySound"common/warning.wav"
			end
			self.btn_bg:Refresh()
		end
		--TODO : OnRowRightClick
		function mdllist.PerformLayout(mdllist)
			DListView.PerformLayout(mdllist)
			self.btn_bg:InvalidateLayout()
		end
		mdllist.PaintOver = function(b,w,h)
			if next(mdllist:GetLines()) and not mdllist:GetSelectedLine() then
				mdllist:NoClipping(false)
				surface.SetDrawColor(255,66,22,255*.5 + 255*.3 * math.sin(RealTime()*4))

				surface.DrawOutlinedRect(-1,-1,w+1,h+1)
				surface.DrawOutlinedRect(0,0,w,h)
				mdllist:NoClipping(true)
			end
		end
		
	local sheet = self:Add( "DPropertySheet" )
		self.sheet = sheet
		sheet:Dock( FILL )
		
	local mdlhistpanel = self:Add( "EditablePanel" )
		self.mdlhistpanel=mdlhistpanel
		sheet:AddSheet( "#servers_history", mdlhistpanel, "icon16/user.png" )
	local settingspnl = self:Add( "DScrollPanel" )
		self.settingspnl=settingspnl
		sheet:AddSheet( "#spawnmenu.utilities.settings", settingspnl, "icon16/cog.png" )
	local blocklistPanel = self:Add( "EditablePanel" )
		self.blocklistPanel=blocklistPanel
		sheet:AddSheet( "#Blocklist", blocklistPanel, "icon16/stop.png" )
	local infopanel = self:Add( "EditablePanel" )
		self.infopanel=infopanel
		infopanel.Think=function()
			infopanel.Think=function() end
			
			local p = vgui.CreateFromTable(about_factory,infopanel)
			self.aboutpnl = p
			--print"create about"
			infopanel.aboutpnl = p
			p:Dock(FILL)
		end
		infopanel:Dock(FILL)
		sheet:AddSheet( "#information", infopanel, "icon16/information.png" )
		
		local function AddS(itm,b)
			
			local c= vgui.Create(itm,settingspnl,b)
			--settingslist:AddItem(c)
			c:Dock(TOP)
			return c
		end
		
		
	
	
	----------------------------------------------------


	blocklistPanel:DockPadding( 2,1,2,1 )


	local txt = blocklistPanel:Add('DLabel','infomsg')
	txt:Dock(TOP)
	txt:SetText"Title blocklist"
	txt:SetWrap(true)
	txt:SetTextColor(Color(0,0,0,255))


	
	local check = blocklistPanel:Add( "DCheckBoxLabel",'nsfwtoggle' )
	 	check:SetConVar("nsfw")
		check:SetText( "Allow NSFW")
		check:SizeToContents()
		check:SetTooltip[[Allow NSFW content in title]]
		check:DockMargin(1,0,1,1)
		check:Dock(TOP)

	local TextEntry = blocklistPanel:Add("DTextEntry", "blocklist" )
	TextEntry:SetSize(100,200)
	TextEntry:Dock( FILL )
	TextEntry:SetValue(table.concat(GetTitleBlocklist(),"\n"))
	TextEntry:SetMultiline(true)
	TextEntry:SetVerticalScrollbarEnabled(true)
	TextEntry:SetAllowNonAsciiCharacters(true)
	TextEntry:SetEditable(true)
	TextEntry:SetTooltip"Add a banned sentence per line.\n An outfit's title matching any of the sentences will be blocked."
	TextEntry:SetPlaceholderText"Add a banned sentence per line.\n An outfit's title matching any of the sentences will be blocked."
	function TextEntry.OnLoseFocus()
		SetTitleBlocklist(TextEntry:GetValue())
		TextEntry:SetValue(table.concat(GetTitleBlocklist(),"\n"))
	end
	----------------------------------------------------

	mdlhistpanel:DockPadding( 2,1,2,1 )

	local function hr()
		local b = AddS('EditablePanel')
		b:SetTall(2)
		b:DockMargin(1,24,1,2)
		b.Paint = function(b,w,h)
			surface.SetDrawColor(240,240,240,200)
			surface.DrawRect(0,0,w,h)
		end
		local hr_line1 = b
	end

	local scroll = mdlhistpanel:Add( "DScrollPanel",'mdlhistscroll' )
	scroll:Dock(FILL)
	local mdlhist = scroll:Add( "DIconLayout",'mdlhist' )
		mdlhist:DockMargin(4,4,4,4)
		--mdlhist:SetMultiSelect( false )
		--mdlhist:AddColumn( "#name" )
		--mdlhist:AddColumn( "#gameui_playermodel" )
		self.mdlhist = mdlhist
	
		
		mdlhist:Dock(FILL)
		mdlhist.OnRowSelected = function(mdlhist,n,itm)
			local dat = GUIGetHistory()[n]
			if not dat then return end
			if not self:WantOutfitMDL(unpack(dat)) then
				surface.PlaySound"common/warning.wav"
			end
		end

		function mdlhist:Clear()
			local chld = self:GetChildren()
			for k, v in pairs( chld ) do
				v:Remove()
			end
		end
		
	local b = mdlhistpanel:Add('DButton','choose button')
		self.btn_clearhist = b
		
		b:Dock(BOTTOM)
		
		b:SetText("#gameui_clearbutton")
		b.DoClick= function()
			GUIClearHistory()
		end
		b:DockMargin(0,5,0,0)
		b:SetImage'icon16/bin.png'

	local slider = AddS( "DNumSlider" )
		slider:SetText( "Outfit download distance" )
		slider:SizeToContents()
		slider:DockPadding(0,16,0,0)
		slider.Label:Dock(TOP)
		slider.Label:DockMargin(0,-16,0,0)
		slider:SetTooltip[[How near does a player have to be for an outfit to download]]

		slider:DockMargin(1,12,1,1)
		slider:SetMin( 500 )
		slider:SetMax( 5000 )
		slider:SetDecimals( 0 )
		slider:SetConVar( Tag..'_distance' )
		local sld_dist = slider
			
	local c = AddS( "DComboBox" )
	c:SetSize( 100, 20 )
	c:SetTooltip[[Distance mode: start downloading outfits when you get near a player]]
	--c.SetValue = function(c,val)
	--	local setv = val==0 and 2 or val==1 and 3 or 1 
	--	dbgn(2,"ChooseDistanceModeCtrl",val,'->',setv)
	--	c:ChooseOptionID(setv)
	--end
	local distance_mode
	c.OnSelect = function(c,val)
		distance_mode=distance_mode or GetConVar(Tag..'_distance_mode')
		local choose = val==1 and -1 or val==2 and 0 or 1
		dbgn(2,"ChooseDistanceMode", val, '->', choose )
		distance_mode:SetInt(choose)
	end
	c:AddChoice( "Default Mode", '-1' )
	c:AddChoice( "See All Outfits", '0' )
	c:AddChoice( "Nearby Outfits Only", '1' )
	
	c:SetConVar(Tag..'_distance_mode')
	local d_4 = c
	c:DockMargin(0,12,0,0)
	
	--TODO
	--local check = functions:Add( "DCheckBoxLabel" )
	-- 	check:SetConVar(Tag.."_ask")
	--	check:SetText( "Ask mode")
	--	check:SizeToContents()
	--	check:Dock(TOP)
	--	check:DockMargin(1,4,1,1)
	
	
	hr()

	local check = AddS( "DCheckBoxLabel" )
	 	check:SetConVar(Tag.."_hands")
		check:SetText( "Use hands")
		check:SetTooltip[[Should we guess hands for the playermodels]]
		check:SizeToContents() 

		check:DockMargin(1,4,1,1)
	local d_6 = check
	
	local check = AddS( "DCheckBoxLabel" )
	 	check:SetConVar(Tag.."_sounds")
		check:SetText( "UI sounds")
		check:SetTooltip[[Should we play informational sounds]]
		check:SizeToContents() 

		check:DockMargin(1,4,1,1)
	local d_7 = check
	
	local check = AddS( "DCheckBoxLabel" )
	 	check:SetConVar(Tag.."_gui_focusdim")
		check:SetText( "Dim GUI")
		check:SetTooltip[[When mouse leaves the UI should we dim it?]]
		check:SizeToContents()
		check:DockMargin(1,4,1,1)
		
	hr()

	local debug = AddS( "DCheckBoxLabel" )
	 	debug:SetConVar(Tag.."_dbg")
		debug:SetText( "#debug")
		debug:SetTooltip[[Print debug stuff to console. Enable this if something is wrong and in the bugreport give the log output.]]
		debug:SizeToContents()
 
		debug:DockMargin(1,14,1,1)
		local d_3 = debug

	local check = AddS( "DCheckBoxLabel" )
	 	check:SetConVar(Tag.."_unsafe")
		check:SetText( "Unsafe")
		check:SizeToContents()

		check:SetTooltip[[Remove some outfit checks (for yourself only). This should not be needed ever.]]
		check:DockMargin(1,4,1,1)
		local d_1 = check
	local check = AddS( "DCheckBoxLabel" )
	 	check:SetConVar(Tag.."_failsafe")
		check:SetText( "Failsafe")
		check:SizeToContents()
		check:SetTooltip[[This gets ticked if you were detected to crash right after applying outfit.]]

		check:DockMargin(1,4,1,1)
		local d_2 = check
		
	local check = AddS( "DCheckBoxLabel" )
	 	check:SetConVar(Tag.."_use_autoblacklist")
		check:SetText( "Autoblacklist")
		check:SizeToContents()
		check:SetTooltip[[Blacklists outfits that crashed you automatically]]
		check:DockMargin(1,4,1,1)
		local d_2 = check
	hr()
	local check = AddS( "DCheckBoxLabel" )
	 	check:SetConVar(Tag.."_animfix_oldmethod")
		check:SetText( "Legacy: Use fullupdate for local player animations")
		check:SizeToContents()
		check:SetTooltip[[Previously we needed a fullupdate to fix animations. Now a different technique is used.]]

		check:DockMargin(1,4,1,1)
		
	local check = AddS( "DCheckBoxLabel" )
		check:SetConVar(Tag.."_download_notifications")
		check:SetText( "Legacy: Show downloading notifications")
		check:SizeToContents()
		check:SetTooltip[[Show downloading notifications when downloading models from the workshop]]

		check:DockMargin(1,4,1,1)

	local check = AddS( "DButton" )
	 	check:SetText( "FIX: Clear models blacklist") 
		check:DockMargin(1,4,1,1)
		check.DoClick=function()
			RunConsoleCommand"outfitter_blacklist_clear"
		end
		check:SetImage'icon16/tag_blue_delete.png'
		
	local check = AddS( "DButton" )
	 	check:SetText( "FIX: Fullupdate") 
		check:DockMargin(1,4,1,1)
		check.DoClick=function()
			Fullupdate()
		end
		check:SetImage'icon16/transmit_error.png'
		
	local check = AddS( "DButton" )
	 	check:SetText( "FIX: Local player animations") 
		check:DockMargin(1,4,1,1)
		check.DoClick=function()
			FixLocalPlayerAnimations(true)
		end
		check:SetImage'icon16/transmit_error.png'
		
	local b = Add('DButton','thirdperson')
		b:SetText("#tool.camera.name")
		b:SetTooltip[[Enables/disable thirdperson (if one is installed)]]

		b.DoClick=function() ToggleThirdperson() end
		b:DockMargin(16,2,16,1)
		b:SetImage'icon16/find.png'
	
	
	
	--local b = Add('EditablePanel')
	--b:SetTall(1)
	--b:DockMargin(-4,24,-4,1)
	--b.Paint = function(b,w,h)
	--	surface.SetDrawColor(240,240,240,200)
	--	surface.DrawRect(0,0,w,h)
	--end
	--local hr_line1 = b
	
	--------------------------------------------------
	
	
		
	-- second layer
	local cont = functions:Add('EditablePanel','container')
	cont:SetTall(24)
	cont:Dock(BOTTOM)
		
	local b = vgui.Create('DButton',mdllist,'Bodygroups button')
		function b.Refresh(b)
			-- poor man's pcall
			co(function()
				b.mdl = false
				b:SetEnabled2(false)
				dbg("Bodygroup","BTN","Refresh")
				
				local l = UIGetMDLList()
				if not l then return end
				local chosen = UIGetChosenMDL()
				if not chosen then return false end
				local mdl = l[chosen]
				if not mdl then return false end
				if not file.Exists(mdl.Name,'workshop') and not file.Exists(mdl.Name,'GAME') then return false end
				local a = mdlinspect.Open(mdl.Name)
				a:ParseHeader()
				local parts = a:BodyPartsEx()
				local ok 
				for k,v in next,parts do
					if v.nummodels>1 then
						ok=true
						break
					end
				end
				if not ok then return end
				
				b:SetEnabled2(true)
				b.mdl = mdl
			end)
		end
		
		
		self.btn_bg= b
		b:Dock(NODOCK)
		b:SetText("")
		b:SetSize(24,24)
		b:SetTooltip[[#GameUI_Modify]]
		b.DoClick= function()
			GUIOpenBodyGroupOverlay(self) --, b.mdl.Name)
		end
		b:SetImage'icon16/group_edit.png'
		b.PerformLayout=function(b,w,h)
			DButton.PerformLayout(b,w,h)
			
			local w2 = b:GetParent():GetCanvas():GetWide()
			
			local _,y = b:GetParent():GetSize()
			b:SetPos(w2-w-1,y-h-1)
		end
		function b.SetEnabled2(b,v)
			b:SetDisabled(not v)
			b._set_enabled = v
		end
		--b.PaintOver= function(b,w,h)
		--	if b._set_enabled then
		--		if UIGetChosenMDL() and UIGetMDLList() and LocalPlayer().latest_want~=UIGetMDLList()[UIGetChosenMDL()] then
		--			surface.SetDrawColor(55,240,55,40+25*math.sin(RealTime()*7)^2)
		--			surface.DrawRect(1,1,w-2,h-2)
		--		end
		--	end
		--end
	
	local b = cont:Add('DButton','Autowear button')
		self.btn_autowear = b
		b:SetTooltip[[Automatically wear this outfit on servers]]
		b:SetText("#makepersistent")
		b:Dock(FILL)
		b:SizeToContents()
		b.DoClick = function()
			local m = DermaMenu()
				m:AddOption("#makepersistent",function()
					SetAutowear()
				end):SetIcon'icon16/vcard_edit.png'
				m:AddOption("#vgui_htmlreload",function()
					if co.make() then return end
					coDoAutowear()
				end):SetIcon'icon16/transmit_go.png'
			m:Open()
		end
		b:SetImage'icon16/disk.png'
	
	
	--------------------------------------------------

	
	local cont = functions:Add('EditablePanel','container')
	cont:SetTall(32)
	cont:Dock(BOTTOM)
	
	local b = cont:Add('DButton','Send button')
		self.btn_send= b
		b:Dock(LEFT)
		b:SetText("#gameui_submit")
		b:SetTooltip[[This broadcasts the outfit you have chosen to the whole server]]
		b.DoClick= function()
			GUIBroadcastMyOutfit()
			b._set_enabled  = false
			self:GetParent():Hide()
		end
		b:SetImage'icon16/transmit.png'
		b.PerformLayout=function(b,w,h)
			DButton.PerformLayout(b,w,h)
			b:SetWide(b:GetParent():GetWide()*.5)
		end
		self.btnSendOutfit = b
		function b.SetEnabled2(b,v)
			b:SetDisabled(not v)
			b._set_enabled = v
		end
		b.PaintOver= function(b,w,h)
			if b._set_enabled then
				if UIGetChosenMDL() and UIGetMDLList() and LocalPlayer().latest_want~=UIGetMDLList()[UIGetChosenMDL()] then
					surface.SetDrawColor(55,240,55,40+25*math.sin(RealTime()*7)^2)
					surface.DrawRect(1,1,w-2,h-2)
				end
			end
		end
	
	
	
	local b = cont:Add('DButton','Clear button')
		self.btn_clear = b
		b:SetTooltip[[This removes all traces of you wearing an outfit]]
		b:SetText("#gameui_cancel")
		b:Dock(FILL)
		b:SizeToContents()
		b.DoClick= function()
			UICancelAll()
			self:DoRefresh(trychoose_mdl)
			--self:GetParent():Hide()
		end
		b:SetImage'icon16/cancel.png'
		
		
	
	local div = self:Add"DHorizontalDivider"
	div:Dock( FILL )
	
	functions:Dock(NODOCK)
	sheet:Dock(NODOCK)
	div:SetCookieName(Tag)
	div:SetLeft( functions )
	div:SetRight( sheet )
	div:SetDividerWidth( 4 ) --set the divider width. DEF: 8
	div:SetLeftMin( 150 )	 --set the minimun width of left side
	div:SetRightMin( 0 )
	div:SetLeftWidth( 300 )

	--------------------------------------------------
	
end


gui_readytosend = false
local wanting = false
local want_wsid
local want_mdl
function PANEL:WantOutfitMDL(wsid,mdl,title)
	dbg("WantOutfitMDL",wanting and "ALREADY WANTING" or "",wsid,mdl,title)
	if wanting and want_wsid == wsid then
		want_mdl = mdl
	end
	
	if wanting then return false end
	want_wsid = wsid
	want_mdl = mdl
	
	local worker=co(function()
		if wanting then return end
		wanting = true
		self:GetParent():Hide()
		dbg("WantOutfitMDL",wanting and "ALREADY WANTING" or "",wsid,mdl,title)
		local ok,err = xpcall(UIChoseWorkshop,debug.traceback,wsid)
		if not ok then ErrorNoHalt(err..'\n') wanting=false return end
		GUIOpen(nil,want_mdl)
		wanting = false
	end)
	
	return worker

end


function PANEL:WSChoose()
	self:Hide()
	if self.chosen_id then
		surface.PlaySound"npc/vort/claw_swing1.wav"
		UIChoseWorkshop(self.chosen_id)
	end
end


function GUIBroadcastMyOutfit()
	local mdl,wsid = UIBroadcastMyOutfit()
	if mdl and wsid then
		co(function()
			local self = GUIPanel()
			--if self and self.lbl_chosen:IsValid() then
			--	self.lbl_chosen:SetText( "Loading info..." )
			--end
			
			
			
			local info = co_steamworks_FileInfo(wsid)
			local title = info.title
			local self = GUIPanel()
			--if self and self.lbl_chosen:IsValid() then
			--	self.lbl_chosen:SetText( title or "" )
			--end
			if not title then return end
			GUIAddHistory(wsid,title,mdl)
		end)
	end
end

local want_n
local choosing
function GUIChooseMDL(n)
	
	dbg("GUIChooseMDL",n,choosing and "already choosing, changing" or "",want_n)
	want_n = n
	
	if choosing then return false end
	local mdllist = UIGetMDLList()
	local mdl = mdllist and mdllist[n]
	if not mdl then return false end
	
	co(function()
		if choosing then return end
		choosing = true
		UIChangeModelToID(n)
		if n~=want_n and want_n then
			dbg("CHANGE WANT OT",want_n)
			UIChangeModelToID(want_n,true)
		end
		dbg("GUIChooseMDL","FINISH",n)
		want_n = nil
		choosing = false
		GUICheckTransmit()
	end)
	return mdl
end


function GUIClearHistory()
	GUIDelHistory(-1)
end

local function SAVE(t)
	local s= json.encode(t)
	util.SetPData("0",Tag,s)
end

local function LOAD()
	local s= util.GetPData("0",Tag,false)
	if not s or s=="" or s=="nil" then return {} end
	local t = json.decode(s)
	return t or {}
end

local hist
function GUIAddHistory(wsid,title,mdl)
	if not title or not mdl or not wsid then return end
	if not hist then
		GUIGetHistory()
	end
	for k,v in next,hist do
		local wsid2,mdl2 = v[1],v[2]
		if wsid2==wsid and mdl2==mdl then return end
	end
	
	local t = {wsid,mdl,title}
	table.insert(hist,t)
	SAVE(hist)
	
	GUIRefresh()
	
	return t
end

function GUIGetHistory()
	if not hist then hist = LOAD() end
	return hist
end

function GUIDelHistory(n)
	if n<0 then table.Empty(hist) end
	local ret = table.remove(hist,n)
	SAVE(hist)
	
	GUIRefresh()
	
	return ret
end

function GUICheckTransmit()
	local gui  = GUIPanel()
	if not gui then return end
	local self = gui.content
	if not self then return end
	
	local cansend = UIGetChosenMDL() and UIGetDownloadInfoX() and UIGetMDLList()
	self.btnSendOutfit:SetEnabled2(cansend)
	self.btn_bg:Refresh()
end

function PANEL:DoRefresh(trychoose_mdl)
	dbg("doRefresh",trychoose_mdl)
	self.mdllist:Clear()
	self.btn_bg:Refresh()
	self.mdlhist:Clear()
	
	self.lbl_chosen:SetText("Please choose a workshop addon")

	local wsid = UIGetWSID()
	
	co(function()
		self.lbl_chosen:SetText("-")

		if wsid and tonumber(wsid) then
			self.lbl_chosen:SetText( "Loading info..." )
			local info = co_steamworks_FileInfo(wsid)
			if not self:IsValid() then return end
			if not self.lbl_chosen:IsValid() then return end
			
			if wsid~=UIGetWSID() then
				return
			end
			if not info or not info.title then
				self.lbl_chosen:SetText("-")
			else
				local str = ("%s (%s)"):format(info.title,string.NiceSize(info.size or 0))
				self.lbl_chosen:SetText(str)
			end
		
		elseif wsid and #wsid:find"http" then -- it's a gma download
			local ok,body,len,hdrs,code = co_head(wsid)
			if ok then
				self.lbl_chosen:SetText("GMA: Not OK?")
			else
				local size = hdrs and hdrs["Content-Length"] and tonumber(hdrs["Content-Length"])
				self.lbl_chosen:SetText(("GMA HEAD OK (%s)"):format(size and string.NiceSize(size) or "Size Unknown!"))
			end
		end
	end)

	
	local tm = UITriedMounting()
	local mdllist = UIGetMDLList()
	
	GUICheckTransmit()
	
	
	-- model list
	local chosen
	for k,dat in next,mdllist or {} do
		if trychoose_mdl and trychoose_mdl==dat.Name then
			chosen = true
		end
		local pnl = self.mdllist:AddLine( dat.Name and MDLToUI(dat.Name) or "???" )
		
		if chosen and chosen==true then
			chosen = pnl
		end
		
	end
	
	local extra = UIGetMDLListExtra()
	if extra and extra.discards then
		
		for k,dat in next,extra.discards or {} do
			local pnl = self.mdllist:AddLine( dat.Name and MDLToUI(dat.Name) or "???" )
			pnl:SetTooltip(dat.error_player or dat.error_vvd or "INVALID MODEL")
			local Paint = pnl.Paint or function() end
			pnl.Paint = function(pnl,w,h)
				local r = Paint(pnl,w,h)
				surface.SetDrawColor(240,30,30,120)
				surface.DrawRect(0,0,w,h)
				return r
			end
		end
	
	end
	
	for _,v in next,GUIGetHistory() do
		local wsid,mdl,title = unpack(v)

		
		local pnl = self.mdlhist:Add( 'DOWorkshopIcon' )
		pnl:SetAddon({wsid = wsid,title=MDLToUI(mdl)})
		self.mdlhist:Layout()
		pnl:SetTooltip(title .. '\n'..mdl)
		pnl._OnMousePressed = pnl.OnMousePressed
		pnl.OnMousePressed = function(pnl,mc)
			if mc==MOUSE_RIGHT then
				local m = DermaMenu()
					m:AddOption("#open_workshop",function()
						gui.OpenURL(("https://steamcommunity.com/workshop/filedetails/?id=%d"):format(wsid))
					end):SetIcon'icon16/world.png'
					m:AddOption("#gameui_delete",function()
						for n,vv in next,GUIGetHistory() do
							if vv==v then
								GUIDelHistory(n)
								return
							end
						end
					end):SetIcon'icon16/bin.png'
				m:Open()
				return
			elseif mc==MOUSE_LEFT then
				if not self:WantOutfitMDL(unpack(v))then
					surface.PlaySound"common/warning.wav"
				end
			end
			
		end
	end

	if chosen then
		if chosen~=true then
			
			dbg("SelectItem","AUTO",chosen,trychoose_mdl)
			
			self.mdllist:SelectItem(chosen)

		else
			dbg("Choose missing",trychoose_mdl)
		end
		
	end
	
	self.btn_bg:Refresh()
	
end

local factory = vgui.RegisterTable(PANEL,'EditablePanel')









-- main panel

local PANEL={}
function PANEL:Init()

	local pnl = vgui.CreateFromTable(factory,self)
	self.content = pnl
	pnl:Dock(FILL)
	
	local t=os.date"*t"
	self.m_bPaintHat = t.month==12 and t.day<=25
	
	self:SetCookieName"ofp"
	self:SetTitle"Outfitter"
	self:SetMinHeight(290)
	self:SetMinWidth(312)
	self:SetPos(32,32)
	self:SetDeleteOnClose(false)
	self.btnMinim:SetEnabled(true)
	self.btnMaxim:SetEnabled(true)
	local had_max = self:GetCookie( "pmax", "" ) == '1'
	
	if had_max then
		self:SetSize(640,400)
	else
		self:SetSize(313,293)
	end
	 
	self.btnMaxim.DoClick=function()
		self:SetSize(640,400)
		self:SetCookie( "pmax", '1' )
		had_max = true
		self:CenterVertical()
	end
	
	self:CenterVertical()
	
	if not had_max then
		self.btnMaxim.PaintOver = function(b,w,h)
			if had_max then return end
			b:NoClipping(false)
			surface.SetDrawColor(255,66,22,255*.5 + 255*.3 * math.sin(RealTime()*4))

			surface.DrawOutlinedRect(-1,-1,w+1,h+1)
			surface.DrawOutlinedRect(0,0,w,h)
			b:NoClipping(true)
		end
	end
	self.btnMinim.DoClick=function()
		self:SetSize(313,293)
		self:CenterVertical()
		
	end
	self:SetDraggable( true )
    self:SetSizable( true )
	
	local title = self.lblTitle
	if title then
		self:SetIcon'icon16/user.png'
		--local img = vgui.Create('DImage',title)
		--img:SetImage("icon16/user.png")
		--img:Dock(LEFT)
		--img.PerformLayout = function()
		--	img:SetWide(img:GetTall())
		--	title:SetTextInset(img:GetTall() + 5,0)
		--end
	
		local check = self:Add( "DCheckBoxLabel" )
	 	check:SetConVar(Tag.."_enabled")
		check:SetText( "#gameui_enabled")
		check:SizeToContents()
		check:SetTooltip[[Toggle this if someone's outfit got blocked or should be showing]]
		self.btnCheck = check
	end
	local OnMouseReleased = self.OnMouseReleased
	self.OnMouseReleased = function(...)
		self.OnMouseReleasedHook(...)
		return OnMouseReleased(...)
	end
	local Think = self.Think
	self.Think = function(...)
				
		Think(...)

		local hovered = self:IsHovered() or self:IsChildHovered()
		
		if hovered and not self.hadhover then
			self.hadhover = true
		end 
		
		local hasf = not outfitter_gui_focusdim:GetBool() or (hovered or not self.hadhover) or self.Dragging or self.Sizing
		if hasf~=self.hierfocused then
			self.hierfocused = hasf
			if hasf then
				self.fadeouttime=nil
				self:SetAlpha(255)
			else
				self.fadeouttime = RealTime()
			end
		end
		if self.fadeouttime then
			local f = (RealTime()-self.fadeouttime)/0.15
			f=1-f
			f=f>1 and 1 or f<0 and 0 or f
			self:SetAlpha(f*200+55)
		end
		
		local x,y=self:CursorPos()
		if x>0 and x<20 and y>0 and y<20 then
			self:SetCursor( "hand" )
		end
	end
end

function PANEL:OnMouseReleasedHook(mc)

	local x,y = self:CursorPos()
	if x<0 or x>20 then return end
	if y<0 or y>20 then return end
	
	
	if mc==MOUSE_LEFT then
		GUIAbout()
		return
	end
	
	local menu = DermaMenu()
	
	if UIGetChosenMDL() and UIGetMDLList() and LocalPlayer().latest_want~=UIGetMDLList()[UIGetChosenMDL()] then
		menu:AddOption( "#gameui_submit", function() GUIBroadcastMyOutfit() end ):SetImage'icon16/transmit.png'
	end
	
	--menu:AddLine()
	
	menu:AddOption( "About", function() GUIAbout() end ):SetImage'icon16/information.png'
	menu:AddOption( "Close", function() self:Hide() end ):SetImage'icon16/door_out.png'
	menu:Open()
end

function PANEL:PerformLayout(w,h)
	DFrame.PerformLayout(self,w,h)
	self.btnMinim:SetEnabled(w>(self:GetMinWidth() + 5) or h>(5 + self:GetMinHeight()))
	
	local check = self.btnCheck
	local cw,ch = 0,0
	if check then
		cw,ch = check:GetSize()
	end
	
	local b = self.btnMinim or self.btnMaxim
	if b and b:IsValid() then
		local bw,bh = b:GetWide(),b:GetTall()
		local bx,by = b:GetPos()
		if check then
			check:SetPos(bx-cw-4,by+bh*.5-ch*.5+1)
			check:SetVisible(w>256)
		end
	end
end
function PANEL:Hide()
	self:SetVisible(false)
	--hook.Run("OnContextMenuClose")
	self:OnClose()
end

function PANEL:OnClose()
	self.want_thirdperson = InThirdperson()
	ToggleThirdperson(false)
end

function PANEL:Show(_,trychoose_mdl)
	--if not self:IsVisible() then
		surface.PlaySound"garrysmod/ui_return.wav"
	--end
	self:SetVisible(true)
	self:MakePopup()
	self:DoRefresh(trychoose_mdl)
	if self.want_thirdperson then
		ToggleThirdperson(true)
	end
end
function PANEL:DoRefresh(trychoose_mdl)
	if not self:IsVisible() then return end
	
	self.content:DoRefresh(trychoose_mdl)
	
end

local factory = vgui.RegisterTable(PANEL,'DFrame')

if this.m_vGUIDlg and ValidPanel(this.m_vGUIDlg) then
	m_vGUIDlg:Remove()
end


function GUIPanel()
	return ValidPanel(m_vGUIDlg) and m_vGUIDlg
end

function GUIRefresh()
	local gui = GUIPanel()
	if gui then gui:DoRefresh() end
end

local prev = rawget(_M,'m_vGUIDlg')
if ValidPanel(prev) then prev:Remove() end
m_vGUIDlg = NULL
local alerted
function GUIOpen(_,trychoose_mdl)
	

	if not ValidPanel(m_vGUIDlg) then
		local d = vgui.CreateFromTable(factory,nil,Tag..'_GUI')
		m_vGUIDlg = d
	end
	
	
	m_vGUIDlg:Show(nil,trychoose_mdl)
	
	if Derma_Message and not alerted and game.SinglePlayer() then
		alerted = true
		Derma_Message("You are playing singleplayer. Outfitter may not work at all.",'WARNING')
	end
	
	return m_vGUIDlg
end

	

if NOUI then return end
concommand.Add(Tag..'_open',function()
	GUIOpen()
end)
--RunConsoleCommand(Tag..'_open')


  

-- button --



local icon = "icon64/outfitter.png"
icon = file.Exists("materials/"..icon,'GAME') and icon or "icon64/playermodel.png"

list.Set("DesktopWindows", Tag, {
	title		= "Outfitter",
	icon		= icon,
	width		= 1,
	height		= 1,
	onewindow	= false,
	init		= function( icon, window )
		window:GetParent():Close()
		window:Remove()
		GUIOpen()
	end
})

--PATH addons/_pcasino/lua/perfectcasino/derma/cl_config.lua:
-- This whole file is a little less than ideal. I find it hard to keep derma clean, especially when it can get so big so quickly.
-- I tried my best to keep consistent and to the point, but it gets a mind of its own in some places.
-- On the plus side, this menu will be used like twice, so its not the end of the world. Right?

-- Function cache
local color = Color
local draw_simpletext = draw.SimpleText
local draw_notexture = draw.NoTexture
local draw_roundedboxex = draw.RoundedBoxEx
local draw_roundedbox = draw.RoundedBox
local surface_setdrawcolor = surface.SetDrawColor
local surface_drawrect = surface.DrawRect
local surface_setdrawcolor = surface.SetDrawColor
local surface_setmaterial = surface.SetMaterial
local surface_drawtexturedrect = surface.DrawTexturedRect
-- Color cache
local mainBlack = color(38, 38, 38)
local bodyBlack = color(40, 40, 40)
local textWhite = color(220, 220, 220)
local mainRed = color(155, 50, 50)
local lineBreak = color(255, 255, 255, 10)
local scrollBackground = color(0, 0, 0, 100)

-- Material cache
local gradientDown = Material("gui/gradient_down")
local gradientMain = Material("gui/gradient")

-- Pre config stuff
local comboOptions = {}
comboOptions["pcasino_slot_machine"] = {
	"anything",
	"bell",
	"berry",
	"cherry",
	"clover",
	"diamond",
	"dollar",
	"melon",
	"seven"
}

PerfectCasino.UI.ConfigMenu = nil
PerfectCasino.UI.CurrentSettings = PerfectCasino.UI.CurrentSettings or {}
function PerfectCasino.UI.Config()
	if IsValid(PerfectCasino.UI.ConfigMenu) then PerfectCasino.UI.ConfigMenu:Show() return end

	local frame = vgui.Create("DFrame")
	PerfectCasino.UI.ConfigMenu = frame
	frame:SetSize(ScrW() * 0.6, ScrH() * 0.6)
	frame:SetTitle("")
	frame:Center()
	frame:MakePopup()
	frame:ShowCloseButton(false)
	frame:SetDraggable(false)
	frame:DockPadding(0, 0, 0, 0)
	frame.Paint = function(self, w, h)
		-- We drop the 40 to allow for rounded edges on the header
		surface_setdrawcolor(bodyBlack)
		surface_drawrect(0, 40, w, h-40)
	end
	frame.fullScreen = false
	frame.centerX, frame.centerY = frame:GetPos()

	local header = vgui.Create("DPanel", frame)
	header:Dock(TOP)
	header:SetTall(40)
	header:DockMargin(0, 0, 0, 0)
	header.Paint = function(self, w, h)
		draw_roundedboxex(frame.fullScreen and 0 or 5, 0, 0, w, 40, mainBlack, true, true)
		draw_simpletext(PerfectCasino.Translation.ConfigMenu.Title, "pCasino.Header.Static", 10, 20, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end

		-- Header buttons
		local close = vgui.Create("DButton", header)
		close:Dock(RIGHT)
		close:SetSize(header:GetTall(), header:GetTall())
		close:SetText("")
		close.animationLerp = 0
		close.Paint = function(self, w, h)
			if self:IsHovered() then
				self.animationLerp = math.Approach(self.animationLerp or 0, 1, 5*FrameTime())
			else
				self.animationLerp = math.Approach(self.animationLerp or 1, 0, 5*FrameTime())
			end

			draw_notexture()
			surface_setdrawcolor(200 - (self.animationLerp*55), 0, 0, 255)
			PerfectCasino.UI.DrawCircle(w*0.5, h*0.5, w*0.2, 1)
		end
		close.DoClick = function()
			frame:Hide()
		end

		local scale = vgui.Create("DButton", header)
		scale:Dock(RIGHT)
		scale:SetSize(header:GetTall(), header:GetTall())
		scale:SetText("")
		scale.animationLerp = 0
		scale.Paint = function(self, w, h)
			if self:IsHovered() then
				self.animationLerp = math.Approach(self.animationLerp or 0, 1, 5*FrameTime())
			else
				self.animationLerp = math.Approach(self.animationLerp or 1, 0, 5*FrameTime())
			end

			draw_notexture()
			surface_setdrawcolor(255, 165 - (self.animationLerp*25), 0, 255)
			PerfectCasino.UI.DrawCircle(w*0.5, h*0.5, w*0.2, 1)
		end
		scale.DoClick = function()
			if frame.fullScreen then
				frame:SizeTo(ScrW()*0.6, ScrH()*0.6, 0.5)
				frame:MoveTo(frame.centerX, frame.centerY, 0.5)
			else
				frame:SizeTo(ScrW(), ScrH(), 0.5)
				frame:MoveTo(0, 0, 0.5)
			end

			frame.fullScreen = not frame.fullScreen
		end

	-- Used to apply padding as DScrollPanel doesn't allow it
	local shellParent = vgui.Create("DPanel", frame)
	shellParent:Dock(FILL)
	shellParent:DockPadding(5, 5, 5, 5)
	shellParent.Paint = function(self, w, h)
		surface_setdrawcolor(0, 0, 0, 155)
		-- Header shadow
		surface_setmaterial(gradientDown)
		surface_drawtexturedrect(0, 0, w, 10)
		-- Navbar shadow
		surface_setmaterial(gradientMain)
		surface_drawtexturedrect(0, 0, 10, h)
	end
	local shell = vgui.Create("DScrollPanel", shellParent)
	shell:Dock(FILL)
	shell.Paint = function() end
	local sbar = shell:GetVBar()
	sbar:SetWide(sbar:GetWide()*0.5)
	sbar:SetHideButtons(true)
	function sbar:Paint(w, h)
		draw_roundedbox(10, 0, 0, w, h, scrollBackground)
	end
	function sbar.btnGrip:Paint(w, h)
		draw_roundedbox(10, 0, 0, w, h, mainRed)
	end



	local navBar = vgui.Create("DScrollPanel", frame)
	navBar:Dock(LEFT)

	local buttonX, buttonY = 0, 0
	local barPos = 0
	navBar.Paint = function(self, w, h)
		surface_setdrawcolor(mainBlack)
		surface_drawrect(0, 0, w, h)

		surface_setdrawcolor(lineBreak)
		surface_drawrect(0, 0, w, 2)

		if not self.currentFocus then return end

		buttonX, buttonY = self.currentFocus:GetPos()
		barPos = Lerp(0.1, barPos, buttonY)
		barPos = math.Approach(barPos, buttonY, 5*FrameTime())

		surface_setdrawcolor(mainRed)
		surface_drawrect(0, barPos, 4, 40)
	end
	navBar:SetSize(frame:GetWide()*0.2)
	navBar:GetVBar():SetWide(0)
	navBar.open = true

	function navBar:AddTab(name, callback)
		local button = vgui.Create("DButton", self)
		button:Dock(TOP)
		button:SetTall(40)
		button:SetText("")

		button.Paint = function(me, w, h)
			draw_simpletext(name, "pCasino.Nav.Static", 12, h*0.5, textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			surface_setdrawcolor(lineBreak)
			surface_drawrect(5, h-2, w-10, 2)
		end

		button.DoClick = function()
			shell:Clear()
			self.currentFocus = button
			callback(shell, button, self)
		end

		if not self.currentFocus then
			timer.Simple(0.1, function()
				if not IsValid(button) then return end
				button.DoClick()
			end)
			self.currentFocus = button
		end

		return button
	end

	local entityToConfig = vgui.Create("DPanel", shell)
	entityToConfig:SetTall(65)
	entityToConfig:Dock(TOP)
	entityToConfig.Paint = function(self, w, h)
		draw_simpletext(PerfectCasino.Translation.ConfigMenu.EntityToConfig, "pCasino.Title.Static", 10, 0, textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		surface_setdrawcolor(lineBreak)
		surface_drawrect(5, h-2, w-10, 2)
	end

	local entry = vgui.Create("DComboBox", entityToConfig)
	frame.entitySelectBox = entry
	entry:Dock(BOTTOM)
	entry:DockMargin(10, 0, 10, 5)
	entry:SetValue(PerfectCasino.Translation.ConfigMenu.EntityToConfigComboBox)
	for k, v in pairs(PerfectCasino.Core.Entites) do
		entry:AddChoice(PerfectCasino.Translation.Entities[k] or k, k)
	end
	entry.OnSelect = function(self, index, name, class)
		local configData = PerfectCasino.Core.GetEntityConfigOptions(class)
		local allSettings = (PerfectCasino.UI.CurrentSettings.Entity == class) and PerfectCasino.UI.CurrentSettings.Settings or {}
		for k, v in pairs(configData) do
			allSettings[k] = allSettings[k] or {}
			if k == "combo" then
				navBar:AddTab(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Title or k, function(shell)
					local title = vgui.Create("DPanel", shell)
					title:Dock(TOP)
					title:DockMargin(0, 0, 0, 5)
					title:SetTall(57.5)
					title.Paint = function(self, w, h)
						draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Title or k, "pCasino.Title.Static", 10, 0, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
						draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Desc or "", "pCasino.SubTitle.Static", 10, h, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
					end

					local function addComboCard(data, key)
						local base = vgui.Create("DPanel", shell)
						base:SetTall(135)
						base:Dock(TOP)
						base.Paint = function(self, w, h)
							surface_setdrawcolor(lineBreak)
							surface_drawrect(5, h-2, w-10, 2)
						end
						local entryBar = vgui.Create("DPanel", base)
						entryBar:Dock(BOTTOM)
						entryBar:SetTall(20)
						entryBar:DockMargin(5, 0, 5, 5)
						entryBar.Paint = function() end
							local multiplier = vgui.Create("DPanel", entryBar)
							multiplier:Dock(LEFT)
							multiplier:SetWide(275)
							multiplier:DockMargin(0, 0, 0, 0)
							multiplier:SetTall(20)
							multiplier.Paint = function(self, w, h)
								draw_simpletext(PerfectCasino.Translation.ConfigMenu.TakeoutBonusMultiplier, "pCasino.Textbox.Static", 10, h*0.5, textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
							end
								local entry = vgui.Create("pCasinoEntry", multiplier)
								entry:Dock(RIGHT)
								entry:DockMargin(5, 0, 5, 0)
								entry.OnChange = function()
									allSettings[k][base.key].p = entry:GetValue()
								end
								entry:SetDisplayText("0.5")
								entry:SetNumeric(true)
								entry:SetValue(data and data.p or 0.5)

							local jackpot = vgui.Create("DPanel", entryBar)
							jackpot:Dock(LEFT)
							jackpot:SetWide(140)
							jackpot:DockMargin(0, 0, 0, 0)
							jackpot:SetTall(20)
							jackpot.Paint = function(self, w, h)
								draw_simpletext(PerfectCasino.Translation.ConfigMenu.IsJackpot, "pCasino.Textbox.Static", 10, h*0.5, textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
							end
								local toggle = vgui.Create("pCasinoSwitch", jackpot)
								toggle:Dock(RIGHT)
								toggle:SetWide(40)
								toggle:SetToggle(data and data.j or false)
								toggle.DoClick = function()
									toggle:Toggle()
									allSettings[k][base.key].j = toggle:GetToggle()
								end

							local delete = vgui.Create("DButton", entryBar)
							delete:Dock(RIGHT)
							delete:SetWide(75)
							delete:SetText("")
							delete:DockMargin(5, 0, 0, 0)
							delete.animationLerp = 0
							delete.Paint = function(self, w, h)
								if self:IsHovered() then
									self.animationLerp = math.Approach(self.animationLerp or 0, 1, 5*FrameTime())
								else
									self.animationLerp = math.Approach(self.animationLerp or 1, 0, 5*FrameTime())
								end
								draw_roundedbox(0+(5*self.animationLerp), 0, 0, w, h, mainRed)
								draw_simpletext(PerfectCasino.Translation.ConfigMenu.Delete, "pCasino.Button.Micro", w*0.5, (h*0.5), textWhite, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
							end
							delete.DoClick = function()
								allSettings[k][base.key] = nil
								base:Remove()
							end

						local btnBar = vgui.Create("DPanel", base)
						btnBar:Dock(BOTTOM)
						btnBar:SetTall(20)
						btnBar:DockMargin(5, 0, 5, 5)
						btnBar.Paint = function() end

						for i=1, 3 do
							local icon = vgui.Create("DImage", base)	-- Add image to Frame
							icon:Dock(LEFT)
							icon:SetWide(75)
							icon:DockMargin(5, 5, 0, 5)
							icon:SetMaterial(PerfectCasino.Icons["anything"].mat)

							local nextIcon = vgui.Create("DButton", btnBar)
							nextIcon:Dock(LEFT)
							nextIcon:SetWide(75)
							nextIcon:SetText("")
							nextIcon:DockMargin(5, 0, 0, 0)
							nextIcon.CurState = 1
							if data then
								for k, v in pairs(comboOptions[class]) do
									if v == data.c[i] then
										nextIcon.CurState = k
										icon:SetMaterial(PerfectCasino.Icons[comboOptions[class][nextIcon.CurState]].mat)
										break
									end
								end
							end
							nextIcon.animationLerp = 0
							nextIcon.Paint = function(self, w, h)
								if self:IsHovered() then
									self.animationLerp = math.Approach(self.animationLerp or 0, 1, 5*FrameTime())
								else
									self.animationLerp = math.Approach(self.animationLerp or 1, 0, 5*FrameTime())
								end
								draw_roundedbox(0+(5*self.animationLerp), 0, 0, w, h, mainRed)
								draw_simpletext(PerfectCasino.Icons[comboOptions[class][self.CurState]].name, "pCasino.Button.Micro", w*0.5, (h*0.5), textWhite, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
							end
							nextIcon.DoClick = function()
								nextIcon.CurState = nextIcon.CurState + 1

								if not comboOptions[class][nextIcon.CurState] then
									nextIcon.CurState = 1
								end

								icon:SetMaterial(PerfectCasino.Icons[comboOptions[class][nextIcon.CurState]].mat)
								
								allSettings[k][base.key].c = allSettings[k][base.key].c or {}
								allSettings[k][base.key].c[i] = comboOptions[class][nextIcon.CurState]
							end
						end

						local icons = {}
						for k, v in pairs(btnBar:GetChildren()) do
							icons[k] = comboOptions[class][v.CurState]
						end
						if key then
							base.key = key
						else
							base.key = table.insert(allSettings[k], {c = {icons[1], icons[2], icons[3]}, p = entry:GetValue(), j = toggle:GetToggle()})
						end
					end

					local newCombo = vgui.Create("DButton", shell)
					newCombo:SetText("")
					newCombo:Dock(TOP)
					newCombo:SetTall(25)
					newCombo:DockMargin(10, 5, 10, 5)
					newCombo.animationLerp = 0
					newCombo.Paint = function(self, w, h)
						if self:IsHovered() then
							self.animationLerp = math.Approach(self.animationLerp or 0, 1, 5*FrameTime())
						else
							self.animationLerp = math.Approach(self.animationLerp or 1, 0, 5*FrameTime())
						end
						draw_roundedbox(0+(5*self.animationLerp), 0, 0, w, h, mainRed)
						draw_simpletext(PerfectCasino.Translation.ConfigMenu.AddComboButton, "pCasino.Main.Static", w*0.5, (h*0.5), textWhite, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
					end
					newCombo.DoClick = function()
						addComboCard(data)
						shell:GetVBar():AnimateTo(150*(#allSettings[k] + 1), 1)
					end

					-- PerfectCasino.Icons

					local tableHeaders = vgui.Create("DPanel", shell)
					tableHeaders:Dock(TOP)
					tableHeaders:SetTall(30)
					tableHeaders.Paint = function(self, w, h)
						draw_simpletext(PerfectCasino.Translation.ConfigMenu.TableHeaderChance, "pCasino.Main.Static", 10, h*0.5, textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
						surface_setdrawcolor(lineBreak)
						surface_drawrect(10, h-2, w-15, 2)
					end

						local useSettings = false
						if not table.IsEmpty(allSettings[k]) then
							useSettings = true
						end
						for n, m in pairs(useSettings and allSettings[k] or v) do
							addComboCard(m, useSettings and n or nil)
						end
				end)
			elseif k == "wheel" then
				navBar:AddTab(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Title or k, function(shell)
					local title = vgui.Create("DPanel", shell)
					title:Dock(TOP)
					title:DockMargin(0, 0, 0, 5)
					title:SetTall(57.5)
					title.Paint = function(self, w, h)
						draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Title or k, "pCasino.Title.Static", 10, 0, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
						draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Desc or "", "pCasino.SubTitle.Static", 10, h, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
					end

					for n, m in pairs(v) do
						allSettings[k][n] = allSettings[k][n] or m
						local setting = vgui.Create("DPanel", shell)
						setting:SetTall(80)
						setting:Dock(TOP)
						setting.Paint = function(self, w, h)
							--draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k][n] or string.upper(n), "pCasino.SubTitle.Static", 10, 0, k == "chance" and colorCache[n] or textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
							surface_setdrawcolor(lineBreak)
							surface_drawrect(5, h-2, w-10, 2)
						end
	
						local icon = vgui.Create("DImageButton", setting)	-- Add image to Frame
						icon:Dock(LEFT)
						icon:SetWide(80)
						icon:DockMargin(5, 5, 0, 5)
						icon.CurState = 1
						icon:SetMaterial(PerfectCasino.Icons[PerfectCasino.IconsList[icon.CurState]].mat)
						for z, x in pairs(PerfectCasino.IconsList) do
							if x == allSettings[k][n].p then
								icon.CurState = z
								icon:SetMaterial(PerfectCasino.Icons[PerfectCasino.IconsList[icon.CurState]].mat)
								break
							end
						end
						icon.DoClick = function()
							icon.CurState = icon.CurState + 1

							if not PerfectCasino.IconsList[icon.CurState] then
								icon.CurState = 1
							end

							icon:SetMaterial(PerfectCasino.Icons[PerfectCasino.IconsList[icon.CurState]].mat)
							
							allSettings[k][n].p = PerfectCasino.IconsList[icon.CurState]
						end

						local inputValue = vgui.Create("pCasinoEntry", setting)
						inputValue:Dock(BOTTOM)
						inputValue:DockMargin(5, 0, 10, 5)
						inputValue.OnChange = function()
							allSettings[k][n].i = inputValue:GetValue() == "" and m.i or inputValue:GetValue()
						end
						inputValue:SetDisplayText(m.i)
						inputValue:SetText((not (allSettings[k][n].i == m.i)) and allSettings[k][n].i or m.i)

						local rewardType = vgui.Create("DComboBox", setting)
						rewardType:Dock(BOTTOM)
						rewardType:DockMargin(5, 5, 10, 5)
						rewardType:SetValue(PerfectCasino.Translation.ConfigMenu.RewardComboBox)
						for o, p in pairs(PerfectCasino.Config.RewardsFunctions) do
							local key = rewardType:AddChoice(PerfectCasino.Translation.Rewards[o] or o, o)
							if allSettings[k][n].f == o then
								rewardType:ChooseOptionID(key)
							end
						end
						rewardType.OnSelect = function(self, index, name, class)
							allSettings[k][n].f = class
						end

						local name = vgui.Create("pCasinoEntry", setting)
						name:Dock(BOTTOM)
						name:DockMargin(5, 0, 10, 0)
						name.OnChange = function()
							allSettings[k][n].n = name:GetValue() == "" and m.n or name:GetValue()
						end
						name:SetDisplayText(m.n)
						name:SetText((not (allSettings[k][n].n == m.n)) and allSettings[k][n].n or m.n)

					end
				end)
			elseif k == "chance" then
				navBar:AddTab(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Title or k, function(shell)
					local title = vgui.Create("DPanel", shell)
					title:Dock(TOP)
					title:DockMargin(0, 0, 0, 5)
					title:SetTall(57.5)
					title.Paint = function(self, w, h)
						draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Title or k, "pCasino.Title.Static", 10, 0, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
						draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Desc or "", "pCasino.SubTitle.Static", 10, h, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
					end
	
					local colorCache = {}
					local chanceBar = vgui.Create("DPanel", shell)
					chanceBar:Dock(TOP)
					chanceBar:DockMargin(0, 0, 0, 5)
					chanceBar:SetTall(60)
					chanceBar.Paint = function(self, w, h)
						draw_simpletext(PerfectCasino.Translation.Config.chance.Bar, "pCasino.Title.Static", 10, 0, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
						surface_setdrawcolor(lineBreak)
						surface_drawrect(10, (h*0.5)+5, w-20, (h*0.5)-10)
	
						-- (hudW-10) * math_clamp(localPly:Health(), 0, 100)/100
						local total = 0
						for n, m in pairs(allSettings[k]) do
							total = total+m
						end
						-- I know, the same loop twice... Ugly :/
						local curPos = 10
						for n, m in pairs(allSettings[k]) do
							if m == 0 then continue end
							if not colorCache[n] then
								colorCache[n] = Color(math.random(100, 255), math.random(100, 255), math.random(100, 255))
							end
	
							local width = (w-20) * (m/total)
							surface_setdrawcolor(colorCache[n])
							surface_drawrect(curPos, (h*0.5)+5, width, (h*0.5)-10)
	
							curPos = curPos + width
						end
					end
	
					for n, m in pairs(v) do
						allSettings[k][n] = allSettings[k][n] or m.d
						local setting = vgui.Create("DPanel", shell)
						setting:SetTall(50)
						setting:Dock(TOP)
						setting.Paint = function(self, w, h)
							draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k][n] or string.upper(n), "pCasino.SubTitle.Static", 60, 0, k == "chance" and colorCache[n] or textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
							surface_setdrawcolor(lineBreak)
							surface_drawrect(5, h-2, w-10, 2)
						end

						local icon = vgui.Create("DImageButton", setting)	-- Add image to Frame
						icon:Dock(LEFT)
						icon:SetWide(45)
						icon:DockMargin(5, 5, 0, 5)
						icon.CurState = 1
						icon:SetMaterial(PerfectCasino.Icons[n].mat)

						local entry = vgui.Create("pCasinoEntry", setting)
						entry:Dock(BOTTOM)
						entry:DockMargin(10, 0, 10, 5)
						entry.OnChange = function()
							allSettings[k][n] = entry:GetValue() == "" and m.d or entry:GetValue()
						end
						entry:SetDisplayText(m.d)
						entry:SetText((not (allSettings[k][n] == m.d)) and allSettings[k][n] or "")
						entry:SetNumeric(true)
					end
				end)
			else
				navBar:AddTab(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Title or k, function(shell)
					local title = vgui.Create("DPanel", shell)
					title:Dock(TOP)
					title:DockMargin(0, 0, 0, 5)
					title:SetTall(57.5)
					title.Paint = function(self, w, h)
						draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Title or k, "pCasino.Title.Static", 10, 0, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
						draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k].Desc or "", "pCasino.SubTitle.Static", 10, h, mainRed, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)
					end
	
					for n, m in pairs(v) do
						-- allSettings[k][n] = allSettings[k][n] or m.d
						if allSettings[k][n] == nil then
							allSettings[k][n] = m.d
						end
						local setting = vgui.Create("DPanel", shell)
						setting:SetTall(50)
						setting:Dock(TOP)
						setting.Paint = function(self, w, h)
							draw_simpletext(PerfectCasino.Translation.Config[k] and PerfectCasino.Translation.Config[k][n] or string.upper(n), "pCasino.SubTitle.Static", 10, 0, k == "chance" and colorCache[n] or textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
							surface_setdrawcolor(lineBreak)
							surface_drawrect(5, h-2, w-10, 2)
						end
	
						if m.t == "bool" then
							local toggle = vgui.Create("pCasinoSwitch", setting)
							toggle:SetPos(10, setting:GetTall()-toggle:GetTall()-5)
							toggle:SetWide(40)
							toggle:SetToggle(allSettings[k][n])
							toggle.DoClick = function()
								toggle:Toggle()
								allSettings[k][n] = toggle:GetToggle()
							end
						else
							local entry = vgui.Create("pCasinoEntry", setting)
							entry:Dock(BOTTOM)
							entry:DockMargin(10, 0, 10, 5)
							entry.OnChange = function()
								allSettings[k][n] = entry:GetValue() == "" and m.d or entry:GetValue()
							end
							entry:SetDisplayText(m.d)
							entry:SetText((not (allSettings[k][n] == m.d)) and allSettings[k][n] or "")
							if m.t == "num" then
								entry:SetNumeric(true)
							end
						end
					end
				end)
			end
		end

		navBar:AddTab(PerfectCasino.Translation.ConfigMenu.SpawnEntity, function(shell)
			local defaults = PerfectCasino.Core.GetEntityConfigOptions(class)
			for k, v in pairs(allSettings) do
				if table.IsEmpty(v) then
					for n, m in pairs(defaults[k]) do
						v[n] = m.d or m
					end
				end
			end

			PerfectCasino.UI.CurrentSettings.Entity = class
			PerfectCasino.UI.CurrentSettings.Settings = allSettings

			PerfectCasino.UI.ConfigMenu:Hide()
		end)

		-- Allow them to reset the options. Essentially hard reloads the menu
		navBar:AddTab(PerfectCasino.Translation.ConfigMenu.ResetButton, function(shell)
			PerfectCasino.UI.ConfigMenu:Close()
			PerfectCasino.UI.ConfigMenu = nil
			PerfectCasino.UI.CurrentSettings = {}
			PerfectCasino.UI.Config()
		end)
	end
end
--PATH addons/_pcasino/lua/perfectcasino/core/sh_chip.lua:
-- All the types of chips
PerfectCasino.Chips.Types = {1, 5, 10, 25, 50, 100, 250, 500, 1000, 2000, 5000, 25000, 50000, 100000, 250000, 500000, 1000000}
-- Builds a stack of chips to equal the number given
function PerfectCasino.Chips:GetFromNumber(num)
	local total = num
	local chips = {}

	-- Loop the chip set and break it into chips
	for i = #PerfectCasino.Chips.Types, 1, -1 do
		local chip = PerfectCasino.Chips.Types[i]
		-- We offset by 1 to account for skins starting at 0
		chips[i-1] = math.floor(total/chip)
		total = total - (chips[i-1]*chip)

		-- Don't include it if it's empty
		if chips[i-1] == 0 then
			chips[i-1] = nil
		end
	end

	return chips
end

--PATH addons/____plogs/lua/plogs/lib/pdraw.lua:
--[[
addons/lgos/lua/plogs/lib/pdraw.lua
--]]
plogs.draw = {} -- Plop it in the plogs table otherwise this creates conflicts

local surface 	= surface
local render 	= render

local surface_SetDrawColor = surface.SetDrawColor
local surface_DrawRect = surface.DrawRect
local function surface_DrawRectBold(x, y, w, h, t)
	if not t then t = 1 end
	surface_DrawRect(x, y, w, t)
	surface_DrawRect(x, y + (h - t), w, t)
	surface_DrawRect(x, y, t, h)
	surface_DrawRect(x + (w - t), y, t, h)
end

function plogs.draw.Box(x, y, w, h, col)
	surface_SetDrawColor(col)
	surface_DrawRect(x, y, w, h)
end

function plogs.draw.Outline(x, y, w, h, col, thickness)
	surface_SetDrawColor(col)
	surface_DrawRectBold(x, y, w, h, thickness)
end

function plogs.draw.OutlinedBox(x, y, w, h, col, bordercol, thickness)
	surface_SetDrawColor(col)
	surface_DrawRect(x + 1, y + 1, w - 2, h - 2)

	surface_SetDrawColor(bordercol)
	surface_DrawRectBold(x, y, w, h, thickness)
end

local blur = Material('pp/blurscreen')
function plogs.draw.Blur(panel, amount) -- Thanks nutscript
	local x, y = panel:LocalToScreen(0, 0)
	local scrW, scrH = ScrW(), ScrH()
	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(blur)
	for i = 1, 3 do
		blur:SetFloat('$blur', (i / 3) * (amount or 6))
		blur:Recompute()
		render.UpdateScreenEffectTexture()
		surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
	end
end


--PATH addons/____plogs/lua/plogs_cfg.lua:
--[[
addons/lgos/lua/plogs_cfg.lua
--]]
--
-- General configs
--

-- The chat command to open the menu, (DO NOT ADD A ! or /, it does this for you)
plogs.cfg.Command = 'logs'

-- Window width percentage, I recomend no lower then 0.75
plogs.cfg.Width = 0.75

-- Window height percentage, I recomend no lower then 0.75
plogs.cfg.Height = 0.75

-- Some logs print to your client console. Enable this to print them to your server console too
plogs.cfg.EchoServer = true

-- Allow me to use logs on your server. (Disable if you're paranoid)
plogs.cfg.DevAccess = false

-- Do you want to store IP logs and playerevents? If enabled make sure to edit plogs_mysql_cfg.lua!
plogs.cfg.EnableMySQL = true

-- The log entry limit, the higher you make this the longer the menu will take to open.
plogs.cfg.LogLimit = 256

-- Format names with steamids? If true "aStoned(STEAMID)", if false just "aStoned"
plogs.cfg.ShowSteamID = true

-- Enable/Disable log types here. Set them to true to disable
plogs.cfg.LogTypes = {
	['chat'] 		= false,
	['commands']	= false,
    ['qf_hitman'] = true,
	['connections'] = false,
	['kills'] 		= false,
	['props'] 		= false,
	['tools'] 		= false,
	['darkrp'] 		= false,
	['ulx']			= false,
	['maestro']		= true,
	['pnlr']		= true, -- NLR Zones					|| 	https://scriptfodder.com/scripts/view/583
	['lac']			= true, -- Leys Serverside AntiCheat 	|| 	https://scriptfodder.com/scripts/view/1148
	['awarn2']		= true, -- AWarn2 						||	https://scriptfodder.com/scripts/view/629
	['hhh']			= true, -- HHH 							||	https://scriptfodder.com/scripts/view/3
	['hitmodule']	= true, -- Hitman Module				||	https://scriptfodder.com/scripts/view/1369
	['cuffs'] 		= false, -- Hand Cuffs 					||	https://scriptfodder.com/scripts/view/910
}


--
-- Specific configs, if you disabled the log type that uses one of these the config it doesn't matter
--

-- Command log blacklist, blacklist commands here that dont need to be logged
plogs.cfg.CommandBlacklist = {
	['_sendDarkRPvars']		= true,
	['_sendAllDoorData']	= true,
	['ulib_update_cvar']	= true,
	['ulib_cl_ready'] 		= true,
	['_xgui']				= true,
	['ulx']					= true,
}

-- Tool log blacklist, blacklist tools here that dont need to be logged
plogs.cfg.ToolBlacklist = {
	['myexampletool'] = true,
}


--PATH addons/ukrp_main_content/lua/autorun/raphtalia_default.lua:
player_manager.AddValidModel( "Raphtalia (Default)", "models/player/dewobedil/the_rising_of_the_shield_hero/raphtalia/default_p.mdl" );
player_manager.AddValidHands( "Raphtalia (Default)", "models/player/dewobedil/the_rising_of_the_shield_hero/raphtalia/c_arms/default_p.mdl", 0, "00000000" )

--View hands code credits: https://steamcommunity.com/id/libertyforce/
if CLIENT then
 
    local function Viewmodel( vm, ply, weapon )
        if CLIENT then
            if ply:GetModel() == "models/player/dewobedil/the_rising_of_the_shield_hero/raphtalia/default_p.mdl" then
                local skin = ply:GetSkin()
                local handring = ply:GetBodygroup( 4 ) -- Use the ID of the playermodel's bodygroup
                local hands = ply:GetHands()
                if ( weapon.UseHands or !weapon:IsScripted() ) then
                    if ( IsValid( hands ) ) then
                        hands:DrawModel()
                        hands:SetSkin( skin ) -- In case you want to change skin too
                        hands:SetBodygroup( 1 , handring ) -- Use the ID of the c_hands bodygroup
                    end
                end
            end
        end
    end
    hook.Add( "PostDrawViewModel", "raphtalia_default", Viewmodel )
 
end
--PATH addons/____sam/lua/sam/libs/sh_sfs.lua:
-- SFS (Srlion's Fast Serializer)
-- we try to avoid NYI operations in luajit as much as possible
-- unforunately, we can't avoid all of them in luajit 2.0.5 - pairs & table.concat
-- https://github.com/tarantool/tarantool/wiki/LuaJIT-Not-Yet-Implemented
-- we don't use string concating because it's also NYI in luajit 2.0.5
-- we never error so we don't get blacklisted by the jit compiler
-- errors return strings instead of throwing errors

-- this is intentionally made for net messages, so you don't have to use pcall to check if there are any errors
-- you should use this without using util.Compress, as this just adds one byte to each value, you will probably end up with a larger string if you compress it

-- this idea is from messagepack which is really smart
-- small numbers (0 ~ 127) and (-32 ~ -1) are encoded as a single byte
-- tables and arrays are encoded with a prefix byte, which is the number of elements in the table or array, but it can be one byte if it's less than 16
-- strings are encoded with a prefix byte, which is the length of the string, but it can be one byte if it's less than 32

local math = math
local HUGE = math.huge
local floor = math.floor
local internal_type = type
local IsColor = IsColor
local type = function(v)
    if IsColor(v) then
        return "Color"
    end
    return internal_type(v)
end

-- string.char is not jit compiled in luajit 2.0.5
local chars = {}; do
    for i = 0, 255 do
        chars[i] = string.char(i)
    end
end

local MAX_NUMBER = 1.7976931348623e+308
local MIN_NUMBER = -MAX_NUMBER

---
local POSITIVE_INT = 0x00
local POSITIVE_INT_END = 0x7f

local TABLE_FIXED = 0x80
local TABLE_FIXED_END = 0x8f

local ARRAY_FIXED = 0x90
local ARRAY_FIXED_END = 0x9f

local STR_FIXED = 0xa0
local STR_FIXED_END = 0xbf

local NIL = 0xc0
local FALSE = 0xc1
local TRUE = 0xc2

local UINT_8 = 0xc3
local UINT_16 = 0xc4
local UINT_32 = 0xc5
local UINT_52 = 0xc6

local NINT_8 = 0xc7
local NINT_16 = 0xc8
local NINT_32 = 0xc9
local NINT_52 = 0xca

local DOUBLE = 0xcb

local STR_8 = 0xcc
local STR_16 = 0xcd
local STR_32 = 0xce

local ARRAY_8 = 0xcf
local ARRAY_16 = 0xd0
local ARRAY_32 = 0xd1

local TABLE_8 = 0xd2
local TABLE_16 = 0xd3
local TABLE_32 = 0xd4

local VECTOR = 0xd5
local ANGLE = 0xd6

local ENTITY = 0xd7
local PLAYER = 0xd8

local COLOR = 0xd9

-- this was added in version 2.0.0
-- it's used for arrays that start at 0, I'm not sure if lua 5.1 has same behavior as luajit 2.0.5
-- but luajit 2.0.5 supports starting arrays at 0 index, so checking if table is an array or not gets messed up and output is wrong
-- so if you supply local t = {[0] = 0, 1, 2, 3} and do next(t, #t) it will return (nil, nil) instead of (0, 0)
local ARRAY_ZERO_BASED_INDEX = 0xda

local FREE_FOR_CUSTOM = 0xdb
local FREE_FOR_CUSTOM_END = 0xdf

local NEGATIVE_INT = 0xe0
local NEGATIVE_INT_END = 0xff
---

local encoders = {}
local Encoder = {
    encoders = encoders
}
do
    local pairs = pairs
    local next = next
    local ceil = math.ceil
    local log = math.log
    local concat = table.concat
    local write, write_unsigned, write_double

    -- garry's mod related
    local Vector_Unpack, Angle_Unpack
    local Entity_EntIndex, Player_UserID
    if FindMetaTable then
        Vector_Unpack = FindMetaTable("Vector").Unpack
        Angle_Unpack = FindMetaTable("Angle").Unpack

        Entity_EntIndex = FindMetaTable("Entity").EntIndex
        Player_UserID = FindMetaTable("Player").UserID
    end
    --

    local get_encoder = function(buf, t)
        local encoder = encoders[type(t)]
        if encoder == nil then
            write(buf, "Unsupported type: ")
            write(buf, type(t))
            return nil
        end
        return encoder
    end

    local buffer = {
        [0] = 0 -- buffer length
    }

    -- this function is obviously not jit compiled in luajit 2.0.5 but internal functions are
    function Encoder.encode(val, max_cache_size)
        max_cache_size = max_cache_size or 2000
        buffer[0] = 0

        local encoder = get_encoder(buffer, val)
        if encoder == nil then
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        if encoder(buffer, val, arg) == true then -- if it returns true, it means there was an error
            -- error is never compiled, so we never error to avoid that
            -- concating in luajit 2.0.5 is NYI, we make sure that all encoders' functions get jit compiled
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        local result = concat(buffer, nil, 1, buffer[0])

        if #buffer > max_cache_size then
            buffer = {
                [0] = 0 -- buffer length
            }
        end

        return result
    end

    function Encoder.encode_array(arr, len, max_cache_size)
        max_cache_size = max_cache_size or 2000
        buffer[0] = 0

        if encoders.array(buffer, arr, len) == true then -- if it returns true, it means there was an error
            -- error is never compiled, so we never error to avoid that
            -- concating in luajit 2.0.5 is NYI, we make sure that all encoders' functions get jit compiled
            return nil, concat(buffer, nil, buffer[0] - 1, buffer[0])
        end

        local result = concat(buffer, nil, 1, buffer[0])

        if #buffer > max_cache_size then
            buffer = {
                [0] = 0 -- buffer length
            }
        end

        return result
    end

    function write(buf, chr)
        local buf_len = buf[0] + 1
        buf[0] = buf_len
        buf[buf_len] = chr
    end
    Encoder.write = write

    encoders["nil"] = function(buf)
        write(buf, chars[NIL])
    end

    function encoders.boolean(buf, bool)
        if bool == true then
            write(buf, chars[TRUE])
        else
            write(buf, chars[FALSE])
        end
    end

    function encoders.array(buf, arr, len, start_index)
        start_index = (start_index == nil or start_index ~= 0 and start_index ~= 1) and 1 or start_index

        if len < 0 then
            write(buf, "Array size cannot be negative: ")
            write(buf, len)
            return true
        elseif len > 0xFFFFFFFF then
            write(buf, "Array size too large to encode: ")
            write(buf, len)
            return true
        end

        if len <= 0xF then
            write(buf, chars[ARRAY_FIXED + len])
        else
            write_unsigned(buf, ARRAY_8, len)
        end

        if start_index == 0 then
            write(buf, chars[ARRAY_ZERO_BASED_INDEX])
        end

        for idx = start_index, len do
            local val = arr[idx]
            local encoder = get_encoder(buf, val)
            if encoder == nil then return true end
            encoder(buf, val)
        end
    end

    -- we can't check if a table is an array or not because lua tables are not arrays, they are tables
    -- use Encoder.encode_array if you want to encode an array
    function encoders.table(buf, tbl)
        -- check if it's an array, it's not accurate for arrays with holes but better than nothing
        do
            -- this is the fastest possible way, a lot better than cbor's/messagepack's/pon's way of checking if it's an array
            local tbl_len = #tbl
            if tbl_len > 0 and next(tbl, tbl_len) == nil and ((tbl_len == 1 and next(tbl) == 1) or (tbl_len > 1 and next(tbl, tbl_len - 1) == tbl_len)) then
                if tbl[0] ~= nil then
                    return encoders.array(buf, tbl, tbl_len, 0)
                else
                    return encoders.array(buf, tbl, tbl_len)
                end
            end
        end

        local buf_len = buf[0]
        local table_start = buf_len -- we store the start of the table so when we write the table size, we can change the current buffer index to the start of the table
        -- we have no way to get the table size without iterating through it, so we just add 5 empty strings to the buffer as a placeholder
        -- we add 5 empty strings because we don't know if table size is going to be a fixed number, uint8, uint16 or uint32
        -- uint32 takes 5 bytes, so we add 5 empty strings
        do
            for idx = 1, 5 do
                buf[buf_len + idx] = ""
            end
            buf_len = buf_len + 5
            buf[0] = buf_len
        end

        local table_count = 0
        for key, val in pairs(tbl) do
            table_count = table_count + 1

            local encoder_key = get_encoder(buf, key)
            if encoder_key == nil then return true end
            encoder_key(buf, key)

            local encoder_val = get_encoder(buf, val)
            if encoder_val == nil then return true end
            encoder_val(buf, val)
        end

        local table_end = buf[0] -- we store the end of the table because we need to change current buffer index to the start of the table to write the table size
        buf[0] = table_start -- change current buffer index to the start of the table

        -- write the table size
        if table_count <= 0xF then
            write(buf, chars[TABLE_FIXED + table_count])
        else
            if table_count > 0xFFFFFFFF then
                write(buf, "Table size too large to encode: ")
                write(buf, table_count)
                return true
            end
            write_unsigned(buf, TABLE_8, table_count)
        end

        buf[0] = table_end -- change current buffer index back to the end of the table
    end

    function encoders.string(buf, str)
        local str_len = #str
        if str_len > 0xFFFFFFFF then
            write(buf, "String too large to encode: ")
            write(buf, str_len)
            return true
        end

        if str_len <= 0x1F then
            write(buf, chars[STR_FIXED + str_len])
        else
            write_unsigned(buf, STR_8, str_len)
        end
        write(buf, str)
    end

    function encoders.number(buf, num)
        if (num > MAX_NUMBER and num ~= HUGE) or (num < MIN_NUMBER and num ~= -HUGE) then
            write(buf, "Number too large to encode: ")
            write(buf, num)
            return true
        end

        if num % 1 ~= 0 or num > 0xFFFFFFFFFFFFF or num < -0xFFFFFFFFFFFFF then -- DOUBLE
            write_double(buf, DOUBLE, num)
            return
        end

        if num < 0 then
            num = -num
            if num <= 0x1F then
                write(buf, chars[NEGATIVE_INT + num])
            else
                write_unsigned(buf, NINT_8, num)
            end
        else
            if num <= 0x7F then
                write(buf, chars[POSITIVE_INT + num])
            else
                write_unsigned(buf, UINT_8, num)
            end
        end
    end

    function encoders.Vector(buf, vec)
        write(buf, chars[VECTOR])
        local x, y, z = Vector_Unpack(vec)
        encoders.number(buf, x)
        encoders.number(buf, y)
        encoders.number(buf, z)
    end

    function encoders.Angle(buf, ang)
        write(buf, chars[ANGLE])
        local p, y, r = Angle_Unpack(ang)
        encoders.number(buf, p)
        encoders.number(buf, y)
        encoders.number(buf, r)
    end

    function encoders.Entity(buf, ent)
        write(buf, chars[ENTITY])
        encoders.number(buf, Entity_EntIndex(ent))
    end

    function encoders.Player(buf, ply)
        write(buf, chars[PLAYER])
        encoders.number(buf, Player_UserID(ply))
    end

    function encoders.Color(buf, col)
        write(buf, chars[COLOR])
        encoders.number(buf, col.r)
        encoders.number(buf, col.g)
        encoders.number(buf, col.b)
        encoders.number(buf, col.a)
    end

    function write_unsigned(buf, tag, num)
        if num <= 0xFF then -- uint8
            write(buf, chars[tag + 0x00])
            write(buf, chars[num])
        elseif num <= 0xFFFF then -- uint16
            write(buf, chars[tag + 0x01])
            write(buf, chars[floor(num / 256)])
            write(buf, chars[num % 256])
        elseif num <= 0xFFFFFFFF then -- uint32
            write(buf, chars[tag + 0x02])
            write(buf, chars[floor(num / 0x1000000) % 256])
            write(buf, chars[floor(num / 0x10000) % 256])
            write(buf, chars[floor(num / 256) % 256])
            write(buf, chars[num % 256])
        elseif num <= 0xFFFFFFFFFFFFF then -- uint52
            write(buf, chars[tag + 0x3])
            write(buf, chars[num % 256])
            write(buf, chars[floor(num / 256) % 256])
            write(buf, chars[floor(num / 0x10000) % 256])
            write(buf, chars[floor(num / 0x1000000) % 256])
            write(buf, chars[floor(num / 0x100000000) % 256])
            write(buf, chars[floor(num / 0x10000000000) % 256])
            write(buf, chars[floor(num / 0x1000000000000) % 256])
        end
    end
    Encoder.write_unsigned = write_unsigned

    -- i can't remember where i got this from, but it's not mine (i swear i always credit people)
    local log2 = log(2)
    function write_double(buf, tag, value)
        local abs_value = value < 0 and -value or value
        --IEEE double-precision floating point number
        --Specification: https://en.wikipedia.org/wiki/Double-precision_floating-point_format
        --Separate out the sign, exponent and fraction
        local sign = value < 0 and 1 or 0
        local exponent = ceil(log(abs_value) / log2) - 1
        local fraction = abs_value / (2 ^ exponent) - 1
        --Make sure the exponent stays in range - allowed values are -1023 through 1024
        if exponent < -1023 then
            --We allow this case for subnormal numbers and just clamp the exponent and re-calculate the fraction
            --without the offset of 1
            exponent = -1023
            fraction = abs_value / (2 ^ exponent)
        elseif abs_value ~= HUGE and exponent > 1024 then
            write(buf, "Exponent out of range: ")
            write(buf, value)
            return true
        end

        --Handle special cases
        if value == 0 then
            --Zero
            exponent = -1023
            fraction = 0
        elseif abs_value == HUGE then
            --Infinity
            exponent = 1024
            fraction = 0
        elseif value ~= value then
            --NaN
            exponent = 1024
            fraction = 1
        end

        local exp_out = exponent + 1023
        local fraction_out = fraction * 0x10000000000000

        write(buf, chars[tag])
        write(buf, chars[128 * sign + floor(exp_out / 16)])
        write(buf, chars[(exp_out % 16) * 16 + floor(fraction_out / 0x1000000000000)])
        write(buf, chars[floor(fraction_out / 0x10000000000) % 256])
        write(buf, chars[floor(fraction_out / 0x100000000) % 256])
        write(buf, chars[floor(fraction_out / 0x1000000) % 256])
        write(buf, chars[floor(fraction_out / 0x10000) % 256])
        write(buf, chars[floor(fraction_out / 0x100) % 256])
        write(buf, chars[floor(fraction_out % 256)])
    end
    Encoder.write_double = write_double
end

local decoders = {}
local Decoder = {
    decoders = decoders
}
do
    local sub = string.sub

    local read_type, read_byte, read_word, read_dword
    local decode_array, decode_table, decode_string, decode_double

    -- garry's mod related
    local Vector, Angle, Entity, Player, Color = Vector, Angle, Entity, Player, Color
    --

    local str_byte = string.byte
    local byte = function(ctx, size)
        local index = ctx[1]
        if index + size - 1 > ctx[3] then -- buffer length
            return nil, "Attemped to read beyond buffer size"
        elseif index + size - 1 > ctx[4] then -- max size
            return nil, "Max decode size exceeded"
        end
        ctx[1] = index + size
        return str_byte(ctx[2], index, index + size - 1)
    end
    Decoder.byte = byte

    local get_decoder = function(ctx)
        local t = read_type(ctx)
        local decoder = decoders[t]
        if decoder == nil then
            return nil, "Unsupported type: ", t
        end
        return decoder
    end
    Decoder.get_decoder = get_decoder

    local context = {
        1,  -- index
        "", -- buffer
        0,  -- buffer length
        HUGE, -- max size for decode, useful when decoding from user input that was sent over netmessages
    }

    local decode = function()
        if context[3] < 1 then -- this will make string.byte fail
            return nil, "Buffer is empty"
        end

        local err, err_2
        local decoder
        local val

        decoder, err, err_2 = get_decoder(context)
        if err ~= nil then
            return nil, err, err_2
        end

        val, err, err_2 = decoder(context)
        if err ~= nil then
            return nil, err, err_2
        end

        return val
    end

    function Decoder.decode(str)
        if type(str) ~= "string" then
            return nil, "str is not a string", str
        end

        context[1] = 1
        context[2] = str
        context[3] = #str
        context[4] = HUGE

        return decode()
    end

    function Decoder.decode_with_max_size(str, max_size)
        if type(str) ~= "string" then
            return nil, "str is not a string", str
        end

        if type(max_size) ~= "number" then
            return nil, "max_size is not a number", max_size
        end

        if max_size < 0 then
            return nil, "max_size can either be a positive number or math.huge for unlimited", max_size
        end

        context[1] = 1
        context[2] = str
        context[3] = #str
        context[4] = max_size

        return decode()
    end

    decoders[NIL] = function(ctx)
        ctx[1] = ctx[1] + 1
        return nil
    end

    decoders[FALSE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return false
    end

    decoders[TRUE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return true
    end

    --
    decoders[ARRAY_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        local len = bty - ARRAY_FIXED
        return decode_array(ctx, len)
    end

    for i = ARRAY_FIXED + 1, ARRAY_FIXED_END do
        decoders[i] = decoders[ARRAY_FIXED]
    end
    --

    decoders[ARRAY_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if len == nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    decoders[ARRAY_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    decoders[ARRAY_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_array(ctx, len)
    end

    --
    decoders[TABLE_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        local len = bty - TABLE_FIXED
        return decode_table(ctx, len)
    end

    for i = TABLE_FIXED + 1, TABLE_FIXED_END do
        decoders[i] = decoders[TABLE_FIXED]
    end
    --

    decoders[TABLE_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    decoders[TABLE_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    decoders[TABLE_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_table(ctx, len)
    end

    --
    decoders[STR_FIXED] = function(ctx)
        local bty, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        local len = bty - STR_FIXED
        return decode_string(ctx, len)
    end

    for i = STR_FIXED + 1, STR_FIXED_END do
        decoders[i] = decoders[STR_FIXED]
    end
    --

    decoders[STR_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    decoders[STR_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    decoders[STR_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local len, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return decode_string(ctx, len)
    end

    --
    decoders[POSITIVE_INT] = function(ctx)
        local bty, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return bty - POSITIVE_INT
    end

    for i = POSITIVE_INT + 1, POSITIVE_INT_END do
        decoders[i] = decoders[POSITIVE_INT]
    end
    --

    decoders[UINT_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u8, err = read_byte(ctx)
        if err ~= nil then
            return nil, err
        end
        return u8
    end

    decoders[UINT_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u16, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return u16
    end

    decoders[UINT_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local u32, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return u32
    end

    decoders[UINT_52] = function(ctx)
        ctx[1] = ctx[1] + 1
        local b1, b2, b3, b4, b5, b6, b7 = byte(ctx, 7)
        if b1 == nil then
            return nil, b2
        end
        return b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000) + (b5 * 0x100000000) + (b6 * 0x10000000000) + (b7 * 0x1000000000000)
    end

    --
    decoders[NEGATIVE_INT] = function(ctx)
        local bty, err = read_byte(ctx)
        if bty == nil then
            return nil, err
        end
        return NEGATIVE_INT - bty
    end

    for i = NEGATIVE_INT + 1, NEGATIVE_INT_END do
        decoders[i] = decoders[NEGATIVE_INT]
    end
    --

    decoders[NINT_8] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n8, err = read_byte(ctx)
        if n8 == nil then
            return nil, err
        end
        return -n8
    end

    decoders[NINT_16] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n16, err = read_word(ctx)
        if err ~= nil then
            return nil, err
        end
        return -n16
    end

    decoders[NINT_32] = function(ctx)
        ctx[1] = ctx[1] + 1
        local n32, err = read_dword(ctx)
        if err ~= nil then
            return nil, err
        end
        return -n32
    end

    decoders[NINT_52] = function(ctx)
        ctx[1] = ctx[1] + 1
        local b1, b2, b3, b4, b5, b6, b7 = byte(ctx, 7)
        if b1 == nil then
            return nil, b2
        end
        return -(b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000) + (b5 * 0x100000000) + (b6 * 0x10000000000) + (b7 * 0x1000000000000))
    end

    decoders[DOUBLE] = function(ctx)
        ctx[1] = ctx[1] + 1
        return decode_double(ctx)
    end

    decoders[VECTOR] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local x, y, z

        -- x
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        x, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- y
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        y, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- z
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        z, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Vector(x, y, z)
    end

    decoders[ANGLE] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local p, y, r

        -- p
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        p, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- y
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        y, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- r
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        r, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Angle(p, y, r)
    end

    decoders[ENTITY] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local ent_index

        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        ent_index, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end

        return Entity(ent_index)
    end

    decoders[PLAYER] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local user_id

        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        user_id, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end

        return Player(user_id)
    end

    decoders[COLOR] = function(ctx)
        ctx[1] = ctx[1] + 1

        local err, err_2
        local decoder
        local r, g, b, a

        -- r
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        r, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- g
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        g, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- b
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        b, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        -- a
        decoder, err, err_2 = get_decoder(ctx)
        if err ~= nil then
            return nil, err, err_2
        end

        a, err = decoder(ctx)
        if err ~= nil then
            return nil, err
        end
        --

        return Color(r, g, b, a)
    end

    function decode_array(ctx, len)
        -- zzzzz no table.new or table.setn, we try to allocate small space to avoid table resizing for small tables
        local arr = {nil, nil, nil, nil, nil, nil, nil, nil}

        local start_index = 1
        if read_type(ctx) == ARRAY_ZERO_BASED_INDEX then
            ctx[1] = ctx[1] + 1
            start_index = 0
        end

        for idx = start_index, len do
            local err, err_2
            local decoder
            local val

            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            val, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end

            arr[idx] = val
        end

        return arr
    end
    Decoder.decode_array = decode_array

    function decode_table(ctx, len)
        local err, err_2
        local decoder
        local key, val

        -- zzzzz no table.new or table.setn, we try to allocate small space to avoid table resizing for small tables
        local tbl = {nil, nil, nil, nil, nil, nil, nil, nil}
        for _ = 1, len do
            -- key
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            key, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end
            --

            -- val
            decoder, err, err_2 = get_decoder(ctx)
            if err ~= nil then
                return nil, err, err_2
            end

            val, err = decoder(ctx)
            if err ~= nil then
                return nil, err
            end
            --

            tbl[key] = val
        end

        return tbl
    end
    Decoder.decode_table = decode_table

    function decode_string(ctx, len)
        local index = ctx[1]
        if index + len - 1 > ctx[3] then
            return nil, "Attemped to read beyond buffer size"
        elseif index + len - 1 > ctx[4] then
            return nil, "Max decode size exceeded"
        end

        ctx[1] = index + len

        return sub(ctx[2], index, index + len - 1)
    end
    Decoder.decode_string = decode_string

    function decode_double(ctx)
        local b1, b2, b3, b4, b5, b6, b7, b8 = byte(ctx, 8)
        if b1 == nil then
            return nil, b2
        end

        --Separate out the values
        local sign = b1 >= 128 and 1 or 0
        local exponent = (b1 % 128) * 16 + floor(b2 / 16)
        local fraction = (b2 % 16) * 0x1000000000000 + b3 * 0x10000000000 + b4 * 0x100000000 + b5 * 0x1000000 + b6 * 0x10000 + b7 * 0x100 + b8
        --Handle special cases
        if exponent == 2047 then
            --Infinities
            if fraction == 0 then return ((sign == 0 and 1) or -1) * HUGE end
            --NaN
            if fraction == 0xfffffffffffff then return 0 / 0 end
        end

        --Combine the values and return the result
        if exponent == 0 then
            --Handle subnormal numbers
            return ((sign == 0 and 1) or -1) * (2 ^ (exponent - 1023)) * (fraction / 0x10000000000000)
        else
            --Handle normal numbers
            return ((sign == 0 and 1) or -1) * (2 ^ (exponent - 1023)) * ((fraction / 0x10000000000000) + 1)
        end
    end
    Decoder.decode_double = decode_double

    function read_type(ctx)
        local typ = str_byte(ctx[2], ctx[1])
        return typ
    end
    Decoder.read_type = read_type

    function read_byte(ctx)
        local bty, err = byte(ctx, 1)
        if bty == nil then
            return nil, err
        end
        return bty
    end
    Decoder.read_byte = read_byte

    function read_word(ctx)
        local b1, b2 = byte(ctx, 2)
        if b1 == nil then
            return nil, b2
        end
        return b1 * 0x100 + b2
    end
    Decoder.read_word = read_word

    function read_dword(ctx)
        local b1, b2, b3, b4 = byte(ctx, 4)
        if b1 == nil then
            return nil, b2
        end
        return b1 * 0x1000000 + b2 * 0x10000 + b3 * 0x100 + b4
    end
    Decoder.read_dword = read_dword
end

return {
    Encoder = Encoder, -- to allow usage of internal functions
    Decoder = Decoder, -- to allow usage of internal functions

    encode = Encoder.encode,
    encode_with_buffer = Encoder.encode_with_buffer,
    encode_array = Encoder.encode_array,

    decode = Decoder.decode,
    decode_with_max_size = Decoder.decode_with_max_size,

    set_type_function = function(t_fn) -- this is for me as I have custom type function in sam/scb to allow type function to get jit compiled :c
        type = t_fn
    end,

    add_encoder = function(typ, encoder)
        encoders[typ] = encoder
        if FREE_FOR_CUSTOM == FREE_FOR_CUSTOM_END then
            return nil, "No more free slots for custom encoders"
        end
        FREE_FOR_CUSTOM = FREE_FOR_CUSTOM + 1
        return FREE_FOR_CUSTOM - 1
    end,

    add_decoder = function(typ, decoder)
        decoders[typ] = decoder
    end,

    chars = chars,
    VERSION = "2.0.8"
}

--PATH addons/____sam/lua/sam/sh_colors.lua:
if SAM_LOADED then return end

local colors = {
	Red   = Color(244, 67, 54),
	Blue  = Color(13, 130, 223),
	Green = Color(0, 230, 64),
	White = Color(236, 240, 241),
	Black = Color(10, 10, 10)
}

function sam.get_color(name)
	return colors[name]
end

function sam.add_color(name, color)
	if isstring(name) and IsColor(color) then
		colors[name] = color
	end
end
--PATH addons/____sam/lua/sam/config/cl_config.lua:
if SAM_LOADED then return end

local sam = sam
local sfs = sam.sfs
local config = sam.config
local type = sam.type

local encoders = sfs.Encoder.encoders

function config.set(key, value, force)
	if not sam.isstring(key) then
		error("invalid setting name")
	end

	if not encoders[type(value)] then
		error("not supported value type")
	end

	if not force and config.get(key) == value then return end
	sam.netstream.Start("Config.Set", key, value)
end

function config.get(key, default)
	local value = sam.get_global("Config", {})[key]
	if value ~= nil then
		return value
	end
	return default
end

local menu_settings = {}
function config.add_menu_setting(title, func)
	local i = #menu_settings + 1
	for k, v in ipairs(menu_settings) do
		if v.title == title then
			i = k
			break
		end
	end
	menu_settings[i] = {
		title = title,
		func = func,
	}
end

function config.get_menu_settings()
	return menu_settings
end

hook.Add("SAM.ChangedGlobalVar", "SAM.CheckLoadedConfig", function(key, value)
	if key == "Config" then
		config.loaded = true
		hook.Call("SAM.LoadedConfig", nil, value)
		hook.Remove("SAM.ChangedGlobalVar", "SAM.CheckLoadedConfig")
	end
end)

--PATH addons/____sui/lua/sui/vgui/sui_label.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local MOUSE_LEFT = MOUSE_LEFT

local SysTime = SysTime

local PANEL = {}

AccessorFunc(PANEL, "m_colText", "TextColor")
AccessorFunc(PANEL, "m_colTextStyle", "TextStyleColor")
AccessorFunc(PANEL, "m_FontName", "Font")

AccessorFunc(PANEL, "m_bDoubleClicking", "DoubleClickingEnabled", FORCE_BOOL)
AccessorFunc(PANEL, "m_bAutoStretchVertical", "AutoStretchVertical", FORCE_BOOL)
AccessorFunc(PANEL, "m_bIsMenuComponent", "IsMenu", FORCE_BOOL)

AccessorFunc(PANEL, "m_bBackground", "PaintBackground",	FORCE_BOOL)
AccessorFunc(PANEL, "m_bBackground", "DrawBackground",	FORCE_BOOL)
AccessorFunc(PANEL, "m_bDisabled", "Disabled", FORCE_BOOL)

AccessorFunc(PANEL, "m_bIsToggle", "IsToggle", FORCE_BOOL)
AccessorFunc(PANEL, "m_bToggle", "Toggle", FORCE_BOOL)

AccessorFunc(PANEL, "m_bBright", "Bright", FORCE_BOOL)
AccessorFunc(PANEL, "m_bDark", "Dark", FORCE_BOOL)
AccessorFunc(PANEL, "m_bHighlight",	"Highlight", FORCE_BOOL)

PANEL:SetIsToggle(false)
PANEL:SetToggle(false)
PANEL:SetDisabled(false)
PANEL:SetDoubleClickingEnabled(true)

local Panel = FindMetaTable("Panel")
local SetMouseInputEnabled = Panel.SetMouseInputEnabled
local SetPaintBackgroundEnabled = Panel.SetPaintBackgroundEnabled
local SetPaintBorderEnabled = Panel.SetPaintBorderEnabled
local InvalidateLayout = Panel.InvalidateLayout
local SetFGColor = Panel.SetFGColor
function PANEL:Init()
	SetMouseInputEnabled(self, false)
	SetPaintBackgroundEnabled(self, false)
	SetPaintBorderEnabled(self, false)
end

function PANEL:AllowScale()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function PANEL:ScaleChanged()
	self:SizeToContents()
end

function PANEL:SetFont(font)
	if self.m_FontName == font then return end

	self.m_FontName = font
	self:SetFontInternal(self.m_FontName)
end

function PANEL:SetTextColor(col)
	if self.m_colText == col then return end

	self.m_colText = col
	SetFGColor(self, col.r, col.g, col.b, col.a)
end
PANEL.SetColor = PANEL.SetTextColor

function PANEL:GetColor()
	return self.m_colText or self.m_colTextStyle
end

function PANEL:Toggle()
	if not self:GetIsToggle() then return end

	self:SetToggle(not self:GetToggle())
	self:OnToggled(self:GetToggle())
end

function PANEL:SetDisabled(bDisabled)
	self.m_bDisabled = bDisabled
	InvalidateLayout(self)
end

function PANEL:SetEnabled(bEnabled)
	self:SetDisabled(not bEnabled)
end

function PANEL:IsEnabled()
	return not self:GetDisabled()
end

function PANEL:ApplySchemeSettings()
	local col = self:GetColor()
	if not col then return end

	self:SetFGColor(col.r, col.g, col.b, col.a)
end

function PANEL:AutoStretchVerticalThink()
	self:SizeToContentsY()
end

function PANEL:SetAutoStretchVertical(enable)
	self.m_bAutoStretchVertical = enable
	self.Think = enable and self.AutoStretchVerticalThink or nil
end

function PANEL:OnCursorEntered()
	InvalidateLayout(self, true)
end

function PANEL:OnCursorExited()
	InvalidateLayout(self, true)
end

function PANEL:OnMousePressed(mousecode)
	if self:GetDisabled() then return end

	if mousecode == MOUSE_LEFT and not dragndrop.IsDragging() and self.m_bDoubleClicking then
		if self.LastClickTime and SysTime() - self.LastClickTime < 0.2 then

			self:DoDoubleClickInternal()
			self:DoDoubleClick()
			return
		end

		self.LastClickTime = SysTime()
	end

	if self:IsSelectable() and mousecode == MOUSE_LEFT and input.IsShiftDown() then
		return self:StartBoxSelection()
	end

	self:MouseCapture(true)
	self.Depressed = true
	self:OnDepressed()
	InvalidateLayout(self, true)

	self:DragMousePress(mousecode)
end

function PANEL:OnMouseReleased(mousecode)
	self:MouseCapture(false)

	if self:GetDisabled() then return end
	if not self.Depressed and dragndrop.m_DraggingMain ~= self then return end

	if self.Depressed then
		self.Depressed = nil
		self:OnReleased()
		InvalidateLayout(self, true)
	end

	if self:DragMouseRelease(mousecode) then return end

	if self:IsSelectable() and mousecode == MOUSE_LEFT then
		local canvas = self:GetSelectionCanvas()
		if canvas then
			canvas:UnselectAll()
		end
	end

	if not self.Hovered then return end

	self.Depressed = true

	if mousecode == MOUSE_RIGHT then
		self:DoRightClick()
	end

	if mousecode == MOUSE_LEFT then
		self:DoClickInternal()
		self:DoClick()
	end

	if mousecode == MOUSE_MIDDLE then
		self:DoMiddleClick()
	end

	self.Depressed = nil
end

function PANEL:OnReleased()
end

function PANEL:OnDepressed()
end

function PANEL:OnToggled(bool)
end

function PANEL:DoClick()
	self:Toggle()
end

function PANEL:DoRightClick()
end

function PANEL:DoMiddleClick()
end

function PANEL:DoClickInternal()
end

function PANEL:DoDoubleClick()
end

function PANEL:DoDoubleClickInternal()
end

sui.register("Label", PANEL, "Label")
--PATH addons/____sui/lua/sui/vgui/sui_number_slider.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local NUMBER_SLIDER_FONT = SUI.CreateFont("NumberSlider", "Roboto Regular", 14)

local PANEL = {}

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()

	local slider = vgui.Create(NAME .. ".Slider", self, "NumberSlider")
	slider:Dock(FILL)

	self.slider = slider

	local label = self:Add(NAME .. ".Label")
	label:Dock(RIGHT)
	label:DockMargin(3, 0, 0, 0)
	label:SetFont(NUMBER_SLIDER_FONT)
	self.label = label

	function label:Think()
		self:SetText(slider:GetValue())

		self:SizeToContents()
	end

	self:SetSize(100, 12)
	self:InvalidateLayout(true)
end

sui.register("NumberSlider", PANEL, "Panel")

--PATH addons/____sui/lua/sui/vgui/sui_zcolumn_sheet.lua:
local IsValid = IsValid

local TDLib_Classes = sui.TDLib.LibClasses
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local Panel = {}

function Panel:Init()
	self.tabs = {}

	local tab_scroller = self:Add(NAME .. ".ScrollPanel")
	tab_scroller:Dock(LEFT)

	function tab_scroller:Paint(w, h)
		self:RoundedBox("Background", 1, 0, 0, w, h, GetColor("column_sheet_bar"))
	end

	self.tabs_wide = 48
	self.tab_scroller = tab_scroller

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function Panel:ScaleChanged()
	local tabs_wide = SUI.Scale(self.tabs_wide)
	self.tab_scroller:SetWide(tabs_wide)

	self:InvalidateLayout(true)

	local tabs = self.tabs
	for i = 1, #self.tabs do
		tabs[i].img:SetMinus(SUI.Scale(20))
	end
end

function Panel:Paint(w, h)
	self:RoundedBox("Background", 1, 0, 0, w, h, GetColor("column_sheet"))
end

local tab_DoClick = function(s)
	s.parent:SetActiveTab(s)
end

local tab_Paint = function(s, w, h)
	local cur_col
	if s.active then
		cur_col = GetColor("column_sheet_tab_active")
	elseif s.Hovered then
		cur_col = GetColor("column_sheet_tab_hover")
	else
		cur_col = GetColor("column_sheet_tab")
	end

	s:RoundedBox("Backgrounds", 0, 0, 0, w, h, cur_col)
end

local tab_OnRemove = function(s)
	table.RemoveByValue(s.parent.tabs, s)
end

function Panel:AddSheet(mat, load_func)
	local tab = self.tab_scroller:Add(NAME .. ".Button")
	tab:Dock(TOP)
	tab:SetText("")
	tab:SetTall(self.tabs_wide)

	tab.On = TDLib_Classes.On

	tab.DoClick = tab_DoClick
	tab.Paint = tab_Paint
	tab:On("OnRemove", tab_OnRemove)

	tab.parent = self
	tab.load_func = load_func

	local img = tab:Add(NAME .. ".Image")
	img:Dock(FILL)
	img:SetImage(mat)
	img:SetMinus(SUI.Scale(20))

	tab.img = img

	self.tab_scroller:AddItem(tab)

	if not self:GetActiveTab() then
		self:SetActiveTab(tab)
	end

	table.insert(self.tabs, tab)

	return tab
end

function Panel:GetActiveTab()
	return self.active_tab
end

function Panel:SetActiveTab(new_tab)
	if new_tab == self.active_tab then return end

	if not IsValid(new_tab.panel) then
		local panel = new_tab.load_func(self)
		panel:SetParent(self)
		panel:SetVisible(false)
		panel:SetAlpha(0)

		panel.tab = new_tab
		new_tab.panel = panel
	end

	local old_active_tab = self.active_tab
	local delay = 0
	if old_active_tab and IsValid(old_active_tab.panel) then
		old_active_tab.active = false
		delay = 0.2
		old_active_tab.panel:AlphaTo(0, delay, 0, function(_, p)
			if p:IsValid() then
				p:SetVisible(false)
			end
		end)
	end

	new_tab.active = true
	new_tab.panel:SetVisible(true)
	new_tab.panel:AlphaTo(255, 0.2, delay)
	self.active_tab = new_tab
end

sui.register("ColumnSheet", Panel, "EditablePanel")
--PATH addons/__________911emergencyresponse/lua/emergencyresponse/client/cl_respond_interface.lua:
local popupCallouts = popupCallouts or {}
local popupPanicButtons = popupPanicButtons or {}
local popupBackupFrames = popupBackupFrames or {}
local tbl = { 'emergencyresponse/callouts/recept/notif_02.wav', 'emergencyresponse/callouts/recept/notif_06.wav', 'emergencyresponse/callouts/recept/notif_08.wav' }
local tbl2 = { 'emergencyresponse/callouts/recept/notif_01.wav', 'emergencyresponse/callouts/recept/notif_03.wav', 'emergencyresponse/callouts/recept/notif_07.wav', 'emergencyresponse/callouts/recept/notif_08.wav', 'emergencyresponse/callouts/recept/notif_09.wav', 'emergencyresponse/callouts/recept/notif_10.wav' }
local col2 = Color( 40, 36, 36, 230 )
local col3 = Color( 155, 26, 26 )
net.Receive( 'EmergencyDispatch:DispatchCallout:SendingCalloutToUnit', function()
	local callCaller = nil
	local callReason = ''
	local callEmergency = ''
	local callLocation = nil
	callCaller = net.ReadEntity()
	callReason = net.ReadString()
	callEmergency = net.ReadString()
	callLocation = net.ReadVector()
	local x, y = 350, 200
	local rX, rY = ScrW() - x - ScrW() * 0.01, ScrH() - y - ScrH() * 0.04
	local popupCall = vgui.Create( 'onyx.Panel' )
	popupCall:SetSize( x, y )
	popupCall:SetPos( ScrW() * 8, rY + -210 * #popupCallouts )
	if #popupCallouts > 0 then
		popupCall:MoveTo( rX, rY + -210 * #popupCallouts, 0.2, 0, 1, function() surface.PlaySound( table.Random( tbl2 ) ) end )
	else
		popupCall:MoveTo( rX, rY, 0.2, 0, 1, function() surface.PlaySound( table.Random( tbl2 ) ) end )
	end

	function popupCall.Paint( self, w, h )
		if not IsValid( callCaller ) then return end
		draw.RoundedBox( 3, 0, 0, w, h, col2 )
		draw.RoundedBox( 3, 0, 0, w, h * 0.28, col3 )
		draw.SimpleText( 'НАДЗВИЧАЙНА СИТУАЦІЯ', onyx.Font( 'Comfortaa@20' ), x * 0.02, y * 0.005, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
		draw.SimpleText( 'Від: ' .. callCaller:Nick(), onyx.Font( 'Comfortaa@12' ), x * 0.03, y * 0.33, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
		draw.SimpleText( 'Розташування: ' .. math.Round( LocalPlayer():GetPos():Distance( callLocation ) / 20 ) .. 'm', onyx.Font( 'Comfortaa@25' ), x * 0.02, y * 0.13, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
	end

	table.insert( popupCallouts, popupCall )
	local popupComment = vgui.Create( 'RichText', popupCall )
	popupComment:SetSize( x + 10, y * 0.5 )
	popupComment:SetPos( x * 0.02, y * 0.45 )
	popupComment:SetText( callReason )
	function popupComment:PerformLayout()
		self:SetFontInternal( onyx.Font( 'Comfortaa@12' ) )
		self:SetFGColor( color_white )
	end

	local popupTakeOut = vgui.Create( 'onyx.ImageButton', popupCall )
	popupTakeOut:SetSize( x * 0.1, y * 0.2 )
	popupTakeOut:SetPos( x * 0.9, y * 0.03 )
	popupTakeOut:SetText( '' )
	popupTakeOut:SetURL( 'https://i.imgur.com/RZuWmue.png', 'smooth' )
	function popupTakeOut.OnCursorEntered( self )
		self.hover = true
		surface.PlaySound( 'UI/buttonrollover.wav' )
	end

	function popupTakeOut.OnCursorExited( self )
		self.hover = false
	end

	function popupTakeOut.DoClick()
		popupCall:MoveTo( ScrW() * 8, rY, 0.2, 0, 1 )
		timer.Simple( 0.2, function() if IsValid( popupCall ) then popupCall:Remove() end end )
		table.remove( popupCallouts, #popupCallouts )
		hook.Remove( 'HUDPaint', 'EmergencyMod:GPSPoint:Callout' )
		surface.PlaySound( 'emergencyresponse/callouts/recept/notif_06.wav' )
	end

	local popupClaim = vgui.Create( 'onyx.ImageButton', popupCall )
	popupClaim:SetSize( x * 0.1, y * 0.2 )
	popupClaim:SetPos( x * 0.8, y * 0.03 )
	popupClaim:SetText( '' )
	popupClaim:SetURL( 'https://i.imgur.com/gRf0Hh9.png', 'smooth' )
	popupClaim.Status = false
	function popupClaim.OnCursorEntered( self )
		self.hover = true
		surface.PlaySound( 'UI/buttonrollover.wav' )
	end

	function popupClaim.OnCursorExited( self )
		self.hover = false
	end

	function popupClaim.DoClick( self )
		if popupClaim.Status == false then
			popupClaim.Status = true
			self:Remove()
			EmergencyResponse:CreateGPSHUDPaint( callLocation, callEmergency, callCaller )
			surface.PlaySound( table.Random( tbl ) )
		else
			popupClaim.Status = false
			popupCall:MoveTo( ScrW() * 3, rY, 0.2, 0, 1 )
			timer.Simple( 0.2, function() if IsValid( popupCall ) then popupCall:Remove() end end )
			table.remove( popupCallouts, #popupCallouts )
			hook.Remove( 'HUDPaint', 'EmergencyMod:GPSPoint:Callout' )
			surface.PlaySound( 'emergencyresponse/callouts/recept/notif_06.wav' )
		end
	end
end )
--PATH addons/_doctor/lua/autorun/sh_blues_pharmaceuticals.lua:
if SERVER then
    AddCSLuaFile("blues_pharm_translation.lua")
end

include("blues_pharm_translation.lua")
BLUES_PHARMA = BLUES_PHARMA or {}

--A list of all chemical types. An entity can set ChemicalID on it to be considered a chemical
BLUES_PHARMA.Chemicals = {
    [1] = {name = "Кето кислота", color = Color(220,20,60)},
    [2] = {name = "Саліцилова кислота", color = Color(95,158,160)},
    [3] = {name = "Пропіонова кислота", color = Color(154,205,50)},
    [4] = {name = "Оцтовий ангідрид", color = Color(46,139,87)},
    [5] = {name = "Діоксид селену", color = Color(218,165,32)},
    [6] = {name = "2-нафтол", color = Color(30,144,255)},
    [7] = {name = "Метилтестостерон", color = Color(173,255,47)},
    [8] = {name = "Aцетон", color = Color(210,105,30)},
    [9] = {name = "Прогестерон", color = Color(255,99,71)},
    [10] = {name = "Деіонізована вода", color = Color(135,206,235)},
    [11] = {name = BLUES_PHARMA.TRANS.BurnedChemicals, color = Color(20,20,20)},
    [12] = {name = "Juul" , abrv = "Верховний" , color = Color(238,232,170)}
} 

BLUES_PHARMA.Medicines = {
    [1] = {
        name = "Аспірин", 
        cookTime = 60, -- Number of seconds it takes to finish cooking
        freezeTime = 60 * 2, --Number of seconds it takes to freeze
        mixIncrement = 5, --The amount to add to the mix value (between 0-100) each mix tick
        overdoseRate = 10, --This is how much it adds to the "overdose" var which has a max of 1 and decreases over time
        pillCount = 5, --This is how many uses a single bottle has
        recipe = {
            [2] = 150, --150ML Salicylic acid
            [4] = 300, --300ml of Acetic anhydride
            [10] = 50 --Water
        },
        onConsumed = function(self, user) --Called when someone eats/takes this medicine. 
            user:BPAddDamageResistance(15, 60)
        end
    },
    [2] = {
        name = "Ібупрофен", 
        cookTime = 90, -- Number of seconds it takes to finish cooking
        freezeTime = 60 * 2.5, --Number of seconds it takes to freeze
        mixIncrement = 6, --The amount to add to the mix value (between 0-100) each mix tick
        overdoseRate = 20, --This is how much it adds to the "overdoes" var which has a max of 1 and decreases over time
        pillCount = 4, --This is how many uses a single bottle has
        recipe = {
            [3] = 150,
            [4] = 300, 
            [10] = 50
        },
        onConsumed = function(self, user) --Called when someone eats/takes this medicine. 
            user:BPAddDamageResistance(40, 40)
        end
    },
    [3] = {
        name = "Напроксен", 
        cookTime = 75, -- Number of seconds it takes to finish cooking
        freezeTime = 60 * 3, --Number of seconds it takes to freeze
        mixIncrement = 7, --The amount to add to the mix value (between 0-100) each mix tick
        overdoseRate = 35, --This is how much it adds to the "overdoes" var which has a max of 1 and decreases over time
        pillCount = 4, --This is how many uses a single bottle has
        recipe = {
            [6] = 250,
            [4] = 150, 
            [10] = 100
        },
        onConsumed = function(self, user) --Called when someone eats/takes this medicine. 
            user:BPAddPassiveHealth(10, 4, 40)
        end
    },
    [4] = {
        name = "Стероїди", 
        cookTime = 60 * 2, -- Number of seconds it takes to finish cooking
        freezeTime = 60 * 3, --Number of seconds it takes to freeze
        mixIncrement = 12, --The amount to add to the mix value (between 0-100) each mix tick
        overdoseRate = 35, --This is how much it adds to the "overdoes" var which has a max of 1 and decreases over time
        pillCount = 5, --This is how many uses a single bottle has
        recipe = {
            [7] = 100,
            [5] = 300, 
            [10] = 100
        },
        onConsumed = function(self, user) --Called when someone eats/takes this medicine. 
            user:BPAddDamageBuff(20, 20)
        end
    },
    [5] = {
        name = "Вітаміни", 
        cookTime = 120, -- Number of seconds it takes to finish cooking
        freezeTime = 60 * 4, --Number of seconds it takes to freeze
        mixIncrement = 3, --The amount to add to the mix value (between 0-100) each mix tick
        overdoseRate = 10, --This is how much it adds to the "overdoes" var which has a max of 1 and decreases over time
        pillCount = 10, --This is how many uses a single bottle has
        recipe = {
            [1] = 150,
            [8] = 200, 
            [10] = 150
        },
        onConsumed = function(self, user) --Called when someone eats/takes this medicine. 
            user:BPAddDamageBuff(10, 60)
            user:BPAddDamageResistance(10, 60)
            user:BPAddPassiveHealth(4, 4, 20)
            user:BPAddSpeedJumpBoost(10, 60)

        end
    },
    [6] = {
        name = "Кортикостероїд", 
        cookTime = 60 * 3, -- Number of seconds it takes to finish cooking
        freezeTime = 60 * 4, --Number of seconds it takes to freeze
        mixIncrement = 4, --The amount to add to the mix value (between 0-100) each mix tick
        overdoseRate = 44, --This is how much it adds to the "overdoes" var which has a max of 1 and decreases over time
        pillCount = 4, --This is how many uses a single bottle has
        recipe = {
            [4] = 200,
            [9] = 200, 
            [10] = 100
        },
        onConsumed = function(self, user) --Called when someone eats/takes this medicine. 
            user:BPDoubleRemainingTime()
        end
    },
    [7] = {
        name = "Діанабол", 
        cookTime = 60 * 2, -- Number of seconds it takes to finish cooking
        freezeTime = 60 * 3, --Number of seconds it takes to freeze
        mixIncrement = 6, --The amount to add to the mix value (between 0-100) each mix tick
        overdoseRate = 10, --This is how much it adds to the "overdoes" var which has a max of 1 and decreases over time
        pillCount = 10, --This is how many uses a single bottle has
        recipe = {
            [7] = 200,
            [1] = 150, 
            [10] = 150
        },
        onConsumed = function(self, user) --Called when someone eats/takes this medicine. 
            user:BPAddSpeedJumpBoost(30, 120)
        end
    },
    [8] = {
        name = "Анадрол", 
        cookTime = 60 * 2, -- Number of seconds it takes to finish cooking
        freezeTime = 60 * 4, --Number of seconds it takes to freeze
        mixIncrement = 6, --The amount to add to the mix value (between 0-100) each mix tick
        overdoseRate = 70, --This is how much it adds to the "overdoes" var which has a max of 1 and decreases over time
        pillCount = 2, --This is how many uses a single bottle has
        recipe = {
            [7] = 300,
            [9] = 100, 
            [10] = 100
        },
        onConsumed = function(self, user) --Called when someone eats/takes this medicine. 
            user:BPAddDamageBuff(50, 40)
        end
    }
}

BLUES_PHARMA.Pages = {
    [1] = {
        type = "header",
        title = [[
        Blue's 
Pharmaceuticals]],
        contents = BLUES_PHARMA.TRANS.BOOK.MiniTutorial1,
        contentsRight = BLUES_PHARMA.TRANS.BOOK.MiniTutorial2 .. [[


This book is dedicated to the following people.

        -Bear AKA bonehit
        -Golden 'The robot' Robo
        -J.P Studios
        -Opium Aryan
        -Trillex]]
    },
    --healers 
    [2] = {
        type = "recipe",
        recipeID = 1,
        desc = [[Аспірин, також відомий як ацетилсаліцилова кислота, - це лікарський засіб для лікування болю, лихоманки або запалення. Специфічні запальні стани, які лікуються аспірином, включають хворобу Кавасакі, перикардит і ревматичну лихоманку. Аспірин, прийнятий незабаром після серцевого нападу, знижує ризик смерті.]],
        effects = [[Надає користувачеві легке (15%) підвищення стійкості до пошкоджень приблизно на 1 хвилину. Ефекти цих ліків не сумуються, а спроби зробити це можуть призвести до передозування.]],
    },
    [3] = {
        type = "recipe",
        recipeID = 2,
        desc = [[Ібупрофен - це лікарський засіб з класу нестероїдних протизапальних препаратів, який використовується для лікування болю, лихоманки та запалення. Сюди входять болісні менструальні періоди, мігрень та ревматоїдний артрит. Він також може використовуватися для закриття відкритої артеріальної протоки у недоношених дітей.]],
        effects = [[Дає користувачеві помірне (40%) підвищення стійкості до пошкоджень приблизно на 40 секунд. Ефекти цих ліків не сумуються, і спроби зробити це можуть призвести до передозування.]],
    },
    [4] = {
        type = "recipe",
        recipeID = 3,
        desc = [[Напроксен, що продається під торговими марками Aleve та Naprosyn, є нестероїдним протизапальним препаратом, який використовується для лікування болю, менструальних болів, запальних захворювань, таких як ревматоїдний артрит, та лихоманки. Приймається перорально. Випускається у формах негайного та сповільненого вивільнення.]],
        effects = [[М'яко зцілює користувача (+10 хп кожні 4 секунди) протягом 80 секунд, в результаті чого користувач отримує 100 хп. Ефекти цих ліків не сумуються, і спроби зробити це можуть призвести до передозування.]],
    },
    --Buffs
    [5] = {
        type = "recipe",
        recipeID = 4,
        desc = [[Стероїд - це біологічно активна органічна сполука з чотирма кільцями, розташованими в певній молекулярній конфігурації. Стероїди виконують дві основні біологічні функції: як важливі компоненти клітинних мембран, що змінюють їхню плинність, і як сигнальні молекули.]],
        effects = [[Дає користувачеві легкий (20%) бафф до шкоди приблизно на хвилину. Ефекти цього засобу не сумуються, і спроби зробити це можуть призвести до передозування.]],
    },
    [6] = {
        type = "recipe",
        recipeID = 5,
        desc = [[Вітамін - це органічна молекула, яка є незамінним мікроелементом, необхідним організму в невеликих кількостях для правильного функціонування його метаболізму. Незамінні поживні речовини не можуть синтезуватися в організмі або взагалі, або в недостатній кількості, а тому повинні надходити з їжею.]],
        effects = [[Дає користувачеві легке зцілення (4 хп на 4 секунди) на 20 секунд, а також легке (10%) збільшення таких характеристик, як Швидкість пересування, висота стрибка, пошкодження та опір пошкодженням приблизно на хвилину. Ефекти цих ліків не сумуються, і спроби зробити це можуть призвести до передозування.]],
    },
    [7] = {
        type = "recipe",
        recipeID = 6,
        desc = [[Кортикостероїди - це штучні препарати, які дуже схожі на кортизол, гормон, що виробляється наднирковими залозами природним шляхом. Кортикостероїди часто називають скороченим терміном "стероїди". Кортикостероїди відрізняються від стероїдних сполук, пов'язаних з чоловічими гормонами, якими зловживають деякі спортсмени.]],
        effects = [[Посилює тривалість поточних активних ефектів загоєння та стійкості до пошкоджень, подвоюючи час, що залишився до їх завершення. Ефекти цих ліків не сумуються, а спроби зробити це можуть призвести до передозування.]],
    },
    [8] = {
        type = "recipe",
        recipeID = 7,
        desc = [[Метандієнон, також відомий як метандієнон або метандростенолон і продається, зокрема, під торговою маркою Dianabol, є андрогеном і анаболічним стероїдним препаратом, який здебільшого більше не використовується. Він також використовується в немедичних цілях для покращення фізичної форми та працездатності. Його приймають через рот.]],
        effects = [[Дає помірне (30%) збільшення швидкості пересування та висоти стрибка протягом приблизно 2 хвилин. Ефекти цього препарату не підсумовуються, і спроби зробити це можуть призвести до передозування.]],
    },
    [9] = {
        type = "recipe",
        recipeID = 8,
        desc = [[Оксиметолон, що продається під торговими марками Anadrol та Anapolon, є андрогеном та анаболічним стероїдним препаратом, який використовується в основному для лікування анемії. Він також використовується для лікування остеопорозу, синдрому виснаження при ВІЛ/СНІДі, а також для сприяння збільшенню маси тіла і росту м'язів у певних ситуаціях.]],
        effects = [[Надає великий (50%) бафф до урону приблизно на 40 секунд. Ефекти цих ліків не сумуються, а спроби зробити це можуть призвести до передозування.]],
    }
}
--PATH addons/__________skeypads/lua/skeypads/lib/cl_imgui.lua:
local imgui = {}
function imgui.Hook( name, id, callback )
	local hookUniqifier = debug.getinfo( 4 ).short_src
	hook.Add( name, 'IMGUI / ' .. id .. ' / ' .. hookUniqifier, callback )
end

local gState = {}
local function shouldAcceptInput()
	-- don't process input during non-main renderpass
	if render.GetRenderTarget() ~= nil then return false end
	-- don't process input if we're doing VGUI stuff (and not in context menu)
	if vgui.CursorVisible() and vgui.GetHoveredPanel() ~= g_ContextMenu then return false end
	return true
end

imgui.Hook( 'PreRender', 'Input', function()
	-- calculate mouse state
	if shouldAcceptInput() then
		local wasPressing = gState.pressing
		gState.pressing = input.IsKeyDown( KEY_E )
		gState.pressed = not wasPressing and gState.pressing
	end
end )

hook.Add( 'NotifyShouldTransmit', 'IMGUI / ClearRenderBounds', function( ent, shouldTransmit ) if shouldTransmit and ent._imguiRBExpansion then ent._imguiRBExpansion = nil end end )
local traceResultTable = {}
local traceQueryTable = {
	output = traceResultTable,
	filter = {}
}

local function isObstructed( eyePos, hitPos, ignoredEntity )
	local q = traceQueryTable
	q.start = eyePos
	q.endpos = hitPos
	q.filter[1] = LocalPlayer()
	q.filter[2] = ignoredEntity
	local tr = util.TraceLine( q )
	if tr.Hit then
		return true, tr.Entity
	else
		return false
	end
end

function imgui.Start3D2D( pos, angles, scale, distanceHide, distanceFadeStart )
	if gState.shutdown == true then return end
	if gState.rendering == true then
		print( '[IMGUI] Starting a new IMGUI context when previous one is still rendering' .. 'Shutting down rendering pipeline to prevent crashes..' )
		gState.shutdown = true
		return false
	end

	local eyePos = LocalPlayer():EyePos()
	local eyePosToPos = pos - eyePos
	-- OPTIMIZATION: Test that we are in front of the UI
	do
		local normal = angles:Up()
		local dot = eyePosToPos:Dot( normal )
		-- since normal is pointing away from surface towards viewer, dot<0 is visible
		if dot >= 0 then return false end
	end

	-- OPTIMIZATION: Distance based fade/hide
	if distanceHide then
		local distance = eyePosToPos:Length()
		if distance > distanceHide then return false end
		if distanceHide and distanceFadeStart and distance > distanceFadeStart then
			local blend = math.min( math.Remap( distance, distanceFadeStart, distanceHide, 1, 0 ), 1 )
			render.SetBlend( blend )
			surface.SetAlphaMultiplier( blend )
		end
	end

	gState.rendering = true
	gState.pos = pos
	gState.angles = angles
	gState.scale = scale
	cam.Start3D2D( pos, angles, scale )
	-- calculate mousepos
	if not vgui.CursorVisible() or vgui.IsHoveringWorld() then
		local tr = sKeypads.SuperSecure.GetRealEyeTrace()
		if not tr then
			gState.rendering = false
			cam.End3D2D()
			return
		end

		local eyepos = tr.StartPos
		local eyenormal
		if vgui.CursorVisible() and vgui.IsHoveringWorld() then
			eyenormal = gui.ScreenToVector( gui.MousePos() )
		else
			eyenormal = tr.Normal
		end

		local planeNormal = angles:Up()
		local hitPos = util.IntersectRayWithPlane( eyepos, eyenormal, pos, planeNormal )
		if hitPos then
			local obstructed, obstructer = isObstructed( eyepos, hitPos, gState.entity )
			if obstructed and obstructer ~= gState.entity then
				gState.mx = nil
				gState.my = nil
			else
				local diff = pos - hitPos
				-- This cool code is from Willox's keypad CalculateCursorPos
				local x = diff:Dot( -angles:Forward() ) / scale
				local y = diff:Dot( -angles:Right() ) / scale
				gState.mx = x
				gState.my = y
			end
		else
			gState.mx = nil
			gState.my = nil
		end
	else
		gState.mx = nil
		gState.my = nil
	end
	return true
end

function imgui.Entity3D2D( ent, lpos, lang, scale, ... )
	gState.entity = ent
	local ret = imgui.Start3D2D( ent:LocalToWorld( lpos ), ent:LocalToWorldAngles( lang ), scale, ... )
	gState.entity = nil
	return ret
end

local function calculateRenderBounds( x, y, w, h )
	local pos = gState.pos
	local fwd, right = gState.angles:Forward(), gState.angles:Right()
	local scale = gState.scale
	local firstCorner, secondCorner = pos + fwd * x * scale + right * y * scale, pos + fwd * ( x + w ) * scale + right * ( y + h ) * scale
	local minrb, maxrb = Vector( math.huge, math.huge, math.huge ), Vector( -math.huge, -math.huge, -math.huge )
	minrb.x = math.min( minrb.x, firstCorner.x, secondCorner.x )
	minrb.y = math.min( minrb.y, firstCorner.y, secondCorner.y )
	minrb.z = math.min( minrb.z, firstCorner.z, secondCorner.z )
	maxrb.x = math.max( maxrb.x, firstCorner.x, secondCorner.x )
	maxrb.y = math.max( maxrb.y, firstCorner.y, secondCorner.y )
	maxrb.z = math.max( maxrb.z, firstCorner.z, secondCorner.z )
	return minrb, maxrb
end

function imgui.ExpandRenderBoundsFromRect( x, y, w, h )
	local ent = gState.entity
	if IsValid( ent ) then
		-- make sure we're not applying same expansion twice
		local expansion = ent._imguiRBExpansion
		if expansion then
			local ex, ey, ew, eh = unpack( expansion )
			if ex == x and ey == y and ew == w and eh == h then return end
		end

		local minrb, maxrb = calculateRenderBounds( x, y, w, h )
		ent:SetRenderBoundsWS( minrb, maxrb )
		ent._imguiRBExpansion = { x, y, w, h }
	end
end

function imgui.End3D2D()
	if gState then
		gState.rendering = false
		cam.End3D2D()
		render.SetBlend( 1 )
		surface.SetAlphaMultiplier( 1 )
	end
end

function imgui.CursorPos()
	local mx, my = gState.mx, gState.my
	return mx, my
end

function imgui.IsHovering( x, y, w, h )
	local mx, my = gState.mx, gState.my
	return mx and my and mx >= x and mx <= x + w and my >= y and my <= y + h
end

function imgui.IsPressing()
	return shouldAcceptInput() and gState.pressing
end

function imgui.IsPressed()
	return shouldAcceptInput() and gState.pressed
end
return imgui
--PATH addons/__________skeypads/lua/skeypads/net/cl_net.lua:
net.Receive( "sKeypads::Notify", function()
    local msg = net.ReadString()
    local type = net.ReadUInt( 3 )
    notification.AddLegacy( msg, type, 3 )
    surface.PlaySound( "buttons/lightswitch2.wav" )
end )
--PATH addons/____slib/lua/slib/vgui/cl_splayerpanel.lua:
local PANEL = {}

local font = slib.createFont("Roboto", 15)
local textcolor, maincolor_7 = slib.getTheme("textcolor"), slib.getTheme("maincolor", 7)

function PANEL:Init()
    local tall = slib.getScaledSize(25, "y")
    self:SetTall(tall)
    self:Dock(TOP)

    self.playerImage = vgui.Create("AvatarImage", self)
    self.playerImage:SetSize(tall, tall)

    self:DockMargin(0, 0, 0, slib.getTheme("margin"))
    self:GetParent():DockPadding(slib.getTheme("margin"), slib.getTheme("margin"), slib.getTheme("margin"), slib.getTheme("margin"))
end

function PANEL:addButton(title, func)
    local bttn = vgui.Create("SButton", self)
    bttn:setTitle(title)
    :Dock(RIGHT)
    :DockMargin(0,slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"))

    bttn.DoClick = func

    return self
end

function PANEL:setPlayer(ply)
    self.ply = ply
    self.name = self.ply:Nick()
    self.playerImage:SetPlayer(ply, 64)

    return self
end

function PANEL:Paint(w,h)
    if !self.ply then self:Remove() end

    surface.SetDrawColor(maincolor_7)
    surface.DrawRect(0, 0, w, h)

    if self.ply then
        draw.SimpleText(self.name, font, slib.getScaledSize(25, "y") + slib.getTheme("margin"), h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end
end

vgui.Register("SPlayerPanel", PANEL, "EditablePanel")
--PATH addons/____slib/lua/slib/vgui/cl_sscrollpanel.lua:
local PANEL = {}

local elegantcol, maincol, maincol_5 = Color(255,255,255,3), slib.getTheme("maincolor"), slib.getTheme("maincolor", 5)

function PANEL:Init()
    local scr = self:GetVBar()
    scr:SetHideButtons(true)

    scr.Paint = function(_, w, h)
        surface.SetDrawColor(self.scrollbg or maincol)
        surface.DrawRect(0,0,w,h)
    end    
    scr.btnUp.Paint = function(_, w, h)end
    scr.btnDown.Paint = function(_, w, h)end
    scr.btnGrip.Paint = function(_, w, h)
        draw.RoundedBoxEx(h * .5, w * 0.5 - (w * 0.45 * 0.5), h * 0.03, w * 0.45, h - h * 0.06, elegantcol, true, true, true, true)
    end

    slib.wrapFunction(self, "SetSize", nil, function() return self end, true)
	slib.wrapFunction(self, "Center", nil, function() return self end, true)
	slib.wrapFunction(self, "SetPos", nil, function() return self end, true)
    slib.wrapFunction(self, "Dock", nil, function() return self end, true)
    slib.wrapFunction(self, "DockMargin", nil, function() return self end, true)
    slib.wrapFunction(self, "SetTall", nil, function() return self end, true)
end

function PANEL:Paint(w,h)
    if self.bg then
        surface.SetDrawColor(self.bg)
        surface.DrawRect(0,0,w,h)
    end
end

vgui.Register("SScrollPanel", PANEL, "DScrollPanel")
--PATH addons/____sprinter/lua/s_printer/languages/sh_english.lua:
if CLIENT then
    slib.setLang("sprinter", "en", "main", "Main")
    slib.setLang("sprinter", "en", "logs", "Logs")
    slib.setLang("sprinter", "en", "upgrades", "Upgrades")
    slib.setLang("sprinter", "en", "settings", "Settings")
    slib.setLang("sprinter", "en", "overclocking", "Overclocking")
    slib.setLang("sprinter", "en", "noisereduction", "Noise reduction")
    slib.setLang("sprinter", "en", "dmgresistance", "Damage resistance")
    slib.setLang("sprinter", "en", "notifications", "Notifications")

    slib.setLang("sprinter", "en", "notify-withdraw", "Notify on withdraw")
    slib.setLang("sprinter", "en", "notify-on-damage", "Notify on damage")
    slib.setLang("sprinter", "en", "notify-low-hp", "Notify on low HP")
    slib.setLang("sprinter", "en", "notify-low-battery", "Notify on low battery")

    slib.setLang("sprinter", "en", "withdrawn-money", "Withdrawn Money")
    slib.setLang("sprinter", "en", "received-damage", "Received Damage")
    slib.setLang("sprinter", "en", "upgraded-printer", "Upgraded Printer")
    slib.setLang("sprinter", "en", "turned-on", "Turned On")
    slib.setLang("sprinter", "en", "turned-off", "Turned Off")

    slib.setLang("sprinter", "en", "are-you-sure", "Are you sure?")
    slib.setLang("sprinter", "en", "this-will-cost", "This will cost %s")

    slib.setLang("sprinter", "en", "nothing-to-show", "Nothing to show here")

    slib.setLang("sprinter", "en", "condition", "Condition")
    slib.setLang("sprinter", "en", "temperature", "Temperature")
    slib.setLang("sprinter", "en", "clockspeed", "Clockspeed")
    slib.setLang("sprinter", "en", "storage", "Storage")
    slib.setLang("sprinter", "en", "income", "Income(min)")
    slib.setLang("sprinter", "en", "eject", "Eject")
    slib.setLang("sprinter", "en", "withdraw", "Withdraw")
    slib.setLang("sprinter", "en", "repair", "Repair")
    slib.setLang("sprinter", "en", "recharge", "Recharge")

    slib.setLang("sprinter", "en", "agree", "Agree")
    slib.setLang("sprinter", "en", "deny", "Deny")

    slib.setLang("sprinter", "en", "empty", "Empty")

    slib.setLang("sprinter", "en", "swep-name", "Printer Bag")
    slib.setLang("sprinter", "en", "swep-instructions", "Primary fire to holster a printer, secondary fire to drop a printer!")

    slib.setLang("sprinter", "en", "manage_rack", "Manage Rack")

    slib.setLang("sprinter", "en", "management", "Management")
    slib.setLang("sprinter", "en", "upgrade_all", "Upgrade All")
    slib.setLang("sprinter", "en", "already_upgraded", "Your printers are already fully upgraded!")
    slib.setLang("sprinter", "en", "authorize", "Authorize")
    slib.setLang("sprinter", "en", "authorization", "Authorization")
    slib.setLang("sprinter", "en", "lock", "Lock")
    slib.setLang("sprinter", "en", "full_hp", "Full HP")
    
    slib.setLang("sprinter", "en", "use_unlock", "Press USE to unlock")
    slib.setLang("sprinter", "en", "use_hack", "Press USE to hack")

    slib.setLang("sprinter", "en", "locked", "Locked")
else
    slib.setLang("sprinter", "en", "upgraded-rack", "You have upgraded all the printers in a rack for %s")
    slib.setLang("sprinter", "en", "upgraded", "You have upgraded a printer for %s")
    slib.setLang("sprinter", "en", "recharged", "You have recharged a printer for %s")
    slib.setLang("sprinter", "en", "repaired", "You have repaired a printer for %s")
    slib.setLang("sprinter", "en", "repaired-rack", "You have repaired a rack for %s")
    slib.setLang("sprinter", "en", "withdrawn", "You withdrew %s")
    slib.setLang("sprinter", "en", "recharged-all", "You have recharged every printer in the rack for %s")
    slib.setLang("sprinter", "en", "recharged-this-many", "You have recharged %s printer(s) in the rack for %s")
    slib.setLang("sprinter", "en", "repaired-all", "You have repaired every printer in the rack for %s")
    slib.setLang("sprinter", "en", "repaired-this-many", "You have repaired %s printer(s) in the rack for %s")
    slib.setLang("sprinter", "en", "no-eject-space", "There is no space to eject the printer")
    slib.setLang("sprinter", "en", "printer-was-damaged", "Your %s printer has received damage!")
    slib.setLang("sprinter", "en", "printer-low-hp", "Your %s printer has low hp!")
    slib.setLang("sprinter", "en", "someone-has-withdrawn", "Someone has withdrawn money from your %s printer!")
    slib.setLang("sprinter", "en", "someone-has-withdrawn-rack", "Someone has withdrawn money from your printer rack!")

    slib.setLang("sprinter", "en", "battery-low", "Your %s printer has low battery, you should recharge it!")
    slib.setLang("sprinter", "en", "rewarded-on-destroy", "You have received %s as a reward for destroying a printer!")

    slib.setLang("sprinter", "en", "cannot-withdraw", "You cannot withdraw money from this printer!")

    slib.setLang("sprinter", "en", "full-printer-bag", "The printer bag is full!")

    slib.setLang("sprinter", "en", "wthdrew", "Withdrew")
    slib.setLang("sprinter", "en", "upgrded", "Upgraded")

    slib.setLang("sprinter", "en", "log_withdrew", "{1} withdrew money from {2}.")
    slib.setLang("sprinter", "en", "log_upgraded", "{1} upgraded {2}.")

    slib.setLang("sprinter", "en", "exploit_attempted", "Attempted to exploit sPrinter.")
end

slib.setLang("sprinter", "en", "rack", "Printer Rack")
slib.setLang("sprinter", "en", "insufficient-permissions", "You have insufficient permissions to do this!")
--PATH addons/____sprinter/lua/s_printer/libraries/cl_3d2dvgui.lua:
--[[
	
3D2D VGUI Wrapper
Copyright (c) 2015-2017 Alexander Overvoorde, Matt Stevens

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

]]--

local origin = Vector(0, 0, 0)
local angle = Angle(0, 0, 0)
local normal = Vector(0, 0, 0)
local scale = 0
local maxrange = 0

-- Helper functions

local function getCursorPos()
	local p = util.IntersectRayWithPlane(LocalPlayer():EyePos(), LocalPlayer():GetAimVector(), origin, normal)

	-- if there wasn't an intersection, don't calculate anything.
	if not p then return end
	if WorldToLocal(LocalPlayer():GetShootPos(), Angle(0,0,0), origin, angle).z < 0 then return end

	local pos = WorldToLocal(p, Angle(0,0,0), origin, angle)

	return pos.x, -pos.y
end

local function getParents(pnl)
	local parents = {}
	local parent = pnl:GetParent()
	while parent do
		table.insert(parents, parent)
		parent = parent:GetParent()
	end
	return parents
end

local function absolutePanelPos(pnl)
	local x, y = pnl:GetPos()
	local parents = getParents(pnl)
	
	for _, parent in ipairs(parents) do
		local px, py = parent:GetPos()
		x = x + px
		y = y + py
	end
	
	return x, y
end

local function pointInsidePanel(pnl, x, y)
	local px, py = absolutePanelPos(pnl)
	local sx, sy = pnl:GetSize()

	if not x or not y then return end

	x = x / scale
	y = y / scale

	return pnl:IsVisible() and x >= px and y >= py and x <= px + sx and y <= py + sy
end

-- Input

local inputWindows = {}
local usedpanel = {}

local function isMouseOver(pnl)
	return pointInsidePanel(pnl, getCursorPos())
end

local function postPanelEvent(pnl, event, ...)
	if not IsValid(pnl) or not pnl:IsVisible() or not pointInsidePanel(pnl, getCursorPos()) then return false end

	local handled = false
	
	for i, child in pairs(table.Reverse(pnl:GetChildren())) do
		if not child:IsMouseInputEnabled() then continue end
		
		if postPanelEvent(child, event, ...) then
			handled = true
			break
		end
	end
	
	if not handled and pnl[event] then
		pnl[event](pnl, ...)
		usedpanel[pnl] = {...}
		return true
	else
		return false
	end
end

-- Always have issue, but less
local hover_OverridenPanels = {}

local function checkHover(pnl, x, y, found, ent)
	if ent and LocalPlayer():GetEyeTrace().Entity ~= ent then return end --- Lets not check while not even hovering the entity!
	if not (x and y) then
		x, y = getCursorPos()
	end

	if !hover_OverridenPanels[pnl] then
		pnl.IsHovered = function()
			return pnl.Hovered
		end

		hover_OverridenPanels[pnl] = true
	end

	local validchild = false
	for c, child in pairs(table.Reverse(pnl:GetChildren())) do
		if not child:IsMouseInputEnabled() then continue end
		
		local check = checkHover(child, x, y, found or validchild)

		if check then
			validchild = true
		return end
	end

	if found then
		if pnl.Hovered then
			pnl.Hovered = false
			if pnl.OnCursorExited then pnl:OnCursorExited() end
		end
	else
		if not validchild and pointInsidePanel(pnl, x, y) then
			pnl.Hovered = true
			if pnl.OnCursorEntered then pnl:OnCursorEntered() end

			return true
		else
			pnl.Hovered = false
			if pnl.OnCursorExited then pnl:OnCursorExited() end
		end
	end

	return false
end

-- Mouse input

hook.Add("KeyPress", "SVGUI3D2DMousePress", function(_, key)
	if key == IN_USE then
		for pnl in pairs(inputWindows) do
			if IsValid(pnl) then
				origin = pnl.Origin
				scale = pnl.Scale
				angle = pnl.Angle
				normal = pnl.Normal

				local key = input.IsKeyDown(KEY_LSHIFT) and MOUSE_RIGHT or MOUSE_LEFT
				
				postPanelEvent(pnl, "OnMousePressed", key)
			end
		end
	end
end)

hook.Add("KeyRelease", "SVGUI3D2DMouseRelease", function(_, key)
	if key == IN_USE then
		for pnl, key in pairs(usedpanel) do
			if IsValid(pnl) then
				origin = pnl.Origin
				scale = pnl.Scale
				angle = pnl.Angle
				normal = pnl.Normal

				if pnl["OnMouseReleased"] then
					pnl["OnMouseReleased"](pnl, key[1])
				end

				usedpanel[pnl] = nil
			end
		end
	end
end)

function vgui.Start3D2DS(pos, ang, res)
	origin = pos
	scale = res
	angle = ang
	normal = ang:Up()
	maxrange = 0
	
	cam.Start3D2D(pos, ang, res)
end

function vgui.MaxRange3D2D(range)
	maxrange = isnumber(range) and range or 0
end

function vgui.IsPointingPanel(pnl)
	origin = pnl.Origin
	scale = pnl.Scale
	angle = pnl.Angle
	normal = pnl.Normal

	return pointInsidePanel(pnl, getCursorPos())
end

local Panel = FindMetaTable("Panel")
function Panel:SPaint3D2D(ent)
	if not self:IsValid() then return end
	
	-- Add it to the list of windows to receive input
	inputWindows[self] = true

	-- Override gui.MouseX and gui.MouseY for certain stuff
	local oldMouseX = gui.MouseX
	local oldMouseY = gui.MouseY
	local cx, cy = getCursorPos()

	function gui.MouseX()
		return (cx or 0) / scale
	end
	function gui.MouseY()
		return (cy or 0) / scale
	end
	
	-- Override think of DFrame's to correct the mouse pos by changing the active orientation
	if self.Think then
		if not self.OThink then
			self.OThink = self.Think
			
			self.Think = function()
				origin = self.Origin
				scale = self.Scale
				angle = self.Angle
				normal = self.Normal
				
				self:OThink()
			end
		end
	end
	
	-- Update the hover state of controls
	local _, tab = checkHover(self,nil,nil,nil,ent)
	
	-- Store the orientation of the window to calculate the position outside the render loop
	self.Origin = origin
	self.Scale = scale
	self.Angle = angle
	self.Normal = normal
	
	-- Draw it manually
	self:SetPaintedManually(false)
		self:PaintManual()
	self:SetPaintedManually(true)

	gui.MouseX = oldMouseX
	gui.MouseY = oldMouseY
end

function vgui.End3D2DS()
	cam.End3D2D()
end

--PATH addons/uweedadvancedcannabisgrowth/lua/autorun/uweed_init.lua:
UWeed = {}
UWeed.Config = {}
UWeed.Translation = {}
UWeed.Core = {}

print("Loading UWeed")

local path = "uweed/"
if SERVER then
	--resource.AddWorkshop("1379977269")
	local files, folders = file.Find(path .. "*", "LUA")
	
	for _, folder in SortedPairs(folders, true) do
		print("Loading folder:", folder)
	    for b, File in SortedPairs(file.Find(path .. folder .. "/sh_*.lua", "LUA"), true) do
	    	print("Loading file:", File)
	        AddCSLuaFile(path .. folder .. "/" .. File)
	        include(path .. folder .. "/" .. File)
	    end
	
	    for b, File in SortedPairs(file.Find(path .. folder .. "/sv_*.lua", "LUA"), true) do
	    	print("Loading file:", File)
	        include(path .. folder .. "/" .. File)
	    end
	
	    for b, File in SortedPairs(file.Find(path .. folder .. "/cl_*.lua", "LUA"), true) do
	    	print("Loading file:", File)
	        AddCSLuaFile(path .. folder .. "/" .. File)
	    end
	end
end

if CLIENT then
	local files, folders = file.Find(path .. "*", "LUA")
	
	for _, folder in SortedPairs(folders, true) do
		print("Loading folder:", folder)
	    for b, File in SortedPairs(file.Find(path .. folder .. "/sh_*.lua", "LUA"), true) do
	    	print("Loading file:", File)
	        include(path .. folder .. "/" .. File)
	    end

	    for b, File in SortedPairs(file.Find(path .. folder .. "/cl_*.lua", "LUA"), true) do
	    	print("Loading file:", File)
	        include(path .. folder .. "/" .. File)
	    end
	end
end
print("Loaded UWeed")
--PATH addons/__main/lua/autorun/wiltos_animbase_loader.lua:

--[[-------------------------------------------------------------------
	Animation Base:
		Create your own animations, mount animations from other games, and more!
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--


if SERVER then
	AddCSLuaFile( "wos/anim_extension/loader/loader.lua" )
end

include( "wos/anim_extension/loader/loader.lua" )
--PATH addons/_dance/lua/wos/fortnite/core/cl_net.lua:
--[[-------------------------------------------------------------------
	Fortnite Dancing Client Net:
		Networking functions for the client
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2019 ]]--[[
							  
	Lua Developer: King David
	Contact: www.wiltostech.com
]]--

wOS = wOS or {}
wOS.Fortnite = wOS.Fortnite or {}

net.Receive( "wOS.Fortnite.StartTauntCamera", function()

	wOS.Fortnite.TauntCamera = wOS.Fortnite:CreateTauntCamera( true )

end )
--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/essentials_sh.lua:
function XeninUI:Ease(t, b, c, d)
	t = t / d
	local ts = t * t
	local tc = ts * t


	return b + c * (-2 * tc + 3 * ts)
end

function XeninUI:EaseInOutQuintic(t, b, c, d)
	t = t / d
	local ts = t * t
	local tc = ts * t


	return b + c * (6 * tc * ts + -15 * ts * ts + 10 * tc)
end

function XeninUI:RemoveDebounce(name)
	timer.Remove("_debounce." .. name)
end

function XeninUI:Debounce(name, wait, func)
	if timer.Exists("_debounce." .. name) then
		timer.Remove("_debounce." .. name)
	end

	timer.Create("_debounce." .. name, wait, 1, function()
		func()

		timer.Remove("_debounce." .. name)
	end)
end

if SERVER then
	util.AddNetworkString("XeninUI.FullClientInit")

	net.Receive("XeninUI.FullClientInit", function(len, p)
		if p.XeninUI_FullClientInit then
			return
		end

		hook.Run("Xenin.OnClientFullInit", p)

		p.XeninUI_FullClientInit = true
	end)
else
	hook.Add("SetupMove", "Xenin.FullClientInit", function()
		timer.Simple(15, function()
			net.Start("XeninUI.FullClientInit")
			net.SendToServer()
		end)

		hook.Remove("SetupMove", "Xenin.FullClientInit")
	end)
end

function XeninUI:LerpColor(fract, from, to)
	return Color(Lerp(fract, from.r, to.r), Lerp(fract, from.g, to.g), Lerp(fract, from.b, to.b), Lerp(fract, from.a or 255, to.a or 255))
end

function XeninUI:GetAngleBetweenTwoVectors(a, b)
	local vec = (a - b):GetNormalized()
	local ang = vec:Angle()

	return ang
end

function XeninUI:GetVector2DDistance(a, b)

	return math.sqrt((a.x - b.x) ^ 2 + (a.y - b.y) ^ 2)
end


function XeninUI:LerpVector(frac, from, to, ease)
	local newFract = ease and ease(frac, 0, 1, 1) or XeninUI:Ease(frac, 0, 1, 1)

	return LerpVector(newFract, from, to)
end

function XeninUI:LerpAngle(frac, from, to, ease)
	local newFract = ease and ease(frac, 0, 1, 1) or XeninUI:Ease(frac, 0, 1, 1)

	return LerpAngle(newFract, from, to)
end

if SERVER then
	util.AddNetworkString("XeninUI.OSTime")

	hook.Add("PlayerInitialSpawn", "XeninUI.OSTime", function(p)
		net.Start("XeninUI.OSTime")
		net.WriteFloat(os.time())
		net.WriteFloat(CurTime())
		net.Send(p)
	end)
else
	os._SVRDiff = 0

	net.Receive("XeninUI.OSTime", function()
		local ostime = net.ReadFloat()
		local ct = net.ReadFloat()

		os._SVRDiff = os.time() - ostime + ct - CurTime()
	end)

	function os.ServerTime()
		return os.time() - os._SVRDiff
	end

	local function TCMD()
		print(os.time(), os.ServerTime(), os.date("%I:%M %p", os.time()), os.date("%I:%M %p", os.ServerTime()))
	end
	concommand.Add("print_servertime", TCMD)
end

function XeninUI:Map(tbl, func)
	local newTbl = {}
	for i, v in pairs(tbl) do
		newTbl[i] = func(v, i)
	end

	return newTbl
end


function XeninUI:Hue2RGB(p, q, t)
	if t < 0 then t = t + 1 end
	if t > 1 then t = t - 1 end
	if t < 1 / 6 then return p + (q - p) * 6 * t end
	if t < 1 * 0.5 then return q end
	if t < 2 / 3 then return p + (q - p) * (2 / 3 - t) * 6 end
	return p
end


function XeninUI:HSLToColor(h, s, l, a)
	local r, g, b
	local t = h / (2 * math.pi)

	if s == 0 then
		r, g, b = l, l, l
	else
		local q
		if l < 0.5 then
			q = l * (1 + s)
		else
			q = l + s - l * s
		end
		local p = 2 * l - q

		r = self:Hue2RGB(p, q, t + 1 / 3)
		g = self:Hue2RGB(p, q, t)
		b = self:Hue2RGB(p, q, t - 1 / 3)
	end

	return Color(r * 255, g * 255, b * 255, (a or 1) * 255)
end


function XeninUI:ColorToHSL(col)
	local r = col.r / 255
	local g = col.g / 255
	local b = col.b / 255
	local max, min = math.max(r, g, b), math.min(r, g, b)
	local b = max + min
	local h = b * 0.5
	if max == min then return 0, 0, h end
	local s, l = h, h
	local d = max - min
	s = l > .5 and d / (2 - b) or d / b
	if max == r then h = (g - b) / d + (g < b and 6 or 0)
	elseif max == g then
		h = (b - r) / d + 2
	elseif max == b then
		h = (r - g) / d + 4
	end
	return h * .16667, s, l
end

function XeninUI:DecToHex(d, zeros)
	return string.format("%0" .. (zeros or 2) .. "x", d)
end

function XeninUI:RGBToHex(color)
	return "#" .. self:DecToHex(math.max(math.min(color.r, 255), 0)) .. self:DecToHex(math.max(math.min(color.g, 255), 0)) .. self:DecToHex(math.max(math.min(color.b, 255), 0))
end

function XeninUI:HexToRGB(hex)
	hex = hex:gsub("#", "")

	if (#hex == 3) then
		local r = hex:sub(1, 1)
		local g = hex:sub(2, 2)
		local b = hex:sub(3, 3)

		return Color(tonumber("0x" .. r .. r), tonumber("0x" .. g .. g), tonumber("0x" .. b .. b))
	end

	return Color(tonumber("0x" .. hex:sub(1, 2)), tonumber("0x" .. hex:sub(3, 4)), tonumber("0x" .. hex:sub(5, 6)))
end

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/inputs/checkbox.lua:
local x

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/breadcrumbs.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.Breadcrumbs", 22)

local matArrow = Material("xenin/next.png", "smooth")

function PANEL:Init()
  self.Buttons = {}
end

function PANEL:SetBreadcrumbs(tbl)
  self.Location = tbl
  for i, v in ipairs(self.Buttons) do
    v:Remove()
    self.Buttons[i] = nil
  end

  for i, v in ipairs(tbl) do
    self:CreateBreadcrumb(v, i)
  end

  self:InvalidateLayout(true)
end

function PANEL:CreateBreadcrumb(data, index)
  local size = #self.Location
  local isLast = size == index
  local name = istable(data) and data.name or data
  local onClick = istable(data) and data.onClick or function()
    return true end

  local btn = self:Add("DButton")
  btn:Dock(LEFT)
  btn:DockMargin(0, 0, 16, 0)
  btn:SetText(name)
  btn:SetExpensiveShadow(1)
  btn:SetFont("XeninUI.Breadcrumbs")
  btn:SizeToContentsX(10)
  btn.TextColor = isLast and XeninUI.Theme.Accent or Color(185, 185, 185)
  btn.IsActive = isLast
  btn.Alpha = 0
  btn.Paint = function(pnl, w, h)
    pnl:SetTextColor(pnl.TextColor)

    if (pnl.Alpha > 0) then
      XeninUI:DrawRoundedBox(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Accent, pnl.Alpha))
    end
  end
  btn.OnCursorEntered = function(pnl)
    pnl:LerpColor("TextColor", color_white)
    pnl:Lerp("Alpha", 255)
  end
  btn.OnCursorExited = function(pnl)
    pnl:LerpColor("TextColor", pnl.IsActive and XeninUI.Theme.Accent or Color(185, 185, 185))
    pnl:Lerp("Alpha", 0)
  end
  btn.DoClick = function(pnl)
    local close = onClick(pnl.IsActive, pnl)

    if close then
      self:RemoveTo(pnl:GetText())
    end
  end

  table.insert(self.Buttons, btn)

  self:CorrectColors()
end

function PANEL:CorrectColors()
  local size = #self.Buttons
  for i, v in ipairs(self.Buttons) do
    local isHovered = v:IsHovered()
    local isActive = i == size
    if (isHovered and isActive) then continue end

    v.IsActive = i == size
    v.TextColor = i == size and XeninUI.Theme.Accent or Color(185, 185, 185)
  end
end

function PANEL:AddBreadcrumb(name, onClick)
  local breadcrumb = onClick and {
    name = name,
    onClick = onClick
  } or name
  local id = table.insert(self.Location, breadcrumb)

  self:CreateBreadcrumb(breadcrumb, id)
  self:InvalidateLayout()
end

function PANEL:RemoveTo(removeToName)
  for i = #self.Location, 1, -1 do
    local breadcrumb = self.Location[i]
    local name = istable(breadcrumb) and breadcrumb.name or breadcrumb

    if (name == removeToName) then
      self.Buttons[i].IsActive = true

      break
    end

    table.remove(self.Location, i)
    if IsValid(self.Buttons[i]) then
      self.Buttons[i]:Remove()
      self.Buttons[i] = nil
    end
  end

  self:CorrectColors()
  self:InvalidateLayout()
end

function PANEL:PerformLayout(w, h)
  self:SizeToContentsX()
end

function PANEL:Paint(w, h)
  local x = 0
  local size = #self.Buttons
  for i, v in ipairs(self.Buttons) do
    if (i == size) then continue end

    surface.SetFont(v:GetFont())
    local tw = surface.GetTextSize(v:GetText())
    x = x + tw + 10 + 16

    surface.SetDrawColor(i == (size - 1) and XeninUI.Theme.Accent or Color(185, 185, 185))
    surface.SetMaterial(matArrow)
    surface.DrawTexturedRect(x - 12, h * 0.5 - h / 5 + 2, h / 2.5, h / 2.5)
  end
end

function PANEL:SizeToContentsX()
  local w = 0

  surface.SetFont("XeninUI.Breadcrumbs")
  local size = #self.Buttons
  for i, v in ipairs(self.Buttons) do
    local tw = surface.GetTextSize(v:GetText())
    tw = tw + 10

    if (i != size) then
      tw = tw + 16
    end

    w = w + tw
  end

  self:SetWide(w)
end

vgui.Register("XeninUI.Breadcrumbs", PANEL)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/checkbox.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.Checkbox", 16)
XeninUI:CreateFont("XeninUI.Checkbox.Small", 15)

function PANEL:Init()
  self:SetText("")
  self.state = nil

  self.barPos = 0

  self.offText = "OFF"
  self.onText = "ON"
  self.font = "XeninUI.Checkbox"
end

function PANEL:Paint(w, h)
  surface.SetDrawColor(Color(0, 0, 0, 150))
  surface.DrawRect(0, 0, w, h)

  self.barPos = self.barPos + ((self.state and 1 or 0) - self.barPos) * 8 * FrameTime()

  local offColor = Color(self.barPos * 200, self.barPos * 200, self.barPos * 200)
  local onColor = Color(200 - (self.barPos * 200), 200 - (self.barPos * 200), 200 - (self.barPos * 200))

  surface.SetDrawColor(Color(200, 200, 200))
  surface.DrawRect(math.Clamp(self.barPos * ((w + 4) * 0.5), 2, w * 0.5), 2, (w - 4) * 0.5, h - 4)

  draw.SimpleText(self.offText, self.font, w / 4, h * 0.5, offColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
  draw.SimpleText(self.onText, self.font, w * 0.5 + w / 4, h * 0.5, onColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end

function PANEL:DoClick()
  self:SetState(!self:GetState())
end

function PANEL:OnStateChanged() end

function PANEL:GetState()
  return self.state
end

function PANEL:SetState(state, instant)
  self.state = state

  self:OnStateChanged(state, instant)

  if instant then
    self.barPos = state and 1 or 0
  end
end

function PANEL:SetStateText(off, on)
  self.offText = off
  self.onText = on
end

vgui.Register("XeninUI.Checkbox", PANEL, "DButton")

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/checkbox_slider.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.Checkbox.Slider", 14)

AccessorFunc(PANEL, "m_state", "State")
AccessorFunc(PANEL, "m_offColor", "OffColor")
AccessorFunc(PANEL, "m_onColor", "OnColor")
AccessorFunc(PANEL, "m_btnOffColor", "ButtonOffColor")
AccessorFunc(PANEL, "m_btnOnColor", "ButtonOnColor")

function PANEL:Init()
  self:SetText("")
  self:SetState(false)

  self:SetOffColor(XeninUI.Theme.Primary)
  self:SetOnColor(XeninUI.Theme.GreenDark)

  self:SetButtonOffColor(Color(72, 72, 72))
  self:SetButtonOnColor(color_white)

  self.Color = self:GetOffColor()
  self.Pos = 0
  self.ButtonColor = self:GetButtonOffColor()
end

function PANEL:Paint(w, h)
  XeninUI:DrawRoundedBox(h * 0.5, 0, 0, w, h, self.Color)

  local size = h * 0.5
  local frac = self.Pos
  local x = frac * (w - (size * 2))





  XeninUI:DrawCircle(size + x, size, size - 3, 30, self.ButtonColor)
end


function PANEL:OnStateChanged(state) end

function PANEL:SetState(state)
  self.m_state = state
  self:OnStateChanged(state)
end

function PANEL:UpdateState(instant)
  local state = self:GetState()
  local col = state and self:GetOnColor() or self:GetOffColor()
  local btnCol = state and self:GetButtonOnColor() or self:GetButtonOffColor()
  local pos = state and 1 or 0

  if instant then
    self.Color = col
    self.ButtonColor = btnCol
    self.Pos = pos
  else
    self:EndAnimations()
    self:LerpColor("Color", col)
    self:LerpColor("ButtonColor", btnCol)
    self:Lerp("Pos", pos)
  end
end

function PANEL:DoClick()
  self:SetState(!self:GetState())
  self:UpdateState()
end

vgui.Register("XeninUI.Checkbox.Slider", PANEL, "DButton")

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/colormixer.lua:
local PANEL = {}

function PANEL:Init()
    self.sliders = vgui.Create("Panel", self)
    self.sliders:Dock(LEFT)
    self.sliders:DockMargin(0, 0, 10, 0)

    self.red = vgui.Create("Panel", self.sliders)
    self.red:Dock(TOP)

    self.rInput = vgui.Create("XeninUI.TextEntry", self.red)
    self.rInput:Dock(LEFT)
    self.rInput:DockMargin(0, 0, 0, 5)
    self.rInput:SetText(0)
    self.rInput.textentry:SetUpdateOnType(true)

    self.Input.textentry.OnValueChange = function(pnl, value)
        local numValue = tonumber(value)
        if not numValue then return pnl:SetText("255")end

        if numValue < 0 or numValue > 255 then return pnl:SetText("255")end

        self.rSlider.fraction = (numValue / 255)
        self.rSlider:InvalidateLayout()
    end

    self.rSlider = vgui.Create("XeninUI.Slider", self.red)
    self.rSlider:Dock(RIGHT)
    self.rSlider:SetMin(0)
    self.rSlider:SetMax(255)
    self.rSlider:SetColor(Color(231, 76, 60))

    self.rSlider.OnValueChanged = function(pnl, frac)
        self.rInput:SetText(math.floor(frac * 255))
    end

    self.green = vgui.Create("Panel", self.sliders)
    self.green:Dock(TOP)

    self.gInput = vgui.Create("XeninUI.TextEntry", self.green)
    self.gInput:Dock(LEFT)
    self.gInput:DockMargin(0, 0, 0, 5)
    self.gInput:SetText(0)
    self.gInput.textentry:SetUpdateOnType(true)

    self.gInput.textentry.OnValueChange = function(pnl, value)
        local numValue = tonumber(value)
        if not numValue then return pnl:SetText("0")end

        if numValue < 0 or numValue > 255 then return pnl:SetText("255")end

        self.gSlider.fraction = (numValue / 255)
        self.gSlider:InvalidateLayout()
    end

    self.gSlider = vgui.Create("XeninUI.Slider", self.green)
    self.gSlider:Dock(RIGHT)
    self.gSlider:SetMin(0)
    self.gSlider:SetMax(255)
    self.gSlider:SetColor(Color(46, 204, 113))

    self.gSlider.OnValueChanged = function(pnl, frac)
        self.gInput:SetText(math.floor(frac * 255))
    end

    self.blue = vgui.Create("Panel", self.sliders)
    self.blue:Dock(TOP)

    self.bInput = vgui.Create("XeninUI.TextEntry", self.blue)
    self.bInput:Dock(LEFT)
    self.bInput:DockMargin(0, 5, 0, 0)
    self.bInput:SetText(0)
    self.bInput.textentry:SetUpdateOnType(true)

    self.bInput.textentry.OnValueChange = function(pnl, value)
        local numValue = tonumber(value)
        if not numValue then return pnl:SetText("0")end

        if numValue < 0 or numValue > 255 then return pnl:SetText("255")end

        self.bSlider.fraction = (numValue / 255)
        self.bSlider:InvalidateLayout()
    end

    self.bSlider = vgui.Create("XeninUI.Slider", self.blue)
    self.bSlider:Dock(RIGHT)
    self.bSlider:SetMin(0)
    self.bSlider:SetMax(255)
    self.bSlider:SetColor(Color(52, 152, 219))

    self.bSlider.OnValueChanged = function(pnl, frac)
        self.bInput:SetText(math.floor(frac * 255))
    end

    self.preview = vgui.Create("Panel", self)
    self.preview:Dock(FILL)
    self.preview:DockMargin(5, 5, 5, 5)

    self.preview.Paint = function(pnl, w, h)
        draw.RoundedBox(6, 0, 0, w, h, self:GetValue())
    end
end

function PANEL:SetValue(color)
    self.rSlider.fraction = color.r / 255
    self.rInput:SetText(color.r)
    self.gSlider.fraction = color.g / 255
    self.gInput:SetText(color.g)
    self.bSlider.fraction = color.b / 255
    self.bInput:SetText(color.b)
end

function PANEL:GetValue()
    return Color(math.floor(self.rSlider.fraction * 255), math.floor(self.gSlider.fraction * 255), math.floor(self.bSlider.fraction * 255))
end

function PANEL:PerformLayout(w, h)
    self.sliders:SetWide(w * .8)

    self.red:SetTall(h / 3)
    self.rInput:SetWide(self.red:GetWide() * .11)
    self.rSlider:SetWide(self.red:GetWide() * .88)

    self.green:SetTall(h / 3)
    self.gInput:SetWide(self.green:GetWide() * .11)
    self.gSlider:SetWide(self.green:GetWide() * .88)

    self.blue:SetTall(h / 3)
    self.bInput:SetWide(self.blue:GetWide() * .11)
    self.bSlider:SetWide(self.blue:GetWide() * .88)
end

vgui.Register("XeninUI.ColorMixer", PANEL)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/colorpicker.lua:
local PANEL = {}


function PANEL:OnChange(color) end

function PANEL:UpdateColor()
  self.Color = XeninUI:HSLToColor(self.Hue, self.Saturation, self.Lightness)
  self:OnChange(self.Color)
end

function PANEL:SetColor(color)
  local h, s, l = ColorToHSL(color)
  h = h / (360 / 5)
  self.Hue = h
  self.Saturation = s
  self.Lightness = l

  self.Color = color
  self:OnChange(color)

  self:UpdatePositions()
end

function PANEL:UpdatePositions()
  local radius = self:GetTriangleRadius()
  local hue = self.Hue
  local third = (2 / 3) * math.pi
  local sat = self.Saturation
  local light = 1 - self.Lightness

  local hX = math.cos(hue)
  local hY = math.sin(hue)
  local sX = math.cos(hue - third)
  local sY = math.sin(hue - third)
  local vX = math.cos(hue + third)
  local vY = math.sin(hue + third)

  local mX = (sX + vX) * 0.5
  local mY = (sY + vY) * 0.5
  local a = (1 - 2 * math.abs(light - 0.5)) * sat

  self.TriX = sX + (vX - sX) * light + (hX - mX) * a
  self.TriY = sY + (vY - sY) * light + (hY - mY) * a
end

function PANEL:Think()
  local cursorX, cursorY = self:CursorPos()
  local cX, cY = self:GetCenter()
  local center = Vector(cX, cY, 0)
  local radius = self:GetRadius()
  local triangleRadius = self:GetTriangleRadius()

  if (!self.Pressed) then return end

  local diffX = cursorX - cX
  local diffY = cursorY - cY
  local rad = math.atan2(diffY, diffX)
  if (rad < 0) then
    rad = rad + (2 * math.pi)
  end

  if self.PressedWheel then
    self.Hue = rad
    self:UpdatePositions()
    self:UpdateColor()

    return
  end

  local rad0 = (rad + 2 * math.pi - self.Hue) % (2 * math.pi)
  local rad1 = rad0 % ((2 / 3) * math.pi) - (math.pi / 3)
  local a = 0.5 * triangleRadius
  local b = math.tan(rad1) * a
  local r = math.sqrt(diffX * diffX + diffY * diffY)
  local maxR = math.sqrt(a * a + b * b)

  if (r > maxR) then
    local dx = math.tan(rad1) * r
    local rad2 = math.Clamp(math.atan(dx / maxR), -math.pi / 3, math.pi / 3)
    rad = rad + (rad2 - rad1)
    rad0 = (rad + 2 * math.pi - self.hue) % (2 * math.pi)
    rad1 = rad0 % ((2 / 3) * math.pi) - (math.pi / 3)
    b = math.tan(rad1) * a
    maxR = math.sqrt(a * a + b * b)
    r = maxR
  end

  self.TriX = math.cos(rad) * r / triangleRadius
  self.TriY = math.sin(rad) * r / triangleRadius

  local triangleSideLen = math.sqrt(3) * triangleRadius
  local light = ((math.sin(rad0) * r) / triangleSideLen) + 0.5
  local widthShare = 1.0 - math.abs(light - 0.5) * 2.0
  local saturation = (((math.cos(rad0) * r) + (triangleRadius * 0.5)) / (1.5 * triangleRadius)) / widthShare
  saturation = math.Clamp(saturation, 0, 1)

  self.Lightness = 1 - light
  self.Saturation = saturation

  self:UpdateColor()
end

function PANEL:Init()
  self.Hue = 0
  self.SmoothHue = 0

  self.Lightness = 0
  self.Saturation = 0

  self.TriX = 0
  self.TriY = 0

  self:UpdateColor()
  self:UpdatePositions()

  XeninUI:DownloadIcon(self, "i0xcO1R")
  XeninUI:DownloadIcon(self, "k5mtok6", "Ring")
  XeninUI:DownloadIcon(self, "t0k86qy", "Picker")
end

function PANEL:OnMousePressed()
  self.Pressed = true

  local cX, cY = self:GetCenter()
  local cursorX, cursorY = self:CursorPos()
  local cursor = Vector(cursorX, cursorY)
  local center = Vector(cX, cY, 0)

  if (cursor:Distance(center) > self:GetTriangleRadius()) then
    self.PressedWheel = true

    return
  end

  self.PressedTriangle = true
end

function PANEL:OnMouseReleased()
  self.Pressed = false
  self.PressedWheel = false
  self.PressedTriangle = false
end

function PANEL:GetCenter()
  return self:GetWide() * 0.5, self:GetTall() * 0.5
end

function PANEL:GetRadius()
  return self:GetTall() * 0.5
end

function PANEL:GetTriangleRadius()
  return self:GetRadius() * 0.7
end

function PANEL:GetRingThickness()
  return self:GetRadius() * 0.2
end

function PANEL:GetHueColor()
  return XeninUI:HSLToColor(self.Hue, 1, 0.5)
end

function PANEL:Paint(w, h)
  local cX, cY = self:GetCenter()
  local radius = self:GetRadius()
  local triangleRadius = self:GetTriangleRadius()

  draw.NoTexture()

  local triangleAng = self.Hue
  local triangleOff = math.pi * 2 / 3
  local vertices = {
    {
      x = cX + math.cos(triangleAng - triangleOff) * triangleRadius,
      y = cY + math.sin(triangleAng - triangleOff) * triangleRadius,
      u = 0.5,
      v = 0.99
    },
    {
      x = cX + math.cos(triangleAng) * triangleRadius,
      y = cY + math.sin(triangleAng) * triangleRadius,
      u = 0.99,
      v = 0.01
    },
    {
      x = cX + math.cos(triangleAng + triangleOff * 1) * triangleRadius,
      y = cY + math.sin(triangleAng + triangleOff * 1) * triangleRadius,
      u = 0.01,
      v = 0.01
    }
  }

  local col = self:GetHueColor()
  surface.SetDrawColor(col)
  surface.DrawPoly(vertices)

  surface.SetDrawColor(255, 255, 255)
  surface.SetMaterial(self.Icon)
  surface.DrawPoly(vertices)
  surface.DrawPoly(vertices)

  vertices[1].u = 0.99
  vertices[1].v = 0.01

  vertices[2].u = 0.01
  vertices[2].v = 0.01

  vertices[3].u = 0.5
  vertices[3].v = 0.99

  surface.SetDrawColor(0, 0, 0)
  surface.SetMaterial(self.Icon)
  surface.DrawPoly(vertices)

  surface.SetDrawColor(255, 255, 255)
  surface.SetMaterial(self.Ring)
  surface.DrawTexturedRect(cX - radius, cY - radius, radius * 2, radius * 2)

  local pickerVerts = {
    {
      x = cX + self.TriX * triangleRadius + 2,
      y = cY + self.TriY * triangleRadius + 2,
      u = 1,
      v = 1
    },
    {
      x = cX + self.TriX * triangleRadius - 2,
      y = cY + self.TriY * triangleRadius + 2,
      u = 0,
      v = 1
    },
    {
      x = cX + self.TriX * triangleRadius - 2,
      y = cY + self.TriY * triangleRadius - 2,
      u = 0,
      v = 0
    },
    {
      x = cX + self.TriX * triangleRadius + 2,
      y = cY + self.TriY * triangleRadius - 2,
      u = 1,
      v = 0
    }
  }

  surface.SetDrawColor(255, 255, 255)
  surface.SetMaterial(self.Picker)
  surface.DrawPoly(pickerVerts)

  local hpX = cX + math.cos(self.Hue) * (radius - self:GetRingThickness() * 0.5)
  local hpY = cY + math.sin(self.Hue) * (radius - self:GetRingThickness() * 0.5)
  local size = 16
  local huePickerVerts = {
    {
      x = hpX + size * 0.5,
      y = hpY + size * 0.5,
      u = 1,
      v = 1
    },
    {
      x = hpX - size * 0.5,
      y = hpY + size * 0.5,
      u = 0,
      v = 1
    },
    {
      x = hpX - size * 0.5,
      y = hpY - size * 0.5,
      u = 0,
      v = 0
    },
    {
      x = hpX + size * 0.5,
      y = hpY - size * 0.5,
      u = 1,
      v = 0
    }
  }
  surface.SetDrawColor(255, 255, 255)
  surface.SetMaterial(self.Picker)
  surface.DrawPoly(huePickerVerts)
end

vgui.Register("XeninUI.ColorPicker", PANEL)

--PATH addons/battlepass/lua/battlepass/challenges/nakopit_250000.lua:
local CHALLENGE = BATTLEPASS:CreateTemplateChallenge()
CHALLENGE:SetName("Накопичити 250000$")
CHALLENGE:SetIcon("battlepass/challenges/shipments.png") -- <- ??
CHALLENGE:SetDesc("")
CHALLENGE:SetProgressDesc("---")
CHALLENGE:SetFinishedDesc("---")
CHALLENGE:SetID("nakopit_250000")
CHALLENGE:SetPremium(true)

CHALLENGE:AddHook("playerGiveMoney_BattlePass", function(self, ply, _ply, sum)
  if IsValid( _ply ) and ply == _ply and _ply.BattlePass.Owned.owned then
    self:AddProgress(sum)
    self:NetworkProgress()
  end
end)

BATTLEPASS:RegisterChallenge(CHALLENGE)
--PATH addons/battlepass/lua/battlepass/challenges/vikonai_5_zakazov_za_naemnika.lua:
local CHALLENGE = BATTLEPASS:CreateTemplateChallenge()
CHALLENGE:SetName("Виконай 5 заказів за найманця")
CHALLENGE:SetIcon("battlepass/challenges/shipments.png") -- <- ??
CHALLENGE:SetDesc("")
CHALLENGE:SetProgressDesc("---")
CHALLENGE:SetFinishedDesc("---")
CHALLENGE:SetID("vikonai_5_zakazov_za_naemnika")

CHALLENGE:AddHook("playerCompletedHit", function(self, ply, _ply)
  if IsValid( _ply ) and ply == _ply and (_ply:Team() == TEAM_KILL or _ply:Team() == TEAM_NAIM) then
    self:AddProgress(1)
    self:NetworkProgress()
  end
end)

BATTLEPASS:RegisterChallenge(CHALLENGE)
--PATH addons/________anticrash/lua/z_anticrash/client/cl_userdata.lua:

CL_ANTICRASH.USERDATA = {}

function CL_ANTICRASH.USERDATA.GetEntityCount(ply)

	local entCount = 0
	
	for k, ent in ents.Iterator() do
		
		if ent:CPPIGetOwner() == ply then
			entCount = entCount + 1
		end
	
	end
			
	return entCount
			
end

function CL_ANTICRASH.USERDATA.GetSpawnedEntitiesCount(ply)
	return ply:z_anticrashGetSpawnCount()
end

function CL_ANTICRASH.USERDATA.GetPropCount(ply)

	local propCount = 0
	
	for k, ent in ents.Iterator() do

		local class = ent:GetClass()
		
		if ent:CPPIGetOwner() == ply and !ent:IsVehicle() and string.StartWith(class, "prop_") then
			propCount = propCount + 1
		end
	
	end
			
	return propCount

end

function CL_ANTICRASH.USERDATA.GetConstraintCount(ply)
	return ply:z_anticrashGetConstraintCount()
end

--PATH addons/________anticrash/lua/z_anticrash/shared/sh_language.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER]]

local translations = {
	
	-- Stats
	lag = "ЛАГ",
	collisions = "ЗІТКНЕННЯ",
	props = "ПРОПИ",
	propsFrozen = "ЗАМОРОЖЕНІ ПР.",
	npcs = "НПС",
	vehicles = "ТРАНСПОРТ",
	players = "ГРАВЦІ",
	uptime = "СЕРВЕР ЗАПУЩЕН",
	entities = "ЕНТІТІ",
	spawned = "СТВОРЕНО",
	fps = "FPS",
	tickrate = "ТИКРЕЙТ",
	runAntiLagMeasures = "ЗАПУСТИТИ АНТИ-ЛАГОВІ ЗАХОДИ",
	
	-- Users
	search = "Пошук",
	constraints = "ПІД'ЄДНАННЯ",
	showEntities = "Показати Ентиті",
	hideEntities = "Сховати Ентиті",
	freezeEntities = "Заморозити Ентиті",
	removeEntities = "Видалити Ентиті",
	
	-- Lag
	heavyLag = "Виявлено сильні лаги!",
	lagIsStuck = "Увага: тривалі лаги",
	crashPrevented = "Запобігано крашу сервера!",
	revertChanges = "+ Видалення %s ентиті створених за останні %s хвилин",
	freezeingEnts = "+ Заморожування %s ентиті",
	offenderWarning = "У %s є підозріло велика кількість ентиті (%s), що викликає лаги!",
	
	-- Notifications
	triggeredAntiLagMeasures = "спрацьовують заходи проти лагів!",
	ranAntilagMeasures = "запущено заходи проти лагів!",
	hasNoEntities = "немає ентиті!",
	youRemovedFrom = "Ви видалили %s ентиті у %s!",
	removedYourObjects = "видалено ваші створені об'єкти!",
	youFrozeFrom = "Ви заморозили %s ентиті у %s!",
	frozeYourObjects = "заморожено ваші створені об'єкти!",

	noUnfrozenEntsFound = "Не знайдено незаморожених ентиті!",
	freezeAllEnts = "%s заморозив об'єкти у %s! (%s)",
	entitiesLowCase = "ентиті",
	
	-- Console Log
	removedEntitiesFrom = "%s видалив %s ентиті у %s!",
	frozeEntitiesFrom = "%s заморозив %s ентиті у %s!",
	removingHighCollision = "Видалення сильних зіткнень %s (%s) у %s!",
	
}

function SH_ANTICRASH.Translate(str)
	local translatedStr = translations[str]
	
	return translatedStr or str
end

function SH_ANTICRASH.Format(str)

	local formattedStr = str

	-- Full string format
	if string.StartWith(str,"##") then

		local str = string.sub( str, 3 )
		local strSplitTbl = string.Split(str,' %')
		local translatedStr = SH_ANTICRASH.Translate(strSplitTbl[1])

		-- Keep format parms only
		table.remove(strSplitTbl,1)
		
		-- Replace format parms
		translatedStr = string.format( translatedStr, unpack(strSplitTbl))
		
		formattedStr = translatedStr
		
	end
	
	-- Partial string format
	local formattedStr = string.gsub(formattedStr, "#(%w*)", function(match)
		return SH_ANTICRASH.Translate(match)
	end)
	
	return formattedStr
	
end
--PATH addons/____bricks_gangs/lua/bricks_server/languages/bricks_gangs/russian.lua:
BRICKS_SERVER.Func.AddLanguageStrings( "russian", {
    ["gang"] = "Банда",
    ["gangNew"] = "Создать банду",
    ["gangRequestCooldown"] = "Пожалуйста подождите, прежде чем запросить другие банды!",
    ["gangRequestDataCooldown"] = "Пожалуйста подождите, прежде чем запросить данную про банды!",
    ["gangNewUpgrade"] = "Новое улучшение",
    ["gangUpgradeTierEdit"] = "%s - Уровень %d",
    ["gangNewAchievement"] = "Новое достижение",
    ["gangNewTerritory"] = "Новая территория",
    ["gangRewardTime"] = "Время приза",
    ["gangRewardTimeQuery"] = "Как часто банда которая одержала терреторию, должна получать награды?",
    ["gangRewards"] = "Награды",
    ["gangNewLeaderboard"] = "Новое меню лидеров",
    ["gangRankQuery"] = "Какой ранг вы хотели бы установить?",
    ["gangPlayerAlreadyRank"] = "Данный игрок уже имеет данный ранг!",
    ["gangInvalidRank"] = "Неверный ранг.",
    ["gangKick"] = "Выгнать",
    ["gangKickConfirm"] = "Вы уверены что хотите выгнать данного игрока?",
    ["gangSetOwner"] = "Установить владельца",

    ["gangInbox"] = "Криминальная почта",
    ["gangNoNotifications"] = "У вас нет новых уведомлений!",
    ["gangTimeAgo"] = "%s назад",
    ["gangNotification"] = "новое уведомление",
    ["gangNotificationHeader"] = "Какой будет заголовок уведомления?",
    ["gangAdminNotification"] = "Админское уведомление",
    ["gangNotificationBody"] = "Что вы напишите в основной части уведомления?",
    ["gangAdminNotificationSent"] = "Админское уведомление отправлено %s!",

    ["gangVariables"] = "Вариации Банды",
    ["gangUpgrades"] = "Улучшение банды",
    ["gangAchievements"] = "Достижения банды",
    ["gangTerritories"] = "Территория банды",
    ["gangLeaderboards"] = "Доска лидеров",

    ["gangClaimedAchievement"] = "Успешно, получено достижение!",
    ["gangAlreadyAssociation"] = "Ваша банда уже имеет такой тип связи с другой бандой!",
    ["gangAlreadySentAssociation"] = "Ваша банда уже отправила им приглашение, в ассоциацию!",
    ["gangAssociationSent"] = "Приглашение ассоциации отправлено!",
    ["gangAssociationAccepted"] = "Приглашение ассоциации принято!",
    ["gangNoAssociation"] = "Ваша банда не имеет никакого отношения к этой банде!",
    ["gangAssociationDissolved"] = "Ассоциация распущена!",

    ["gangOwner"] = "Владелец",
    ["gangOfficer"] = "Офицер",
    ["gangMember"] = "Участник",

    ["gangCannotDeposit"] = "Вы не можете положить это оружие!",
    ["gangStorageFullError"] = "Хранилище банды переполнено!",
    ["gangDepositedItem"] = "Вы поклали предмет в хранилище банды!",
    ["gangDroppedItem"] = "Выброшено 1 предмет из вашего хранилища банды.",
    ["gangUsedItem"] = "Использован 1 предмет из вашего хранилища банды.",
    ["gangCantUse"] = "Вы не можете использовать это!",

    ["gangKicked"] = "Вас выгнали из банды %s!",
    ["gangAlreadyIn"] = "Вы уже в банде!",
    ["gangNameLength"] = "Название банды не может быть длиннее %d символов!",
    ["gangIconLength"] = "URL значка банды не может быть длиннее %d символов!",
    ["gangCreatedFor"] = "Ваша новая банда была создана для %s!",
    ["gangCreated"] = "Ваша банда создана!",
    ["gangCreationNoMoney"] = "Вам не хватает денег, вам нужно %s!",
    ["gangWaitBeforeSaving"] = "Пожалуйста, подождите %d секунд, прежде чем сохранить изменения!",
    ["gangRolesUpdated"] = "Ранги банды обновлены!",
    ["gangCannotTarget"] = "Вы не можете трогать его!",
    ["gangRankNotExists"] = "Данный ранг не найден!",
    ["gangCantPromote"] = "Вы не можете повысить кого-либо на уровень выше, или такой же как у вас!",
    ["gangRankSet"] = "Ранг успешно установлен!",
    ["gangRankSetFail"] = "Не удалось установить ранг!",
    ["gangSettingsUpdated"] = "Настройки банды обновлены!",
    ["gangPlayerKicked"] = "Удачно выгнан %s с вашей банды!",
    ["gangPlayerKickError"] = "Ошибка при изгнании учасника!",
    ["gangWaitBeforeInvite"] = "Пожалуйста, подождите 5 секунд прежде чем пригласить другого игрока!",
    ["gangPlayerOffline"] = "Этот игрок больше не в сети!",
    ["gangPlayerAlreadyInvited"] = "Этот игрок уже имеет активное приглашение!",
    ["gangPlayerInvited"] = "Вы пригласили, %s в вашу банду!",
    ["gangInviteReceived"] = "Вы были приглашены в банду %s! Введите !gang дабы принять.",
    ["gangLeaveCurrent"] = "Вы должны покинуть свою текущую банду в первую очередь!",
    ["gangReachedMemberLimit"] = "Банда достигла предела своих участников!",
    ["gangJoined"] = "Успешно вступили в %s!",
    ["gangNotEnoughMoney"] = "Вам не хватает денег!",
    ["gangDepositedMoney"] = "Вы успешно внесли %s в вашу банду!",
    ["gangWithdrewMoney"] = "Вы успешно сняли %s с вашей банды!",
    ["gangDisbanded"] = "Ваша банда успешно распущена %s!",
    ["gangOwnershipTransfered"] = "Успешно передано право владения банды с %s на %s!",
    ["gangLeft"] = "Вы покинули %s!",

    ["gangTerritoryCaptured"] = "Ваша банда захватила %s территорию!",
    ["gangIncorrectLevel"] = "Ваша банда не имеет нужный уровень, чтобы купить это обновление!",
    ["gangIncorrectGroup"] = "Вы не подходящая группа, чтобы купить это обновление!",
    ["gangUpgradeBought"] = "Обновление куплено для банды %s!",
    ["gangNotEnoughFunds"] = "У вашей банды недостаточно средств для покупки этого улучшения!",

    ["gangAddAchievement"] = "Добавить достижение",
    ["gangNewAchievementType"] = "Каким должен быть новый тип достижений?",
    ["gangAddLeaderboard"] = "Добавить таблицу лидеров",
    ["gangNewLeaderboardType"] = "Каким должен быть новый тип таблицы лидеров??",
    ["gangAddTerritory"] = "Добавить территорию",
    ["gangAddTier"] = "Добавить уровень",
    ["gangTierX"] = "Уровень %d",
    ["gangNewUpgradeType"] = "Каким должен быть новый тип улучшения?",
    ["gangNewUpgradeDesc"] = "Новое описание улучшения.",

    ["gangDepositMenu"] = "Меню депозита",
    ["gangDepositInventoryQuery"] = "Вы хотите внести депозит %s с вашего инвентаря?",
    ["gangDepositPlayerQuery"] = "Вы хотите внести депозит %s с вашего владения?",
    ["gangNoDepositItems"] = "У вас нет предметов, которые можно сдать на в хранилище банды!",

    ["gangMenu"] = "Меню банды",
    ["gangNone"] = "Нет банды",
    ["gangID"] = "ID: %d",
    ["gangDashboard"] = "Управление",
    ["gangMembers"] = "Участники",
    ["gangStorage"] = "Хранилище",
    ["gangUpgrades"] = "Улучшения",
    ["gangBalance"] = "Баланс",
    ["gangAchievements"] = "Достижения",
    ["gangAssociations"] = "Ассоциации",
    ["gangLeaderboards"] = "Таблица лидеров",
    ["gangTerritories"] = "Территории",
    ["gangRanks"] = "Ранги",
    ["gangCreate"] = "Создать банду",
    ["gangProgress"] = "Прогресс: %s",

    ["gangNoneFound"] = "По вашему запросу ничего не найдено.",
    ["gangMemberCount"] = "%d/%d Участники",
    ["gangFailedToLoad"] = "Произошла ошибка при загрузке данных!",
    ["gangSetRank"] = "Установить ранг",
    ["gangDissolveAssociation"] = "Хотели бы вы расторгнуть эту ассоциацию??",
    ["gangAssociationStatus"] = "Статус: %s",
    ["gangNeutral"] = "Нейтрально",
    ["gangCreateString"] = "Создать банду для %s",
    ["gangName"] = "Название:",
    ["gangIcon"] = "URL Значка:",
    
    ["gangInformation"] = "ИНФОРМАЦИЯ О БАНДЕ",
    ["gangChat"] = "ЧАТ БАНДЫ",
    ["gangMessage"] = "Сообщение банды",
    ["gangActions"] = "ДЕЙСТВИЯ БАНДЫ",
    ["gangDepositMoney"] = "Внести деньги",
    ["gangDepositMoneyQuery"] = "Сколько бы вы хотели внести на депозит?",
    ["gangDepositMoneyLess"] = "Вы не можете внести депозит меньше, чем %s!",
    ["gangDepositMoneyMuch"] = "Баланс вашей банды не может вместить так много, вы должны улучшить хранилище баланса!",
    ["gangWithdrawMoney"] = "Снять деньги",
    ["gangWithdrawMoneyQuery"] = "Сколько бы вы хотели снять?",
    ["gangWithdrawMoneyLess"] = "Вы не можете снять меньше, чем %s!",
    ["gangWithdrawMoneyMuch"] = "Вашей банде не хватает средств!",
    ["gangInvitePlayer"] = "Пригласить игрока",
    ["gangInvitePlayerQuery"] = "Какого игрока вы бы хотели пригласить?",
    ["gangDisband"] = "Распустить банду",
    ["gangDisbandQuery"] = "Удаление вашей банды не может быть отменено, введите %s дабы удалить банду.",
    ["gangTransfer"] = "Передать права на банду",
    ["gangTransferQuery"] = "Кому бы вы хотели передать права банды?",
    ["gangLeave"] = "Покинуть банду",
    ["gangLeaveQuery"] = "Вы уверены, что хотите покинуть эту банду??",
    ["gangMemberUpper"] = "УЧАСТНИКИ БАНДЫ",
    ["gangHighestRank"] = "Наивысший ранг",
    ["gangLowestRank"] = "Самый низкий ранг",

    ["gangUnsavedChanges"] = "Внимание! У вас есть несохраненные изменения.",
    ["gangSaveChanges"] = "Сохранить изменения",
    ["gangReset"] = "Сбросить",
    ["gangRanksUpper"] = "РАНГИ БАНДЫ",
    ["gangNewRank"] = "Новый ранг",
    ["gangRankName"] = "Название ранга",
    ["gangRankColor"] = "Цвет ранга",
    ["gangClearPerms"] = "Очистить права",
    ["gangDeleteRank"] = "Удалить ранг",
    ["gangDeleteRankQuery"] = "Вы уверены, что хотите удалить этот ранг?",

    ["gangStorageUpper"] = "ХРАНИЛИЩЕ БАНДЫ",
    ["gangStorageProgress"] = "Заполненость %d/%d",
    ["gangClaimed"] = "Создано",
    ["gangUnclaimed"] = "Не создано",
    ["gangClaimedAgo"] = "Создано %s назад",
    ["gangRewardsEvery"] = "Учитывая каждый %s",
    ["gangBuyUpgrade"] = "Вы хотите купить это обновление для %s?",
    ["gangUpgradeTier"] = "Уровень улучшения %d/%d",
    ["gangCurrent"] = "Текущий уровень: %s",
    ["gangNext"] = "Следующий уровень: %s",

    ["gangTerritoryUpper"] = "ТЕРРИТОРИИ",
    ["gangCaptured"] = "ЗАХВАЧЕНО",
    ["gangTerritoryAlready"] = "Ваша банда уже захватила эту территорию!",
    ["gangCaptureFail"] = "Вы отошли слишком далеко или погибли, захват не удался!",
    ["gangTerritoryPlaced"] = "Территория успешно размещена.",
    ["gangInvalidTerritory"] = "Неверная территория, выберите действительную из меню инструментов.",
    ["gangTerritoryRemoved"] = "Территория успешно удалена.",
    ["gangTerritoryRemoveFail"] = "Вы можете использовать этот инструмент только для удаления/создания территорий.",
    ["gangTerritoryDesc"] = "Размещает и удаляет территории с Brick's Gangs. Щелкните левой кнопкой мыши - поместите, щелкните правой кнопкой мыши - удалите.",
    ["gangTerritory"] = "ТЕРРИТОРИЯ",
    ["gangTerritoryPlacer"] = "Место территории",
    ["gangTerritoryDescSmall"] = "Размещает и удаляет территории с сервера Брик.",
    ["gangTerritoryInstructions"] = "Левый клик - разместить, правый клик - удалить.",

    ["gangSettings"] = "Настройки",
    ["gangManagement"] = "Управление",
    ["gangChatLower"] = "Чат банды",
    ["gangDepositItems"] = "Депозит предметами",
    ["gangWithdrawItems"] = "Забрать предметы",
    ["gangViewStorage"] = "Посмотреть хранилище",
    ["gangEditRoles"] = "Изменить ранги",
    ["gangEditSettings"] = "Изменить настройки",
    ["gangInvitePlayers"] = "Пригласить игроков",
    ["gangKickPlayers"] = "Выгнать игроков",
    ["gangChangeRank"] = "Изменить ранг игрока",
    ["gangPurchaseUpgrades"] = "Купить улучшение",
    ["gangAcceptDeclineInbox"] = "Принять или отклонить входящие уведомления",
    ["gangAssociationSend"] = "Отправить запросы на ассоциацию",
    ["gangAssociationAccept"] = "Принять запросы на ассоциацию",
    ["gangSendChatMessages"] = "Отправить сообщение в чат",
    ["gangMaxMembers"] = "Макс. Участников",
    ["gangMaxBalance"] = "Макс. Баланс",
    ["gangStorageSlots"] = "Слоты хранилища",
    ["gangXSlots"] = "%d Слотов",
    ["gangSlots"] = "Слотов",
    ["gangIncreasedHealth"] = "Увеличение здоровья",
    ["gangExtraHealth"] = "Дополнительное здоровье",
    ["gangXHP"] = "+%d ХП",
    ["gangIncreasedArmor"] = "Усиленная броня",
    ["gangXAP"] = "+%d ЗАЩИТЫ",
    ["gangExtraArmor"] = "Дополнительная броня",
    ["gangIncreasedSalary"] = "Увеличение зарплаты",
    ["gangExtraSalary"] = "Дополнительная зарплата",
    ["gangPermWeapon"] = "Вечное оружие",
    ["gangWeapon"] = "Оружие",
    ["gangBalanceFull"] = "Баланс банды",
    ["gangMembersFull"] = "Участники банды",
    ["gangStorageFull"] = "Хранилище банды",
    ["gangItems"] = "Предметы",
    ["gangItem"] = "Предмет",
    ["gangLevel"] = "Уровень банды",
    ["gangInvite"] = "Пригласить в банду",
    ["gangInviteReceivedInbox"] = "Вас пригласили вступить в банду %s!",
    ["gangAssociationInvite"] = "Приглашение ассоциации",
    ["gangAssociationInviteInbox"] = "Банда %s запросила ассоциацию '%s' с вашей бандой!",
    ["gangAssociationCreated"] = "Ассоциация создана",
    ["gangAssociationCreatedInbox"] = "Ваша банда теперь имеет ассоциацию '%s' с бандой %s!",
    ["gangAssociationDissolved"] = "Ассоциация распущена",
    ["gangAssociationDissolvedInbox"] = "Ваша связь с бандой %s распущена!",
    ["gangInboxAchievement"] = "Достижение банды",
    ["gangInboxAchievementCompleted"] = "Ваша банда завершила '%s' достижение!",
    ["gangInboxAchievementCompletedReward"] = "Ваша банда завершила '%s' достижение, ваша награда: %s!",
    ["gangExperienceFull"] = "Опыт банды",
    ["gangJobWhitelist"] = "Белый список профессий",
    ["gangJobs"] = "Работы",
    ["gangJobsSelect"] = "Выберите команды, в которых игроки занесены в белый список.",
    ["gangStorageItems"] = "Хранение предметов",
    ["gangAllyRequest"] = "Вы уверены, что хотите запросить союз с этой бандой?",
    ["gangWarRequest"] = "Вы уверены, что хотите запросить войну с этой бандой?",
    ["gangSetLevel"] = "Установить уровень",
    ["gangSetLevelQuery"] = "Каким должен быть новый уровень банды?",
    ["gangSetLevelMsg"] = "Успешно установлен уровень банды с %s на %d!",
    ["gangAddExperience"] = "Добавить опыт",
    ["gangAddExperienceQuery"] = "Какой опыт вы бы хотели добавить в банду?",
    ["gangAddExperienceMsg"] = "Успешно добавил %s опыта в банду %s!",
    ["gangSetBalance"] = "Установить баланс",
    ["gangSetBalanceQuery"] = "Каким должен быть новый баланс банды?",
    ["gangSetBalanceMsg"] = "Успешно установлен баланс банды с %s на %s!",
    ["gangAddBalance"] = "Добавить баланс",
    ["gangAddBalanceQuery"] = "Сколько денег вы хотели бы добавить на баланс банды?",
    ["gangAddBalanceMsg"] = "Успешно добавлено %s баланс для банды %s!",
    ["gangViewMembers"] = "Просмотр участников",
    ["gangCantKickOwner"] = "Вы не можете выгнать владельца банды!",
    ["gangKickSuccessAdmin"] = "Успешно выгнали участника из банды!",
    ["gangKickFailAdmin"] = "Не удалось выгнать участника из банды!",
    ["gangSetRankSuccessAdmin"] = "Успешно установить ранг участника!",
    ["gangSetRankFailAdmin"] = "Не удалось установить ранг участника!",
    ["gangMemberAlreadyOwner"] = "Этот участник уже является владельцем этой банды!",
    ["gangNotMember"] = "Этот игрок не является участником этой банды!",
    ["gangOwnershipTransferedAdmin"] = "Успешно переданы права на банду!",
    ["gangDeleteAdminQuery"] = "Удаление банды не может быть отменено, введите %s дабы удалить.",
    ["gangDeleteSuccessAdmin"] = "Успешно удалили банду %s!",
    ["gangMenuBind"] = "Хоткей(Бинд) для меню банды",
} )
--PATH addons/____bricks_framework/lua/bricks_server/languages/bricks_server/turkish.lua:
BRICKS_SERVER.Func.AddLanguageStrings( "turkish", {
    ["search"] = "Ara",
    ["invalidPlayerProfile"] = "Geçersiz oyuncu profili aratıldı!",
    ["unbound"] = "SERBEST",
    ["themes"] = "TEMALAR",
    ["groups"] = "GrUPLAR",
    ["general"] = "Genel",
    ["itemWhitelisting"] = "Eşya Beyaz Listeleme",
    ["rarities"] = "Enderlikler",
    ["languages"] = "Diller",
    ["disabled"] = "Deaktif",
    ["enabled"] = "Aktif",
    ["purchase"] = "Satın Al",
    ["profile"] = "Profil",
    ["view"] = "Görüntüle",
    ["admin"] = "Admin",
    ["noToolPermission"] = "Bu aleti kullanmaya yetkiniz yok.",
    ["settings"] = "Ayarlar",
    ["players"] = "Oyuncular",
    ["modules"] = "Modüller",

    ["userGroupEditor"] = "Kullanıcı Grup Düzenleyicisi",
    ["addNewGroup"] = "Yeni grup ekle",
    ["newUserGroup"] = "Yeni kullanıcı grubu ne olsun?",
    ["groupName"] = "GrupAdı",

    ["custom"] = "Özel",
    ["addNew"] = "Yeni ekle",
    ["material"] = "Materyal",
    ["directImage"] = "Aşağıya resim URL'si yerleştirin.",
    ["default"] = "Varsayılan",
    ["selectMaterial"] = "Bir materyal seçmen lazım!",

    ["errorNoText"] = "HATA: METİN YOK",
    ["selectOption"] = "Bir ayar seçin",
    ["selectValue"] = "Bir değer seçin.",
    ["selectColor"] = "Bir renk seçin.",
    ["configSaved"] = "Konfig kaydedildi!",
    ["cmdNoPermission"] = "Bu komutu kullanmaya iznin yok.",
    ["entityPosUpdated"] = "Varlık pozisyonları kaydedildi.",
    ["noEntitiesSpawned"] = "Kaydedilmiş hiçbir varlık çıkartılmadı.",
    ["xEntitiesSpawned"] = "%d çıkartılan varlıkları kaydetti.",
    ["error"] = "Hata",

    ["seconds"] = "%d saniye",
    ["second"] = "%d saniye",
    ["minutes"] = "%d dakika",
    ["minute"] = "%d dakika",
    ["hours"] = "%d saat",
    ["hour"] = "%d saat",

    ["noRarity"] = "Nadir değil",

    ["config"] = "Konfig",
    ["edit"] = "Düzenle",
    ["editColor"] = "Rengi Düzenle",
    ["editName"] = "İsim Düzenle",
    ["remove"] = "Kaldır",
    ["name"] = "İsim",
    ["description"] = "Açıklama",
    ["model"] = "Model",
    ["icon"] = "İkon",
    ["type"] = "Tür",
    ["price"] = "Ücret",
    ["group"] = "Grup",
    ["category"] = "Kategori",
    ["color"] = "Renk",
    ["invalidType"] = "Geçersiz tür.",
    ["invalidOption"] = "Geçersiz ayar.",
    ["invalidChoice"] = "Geçersiz seçenek.",
    ["invalidGroup"] = "Geçersiz grup.",
    ["invalidPlayer"] = "Geçersiz oyuncu.",
    ["true"] = "DOĞRU",
    ["false"] = "YANLIŞ",
    ["noDescription"] = "Açıklama bulunmamakta",
    ["other"] = "Diğer",
    ["completed"] = "Tamamlandı",
    ["close"] = "Kapat",
    ["main"] = "Ana Sayfa",
    
    ["valueQuery"] = "%s ne olmalı?",
    ["dataValueQuery"] = "Bu hangi veri olmalı?",
    ["newNameQuery"] = "Yeni isim ne olsun?",
    ["newDescriptionQuery"] = "Yeni açıklama ne olsun?",
    ["newModelQuery"] = "Yeni model ne olsun?",
    ["newIconQuery"] = "Yeni ikon ne olsun?",
    ["newColorQuery"] = "Yeni renk ne olsun?",
    ["npcTypeQuery"] = "Bu NPC ne tür olsn?",
    ["newTypeQuery"] = "Yeni tür ne olsun",
    ["groupRequirementQuery"] = "Grup gereksinimleri ne olsun?",
    ["levelRequirementQuery"] = "Seviye gereksinimleri ne olsun?",
    ["newPriceQuery"] = "Yeni ücreti ne olsun?",
    ["newCategoryQuery"] = "Yeni kategori ne olsun?",
    ["npcType"] = "NPC Türü",

    ["npcEditor"] = "NPC Düzenleyicisi",
    ["addNPC"] = "NPC Ekle",
    ["newNPC"] = "Yeni NPC",

    ["ok"] = "TAMAM",
    ["cancel"] = "İptal",
    ["save"] = "Kaydet",
    ["confirm"] = "Onayla",
    ["nil"] = "NIL",
    ["none"] = "Yok",
    ["selected"] = "Seçilmiş",
    ["unselected"] = "Seçilmemiş",
    ["add"] = "Ekle",

    ["shootyStick"] = "Bir sopa!",
    ["permanent"] = "Kalıcı",
    ["tierX"] = "(Aşama %d)",
    ["someDescription"] = "Açıklama.",
    ["invalidNPC"] = "BRICKS SUNUCU HATASI: Geçersiz NPC",

    ["disconnected"] = "Bağlantı Kesildi",
    ["profileView"] = "Profili Görüntüle",
    ["loading"] = "Yükleniyor",
    ["statistics"] = "İstatistikler",
    ["steamID64"] = "SteamID64",
    ["donationRank"] = "Bağışçı Rütbesi",
    ["staffRank"] = "Yetkili Rütbesi",
    ["currentJob"] = "Şu anki Meslek",
    ["wallet"] = "Cüzdan",
    ["level"] = "Seviye",
    ["levelX"] = "Seviye %d",
    ["experience"] = "Tecrübe",
    ["exp"] = "TP",
    ["money"] = "Para",
    ["playerLogs"] = "Oyuncu Kayıtları",
    ["deleteLogs"] = "Kayıtları sil",
    ["xLogs"] = "%d'nın kayıtları",
    ["xAdminGroups"] = "%d Admin Grupları",
    ["noUserGroups"] = "Hiçbir kullanıcı grubu bulunamadı",
    ["userGroups"] = "Kullanıcı Grubu: %s",
    ["editUserGroups"] = "Kullanıcı Kruplarını Düzenle",
    ["newGroupColor"] = "Yeni grup rengi ne olsun?",
    ["newGroupName"] = "Yeni grup ismi ne olsun?",
    ["groupAlreadyExists"] = "Bu grup zaten bulunmakta!",
    ["whitelist"] = "Beyaz Liste",
    ["unWhitelist"] = "Beyaz Listeden Çıkar",
    ["addCustom"] = "Özel Ekle",
    ["entClassWhitelist"] = "Hangi varlık sınıfını beyaz listeye almak istiyorsun?",
    ["entClassAlreadyOnList"] = "Bu valrık sınıfı zaten beyaz listede!",
    ["changesServerRestart"] = "Sunucu tekrardan başlatılıncaya kadar değişimler uygulanmayacak!",
    ["comingSoon"] = "Çok Yakında!",
    ["features"] = "OZELLIKLER",
    ["addNewRarity"] = "Yeni bir enderlik ekle",
    ["newRarity"] = "Yeni Enderlik",
    ["needToAddRarity"] = "İlk başta enderlik türü eklemen lazım!",
    ["whatRarityItem"] = "Bu eşya hangi enderlikte olsun?",
    ["invalidRarity"] = "Geçersiz Enderlik.",
    ["rarityAlreadyExists"] = "Bu isime sahip bir enderlik bulunmakta!",
    ["themeColorX"] = "Tema - Renk %d",
    ["themeTextColor"] = "Tema - Yazı Rengi",
    ["presetAccents"] = "Önceden Ayarlanmış Aksanlar",
    ["presetBackgrounds"] = "Önceden Ayarlanmış Arka Planlar",
    ["resetToBaseThemes"] = "Ana temaları sıfırla",
    ["resetToCurrentThemes"] = "Şimdiki temaları sıfırla",
    ["toggle"] = "Toggle",
    ["menu"] = "Menü",
    ["emptyValue"] = "BOŞ DEĞER",
    ["newValueQuery"] = "Yeni değer ne olsun?",
    ["pressKey"] = "BİR TUŞA BAS",

    ["entityPlacer"] = "Varlık Yerleştiricisi",
    ["invalidEntityType"] = "Geçersiz varlık türü, aletler menüsünden geçerli bir tür seç.",
    ["entityPlaced"] = "Varlık başarıyla yerleştirildi.",
    ["entityRemoved"] = "Varlık başarıyla kaldırıldı.",
    ["canOnlyUseToolEntity"] = "Bu alet sadece bir varlığı kaldırıp/oluşturmak için kullanabilirsin.",
    ["entityType"] = "Varlık Türü",
    ["entityPlacerDescription"] = "Sunucuya varlık yerleştirip kaldırmanı sağlar. Sol Tık - yerleştir. Sağ Tık - kaldır.",
    ["entityPlacerDescriptionSmall"] = "Varlıkları yerleştirip kaldırır",
    ["entityPlacerInstructions"] = "Sol Tık - yerleştir, Sağ Tık - kaldır.",

    ["npcPlacer"] = "NPC Yerleştiricisi",
    ["npcPlaced"] = "NPC başarıyla yerleştirildi.",
    ["invalidNPCType"] = "Geçersiz NPC türü, aletler menüsünden geçerli bir alet seçin.",
    ["npcRemoved"] = "NPC kaldırıldı.",
    ["errorNotNPC"] = "Bu aleti sadece NPC kaldırıp/oluşturmanı sağlar.",
    ["npcPlacerDescription"] = "PSunucudan NPC kaldırıp yerleştirmeni sağlar, Sol Tık - yerleştir, Sağ Tık - kaldır.",
    ["npcPlacerDescriptionSmall"] = "Sunucudan NPC kaldırıp eklemeni sağlar.",

    ["inventory"] = "Envanter",
    ["player"] = "Oyuncu",
    ["drop"] = "Bırak",
    ["use"] = "Kullan",
    ["dropAll"] = "Hepsini Bırak",
    ["delete"] = "Kaldır",
} )
--PATH addons/____bricks_framework/lua/bricks_server/core/shared/sh_itemtypes.lua:
BRICKS_SERVER.DEVCONFIG.INVENTORY = BRICKS_SERVER.DEVCONFIG.INVENTORY or {}
BRICKS_SERVER.DEVCONFIG.INVENTORY.EntTypes = BRICKS_SERVER.DEVCONFIG.INVENTORY.EntTypes or {}

local itemMeta = {
	Register = function( self )
        BRICKS_SERVER.DEVCONFIG.INVENTORY.EntTypes[self.Class] = self
	end
}

itemMeta.__index = itemMeta

function BRICKS_SERVER.Func.CreateItemType( class )
	local item = {
		Class = class
	}
	
	setmetatable( item, itemMeta )
	
	return item
end

for k, v in pairs( file.Find( "bricks_server/itemtypes/*.lua", "LUA" ) ) do
    AddCSLuaFile( "bricks_server/itemtypes/" .. v )
    include( "bricks_server/itemtypes/" .. v )
end
--PATH addons/____bricks_framework/lua/bricks_server/core/client/cl_config_popups.lua:
function BRICKS_SERVER.Func.CreateGroupEditor( defaultGroups, onSave, onCancel, swap )
	BS_GROUP_EDITOR = vgui.Create( "DFrame" )
	BS_GROUP_EDITOR:SetSize( ScrW(), ScrH() )
	BS_GROUP_EDITOR:Center()
	BS_GROUP_EDITOR:SetTitle( "" )
	BS_GROUP_EDITOR:ShowCloseButton( false )
	BS_GROUP_EDITOR:SetDraggable( false )
	BS_GROUP_EDITOR:MakePopup()
	BS_GROUP_EDITOR:SetAlpha( 0 )
	BS_GROUP_EDITOR:AlphaTo( 255, 0.1, 0 )
	BS_GROUP_EDITOR.Paint = function( self2 ) 
		BRICKS_SERVER.Func.DrawBlur( self2, 4, 4 )
	end

	local backPanel = vgui.Create( "DPanel", BS_GROUP_EDITOR )
	backPanel.Paint = function( self2, w, h ) 
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )
		draw.RoundedBox( 5, 1, 1, w-2, h-2, BRICKS_SERVER.Func.GetTheme( 2 ) )
	end

	local groupsTable = table.Copy( defaultGroups )
	local textArea

	function backPanel.FillGroups()
		backPanel:Clear()

		textArea = vgui.Create( "DPanel", backPanel )
		textArea:Dock( TOP )
		textArea:DockMargin( 10, 10, 10, 0 )
		textArea:SetTall( 30 )
		textArea.Paint = function( self2, w, h ) 
			draw.SimpleText( BRICKS_SERVER.Func.L( "userGroupEditor" ), "BRICKS_SERVER_Font20", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end

		for k, v in pairs( groupsTable ) do
			local actionButtonBack = vgui.Create( "DPanel", backPanel )
			actionButtonBack:Dock( TOP )
			actionButtonBack:DockMargin( 10, 10, 10, 0 )
			actionButtonBack:SetTall( 40 )
			actionButtonBack.Paint = function() end

			local actionButtonDelete = vgui.Create( "DButton", actionButtonBack )
			actionButtonDelete:SetText( "" )
			actionButtonDelete:Dock( RIGHT )
			actionButtonDelete:DockMargin( 5, 0, 0, 0 )
			actionButtonDelete:SetWide( actionButtonBack:GetTall() )
			local changeAlpha = 0
			local deleteMat = Material( "materials/bricks_server/delete.png" )
			actionButtonDelete.Paint = function( self2, w, h )
				if( self2:IsDown() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
				elseif( self2:IsHovered() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
				else
					changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
				end
				
				draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red )
		
				surface.SetAlphaMultiplier( changeAlpha/255 )
					draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed )
				surface.SetAlphaMultiplier( 1 )

				surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
				surface.SetMaterial( deleteMat )
				local iconSize = h*0.65
				surface.DrawTexturedRect( (h-iconSize)*0.5, (h*0.5)-(iconSize*0.5), iconSize, iconSize )
			end
			actionButtonDelete.DoClick = function()
				if( isnumber( k ) ) then
					table.remove( groupsTable, k )
				else
					groupsTable[k] = nil
				end

				backPanel.FillGroups()
			end

			local actionButton = vgui.Create( "DPanel", actionButtonBack )
			actionButton:Dock( FILL )
			actionButton.Paint = function( self2, w, h )
				draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

				draw.SimpleText( ((not swap and v) or k), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			end
		end

		local newGroupButton = vgui.Create( "DButton", backPanel )
		newGroupButton:SetText( "" )
		newGroupButton:Dock( TOP )
		newGroupButton:DockMargin( 10, 10, 10, 0 )
		newGroupButton:SetTall( 40 )
		local changeAlpha = 0
		newGroupButton.Paint = function( self2, w, h )
			if( self2:IsDown() ) then
				changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
			elseif( self2:IsHovered() ) then
				changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
			else
				changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
			end
			
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
	
			surface.SetAlphaMultiplier( changeAlpha/255 )
				draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
			surface.SetAlphaMultiplier( 1 )

			draw.SimpleText( BRICKS_SERVER.Func.L( "addNewGroup" ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		newGroupButton.DoClick = function()
			BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newUserGroup" ), BRICKS_SERVER.Func.L( "groupName" ), function( text ) 
				if( not swap ) then
					table.insert( groupsTable, text )
				else
					groupsTable[text] = true
				end
				backPanel.FillGroups()
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
		end

		local buttonPanel = vgui.Create( "DPanel", backPanel )
		buttonPanel:Dock( BOTTOM )
		buttonPanel:DockMargin( 10, 10, 10, 10 )
		buttonPanel:SetTall( 40 )
		buttonPanel.Paint = function( self2, w, h ) end
	
		local leftButton = vgui.Create( "DButton", buttonPanel )
		leftButton:Dock( LEFT )
		leftButton:SetText( "" )
		leftButton:DockMargin( 0, 0, 0, 0 )
		local changeAlpha = 0
		leftButton.Paint = function( self2, w, h )
			if( self2:IsHovered() ) then
				changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
			else
				changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
			end
			
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.Green )
	
			surface.SetAlphaMultiplier( changeAlpha/255 )
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen )
			surface.SetAlphaMultiplier( 1 )
	
			draw.SimpleText( BRICKS_SERVER.Func.L( "save" ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		leftButton.DoClick = function()
			onSave( groupsTable )
	
			BS_GROUP_EDITOR:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( BS_GROUP_EDITOR ) ) then
					BS_GROUP_EDITOR:Remove()
				end
			end )
		end
	
		local rightButton = vgui.Create( "DButton", buttonPanel )
		rightButton:Dock( RIGHT )
		rightButton:SetText( "" )
		rightButton:DockMargin( 0, 0, 0, 0 )
		local changeAlpha = 0
		rightButton.Paint = function( self2, w, h )
			if( self2:IsHovered() ) then
				changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
			else
				changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
			end
			
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red )
	
			surface.SetAlphaMultiplier( changeAlpha/255 )
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed )
			surface.SetAlphaMultiplier( 1 )
	
			draw.SimpleText( BRICKS_SERVER.Func.L( "cancel" ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		rightButton.DoClick = function()
			onCancel()
	
			BS_GROUP_EDITOR:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( BS_GROUP_EDITOR ) ) then
					BS_GROUP_EDITOR:Remove()
				end
			end )
		end
	
		backPanel:SetSize( (2*10)+(2*150)+80, buttonPanel:GetTall()+(5*10)+textArea:GetTall()+((table.Count( groupsTable ) or 10)*50)+newGroupButton:GetTall() )
		backPanel:Center()
	
		leftButton:SetWide( (backPanel:GetWide()-30)*0.5 )
		rightButton:SetWide( (backPanel:GetWide()-30)*0.5 )
	end
	backPanel.FillGroups()
end

function BRICKS_SERVER.Func.CreateTeamSelector( defaultTable, subtitle, saveFunc )
	local frameBack = vgui.Create( "DFrame" )
	frameBack:SetSize( ScrW(), ScrH() )
	frameBack:Center()
	frameBack:SetTitle( "" )
	frameBack:ShowCloseButton( false )
	frameBack:SetDraggable( false )
	frameBack:MakePopup()
	frameBack:SetAlpha( 0 )
	frameBack:AlphaTo( 255, 0.1, 0 )
	frameBack.Paint = function( self2 ) 
		BRICKS_SERVER.Func.DrawBlur( self2, 4, 4 )
	end

	local teamsTableCopy = table.Copy( defaultTable )

	local backPanel = vgui.Create( "DPanel", frameBack )
	backPanel:SetSize( ScrW()*0.4, 0 )
	backPanel.Paint = function( self2, w, h ) 
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )
		draw.RoundedBox( 5, 1, 1, w-2, h-2, BRICKS_SERVER.Func.GetTheme( 2 ) )
	end

	local textArea = vgui.Create( "DPanel", backPanel )
	textArea:Dock( TOP )
	textArea:DockMargin( 10, 10, 10, 0 )
	textArea:SetTall( 30 )
	textArea.Paint = function( self2, w, h ) 
		draw.SimpleText( subtitle, "BRICKS_SERVER_Font20", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local chooserBack = vgui.Create( "bricks_server_scrollpanel", backPanel )
	chooserBack:Dock( TOP )
	chooserBack:DockMargin( 10, 10, 10, 0 )
	chooserBack:SetTall( ScrH()*0.4 )
	chooserBack.Paint = function() end
	
	local spacing = 5
	local gridWide = backPanel:GetWide()-20
    local wantedSlotSize = 135
    local slotsWide = math.floor( gridWide/wantedSlotSize )
	local slotSize = (gridWide-((slotsWide-1)*spacing))/slotsWide

	local chooserLayout = vgui.Create( "DIconLayout", chooserBack )
    chooserLayout:Dock( FILL )
    chooserLayout:SetSpaceY( spacing )
	chooserLayout:SetSpaceX( spacing )
	
	function backPanel.RefreshTeams()
		chooserLayout:Clear()
		
		for k, v in pairs( RPExtraTeams ) do
			local materialEntry = chooserLayout:Add( "DButton" )
			materialEntry:SetSize( slotSize, slotSize )
			materialEntry:SetText( "" )
			local changeAlpha = 0
			local name = util.CRC( k )
			local icon
			materialEntry.Paint = function( self2, w, h )
				if( teamsTableCopy[v.command] ) then
					draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
				else
					draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
				end

				if( icon:IsDown() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 150 )
				elseif( icon:IsHovered() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 95 )
				else
					changeAlpha = math.Clamp( changeAlpha-10, 0, 95 )
				end

				surface.SetAlphaMultiplier( changeAlpha/255 )
				draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
				surface.SetAlphaMultiplier( 1 )

				if( string.len( v.name ) > 16 ) then
					draw.SimpleText( string.sub( v.name, 1, 16 ) .. "...", "BRICKS_SERVER_Font20", w*0.5, h-5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
				else
					draw.SimpleText( v.name, "BRICKS_SERVER_Font20", w*0.5, h-5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
				end
			end

			icon = vgui.Create( "DModelPanel", materialEntry )
			icon:Dock( FILL )
			icon:DockMargin( 0, 0, 0, 30 )
			if( istable( v.model ) ) then
				icon:SetModel( v.model[1] )
			else
				icon:SetModel( v.model )
			end
			function icon:LayoutEntity( Entity ) return end

			icon.DoClick = function()
				if( teamsTableCopy[v.command] ) then
					teamsTableCopy[v.command] = nil
				else
					teamsTableCopy[v.command] = true
				end
			end
		end

		chooserLayout:PerformLayout()
		chooserBack:Rebuild()
	end
	backPanel.RefreshTeams()

	local buttonPanel = vgui.Create( "DPanel", backPanel )
	buttonPanel:Dock( BOTTOM )
	buttonPanel:DockMargin( 10, 0, 10, 10 )
	buttonPanel:SetTall( 40 )
	buttonPanel.Paint = function( self2, w, h ) end

	local leftButton = vgui.Create( "DButton", buttonPanel )
	leftButton:Dock( LEFT )
	leftButton:SetText( "" )
	leftButton:DockMargin( 0, 0, 0, 0 )
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( BRICKS_SERVER.Func.L( "confirm" ) )
	textX = textX+20
	leftButton:SetWide( math.max( (ScrW()/2560)*150, textX ) )
	local changeAlpha = 0
	leftButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( BRICKS_SERVER.Func.L( "confirm" ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	leftButton.DoClick = function()
		saveFunc( teamsTableCopy )
		frameBack:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( frameBack ) ) then
				frameBack:Remove()
			end
		end )
	end

	local rightButton = vgui.Create( "DButton", buttonPanel )
	rightButton:Dock( RIGHT )
	rightButton:SetText( "" )
	rightButton:DockMargin( 0, 0, 0, 0 )
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( BRICKS_SERVER.Func.L( "cancel" ) )
	textX = textX+20
	rightButton:SetWide( math.max( (ScrW()/2560)*150, textX ) )
	local changeAlpha = 0
	rightButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( BRICKS_SERVER.Func.L( "cancel" ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	rightButton.DoClick = function()
		frameBack:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( frameBack ) ) then
				frameBack:Remove()
			end
		end )
	end

	backPanel:SetSize( backPanel:GetWide(), buttonPanel:GetTall()+(4*10)+textArea:GetTall()+chooserBack:GetTall()+10 )
	backPanel:Center()
end

function BRICKS_SERVER.Func.CreateShipmentSelector( defaultTable, subtitle, saveFunc )
	local frameBack = vgui.Create( "DFrame" )
	frameBack:SetSize( ScrW(), ScrH() )
	frameBack:Center()
	frameBack:SetTitle( "" )
	frameBack:ShowCloseButton( false )
	frameBack:SetDraggable( false )
	frameBack:MakePopup()
	frameBack:SetAlpha( 0 )
	frameBack:AlphaTo( 255, 0.1, 0 )
	frameBack.Paint = function( self2 ) 
		BRICKS_SERVER.Func.DrawBlur( self2, 4, 4 )
	end

	local shipmentsTableCopy = table.Copy( defaultTable )

	for k, v in pairs( shipmentsTableCopy ) do
		local found, foundKey = DarkRP.getShipmentByName( k )

		if( not found ) then
			shipmentsTableCopy[k] = nil
		end
	end

	local backPanel = vgui.Create( "DPanel", frameBack )
	backPanel:SetSize( ScrW()*0.4, 0 )
	backPanel.Paint = function( self2, w, h ) 
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )
		draw.RoundedBox( 5, 1, 1, w-2, h-2, BRICKS_SERVER.Func.GetTheme( 2 ) )
	end

	local textArea = vgui.Create( "DPanel", backPanel )
	textArea:Dock( TOP )
	textArea:DockMargin( 10, 10, 10, 0 )
	textArea:SetTall( 30 )
	textArea.Paint = function( self2, w, h ) 
		draw.SimpleText( subtitle, "BRICKS_SERVER_Font20", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local chooserBack = vgui.Create( "bricks_server_scrollpanel", backPanel )
	chooserBack:Dock( TOP )
	chooserBack:DockMargin( 10, 10, 10, 0 )
	chooserBack:SetTall( ScrH()*0.4 )
	chooserBack.Paint = function() end
	
	local spacing = 5
	local gridWide = backPanel:GetWide()-20
    local wantedSlotSize = 135
    local slotsWide = math.floor( gridWide/wantedSlotSize )
	local slotSize = (gridWide-((slotsWide-1)*spacing))/slotsWide

	local chooserLayout = vgui.Create( "DIconLayout", chooserBack )
    chooserLayout:Dock( FILL )
    chooserLayout:SetSpaceY( spacing )
	chooserLayout:SetSpaceX( spacing )
	
	function backPanel.RefreshTeams()
		chooserLayout:Clear()
		
		for k, v in pairs( CustomShipments ) do
			local materialEntry = chooserLayout:Add( "DButton" )
			materialEntry:SetSize( slotSize, slotSize )
			materialEntry:SetText( "" )
			local changeAlpha = 0
			local name = util.CRC( k )
			local icon
			materialEntry.Paint = function( self2, w, h )
				if( shipmentsTableCopy[v.name] ) then
					draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
				else
					draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
				end

				if( icon:IsDown() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 150 )
				elseif( icon:IsHovered() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 95 )
				else
					changeAlpha = math.Clamp( changeAlpha-10, 0, 95 )
				end

				surface.SetAlphaMultiplier( changeAlpha/255 )
				draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
				surface.SetAlphaMultiplier( 1 )

				if( string.len( v.name ) > 16 ) then
					draw.SimpleText( string.sub( v.name, 1, 16 ) .. "...", "BRICKS_SERVER_Font20", w*0.5, h-5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
				else
					draw.SimpleText( v.name, "BRICKS_SERVER_Font20", w*0.5, h-5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
				end
			end

			icon = vgui.Create( "DModelPanel", materialEntry )
			icon:Dock( FILL )
			icon:SetModel( v.model )
			if( IsValid( icon.Entity ) ) then
				function icon:LayoutEntity( Entity ) return end
				local mn, mx = icon.Entity:GetRenderBounds()
				local size = 0
				size = math.max( size, math.abs(mn.x) + math.abs(mx.x) )
				size = math.max( size, math.abs(mn.y) + math.abs(mx.y) )
				size = math.max( size, math.abs(mn.z) + math.abs(mx.z) )
		
				icon:SetFOV( 70 )
				icon:SetCamPos( Vector( size, size, size ) )
				icon:SetLookAt( (mn + mx) * 0.5 )
			end

			icon.DoClick = function()
				if( shipmentsTableCopy[v.name] ) then
					shipmentsTableCopy[v.name] = nil
				else
					shipmentsTableCopy[v.name] = true
				end
			end
		end

		chooserLayout:PerformLayout()
		chooserBack:Rebuild()
	end
	backPanel.RefreshTeams()

	local buttonPanel = vgui.Create( "DPanel", backPanel )
	buttonPanel:Dock( BOTTOM )
	buttonPanel:DockMargin( 10, 0, 10, 10 )
	buttonPanel:SetTall( 40 )
	buttonPanel.Paint = function( self2, w, h ) end

	local leftButton = vgui.Create( "DButton", buttonPanel )
	leftButton:Dock( LEFT )
	leftButton:SetText( "" )
	leftButton:DockMargin( 0, 0, 0, 0 )
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( BRICKS_SERVER.Func.L( "confirm" ) )
	textX = textX+20
	leftButton:SetWide( math.max( (ScrW()/2560)*150, textX ) )
	local changeAlpha = 0
	leftButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( BRICKS_SERVER.Func.L( "confirm" ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	leftButton.DoClick = function()
		saveFunc( shipmentsTableCopy )
		frameBack:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( frameBack ) ) then
				frameBack:Remove()
			end
		end )
	end

	local rightButton = vgui.Create( "DButton", buttonPanel )
	rightButton:Dock( RIGHT )
	rightButton:SetText( "" )
	rightButton:DockMargin( 0, 0, 0, 0 )
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( BRICKS_SERVER.Func.L( "cancel" ) )
	textX = textX+20
	rightButton:SetWide( math.max( (ScrW()/2560)*150, textX ) )
	local changeAlpha = 0
	rightButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( BRICKS_SERVER.Func.L( "cancel" ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	rightButton.DoClick = function()
		frameBack:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( frameBack ) ) then
				frameBack:Remove()
			end
		end )
	end

	backPanel:SetSize( backPanel:GetWide(), buttonPanel:GetTall()+(4*10)+textArea:GetTall()+chooserBack:GetTall()+10 )
	backPanel:Center()
end

function BRICKS_SERVER.Func.MaterialRequest( title, subtitle, default, func_confirm, func_cancel, confirmText, cancelText )
	local frameBack = vgui.Create( "DFrame" )
	frameBack:SetSize( ScrW(), ScrH() )
	frameBack:Center()
	frameBack:SetTitle( "" )
	frameBack:ShowCloseButton( false )
	frameBack:SetDraggable( false )
	frameBack:MakePopup()
	frameBack:SetAlpha( 0 )
	frameBack:AlphaTo( 255, 0.1, 0 )
	frameBack.Paint = function( self2, w, h ) 
		BRICKS_SERVER.Func.DrawBlur( self2, 4, 4 )

		surface.SetDrawColor( 0, 0, 0, 100 )
		surface.DrawRect( 0, 0, w, h )
	end

	surface.SetFont( "BRICKS_SERVER_Font20" )
	local textX, textY = surface.GetTextSize( subtitle )

	local backPanel = vgui.Create( "bricks_server_dframepanel", frameBack )
	backPanel:SetHeader( title )
	backPanel:SetWide( math.max( ScrW()*0.4, textX+30 ) )
	backPanel.onCloseFunc = function()
		frameBack:Remove()
	end

	local textArea = vgui.Create( "DPanel", backPanel )
	textArea:Dock( TOP )
	textArea:DockMargin( 10, 10, 10, 0 )
	textArea:SetTall( 30 )
	textArea.Paint = function( self2, w, h ) 
		draw.SimpleText( subtitle, "BRICKS_SERVER_Font20", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local chooserBack = vgui.Create( "DPanel", backPanel )
	chooserBack:Dock( TOP )
	chooserBack:DockMargin( 10, 10, 10, 0 )
	chooserBack:SetTall( ScrH()*0.4 )
	chooserBack.Paint = function() end

	local materialsScroll = vgui.Create( "bricks_server_scrollpanel", chooserBack )
	materialsScroll:Dock( FILL )
	materialsScroll.Paint = function( self2, w, h ) end
	
	local spacing = 5
	local gridWide = backPanel:GetWide()-20
    local wantedSlotSize = 100
    local slotsWide = math.floor( gridWide/wantedSlotSize )
	local slotSize = (gridWide-((slotsWide-1)*spacing))/slotsWide

	local materialsGridCustom = vgui.Create( "DIconLayout", materialsScroll )
    materialsGridCustom:Dock( TOP )
    materialsGridCustom:DockMargin( 0, 0, 0, 0 )
    materialsGridCustom:SetSpaceY( spacing )
	materialsGridCustom:SetSpaceX( spacing )
	
	local materialsGridDefault = vgui.Create( "DIconLayout", materialsScroll )
    materialsGridDefault:Dock( TOP )
    materialsGridDefault:SetSpaceY( spacing )
	materialsGridDefault:SetSpaceX( spacing )
	
	local selected = default
	function backPanel.RefreshMaterials( time )
		local defaultMaterials = {}
		local customMaterials = {}

		materialsGridCustom:Clear()
		materialsGridDefault:Clear()

		for k, v in pairs( BRICKS_SERVER.CachedMaterials ) do
			if( string.StartWith( k, "http" ) ) then
				table.insert( customMaterials, { v, k } )
			else
				table.insert( defaultMaterials, { v, k } )
			end
		end

		table.SortByMember( defaultMaterials, 2, true )

		local materialCustomHeader = materialsGridCustom:Add( "DPanel" )
		materialCustomHeader:SetSize( gridWide-20, 40 )
		materialCustomHeader.Paint = function( self2, w, h )
			draw.SimpleText( BRICKS_SERVER.Func.L( "custom" ), "BRICKS_SERVER_Font25", 0, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
		end

		for k, v in pairs( customMaterials ) do
			local materialEntry = materialsGridCustom:Add( "DButton" )
			materialEntry:SetSize( slotSize, slotSize )
			materialEntry:SetText( "" )
			local changeAlpha = 0
			local name = util.CRC( v[2] )
			materialEntry.Paint = function( self2, w, h )
				if( selected == v[2] ) then
					draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
				else
					draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
				end

				if( self2:IsDown() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 150 )
				elseif( self2:IsHovered() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 95 )
				else
					changeAlpha = math.Clamp( changeAlpha-10, 0, 95 )
				end

				surface.SetAlphaMultiplier( changeAlpha/255 )
				draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
				surface.SetAlphaMultiplier( 1 )

				if( BRICKS_SERVER.CachedMaterials[v[2]] ) then
					surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
					surface.SetMaterial( BRICKS_SERVER.CachedMaterials[v[2]] )
					local iconSize = h*0.5
					surface.DrawTexturedRect( (h-iconSize)*0.5, (h*0.5)-(iconSize*0.5), iconSize, iconSize )
				end

				draw.SimpleText( name, "BRICKS_SERVER_Font17", w*0.5, h-5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			end
			materialEntry.DoClick = function()
				selected = v[2]
			end
		end

		local customMaterialNew = materialsGridCustom:Add( "DButton" )
		customMaterialNew:SetSize( slotSize, slotSize )
		customMaterialNew:SetText( "" )
		local changeAlpha = 0
		local newMat = Material( "materials/bricks_server/add.png")
		customMaterialNew.Paint = function( self2, w, h )
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

			if( self2:IsDown() ) then
				changeAlpha = math.Clamp( changeAlpha+10, 0, 150 )
			elseif( self2:IsHovered() ) then
				changeAlpha = math.Clamp( changeAlpha+10, 0, 95 )
			else
				changeAlpha = math.Clamp( changeAlpha-10, 0, 95 )
			end

			surface.SetAlphaMultiplier( changeAlpha/255 )
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
			surface.SetAlphaMultiplier( 1 )

			if( newMat ) then
				surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
				surface.SetMaterial( newMat )
				local iconSize = 32
				surface.DrawTexturedRect( (h-iconSize)*0.5, (h*0.5)-(iconSize*0.5), iconSize, iconSize )
			end

			draw.SimpleText( BRICKS_SERVER.Func.L( "addNew" ), "BRICKS_SERVER_Font17", w*0.5, h-5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
		end
		customMaterialNew.DoClick = function()
			BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "material" ), BRICKS_SERVER.Func.L( "directImage" ), "https://i.imgur.com/XBwi3Nh.png", function( text ) 
				selected = text
				BRICKS_SERVER.Func.CacheImageFromURL( text, function() backPanel.RefreshMaterials() end )
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
		end

		local materialDefaultHeader = materialsGridDefault:Add( "DPanel" )
		materialDefaultHeader:SetSize( gridWide-20, 40 )
		materialDefaultHeader.Paint = function( self2, w, h )
			draw.SimpleText( BRICKS_SERVER.Func.L( "default" ), "BRICKS_SERVER_Font25", 0, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
		end

		for k, v in pairs( defaultMaterials ) do
			local materialEntry = materialsGridDefault:Add( "DButton" )
			materialEntry:SetSize( slotSize, slotSize )
			materialEntry:SetText( "" )
			local changeAlpha = 0
			materialEntry.Paint = function( self2, w, h )
				if( selected == v[2] ) then
					draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
				else
					draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
				end
				if( self2:IsDown() ) then
					changeAlpha = math.Clamp( changeAlpha-10, 0, 95 )
				elseif( self2:IsHovered() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 95 )
				else
					changeAlpha = math.Clamp( changeAlpha-10, 0, 95 )
				end

				surface.SetAlphaMultiplier( changeAlpha/255 )
				draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
				surface.SetAlphaMultiplier( 1 )

				if( BRICKS_SERVER.CachedMaterials[v[2]] ) then
					surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
					surface.SetMaterial( BRICKS_SERVER.CachedMaterials[v[2]] )
					local iconSize = h*0.5
					surface.DrawTexturedRect( (h-iconSize)*0.5, (h*0.5)-(iconSize*0.5), iconSize, iconSize )
				end

				draw.SimpleText( string.Replace( v[2], ".png", "" ), "BRICKS_SERVER_Font17", w*0.5, h-5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
			end
			materialEntry.DoClick = function()
				selected = v[2]
			end
		end

		materialsGridCustom:SetTall( (math.ceil((#customMaterials+1)/slotsWide)*slotSize)+((math.ceil((#customMaterials+1)/slotsWide)-1)*spacing)+45 )
		materialsGridDefault:SetTall( (math.ceil(#defaultMaterials/slotsWide)*slotSize)+((math.ceil(#defaultMaterials/slotsWide)-1)*spacing)+45 )

		materialsGridCustom:PerformLayout()
		materialsGridDefault:PerformLayout()
		materialsScroll:Rebuild()
	end
	backPanel.RefreshMaterials()

	local buttonPanel = vgui.Create( "DPanel", backPanel )
	buttonPanel:Dock( BOTTOM )
	buttonPanel:DockMargin( 10, 0, 10, 10 )
	buttonPanel:SetTall( 40 )
	buttonPanel.Paint = function( self2, w, h ) end

	local leftButton = vgui.Create( "DButton", buttonPanel )
	leftButton:Dock( LEFT )
	leftButton:SetText( "" )
	leftButton:DockMargin( 0, 0, 0, 0 )
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( confirmText )
	textX = textX+20
	leftButton:SetWide( math.max( (ScrW()/2560)*150, textX ) )
	local changeAlpha = 0
	leftButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( confirmText, "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	leftButton.DoClick = function()
		if( BRICKS_SERVER.CachedMaterials[selected] ) then
			func_confirm( selected )
			frameBack:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( frameBack ) ) then
					frameBack:Remove()
				end
			end )
		else
			notification.AddLegacy( BRICKS_SERVER.Func.L( "selectMaterial" ), 1, 3 )
		end
	end

	local rightButton = vgui.Create( "DButton", buttonPanel )
	rightButton:Dock( RIGHT )
	rightButton:SetText( "" )
	rightButton:DockMargin( 0, 0, 0, 0 )
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( cancelText )
	textX = textX+20
	rightButton:SetWide( math.max( (ScrW()/2560)*150, textX ) )
	local changeAlpha = 0
	rightButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( cancelText, "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	rightButton.DoClick = function()
		func_cancel( selected )
		frameBack:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( frameBack ) ) then
				frameBack:Remove()
			end
		end )
	end

	backPanel:SetTall( buttonPanel:GetTall()+(4*10)+textArea:GetTall()+chooserBack:GetTall()+10+backPanel.headerHeight )
	backPanel:Center()
end
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_config_general.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel()
    function self.RefreshPanel()
        self:Clear()

        self.slots = nil
        if( self.grid and IsValid( self.grid ) ) then
            self.grid:Remove()
        end

        BRICKS_SERVER.Func.FillVariableConfigs( self, "GENERAL", "GENERAL", { ["Admin Permissions"] = { function()
            BRICKS_SERVER.Func.CreateGroupEditor( (BS_ConfigCopyTable.GENERAL.AdminPermissions or {}), function( userGroups ) 
                BS_ConfigCopyTable.GENERAL.AdminPermissions = userGroups or {}
                self.RefreshPanel()
                BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
            end, function() end, true )
        end, BRICKS_SERVER.Func.L( "xAdminGroups", table.Count( BS_ConfigCopyTable.GENERAL.AdminPermissions or {} ) ) } } )
    end
    self.RefreshPanel()
end

function PANEL:Paint( w, h )
    
end

vgui.Register( "bricks_server_config_general", PANEL, "bricks_server_scrollpanel" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_config_itemrarities.lua:
local PANEL = {}

function PANEL:Init()
    self.margin = 0
end

function PANEL:FillPanel()
    self.panelWide, self.panelTall = ScrW()*0.6-BRICKS_SERVER.DEVCONFIG.MainNavWidth, ScrH()*0.65-40

    self.topBar = vgui.Create( "DPanel", self )
    self.topBar:Dock( TOP )
    self.topBar:SetTall( 60 )
    self.topBar.Paint = function( self, w, h ) 
        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
        surface.DrawRect( 0, 0, w, h )
    end 

    self.searchBar = vgui.Create( "bricks_server_searchbar", self.topBar )
    self.searchBar:Dock( LEFT )
    self.searchBar:DockMargin( 25, 10, 10, 10 )
    self.searchBar:SetWide( ScrW()*0.2 )
    self.searchBar:SetBackColor( BRICKS_SERVER.Func.GetTheme( 1 ) )
    self.searchBar:SetHighlightColor( BRICKS_SERVER.Func.GetTheme( 0 ) )
    self.searchBar.OnChange = function()
        self:Refresh()
    end

    self.scrollPanel = vgui.Create( "bricks_server_scrollpanel_bar", self )
    self.scrollPanel:Dock( FILL )
    self.scrollPanel:DockMargin( 25, 25, 25, 25 )
    self.scrollPanel.Paint = function( self, w, h ) end 

    self.spacing = 5
    local gridWide = self.panelWide-50-10-self.spacing
    local wantedSlotSize = 125*(ScrW()/2560)
    self.slotsWide = math.floor( gridWide/wantedSlotSize )
    self.slotSize = (gridWide-((self.slotsWide-1)*self.spacing))/self.slotsWide

    self.grid = vgui.Create( "DIconLayout", self.scrollPanel )
    self.grid:Dock( TOP )
    self.grid:SetSpaceY( self.spacing )
    self.grid:SetSpaceX( self.spacing )

    self:Refresh()
end

function PANEL:Refresh()
    self.grid:Clear()

    local sortedItems = {}
    local rarityItems = BRICKS_SERVER.Func.GetRarityItems() or {}
    for k, v in pairs( rarityItems ) do
        if( self.searchBar:GetValue() != "" and not string.find( string.lower( v[1] or "" ), string.lower( self.searchBar:GetValue() ) ) ) then
            continue
        end

        local rarityInfo, rarityKey = {}, 0
        if( BS_ConfigCopyTable.INVENTORY.ItemRarities[k] ) then
            rarityInfo, rarityKey = BRICKS_SERVER.Func.GetRarityInfo( BS_ConfigCopyTable.INVENTORY.ItemRarities[k] )
        end

        local itemTable = table.Copy( v )
        itemTable.Key = k
        itemTable.Rarity = rarityKey or 0
        itemTable.RarityInfo = rarityInfo

        table.insert( sortedItems, itemTable )
    end

    table.sort( sortedItems, function( a, b ) return ((a or {}).Rarity or 0) > ((b or {}).Rarity or 0) end )

    local loadingIcon = Material( "materials/bricks_server/loading.png" )

    local modelsToLoad = {}
    for k, v in pairs( sortedItems ) do
        local slotBack = self.grid:Add( "DPanel" )
        slotBack:SetSize( self.slotSize, self.slotSize )
        local changeAlpha = 0
        slotBack.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
            
            if( IsValid( self2.itemModel ) ) then
                if( self2.itemModel:IsDown() ) then
                    changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
                elseif( self2.itemModel:IsHovered() ) then
                    changeAlpha = math.Clamp( changeAlpha+10, 0, 95 )
                else
                    changeAlpha = math.Clamp( changeAlpha-10, 0, 95 )
                end
            else
                surface.SetDrawColor( 255, 255, 255, 255 )
                surface.SetMaterial( loadingIcon )
                local size = 32
                surface.DrawTexturedRectRotated( w*0.5, h*0.5, size, size, -(CurTime() % 360 * 250) )
            end

            surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
            surface.SetAlphaMultiplier( 1 )

            draw.SimpleText( (v[1] or BRICKS_SERVER.Func.L( "nil" )), "BRICKS_SERVER_Font17", w*0.5, h-5, ((v.RarityInfo and BRICKS_SERVER.Func.GetRarityColor( v.RarityInfo )) or BRICKS_SERVER.Func.GetTheme( 6 )), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
        end

        table.insert( modelsToLoad, { slotBack, v.Key } )
    end

    local function loadModel( k )
        if( not modelsToLoad[k] ) then return end

        local parent, itemKey = modelsToLoad[k][1], modelsToLoad[k][2]
        local model, color = rarityItems[itemKey][2], rarityItems[itemKey][3]

        if( not IsValid( parent ) ) then return end

        if( model ) then
            parent.itemModel = vgui.Create( "DModelPanel", parent )
            parent.itemModel:Dock( FILL )
            parent.itemModel:SetModel( model )
            function parent.itemModel:LayoutEntity( Entity ) return end
            if( parent.itemModel.Entity and IsValid( parent.itemModel.Entity ) ) then
                local mn, mx = parent.itemModel.Entity:GetRenderBounds()
                local size = 0
                size = math.max( size, math.abs(mn.x) + math.abs(mx.x) )
                size = math.max( size, math.abs(mn.y) + math.abs(mx.y) )
                size = math.max( size, math.abs(mn.z) + math.abs(mx.z) )
    
                parent.itemModel:SetFOV( 70 )
                parent.itemModel:SetCamPos( Vector( size, size, size ) )
                parent.itemModel:SetLookAt( (mn + mx) * 0.5 )
            end

            if( color ) then
                parent.itemModel:SetColor( color )
            end
        else
            parent.itemModel = vgui.Create( "DButton", parent )
            parent.itemModel:Dock( FILL )
            parent.itemModel:SetText( "" )
            parent.itemModel.Paint = function() end
        end

        parent.itemModel.DoClick = function()
            local options = {}
            for k, v in pairs( BS_ConfigCopyTable.GENERAL.Rarities ) do
                options[k] = v[1] or BRICKS_SERVER.Func.L( "nil" )
            end

            if( table.Count( options ) <= 0 ) then 
                notification.AddLegacy( BRICKS_SERVER.Func.L( "needToAddRarity" ), 1, 5 )
                return 
            end

            BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "whatRarityItem" ), BRICKS_SERVER.Func.L( "none" ), options, function( value, data ) 
                if( BS_ConfigCopyTable.GENERAL.Rarities[data] ) then
                    BS_ConfigCopyTable.INVENTORY.ItemRarities[itemKey] = value
                    self:Refresh()
                    BRICKS_SERVER.Func.ConfigChange( "INVENTORY" )
                else
                    notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidRarity" ), 1, 3 )
                end
            end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
        end

        timer.Simple( 0.02, function()
            if( not IsValid( self ) ) then return end
            
            loadModel( k+1 )
        end )
    end

    timer.Simple( 0.02, function()
        if( not IsValid( self ) ) then return end

        loadModel( 1 )
    end )
end

function PANEL:Paint( w, h )
    
end

vgui.Register( "bricks_server_config_itemrarities", PANEL, "DPanel" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_config_themes.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel()
    function self.RefreshPanel()
        self:Clear()

        for k, v in pairs( BRICKS_SERVER.BASECONFIG.THEME ) do
            local themeBack = vgui.Create( "DPanel", self )
            themeBack:Dock( TOP )
            themeBack:DockMargin( 0, 0, 0, 5 )
            themeBack:SetTall( 100 )
            local displayColor = BRICKS_SERVER.Func.GetTheme( k ) or Color( 155, 155, 155 )
            themeBack.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, Color( 0, 0, 0 ) )
                draw.RoundedBox( 5, 2, 2, w-4, h-4, displayColor )

                if( k != 6 ) then
                    draw.SimpleText( BRICKS_SERVER.Func.L( "themeColorX", k ), "BRICKS_SERVER_Font33", 15, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                else
                    local textCol = BRICKS_SERVER.Func.GetTheme( 6 )
                    draw.SimpleText( BRICKS_SERVER.Func.L( "themeTextColor" ), "BRICKS_SERVER_Font33", 15, 5, Color( math.abs( textCol.r-255 ), math.abs( textCol.g-255 ), math.abs( textCol.b-255 ) ), 0, 0 )
                end
            end

            local themeMixer = vgui.Create( "DColorMixer", themeBack )
            themeMixer:Dock( RIGHT )
            themeMixer:DockMargin( 5, 5, 5, 5 )
            themeMixer:SetWide( 250 )
            themeMixer:SetPalette( false )
            themeMixer:SetAlphaBar( false) 
            themeMixer:SetWangs( true )
            themeMixer:SetColor( BRICKS_SERVER.Func.GetTheme( k ) )
            themeMixer.ValueChanged = function()
                displayColor = themeMixer:GetColor() or Color( 155, 155, 155 )
                BS_ConfigCopyTable.THEME[k] = themeMixer:GetColor() or Color( 155, 155, 155 )
                BRICKS_SERVER.Func.ConfigChange( "THEME" )
            end
        end

        local accentBack = vgui.Create( "DPanel", self )
        accentBack:Dock( TOP )
        accentBack:DockMargin( 0, 0, 0, 5 )
        accentBack:SetTall( 100 )
        accentBack:DockPadding( 0, 0, 30, 0 )
        accentBack.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
            draw.RoundedBox( 5, 5, 45, w-10, h-45-5, BRICKS_SERVER.Func.GetTheme( 2 ) )

            draw.SimpleText( BRICKS_SERVER.Func.L( "presetAccents" ), "BRICKS_SERVER_Font33", 15, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
        end

        local first = true
        for k, v in pairs( BRICKS_SERVER.DEVCONFIG.AccentThemes ) do
            local accentButton = vgui.Create( "DButton", accentBack )
            accentButton:Dock( LEFT )
            accentButton:SetText( "" )
            if( first ) then
                accentButton:DockMargin( 10, 50, 0, 10 )
                first = false
            else
                accentButton:DockMargin( 5, 50, 0, 10 )
            end
            accentButton:SetWide( 40 )
            local changeAlpha = 0
            accentButton.Paint = function( self2, w, h )
                if( self2:IsHovered() ) then
                    changeAlpha = math.Clamp( changeAlpha+10, 0, 100 )
                else
                    changeAlpha = math.Clamp( changeAlpha-10, 0, 100 )
                end
                
                draw.RoundedBox( 5, 0, 0, w, h, v[1] )
        
                surface.SetAlphaMultiplier( changeAlpha/255 )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                surface.SetAlphaMultiplier( 1 )
            end
            accentButton.DoClick = function()
                BS_ConfigCopyTable.THEME[4] = v[1]
                BS_ConfigCopyTable.THEME[5] = v[2]
                BRICKS_SERVER.Func.ConfigChange( "THEME" )
                self.RefreshPanel()
            end
        end

        local backgroundBack = vgui.Create( "DPanel", self )
        backgroundBack:Dock( TOP )
        backgroundBack:DockMargin( 0, 0, 0, 5 )
        backgroundBack:SetTall( 100 )
        backgroundBack:DockPadding( 0, 0, 30, 0 )
        backgroundBack.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
            draw.RoundedBox( 5, 5, 45, w-10, h-45-5, BRICKS_SERVER.Func.GetTheme( 2 ) )

            draw.SimpleText( BRICKS_SERVER.Func.L( "presetBackgrounds" ), "BRICKS_SERVER_Font33", 15, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
        end

        local first = true
        for k, v in pairs( BRICKS_SERVER.DEVCONFIG.BackgroundThemes ) do
            local backgroundButton = vgui.Create( "DButton", backgroundBack )
            backgroundButton:Dock( LEFT )
            backgroundButton:SetText( "" )
            if( first ) then
                backgroundButton:DockMargin( 10, 50, 0, 10 )
                first = false
            else
                backgroundButton:DockMargin( 5, 50, 0, 10 )
            end
            backgroundButton:SetWide( 40 )
            local changeAlpha = 0
            backgroundButton.Paint = function( self2, w, h )
                if( self2:IsHovered() ) then
                    changeAlpha = math.Clamp( changeAlpha+10, 0, 100 )
                else
                    changeAlpha = math.Clamp( changeAlpha-10, 0, 100 )
                end
                
                draw.RoundedBox( 5, 0, 0, w, h, v[1] )
        
                surface.SetAlphaMultiplier( changeAlpha/255 )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                surface.SetAlphaMultiplier( 1 )
            end
            backgroundButton.DoClick = function()
                BS_ConfigCopyTable.THEME[0] = v[1]
                BS_ConfigCopyTable.THEME[1] = v[2]
                BS_ConfigCopyTable.THEME[2] = v[3]
                BS_ConfigCopyTable.THEME[3] = v[4]
                BS_ConfigCopyTable.THEME[6] = v[6]
                BRICKS_SERVER.Func.ConfigChange( "THEME" )
                self.RefreshPanel()
            end
        end

        local themeReset = vgui.Create( "DButton", self )
        themeReset:Dock( TOP )
        themeReset:SetText( "" )
        themeReset:DockMargin( 0, 0, 0, 5 )
        themeReset:SetTall( 40 )
        local changeAlpha = 0
        themeReset.Paint = function( self2, w, h )
            if( self2:IsDown() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
            elseif( self2:IsHovered() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
            else
                changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
    
            surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
            surface.SetAlphaMultiplier( 1 )
    
            draw.SimpleText( BRICKS_SERVER.Func.L( "resetToBaseThemes" ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
        themeReset.DoClick = function()
            BS_ConfigCopyTable.THEME = table.Copy( BRICKS_SERVER.BASECONFIG.THEME )
            BRICKS_SERVER.Func.ConfigChange( "THEME" )
            self.RefreshPanel()
        end

        local themeResetPrevious = vgui.Create( "DButton", self )
        themeResetPrevious:Dock( TOP )
        themeResetPrevious:SetText( "" )
        themeResetPrevious:DockMargin( 0, 0, 0, 5 )
        themeResetPrevious:SetTall( 40 )
        local changeAlpha = 0
        themeResetPrevious.Paint = function( self2, w, h )
            if( self2:IsDown() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
            elseif( self2:IsHovered() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
            else
                changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
    
            surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
            surface.SetAlphaMultiplier( 1 )
    
            draw.SimpleText( BRICKS_SERVER.Func.L( "resetToCurrentThemes" ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
        themeResetPrevious.DoClick = function()
            BS_ConfigCopyTable.THEME = table.Copy( BRICKS_SERVER.CONFIG.THEME )
            BRICKS_SERVER.Func.ConfigChange( "THEME" )
            self.RefreshPanel()
        end
    end
    self.RefreshPanel()
end

function PANEL:Paint( w, h )
    
end

vgui.Register( "bricks_server_config_themes", PANEL, "bricks_server_scrollpanel" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_dcheckbox.lua:
local PANEL = {}

function PANEL:Init()
	self:SetSize( 45, 50 )

	self.toggle = vgui.Create( "DButton", self )
	self.toggle:Dock( LEFT )
	self.toggle:SetWide( 45 )
	self.toggle:SetText( "" )
	self.toggle.xPos = 0
	self.toggle.Paint = function( self2, w, h )
		local backH = 16
		local circleRadius = math.min( h*0.5, (backH*0.5)*1.35 )
		self2.minXPos, self2.maxXPos = circleRadius, w-circleRadius

		draw.RoundedBox( backH*0.5, 0, (h*0.5)-(backH*0.5), w, backH, (self.backgroundCol or BRICKS_SERVER.Func.GetTheme( 3 )) )
		
		if( self.toggled ) then
			self2.xPos = math.Clamp( self2.xPos+3, self2.minXPos, self2.maxXPos )
		else
			self2.xPos = math.Clamp( self2.xPos-3, self2.minXPos, self2.maxXPos )
		end

		BRICKS_SERVER.Func.DrawCircle( self2.xPos, h*0.5, circleRadius, (self.toggled and BRICKS_SERVER.DEVCONFIG.BaseThemes.Green) or BRICKS_SERVER.DEVCONFIG.BaseThemes.Red )
	end
	self.toggle.DoClick = function()
		self.toggled = not self.toggled

		if( self.OnChange ) then
			self.OnChange( self.toggled )
		end
	end
end

function PANEL:SetValue( value )
	if( value ) then
		self.toggle.xPos = self.toggle.maxXPos or 0
		self.toggled = true
	else
		self.toggle.xPos = self.toggle.minXPos or 0
		self.toggled = false
	end
end

function PANEL:SetDisabled( value )
	self.toggle:SetDisabled( value )
end

function PANEL:SetTitle( title )
	self.title = title

	surface.SetFont( "BRICKS_SERVER_Font20" )
	local titleX, titleY = surface.GetTextSize( self.title or BRICKS_SERVER.Func.L( "toggle" ) )

	if( title != "" ) then
		self:SetWide( 45+5+titleX )
	else
		self:SetWide( 45 )
	end
end

function PANEL:Paint( w, h )
	draw.SimpleText( (self.title or BRICKS_SERVER.Func.L( "toggle" )), "BRICKS_SERVER_Font20", self.toggle:GetWide()+5, h*0.5-1, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
end
 
vgui.Register( "bricks_server_dcheckbox", PANEL, "DPanel" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_dslider.lua:

local PANEL = {}

AccessorFunc( PANEL, "NumSlider", "NumSlider" )

AccessorFunc( PANEL, "m_fSlideX", "SlideX" )
AccessorFunc( PANEL, "m_fSlideY", "SlideY" )

AccessorFunc( PANEL, "m_iLockX", "LockX" )
AccessorFunc( PANEL, "m_iLockY", "LockY" )

AccessorFunc( PANEL, "Dragging", "Dragging" )
AccessorFunc( PANEL, "m_bTrappedInside", "TrapInside" )
AccessorFunc( PANEL, "m_iNotches", "Notches" )

function PANEL:Init()
	self:SetMouseInputEnabled( true )
	self:SetTrapInside( true )

	self:SetSlideX( 0 )
	self:SetSlideY( 0.5 )

	self.Knob = vgui.Create( "DButton", self )
	self.Knob:SetText( "" )
	self.Knob:SetSize( 20, 20 )
	self.Knob.Paint = function( panel, w, h )
		BRICKS_SERVER.Func.DrawCircle( w*0.5, h*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 5, 75 ) )
		BRICKS_SERVER.Func.DrawCircle( w*0.5, h*0.5, h*0.5-2, BRICKS_SERVER.Func.GetTheme( 5 ) )
	end
	self.Knob.OnCursorMoved = function( panel, x, y )
		local x, y = panel:LocalToScreen( x, y )
		x, y = self:ScreenToLocal( x, y )
		self:OnCursorMoved( x, y )
	end

	self:SetLockY( 0.5 )
end

function PANEL:Paint( w, h )
	surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3 ) )
	surface.DrawRect( 10, (h*0.5)-1, w-20, 2 )
end

--
-- We we currently editing?
--
function PANEL:IsEditing()

	return self.Dragging || self.Knob.Depressed

end

function PANEL:SetBackground( img )

	if ( !self.BGImage ) then
		self.BGImage = vgui.Create( "DImage", self )
	end

	self.BGImage:SetImage( img )
	self:InvalidateLayout()

end

function PANEL:SetImage( strImage )
	-- RETIRED
end

function PANEL:SetImageColor( color )
	-- RETIRED
end

function PANEL:SetEnabled( b )
	self.Knob:SetEnabled( b )
	FindMetaTable( "Panel" ).SetEnabled( self, b ) -- There has to be a better way!
end

function PANEL:OnCursorMoved( x, y )

	if ( !self.Dragging && !self.Knob.Depressed ) then return end

	local w, h = self:GetSize()
	local iw, ih = self.Knob:GetSize()

	if ( self.m_bTrappedInside ) then

		w = w - iw
		h = h - ih

		x = x - iw * 0.5
		y = y - ih * 0.5

	end

	x = math.Clamp( x, 0, w ) / w
	y = math.Clamp( y, 0, h ) / h

	if ( self.m_iLockX ) then x = self.m_iLockX end
	if ( self.m_iLockY ) then y = self.m_iLockY end

	x, y = self:TranslateValues( x, y )

	self:SetSlideX( x )
	self:SetSlideY( y )

	self:InvalidateLayout()

end

function PANEL:TranslateValues( x, y )

	-- Give children the chance to manipulate the values..
	return x, y

end

function PANEL:OnMousePressed( mcode )

	if ( !self:IsEnabled() ) then return true end

	-- When starting dragging with not pressing on the knob.
	self.Knob.Hovered = true

	self:SetDragging( true )
	self:MouseCapture( true )

	local x, y = self:CursorPos()
	self:OnCursorMoved( x, y )

end

function PANEL:OnMouseReleased( mcode )

	-- This is a hack. Panel.Hovered is not updated when dragging a panel (Source's dragging, not Lua Drag'n'drop)
	self.Knob.Hovered = vgui.GetHoveredPanel() == self.Knob

	self:SetDragging( false )
	self:MouseCapture( false )

end

function PANEL:PerformLayout()

	local w, h = self:GetSize()
	local iw, ih = self.Knob:GetSize()

	if ( self.m_bTrappedInside ) then

		w = w - iw
		h = h - ih
		self.Knob:SetPos( ( self.m_fSlideX || 0 ) * w, ( self.m_fSlideY || 0 ) * h )

	else

		self.Knob:SetPos( ( self.m_fSlideX || 0 ) * w - iw * 0.5, ( self.m_fSlideY || 0 ) * h - ih * 0.5 )

	end

	if ( self.BGImage ) then
		self.BGImage:StretchToParent( 0, 0, 0, 0 )
		self.BGImage:SetZPos( -10 )
	end

end

function PANEL:SetSlideX( i )
	self.m_fSlideX = i
	self:InvalidateLayout()
end

function PANEL:SetSlideY( i )
	self.m_fSlideY = i
	self:InvalidateLayout()
end

function PANEL:GetDragging()
	return self.Dragging || self.Knob.Depressed
end

derma.DefineControl( "bricks_server_dslider", "", PANEL, "Panel" )

--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_profile.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel( f4Panel, sheetButton )
    if( not IsValid( f4Panel ) ) then return end

    function f4Panel.FillProfile()
        if( not IsValid( self ) ) then return end
        
        self:Clear()
        
        local profileModelBack = vgui.Create( "DPanel", self )
        profileModelBack:Dock( LEFT )
        profileModelBack:DockMargin( 0, 0, 5, 0 )
        profileModelBack:SetWide( (f4Panel:GetWide()-BRICKS_SERVER.DEVCONFIG.MainNavWidth-20-5)*0.5 )
        local plyName = LocalPlayer():Nick()
        surface.SetFont( "BRICKS_SERVER_Font25" )
        local textX, textY = surface.GetTextSize( plyName )
        local donationRank
        for k, v in pairs( BRICKS_SERVER.CONFIG.GENERAL.Groups ) do
            if( BRICKS_SERVER.Func.IsInGroup( LocalPlayer(), v[1] ) ) then
                donationRank = k
                break
            end
        end

        surface.SetFont( "BRICKS_SERVER_Font20" )
        local donationTextX, donationTextY = surface.GetTextSize( (BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank] or {})[1] or "" )
        donationTextX = donationTextX+10
        local totalW = textX+donationTextX+5
        profileModelBack.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

            draw.SimpleText( plyName, "BRICKS_SERVER_Font25", (w*0.5)-(totalW*0.5), h-(h/10), BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )

            if( BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank] ) then
                draw.RoundedBox( 5, (w*0.5)-(totalW*0.5)+textX+5, h-(h/10)-(donationTextY*0.5)+1.5, donationTextX, donationTextY, (BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank][3] or BRICKS_SERVER.Func.GetTheme( 5 ))  )
                draw.SimpleText( BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank][1], "BRICKS_SERVER_Font20", (w*0.5)-(totalW*0.5)+textX+5+(donationTextX*0.5), h-(h/10), BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            end
        end

        local profileModelBack = vgui.Create( "DModelPanel", profileModelBack )
        profileModelBack:Dock( FILL )
        profileModelBack:DockMargin( 10, 10, 10, 10 )
        profileModelBack:SetModel( LocalPlayer():GetModel() or "" )
        function profileModelBack:LayoutEntity( Entity ) return end

        local dataToShow = {
            [1] = { BRICKS_SERVER.Func.L( "name" ), LocalPlayer():Nick() },
            [2] = { BRICKS_SERVER.Func.L( "steamID64" ), LocalPlayer():SteamID64() },
            [3] = { BRICKS_SERVER.Func.L( "donationRank" ), (BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank] or {})[1] or BRICKS_SERVER.Func.L( "none" ) },
            [4] = { BRICKS_SERVER.Func.L( "staffRank" ), BRICKS_SERVER.Func.GetAdminGroup( LocalPlayer() ) }
        }

        if( DarkRP ) then
            table.insert( dataToShow, { BRICKS_SERVER.Func.L( "currentJob" ), LocalPlayer():getDarkRPVar( "job" ) or BRICKS_SERVER.Func.L( "none" ) } )
            table.insert( dataToShow, { BRICKS_SERVER.Func.L( "wallet" ), DarkRP.formatMoney( LocalPlayer():getDarkRPVar( "money" ) or 0 ) } )
        end
    
        if( BRICKS_SERVER.Func.IsSubModuleEnabled( "essentials", "levelling" ) ) then
            table.insert( dataToShow, { BRICKS_SERVER.Func.L( "level" ), BRS_LEVEL or 0 } )
            table.insert( dataToShow, { BRICKS_SERVER.Func.L( "experience" ), string.Comma( math.Round( BRS_EXPERIENCE or 0 ) ) } )
        end

        if( BRICKS_SERVER.Func.IsSubModuleEnabled( "default", "currencies" ) ) then
            for k, v in pairs( BRICKS_SERVER.CONFIG.CURRENCIES or {} ) do
                if( not BRICKS_SERVER.DEVCONFIG.Currencies["custom_" .. k] ) then continue end

                local currencyTable = BRICKS_SERVER.DEVCONFIG.Currencies["custom_" .. k]

                table.insert( dataToShow, { v.Name, currencyTable.formatFunction( currencyTable.getFunction( LocalPlayer() ) or 0 ) } )
            end
        end
        
        local profileInfoBack = vgui.Create( "DPanel", self )
        profileInfoBack:Dock( FILL )
        local initialSpacer = 50
        local spacing = 30
        profileInfoBack.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

            for k, v in ipairs( dataToShow ) do
                local pos = k
                if( k % 2 == 0 ) then
                    pos = k-1
                    draw.SimpleText( v[1], "BRICKS_SERVER_Font25", (w/4)*3, initialSpacer+(spacing*(pos-1)), BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                    draw.SimpleText( v[2], "BRICKS_SERVER_Font20", (w/4)*3, initialSpacer+(spacing*(pos-1))+20, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                else
                    draw.SimpleText( v[1], "BRICKS_SERVER_Font25", (w/4)*1, initialSpacer+(spacing*(pos-1)), BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                    draw.SimpleText( v[2], "BRICKS_SERVER_Font20", (w/4)*1, initialSpacer+(spacing*(pos-1))+20, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                end
            end
        end
    end
    f4Panel.FillProfile()

    hook.Add( "OnPlayerChangedTeam", "BRS.OnPlayerChangedTeam.F4Profile", function()
        timer.Simple( 1, function()
            if( f4Panel.FillProfile ) then
                f4Panel.FillProfile()
            end
        end )
    end )
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_profile", PANEL, "DPanel" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/client/cl_gang_drawing.lua:
local ownerMat = Material( "bricks_server/crown.png" )
function BRICKS_SERVER.Func.GangCreateMemberSlot( parent, width, height, steamID, name, groupID, gangTable, actions )
    local playerEnt = player.GetBySteamID( steamID )
    local playerName = name

    if( IsValid( playerEnt ) ) then
        playerName = playerEnt:Nick()
    end

    local avatarBackSize = height-12
    local textStartPos = height+5

    local onlineSize = 22
    
    local playerBack = parent:Add( "DPanel" )
    playerBack:SetSize( width, height )
    local alpha = 0
    local playerButton
    local clickColor = Color( BRICKS_SERVER.Func.GetTheme( 0 ).r, BRICKS_SERVER.Func.GetTheme( 0 ).g, BRICKS_SERVER.Func.GetTheme( 0 ).b, 50 )
    playerBack.Paint = function( self2, w, h )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
        
        if( IsValid( playerButton ) ) then
            if( not playerButton:IsDown() and playerButton:IsHovered() ) then
                alpha = math.Clamp( alpha+3, 0, 50 )
            else
                alpha = math.Clamp( alpha-3, 0, 50 )
            end
    
            draw.RoundedBox( 5, 0, 0, w, h, Color( BRICKS_SERVER.Func.GetTheme( 1 ).r, BRICKS_SERVER.Func.GetTheme( 1 ).g, BRICKS_SERVER.Func.GetTheme( 1 ).b, alpha ) )

            BRICKS_SERVER.Func.DrawClickCircle( playerButton, w, h, clickColor )
        end

        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
        draw.NoTexture()
        BRICKS_SERVER.Func.DrawCircle( (h-avatarBackSize)*0.5+(avatarBackSize*0.5), h*0.5, avatarBackSize*0.5, 45 )

        draw.SimpleText( playerName, "BRICKS_SERVER_Font30", textStartPos, h*0.5+2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_BOTTOM )
        draw.SimpleText( gangTable.Roles[groupID][1], "BRICKS_SERVER_Font20", textStartPos+1, h*0.5-2, (gangTable.Roles[groupID][2] or BRICKS_SERVER.Func.GetTheme( 6 )), 0, 0 )

        draw.NoTexture()
        if( IsValid( playerEnt ) ) then
            surface.SetDrawColor( BRICKS_SERVER.DEVCONFIG.BaseThemes.Green )
        else
            surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
        end
        BRICKS_SERVER.Func.DrawArc( width-(height-onlineSize)*0.5-(onlineSize*0.5), height*0.5, onlineSize*0.5, 1, 0, 360, (IsValid( playerEnt ) and BRICKS_SERVER.DEVCONFIG.BaseThemes.Green) or BRICKS_SERVER.Func.GetTheme( 2 ) )
        BRICKS_SERVER.Func.DrawCircle( width-(height-onlineSize)*0.5-(onlineSize*0.5), height*0.5, (onlineSize-6)*0.5, 45 )
    end

    if( (gangTable.Owner or "") == steamID ) then
        surface.SetFont( "BRICKS_SERVER_Font30" )
        local nameX, nameY = surface.GetTextSize( playerName )

        local iconSize = 16

        local playerOwner = vgui.Create( "DPanel", playerBack )
        playerOwner:SetSize( iconSize, iconSize )
        playerOwner:SetPos( textStartPos+nameX+5, (height*0.5+2-(nameY*0.5))-(iconSize*0.5) )
        playerOwner.Paint = function( self2, w, h )
            surface.SetDrawColor( 243, 156, 18 )
            surface.SetMaterial( ownerMat )
            surface.DrawTexturedRect( 0, 0, w, h )
        end
    end

    local distance = 2

    local playerIcon = vgui.Create( "bricks_server_circle_avatar" , playerBack )
    playerIcon:SetPos( (height-avatarBackSize)*0.5+distance, (height-avatarBackSize)*0.5+distance )
    playerIcon:SetSize( avatarBackSize-(2*distance), avatarBackSize-(2*distance) )
    if( IsValid( playerEnt ) ) then
        playerIcon:SetPlayer( playerEnt, 64 )
    else
        playerIcon:SetSteamID( util.SteamIDTo64( steamID ), 64 )
    end

    playerButton = vgui.Create( "DButton" , playerBack )
    playerButton:SetSize( width, height )
    playerButton:SetText( "" )
    local x, y, w, h = 0, 0, playerButton:GetWide(), playerButton:GetTall()
    playerButton.Paint = function( self2, w, h )
        local toScreenX, toScreenY = self2:LocalToScreen( 0, 0 )
        if( x != toScreenX or y != toScreenY ) then
            x, y = toScreenX, toScreenY
        end
    end
    playerButton.DoClick = function( self2 )
        self2.Menu = vgui.Create( "bricks_server_dmenu" )

        if( not actions ) then
            if( LocalPlayer():GangHasPermission( "ChangePlayerRoles" ) ) then
                self2.Menu:AddOption( "Set rank", function()
                    local options = {}
                    for k, v in pairs( gangTable.Roles or {} ) do
                        options[k] = v[1]
                    end

                    BRICKS_SERVER.Func.ComboRequest( "Gang", BRICKS_SERVER.Func.L( "gangRankQuery" ), groupID, options, function( value, data ) 
                        if( (gangTable.Roles or {})[data] ) then
                            if( groupID != data ) then
                                net.Start( "BRS.Net.GangSetRank" )
                                    net.WriteString( steamID )
                                    net.WriteUInt( data, 16 )
                                net.SendToServer()
                            else
                                notification.AddLegacy( BRICKS_SERVER.Func.L( "gangPlayerAlreadyRank" ), 1, 3 )
                            end
                        else
                            notification.AddLegacy( BRICKS_SERVER.Func.L( "gangInvalidRank" ), 1, 3 )
                        end
                    end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
                end )
            end

            if( LocalPlayer():GangHasPermission( "KickPlayers" ) ) then
                self2.Menu:AddOption( BRICKS_SERVER.Func.L( "gangKick" ), function()
                    BRICKS_SERVER.Func.Query( BRICKS_SERVER.Func.L( "gangKickConfirm" ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ), BRICKS_SERVER.Func.L( "cancel" ), function() 
                        net.Start( "BRS.Net.GangKick" )
                            net.WriteString( steamID )
                        net.SendToServer()
                    end )
                end )
            end
        else
            for k, v in pairs( actions ) do
                self2.Menu:AddOption( v[1], v[2] )
            end
        end

        self2.Menu:Open()
        self2.Menu:SetPos( x+w+5, y+(h*0.5)-(self2.Menu:GetTall()*0.5) )
    end

    return playerBack
end

function BRICKS_SERVER.Func.GangGenerateInbox()
    local sortedInbox = {}
    for k, v in pairs( BRS_GANG_INBOXES or {} ) do
        if( k != LocalPlayer():SteamID() and k != LocalPlayer():GetGangID() ) then continue end

        for key, val in pairs( v ) do
            local notificationTable = val
            notificationTable.Key = key
            notificationTable.ReceiverKey = k

            table.insert( sortedInbox, notificationTable )
        end
    end

    return sortedInbox
end

function BRICKS_SERVER.Func.GangCreateInbox( buttonParent, button, showRight, extraY, buttonX, buttonY )
    button.DoClick = function()
        if( IsValid( button.InboxPanel ) ) then 
            button.InboxPanel:Remove()
            return
        end

        button.InboxPanel = vgui.Create( "DPanel", buttonParent )
        button.InboxPanel:SetSize( ScrW()*0.15, ScrH()*0.25 )
        if( not showRight ) then
            button.InboxPanel:SetPos( buttonX-button.InboxPanel:GetWide()+button:GetWide(), buttonY+button:GetTall()+5+extraY )
        else
            button.InboxPanel:SetPos( buttonX, buttonY+button:GetTall()+5+extraY )
        end
        local inboxCount = 0
        button.InboxPanel.Paint = function( self2, w, h )
            local x, y = self2:LocalToScreen( 0, 0 )

            BRICKS_SERVER.BSHADOWS.BeginShadow()
            draw.RoundedBox( 5, x, y, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )			
            BRICKS_SERVER.BSHADOWS.EndShadow( 1, 2, 2, 255, 0, 0, false )

            draw.RoundedBoxEx( 5, 0, 0, w, 40, BRICKS_SERVER.Func.GetTheme( 3 ), true, true, false, false )
        
            draw.SimpleText( BRICKS_SERVER.Func.L( "gangInbox" ) .. " - " .. ((inboxCount != 1 and BRICKS_SERVER.Func.L( "gangXMessages", inboxCount )) or BRICKS_SERVER.Func.L( "gangXMessage", inboxCount )), "BRICKS_SERVER_Font25", 10, 40*0.5-1, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
        end
        button.InboxPanel.Think = function( self2 )
            if( not IsValid( button ) ) then 
                self2:Remove()
            end
        end

        local inboxScroll = vgui.Create( "bricks_server_scrollpanel", button.InboxPanel )
        inboxScroll:Dock( FILL )
        inboxScroll:DockMargin( 0, 40, 0, 0 )


        function button.RefreshGangInbox()
            if( not IsValid( inboxScroll ) ) then return end

            inboxScroll:Clear()

            local sortedInbox = BRICKS_SERVER.Func.GangGenerateInbox()

            inboxCount = #sortedInbox

            table.SortByMember( sortedInbox, "Time", false )

            for k, v in pairs( sortedInbox ) do
                local devConfigTable = BRICKS_SERVER.DEVCONFIG.GangNotifications[v.Type]

                if( not devConfigTable ) then continue end

                local header = string.upper( devConfigTable.Name )
                if( devConfigTable.FormatHeader ) then
                    header = string.upper( devConfigTable.FormatHeader( v.ReqInfo ) )
                end

                surface.SetFont( "BRICKS_SERVER_Font23" )
                local headerX, headerY = surface.GetTextSize( header )

                local inboxEntry = vgui.Create( "DPanel", inboxScroll )
                inboxEntry:Dock( TOP )
                inboxEntry:SetTall( 120 )
                inboxEntry.Paint = function( self2, w, h )
                    draw.SimpleText( header, "BRICKS_SERVER_Font23", 10, 5, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 150 ), 0, 0 )

                    local timeSince = math.max( 0, math.floor( os.time()-v.Time ) )

                    draw.SimpleText( string.upper( BRICKS_SERVER.Func.L( "gangTimeAgo", BRICKS_SERVER.Func.FormatWordTime( timeSince ) ) ), "BRICKS_SERVER_Font17", w-10, 5+headerY, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 75 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM )
                end
                local buttonCount = 0
                inboxEntry.AddButton = function( icon, func, color, clickColor )
                    buttonCount = buttonCount+1

                    local inboxEntryButton = vgui.Create( "DButton", inboxEntry )
                    inboxEntryButton:SetSize( BRICKS_SERVER.Func.ScreenScale( 24 ), BRICKS_SERVER.Func.ScreenScale( 24 ) )
                    inboxEntryButton:SetPos( button.InboxPanel:GetWide()-(buttonCount*(8+inboxEntryButton:GetWide())), inboxEntry:GetTall()-inboxEntryButton:GetTall()-8 )
                    inboxEntryButton:SetText( "" )
                    local Alpha = 0
                    local inboxMat = Material( icon )
                    inboxEntryButton.Paint = function( self2, w, h )
                        if( self2:IsDown() ) then
                            Alpha = 0
                        elseif( self2:IsHovered() ) then
                            Alpha = math.Clamp( Alpha+5, 0, 75 )
                        else
                            Alpha = math.Clamp( Alpha-5, 0, 75 )
                        end
                    
                        draw.RoundedBox( 6, 0, 0, w, h, color )
                        surface.SetAlphaMultiplier( Alpha/255 )
                        draw.RoundedBox( 6, 0, 0, w, h, clickColor )
                        surface.SetAlphaMultiplier( 1 )
                    
                        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
                        surface.SetMaterial( inboxMat )
                        local iconSize = BRICKS_SERVER.Func.ScreenScale( 16 )
                        surface.DrawTexturedRect( (w*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
                    end
                    inboxEntryButton.DoClick = func
                end

                if( (v.ReceiverKey or "") == LocalPlayer():SteamID() or LocalPlayer():GangHasPermission( "EditInbox" ) ) then
                    inboxEntry.AddButton( "bricks_server/decline_16.png", function()
                        net.Start( "BRS.Net.DeleteGangInboxEntry" )
                            net.WriteString( v.ReceiverKey )
                            net.WriteUInt( v.Key, 16 )
                        net.SendToServer()
                    end, Color( 207, 72, 72 ), Color( 167, 32, 32 ) )

                    if( devConfigTable.AcceptFunc ) then
                        inboxEntry.AddButton( "bricks_server/accept_16.png", function()
                            devConfigTable.AcceptFunc( v.ReqInfo, v.Key )
                        end, Color( 60, 174, 101 ), Color( 20, 134, 61 ) )
                    end
                end

                local inboxDescription = vgui.Create( "DPanel", inboxEntry )
                inboxDescription:Dock( FILL )
                inboxDescription:DockMargin( 10, 30, 10, 29 )
                inboxDescription.Paint = function( self2, w, h )
                    local description = BRICKS_SERVER.Func.TextWrap( (devConfigTable.FormatDescription( v.ReqInfo ) or BRICKS_SERVER.Func.L( "noDescription" )), "BRICKS_SERVER_Font19", w )

                    BRICKS_SERVER.Func.DrawNonParsedText( description, "BRICKS_SERVER_Font19", 0, 0, BRICKS_SERVER.Func.GetTheme( 6 ), 0 )
                end
            end

            button.InboxPanel:SetTall( 40+(math.Clamp( inboxCount, 1, 3 )*120) )
        end
        button.RefreshGangInbox()
    end

    local function RefreshGangInboxNotification()
        if( IsValid( button.inboxNotification ) ) then
            button.inboxNotification:Remove()
        end

        local inboxCount = table.Count( BRICKS_SERVER.Func.GangGenerateInbox() or {} )
        if( inboxCount > 0 ) then
            local extraDistance = 4

            button.inboxNotification = vgui.Create( "DPanel", buttonParent )
            button.inboxNotification:SetSize( BRICKS_SERVER.Func.ScreenScale( 14 ), BRICKS_SERVER.Func.ScreenScale( 14 ) )
            button.inboxNotification:SetPos( buttonX+button:GetWide()-(button.inboxNotification:GetWide()*0.5)-extraDistance, buttonY+button:GetTall()-(button.inboxNotification:GetTall()*0.5)-extraDistance+extraY )
            button.inboxNotification.Paint = function( self2, w, h )
                surface.SetDrawColor( 207, 72, 72 )
                draw.NoTexture()
                BRICKS_SERVER.Func.DrawCircle( w*0.5, h*0.5, w*0.5, 45 )		
            end
        end
    end
    RefreshGangInboxNotification()

    hook.Add( "BRS.Hooks.RefreshGangInbox", "BricksServerHooks_BRS_RefreshGangInbox_Dashboard_" .. tostring( button ), function()
        if( IsValid( button ) ) then
            if( button.RefreshGangInbox ) then button.RefreshGangInbox() end

            RefreshGangInboxNotification()
        else
            hook.Remove( "BRS.Hooks.RefreshGangInbox", "BricksServerHooks_BRS_RefreshGangInbox_Dashboard_" .. tostring( button ) )
        end
    end )
end
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/vgui/bricks_server_gangmenu_dashboard.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel( gangTable )
    local graphs = {
        [1] = {
            Title = BRICKS_SERVER.Func.L( "gangMembers" ),
            Color1 = Color( 128, 38, 38 ),
            Color2 = Color( 210, 74, 74 ),
            HighlightColor = Color( 201, 70, 70 ),
            SubTitle = function() 
                local memberCount = table.Count( gangTable.Members or {} )
                return memberCount .. ((memberCount != 1 and " PLAYERS") or " PLAYER")
            end,
            BottomTitle = "MEMBERS ONLINE",
            BottomSubTitle = function() 
                local onlineCount = 0
                for k, v in pairs( gangTable.Members or {} ) do
                    local ply = player.GetBySteamID( k )

                    if( IsValid( ply ) ) then
                        onlineCount = onlineCount+1
                    end
                end
                return onlineCount
            end
        },
        [2] = {
            Title = BRICKS_SERVER.Func.L( "gangBalance" ),
            Color1 = Color( 39, 128, 100 ),
            Color2 = Color( 74, 211, 114 ),
            HighlightColor = Color( 71, 204, 112 ),
            SubTitle = function() return DarkRP.formatMoney( gangTable.Money or 0 ) end,
            BottomTitle = "LAST TRANSACTION",
            BottomSubTitle = function() 
                local transaction

                if( transaction ) then
                    return {
                        { ((transaction >= 0 and "+") or "-") .. DarkRP.formatMoney( transaction ), "BRICKS_SERVER_Font33", ((transaction >= 0 and Color( 71, 204, 112 )) or Color( 229, 62, 62 )) }
                    }
                else
                    return "???"
                end
            end
        },
        [4] = {
            Title = BRICKS_SERVER.Func.L( "gangLevel" ),
            Color1 = Color( 196, 32, 201 ),
            Color2 = Color( 166, 61, 212 ),
            HighlightColor = Color( 194, 34, 202 ),
            SubTitle = function() return gangTable.Level or 0 end,
            BottomTitle = "XP PROGRESS",
            BottomSubTitle = function() 
                local currentXP = math.max( 0, (gangTable.Experience or 0)-BRICKS_SERVER.Func.GetGangExpToLevel( 0, (gangTable.Level or 0) ) )
                local goalXP = math.max( 0, BRICKS_SERVER.Func.GetGangExpToLevel( (gangTable.Level or 0), (gangTable.Level or 0)+1 ) )
                return {
                    { string.Comma( math.floor( currentXP ) ) }, 
                    { "/" .. string.Comma( math.floor( goalXP ) ) .. "XP", "BRICKS_SERVER_Font28B", Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 75 ) }
                }
            end,
        }
    }

    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "storage" ) ) then
        graphs[3] = {
            Title = BRICKS_SERVER.Func.L( "gangStorage" ),
            Color1 = Color( 76, 113, 212 ),
            Color2 = Color( 81, 80, 171 ),
            HighlightColor = Color( 80, 84, 175 ),
            SubTitle = function() 
                return {
                    { table.Count( gangTable.Storage or {} ) }, 
                    { "/" .. BRICKS_SERVER.Func.GangGetUpgradeInfo( LocalPlayer():GetGangID(), "StorageSlots" )[1], "BRICKS_SERVER_Font28B" }
                }
            end,
            BottomTitle = "STORAGE USED",
            BottomSubTitle = function() return math.Clamp( 100*(table.Count( gangTable.Storage or {} )/BRICKS_SERVER.Func.GangGetUpgradeInfo( LocalPlayer():GetGangID(), "StorageSlots" )[1]), 0, 100 ) .. "% FILLED" end
        }
    else
        graphs[3] = {
            Title = BRICKS_SERVER.Func.L( "gangStorage" ),
            Color1 = Color( 76, 113, 212 ),
            Color2 = Color( 81, 80, 171 ),
            HighlightColor = Color( 80, 84, 175 ),
            SubTitle = function() 
                return {
                    { 0 }, 
                    { "/" .. 0, "BRICKS_SERVER_Font28B" }
                }
            end,
            BottomTitle = "STORAGE DISABLED",
            BottomSubTitle = function() return "0% FILLED" end
        }
    end

    local outerMargin = 24

    local panelWide = self.panelWide-(2*outerMargin)
    
    local statisticsBack = vgui.Create( "DPanel", self )
    statisticsBack:Dock( TOP )
    statisticsBack:DockMargin( outerMargin, outerMargin, outerMargin, 0 )
    statisticsBack:DockPadding( 0, 35, 0, 0 )
    statisticsBack:SetTall( BRICKS_SERVER.Func.ScreenScale( 275 ) )
    statisticsBack.Paint = function( self2, w, h ) 
        draw.SimpleText( BRICKS_SERVER.Func.L( "gangInformation" ), "BRICKS_SERVER_Font30", 0, 0, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 150 ), 0, 0 )
    end

    local graphSpacing = 30
    local graphWide = (panelWide-((#graphs-1)*graphSpacing))/#graphs
    local graphBackTall = statisticsBack:GetTall()-35

    for k, v in ipairs( graphs ) do
        local graphBack = vgui.Create( "DPanel", statisticsBack )
        graphBack:Dock( LEFT )
        graphBack:DockMargin( 0, 0, graphSpacing, 0 )
        graphBack:SetWide( graphWide )
        graphBack.Paint = function( self2, w, h ) end

        local graphTop = vgui.Create( "DPanel", graphBack )
        graphTop:Dock( TOP )
        graphTop:SetTall( graphBackTall*0.6 )
        graphTop.Paint = function( self2, w, h ) 
            BRICKS_SERVER.Func.DrawGradientRoundedBox( 8, 0, 0, w, h, 1, v.Color1, v.Color2 )

            draw.SimpleText( string.upper( v.Title ), "BRICKS_SERVER_Font28B", w*0.5, h*0.5+4, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 150 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )

            if( not istable( v.SubTitle() ) ) then
                draw.SimpleText( v.SubTitle(), "BRICKS_SERVER_Font36B", w*0.5, h*0.5-4, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
            else
                local textW, textH = 0, 0
                for k, v in pairs( v.SubTitle() ) do
                    surface.SetFont( v[2] or "BRICKS_SERVER_Font36B" )
                    local addTextW, addTextH = surface.GetTextSize( v[1] or "" )
                    textW, textH = textW+addTextW, math.max( textH, addTextH )
                end

                local previousTextW = 0
                for k, v in pairs( v.SubTitle() ) do
                    surface.SetFont( v[2] or "BRICKS_SERVER_Font36B" )
                    local newTextW, newTextH = surface.GetTextSize( v[1] or "" )

                    draw.SimpleText( v[1], (v[2] or "BRICKS_SERVER_Font36B"), (w*0.5)-(textW*0.5)+previousTextW, h*0.5-4+textH, (v[3] or BRICKS_SERVER.Func.GetTheme( 6 )), 0, TEXT_ALIGN_BOTTOM )

                    previousTextW = previousTextW+newTextW
                end
            end
        end

        surface.SetFont( "BRICKS_SERVER_Font21" )
        local bottomTitleX, bottomTitleY = surface.GetTextSize( v.BottomTitle or "" )

        surface.SetFont( "BRICKS_SERVER_Font33" )
        local bottomSubTitleX, bottomSubTitleY = 0, 0

        if( not istable( v.BottomSubTitle() ) ) then
            bottomSubTitleX, bottomSubTitleY = surface.GetTextSize( v.BottomSubTitle() or "" )
        else
            for k, v in pairs( v.BottomSubTitle() ) do
                surface.SetFont( v[2] or "BRICKS_SERVER_Font33" )
                local addTextW, addTextH = surface.GetTextSize( v[1] or "" )
                bottomSubTitleX, bottomSubTitleY = bottomSubTitleX+addTextW, math.max( bottomSubTitleY, addTextH )
            end
        end

        local textSpacing = -6
        local contentH = bottomTitleY+textSpacing+bottomSubTitleY

        local graphBottom = vgui.Create( "DPanel", graphBack )
        graphBottom:Dock( BOTTOM )
        graphBottom:SetTall( graphBackTall-graphTop:GetTall()-BRICKS_SERVER.Func.ScreenScale( 20 ) )
        graphBottom.Paint = function( self2, w, h ) 
            draw.RoundedBox( 10, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

            BRICKS_SERVER.Func.DrawPartialRoundedBox( 8, 0, 0, w, 8, v.Color2, w, 20 )

            local startY = 8+((h-8)*0.5)-(contentH*0.5)-2

            draw.SimpleText( v.BottomTitle, "BRICKS_SERVER_Font21", 25, startY, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 75 ) )

            if( not istable( v.BottomSubTitle() ) ) then
                draw.SimpleText( v.BottomSubTitle(), "BRICKS_SERVER_Font33", 25, startY+bottomTitleY+textSpacing, BRICKS_SERVER.Func.GetTheme( 6 ) )
            else
                local previousTextW = 0
                for k, v in pairs( v.BottomSubTitle() ) do
                    surface.SetFont( v[2] or "BRICKS_SERVER_Font33" )
                    local newTextW, newTextH = surface.GetTextSize( v[1] or "" )

                    draw.SimpleText( v[1], (v[2] or "BRICKS_SERVER_Font33"), 25+previousTextW, startY+bottomTitleY+textSpacing+bottomSubTitleY, (v[3] or BRICKS_SERVER.Func.GetTheme( 6 )), 0, TEXT_ALIGN_BOTTOM )

                    previousTextW = previousTextW+newTextW
                end
            end
        end
    end

    local bottomBack = vgui.Create( "DPanel", self )
    bottomBack:Dock( FILL )
    bottomBack:DockMargin( outerMargin, outerMargin, outerMargin, outerMargin )
    bottomBack.Paint = function( self2, w, h ) end

    local memberLeftMargin = 25

    local membersBack = vgui.Create( "DPanel", bottomBack )
    membersBack:Dock( LEFT )
    membersBack:SetWide( panelWide*0.38 )
    membersBack.Paint = function( self2, w, h ) 
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

        BRICKS_SERVER.Func.DrawPartialRoundedBox( 8, 0, 0, w, 10, BRICKS_SERVER.Func.GetTheme( 3 ), w, 20 )

        draw.SimpleText( string.upper( BRICKS_SERVER.Func.L( "gangMembers" ) ), "BRICKS_SERVER_Font21", memberLeftMargin, 25, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 75 ) )
    end

    local membersScroll = vgui.Create( "bricks_server_scrollpanel_bar", membersBack )
    membersScroll:Dock( FILL )
    membersScroll:DockMargin( memberLeftMargin, 60, 15, 25 )

    function self.RefreshMembers()
        membersScroll:Clear()

        local showMembers = {}
        for k, v in pairs( gangTable.Members ) do
            local memberPly = player.GetBySteamID( k )

            table.insert( showMembers, { v[2]+((not IsValid( memberPly ) and 100) or 0), IsValid( memberPly ), k, v[1], v[2] } ) -- sort value, online, steamid, name, groupid
        end

        table.SortByMember( showMembers, 1, true )

        for k, v in pairs( showMembers ) do
            local playerEnt = player.GetBySteamID( v[3] )
            local playerName = v[4]
        
            if( IsValid( playerEnt ) ) then
                playerName = playerEnt:Nick()
            end

            local avatarBoxH = BRICKS_SERVER.Func.ScreenScale( 50 )
            local circleRadius = BRICKS_SERVER.Func.ScreenScale( 7 )

            surface.SetFont( "BRICKS_SERVER_Font33" )
            local bottomTitleX, bottomTitleY = surface.GetTextSize( playerName or "" )
    
            surface.SetFont( "BRICKS_SERVER_Font21" )
            local bottomSubTitleX, bottomSubTitleY = surface.GetTextSize( gangTable.Roles[v[5]][1] or "" )
    
            local textSpacing = -2
            local contentH = bottomTitleY+textSpacing+bottomSubTitleY

            local playerBack = vgui.Create( "DPanel", membersScroll )
            playerBack:Dock( TOP )
            playerBack:DockMargin( 0, 0, 0, 15 )
            playerBack:SetTall( avatarBoxH+(circleRadius*0.45) )
            local alpha = 0
            local playerButton
            local clickColor = Color( BRICKS_SERVER.Func.GetTheme( 0 ).r, BRICKS_SERVER.Func.GetTheme( 0 ).g, BRICKS_SERVER.Func.GetTheme( 0 ).b, 50 )
            playerBack.Paint = function( self2, w, h )
                if( IsValid( playerButton ) ) then
                    if( not playerButton:IsDown() and playerButton:IsHovered() ) then
                        alpha = math.Clamp( alpha+3, 0, 50 )
                    else
                        alpha = math.Clamp( alpha-3, 0, 50 )
                    end
            
                    draw.RoundedBox( 5, 0, 0, w, h, Color( BRICKS_SERVER.Func.GetTheme( 0 ).r, BRICKS_SERVER.Func.GetTheme( 0 ).g, BRICKS_SERVER.Func.GetTheme( 0 ).b, alpha ) )
        
                    BRICKS_SERVER.Func.DrawClickCircle( playerButton, w, h, clickColor )
                end

                local startY = (avatarBoxH*0.5)-(contentH*0.5)-2

                draw.SimpleText( playerName, "BRICKS_SERVER_Font33", avatarBoxH+15, startY, BRICKS_SERVER.Func.GetTheme( 6 ) )
                draw.SimpleText( string.upper( gangTable.Roles[v[5]][1] ), "BRICKS_SERVER_Font21", avatarBoxH+15+1, startY+bottomTitleY+textSpacing, (gangTable.Roles[v[5]][2] or BRICKS_SERVER.Func.GetTheme( 6 )) )
            end

            local playerIcon = vgui.Create( "bricks_server_rounded_avatar" , playerBack )
            playerIcon:SetPos( 0, 0 )
            playerIcon:SetSize( avatarBoxH, avatarBoxH )
            playerIcon.rounded = 8
            if( IsValid( playerEnt ) ) then
                playerIcon:SetPlayer( playerEnt, 64 )
            else
                playerIcon:SetSteamID( util.SteamIDTo64( v[3] ), 64 )
            end

            playerButton = vgui.Create( "DButton", playerBack )
            playerButton:SetSize( (panelWide*0.38)-memberLeftMargin-15, avatarBoxH+(circleRadius*0.45) )
            playerButton:SetText( "" )
            local x, y, w, h = 0, 0, playerButton:GetWide(), playerButton:GetTall()
            playerButton.Paint = function( self2, w, h )
                local toScreenX, toScreenY = self2:LocalToScreen( 0, 0 )
                if( x != toScreenX or y != toScreenY ) then
                    x, y = toScreenX, toScreenY
                end

                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
                draw.NoTexture()
                BRICKS_SERVER.Func.DrawCircle( h-circleRadius, h-circleRadius, circleRadius+2, 45 )
        
                draw.NoTexture()
                if( IsValid( playerEnt ) ) then
                    surface.SetDrawColor( BRICKS_SERVER.DEVCONFIG.BaseThemes.Green )
                else
                    surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3 ) )
                end
                BRICKS_SERVER.Func.DrawCircle( h-circleRadius, h-circleRadius, circleRadius, 45 )
            end
            playerButton.DoClick = function( self2 )
                self2.Menu = vgui.Create( "bricks_server_dmenu" )

                if( not actions ) then
                    if( LocalPlayer():GangHasPermission( "ChangePlayerRoles" ) ) then
                        self2.Menu:AddOption( "Set rank", function()
                            local options = {}
                            for k, v in pairs( gangTable.Roles or {} ) do
                                options[k] = v[1]
                            end

                            BRICKS_SERVER.Func.ComboRequest( "Gang", BRICKS_SERVER.Func.L( "gangRankQuery" ), groupID, options, function( value, data ) 
                                if( (gangTable.Roles or {})[data] ) then
                                    if( groupID != data ) then
                                        net.Start( "BRS.Net.GangSetRank" )
                                            net.WriteString( v[3] )
                                            net.WriteUInt( data, 16 )
                                        net.SendToServer()
                                    else
                                        notification.AddLegacy( BRICKS_SERVER.Func.L( "gangPlayerAlreadyRank" ), 1, 3 )
                                    end
                                else
                                    notification.AddLegacy( BRICKS_SERVER.Func.L( "gangInvalidRank" ), 1, 3 )
                                end
                            end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
                        end )
                    end

                    if( LocalPlayer():GangHasPermission( "KickPlayers" ) ) then
                        self2.Menu:AddOption( BRICKS_SERVER.Func.L( "gangKick" ), function()
                            BRICKS_SERVER.Func.Query( BRICKS_SERVER.Func.L( "gangKickConfirm" ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ), BRICKS_SERVER.Func.L( "cancel" ), function() 
                                net.Start( "BRS.Net.GangKick" )
                                    net.WriteString( v[3] )
                                net.SendToServer()
                            end )
                        end )
                    end
                else
                    for k, v in pairs( actions ) do
                        self2.Menu:AddOption( v[1], v[2] )
                    end
                end

                self2.Menu:Open()
                self2.Menu:SetPos( x+w+5, y+(h*0.5)-(self2.Menu:GetTall()*0.5) )
            end
        end
    end
    self.RefreshMembers()

    local actionsBack = vgui.Create( "DPanel", bottomBack )
    actionsBack:Dock( RIGHT )
    actionsBack:SetWide( graphWide )
    actionsBack:DockPadding( 0, 35, 0, 0 )
    actionsBack.Paint = function( self2, w, h ) 
        draw.SimpleText( string.upper( BRICKS_SERVER.Func.L( "gangActions" ) ), "BRICKS_SERVER_Font21", 0, 0, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 75 ) )
    end

    local actionsScroll = vgui.Create( "bricks_server_scrollpanel", actionsBack )
    actionsScroll:Dock( FILL )

    local actions = {}

    if( LocalPlayer():GangHasPermission( "DepositMoney" ) ) then
        table.insert( actions, {
            Name = BRICKS_SERVER.Func.L( "gangDepositMoney" ),
            Color = Color( 207, 72, 72 ),
            ColorDown = BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed,
            Func = function()
                BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "gangDepositMoneyQuery" ), (BRICKS_SERVER.CONFIG.GANGS["Minimum Deposit"] or 1000), function( number ) 
                    if( (gangTable.Money or 0)+number <= BRICKS_SERVER.Func.GangGetUpgradeInfo( LocalPlayer():GetGangID(), "MaxBalance" )[1] ) then
                        if( number >= (BRICKS_SERVER.CONFIG.GANGS["Minimum Deposit"] or 1000) ) then
                            net.Start( "BRS.Net.GangDepositMoney" )
                                net.WriteUInt( number, 32 )
                            net.SendToServer()
                        else
                            BRICKS_SERVER.Func.Message( BRICKS_SERVER.Func.L( "gangDepositMoneyLess", DarkRP.formatMoney( BRICKS_SERVER.CONFIG.GANGS["Minimum Deposit"] or 1000 ) ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ) )
                        end
                    else
                        BRICKS_SERVER.Func.Message( BRICKS_SERVER.Func.L( "gangDepositMoneyMuch" ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ) )
                    end
                end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
            end
        } )
    end

    if( LocalPlayer():GangHasPermission( "WithdrawMoney" ) ) then
        table.insert( actions, {
            Name = BRICKS_SERVER.Func.L( "gangWithdrawMoney" ),
            Color = Color( 65, 190, 110 ),
            ColorDown = BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen,
            Func = function()
                BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "gangWithdrawMoneyQuery" ), (BRICKS_SERVER.CONFIG.GANGS["Minimum Withdraw"] or 1000), function( number ) 
                    if( (gangTable.Money or 0) >= number ) then
                        if( number >= (BRICKS_SERVER.CONFIG.GANGS["Minimum Withdraw"] or 1000) ) then
                            net.Start( "BRS.Net.GangWithdrawMoney" )
                                net.WriteUInt( number, 32 )
                            net.SendToServer()
                        else
                            BRICKS_SERVER.Func.Message( BRICKS_SERVER.Func.L( "gangWithdrawMoneyLess", DarkRP.formatMoney( BRICKS_SERVER.CONFIG.GANGS["Minimum Withdraw"] or 1000 ) ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ) )
                        end
                    else
                        BRICKS_SERVER.Func.Message( BRICKS_SERVER.Func.L( "gangWithdrawMoneyMuch" ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ) )
                    end
                end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
            end
        } )
    end

    if( LocalPlayer():GangHasPermission( "InvitePlayers" ) ) then
        table.insert( actions, {
            Name = BRICKS_SERVER.Func.L( "gangInvitePlayer" ),
            Func = function()
                local options = {}
                for k, v in player.Iterator() do
                    if( gangTable.Members[v:SteamID()] ) then continue end
                    
                    options[v:SteamID()] = v:Nick() .. " (" .. ((not v:IsBot() and v:SteamID()) or "BOT") .. ")"
                end
    
                BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "gangInvitePlayerQuery" ), BRICKS_SERVER.Func.L( "none" ), options, function( value, data ) 
                    if( options[data] ) then
                        net.Start( "BRS.Net.GangInvite" )
                            net.WriteString( data )
                        net.SendToServer()
                    else
                        notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidPlayer" ), 1, 3 )
                    end
                end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
            end
        } )
    end

    if( gangTable.Owner == LocalPlayer():SteamID() ) then
        table.insert( actions, {
            Name = BRICKS_SERVER.Func.L( "gangDisband" ),
            Func = function()
                BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "gangDisbandQuery", string.upper( gangTable.Name ) ), "", function( text ) 
                    if( text == string.upper( gangTable.Name ) ) then
                        net.Start( "BRS.Net.GangDisband" )
                        net.SendToServer()
                    end
                end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
            end
        } )

        table.insert( actions, {
            Name = BRICKS_SERVER.Func.L( "gangTransfer" ),
            Func = function()
                local options = {}
                for k, v in pairs( gangTable.Members ) do
                    if( (gangTable.Owner or "") == k ) then continue end

                    options[k] = v[1]
                end
    
                BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "gangTransferQuery" ), BRICKS_SERVER.Func.L( "none" ), options, function( value, data ) 
                    if( options[data] ) then
                        net.Start( "BRS.Net.GangTransfer" )
                            net.WriteString( data )
                        net.SendToServer()
                    else
                        notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidPlayer" ), 1, 3 )
                    end
                end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
            end
        } )
    else
        table.insert( actions, {
            Name = BRICKS_SERVER.Func.L( "gangLeave" ),
            Func = function()
                BRICKS_SERVER.Func.Query( BRICKS_SERVER.Func.L( "gangLeaveQuery" ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ), BRICKS_SERVER.Func.L( "cancel" ), function() 
                    net.Start( "BRS.Net.GangLeave" )
                    net.SendToServer()
                end )
            end
        } )
    end

    for k, v in pairs( actions ) do
        local action = vgui.Create( "DButton", actionsScroll )
        action:Dock( TOP )
        action:SetTall( BRICKS_SERVER.Func.ScreenScale( 50 ) )
        action:DockMargin( 0, 0, 0, BRICKS_SERVER.Func.ScreenScale( 15 ) )
        action:SetText( "" )
        local Alpha = 0
        action.Paint = function( self2, w, h ) 
            if( not self2:IsDown() and self2:IsHovered() ) then
                Alpha = math.Clamp( Alpha+5, 0, 100 )
            else
                Alpha = math.Clamp( Alpha-5, 0, 100 )
            end
        
            draw.RoundedBox( 8, 0, 0, w, h, (v.Color or BRICKS_SERVER.Func.GetTheme( 2 )) )

            surface.SetAlphaMultiplier( Alpha/255 )
            draw.RoundedBox( 8, 0, 0, w, h, (v.ColorDown or BRICKS_SERVER.Func.GetTheme( 3 )) )
            surface.SetAlphaMultiplier( 1 )

            BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, (v.ColorDown or BRICKS_SERVER.Func.GetTheme( 3 )) )

            draw.SimpleText( string.upper( v.Name ), "BRICKS_SERVER_Font21", 15, h*0.5, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 100 ), 0, TEXT_ALIGN_CENTER )
        end
        action.DoClick = v.Func
    end

    local chatBack = vgui.Create( "DPanel", bottomBack )
    chatBack:Dock( FILL )
    chatBack:DockMargin( outerMargin, 0, outerMargin, 0 )
    chatBack.Paint = function( self2, w, h ) 
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

        BRICKS_SERVER.Func.DrawPartialRoundedBox( 8, 0, 0, w, 10, BRICKS_SERVER.Func.GetTheme( 3 ), w, 20 )

        draw.SimpleText( string.upper( BRICKS_SERVER.Func.L( "gangChat" ) ), "BRICKS_SERVER_Font21", memberLeftMargin, 25, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 75 ) )
    end

    local chatMessageBack
    if( LocalPlayer():GangHasPermission( "SendMessages" ) ) then
        chatMessageBack = vgui.Create( "DPanel", chatBack )
        chatMessageBack:Dock( BOTTOM )
        chatMessageBack:DockMargin( 15, 0, 15, 15 )
        chatMessageBack:SetTall( BRICKS_SERVER.Func.ScreenScale( 40 ) )
        chatMessageBack.Paint = function( self2, w, h ) 
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
        end

        local chatMessageEntry
        local function sendChatMessage()
            if( BRICKS_SERVER.CONFIG.GANGS["Disable Gang Chat"] ) then
                BRICKS_SERVER.Func.Message( BRICKS_SERVER.Func.L( "gangMessageDisabled" ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ) )
                return
            end

            local message = chatMessageEntry:GetValue()
            if( message and message != "" ) then
                net.Start( "BRS.Net.GangSendMessage" )
                    net.WriteString( message )
                net.SendToServer()
            end

            chatMessageEntry:SetText( "" )
        end

        local chatMessageButton = vgui.Create( "DButton", chatMessageBack )
        chatMessageButton:Dock( RIGHT )
        chatMessageButton:SetWide( chatMessageBack:GetTall() )
        chatMessageButton:SetText( "" )
        local Alpha = 0
        local sendMat = Material( "bricks_server/gang_send.png" )
        chatMessageButton.Paint = function( self2, w, h ) 
            if( not self2:IsDown() and self2:IsHovered() ) then
                Alpha = math.Clamp( Alpha+5, 0, 100 )
            else
                Alpha = math.Clamp( Alpha-5, 0, 100 )
            end

            surface.SetAlphaMultiplier( Alpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )
            surface.SetAlphaMultiplier( 1 )

            BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )

            surface.SetDrawColor( 255, 255, 255, 20+(235*(Alpha/100)) )
            surface.SetMaterial( sendMat )
            local iconSize = BRICKS_SERVER.Func.ScreenScale( 24 )
            surface.DrawTexturedRect( (w*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
        end
        chatMessageButton.DoClick = sendChatMessage

        chatMessageEntry = vgui.Create( "bricks_server_search", chatMessageBack )
        chatMessageEntry:Dock( FILL )
        chatMessageEntry:DockMargin( 10, 0, 0, 0 )
        chatMessageEntry:SetFont( "BRICKS_SERVER_Font21" )
        chatMessageEntry.backFont = "BRICKS_SERVER_Font21"
        chatMessageEntry.backText = string.upper( BRICKS_SERVER.Func.L( "gangMessage" ) .. "..." )
        chatMessageEntry.backTextColor = Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 75 )
        chatMessageEntry.OnEnter = sendChatMessage
    end

    local chatScroll = vgui.Create( "bricks_server_scrollpanel_bar", chatBack )
    chatScroll:Dock( BOTTOM )
    chatScroll:DockMargin( 15, 0, 15, 15 )
    chatScroll.Paint = function( self2, w, h ) end
    local scrollH = 0
    chatScroll.pnlCanvas.Paint = function( self2, w, h ) 
        if( scrollH != h ) then
            scrollH = h
            chatScroll.VBar:AnimateTo( scrollH, 0 ) 
        end
    end

    local chatScrollMaxH = (ScrH()*0.65)-40-(2*outerMargin)-statisticsBack:GetTall()-outerMargin-60-((chatMessageBack and 55) or 0)-10

    self.chatSlots = 0
    function self.AddGangChatMessage( time, message, memberSteamID )
        self.chatSlots = self.chatSlots+1
        chatScroll:SetTall( math.min( chatScrollMaxH, chatScroll:GetTall()+((self.chatSlots % 2 == 0 and 15) or 0) ) )

        local memberTable = (gangTable.Members or {})[memberSteamID] or {}
        local groupData = (gangTable.Roles or {})[memberTable[2] or 0] or {}

        surface.SetFont( "BRICKS_SERVER_Font21" )
        local bottomTitleX, bottomTitleY = surface.GetTextSize( memberTable[1] or "NIL" )

        surface.SetFont( "BRICKS_SERVER_Font26" )
        local bottomSubTitleX, bottomSubTitleY = surface.GetTextSize( message or "" )

        surface.SetFont( "BRICKS_SERVER_Font17" )
        local timeTextX, timeTextY = surface.GetTextSize( BRICKS_SERVER.Func.FormatTimeInPlace( time ) or "" )

        local bottomTitleFullW = bottomTitleX+8+timeTextX
        local messageWidth = (2*12)+((bottomSubTitleX > bottomTitleFullW and bottomSubTitleX) or bottomTitleFullW)

        local textSpacing = -6
        local contentH = bottomTitleY+textSpacing+bottomSubTitleY

        local messageEntry = vgui.Create( "DPanel", chatScroll )
        messageEntry:Dock( TOP )
        messageEntry:DockMargin( 0, 15, math.max( 10, panelWide-(2*outerMargin)-membersBack:GetWide()-graphWide-messageWidth-30-10 ), 0 )
        messageEntry:SetTall( 60 )
        local messageWrap, lineCount
        messageEntry.Paint = function( self2, w, h ) 
            draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

            local startY = (h*0.5)-(contentH*0.5)-2

            draw.SimpleText( (memberTable[1] or "NIL"), "BRICKS_SERVER_Font21", 12, startY, (groupData[2] or BRICKS_SERVER.Func.GetTheme( 5 )) )

            if( not messageWrap ) then
                messageWrap, lineCount = BRICKS_SERVER.Func.TextWrap( message, "BRICKS_SERVER_Font26", w-24 )
                messageEntry:SetTall( 60+((lineCount-1)*bottomSubTitleY) )
                contentH = bottomTitleY+textSpacing+(lineCount*bottomSubTitleY)
                chatScroll:SetTall( math.min( chatScrollMaxH, chatScroll:GetTall()+messageEntry:GetTall() ) )
            end

            BRICKS_SERVER.Func.DrawNonParsedText( messageWrap, "BRICKS_SERVER_Font26", 12, startY+bottomTitleY+textSpacing, BRICKS_SERVER.Func.GetTheme( 6 ), 0 )

            draw.SimpleText( BRICKS_SERVER.Func.FormatTimeInPlace( time ), "BRICKS_SERVER_Font15", 12+bottomTitleX+8, startY+bottomTitleY-1, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 75 ), 0, TEXT_ALIGN_BOTTOM )
        end

        return messageEntry
    end

    function self.RefreshGangChat()
        chatScroll:Clear()
        self.chatSlots = 0

        local gangID = LocalPlayer():GetGangID()

        if( not BRS_GANG_CHATS or not BRS_GANG_CHATS[gangID] ) then return end

        local sortedMessages = table.Copy( BRS_GANG_CHATS[gangID] )
        table.SortByMember( sortedMessages, 1, true )

        for k, v in ipairs( sortedMessages ) do
            local messageEntry = self.AddGangChatMessage( v[1], v[2], v[3] )
        end
    end
    self.RefreshGangChat()

    hook.Add( "BRS.Hooks.InsertGangChat", self, function( self, messageKey )
        if( IsValid( self ) ) then
            local gangID = LocalPlayer():GetGangID()
            local messageTable = ((BRS_GANG_CHATS or {})[gangID] or {})[messageKey]

            if( not messageTable ) then return end

            self.AddGangChatMessage( messageTable[1], messageTable[2], messageTable[3] )
            surface.PlaySound( "UI/buttonclick.wav" ) 
        else
            hook.Remove( "BRS.Hooks.InsertGangChat", self )
        end
    end )

    local inboxButton = vgui.Create( "DButton", self )
    inboxButton:SetSize( BRICKS_SERVER.Func.ScreenScale( 40 ), BRICKS_SERVER.Func.ScreenScale( 40 ) )
    inboxButton:SetPos( panelWide+outerMargin-inboxButton:GetWide(), ((outerMargin+35)*0.5)-(inboxButton:GetTall()*0.5) )
    inboxButton:SetText( "" )
    local Alpha = 0
    local inboxMat = Material( "bricks_server/invite.png" )
    inboxButton.Paint = function( self2, w, h )
        if( self2:IsDown() ) then
            Alpha = 0
        elseif( self2:IsHovered() ) then
            Alpha = math.Clamp( Alpha+5, 0, 35 )
        else
            Alpha = math.Clamp( Alpha-5, 0, 35 )
        end
    
        draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )
        surface.SetAlphaMultiplier( Alpha/255 )
        draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
        surface.SetAlphaMultiplier( 1 )
    
        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 1 ) )
        surface.SetMaterial( inboxMat )
        local iconSize = BRICKS_SERVER.Func.ScreenScale( 24 )
        surface.DrawTexturedRect( (w*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
    end

    BRICKS_SERVER.Func.GangCreateInbox( self, inboxButton, false, 0, inboxButton:GetPos() )
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_gangmenu_dashboard", PANEL, "DPanel" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/submodules/achievements/vgui/bricks_server_gangmenu_achievements.lua:
local PANEL = {}

function PANEL:Init()
    self:DockMargin( 10, 10, 10, 10 )
end

function PANEL:FillPanel( gangTable )
    local categoryList = vgui.Create( "bricks_server_dcategorylist", self )
    categoryList:Dock( FILL )

    function self.RefreshPanel()
        categoryList:Clear()

        local categories = {}
        local slotTall, spacing = 80, 5

        for k, v in pairs( BRICKS_SERVER.CONFIG.GANGS.Achievements or {} ) do
            local categoryName = v.Category or BRICKS_SERVER.Func.L( "other" )
            if( not categories[categoryName] ) then
                local categoryColor = BRICKS_SERVER.Func.GetTheme( 5 )

                categories[categoryName] = categoryList:Add( categoryName, categoryColor )
                categories[categoryName]:SetTall( 40+spacing )

                local spacer = vgui.Create( "DPanel", categories[categoryName] )
                spacer:Dock( BOTTOM )
                spacer:SetTall( spacing )
                spacer.Paint = function( self2, w, h ) end
            end

            categories[categoryName]:SetTall( categories[categoryName]:GetTall()+slotTall+spacing )

            local upgradeDevConfig = BRICKS_SERVER.DEVCONFIG.GangAchievements[v.Type] or {}

            local achievementBack = vgui.Create( "DPanel", categories[categoryName] )
            achievementBack:Dock( TOP )
            achievementBack:DockMargin( spacing, spacing, spacing, 0 )
            achievementBack:SetTall( slotTall )
            achievementBack.Paint = function( self2, w, h ) 
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
            end

            local achievementIcon = vgui.Create( "DPanel", achievementBack )
            achievementIcon:Dock( LEFT )
            achievementIcon:DockMargin( 0, 0, 0, 0 )
            achievementIcon:SetWide( achievementBack:GetTall() )
            local iconMat = Material( "bricks_server/upgrades.png" )
            if( v.Icon ) then
                BRICKS_SERVER.Func.GetImage( v.Icon, function( mat ) 
                    iconMat = mat 
                end )
            end
            achievementIcon.Paint = function( self2, w, h ) 
                surface.SetDrawColor( 255, 255, 255, 255 )
                surface.SetMaterial( iconMat )
                local iconSize = 64
                surface.DrawTexturedRect( (w*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
            end

            local achievementInfo = vgui.Create( "DPanel", achievementBack )
            achievementInfo:Dock( LEFT )
            achievementInfo:DockMargin( 0, 10, 0, 10 )
            achievementInfo:SetWide( 125 )
            achievementInfo.Paint = function( self2, w, h ) 
                draw.SimpleText( (v.Name or BRICKS_SERVER.Func.L( "nil" )), "BRICKS_SERVER_Font17", 0, 5, BRICKS_SERVER.Func.GetTheme( 5 ), 0, 0 )
            end
            
            local achievementDescription = vgui.Create( "DPanel", achievementInfo )
            achievementDescription:Dock( FILL )
            achievementDescription:DockMargin( 0, 22, 0, 0 )
            achievementDescription.Paint = function( self2, w, h )
                local description = BRICKS_SERVER.Func.TextWrap( (v.Description or BRICKS_SERVER.Func.L( "noDescription" )), "BRICKS_SERVER_Font17", w )

                BRICKS_SERVER.Func.DrawNonParsedText( description, "BRICKS_SERVER_Font17", 0, 0, BRICKS_SERVER.Func.GetTheme( 6 ), 0 )
            end

            local completed = BRICKS_SERVER.Func.GangGetAchievementCompleted( LocalPlayer():GetGangID(), k )
            if( completed ) then
                local completedBack = vgui.Create( "DPanel", achievementBack )
                completedBack:Dock( RIGHT )
                completedBack:DockMargin( 0, 10, 10, 10 )
                completedBack:SetWide( achievementBack:GetTall()-20 )
                local completedMat = Material( "bricks_server/gang_upgrade_bought.png" )
                completedBack.Paint = function( self2, w, h )
                    draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

                    surface.SetDrawColor( 255, 255, 255, 20 )
                    surface.SetMaterial( completedMat )
                    local iconSize = 32
                    surface.DrawTexturedRect( (w*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
                end 
            end

            local achievementProgress = vgui.Create( "DPanel", achievementBack )
            achievementProgress:Dock( BOTTOM )
            achievementProgress:DockMargin( 5, 0, 5, 10 )
            achievementProgress:SetTall( 32 )
            local themeColor = BRICKS_SERVER.Func.GetTheme( 0 )
            local overlayColor = Color( themeColor.r, themeColor.g, themeColor.b, 125 )
            local goal = upgradeDevConfig.GetGoal( v.ReqInfo ) or 0
            achievementProgress.Paint = function( self2, w, h ) 
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

                if( not completed ) then
                    local progress = upgradeDevConfig.GetProgress( gangTable ) or 0
                    local decimal = math.Clamp( progress/goal, 0, 1 )

                    draw.RoundedBox( 5, 0, 0, w*decimal, h, overlayColor )

                    draw.SimpleText( BRICKS_SERVER.Func.L( "gangProgress", upgradeDevConfig.Format( progress, goal ) ), "BRICKS_SERVER_Font17", 10, h*0.5-1, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
                    
                    draw.SimpleText( math.floor( decimal*100 ) .. "%", "BRICKS_SERVER_Font17", w-10, h*0.5-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
                else
                    draw.RoundedBox( 5, 0, 0, w, h, overlayColor )

                    draw.SimpleText( BRICKS_SERVER.Func.L( "completed" ), "BRICKS_SERVER_Font17", 10, h*0.5-1, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
                end
            end

            local achievementNoticeBack = vgui.Create( "DPanel", achievementBack )
            achievementNoticeBack:Dock( FILL )
            achievementNoticeBack:DockMargin( 5, 10, 5, 5 )
            achievementNoticeBack.Paint = function( self2, w, h ) end
            achievementNoticeBack.AddInfo = function( text, dockRight, color )
                surface.SetFont( "BRICKS_SERVER_Font17" )
                local textX, textY = surface.GetTextSize( text )

                local upgradeReqInfo = vgui.Create( "DPanel", achievementNoticeBack )
                upgradeReqInfo:Dock( (dockRight and RIGHT) or LEFT )
                upgradeReqInfo:DockMargin( (dockRight and 5) or 0, 0, (not dockRight and 5) or 0, 0 )
                upgradeReqInfo:SetWide( textX+15 )
                upgradeReqInfo.Paint = function( self2, w, h ) 
                    draw.RoundedBox( 5, 0, 0, w, h, (color or BRICKS_SERVER.Func.GetTheme( 4 )) )

                    draw.SimpleText( text, "BRICKS_SERVER_Font17", w*0.5, h*0.5-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                end
            end

            for k, v in pairs( v.Rewards or {} ) do
                local devConfigReward = BRICKS_SERVER.DEVCONFIG.GangRewards[k]

                if( not devConfigReward ) then continue end

                achievementNoticeBack.AddInfo( devConfigReward.FormatDescription( v ), true, devConfigReward.Color )
            end
        end
    end
    self.RefreshPanel()

    hook.Add( "BRS.Hooks.RefreshGang", self, function( self, valuesChanged )
        if( IsValid( self ) ) then
            if( valuesChanged and valuesChanged["Achievements"] ) then
                self.RefreshPanel()
            end
        else
            hook.Remove( "BRS.Hooks.RefreshGang", self )
        end
    end )
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_gangmenu_achievements", PANEL, "DPanel" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/submodules/associations/shared/sh_gang_associations.lua:
function BRICKS_SERVER.Func.GangsGetAssociation( gang1, gang2 )
    if( not BRS_GANG_ASSOCIATIONS ) then return false end

    if( BRS_GANG_ASSOCIATIONS[gang1] and BRS_GANG_ASSOCIATIONS[gang1][gang2] ) then
        return BRS_GANG_ASSOCIATIONS[gang1][gang2]
    end

    if( BRS_GANG_ASSOCIATIONS[gang2] and BRS_GANG_ASSOCIATIONS[gang2][gang1] ) then
        return BRS_GANG_ASSOCIATIONS[gang2][gang1]
    end

    return false
end

function BRICKS_SERVER.Func.GangHasAssociationInvite( toGang, fromGang )
    if( BRS_GANG_INBOXES and BRS_GANG_INBOXES[toGang] ) then 
        for k, v in pairs( BRS_GANG_INBOXES[toGang] ) do
            if( istable( v ) and v.Type == "AssociationInvite" and v.ReqInfo and v.ReqInfo[1] and v.ReqInfo[1] == fromGang ) then
                return k
            end
        end
    end

    return false
end

local playerMeta = FindMetaTable("Player")
function playerMeta:GetGangAssociationWith( otherPly )
    local gang1, gang2 = self:GetGangID(), otherPly:GetGangID()

    if( not gang1 or not gang2 ) then return false end

    return BRICKS_SERVER.Func.GangsGetAssociation( gang1, gang2 )
end
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/submodules/territories/shared/sh_gang_territories.lua:
function BRICKS_SERVER.Func.GangTerritoryExists( territoryKey )
    if( territoryKey and BRS_GANG_TERRITORIES and BRS_GANG_TERRITORIES[territoryKey] ) then return BRS_GANG_TERRITORIES[territoryKey] end

    if( BRICKS_SERVER.CONFIG.GANGS.Territories[territoryKey] ) then
        if( not BRS_GANG_TERRITORIES ) then
            BRS_GANG_TERRITORIES = {}
        end

        BRS_GANG_TERRITORIES[territoryKey] = { 
            Claimed = false
        }

        return BRS_GANG_TERRITORIES[territoryKey]
    end

    return false
end
--PATH addons/__main/lua/drugs_effects/savav_acid.lua:
local mat_fb = Material( "pp/fb" )
local DRUG = "savav_acid"
--inQuad( delta, ScrH(), -ScrH() )

--[[
hook.Add( "RenderScreenspaceEffects", "DrugsREcts", function()

if LocalPlayer().Active == 1 then
	DrawColorModify( 

{
	[ "$pp_colour_addr" ] = 0,
	[ "$pp_colour_addg" ] = 0,
	[ "$pp_colour_addb" ] = 0,
	[ "$pp_colour_brightness" ] = 0,
	[ "$pp_colour_contrast" ] = 1,
	[ "$pp_colour_colour" ] = 1,
	[ "$pp_colour_mulr" ] = 0,
	[ "$pp_colour_mulg" ] = 0,
	[ "$pp_colour_mulb" ] = 0
}

	)
end

end )
-]]

hook.Add( "Think", "ThinkDrugsREct_savav_acid", function()
	if LocalPlayer().ALPHA1 != nil then  
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then
		
		if math.random(0,600) == 1 then

				LocalPlayer():ConCommand( "+jump" )
				
		elseif math.random(0,200) == 2 then	
		LocalPlayer():ConCommand( "+forward" )
			timer.Simple(0.1,function()
				LocalPlayer():ConCommand( "-forward" )
			end)
		elseif math.random(0,600) == 2 then
				LocalPlayer():SetEyeAngles(LocalPlayer():EyeAngles()+Angle(0,math.random(-90,90),0))
		else
				LocalPlayer():ConCommand( "-jump" )
				
		end
		
	end
end
	end
end)

local function MyCalcView( ply, pos, angles, fov )
	if LocalPlayer().ALPHA1 != nil then 
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then
		local view = {}

		view.origin = pos-( angles:Forward()*LocalPlayer().ALPHA1/10 )
		view.angles = angles+Angle(0,0,math.cos(CurTime()/8)*LocalPlayer().ALPHA1/4)
		view.fov = fov + LocalPlayer().ALPHA1*0.5
		view.drawviewer = false

		return view
	end
end
	end
end

hook.Add( "CalcView", "CalcViewDrugsRect_savav_acid", MyCalcView )

hook.Add( "HUDPaint", "DrugsREct_savav_acid", function()
if LocalPlayer().ALPHA1 != nil then
if LocalPlayer().Active == 0 then
if LocalPlayer().ALPHA1 > 0 then LocalPlayer().ALPHA1 = LocalPlayer().ALPHA1 - 0.05 end
if LocalPlayer().ALPHA2 > 0 then LocalPlayer().ALPHA2 = LocalPlayer().ALPHA2 - 0.05 end
end

if LocalPlayer().ALPHA1 != nil then
	if LocalPlayer().DrugType == DRUG then
	if LocalPlayer().Active == 1 then
		if LocalPlayer().ALPHA1 < 255 then LocalPlayer().ALPHA1 = LocalPlayer().ALPHA1 + 0.05 end
	if !LocalPlayer():Alive() then
	LocalPlayer().MUSIC:ChangePitch( 0, 60 )
	LocalPlayer().MUSIC:ChangeVolume( 0, 100 )
	LocalPlayer().Active = 0
	end
	end



	for i=1,35 do

	local Cos = math.cos(i*0.5) * LocalPlayer().ALPHA1*2
	local Sin = math.sin(i*0.5) * LocalPlayer().ALPHA1*2
	local Sinonius = math.cos(CurTime())* LocalPlayer().ALPHA1/15
	local Cosonius = math.sin(CurTime())* LocalPlayer().ALPHA1/15

		surface.SetDrawColor( 255, 255, 255, ( LocalPlayer().ALPHA1/2.1 )/(i/10) )
		surface.SetMaterial( mat_fb	) 
		surface.DrawTexturedRect( Cos-Cosonius, (Sin-Sinonius), ScrW(), ScrH() )
	end

		surface.SetDrawColor( math.sin(CurTime())*255, 255, -math.cos(CurTime())*255, ( LocalPlayer().ALPHA1*0.5 ) )
		surface.DrawRect( 0, 0, ScrW(), ScrH() )

		if LocalPlayer().ALPHA1 <= 0 then

			LocalPlayer().DrugType = "0"
				LocalPlayer().MUSIC:Stop()
			
		end
end

	end
end
end )


local function DrugEffect_savav_acid(data)



if LocalPlayer().Active == 0 or LocalPlayer().Active == nil then
LocalPlayer().DrugType = data:ReadString()
LocalPlayer().Active = 1
LocalPlayer().ALPHA1 = 0
LocalPlayer().ALPHA2 = 0


LocalPlayer().MUSIC = CreateSound( LocalPlayer(), "MIBD.wav" )

LocalPlayer().MUSIC:Play()
LocalPlayer().MUSIC:ChangePitch( 0, 0 )
LocalPlayer().MUSIC:ChangeVolume( 0, 0 )
LocalPlayer().MUSIC:ChangePitch( 100, 25 )
LocalPlayer().MUSIC:ChangeVolume( 0.4, 6 )

timer.Simple(80,function()

LocalPlayer().MUSIC:ChangePitch( 0, 160 )
LocalPlayer().MUSIC:ChangeVolume( 0, 200 )
LocalPlayer().Active = 0


end)

end

end


local function DrugEffect_WATER(data)
LocalPlayer().Active = 0
end

usermessage.Hook("DrugEffect_WATER", DrugEffect_WATER ) 
usermessage.Hook("DrugEffect_savav_acid", DrugEffect_savav_acid ) 
 
--PATH addons/__main/lua/autorun/client/cl_snow.lua:
function SnowActivate()
    CreateClientConVar( 'falling_snow', '1' )
    local emitter = ParticleEmitter( Vector(), false )
    local spawned = false
    local mat_whitelist = {
        ['grass'] = true,
        ['dirt'] = true,
        ['paper'] = true,
        ['antlionsand'] = true,
        ['building_template/roof_template001a'] = true,
        ['metal/metalroof006a'] = true,
        ['concrete/concretewall001a'] = true,
        ['concrete/concretefloor031a'] = true,
        ['metal/metalroof008a'] = true,
        ['metal/metalroof005a'] = true,
        ['metal/metalroof004a'] = true,
        ['tile/infroofb'] = true,
        ['metal/milroof002'] = true,
        ['cs_italy/tileroof01'] = true,
    }

    for _, v in ipairs( game.GetWorld():GetBrushSurfaces() ) do
        local mat_surfaceprop = string.lower( v:GetMaterial():GetString( '$surfaceprop' ) or '' )
        local mat_basetexture = string.lower( v:GetMaterial():GetString( '$basetexture' ) or '' )
        --
        if mat_whitelist[mat_surfaceprop] or mat_whitelist[mat_basetexture] then
            v:GetMaterial():SetTexture( '$basetexture', 'nature/snowfloor001a' )
            v:GetMaterial():SetTexture( '$basetexture2', 'nature/snowfloor001a' )
            v:GetMaterial():SetVector( '$color2', Vector( 0.6, 0.6, 0.6 ) )
        end
    end

    Material( 'infmap/flatgrass' ):SetTexture( '$basetexture', 'nature/snowfloor001a' )
    Material( 'infmap/flatgrass' ):SetVector( '$color2', Vector( 0.75, 0.75, 0.75 ) )
    spawned = true
    hook.Add( 'Think', 'snow_spawn', function()
        if not util.IsSkyboxVisibleFromPoint( EyePos() ) or not spawned then return end
        --
        for _ = 1, 10 do
            local startpos = EyePos() + Vector( math.Rand( -3000, 3000 ), math.Rand( -3000, 3000 ), math.Rand( 1000, 2000 ) )
            local particle = emitter:Add( 'particle/particle_glow_04', startpos )
            if particle then
                local tr = util.QuickTrace( startpos, Vector( 0, 0, -2000 ) ).HitPos
                local dietime = ( startpos[3] - tr[3] ) * 0.0035
                particle:SetDieTime( math.min( dietime, 10 ) )
                --
                particle:SetStartAlpha( 255 )
                particle:SetEndAlpha( 255 )
                particle:SetAirResistance( 120 )
                --
                local flake_size = math.Rand( 5, 10 )
                particle:SetStartSize( flake_size )
                particle:SetEndSize( flake_size )
                --
                particle:SetGravity( Vector( 0, 0, -600 ) )
                particle:SetVelocity( Vector( 0, 0, -600 ) )
                particle:SetNextThink( CurTime() )
            end
        end
    end )

    local function calc_fog( mult )
        render.FogStart( 0 )
        render.FogMaxDensity( 1 )
        render.FogColor( 240, 240, 240 )
        render.FogEnd( 20000 * ( mult or 1 ) )
        render.FogMode( MATERIAL_FOG_LINEAR )
        return true
    end

    hook.Add( 'SetupWorldFog', '!snowfog', calc_fog )
    hook.Add( 'SetupSkyboxFog', '!snowfog', calc_fog )
end
--PATH addons/unbox/lua/unbox/spinner.lua:
// VguiClass: Unbox Spin animation

if debug.getinfo( 1 ).short_src == "Joch<spinner.lua>" then
	include( "autorun/client/cl_unboxing_2.lua" )
	return
end

local ModelPanel = (...).ModelPanel
local generateTape = (...).generateTape
local frameColor = (...).frameColor
local gradientL = Material( "vgui/gradient-l.vmt", "smooth noclamp" )
local gradientR = Material( "vgui/gradient-r.vmt", "smooth noclamp" )

local lastTick = 0
local function PlayTick( )
	if lastTick > CurTime( ) - 0.05 then
		return
	end
	lastTick = CurTime( )
	LocalPlayer( ):EmitSound("ub_tick.wav")
end

return {
	Base = "DHorizontalScroller",
	Init = function( self )
		self:SetOverlap( -6 )
		self:SetShowDropTargets( false )
		self.btnRight.Paint=nil
		self.btnLeft.Paint=nil

		self:SetMouseInputEnabled( false )
		self.OnMouseWheeled = nil

		self.Finished = true
	end,
	SetID = function( self, id )
		self.ID = id

		self:SetScroll( 0 )
		self:GenerateTape( )
	end,
	GenerateTape = function( self )
		self.Items = {}
		local tape = generateTape( self.ID )

		for k,id in pairs( tape ) do
			local p = vgui.CreateFromTable( ModelPanel )
			p:SetWide( 100 )
			p:Set( id )
			self.Items[ k ] = p
			self:AddPanel( p )
		end
	end,
	ScrollTo = function( self, panel )
		self:InvalidateLayout( true )

		local x, y = self.pnlCanvas:GetChildPosition( panel )
		local w, h = panel:GetSize()

		x = x + w * 0.5
		x = x - self:GetWide() * 0.5 + math.random( -w * 0.5 + 3, w * 0.5 - 2 )

		self.ResultScroll = x
	end,
	Think = function( self )
		if self.Finished then return end

		local scroll = self.OffsetX


		if self.ResultScroll - scroll < 1 then
			self.Finished = true
			if self.OnFinish then
				self:OnFinish( )
			end
		else
			local num = (scroll / (100))
			local float = num % 1
			if float > 0.6 and float < 0.7 then
				local int = math.floor( num )
				if self.LastSound ~= int then
					self.LastSound = int
					PlayTick( )
				end
			end
			self:SetScroll( Lerp( 0.01, scroll, self.ResultScroll ) )
		end
	end,
	OnFinish = function( self )
		//print("finished!")
	end,
	PaintOver = function( self, w, h )
		draw.RoundedBox( 0, w*0.5 - 1, 0, 2, h, Color( 255,140, 0, 150 ) )
		
		surface.SetDrawColor( frameColor )

		local size = w/6

		for i = 1, 4 do // make it darker

			surface.SetMaterial( gradientL )
			surface.DrawTexturedRect(0,0,size,h)

			surface.SetMaterial( gradientR )
			surface.DrawTexturedRect(w - size + 1,0,size,h)

		end
	end,
	DoSpin = function( self, winID )
		local slotID = math.floor( table.Count( self.Items ) * .75 )
		local panel = self.Items[ slotID ]
		if not panel or not IsValid( panel ) then return end

		panel:Set( winID )

		self.tim = 0
		self.Finished = false
		self:ScrollTo( panel )
	end
}
--PATH addons/_outfitter/lua/autorun/client/isdormant.lua:
require'isdormant'
--PATH addons/_outfitter/lua/autorun/client/webbrowser.lua:
local Tag = 'custombrowser'
-- javascript hacks
local fixselect = [[
(function() {
if (document.getElementsByTagName("select").length>0) {

    if (!window.jQuery) {
        var script = document.createElement("SCRIPT");
        script.src = 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js';
        script.type = 'text/javascript';
        document.getElementsByTagName("head")[0].appendChild(script);
    }
    var checkReady = function(callback) {
        if (window.jQuery) {
            callback(jQuery);
        } else {
            window.setTimeout(function() {
                checkReady(callback);
            }, 100);
        }
    };

    checkReady(function($) {

        (function($) {
            console.log("loaded jquery");
            var script = document.createElement("SCRIPT");
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.0-rc.2/js/select2.min.js';
            script.type = 'text/javascript';
            document.getElementsByTagName("head")[0].appendChild(script);


            var head = document.getElementsByTagName('head')[0];
            var link = document.createElement('link');
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = 'https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.0-rc.2/css/select2.min.css';
            link.media = 'all';
            head.appendChild(link);

            var checkReady = function(callback) {
                if ($.fn.select2 == null) {
                    window.setTimeout(function() {
                        checkReady(callback);
                    }, 100);
                } else {
                    callback();
                }
            };

            checkReady(function() {
                console.log("loaded select2");
                $('select').select2();
                console.log("injected select replacement");
            });
        })($);



    });

};

})();

]]
local PANEL = {}

function PANEL:Init()
	self.firstload = true
	self:SetVisible(false)
	self:SetSize(ScrW() * 0.9, ScrH() * 0.8)
	self:Center()
	self:SetTitle("Web Browser")
	self:SetDeleteOnClose(false)
	self:ShowCloseButton(true)
	self:SetDraggable(true)
	self:SetSizable(true)

	if self.btnMinim then
		self.btnMinim:SetDisabled(false)

		self.btnMinim.DoClick = function()
			self:SetVisible(false)
		end
	end

	if self.btnMaxim then
		self.btnMaxim:SetDisabled(false)

		self.btnMaxim.DoClick = function()
			self:SetSize(ScrW(), ScrH())
			self:Center()
		end
	end

	local top = vgui.Create("EditablePanel", self)
	self.top = top
	top:Dock(TOP)
	top:SetTall(24)
	local PreviousIcon = "icon16/arrow_left.png"
	local NextIcon = "icon16/arrow_right.png"
	local btn = vgui.Create("DButton", self.top)
	btn:SetText("")
	btn:SetSize(24, 24)
	btn:SetIcon(PreviousIcon)
	btn:Dock(LEFT)

	function btn.DoClick()
		self.browser:GoBack()
		--self.browser:RunJavascript[[history.back();]]
	end

	local btn = vgui.Create("DButton", self.top)
	btn:SetText("")
	btn:SetSize(24, 24)
	btn:SetIcon(NextIcon)
	btn:Dock(LEFT)

	function btn.DoClick()
		self.browser:GoForward()
		--self.browser:RunJavascript[[history.forward();]]
	end

	local entry = vgui.Create("DTextEntry", top)
	self.entry = entry
	entry:Dock(FILL)
	entry:SetTall(24)

	function entry.OnEnter(entry)
		local val = entry:GetText()
		local js, txt = val:match("javascript:(.+)")

		if js and txt then
			self.browser:QueueJavascript(txt)

			return
		end

		self:OpenURL(val)
		self.browser:RequestFocus()
	end

	local btn = vgui.Create("DButton", self.top)
	btn:SetText("")
	btn:SetSize(24, 24)
	btn:Dock(LEFT)

	function btn.DoClick()
		if self.browser:IsLoading() then
			self.browser:StopLoading()
		else
			self.browser:Refresh(true) --RunJavascript[[location.reload(true);]]
		end
	end

	local RefreshIcon = Material("icon16/arrow_refresh.png")
	local CancelIcon = Material("icon16/cross.png")

	btn.Paint = function(btn, w, h)
		DButton.Paint(btn, w, h)

		if not self.browser:IsLoading() then
			surface.SetDrawColor(255, 255, 255, 255)
			surface.SetMaterial(RefreshIcon)
			surface.DrawTexturedRect(btn:GetWide() * 0.5 - 16 * 0.5, btn:GetTall() * 0.5 - 16 * 0.5, 16, 16)
		else
			surface.SetDrawColor(255, 255, 255, 255)
			surface.SetMaterial(CancelIcon)
			surface.DrawTexturedRect(btn:GetWide() * 0.5 - 16 * 0.5, btn:GetTall() * 0.5 - 16 * 0.5, 16, 16)
		end
	end

	local btn = vgui.Create("DButton", self.top)
	btn:SetText("")
	btn:SetSize(24, 24)
	btn:SetIcon("icon16/script_gear.png")
	btn:Dock(RIGHT)

	function btn.DoClick()
		self.browser:RunJavascript[[var s = document.documentElement.outerHTML; document.write('<html><body><textarea id="dsrc" style="width: 100%; height: 100%;"></textarea></body></html>');  var ta=document.getElementById( 'dsrc'); ta.value=s; void 0;]]
	end

	local browser = vgui.Create("DHTML", self)
	self.browser = browser
	browser:Dock(FILL)
	browser.Paint = function() end
	browser:SetFocusTopLevel(true)

	browser.OnChangeTitle = function(browser, title)
		self:SetTitle(title and title ~= "" and title or "Web browser")
	end

	browser.OnChangeTargetURL = function(browser, url)
		self:StatusChanged(url)
	end

	browser.OnChildViewCreated = print

	browser.OnBeginLoadingDocument = function(browser, url)
		self.loaded = false
		self.entry:SetText(url)
	end

	browser.OnFinishLoadingDocument = function(browser, url)
		self.loaded = true
	end

	browser.OnDocumentReady = function(browser, url)
		self:_InjectScripts(browser)

		if self.InjectScripts then
			self:InjectScripts(browser)
		end

		self.url = url
		self:LoadedURL(url)
		self.entry:SetText(url)
	end

	browser:AddFunction("gmod", "dbg", function(...)
		Msg"[Browser] "
		print(...)
	end)

	browser:AddFunction("console", "info", function(...)
		Msg"[Browser] "
		print(...)
	end)

	browser:AddFunction("gmod", "status", function(txt)
		if txt ~= "" then
			print("status", txt)
		end

		self:StatusChanged(txt)
	end)

	browser:AddFunction("gmod", "reqtoken", function()
		if not GetAuthToken then
			local s = ([[if ('OnAuthToken' in window) { OnAuthToken(false); };]])

			if browser:IsValid() and not browser:IsLoading() then
				browser:QueueJavascript(s)
			end

			return
		end

		Derma_Query("Do you want to send your auth token to this website?", "Auth Token", "Yes", function()
			GetAuthToken(function(dat)
				local s = ([[if ('OnAuthToken' in window) { OnAuthToken("%s"); };]]):format(string.JavascriptSafe(dat))

				if browser:IsValid() and not browser:IsLoading() then
					browser:QueueJavascript(s)
				end
			end)
		end, "No", function() end)
	end)

	browser.ActionSignal = function(...)
		Msg"[BrowserACT] "
		print(...)
	end

	browser.OnKeyCodePressed = function(browser, code)
		if code == KEY_F5 then
			self.browser:RunJavascript[[location.reload(true);]]

			return
		end
	end

	--print("BROWSERKEY",code)
	local status = vgui.Create("DLabel", self)
	self.status = status
	status:SetText""
	status:Dock(BOTTOM)
end

function PANEL:StatusChanged(txt)
	if self.statustxt ~= txt then
		self.statustxt = txt
		self.status:SetText(txt or "")
	end
end

function PANEL:LoadedURL()
end

function PANEL:OpenURL(url)
	self.browser:StopLoading()
	self.browser:OpenURL(url)
	self.entry:SetText(url)

	if self.firstload then
		self.firstload = nil
	end
end

function PANEL:Think(w, h)
	DFrame.Think(self, w, h)

	if input.IsKeyDown(KEY_ESCAPE) then
		if self.firstload then
			self:Close()
		else
			self:SetVisible(false)
		end

		if gui and gui.HideGameUI then
			gui.HideGameUI()
		end
	end

	if not self.wasloading and self.browser:IsLoading() then
		self.wasloading = true
	end

	if self.wasloading and not self.browser:IsLoading() then
		self.wasloading = false
	end
end

function PANEL:GetBrowser()
	return self.browser
end

function PANEL:_InjectScripts(browser)
	browser:QueueJavascript[[function alert(str) { console.log("Alert: "+str); }]]
	browser:QueueJavascript(fixselect)
	-- fix links and background transparency problems
	browser:QueueJavascript[[
		setTimeout(function() {
			document.documentElement.style.backgroundColor = 'white';
		}, 0);
		
		setTimeout(function() {
			  var elems = document.getElementsByTagName("a");
				for (var i = 0; i < elems.length; i++) {
					var dat = elems[i]['target'];
					if (dat == "_blank" || dat == "_parent"|| dat == "_top") {
						elems[i]['target'] = "_self";
					}
				}
		}, 0);
		
	]]
	browser:QueueJavascript[[
		function getLink() {
			gmod.status(this.href || "-");
		}
		function clickLink() {
			gmod.status("Loading...");
		}
		function killstatus() {
			gmod.status("");
		}
		var links = document.getElementsByTagName("a");
		for (i = 0; i < links.length; i++) {
			links[i].addEventListener('mouseover',getLink,false);
			links[i].addEventListener('mouseout',killstatus,false);
			links[i].addEventListener('click',clickLink,false);
		}

	]]
end

function PANEL:Show()
	if not self:IsVisible() then
		self:SetVisible(true)
		self:MakePopup()
		self:SetKeyboardInputEnabled(true)
		self:SetMouseInputEnabled(true)
	end

	if ValidPanel(self.browser) then
		self.browser:RequestFocus()
	end
	--hook.Run("OnContextMenuOpen")
	--print(self.browser.URL)
end

function PANEL:Close()
	self:SetVisible(false)
	self:Remove()
	--hook.Run("OnContextMenuClose")
end

vgui.Register(Tag, PANEL, "DFrame")
local webbrowser_panel

function _G.GetWebBrowserPanel()
	return webbrowser_panel
end

local function HidePanel()
	webbrowser_panel:Close()
end

local function ShowPanel(url)
	local new = false

	if not ValidPanel(webbrowser_panel) then
		new = true
		webbrowser_panel = vgui.Create(Tag)
		--_G.p=webbrowser_panel
	end

	webbrowser_panel:Show()

	if url and url ~= "" then
		webbrowser_panel:OpenURL(url)
	else
		if new then
			webbrowser_panel.entry:RequestFocus()
		end
	end

	return webbrowser_panel
end

local webbrowser_enabled = CreateClientConVar("webbrowser_enabled", "0", true)
local mediaurls = {"mp4"} -- File extensions that shouldn't be opened with ingame browser.
gui.OLDOpenURL = gui.OLDOpenURL or gui.OpenURL

function gui.OpenURL(url, useold)
	local extension = url:match(".+%.(.-)%s*$")
	if not webbrowser_enabled:GetBool() or useold or table.HasValue(mediaurls, extension) then return gui.OLDOpenURL(url) end
	local browser = ShowPanel(url)

	return browser.browser, browser
end

function gui.OpenURLIngame(url)
	local extension = url:match(".+%.(.-)%s*$")

	if table.HasValue(mediaurls, extension) then
		error"invalid url"
	end

	local browser = ShowPanel(url)

	return browser.browser, browser
end

local function webbrowser(a, b, c, line)
	local url = line:gsub('^%"', ""):gsub('%"$', "")
	ShowPanel(url)
end

concommand.Add("webbrowser", webbrowser, nil)
concommand.Add("browser", webbrowser, nil)
concommand.Add("open", webbrowser, nil)
local webbrowser_f1_open = CreateClientConVar("webbrowser_f1_open", "1", true)
local f1key = input.LookupKeyBinding(KEY_F1)

local rec

local webbrowser = _G.webbrowserbutton or {}
_G.webbrowserbutton = webbrowser

function webbrowser:CreateContextMenuButton(iconlayout)
	local container = iconlayout:Add("DPanel")
	container:SetSize(128, 32)
	container.webbrowserbutton = true
	local txt = container:Add("DTextEntry")
	txt:SetPlaceholderText("Web Browser")
	txt:SetText""
	txt:Dock(FILL)

	txt.OnEnter = function()
		gui.OpenURLIngame(txt:GetText())
		txt:SetText""
	end

	local button = container:Add("DImageButton")
	button:SetImage("icon16/world_go.png")
	button:Dock(RIGHT)
	button:SetWidth(container:GetTall() - 8)
	button:DockMargin(4, 4, 4, 4)

	button.DoClick = function()
		gui.OpenURLIngame(txt:GetText())
	end

	return container
end

function webbrowser:GetContextMenuButton(iconlayout)
	local contextbutton = nil

	for i = 0, iconlayout:ChildCount() do
		local child = iconlayout:GetChild(i)

		if IsValid(child) and child.webbrowserbutton then
			contextbutton = child
			break
		end
	end

	return contextbutton
end

--forcefully removes it in case it fucks up
function webbrowser:RemoveContextMenuButton(iconlayout, buttonpanel)
	if IsValid(buttonpanel) then
		buttonpanel:Remove()
	end
end

function webbrowser:GetContextMenuLayout()
	if not IsValid(g_ContextMenu) then return end
	local iconlayout = nil

	for i = 0, g_ContextMenu:ChildCount() do
		local child = g_ContextMenu:GetChild(i)

		if IsValid(child) and child:GetName() == "DIconLayout" then
			iconlayout = child
			break
		end
	end

	return iconlayout
end

function webbrowser:HandleContextMenuButton(docleanup)
	local iconlayout = self:GetContextMenuLayout()
	if not IsValid(iconlayout) then return end
	local buttonpanel = self:GetContextMenuButton(iconlayout)

	if IsValid(buttonpanel) and docleanup then
		self:RemoveContextMenuButton(iconlayout, buttonpanel)
		iconlayout:InvalidateLayout()
	end

	if not IsValid(buttonpanel) then
		self:CreateContextMenuButton(iconlayout)
		iconlayout:InvalidateLayout()
	end
end

hook.Add("ContextMenuCreated", "webbrowserbutton", function()
	webbrowserbutton:HandleContextMenuButton(true)
end)

--PATH addons/__________scripts__loader/lua/scriptssss/_server_1/sh_jobs.lua:
-- [id] = {
--     [steamid] = true
-- }
local tbljobs_access = {
    ["niggfwfesssr"] = {
        ["STEAM_0:0:450137406"] = true,
        ["STEAM_0:1:120409042"] = true,
        ["STEAM_0:0:597860585"] = true,
        ["STEAM_0:1:636396089"] = true,
        ["STEAM_0:0:566244461"] = true,
        ["STEAM_0:1:760005561"] = true,
        ["STEAM_0:0:649878040"] = true,
        ["STEAM_0:1:551756931"] = true,
        ["STEAM_0:1:544527523"] = true,
        ["STEAM_0:1:704050139"] = true,
        ["STEAM_0:1:625769413"] = true,
        ["STEAM_0:1:456755552"] = true,
        ["STEAM_0:0:704419021"] = true,
    },
    ["nigaaaaaaaaaaaaaa33gfwfesssr"] = {
        ["STEAM_0:0:220004443"] = true,
    },
    ["niggfwfesssr6645645tedgdfgr"] = {
        ["STEAM_0:0:184853533"] = true,
        ["STEAM_0:1:580123290"] = true,
        ["STEAM_0:1:760005561"] = true,
        ["STEAM_0:1:625769413"] = true,
    },
    ["niggfwfesssr221232142"] = {
        ["STEAM_0:1:626248835"] = true,
        ["STEAM_0:1:469562433"] = true,
        ["STEAM_0:1:569511267"] = true,
        ["STEAM_0:0:566244461"] = true,
        ["STEAM_0:0:709551420"] = true,
        ["STEAM_0:1:608196074"] = true,
    },
    ["niggfwfesssr22"] = {
        ["STEAM_0:0:739134032"] = true,
        ["STEAM_0:1:242255701"] = true,
        ["STEAM_0:1:193129981"] = true,
    },
    ["niggfwfesssr223"] = {
        ["STEAM_0:0:651957902"] = true,
        ["STEAM_0:0:679144329"] = true,
        ["STEAM_0:1:512233896"] = true,
        ["STEAM_0:1:536163323"] = true,
        ["STEAM_0:1:174206189"] = true,
        ["STEAM_0:1:627296059"] = true,
    },
    ["nigg4324234fwfesssr1"] = {
        ["STEAM_0:0:184853533"] = true,
        ["STEAM_0:0:63554495"] = true
    },
    ["nigg4324234fwfesssr1131235655555"] = {
        ["STEAM_0:1:613568329"] = true,
        ["STEAM_0:0:450137406"] = true,
        ["STEAM_0:0:121551094"] = true
    },
    ["niggfwfesssr1"] = {
        ["STEAM_0:0:725906019"] = true,
        ["STEAM_0:1:477858912"] = true,
        ["STEAM_0:0:566244461"] = true,
        ["STEAM_0:1:600476323"] = true,
        ["STEAM_0:0:643390253"] = true,
        ["STEAM_0:1:519322911"] = true,
        ["STEAM_0:1:572887546"] = true,
        ["STEAM_0:0:709551420"] = true,
        ["STEAM_0:0:556211243"] = true,
        ["STEAM_0:1:640957612"] = true,
    },
    ["niggfwfesssr2"] = {
        ["STEAM_0:0:673247761"] = true,
        ["STEAM_0:0:814015599"] = true,
        ["STEAM_0:0:599174076"] = true,
        ["STEAM_0:0:593033373"] = true,
        ["STEAM_0:0:441605243"] = true,
        ["STEAM_0:0:587185454"] = true,
    },
    ["niggfwfesssr23212sdas4"] = {
        ["STEAM_0:0:508183961"] = true,
        ["STEAM_0:1:650549758"] = true,
        ["STEAM_0:0:650549758"] = true,
        ["STEAM_0:0:31516481"] = true,
        ["STEAM_0:1:640957612"] = true,
        ["STEAM_0:1:606750788"] = true,
        ["STEAM_0:1:535281143"] = true,
        ["STEAM_0:0:632225562"] = true,
        ["STEAM_0:0:566244461"] = true,
        ["STEAM_0:0:220004443"] = true,
        ["STEAM_0:0:173289826"] = true,
        ["STEAM_0:0:121551094"] = true,
        ["STEAM_0:0:689568435"] = true,
        ["STEAM_0:1:600665265"] = true,
        ["STEAM_0:0:215047514"] = true,
    },
    ["niggfwfesssr23323232323322sdas4"] = {
        ["STEAM_0:0:173289826"] = true,
    },
    ["niggfwfesssr3"] = {
        ["STEAM_0:0:220004443"] = true,
        ["STEAM_0:1:564249355"] = true,
        ["STEAM_0:1:456755552"] = true,
    },
    ["ADMI3WWWdadtW"] = {
        ["STEAM_0:0:79383715"] = true,
    },
    ["TEAM_ADMIPENIs2424g"] = {
        ["STEAM_0:1:14253376"] = true,
        ["STEAM_0:0:609543932"] = true,
        ["STEAM_0:0:456048053"] = true,
        ["STEAM_0:1:564249355"] = true,
        ["STEAM_0:0:590511782"] = true,
        ["STEAM_0:0:651957902"] = true,
    },
    ["kamadotanjiro"] = {
        ["STEAM_0:1:600665265"] = true,
    },
    ["YagamiLait"] = {
        ["STEAM_0:1:595522442"] = true,
    },
    ["ClausMadson"] = {
        ["STEAM_0:0:629004634"] = true,
    },
    ["Tron"] = {
        ["STEAM_0:0:739134032"] = true,
    },
    ["Immortal"] = {
        ["STEAM_0:1:526747865"] = true,
        ["STEAM_0:1:774738694"] = true,
    },
    ["Grimdjou"] = {
        ["STEAM_0:1:525613911"] = true,
    },
}

TEAM_ADMI3qwfqwN = rp.AddTeam( "Ітачі", {
    Color = Color( 0, 0, 0, 255 ),
    Model = { "models/itachianbu/itachianbu.mdl" },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Герой аніме, якого було визнано небезпечним злочинцем.
        Член злочинної організації Акацукі.;

    ]],
    Weapons = {},
    Command = "niggfwfesssr",
    Max = 10,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    hitman = true,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 200 )
        ply:SetHealth( 200 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqw12312321AAAaN = rp.AddTeam( "Блудний лицар", {
    Color = Color( 255, 0, 0, 255 ),
    Model = { "models/epangelmatikes/revan/revan_opt.mdl" },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Персонаж із розширеного всесвіту "Зоряних війн".
        Джедай, який боровся в Мандалорських війнах.;

    ]],
    Weapons = {},
    Command = "nigaaaaaaaaaaaaaa33gfwfesssr",
    Max = 10,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["nigaaaaaaaaaaaaaa33gfwfesssr"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["nigaaaaaaaaaaaaaa33gfwfesssr"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwNYASD44 = rp.AddTeam( "Рюк", {
    Color = Color( 230, 230, 250, 255 ),
    Model = { "models/konnie/jumpforce/ryuk.mdl" },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Герой аніме, який є один з богів смерті.
        Для продовження свого життя йому потрібно було вбивати смертних за допомогою зошита смерті.

    ]],
    Weapons = { "death_note" },
    Command = "niggfwfesssr6645645tedgdfgr",
    Max = 10,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    hitman = true,
    Armor = 200,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 200 )
        ply:SetHealth( 200 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr6645645tedgdfgr"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr6645645tedgdfgr"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN223336 = rp.AddTeam( "Работоргівець", {
    Color = Color( 143, 38, 78, 255 ),
    Model = { "models/jazzmcfly/kantai/iowa/iowa.mdl" },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Людина яка грабує людей, та продає їх для заробітку.
    ]],
    Weapons = { "weapon_cuff_rope" },
    Command = "niggfwfesssr221232142",
    Max = 10,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 150,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
        ply:SetArmor( 150 )
        ply:SetMaxArmor( 150 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr221232142"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr221232142"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN22 = rp.AddTeam( "Мадара Учіха", {
    Color = Color( 0, 0, 0, 255 ),
    Model = { "models/player/naruto/madara.mdl" },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Герой аніме, легендарний лідер клану Учіха.;

    ]],
    Weapons = { "weapon_amaterasu" },
    Command = "niggfwfesssr22",
    Max = 10,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr22"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr22"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN223 = rp.AddTeam( "Авторитет", {
    Color = Color( 126, 5, 177, 255 ),
    Model = { "models/kuma96/codmw/characters/velikan/velikan_pm.mdl" },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Авторитет в кримінальному світі, сильний та впевнений.

    ]],
    Weapons = {},
    Command = "niggfwfesssr223",
    Max = 10,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 200,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 200 )
        ply:SetHealth( 200 )
        ply:SetArmor( 200 )
        ply:SetMaxArmor( 200 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr223"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr223"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN1 = rp.AddTeam( "Baby Yoda", {
    Color = Color( 0, 255, 0, 255 ),
    Model = { "models/kaesar/baby_yoda/baby_yoda.mdl", },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Популярний персонаж "Зоряних війн".
        Маленьке дитинча яке хотіло досліджувати світ.

    ]],
    Weapons = {},
    Command = "nigg4324234fwfesssr1",
    Max = 0,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
        ply:SetArmor( 0 )
        ply:SetMaxArmor( 0 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["nigg4324234fwfesssr1"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["nigg4324234fwfesssr1"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN11231234444 = rp.AddTeam( "Tails", {
    Color = Color( 255, 255, 0, 255 ),
    Model = { "models/player/tails.mdl", },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Персонаж ігор та мультфільмів "Sonic the Hedgehog".
        Скромне добродушне лисеня яке мріє стати як Сонік.

    ]],
    Weapons = { "weapon_amaterasu" },
    Command = "nigg4324234fwfesssr1131235655555",
    Max = 0,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 150,
    Police = true,
    hasLicense = true,
    nocuff = true,
    Spawn = rp.Setting.PoliceSpawn,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
        ply:SetArmor( 150 )
        ply:SetMaxArmor( 150 )
        ply:SetRunSpeed( rp.Setting.DefaultSpeedRun + 75 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["nigg4324234fwfesssr1131235655555"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["nigg4324234fwfesssr1131235655555"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN1 = rp.AddTeam( "Neco Arc", {
    Color = Color( 255, 0, 0, 255 ),
    Model = { "models/mocha/necoarc/necoarc.mdl", "models/mocha/necoarcchaos/necoarcchaos.mdl", },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Неко-дух , що з"являється в серії "Tsukihime".
        Є членом раси Неко-духів, яка мріє щоб всі думали що вона розумна.

    ]],
    Weapons = { "weapon_357" },
    Command = "niggfwfesssr1",
    Max = 0,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 100,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr1"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr1"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN2 = rp.AddTeam( "Ассасин", {
    Color = Color( 255, 255, 255, 255 ),
    Model = { "models/player/altair_ibnlaahad.mdl" },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Майстер Ассассін і наставник із сирійського Братства Ассассінів.
        Нахабний та грубий до своїх побратимів.

    ]],
    Weapons = {},
    Command = "niggfwfesssr2",
    Max = 10,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 100,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 200 )
        ply:SetHealth( 200 )
        ply:SetArmor( 150 )
        ply:SetMaxArmor( 150 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr2"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr2"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN2553443a = rp.AddTeam( "Імп", {
    Color = Color( 0, 0, 0, 255 ),
    Model = { "models/custom/cmankarthecat/helluvaboss/moxxie_pm.mdl", "models/player/blitzo_character/blitzo_pm/blitzo_pm.mdl" },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Кіллер з агенства "Кілери-біса".
        Займається вбивством людей на Землі, які тим чи іншим чином змогли якось досадити грішникам, що потрапили в Пекло.

    ]],
    Weapons = { "weapon_amaterasu" },
    Command = "niggfwfesssr23212sdas4",
    Max = 10,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 100,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
        ply:SetArmor( 150 )
        ply:SetMaxArmor( 150 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr23212sdas4"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr23212sdas4"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN25535533543a = rp.AddTeam( "ЧБД", {
    Color = Color( 255, 200, 0 ),
    Model = { "models/player/funnyrat/rat.mdl" },
    Description = [[

            ПРИВАТНА ПРОФЕСІЯ

            Просто криса.

        ]],
    Weapons = {},
    Command = "niggfwfesssr23323232323322sdas4",
    Max = 1,
    Salary = 300,
    admin = 0,
    Police = true,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 100,
    hasLicense = true,
    mozhnovnegodisguse = false,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
        ply:SetArmor( 150 )
        ply:SetMaxArmor( 150 )
        ply:SetRunSpeed( rp.Setting.DefaultSpeedRun + 75 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr23323232323322sdas4"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr23323232323322sdas4"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN3 = rp.AddTeam( "Детектив", {
    Color = Color( 253, 255, 84, 255 ),
    Model = { "models/player/emesisblue/spy_fixed.mdl" },
    Description = [[
    
        ПРИВАТНА ПРОФЕСІЯ

        Учасник держструктур, який займається розлідуванням справ.
    
        ]],
    Weapons = {},
    Command = "niggfwfesssr3",
    Max = 3,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    hasLicense = true,
    nocuff = true,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr3"][ply:SteamID()] or ply:IsRoot() or BATTLEPASS:GetPermanentVariable( ply, "jobdetective" ) end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr3"][ply:SteamID()] or ply:IsRoot() or BATTLEPASS:GetPermanentVariable( ply, "jobdetective" ) end,
    Police = true,
    Spawn = rp.Setting.PoliceSpawn,
} )

TEAM_ADMI3WWWdadtW = rp.AddTeam( "Шинобі", {
    Color = Color( 220, 220, 0 ),
    Model = { "models/itachianbu/itachianbu.mdl" },
    Description = [[

        Персонаж з аніме "Наруто".
        Член спеціалізованого клану , який виконує місії за певну плату.

        ]],
    Weapons = { "weapon_amaterasu" },
    Command = "ADMI3WWWdadtW",
    Max = 10,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    hasLicense = true,
    nocuff = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 200 )
        ply:SetHealth( 200 )
        ply:SetArmor( 200 )
        ply:SetMaxArmor( 200 )
        ply:SetRunSpeed( rp.Setting.DefaultSpeedRun + 75 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["ADMI3WWWdadtW"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["ADMI3WWWdadtW"][ply:SteamID()] or ply:IsRoot() end,
    Police = true,
    Spawn = rp.Setting.PoliceSpawn,
} )

TEAM_ADMIPENIs2424g = rp.AddTeam( "Киборг", {
    Color = Color( 220, 220, 0 ),
    Model = { "models/rammatra/ow2/rstar/rammatra/rammatra.mdl" },
    Description = [[
    FearRP от 3-х людей!
    Не працює правило SoloRaid!
        ]],
    Weapons = { "weapon_amaterasu" },
    Command = "TEAM_ADMIPENIs2424g",
    Max = 10,
    Salary = 300,
    admin = 0,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    hasLicense = true,
    IsDisguse = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
        ply:SetArmor( 150 )
        ply:SetMaxArmor( 150 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["TEAM_ADMIPENIs2424g"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["TEAM_ADMIPENIs2424g"][ply:SteamID()] or ply:IsRoot() end,
} )

TEAM_ADMI3dwae21wN3_KamadoTanjiro = rp.AddTeam( "Kamado Tanjiro", {
    Color = Color( 16, 97, 0 ),
    Model = { "models/player/tanjiro.mdl" },
    Description = [[
    
        Головний герой аніме "Клинок, що розсікає демонів".
        Він став винищувачем демонів, щоб знайти відповідального за вбивство його сім"ї та перетворення його сестри на демона.

        ]],
    Weapons = {},
    Command = "kamadotanjiro",
    Max = 3,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    hasLicense = false,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
        ply:SetArmor( 150 )
        ply:SetMaxArmor( 150 )
    end,
    candemote = false,
    mozhnovnegodisguse = false,
    canSee = function( ply ) return ply:IsRoot() or BATTLEPASS:GetPermanentVariable( ply, "jobkamado" ) or tbljobs_access["kamadotanjiro"][ply:SteamID()] end,
    customCheck = function( ply ) return ply:IsRoot() or BATTLEPASS:GetPermanentVariable( ply, "jobkamado" ) or tbljobs_access["kamadotanjiro"][ply:SteamID()] end,
} )

TEAM_ADMIdwadsd123wd_YagamiLait = rp.AddTeam( "Ягамі Лайт", {
    Color = Color( 88, 88, 88 ),
    Model = { "models/konnie/jumpforce/lightyagami.mdl" },
    Description = [[
    
        ПРИВАТНА ПРОФЕСІЯ

        Головний герой аніме "Death Note".
        Він неймовірно розумний, однак знудьгований юнак, який випадково знаходить Записник Смерті Бога Смерті Рюка.
    
        ]],
    Weapons = {},
    Command = "YagamiLait",
    Max = 2,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 150,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
        ply:SetRunSpeed( rp.Setting.DefaultSpeedRun * 1.5 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["YagamiLait"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["YagamiLait"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ZZZZZZZZZZZZZZZZZZZZALUPA_ClausMadnos = rp.AddTeam( "Claus Madson", {
    Color = Color( 88, 88, 88 ),
    Model = { "models/vinrax/player/Jack_player.mdl" },
    Description = [[
    
        ПРИВАТНА ПРОФЕСІЯ
    
        Дрищ який може постояти за себе та своїх друзів.
        Уособлення сутності однієї людини.

        ]],
    Weapons = { "weapon_amaterasu" },
    Command = "ClausMadson",
    Max = 3,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 150,
    hasLicense = false,
    PlayerLoadout = function( ply )
        ply:SetMaxArmor( 150 )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["ClausMadson"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["ClausMadson"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Tron = rp.AddTeam( "Титан", {
    Color = Color( 255, 255, 255 ),
    Model = { "models/player/anon/anon.mdl" },
    Description = [[
     
        ПРИВАТНА ПРОФЕСІЯ
     
        Один з сильніших бійців спецслужб, який в змозі впоратись наодинці з трьома злочинцями. 
    
        ]],
    Weapons = {},
    Command = "Tron",
    Max = 3,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    mozhnovnegodisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 200,
    Police = true,
    hasLicense = true,
    nocuff = true,
    PlayerLoadout = function( ply )
        ply:SetMaxArmor( 200 )
        ply:SetMaxHealth( 200 )
        ply:SetHealth( 200 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["Tron"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["Tron"][ply:SteamID()] or ply:IsRoot() end,
    Spawn = rp.Setting.PoliceSpawn,
} )

TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_IMMORTAL = rp.AddTeam( "Immortal", {
    Color = Color( 215, 184, 233 ),
    Model = { "models/kerosenn/darkest_dungeon/heroes/Jester/playermodel/dd2_Jester_pm.mdl", "models/kerosenn/darkest_dungeon/heroes/grave_robber/playermodel/dd2_grave_robber_pm.mdl" },
    Description = [[
     
        ПРИВАТНА ПРОФЕСІЯ
    
        Непереможна та нездоланна вища сила синдикату "Immortals"
    
        ]],
    Weapons = { "weapon_amaterasu" },
    Command = "Immortal",
    Max = 7,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    mozhnovnegodisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    Police = false,
    hasLicense = false,
    nocuff = true,
    candemote = false,
    PlayerLoadout = function( ply )
        ply:SetHealth( 300 )
        ply:SetMaxHealth( 300 )
        ply:SetArmor( 200 )
        ply:SetMaxArmor( 200 )
        local i = 0.6
        ply:SetModelScale( i, 0 )
        ply:SetViewOffset( Vector( 0, 0, 64 ) * i )
        ply:SetViewOffsetDucked( Vector( 0, 0, 28 ) * i )
    end,
    canSee = function( ply ) return tbljobs_access["Immortal"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["Immortal"][ply:SteamID()] or ply:IsRoot() end,
} )

TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_GRIMDJOU = rp.AddTeam( "Гримджоу", {
    Color = Color( 0, 122, 221 ),
    Model = { "models/grimmjow/bleach/rstar/grimmjow/grimmjow.mdl" },
    Description = [[]],
    Weapons = { "bala_swep" },
    Command = "Grimdjou",
    Max = 1,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    mozhnovnegodisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    Police = false,
    hasLicense = false,
    candemote = false,
    PlayerLoadout = function( ply )
        ply:SetHealth( 200 )
        ply:SetMaxHealth( 200 )
        ply:SetArmor( 200 )
        ply:SetMaxArmor( 200 )
    end,
    canSee = function( ply ) return tbljobs_access["Grimdjou"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["Grimdjou"][ply:SteamID()] or ply:IsRoot() end,
} )

rp.AddDoorGroup( "Держава", TEAM_ADMI3WWWdadtW, TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Tron, TEAM_ADMI3qwfqwN11231234444, TEAM_ADMI3qwfqwN3 )
--PATH gamemodes/darkrp/gamemode/core/core_cl.lua:
function GM:ChatText( _, _, _, type )
	if type == 'joinleave' then
		return true
	elseif type == 'namechange' then
		return true
	elseif type == 'servermsg' then
		return true
	end
end

local GUIToggled = false
local mouseX, mouseY = ScrW() * 0.5, ScrH() * 0.5
function GM:ShowSpare1()
	GUIToggled = not GUIToggled
	if GUIToggled then
		gui.SetMousePos( mouseX, mouseY )
	else
		mouseX, mouseY = gui.MousePos()
	end

	gui.EnableScreenClicker( GUIToggled )
end

local FKeyBinds = {
	-- ['gm_showhelp'] = 'ShowHelp',
	-- ['gm_showteam'] = 'ShowTeam',
	['gm_showspare1'] = 'ShowSpare1',
	-- ['gm_showspare2'] = 'ShowSpare2'
}

hook.Add( 'PlayerBindPress', 'FixBind', function( _, bind )
	local bnd = string.match( string.lower( bind ), 'gm_[a-z]+[12]?' )
	if bnd and FKeyBinds[bnd] then hook.Call( FKeyBinds[bnd], GAMEMODE ) end
end )

function GM:HUDDrawTargetID()
	return false
end

hook.Add( 'InitPostEntity', 'Load', function() rp.ConCommand_Add( 'hitman', 1, function() onyx.ChoosePlayer( 'Замовити вбийство', 'Виберіть людину, на яку хочете замовити вбивство', function( pl ) onyx.SimpleQuery( 'Замовити вбийство', 'Сума грошей (10.000 - 500.000)', true, function( num ) RunConsoleCommand( 'hit', pl:SteamID64(), num ) end, 'Так', nil, 'Ні' ) end, nil, function( ply ) return not ply:IsHitman() end ) end ) end )
hook.Remove( 'PreDrawHalos', 'PropertiesHover' )
module( 'neitan_trinfo', package.seeall )
local tbl = {
	['prop_door_rotating'] = {
		{
			key = 'E',
			info = 'Відкрити / закрити'
		},
	},
	-- DarkRP класс оружия когда оно выброшено
	['spawned_weapon'] = {
		{
			key = 'E',
			info = 'Взяти'
		},
	},
	-- DarkRP класс любой еды
	['spawned_food'] = {
		{
			key = 'E',
			info = 'Слухати'
		},
	},
	-- DarkRP класс любого ящика с предметами
	['spawned_shipment'] = {
		{
			key = 'E',
			info = 'Взяти'
		},
	},
	-- DarkRP класс ящика с патронами
	['spawned_ammo'] = {
		{
			key = 'E',
			info = 'Взяти'
		}
	},
	-- Энтити принтер
	['money_printer'] = {
		{
			key = 'E',
			info = 'Використати'
		}
	},
	-- DarkRP класс денег
	['spawned_money'] = {
		{
			key = 'E',
			info = 'Взяти'
		}
	}
}

tbl.halos = {
	-- Тут прописываем к каким энтити будет обводка. Это чаще нужно чтоб к примеру на оружии
	-- вы указали включить обводку а к автомату с водой не нужно.
	-- True - включить   /  False - выключить
	['spawned_weapon'] = {
		neitan_halo = true
	},
	['spawned_shipment'] = {
		neitan_halo = false
	},
	['spawned_ammo'] = {
		neitan_halo = false
	},
	['spawned_food'] = {
		neitan_halo = false
	},
	['spawned_money'] = {
		neitan_halo = true
	}
}

local function build( key, info, amount )
	surface.SetFont( 'Roboto_24' )
	local boxsizew, boxsizeh = 36, 36
	local infosizew = surface.GetTextSize( info )
	local padding = -25
	local down = 100
	local w, h = ScrW(), ScrH()
	onyx.hud.DrawShadowText2D( info, onyx.Font( 'Comfortaa@24' ), w * 0.5 + boxsizew * 0.5, h * 0.5 + down + amount / 0.025, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	draw.RoundedBox( 10, w * 0.5 - boxsizew * 0.5 - ( infosizew + boxsizew + padding ) * 0.5, h * 0.5 - boxsizeh * 0.5 + down + amount / 0.025, boxsizew, boxsizeh, Color( 0, 0, 0, 200 ) )
	onyx.hud.DrawShadowText2D( key, onyx.Font( 'Comfortaa@24' ), w * 0.5 - ( infosizew + boxsizew + padding ) * 0.5, h * 0.5 + down + amount / 0.025, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
end

local dis = 100
hook.Add( 'HUDPaint', 'neitan_trinfo_hp', function()
	local te = LocalPlayer():GetEyeTrace().Entity
	if not IsValid( te ) or LocalPlayer():InVehicle() or LocalPlayer():GetPos():DistToSqr( te:GetPos() ) > dis * dis then return end
	if te:GetClass() == 'player' then
		local pl = te
		if pl:IsHitman() then build( 'Е', 'Зробити замовлення', 1 ) end
	end

	if tbl[te:GetClass()] then
		for k, v in pairs( tbl[te:GetClass()] ) do
			build( v.key, v.info, k )
		end
	end
end )

local nextCleanTime = 600
hook.Add( 'Think', '__AutoCleaner', function()
	if nextCleanTime < CurTime() then
		RunConsoleCommand( 'r_cleardecals' )
		RunConsoleCommand( 'stopsound' )
		--
		nextCleanTime = CurTime() + 600
	end
end )
--PATH gamemodes/darkrp/gamemode/core/chat/__chat_utils_sh.lua:
local isTable = istable
local isString = isstring
local tableCount = table.Count
local utils = {}
local function compare( toCompare1, toCompare2 )
    return toCompare1 == toCompare2
end

--
-- TODO: Comment method role
--
function utils.ComparePrefixes( prefix, prefixes )
    if not isString( prefix ) then return end
    local isEqual = false
    if not isTable( prefixes ) then return compare( prefix, prefixes ) end
    for _, v in ipairs( prefixes ) do
        if compare( prefix, v ) then
            isEqual = true
            break
        end
    end
    return isEqual
end

local RESTRICTED_FUNCTIONS = {
    ["usergroup"] = function( target, toCompare ) return compare( target:GetUserGroup(), toCompare ) end,
    ["steamid"] = function( target, toCompare ) return compare( target:SteamID(), toCompare ) end,
    ["steamid64"] = function( target, toCompare ) return compare( target:SteamID64(), toCompare ) end,
    ["team"] = function( target, toCompare ) return compare( target:Team(), toCompare ) end
}

--
-- TODO: Comment method role
--
function utils.isPlayerRestricted( ply, restrictions )
    local isRestricted = true
    local emptyRestrictions = true
    for type, values in pairs( restrictions ) do
        if tableCount( values ) == 0 then continue end
        emptyRestrictions = false
        for value, __ in pairs( values ) do
            if RESTRICTED_FUNCTIONS[type]( ply, value ) then
                isRestricted = false
                break
            end
        end
    end

    if emptyRestrictions then return false end
    return isRestricted
end

rp.chatcommands = {}
rp.chatcommands.utils = utils
--PATH gamemodes/darkrp/gamemode/core/chat/_chat_sh.lua:
local toLower = string.lower
local setChar = string.SetChar
local strExplode = string.Explode
--
local tableCopy = table.Copy
local tableRemove = table.remove
--
local isString = isstring
--
local utils = rp.chatcommands.utils
--
local commands = commands or {}
commandsLib = commandsLib or {}
--
-- TODO: Comment method role 
--
function commandsLib.register( name, options )
    local command = chatCommand( name, options )
    if command and not commands[name] then
        -- TODO: Optimize stockage
        commands[name] = command
        return true
    end
    return false
end

--
-- TODO: Comment method role 
--
local function existCommandName( text )
    return commands[text] ~= nil
end

local function getCommand( commandName )
    return tableCopy( commands[commandName] )
end

function commandsLib.delete( name )
    local exist = existCommandName( name )
    if exist then
        local command = getCommand( name )
        --
        commands[name] = nil
        command:OnDelete()
    end
end

function commandsLib.executeCommand( text, ply )
    if text == nil or not isString( text ) then return end
    if ply == nil or not ply:IsPlayer() then return end
    --
    local commandPrefix = text[1]
    --
    text = setChar( text, 1, '' ) -- Remove prefix
    -- TODO: Add options separator configuration
    text = strExplode( ' ', text ) -- Explode to get command name and options
    --
    local commandName = toLower( text[1] )
    --
    if existCommandName( commandName ) then
        local command = getCommand( commandName )
        --
        tableRemove( text, 1 )
        --
        if utils.ComparePrefixes( commandPrefix, command:getPrefix() ) and not utils.isPlayerRestricted( ply, command:getRestricted() ) then
            command:execute( ply, text )
            --
            return not command:getShowMessage()
        end
    end
    return
end

if CLIENT then hook.Add( "OnPlayerChat", "OnPlayerChat:CommandsLib", function( requester, text ) return commandsLib.executeCommand( text, requester ) end ) end
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/toolmenu_cl.lua:

local PANEL = {}

--[[---------------------------------------------------------
   Name: Paint
-----------------------------------------------------------]]
function PANEL:Init()

	self.ToolPanels = {}

	self:LoadTools()

	self:SetFadeTime(0)

end


--[[---------------------------------------------------------
	LoadTools
-----------------------------------------------------------]]
function PANEL:LoadTools()

	local tools = spawnmenu.GetTools()

	for strName, pTable in pairs(tools) do

		self:AddToolPanel(strName, pTable)

	end

end


--[[---------------------------------------------------------
	LoadTools
-----------------------------------------------------------]]
function PANEL:AddToolPanel(Name, ToolTable)

	-- I hate relying on a table's internal structure
	-- but this isn't really that avoidable.

	local Panel = vgui.Create("ToolPanel")
	Panel:SetTabID(Name)
	Panel:LoadToolsFromTable(ToolTable.Items)

	self:AddSheet(ToolTable.Label, Panel, ToolTable.Icon)
	self.ToolPanels[ Name ] = Panel

end

--[[---------------------------------------------------------
   Name: Paint
-----------------------------------------------------------]]
function PANEL:Paint(w, h)

	DPropertySheet.Paint(self, w, h)

end

--[[---------------------------------------------------------
   Name: PerformLayout
-----------------------------------------------------------]]
function PANEL:PerformLayout()

	DPropertySheet.PerformLayout(self)

	-- We want to size to the contents in the base panel
	self:SizeToContentWidth()

end

--[[---------------------------------------------------------
   Name: GetToolPanel
-----------------------------------------------------------]]
function PANEL:GetToolPanel(id)

	return self.ToolPanels[ id ]

end

vgui.Register("ToolMenu", PANEL, "DPropertySheet")
--PATH addons/__________scripts__loader/lua/scriptssss/_server_1/sh_jobs.lua:
-- [id] = {
--     [steamid] = true
-- }
local tbljobs_access = {
    ["niggfwfesssr"] = {
        ["STEAM_0:0:450137406"] = true,
        ["STEAM_0:1:120409042"] = true,
        ["STEAM_0:0:597860585"] = true,
        ["STEAM_0:1:636396089"] = true,
        ["STEAM_0:0:566244461"] = true,
        ["STEAM_0:1:760005561"] = true,
        ["STEAM_0:0:649878040"] = true,
        ["STEAM_0:1:551756931"] = true,
        ["STEAM_0:1:544527523"] = true,
        ["STEAM_0:1:704050139"] = true,
        ["STEAM_0:1:625769413"] = true,
        ["STEAM_0:1:456755552"] = true,
        ["STEAM_0:0:704419021"] = true,
    },
    ["nigaaaaaaaaaaaaaa33gfwfesssr"] = {
        ["STEAM_0:0:220004443"] = true,
    },
    ["niggfwfesssr6645645tedgdfgr"] = {
        ["STEAM_0:0:184853533"] = true,
        ["STEAM_0:1:580123290"] = true,
        ["STEAM_0:1:760005561"] = true,
        ["STEAM_0:1:625769413"] = true,
    },
    ["niggfwfesssr221232142"] = {
        ["STEAM_0:1:626248835"] = true,
        ["STEAM_0:1:469562433"] = true,
        ["STEAM_0:1:569511267"] = true,
        ["STEAM_0:0:566244461"] = true,
        ["STEAM_0:0:709551420"] = true,
        ["STEAM_0:1:608196074"] = true,
    },
    ["niggfwfesssr22"] = {
        ["STEAM_0:0:739134032"] = true,
        ["STEAM_0:1:242255701"] = true,
        ["STEAM_0:1:193129981"] = true,
    },
    ["niggfwfesssr223"] = {
        ["STEAM_0:0:651957902"] = true,
        ["STEAM_0:0:679144329"] = true,
        ["STEAM_0:1:512233896"] = true,
        ["STEAM_0:1:536163323"] = true,
        ["STEAM_0:1:174206189"] = true,
        ["STEAM_0:1:627296059"] = true,
    },
    ["nigg4324234fwfesssr1"] = {
        ["STEAM_0:0:184853533"] = true,
        ["STEAM_0:0:63554495"] = true
    },
    ["nigg4324234fwfesssr1131235655555"] = {
        ["STEAM_0:1:613568329"] = true,
        ["STEAM_0:0:450137406"] = true,
        ["STEAM_0:0:121551094"] = true
    },
    ["niggfwfesssr1"] = {
        ["STEAM_0:0:725906019"] = true,
        ["STEAM_0:1:477858912"] = true,
        ["STEAM_0:0:566244461"] = true,
        ["STEAM_0:1:600476323"] = true,
        ["STEAM_0:0:643390253"] = true,
        ["STEAM_0:1:519322911"] = true,
        ["STEAM_0:1:572887546"] = true,
        ["STEAM_0:0:709551420"] = true,
        ["STEAM_0:0:556211243"] = true,
        ["STEAM_0:1:640957612"] = true,
    },
    ["niggfwfesssr2"] = {
        ["STEAM_0:0:673247761"] = true,
        ["STEAM_0:0:814015599"] = true,
        ["STEAM_0:0:599174076"] = true,
        ["STEAM_0:0:593033373"] = true,
        ["STEAM_0:0:441605243"] = true,
        ["STEAM_0:0:587185454"] = true,
    },
    ["niggfwfesssr23212sdas4"] = {
        ["STEAM_0:0:508183961"] = true,
        ["STEAM_0:1:650549758"] = true,
        ["STEAM_0:0:650549758"] = true,
        ["STEAM_0:0:31516481"] = true,
        ["STEAM_0:1:640957612"] = true,
        ["STEAM_0:1:606750788"] = true,
        ["STEAM_0:1:535281143"] = true,
        ["STEAM_0:0:632225562"] = true,
        ["STEAM_0:0:566244461"] = true,
        ["STEAM_0:0:220004443"] = true,
        ["STEAM_0:0:173289826"] = true,
        ["STEAM_0:0:121551094"] = true,
        ["STEAM_0:0:689568435"] = true,
        ["STEAM_0:1:600665265"] = true,
        ["STEAM_0:0:215047514"] = true,
    },
    ["niggfwfesssr23323232323322sdas4"] = {
        ["STEAM_0:0:173289826"] = true,
    },
    ["niggfwfesssr3"] = {
        ["STEAM_0:0:220004443"] = true,
        ["STEAM_0:1:564249355"] = true,
        ["STEAM_0:1:456755552"] = true,
    },
    ["ADMI3WWWdadtW"] = {
        ["STEAM_0:0:79383715"] = true,
    },
    ["TEAM_ADMIPENIs2424g"] = {
        ["STEAM_0:1:14253376"] = true,
        ["STEAM_0:0:609543932"] = true,
        ["STEAM_0:0:456048053"] = true,
        ["STEAM_0:1:564249355"] = true,
        ["STEAM_0:0:590511782"] = true,
        ["STEAM_0:0:651957902"] = true,
    },
    ["kamadotanjiro"] = {
        ["STEAM_0:1:600665265"] = true,
    },
    ["YagamiLait"] = {
        ["STEAM_0:1:595522442"] = true,
    },
    ["ClausMadson"] = {
        ["STEAM_0:0:629004634"] = true,
    },
    ["Tron"] = {
        ["STEAM_0:0:739134032"] = true,
    },
    ["Immortal"] = {
        ["STEAM_0:1:526747865"] = true,
        ["STEAM_0:1:774738694"] = true,
    },
    ["Grimdjou"] = {
        ["STEAM_0:1:525613911"] = true,
    },
}

TEAM_ADMI3qwfqwN = rp.AddTeam( "Ітачі", {
    Color = Color( 0, 0, 0, 255 ),
    Model = { "models/itachianbu/itachianbu.mdl" },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Герой аніме, якого було визнано небезпечним злочинцем.
        Член злочинної організації Акацукі.;

    ]],
    Weapons = {},
    Command = "niggfwfesssr",
    Max = 10,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    hitman = true,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 200 )
        ply:SetHealth( 200 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqw12312321AAAaN = rp.AddTeam( "Блудний лицар", {
    Color = Color( 255, 0, 0, 255 ),
    Model = { "models/epangelmatikes/revan/revan_opt.mdl" },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Персонаж із розширеного всесвіту "Зоряних війн".
        Джедай, який боровся в Мандалорських війнах.;

    ]],
    Weapons = {},
    Command = "nigaaaaaaaaaaaaaa33gfwfesssr",
    Max = 10,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["nigaaaaaaaaaaaaaa33gfwfesssr"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["nigaaaaaaaaaaaaaa33gfwfesssr"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwNYASD44 = rp.AddTeam( "Рюк", {
    Color = Color( 230, 230, 250, 255 ),
    Model = { "models/konnie/jumpforce/ryuk.mdl" },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Герой аніме, який є один з богів смерті.
        Для продовження свого життя йому потрібно було вбивати смертних за допомогою зошита смерті.

    ]],
    Weapons = { "death_note" },
    Command = "niggfwfesssr6645645tedgdfgr",
    Max = 10,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    hitman = true,
    Armor = 200,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 200 )
        ply:SetHealth( 200 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr6645645tedgdfgr"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr6645645tedgdfgr"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN223336 = rp.AddTeam( "Работоргівець", {
    Color = Color( 143, 38, 78, 255 ),
    Model = { "models/jazzmcfly/kantai/iowa/iowa.mdl" },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Людина яка грабує людей, та продає їх для заробітку.
    ]],
    Weapons = { "weapon_cuff_rope" },
    Command = "niggfwfesssr221232142",
    Max = 10,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 150,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
        ply:SetArmor( 150 )
        ply:SetMaxArmor( 150 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr221232142"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr221232142"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN22 = rp.AddTeam( "Мадара Учіха", {
    Color = Color( 0, 0, 0, 255 ),
    Model = { "models/player/naruto/madara.mdl" },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Герой аніме, легендарний лідер клану Учіха.;

    ]],
    Weapons = { "weapon_amaterasu" },
    Command = "niggfwfesssr22",
    Max = 10,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr22"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr22"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN223 = rp.AddTeam( "Авторитет", {
    Color = Color( 126, 5, 177, 255 ),
    Model = { "models/kuma96/codmw/characters/velikan/velikan_pm.mdl" },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Авторитет в кримінальному світі, сильний та впевнений.

    ]],
    Weapons = {},
    Command = "niggfwfesssr223",
    Max = 10,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 200,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 200 )
        ply:SetHealth( 200 )
        ply:SetArmor( 200 )
        ply:SetMaxArmor( 200 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr223"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr223"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN1 = rp.AddTeam( "Baby Yoda", {
    Color = Color( 0, 255, 0, 255 ),
    Model = { "models/kaesar/baby_yoda/baby_yoda.mdl", },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Популярний персонаж "Зоряних війн".
        Маленьке дитинча яке хотіло досліджувати світ.

    ]],
    Weapons = {},
    Command = "nigg4324234fwfesssr1",
    Max = 0,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
        ply:SetArmor( 0 )
        ply:SetMaxArmor( 0 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["nigg4324234fwfesssr1"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["nigg4324234fwfesssr1"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN11231234444 = rp.AddTeam( "Tails", {
    Color = Color( 255, 255, 0, 255 ),
    Model = { "models/player/tails.mdl", },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Персонаж ігор та мультфільмів "Sonic the Hedgehog".
        Скромне добродушне лисеня яке мріє стати як Сонік.

    ]],
    Weapons = { "weapon_amaterasu" },
    Command = "nigg4324234fwfesssr1131235655555",
    Max = 0,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 150,
    Police = true,
    hasLicense = true,
    nocuff = true,
    Spawn = rp.Setting.PoliceSpawn,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
        ply:SetArmor( 150 )
        ply:SetMaxArmor( 150 )
        ply:SetRunSpeed( rp.Setting.DefaultSpeedRun + 75 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["nigg4324234fwfesssr1131235655555"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["nigg4324234fwfesssr1131235655555"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN1 = rp.AddTeam( "Neco Arc", {
    Color = Color( 255, 0, 0, 255 ),
    Model = { "models/mocha/necoarc/necoarc.mdl", "models/mocha/necoarcchaos/necoarcchaos.mdl", },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Неко-дух , що з"являється в серії "Tsukihime".
        Є членом раси Неко-духів, яка мріє щоб всі думали що вона розумна.

    ]],
    Weapons = { "weapon_357" },
    Command = "niggfwfesssr1",
    Max = 0,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 100,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr1"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr1"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN2 = rp.AddTeam( "Ассасин", {
    Color = Color( 255, 255, 255, 255 ),
    Model = { "models/player/altair_ibnlaahad.mdl" },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Майстер Ассассін і наставник із сирійського Братства Ассассінів.
        Нахабний та грубий до своїх побратимів.

    ]],
    Weapons = {},
    Command = "niggfwfesssr2",
    Max = 10,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 100,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 200 )
        ply:SetHealth( 200 )
        ply:SetArmor( 150 )
        ply:SetMaxArmor( 150 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr2"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr2"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN2553443a = rp.AddTeam( "Імп", {
    Color = Color( 0, 0, 0, 255 ),
    Model = { "models/custom/cmankarthecat/helluvaboss/moxxie_pm.mdl", "models/player/blitzo_character/blitzo_pm/blitzo_pm.mdl" },
    Description = [[

        ПРИВАТНА ПРОФЕСІЯ

        Кіллер з агенства "Кілери-біса".
        Займається вбивством людей на Землі, які тим чи іншим чином змогли якось досадити грішникам, що потрапили в Пекло.

    ]],
    Weapons = { "weapon_amaterasu" },
    Command = "niggfwfesssr23212sdas4",
    Max = 10,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 100,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
        ply:SetArmor( 150 )
        ply:SetMaxArmor( 150 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr23212sdas4"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr23212sdas4"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN25535533543a = rp.AddTeam( "ЧБД", {
    Color = Color( 255, 200, 0 ),
    Model = { "models/player/funnyrat/rat.mdl" },
    Description = [[

            ПРИВАТНА ПРОФЕСІЯ

            Просто криса.

        ]],
    Weapons = {},
    Command = "niggfwfesssr23323232323322sdas4",
    Max = 1,
    Salary = 300,
    admin = 0,
    Police = true,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 100,
    hasLicense = true,
    mozhnovnegodisguse = false,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
        ply:SetArmor( 150 )
        ply:SetMaxArmor( 150 )
        ply:SetRunSpeed( rp.Setting.DefaultSpeedRun + 75 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr23323232323322sdas4"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr23323232323322sdas4"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ADMI3qwfqwN3 = rp.AddTeam( "Детектив", {
    Color = Color( 253, 255, 84, 255 ),
    Model = { "models/player/emesisblue/spy_fixed.mdl" },
    Description = [[
    
        ПРИВАТНА ПРОФЕСІЯ

        Учасник держструктур, який займається розлідуванням справ.
    
        ]],
    Weapons = {},
    Command = "niggfwfesssr3",
    Max = 3,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    hasLicense = true,
    nocuff = true,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["niggfwfesssr3"][ply:SteamID()] or ply:IsRoot() or BATTLEPASS:GetPermanentVariable( ply, "jobdetective" ) end,
    customCheck = function( ply ) return tbljobs_access["niggfwfesssr3"][ply:SteamID()] or ply:IsRoot() or BATTLEPASS:GetPermanentVariable( ply, "jobdetective" ) end,
    Police = true,
    Spawn = rp.Setting.PoliceSpawn,
} )

TEAM_ADMI3WWWdadtW = rp.AddTeam( "Шинобі", {
    Color = Color( 220, 220, 0 ),
    Model = { "models/itachianbu/itachianbu.mdl" },
    Description = [[

        Персонаж з аніме "Наруто".
        Член спеціалізованого клану , який виконує місії за певну плату.

        ]],
    Weapons = { "weapon_amaterasu" },
    Command = "ADMI3WWWdadtW",
    Max = 10,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    hasLicense = true,
    nocuff = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 200 )
        ply:SetHealth( 200 )
        ply:SetArmor( 200 )
        ply:SetMaxArmor( 200 )
        ply:SetRunSpeed( rp.Setting.DefaultSpeedRun + 75 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["ADMI3WWWdadtW"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["ADMI3WWWdadtW"][ply:SteamID()] or ply:IsRoot() end,
    Police = true,
    Spawn = rp.Setting.PoliceSpawn,
} )

TEAM_ADMIPENIs2424g = rp.AddTeam( "Киборг", {
    Color = Color( 220, 220, 0 ),
    Model = { "models/rammatra/ow2/rstar/rammatra/rammatra.mdl" },
    Description = [[
    FearRP от 3-х людей!
    Не працює правило SoloRaid!
        ]],
    Weapons = { "weapon_amaterasu" },
    Command = "TEAM_ADMIPENIs2424g",
    Max = 10,
    Salary = 300,
    admin = 0,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    hasLicense = true,
    IsDisguse = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
        ply:SetArmor( 150 )
        ply:SetMaxArmor( 150 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["TEAM_ADMIPENIs2424g"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["TEAM_ADMIPENIs2424g"][ply:SteamID()] or ply:IsRoot() end,
} )

TEAM_ADMI3dwae21wN3_KamadoTanjiro = rp.AddTeam( "Kamado Tanjiro", {
    Color = Color( 16, 97, 0 ),
    Model = { "models/player/tanjiro.mdl" },
    Description = [[
    
        Головний герой аніме "Клинок, що розсікає демонів".
        Він став винищувачем демонів, щоб знайти відповідального за вбивство його сім"ї та перетворення його сестри на демона.

        ]],
    Weapons = {},
    Command = "kamadotanjiro",
    Max = 3,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    hasLicense = false,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
        ply:SetArmor( 150 )
        ply:SetMaxArmor( 150 )
    end,
    candemote = false,
    mozhnovnegodisguse = false,
    canSee = function( ply ) return ply:IsRoot() or BATTLEPASS:GetPermanentVariable( ply, "jobkamado" ) or tbljobs_access["kamadotanjiro"][ply:SteamID()] end,
    customCheck = function( ply ) return ply:IsRoot() or BATTLEPASS:GetPermanentVariable( ply, "jobkamado" ) or tbljobs_access["kamadotanjiro"][ply:SteamID()] end,
} )

TEAM_ADMIdwadsd123wd_YagamiLait = rp.AddTeam( "Ягамі Лайт", {
    Color = Color( 88, 88, 88 ),
    Model = { "models/konnie/jumpforce/lightyagami.mdl" },
    Description = [[
    
        ПРИВАТНА ПРОФЕСІЯ

        Головний герой аніме "Death Note".
        Він неймовірно розумний, однак знудьгований юнак, який випадково знаходить Записник Смерті Бога Смерті Рюка.
    
        ]],
    Weapons = {},
    Command = "YagamiLait",
    Max = 2,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 150,
    hasLicense = true,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
        ply:SetRunSpeed( rp.Setting.DefaultSpeedRun * 1.5 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["YagamiLait"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["YagamiLait"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ZZZZZZZZZZZZZZZZZZZZALUPA_ClausMadnos = rp.AddTeam( "Claus Madson", {
    Color = Color( 88, 88, 88 ),
    Model = { "models/vinrax/player/Jack_player.mdl" },
    Description = [[
    
        ПРИВАТНА ПРОФЕСІЯ
    
        Дрищ який може постояти за себе та своїх друзів.
        Уособлення сутності однієї людини.

        ]],
    Weapons = { "weapon_amaterasu" },
    Command = "ClausMadson",
    Max = 3,
    Salary = 300,
    admin = 0,
    IsDisguse = true,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 150,
    hasLicense = false,
    PlayerLoadout = function( ply )
        ply:SetMaxArmor( 150 )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["ClausMadson"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["ClausMadson"][ply:SteamID()] or ply:IsRoot() end
} )

TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Tron = rp.AddTeam( "Титан", {
    Color = Color( 255, 255, 255 ),
    Model = { "models/player/anon/anon.mdl" },
    Description = [[
     
        ПРИВАТНА ПРОФЕСІЯ
     
        Один з сильніших бійців спецслужб, який в змозі впоратись наодинці з трьома злочинцями. 
    
        ]],
    Weapons = {},
    Command = "Tron",
    Max = 3,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    mozhnovnegodisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 200,
    Police = true,
    hasLicense = true,
    nocuff = true,
    PlayerLoadout = function( ply )
        ply:SetMaxArmor( 200 )
        ply:SetMaxHealth( 200 )
        ply:SetHealth( 200 )
    end,
    candemote = false,
    canSee = function( ply ) return tbljobs_access["Tron"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["Tron"][ply:SteamID()] or ply:IsRoot() end,
    Spawn = rp.Setting.PoliceSpawn,
} )

TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_IMMORTAL = rp.AddTeam( "Immortal", {
    Color = Color( 215, 184, 233 ),
    Model = { "models/kerosenn/darkest_dungeon/heroes/Jester/playermodel/dd2_Jester_pm.mdl", "models/kerosenn/darkest_dungeon/heroes/grave_robber/playermodel/dd2_grave_robber_pm.mdl" },
    Description = [[
     
        ПРИВАТНА ПРОФЕСІЯ
    
        Непереможна та нездоланна вища сила синдикату "Immortals"
    
        ]],
    Weapons = { "weapon_amaterasu" },
    Command = "Immortal",
    Max = 7,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    mozhnovnegodisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    Police = false,
    hasLicense = false,
    nocuff = true,
    candemote = false,
    PlayerLoadout = function( ply )
        ply:SetHealth( 300 )
        ply:SetMaxHealth( 300 )
        ply:SetArmor( 200 )
        ply:SetMaxArmor( 200 )
        local i = 0.6
        ply:SetModelScale( i, 0 )
        ply:SetViewOffset( Vector( 0, 0, 64 ) * i )
        ply:SetViewOffsetDucked( Vector( 0, 0, 28 ) * i )
    end,
    canSee = function( ply ) return tbljobs_access["Immortal"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["Immortal"][ply:SteamID()] or ply:IsRoot() end,
} )

TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_GRIMDJOU = rp.AddTeam( "Гримджоу", {
    Color = Color( 0, 122, 221 ),
    Model = { "models/grimmjow/bleach/rstar/grimmjow/grimmjow.mdl" },
    Description = [[]],
    Weapons = { "bala_swep" },
    Command = "Grimdjou",
    Max = 1,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    mozhnovnegodisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    Police = false,
    hasLicense = false,
    candemote = false,
    PlayerLoadout = function( ply )
        ply:SetHealth( 200 )
        ply:SetMaxHealth( 200 )
        ply:SetArmor( 200 )
        ply:SetMaxArmor( 200 )
    end,
    canSee = function( ply ) return tbljobs_access["Grimdjou"][ply:SteamID()] or ply:IsRoot() end,
    customCheck = function( ply ) return tbljobs_access["Grimdjou"][ply:SteamID()] or ply:IsRoot() end,
} )

rp.AddDoorGroup( "Держава", TEAM_ADMI3WWWdadtW, TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Tron, TEAM_ADMI3qwfqwN11231234444, TEAM_ADMI3qwfqwN3 )
--PATH addons/__main_only_1st/lua/weapons/death_note/cl_init.lua:
--Weapon cl_init
include( "shared.lua" )
SWEP.PrintName = "Death-Note"
SWEP.Slot = 5
SWEP.SlotPos = 20
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
function SWEP:DrawHUD()
    local x = ScrW() * 0.5
    local y = ScrH() * 0.5
    surface.SetDrawColor( 50, 50, 50, 255 )
    local gap = math.abs( math.sin( CurTime() * 1.5 ) * 6 )
    local length = gap + 5
    surface.DrawLine( x - length, y, x - gap, y )
    surface.DrawLine( x + length, y, x + gap, y )
    surface.DrawLine( x, y - length, x, y - gap )
    surface.DrawLine( x, y + length, x, y + gap )
end
--PATH gamemodes/darkrp/entities/weapons/gmod_tool/stool_cl.lua:


--[[---------------------------------------------------------
   Tool should return true if freezing the view angles
-----------------------------------------------------------]]
function ToolObj:FreezeMovement()
		return false 
end


--[[---------------------------------------------------------
   The tool's opportunity to draw to the HUD
-----------------------------------------------------------]]
function ToolObj:DrawHUD()
end
--PATH addons/____bricks_framework/lua/weapons/gmod_tool/stools/bricks_server_npcs.lua:
TOOL.Category = "Bricks Server"
TOOL.Name = "NPC Placer"
TOOL.Command = nil
TOOL.ConfigName = "" --Setting this means that you do not have to create external configuration files to define the layout of the tool config-hud 

function TOOL:LeftClick( trace )
	if( !trace.HitPos || IsValid( trace.Entity ) && trace.Entity:IsPlayer() ) then return false end
	if( CLIENT ) then return true end

	local ply = self:GetOwner()
	
	if( not BRICKS_SERVER.Func.HasAdminAccess( ply ) ) then
		BRICKS_SERVER.Func.SendNotification( ply, 1, 2, BRICKS_SERVER.Func.L( "noToolPermission" ) )
		return
	end

	if( BRICKS_SERVER.CONFIG.NPCS[ply:GetNW2Int( "bricks_server_tool_npctype" )] ) then
		local NPCEnt = ents.Create( "bricks_server_npc" )
		NPCEnt:SetPos( trace.HitPos )
		local EntAngles = NPCEnt:GetAngles()
		local PlayerAngle = ply:GetAngles()
		NPCEnt:SetAngles( Angle( EntAngles.p, PlayerAngle.y+180, EntAngles.r ) )
		NPCEnt:Spawn()
		NPCEnt:SetNPCKey( ply:GetNW2Int( "bricks_server_tool_npctype" ) )
		
		BRICKS_SERVER.Func.SendNotification( ply, 1, 2, BRICKS_SERVER.Func.L( "npcPlaced" ) )
		ply:ConCommand( "bricks_server_saveentpositions" )
	else
		BRICKS_SERVER.Func.SendNotification( ply, 1, 2, BRICKS_SERVER.Func.L( "invalidNPCType" ) )
	end
end
 
function TOOL:RightClick( trace )
	if( !trace.HitPos ) then return false end
	if( !IsValid( trace.Entity ) or trace.Entity:IsPlayer() ) then return false end
	if( CLIENT ) then return true end

	local ply = self:GetOwner()
	
	if( not BRICKS_SERVER.Func.HasAdminAccess( ply ) ) then
		BRICKS_SERVER.Func.SendNotification( ply, 1, 2, BRICKS_SERVER.Func.L( "noToolPermission" ) )
		return
	end
	
	if( trace.Entity:GetClass() == "bricks_server_npc" ) then
		trace.Entity:Remove()
		BRICKS_SERVER.Func.SendNotification( ply, 1, 2, BRICKS_SERVER.Func.L( "npcRemoved" ) )
		ply:ConCommand( "bricks_server_saveentpositions" )
	else
		BRICKS_SERVER.Func.SendNotification( ply, 1, 2, BRICKS_SERVER.Func.L( "errorNotNPC" ) )
		return false
	end
end

function TOOL:DrawToolScreen( width, height )
	if( not BRICKS_SERVER.Func.HasAdminAccess( LocalPlayer() ) ) then return end

	surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
	surface.DrawRect( 0, 0, width, height )

	surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 0 ) )
	surface.DrawRect( 0, 0, width, 60 )
	
	draw.SimpleText( language.GetPhrase( "tool.bricks_server_npcs.name" ), "BRICKS_SERVER_Font33", width*0.5, 30, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	local NPCSelected = BRICKS_SERVER.CONFIG.NPCS[LocalPlayer():GetNW2Int( "bricks_server_tool_npctype", 0 )]
	draw.SimpleText( BRICKS_SERVER.Func.L( "selected" ), "BRICKS_SERVER_Font33", width*0.5, 60+((height-60)*0.5)-15, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
	draw.SimpleText( ((NPCSelected and (NPCSelected.Name or BRICKS_SERVER.Func.L( "error" ))) or BRICKS_SERVER.Func.L( "none" )), "BRICKS_SERVER_Font25", width*0.5, 60+((height-60)*0.5)-15, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
end

function TOOL.BuildCPanel( panel )
	panel:AddControl("Header", { Text = BRICKS_SERVER.Func.L( "npcType" ), Description = BRICKS_SERVER.Func.L( "npcPlacerDescription" ) })
 
	local combo = panel:AddControl( "ComboBox", { Label = BRICKS_SERVER.Func.L( "npcType" ) } )
	for k, v in pairs( BRICKS_SERVER.CONFIG.NPCS or {} ) do
		combo:AddOption( v.Name, { k } )
	end
	function combo:OnSelect( index, text, data )
		net.Start( "BRS.Net.ToolNPCPlacer" )
			net.WriteUInt( data[1], 8 )
		net.SendToServer()
	end
end

if( CLIENT ) then
	language.Add( "tool.bricks_server_npcs.name", BRICKS_SERVER.Func.L( "npcPlacer" ) )
	language.Add( "tool.bricks_server_npcs.desc", BRICKS_SERVER.Func.L( "npcPlacerDescriptionSmall" ) )
	language.Add( "tool.bricks_server_npcs.0", BRICKS_SERVER.Func.L( "entityPlacerInstructions" ) )
elseif( SERVER ) then
	util.AddNetworkString( "BRS.Net.ToolNPCPlacer" )
	net.Receive( "BRS.Net.ToolNPCPlacer", function( len, ply )
		if( not BRICKS_SERVER.Func.HasAdminAccess( ply ) ) then return end

		ply:SetNW2Int( "bricks_server_tool_npctype", net.ReadUInt( 8 ) )
	end )
end
--PATH addons/_pcasino/lua/weapons/gmod_tool/stools/pcasino_creator.lua:
TOOL.Category = "pCasino"
TOOL.Name = "#tool.pcasino_creator.name"
TOOL.Command = nil

TOOL.Information = {
	{
		name = "left"
	},
	{
		name = "right"
	},
	{
		name = "reload"
	}
}

if CLIENT then
	language.Add("tool.pcasino_creator.name", "Entity Creation")
	language.Add("tool.pcasino_creator.desc", "Used to place all the pCasino entities.")
	language.Add("tool.pcasino_creator.left", "Place the configured entity.")
	language.Add("tool.pcasino_creator.right", "Open the menu to configure an entity.")
	language.Add("tool.pcasino_creator.reload", "Remove the entity permanently.")
end

local cooldown = 0
local currentEnt

local offset = {
	["pcasino_slot_machine"] = function(ent) return Vector(0, 0, 48) end,
	["pcasino_roulette_table"] = function(ent) return Vector(0, 0, 20) end,
	["pcasino_mystery_wheel"] = function(ent) return Vector(0, 0, 61) end,
	["pcasino_sign_plaque"] = function(ent) return ent:GetForward() * 4 end,
	["pcasino_sign_stand"] = function(ent) return Vector(0, 0, 27) end,
	["pcasino_sign_wall_logo"] = function(ent) return ent:GetForward() * 6 end,
	["pcasino_sign_interior_standing"] = function(ent) return Vector(0, 0, 29) end,
	["pcasino_sign_interior_wall"] = function(ent) return ent:GetForward() * 2.5 end,
	["pcasino_chair"] = function(ent) return Vector(0, 0, 26) end,
	["pcasino_npc"] = function(ent) return Vector(0, 0, 1) end
}

local ang = {
	["pcasino_chair"] = function(ent) return Angle(0, 180, 0) end
}

function TOOL:LeftClick(trace)
	if SERVER then return end
	if PerfectCasino.Cooldown.Check("ToolGun:Cooldown", 1) then return end
	if not PerfectCasino.Core.Access(LocalPlayer()) then return end

	if not PerfectCasino.UI.CurrentSettings.Entity then
		PerfectCasino.Core.Msg(PerfectCasino.Translation.ToolGun.NoEntity)

		return
	end

	if cooldown > CurTime() then return end
	cooldown = CurTime() + 1
	plyAngle = LocalPlayer():GetAngles()
	net.Start("pCasino:ToolGun:CreateEntity")
	net.WriteString(PerfectCasino.UI.CurrentSettings.Entity)
	net.WriteTable(PerfectCasino.UI.CurrentSettings.Settings)
	net.WriteVector(trace.HitPos + plyAngle:Forward() + plyAngle:Up() + (offset[PerfectCasino.UI.CurrentSettings.Entity] and offset[PerfectCasino.UI.CurrentSettings.Entity](currentEnt) or vector_origin))
	net.WriteAngle(Angle(0, math.Round(plyAngle.y / 10) * 10 + 180, plyAngle.z) + (ang[PerfectCasino.UI.CurrentSettings.Entity] and ang[PerfectCasino.UI.CurrentSettings.Entity](currentEnt) or angle_zero))
	net.SendToServer()
end

function TOOL:RightClick(trace)
	if SERVER then return end
	if PerfectCasino.Cooldown.Check("ToolGun:Cooldown", 1) then return end
	if not PerfectCasino.Core.Access(LocalPlayer()) then return end
	if cooldown > CurTime() then return end
	cooldown = CurTime() + 1
	PerfectCasino.UI.Config()
end

function TOOL:Reload(trace)
	if CLIENT then return end
	if not PerfectCasino.Core.Access(self:GetOwner()) then return end
	local entity = trace.Entity
	if not entity.DatabaseID then return end
	PerfectCasino.Database.DeleteEntityByID(entity.DatabaseID)
	entity:Remove()
end

concommand.Add("pcasino_remove_ent", function(ply)
	if CLIENT then return end
	if not PerfectCasino.Core.Access(ply) then return end
	local entity = ply:GetEyeTrace().Entity
	if not entity.DatabaseID then return end
	PerfectCasino.Database.DeleteEntityByID(entity.DatabaseID)
	entity:Remove()
end)

concommand.Add("pcasino_update_pos", function(ply)
	if CLIENT then return end
	if not IsValid(ply) then return end
	if not PerfectCasino.Core.Access(ply) then return end
	PerfectCasino.Database.UpdateAllPositions()
end)

function TOOL:Think()
	if SERVER then return end
	if not PerfectCasino.Core.Access(LocalPlayer()) then return end

	if not PerfectCasino.UI.CurrentSettings.Entity then
		if IsValid(currentEnt) then
			currentEnt:Remove()
		end

		return
	end

	if not IsValid(currentEnt) then
		currentEnt = ents.CreateClientProp()
		currentEnt:SetModel(PerfectCasino.Core.Entites[PerfectCasino.UI.CurrentSettings.Entity].model)
		currentEnt:SetMaterial("models/wireframe")
		currentEnt:Spawn()
	end

	if not (currentEnt:GetModel() == PerfectCasino.Core.Entites[PerfectCasino.UI.CurrentSettings.Entity].model) then
		currentEnt:SetModel(PerfectCasino.Core.Entites[PerfectCasino.UI.CurrentSettings.Entity].model)
	end

	trace = LocalPlayer():GetEyeTrace()
	plyAngle = LocalPlayer():GetAngles()
	currentEnt:SetPos(trace.HitPos + plyAngle:Forward() + plyAngle:Up() + (offset[PerfectCasino.UI.CurrentSettings.Entity] and offset[PerfectCasino.UI.CurrentSettings.Entity](currentEnt) or vector_origin))
	currentEnt:SetAngles(Angle(0, math.Round(plyAngle.y / 10) * 10 + 180, plyAngle.z) + (ang[PerfectCasino.UI.CurrentSettings.Entity] and ang[PerfectCasino.UI.CurrentSettings.Entity](currentEnt) or angle_zero))
end

function TOOL:Holster()
	if IsValid(currentEnt) then
		currentEnt:Remove()
		currentEnt = nil
	end
end

concommand.Add('CASINO_TEST_MENU', function()
	PerfectCasino.UI.Config()
end)

concommand.Add('CASINO_TEST_STAVIT', function()
	local trace = LocalPlayer():GetEyeTrace()
	plyAngle = LocalPlayer():GetAngles()
	net.Start("pCasino:ToolGun:CreateEntity")
	net.WriteString(PerfectCasino.UI.CurrentSettings.Entity)
	net.WriteTable(PerfectCasino.UI.CurrentSettings.Settings)
	net.WriteVector(trace.HitPos + plyAngle:Forward() + plyAngle:Up() + (offset[PerfectCasino.UI.CurrentSettings.Entity] and offset[PerfectCasino.UI.CurrentSettings.Entity](currentEnt) or vector_origin))
	net.WriteAngle(Angle(0, math.Round(plyAngle.y / 10) * 10 + 180, plyAngle.z) + (ang[PerfectCasino.UI.CurrentSettings.Entity] and ang[PerfectCasino.UI.CurrentSettings.Entity](currentEnt) or angle_zero))
	net.SendToServer()
end)

concommand.Add('CASINO_TEST_DELETE', function()
	net.Start('KOSTIL')
	net.SendToServer()
end)

if SERVER then
	util.AddNetworkString('KOSTIL')

	net.Receive('KOSTIL', function(len, ply)
		if not PerfectCasino.Core.Access(ply) then return end
		local trace = ply:GetEyeTrace()
		local entity = trace.Entity
		if not entity.DatabaseID then return end
		PerfectCasino.Database.DeleteEntityByID(entity.DatabaseID)
		entity:Remove()
	end)
end
--PATH gamemodes/darkrp/entities/weapons/gmod_tool/stools/weld.lua:
/*
TOOL.Category = "Constraints"
TOOL.Name = "#tool.weld.name"
-- cvb 
TOOL.ClientConVar[ "forcelimit" ] = "0"

function TOOL:LeftClick(trace)

	if (self:GetOperation() == 1) then return false end
	if (not IsValid(trace.Entity)) && trace.Entity:IsPlayer() then return false end

	-- If there's no physics object then we can't constraint it!
	if (SERVER && !util.IsValidPhysicsObject(trace.Entity, trace.PhysicsBone)) then return false end

	local iNum = self:NumObjects()
	local Phys = trace.Entity:GetPhysicsObjectNum(trace.PhysicsBone)
	self:SetObject(iNum + 1, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal)

	if (CLIENT) then

		if (iNum > 0) then self:ClearObjects() end
		return true

	end

	self:SetOperation(2)

	if (iNum == 0) then

		self:SetStage(1)
		return true

	end

	if (iNum == 1) then

		-- Get client's CVars
		local forcelimit = self:GetClientNumber("forcelimit")
		local nocollide = false

		-- Get information we're about to use
		local Ent1, Ent2 = self:GetEnt(1), self:GetEnt(2)
		local Bone1, Bone2 = self:GetBone(1), self:GetBone(2)

		local constraint = constraint.Weld(Ent1, Ent2, Bone1, Bone2, forcelimit, nocollide)
		if (constraint) then

			undo.Create("Weld")
				undo.AddEntity(constraint)
				undo.SetPlayer(self:GetOwner())
			undo.Finish()

			self:GetOwner():AddCleanup("constraints", constraint)

			Ent1.Weld = true
			Ent2.Weld = true
			//table.insert(Ent1.WeldWho,Ent2)
			//table.insert(Ent1.WeldWho,Ent1)
//
			//table.insert(Ent2.WeldWho,Ent2)
			//table.insert(Ent2.WeldWho,Ent1)
//
			//table.insert(Ent2.WeldWho,Ent1.WeldWho)
			//table.insert(Ent1.WeldWho,Ent2.WeldWho)

			-- Freeze props
			local po
			po = Ent1:GetPhysicsObject() if (IsValid(po)) then po:EnableMotion(false) self:GetOwner():AddFrozenPhysicsObject(Ent1, po) end
			po = Ent2:GetPhysicsObject() if (IsValid(po)) then po:EnableMotion(false) self:GetOwner():AddFrozenPhysicsObject(Ent2, po) end
		end

		-- Clear the objects so we're ready to go again
		self:ClearObjects()

	end

	return true

end

function TOOL:RightClick(trace)

	if (self:GetOperation() == 2) then return false end

	-- Make sure the object we're about to use is valid
	local iNum = self:NumObjects()
	local Phys = trace.Entity:GetPhysicsObjectNum(trace.PhysicsBone)

	-- You can click anywhere on the 3rd pass
	if (iNum < 2) then

		-- If there's no physics object then we can't constraint it!
		if (SERVER && !util.IsValidPhysicsObject(trace.Entity, trace.PhysicsBone)) then return false end

		-- Don't weld players, or to players
		if (trace.Entity:IsPlayer() or trace.Entity:IsWorld()) then return false end

		-- Don't do anything with stuff without any physics..
		if (SERVER && !IsValid(Phys)) then return false end

	end

	if (iNum == 0) then

		if (!IsValid(trace.Entity)) then return false end
		if (trace.Entity:GetClass() == "prop_vehicle_jeep") then return false end

	end

	self:SetObject(iNum + 1, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal)
	self:SetOperation(1)

	--
	-- Stage 0 - grab an object, make a ghost entity
	--
	if (iNum == 0) then

		self:StartGhostEntity(trace.Entity)
		self:SetStage(1)
		return true

	end

	--
	-- Stage 1 - choose the spot and object to weld it to
	--
	if (iNum == 1) then

		if (CLIENT) then
			self:ReleaseGhostEntity()
			return true
		end

		-- Get information we're about to use
		local Norm1, Norm2 = self:GetNormal(1), self:GetNormal(2)
		local Phys1 = self:GetPhys(1)
		local WPos2 = self:GetPos(2)

		-- Note: To keep stuff ragdoll friendly try to treat things as physics objects rather than entities
		local Ang1, Ang2 = Norm1:Angle(), (-Norm2):Angle()
		local TargetAngle = Phys1:AlignAngles(Ang1, Ang2)

		Phys1:SetAngles(TargetAngle)

		-- Move the object so that the hitpos on our object is at the second hitpos
		local TargetPos = WPos2 + (Phys1:GetPos() - self:GetPos(1))

		-- Set the position
		Phys1:SetPos(TargetPos)
		Phys1:EnableMotion(false)

		-- Wake up the physics object so that the entity updates
		Phys1:Wake()

		self.RotAxis = Norm2

		self:ReleaseGhostEntity()

		self:SetStage(2)

		return true

	end

	--
	-- Stage 2 - Weld it in place.
	--
	if (iNum == 2) then

		if (CLIENT) then

			self:ClearObjects()
			return true

		end

		-- Get client's CVars
		local forcelimit = self:GetClientNumber("forcelimit")
		local nocollide = false

		-- Get information we're about to use
		local Ent1, Ent2 = self:GetEnt(1), self:GetEnt(2)
		local Bone1, Bone2 = self:GetBone(1),	self:GetBone(2)
		local Phys1 = self:GetPhys(1)

		-- The entity became invalid half way through
		if (!IsValid(Ent1)) then

			self:ClearObjects()
			return false

		end

		local constraint = constraint.Weld(Ent1, Ent2, Bone1, Bone2, forcelimit, nocollide)
		if (constraint) then

			Phys1:EnableMotion(true)

			undo.Create("Weld")
				undo.AddEntity(constraint)
				undo.SetPlayer(self:GetOwner())
			undo.Finish()

			self:GetOwner():AddCleanup("constraints", constraint)

		end

		-- Clear the objects so we're ready to go again
		self:ClearObjects()
		return true

	end

end

function TOOL:Think()

	if (self:NumObjects() < 1) then return end

	if (self:GetOperation() == 1) then

		if (SERVER && !IsValid(self:GetEnt(1))) then

			self:ClearObjects()
			return

		end

		if (self:NumObjects() == 1) then

			self:UpdateGhostEntity()
			return

		end

		if (SERVER && self:NumObjects() == 2) then

			local Phys1 = self:GetPhys(1)

			local cmd = self:GetOwner():GetCurrentCommand()

			local degrees = cmd:GetMouseX() * 0.05

			local angle = Phys1:RotateAroundAxis(self.RotAxis, degrees)

			Phys1:SetAngles(angle)

			-- Move so spots join up
			local TargetPos = self:GetPos(2 ) + (Phys1:GetPos() - self:GetPos(1))
			Phys1:SetPos(TargetPos)
			Phys1:Wake()

		end

	end

end

function TOOL:Reload(trace)

	if (!IsValid(trace.Entity) || trace.Entity:IsPlayer()) then return false end
	if (CLIENT) then return true end

	self:ClearObjects()

	return constraint.RemoveConstraints(trace.Entity, "Weld")

end

function TOOL:FreezeMovement()

	return self:GetOperation() == 1 && self:GetStage() == 2

end

function TOOL:Holster()

	self:ClearObjects()

end

function TOOL.BuildCPanel(CPanel)

	CPanel:AddControl("Header", { Description	= "#tool.weld.help" })
	CPanel:AddControl("Slider", { Label = "#tool.forcelimit", Command = "weld_forcelimit", Type = "Float", Min = 0, Max = 1000, Help = true })

end

*/
--PATH addons/__main/lua/weapons/l96_dragon/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("l96_dragon") -- must be the name of your swep but NO CAPITALS!
SWEP.Category				= "CSO/CF Weapons" --Category where you will find your weapons
SWEP.Author				= "Zekeou"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.PrintName				= "L96 Dragon"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 4			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= false	-- Set false if you want no crosshair from hip
SWEP.Weight				= 30			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.DrawCrossHair          = false
SWEP.XHair					= false		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.BoltAction				= true		-- Is this a bolt action rifle?
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_snip_awm.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_snip_awm.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= true
SWEP.Base 				= "zekeou_scoped_base" --the Base this weapon will work on. PLEASE RENAME THE BASE!
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("weapons/CF_L96/G_MZC_AWM_FIRE.wav")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 35		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 17		-- Size of a clip
SWEP.Primary.DefaultClip			= 34	-- Bullets you start with
SWEP.Primary.KickUp			= 1				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 1			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal			= 1		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "SniperPenetratedRound"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.ScopeZoom			= 8	
SWEP.Secondary.UseACOG			= false -- Choose one scope type
SWEP.Secondary.UseMilDot		= true	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	

SWEP.data 				= {}
SWEP.data.ironsights			= 1
SWEP.ScopeScale 			= 0.5
SWEP.ReticleScale 				= 0.6

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 199	--base damage per bullet
SWEP.Primary.Spread		= .01	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .0001 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector(-7.323, -3.859, 2.759)
SWEP.IronSightsAng = Vector(0.275, -2.481, 0)
SWEP.SightsPos = Vector(-7.323, -3.859, 2.759)
SWEP.SightsAng = Vector(0.275, -2.481, 0)
SWEP.RunSightsPos = Vector (0, 0, 0)
SWEP.RunSightsAng = Vector (0, 0, 0)

--PATH addons/__main/lua/weapons/m3_umbrella/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m3_umbrella") -- must be the name of your swep
SWEP.Category				= "CSO/CF Weapons" --Category where you will find your weapons
SWEP.Author				= "Zekeou"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.PrintName				= "Lightning SG-1 Umbrella Gun"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 3			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative to other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "shotgun"

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_shot_m3umbrela.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_shot_xm1014.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= false
SWEP.Base 				= "zekeou_shotty_base" --the Base this weapon will work on. PLEASE RENAME THE BASE!
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("weapons/M3_Umbrella/Umbrella Gun Fire.wav")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 70		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 8			-- Size of a clip
SWEP.Primary.DefaultClip			= 30	-- Default number of bullets in a clip
SWEP.Primary.KickUp			= 5				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.8		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal			= 0.6	-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "buckshot"

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 

SWEP.ShellTime			= .34

SWEP.Primary.NumShots	= 9		-- How many bullets to shoot per trigger pull, AKA pellets
SWEP.Primary.Damage		= 11	-- Base damage per bullet
SWEP.Primary.Spread		= .035	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .035	-- Ironsight accuracy, should be the same for shotguns
-- Because irons don't magically give you less pellet spread!

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(3.359, 0, 2.519)
SWEP.IronSightsAng = Vector(-1.043, 0.488, 0)
SWEP.SightsPos = Vector(3.359, 0, 2.519)
SWEP.SightsAng = Vector(-1.043, 0.488, 0)
SWEP.RunSightsPos = Vector (0, 0, 0)
SWEP.RunSightsAng = Vector (0, 0, 0)

SWEP.WElements = {
	["M3_Umbrella"] = { type = "Model", model = "models/weapons/w_shot_m3umbrela.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.743, -0.08, 1.437), angle = Angle(-8.886, -2.445, 180), size = Vector(0.999, 0.999, 0.999), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

--PATH addons/__main/lua/weapons/m9k_amd65/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_amd65")					-- must be the name of your swep
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "AMD 65"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 24			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_amd_65.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_amd_65.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("amd65.single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 750			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 20		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= .7		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.2		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.4		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "ar2"

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 31	-- Base damage per bullet
SWEP.Primary.Spread		= .021	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .011 -- Ironsight accuracy, should be the same for shotguns


SWEP.SelectiveFire		= true

//just cleaning up an empty spot that bugs me
SWEP.VElements = {
	["element"] = { type = "Model", model = "models/Mechanics/wheels/wheel_speed_72.mdl", bone = "Havana Daydreamin", rel = "", pos = Vector(-0.15, -5.336, 1.608), angle = Angle(0, 0, 90), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.IronSightsPos = Vector(3.5, -2.21, 2.115)
SWEP.IronSightsAng = Vector(-3.701, 0, 0)
SWEP.SightsPos = Vector(3.5, -2.21, 2.115)
SWEP.SightsAng = Vector(-3.701, 0, 0)
SWEP.RunSightsPos = Vector(-5.198, -9.164, 0)
SWEP.RunSightsAng = Vector(-8.825, -70, 0)


if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_aw50/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_aw50") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Sniper Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "AI AW50"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 50			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= false		-- Set false if you want no crosshair from hip
SWEP.XHair					= false		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.Weight				= 50			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.BoltAction				= true		-- Is this a bolt action rifle?
SWEP.HoldType 				= "rpg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_aw50_awp.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_acc_int_aw50.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Weaponaw50.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 50		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 10		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp				= 1				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 1			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 1		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "SniperPenetratedRound"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.ScopeZoom			= 9	
SWEP.Secondary.UseACOG			= false -- Choose one scope type
SWEP.Secondary.UseMilDot		= false	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= true	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= false
SWEP.Secondary.UseMatador		= false

SWEP.data 				= {}
SWEP.data.ironsights		= 1
SWEP.ScopeScale 			= 0.7
SWEP.ReticleScale 			= 0.6

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 95	--base damage per bullet
SWEP.Primary.Spread		= .01	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .0001 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector(3.68, 0, 1.08)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(3.68, 0, 1.08)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector (-2.3095, -3.0514, 2.3965)
SWEP.RunSightsAng = Vector (-19.8471, -33.9181, 10)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_g3a3/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_g3a3") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "HK G3A3"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 30			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_hk_g3_rif.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_hk_g3.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= true	
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("hk_g3_weapon.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 550			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 20		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.4		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.5		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "ar2"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 33	-- Base damage per bullet
SWEP.Primary.Spread		= .026	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .016 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-2.419, -2.069, 1.498)
SWEP.IronSightsAng = Vector(-0.109, -0.281, 0)
SWEP.SightsPos = Vector(-2.419, -2.069, 1.498)
SWEP.SightsAng = Vector(-0.109, -0.281, 0)
SWEP.RunSightsPos = Vector(3.384, -3.044, -0.264)
SWEP.RunSightsAng = Vector(-7.402, 43.334, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end


if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_kac_pdw/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_kac_pdw") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Submachine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "KAC PDW"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 44			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "smg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_kac_pdw1.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_kac_pdw.mdl"	-- Weapon world model 
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("KAC_PDW.Single")		-- Script that calls the primary fire sound
SWEP.Primary.SilencedSound 	= Sound("KAC_PDW.SilentSingle")
SWEP.Primary.RPM			= 600			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.1		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.1		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.2		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.CanBeSilenced		= true

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 15	-- Base damage per bullet
SWEP.Primary.Spread		= .025	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .015 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(3.342, 0, 0.759)
SWEP.IronSightsAng = Vector(2.46, -0.025, 0)
SWEP.SightsPos = Vector(3.342, 0, 0.759)
SWEP.SightsAng = Vector(2.46, -0.025, 0)
SWEP.RunSightsPos = Vector(-4.646, -4.173, 0)
SWEP.RunSightsAng = Vector(-10.197, -53.189, 0)

SWEP.WElements = {
	["eotech"] = { type = "Model", model = "models/wystan/attachments/eotech557sight.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(-7.539, 1.485, 10.295), angle = Angle(-172.297, 180, 0), size = Vector(1.378, 1.378, 1.378), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.VElements = {
	["eotech"] = { type = "Model", model = "models/wystan/attachments/eotech557sight.mdl", bone = "DrawCall_0", rel = "", pos = Vector(-0.281, 10.85, -6.398), angle = Angle(0, 90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.ViewModelBoneMods = {
	["DrawCall_0009"] = { scale = Vector(1, 1, 1), pos = Vector(-0.154, 0, 0), angle = Angle(0, 0, 0) }
}

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_l85/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_l85") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "L85"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 32			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- Set false if you want no crosshair from hip
SWEP.Weight				= 50			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.XHair					= true		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.BoltAction				= false		-- Is this a bolt action rifle?
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_rif_l85.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_l85a2.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Weapon_l85.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 675		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp				= .4				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= .4			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= .5		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "ar2"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.ScopeZoom			= 4	
SWEP.Secondary.UseACOG			= true -- Choose one scope type
SWEP.Secondary.UseMilDot		= false	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= false
SWEP.Secondary.UseMatador		= false

SWEP.data 				= {}
SWEP.data.ironsights		= 1
SWEP.ScopeScale 			= 0.5
SWEP.ReticleScale 			= 0.6

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 29	--base damage per bullet
SWEP.Primary.Spread		= .023	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .015 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector (2.275, -2.9708, 0.5303)
SWEP.IronSightsAng = Vector (0, 0, 0)
SWEP.SightsPos = Vector (2.275, -2.9708, 0.5303)
SWEP.SightsAng = Vector (0, 0, 0)
SWEP.RunSightsPos = Vector (-3.0328, 0, 1.888)
SWEP.RunSightsAng = Vector (-24.2146, -36.522, 10)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_m3/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_m3") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Shotguns"
SWEP.Author				= "iron angles and models hexed and converted to gmod my Mr Fokkusu"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Benelli M3"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 24			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "shotgun"	-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_benelli_m3_s90.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_benelli_m3.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_shotty_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("BenelliM3.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 70		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 8			-- Size of a clip
SWEP.Primary.DefaultClip		= 30	-- Default number of bullets in a clip
SWEP.Primary.KickUp				= 0.8			-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.5		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3	-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "buckshot"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.ShellTime			= .45

SWEP.Primary.NumShots	= 9		-- How many bullets to shoot per trigger pull, AKA pellets
SWEP.Primary.Damage		= 10	-- Base damage per bullet
SWEP.Primary.Spread		= .0326	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .0326	-- Ironsight accuracy, should be the same for shotguns
-- Because irons don't magically give you less pellet spread!

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(2.279, -1.007, 1.302)
SWEP.IronSightsAng = Vector(0.47, -0.024, 0)
SWEP.SightsPos = Vector(2.279, -1.007, 1.302)
SWEP.SightsAng = Vector(0.47, -0.024, 0)
SWEP.RunSightsPos = Vector(-7.639, -7.796, 0.865)
SWEP.RunSightsAng = Vector(-17.362, -69.724, 0)


if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_mp40/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_mp40") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Submachine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "MP40"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 50			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "smg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 55
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_mp40smg.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_mp40smg.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= true
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("mp40.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 500			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 32		-- Size of a clip
SWEP.Primary.DefaultClip		= 64		-- Bullets you start with
SWEP.Primary.KickUp				= 0.3		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.2		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.4		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 25	-- Base damage per bullet
SWEP.Primary.Spread		= .022	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .015 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(3.881, 0.187, 1.626)
SWEP.IronSightsAng = Vector(-0.047, 0, 0)
SWEP.SightsPos = Vector(3.881, 0.187, 1.626)
SWEP.SightsAng = Vector(-0.047, 0, 0)
SWEP.RunSightsPos = Vector(-5.119, -4.173, 0.865)
SWEP.RunSightsAng = Vector(-9.094, -56.496, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_mp5/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_mp5") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Submachine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "HK MP5"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 46			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_navymp5.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_hk_mp5.mdl"	-- Weapon world model 
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("mp5_navy_Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 800			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.1		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.1		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.2		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 22	-- Base damage per bullet
SWEP.Primary.Spread		= .023	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .013 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(2.549, -0.927, 1.09)
SWEP.IronSightsAng = Vector(0.125, -0.071, 0)
SWEP.SightsPos = Vector(2.549, -0.927, 1.09)
SWEP.SightsAng = Vector(0.125, -0.071, 0)
SWEP.RunSightsPos = Vector (-3.0328, 0, 1.888)
SWEP.RunSightsAng = Vector (-24.2146, -36.522, 10)



if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_mp5sd/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_mp5sd") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Submachine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "MP5SD"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 47			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_hkmp5sd.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_hk_mp5sd.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base" 
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_hkmp5sd.single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 700			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.2		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.2		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 65		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 30	-- Base damage per bullet
SWEP.Primary.Spread		= .025	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .015 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-2.284, -1.446, 0.884)
SWEP.IronSightsAng = Vector(2.368, 0, 0)
SWEP.SightsPos = Vector(-2.284, -1.446, 0.884)
SWEP.SightsAng = Vector(2.368, 0, 0)
SWEP.RunSightsPos = Vector(3.858, -1.655, -0.866)
SWEP.RunSightsAng = Vector(-4.634, 49.493, 0)



if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_remington870/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_remington870") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Shotguns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Remington 870"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 26			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "shotgun"	-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_rem870tactical.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_remington_870_tact.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_shotty_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("WepRem870.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 70		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 8			-- Size of a clip
SWEP.Primary.DefaultClip		= 30	-- Default number of bullets in a clip
SWEP.Primary.KickUp				= 1.25				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.8		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.4	-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "buckshot"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.ShellTime			= .45

SWEP.Primary.NumShots	= 9		-- How many bullets to shoot per trigger pull, AKA pellets
SWEP.Primary.Damage		= 10	-- Base damage per bullet
SWEP.Primary.Spread		= .035	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .035	-- Ironsight accuracy, should be the same for shotguns
-- Because irons don't magically give you less pellet spread!

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-2.014, 0.1, 1.2)
SWEP.IronSightsAng = Vector(0.551, 0.028, 0)
SWEP.SightsPos = Vector(-2.014, 0.1, 1.2)
SWEP.SightsAng = Vector(0.551, 0.028, 0)
SWEP.RunSightsPos = Vector(6.534, -4.646, 1.654)
SWEP.RunSightsAng = Vector(-19.567, 68.622, 0)


if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_smgp90/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_smgp90") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Submachine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "FN P90"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 51			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "rpg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_p90_smg.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_fn_p90.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("P90_weapon.single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 900			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 50		-- Size of a clip
SWEP.Primary.DefaultClip		= 100		-- Bullets you start with
SWEP.Primary.KickUp				= 0.6		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.4		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.5		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 18	-- Base damage per bullet
SWEP.Primary.Spread		= .032	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .02 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(2.707, -2.46, 2.219)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(2.707, -2.46, 2.219)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector (-2.3095, -3.0514, 2.3965)
SWEP.RunSightsAng = Vector (-19.8471, -33.9181, 10)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_spas12/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_spas12") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Shotguns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "SPAS 12"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 27			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "shotgun"	-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_spas12_shot.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_spas_12.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_shotty_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("spas_12_shoty.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 350		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 8			-- Size of a clip
SWEP.Primary.DefaultClip		= 30	-- Default number of bullets in a clip
SWEP.Primary.KickUp				= 1.5				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.7	-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "buckshot"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 
SWEP.ShellTime			= .4

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 10		-- How many bullets to shoot per trigger pull, AKA pellets
SWEP.Primary.Damage		= 10	-- Base damage per bullet
SWEP.Primary.Spread		= .03	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .03	-- Ironsight accuracy, should be the same for shotguns
-- Because irons don't magically give you less pellet spread!

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(2.657, .394, 1.659)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(2.657, .394, 1.659)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(-3.116, -3.935, 0.492)
SWEP.RunSightsAng = Vector(-19.894, -47.624, 10.902)



if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_svu/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_svu") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Sniper Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Dragunov SVU"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 49			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= false		-- Set false if you want no crosshair from hip
SWEP.XHair					= false		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.Weight				= 50			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.BoltAction				= false		-- Is this a bolt action rifle?
SWEP.HoldType 				= "rpg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_sniper_svu.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_dragunov_svu.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Weapon_SVU.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 400		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 10		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp				= 1				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 1			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 1		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "SniperPenetratedRound"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.ScopeZoom			= 9	
SWEP.Secondary.UseACOG			= false -- Choose one scope type
SWEP.Secondary.UseMilDot		= false	-- I mean it, only one	
SWEP.Secondary.UseSVD			= true	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= false
SWEP.Secondary.UseMatador		= false

SWEP.data 				= {}
SWEP.data.ironsights		= 1
SWEP.ScopeScale 			= 0.7
SWEP.ReticleScale 			= 0.6

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 93	--base damage per bullet
SWEP.Primary.Spread		= .01	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .0001 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector(-3.24, 0, 0.88)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(-3.24, 0, 0.88)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(3.143, -6, 0.286)
SWEP.RunSightsAng = Vector(-5, 55, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/_ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}
bshields.shields = {
	{
		[1] = {
			["angles"] = Angle( 4, 6, -14 ),
			["position"] = Vector( 0, 8, -1 )
		},
		[2] = {
			["angles"] = Angle( 6, 6, -12 ),
			["position"] = Vector( 8, 10, -4 )
		},
		[3] = {
			["angles"] = Angle( -3, 7, -16 ),
			["position"] = Vector( -1, 4, -3 )
		}
	},
	{
		[1] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 6, -4, -8 )
		},
		[2] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 16, -3, -12 )
		},
		[3] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 6, -3, -12 )
		}
	},
	{
		[1] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -7, -13 )
		},
		[2] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -6, -22 )
		},
		[3] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -8, -12 )
		}
	}
}
--PATH addons/swb_base/lua/weapons/swb_base/shared.lua:
if SERVER then
	include("sv_filestodownload.lua")
end

AddCSLuaFile()
AddCSLuaFile("sh_bullets.lua")
AddCSLuaFile("cl_model.lua")
AddCSLuaFile("cl_hud.lua")
AddCSLuaFile("cl_calcview.lua")
AddCSLuaFile("sh_ammotypes.lua")
AddCSLuaFile("sh_move.lua")
AddCSLuaFile("sh_sounds.lua")
AddCSLuaFile("cl_playerbindpress.lua")

include("sh_bullets.lua")
include("sh_ammotypes.lua")
include("sh_move.lua")
include("sh_sounds.lua")


if CLIENT then
	include("cl_calcview.lua")
	include("cl_playerbindpress.lua")
	include("cl_model.lua")
	include("cl_hud.lua")
	
	SWEP.DrawCrosshair = false
	SWEP.BounceWeaponIcon = false
	SWEP.DrawWeaponInfoBox = false
	SWEP.CurFOVMod = 0
	SWEP.BobScale = 0
	SWEP.SwayScale = 0
	SWEP.ZoomAmount = 15
	SWEP.FadeCrosshairOnAim = true
	SWEP.DrawAmmo = true
	SWEP.DrawTraditionalWorldModel = true
	SWEP.CrosshairEnabled = true
	SWEP.ViewbobEnabled = true
	SWEP.ViewbobIntensity = 1
	SWEP.ReloadViewBobEnabled = true
	SWEP.RVBPitchMod = 1
	SWEP.RVBYawMod = 1
	SWEP.RVBRollMod = 1
	SWEP.BulletDisplay = 0
	SWEP.Shell = "mainshell"
	SWEP.ShellScale = 1
	SWEP.ZoomAmount = 15
	SWEP.CSMuzzleFlashes  = true
	SWEP.ZoomWait = 0
	SWEP.CrosshairParts = {left = true, right = true, upper = true, lower = true}
	SWEP.FireModeDisplayPos = "middle"
	SWEP.SwimPos = Vector(0, 0, -2.461)
	SWEP.SwimAng = Vector(-26.57, 0, 0)
end

SWEP.FadeCrosshairOnAim = true

if SERVER then
	include("sv_hooks.lua")
	SWEP.PlayBackRateSV = 1
end

SWEP.AimMobilitySpreadMod = 0.5
SWEP.PenMod = 1
SWEP.AmmoPerShot = 1
SWEP.SWBWeapon = true
SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 50
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= ""
SWEP.WorldModel		= ""
SWEP.AnimPrefix		= "fist"

SWEP.Spawnable			= false
SWEP.AdminSpawnable		= false

SWEP.Primary.ClipSize		= -1					// Size of a clip
SWEP.Primary.DefaultClip	= -1				// Default number of bullets in a clip
SWEP.Primary.Automatic		= false				// Automatic/Semi Auto
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1				// Size of a clip
SWEP.Secondary.DefaultClip	= -1				// Default number of bullets in a clip
SWEP.Secondary.Automatic	= true				// Automatic/Semi Auto
SWEP.Secondary.Ammo			= "none"

SWEP.AddSpread = 0
SWEP.SpreadWait = 0
SWEP.AddSpreadSpeed = 1
SWEP.ReloadWait = 0
SWEP.PlayBackRateHip = 1
SWEP.PlayBackRate = 1
SWEP.ReloadSpeed = 1

SWEP.Chamberable = true
SWEP.UseHands = true
SWEP.CanPenetrate = true
SWEP.CanRicochet = true
SWEP.AddSafeMode = true
SWEP.Suppressable = false
SWEP.SprintingEnabled = true
SWEP.HolsterUnderwater = true
SWEP.HolsterOnLadder = true

SWEP.BurstCooldownMul = 1.75
SWEP.BurstSpreadIncMul = 0.5
SWEP.BurstRecoilMul = 0.85
SWEP.DeployTime = 1
SWEP.Shots = 1
SWEP.FromActionToNormalWait = 0
SWEP.ShotgunReloadState = 0

SWB_IDLE = 0
SWB_RUNNING = 1
SWB_AIMING = 2
SWB_ACTION = 3

SWEP.FireModeNames = {["auto"] = {display = "FULL-AUTO", auto = true, burstamt = 0, buldis = 5},
	["semi"] = {display = "SEMI-AUTO", auto = false, burstamt = 0, buldis = 1},
	["double"] = {display = "DOUBLE-ACTION", auto = false, burstamt = 0, buldis = 1},
	["bolt"] = {display = "BOLT-ACTION", auto = false, burstamt = 0, buldis = 1},
	["pump"] = {display = "PUMP-ACTION", auto = false, burstamt = 0, buldis = 1},
	["break"] = {display = "BREAK-ACTION", auto = false, burstamt = 0, buldis = 1},
	["2burst"] = {display = "2-ROUND BURST", auto = true, burstamt = 2, buldis = 2},
	["3burst"] = {display = "3-ROUND BURST", auto = true, burstamt = 3, buldis = 3},
	["safe"] = {display = "SAFE", auto = false, burstamt = 0, buldis = 0}}

local math = math

function SWEP:IsEquipment() -- I have no idea what I'm doing, help
	return WEPS.IsEquipment(self)
end

function SWEP:CalculateEffectiveRange()
	self.EffectiveRange = self.CaseLength * 10 - self.BulletDiameter * 5 -- setup realistic base effective range
	self.EffectiveRange = self.EffectiveRange * 39.37 -- convert meters to units
	self.EffectiveRange = self.EffectiveRange * 0.25
	self.DamageFallOff = (100 - (self.CaseLength - self.BulletDiameter)) / 200
	self.PenStr = (self.BulletDiameter * 0.5 + self.CaseLength * 0.35) * (self.PenAdd and self.PenAdd or 1)
	self.PenetrativeRange = self.EffectiveRange * 0.5
end

local tbl, tbl2

function SWEP:Initialize()
	self:SetHoldType(self.NormalHoldType)
	self:CalculateEffectiveRange()
	self.CHoldType = self.NormalHoldType
	
	if self.AddSafeMode then
		table.insert(self.FireModes, #self.FireModes + 1, "safe")
	end
	
	t = self.FireModes[1]
	self.FireMode = t
	t = self.FireModeNames[t]
	
	self.Primary.Auto = t.auto
	self.BurstAmount = t.burstamt
	
	self.CurCone = self.HipSpread
	self.Primary.ClipSize_Orig = self.Primary.ClipSize
	
	if CLIENT then
		self.ViewModelFOV_Orig = self.ViewModelFOV
		self.BulletDisplay = t.buldis
		self.FireModeDisplay = t.display
		
		if self.WM then
			self.WMEnt = ClientsideModel(self.WM, RENDERGROUP_BOTH)
			self.WMEnt:SetNoDraw(true)
		end
	end
end

function SWEP:SetupDataTables()
	self:DTVar("Int", 0, "State")
	self:DTVar("Int", 1, "Shots")
	self:DTVar("Bool", 0, "Suppressed")
	self:DTVar("Bool", 1, "Safe")
end

local vm, CT, aim, cone, vel, CT, tr
local td = {}

function SWEP:Deploy()
	if self.dt.Suppressed then
		self:SendWeaponAnim(ACT_VM_DRAW_SILENCED)
	else
		self:SendWeaponAnim(ACT_VM_DRAW)
	end
			
	self.dt.State = SWB_IDLE
	CT = CurTime()
	
	self:SetNextSecondaryFire(CT + self.DeployTime)
	self:SetNextPrimaryFire(CT + self.DeployTime)
	return true
end

function SWEP:Holster()
	if self.ReloadDelay then
		return false
	end
	
	self.ShotgunReloadState = 0
	self.ReloadDelay = nil
	self.dt.State = SWB_IDLE
	return true
end

local mag

function SWEP:Reload()
	CT = CurTime()
	
	if self.ReloadDelay or CT < self.ReloadWait or self.dt.State == SWB_ACTION or self.ShotgunReloadState != 0 then
		return
	end
	
	if self.Owner:KeyDown(IN_USE) and self.dt.State != SWB_RUNNING then
		self:CycleFiremodes()
		return
	end
	
	mag = self:Clip1()
	
	if (self.Chamberable and mag >= self.Primary.ClipSize + 1) or (not self.Chamberable and mag >= self.Primary.ClipSize) or self.Owner:GetAmmoCount(self.Primary.Ammo) == 0 then
		return
	end
	
	if self.dt.State != SWB_RUNNING then
		self.dt.State = SWB_IDLE
	end
	
	if self.ShotgunReload then
		self.ShotgunReloadState = 1
		self:SendWeaponAnim(ACT_SHOTGUN_RELOAD_START)
		self.ReloadDelay = CT + self.ReloadStartWait
	else
		if self.Chamberable then
			if mag == 0 then
				self.Primary.ClipSize = self.Primary.ClipSize_Orig
			else
				self.Primary.ClipSize = self.Primary.ClipSize_Orig + 1
			end
		end
		
		if self.dt.Suppressed then
			self:DefaultReload(ACT_VM_RELOAD_SILENCED)
		else
			self:DefaultReload(ACT_VM_RELOAD)
		end
		
		self.Owner:SetAnimation(PLAYER_RELOAD)
	end
	--[[self:SendWeaponAnim(ACT_VM_RELOAD)
	
	vm = self.Owner:GetViewModel() 
	vm:SetPlaybackRate(self.ReloadSpeed)
	dur = vm:SequenceDuration() / self.ReloadSpeed
	
	self.ReloadDelay = CT + dur]]--
	--self:SetNextPrimaryFire(CT + dur)
	--self:SetNextSecondaryFire(CT + dur)
end

function SWEP:CycleFiremodes()
	t = self.FireModes
	
	if not t.last then
		t.last = 2
	else
		if not t[t.last + 1] then
			t.last = 1
		else
			t.last = t.last + 1
		end
	end
	
	if self.dt.State == SWB_AIMING then
		if self.FireModes[t.last] == "safe" then
			t.last = 1
		end
	end
	
	if self.FireMode != self.FireModes[t.last] and self.FireModes[t.last] then
		CT = CurTime()
		self:SelectFiremode(self.FireModes[t.last])
		self:SetNextPrimaryFire(CT + 0.25)
		self:SetNextSecondaryFire(CT + 0.25)
		self.ReloadWait = CT + 0.25
	end
end

function SWEP:SelectFiremode(n)
	if CLIENT then
		return
	end
	
	t = self.FireModeNames[n]
	self.Primary.Automatic = t.auto
	self.FireMode = n
	self.BurstAmount = t.burstamt
	
	if self.FireMode == "safe" then
		self.dt.Safe = true -- more reliable than umsgs
	else
		self.dt.Safe = false
	end
	
	umsg.Start("SWB_FIREMODE")
		umsg.Entity(self.Owner)
		umsg.String(n)
	umsg.End()
end

local reg = debug.getregistry()
local GetVelocity = reg.Entity.GetVelocity
local Length = reg.Vector.Length
local GetAimVector = reg.Player.GetAimVector

function SWEP:CalculateSpread(vel)
	aim = GetAimVector(self.Owner)
	CT = CurTime()
	
	if not self.Owner.LastView then
		self.Owner.LastView = aim
		self.Owner.ViewAff = 0
	else
		self.Owner.ViewAff = Lerp(0.25, self.Owner.ViewAff, (aim - self.Owner.LastView):Length() * 0.5)
		self.Owner.LastView = aim
	end
	
	if self.dt.State == SWB_AIMING then
		self.BaseCone = self.AimSpread
		
		if self.Owner.Expertise then
			self.BaseCone = self.BaseCone * (1 - self.Owner.Expertise["steadyaim"].val * 0.0015)
		end
	else
		self.BaseCone = self.HipSpread
		
		if self.Owner.Expertise then
			self.BaseCone = self.BaseCone * (1 - self.Owner.Expertise["wepprof"].val * 0.0015)
		end
	end
	
	if self.Owner:Crouching() then
		self.BaseCone = self.BaseCone * (self.dt.State == SWB_AIMING and 0.9 or 0.75)
	end
	
	self.CurCone = math.Clamp(self.BaseCone + self.AddSpread + (vel / 10000 * self.VelocitySensitivity) * (self.dt.State == SWB_AIMING and self.AimMobilitySpreadMod or 1) + self.Owner.ViewAff, 0, 0.09 + self.MaxSpreadInc)
	
	if CT > self.SpreadWait then
		self.AddSpread = math.Clamp(self.AddSpread - 0.005 * self.AddSpreadSpeed, 0, self.MaxSpreadInc)
		self.AddSpreadSpeed = math.Clamp(self.AddSpreadSpeed + 0.05, 0, 1)
	end
end

local SP = game.SinglePlayer()

local mag, ammo

function SWEP:IndividualThink()
	if (SP and SERVER) or not SP then
		if self.dt.State == SWB_AIMING then
			if not self.Owner:OnGround() or Length(GetVelocity(self.Owner)) >= self.Owner:GetWalkSpeed() * 1.35 or not self.Owner:KeyDown(IN_ATTACK2) then
				CT = CurTime()
				self.dt.State = SWB_IDLE
				self:SetNextSecondaryFire(CT + 0.2)
			end
		end
	end
end

local IFTP
local wl, ws

function SWEP:Think()
	if self.IndividualThink then
		self:IndividualThink()
	end

	if (not IsValid(self.Owner)) then return end
	
	vel = Length(GetVelocity(self.Owner))
	IFTP = IsFirstTimePredicted()
	
	if (not SP and IFTP) or SP then
		self:CalculateSpread(vel)
	end
	
	CT = CurTime()
	wl = self.Owner:WaterLevel()

	if self.Owner:OnGround() then
		if wl >= 3 and self.HolsterUnderwater then
			if self.ShotgunReloadState == 1 then
				self.ShotgunReloadState = 2
			end
			
			self.dt.State = SWB_ACTION
			self.FromActionToNormalWait = CT + 0.3
		else
			ws = self.Owner:GetWalkSpeed()
			
			if ((vel > ws * 1.2 and self.Owner:KeyDown(IN_SPEED)) or vel > ws * 3 or (self.ForceRunStateVelocity and vel > self.ForceRunStateVelocity)) and self.SprintingEnabled then
				self.dt.State = SWB_RUNNING
			else
				if self.dt.State != SWB_AIMING then
					if CT > self.FromActionToNormalWait then
						if self.dt.State != SWB_IDLE then
							self.dt.State = SWB_IDLE
							self:SetNextPrimaryFire(CT + 0.3)
							self:SetNextSecondaryFire(CT + 0.3)
							self.ReloadWait = CT + 0.3
						end
					end
				end
			end
		end
	else
		if (wl > 1 and self.HolsterUnderwater) or (self.Owner:GetMoveType() == MOVETYPE_LADDER and self.HolsterOnLadder) then
			if self.ShotgunReloadState == 1 then
				self.ShotgunReloadState = 2
			end
			
			self.dt.State = SWB_ACTION
			self.FromActionToNormalWait = CT + 0.3
		else
			if CT > self.FromActionToNormalWait then
				if self.dt.State != SWB_IDLE then
					self.dt.State = SWB_IDLE
					self:SetNextPrimaryFire(CT + 0.3)
					self:SetNextSecondaryFire(CT + 0.3)
					self.ReloadWait = CT + 0.3
				end
			end
		end
	end
	
	if self.dt.Shots > 0 then
		if not self.Owner:KeyDown(IN_ATTACK) then
			if self.BurstAmount and self.BurstAmount > 0 then
				self.dt.Shots = 0
				self:SetNextPrimaryFire(CT + self.FireDelay * self.BurstCooldownMul)
				self.ReloadWait = CT + self.FireDelay * self.BurstCooldownMul
			end
		end
	end
	
	if IFTP then
		if self.ShotgunReloadState == 1 then
			if self.Owner:KeyPressed(IN_ATTACK) then
				self.ShotgunReloadState = 2
			end
			
			if CT > self.ReloadDelay then
				self:SendWeaponAnim(ACT_VM_RELOAD)
				
				if SERVER then
					self.Owner:SetAnimation(PLAYER_RELOAD)
				end
				
				mag, ammo = self:Clip1(), self.Owner:GetAmmoCount(self.Primary.Ammo)
				
				if SERVER then
					self:SetClip1(mag + 1)
					self.Owner:SetAmmo(ammo - 1, self.Primary.Ammo)
				end
				
				self.ReloadDelay = CT + self.ReloadShellInsertWait
				
				if mag + 1 == self.Primary.ClipSize or ammo - 1 == 0 then
					self.ShotgunReloadState = 2
				end
			end
		elseif self.ShotgunReloadState == 2 then
			if CT > self.ReloadDelay then
				self:SendWeaponAnim(ACT_SHOTGUN_RELOAD_FINISH)
				self.ShotgunReloadState = 0
				self:SetNextPrimaryFire(CT + self.ReloadFinishWait)
				self:SetNextSecondaryFire(CT + self.ReloadFinishWait)
				self.ReloadWait = CT + self.ReloadFinishWait
				self.ReloadDelay = nil
			end
		end
	end
	
	if SERVER then
		if self.dt.Safe then
			if self.CHoldType != self.RunHoldType then
				self:SetHoldType(self.RunHoldType)
				self.CHoldType = self.RunHoldType
			end
		else
			if self.dt.State == SWB_RUNNING or self.dt.State == SWB_ACTION then
				if self.CHoldType != self.RunHoldType then
					self:SetHoldType(self.RunHoldType)
					self.CHoldType = self.RunHoldType
				end
			else
				if self.CHoldType != self.NormalHoldType then
					self:SetHoldType(self.NormalHoldType)
					self.CHoldType = self.NormalHoldType
				end
			end
		end
	end
	
	--[[if self.ReloadDelay and CT >= self.ReloadDelay then
		mag, ammo = self:Clip1(), self.Owner:GetAmmoCount(self.Primary.Ammo)
		
		if self.ReloadAmount then
			if SERVER then
				self:SetClip1(math.Clamp(mag + self.ReloadAmount, 0, self.Primary.ClipSize))
				self.Owner:RemoveAmmo(self.ReloadAmount, self.Primary.Ammo)
			end
		else
			if mag > 0 then
				if ammo >= self.Primary.ClipSize - mag then
					if SERVER then
						self:SetClip1(math.Clamp(self.Primary.ClipSize, 0, self.Primary.ClipSize))
						self.Owner:RemoveAmmo(self.Primary.ClipSize - mag, self.Primary.Ammo)
					end
				else
					if SERVER then
						self:SetClip1(math.Clamp(mag + ammo, 0, self.Primary.ClipSize))
						self.Owner:RemoveAmmo(ammo, self.Primary.Ammo)
					end
				end
			else
				if ammo >= self.Primary.ClipSize then
					if SERVER then
						self:SetClip1(math.Clamp(self.Primary.ClipSize, 0, self.Primary.ClipSize))
						self.Owner:RemoveAmmo(self.Primary.ClipSize, self.Primary.Ammo)
					end
				else
					if SERVER then
						self:SetClip1(math.Clamp(ammo, 0, self.Primary.ClipSize))
						self.Owner:RemoveAmmo(ammo, self.Primary.Ammo)
					end
				end
			end
		end
		
		self.ReloadDelay = nil
	end]]--
end

local mul

function SWEP:PrimaryAttack()
	if self.ShotgunReloadState != 0 then
		return
	end
	
	if self.ReloadDelay then
		return
	end
	
	if self.dt.Safe then
		self:CycleFiremodes()
		return
	end
	
	mag = self:Clip1()
	
	if mag == 0 then
		self:EmitSound("SWB_Empty", 100, 100)
		self:SetNextPrimaryFire(CT + 0.25)
		return
	end
	
	if self.dt.State == SWB_RUNNING or self.dt.State == SWB_ACTION then
		return
	end
	
	if self.BurstAmount and self.BurstAmount > 0 then
		if self.dt.Shots >= self.BurstAmount then
			return
		end
		
		self.dt.Shots = self.dt.Shots + 1
	end
	
	
	self.Owner:SetAnimation(PLAYER_ATTACK1)
	CT = CurTime()
	
	if self.dt.Suppressed then
		self:SendWeaponAnim(ACT_VM_PRIMARYATTACK_SILENCED)
	else
		self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
	end
	
	if self.FireAnimFunc then
		self:FireAnimFunc()
	else
		if self.dt.State == SWB_AIMING then
			if mag - self.AmmoPerShot <= 0 and self.DryFire then
				if self.dt.Suppressed then
					self:SendWeaponAnim(ACT_VM_DRYFIRE_SILENCED)
				else
					self:SendWeaponAnim(ACT_VM_DRYFIRE)
				end
			else
				if self.dt.Suppressed then
					self:SendWeaponAnim(ACT_VM_PRIMARYATTACK_SILENCED)
				else
					self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
				end
			end
			
			if self.FadeCrosshairOnAim then
				if SP then
					if SERVER then
						self.Owner:GetViewModel():SetPlaybackRate(self.PlayBackRate or 1)
					end
				else
					if SERVER then
						self.Owner:GetViewModel():SetPlaybackRate(self.PlayBackRateSV or 1)
					else
						self.Owner:GetViewModel():SetPlaybackRate(self.PlayBackRate or 1)
					end
				end
			end
		else
			if mag - self.AmmoPerShot <= 0 and self.DryFire then
				if self.dt.Suppressed then
					self:SendWeaponAnim(ACT_VM_DRYFIRE_SILENCED)
				else
					self:SendWeaponAnim(ACT_VM_DRYFIRE)
				end
			else
				if self.dt.Suppressed then
					self:SendWeaponAnim(ACT_VM_PRIMARYATTACK_SILENCED)
				else
					self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
				end
			end
			
			if self.FadeCrosshairOnAim then
				self.Owner:GetViewModel():SetPlaybackRate(self.PlayBackRateHip or 1)
			end
		end
	end
	
	if IsFirstTimePredicted() then
		if self.dt.Suppressed then
			self:EmitSound(self.FireSoundSuppressed, 105, 100)
		else
			self:EmitSound(self.FireSound, 105, 100)
		end
		
		self:FireBullet(self.Damage * (self.dt.Suppressed and 0.9 or 1), self.CurCone, self.Shots)
		self:MakeRecoil()
		
		self.SpreadWait = CT + self.SpreadCooldown
		mul = 1
	
		if self.Owner:Crouching() then
			mul = mul * 0.75
		end
		
		if self.Owner.Expertise then
			mul = mul * (1 - self.Owner.Expertise["wepprof"].val * 0.002)
			
			if SERVER then
				if self.dt.State == SWB_AIMING then
					self.Owner:ProgressStat("steadyaim", self.Recoil * 1.5)
					self.Owner:ProgressStat("wepprof", self.Recoil * 0.5)
				else
					self.Owner:ProgressStat("wepprof", self.Recoil * 1.5)
				end
				
				self.Owner:ProgressStat("rechandle", self.Recoil)
			end
		end
		
		if self.BurstAmount > 0 then
			self.AddSpread = math.Clamp(self.AddSpread + self.SpreadPerShot * self.BurstSpreadIncMul * mul, 0, self.MaxSpreadInc)
		else
			self.AddSpread = math.Clamp(self.AddSpread + self.SpreadPerShot * mul, 0, self.MaxSpreadInc)
		end
		
		self.AddSpreadSpeed = math.Clamp(self.AddSpreadSpeed - 0.2, 0, 1)
		
		if CLIENT then
			if self.dt.State == SWB_AIMING then
				self.FireMove = 1
			else
				self.FireMove = 0.4
			end
		end
		
		if SP and SERVER then
			//SendUserMessage("SWB_Recoil", self.Owner)
		end
	end
	
	self:TakePrimaryAmmo(self.AmmoPerShot)
	self:SetNextPrimaryFire(CT + self.FireDelay)
	self:SetNextSecondaryFire(CT + self.FireDelay)
	self.ReloadWait = CT + (self.WaitForReloadAfterFiring and self.WaitForReloadAfterFiring or self.FireDelay)
end

local ang

function SWEP:MakeRecoil(mod)
	mod = mod and mod or 1
	
	if self.Owner:Crouching() then
		mod = mod * 0.75
	end
	
	if self.dt.State == SWB_AIMING then
		mod = mod * 0.85
	end
	
	if self.dt.Suppressed then
		mod = mod * 0.85
	end
	
	if self.BurstAmount > 0 then
		mod = mod * self.BurstRecoilMul
	end
	
	if self.Owner.Expertise then
		mod = mod * (1 - self.Owner.Expertise["rechandle"].val * 0.0015)
	end
	
	if (SP and SERVER) or (not SP and CLIENT) then
		ang = self.Owner:EyeAngles()
		ang.p = ang.p - self.Recoil * 0.5 * mod
		ang.y = ang.y + math.random(-1, 1) * self.Recoil * 0.5 * mod
	
		self.Owner:SetEyeAngles(ang)
	end
	
	self.Owner:ViewPunch(Angle(-self.Recoil * 1.25 * mod, 0, 0))
end

function SWEP:SecondaryAttack()
	if self.ShotgunReloadState != 0 then
		return
	end
	
	if self.ReloadDelay then
		return
	end
	
	if self.dt.Safe then
		self:CycleFiremodes()
		return
	end
	
	if self.dt.State == SWB_RUNNING or self.dt.State == SWB_ACTION or self.dt.State == SWB_AIMING then
		return
	end
	
	if self.Suppressable and self.Owner:KeyDown(IN_USE) then
		self:ToggleSuppressor()
		return
	end
	
	if not self.Owner:OnGround() or Length(GetVelocity(self.Owner)) >= self.Owner:GetWalkSpeed() * 1.2 then
		return
	end
	
	CT = CurTime()
	
	self.dt.State = SWB_AIMING 
	
	if IsFirstTimePredicted() then
		self.AimTime = UnPredictedCurTime() + 0.25
		
		if self.PreventQuickScoping then
			self.AddSpread = math.Clamp(self.AddSpread + 0.03, 0, self.MaxSpreadInc)
			self.SpreadWait = CT + 0.3
		end
	end
	
	if SP and SERVER then
		//SendUserMessage("SWB_AimTime", self.Owner)
	end
	
	self:SetNextSecondaryFire(CT + 0.1)
end

function SWEP:ToggleSuppressor()
	if self.dt.Suppressed then
		self:SendWeaponAnim(ACT_VM_DETACH_SILENCER)
	else
		self:SendWeaponAnim(ACT_VM_ATTACH_SILENCER)
	end
	
	vm = self.Owner:GetViewModel()
	dur = vm:SequenceDuration()
	CT = CurTime()
	
	self:SetNextPrimaryFire(CT + dur)
	self:SetNextSecondaryFire(CT + dur)
	self.ReloadWait = CT + dur
	self.dt.Suppressed = ! self.dt.Suppressed
end

function SWEP:Equip()
end

if CLIENT then
	local EP, EA2, FT
	
	function SWEP:ViewModelDrawn()
		EP, EA2, FT = EyePos(), EyeAngles(), FrameTime()
		
		if IsValid(self.Hands) then
			self.Hands:SetRenderOrigin(EP)
			self.Hands:SetRenderAngles(EA2)
			self.Hands:FrameAdvance(FT)
			self.Hands:SetupBones()
			self.Hands:SetParent(self.Owner:GetViewModel())
			self.Hands:DrawModel()
		end
	end
	
	local wm, pos, ang
	local GetBonePosition = debug.getregistry().Entity.GetBonePosition
	
	local ply, wep
	
	local function GetRecoil()
		ply = LocalPlayer()
		
		if not ply:Alive() then
			return
		end
		
		wep = ply:GetActiveWeapon()
		
		if IsValid(wep) and wep.SWBWeapon then
			CT = CurTime()
			wep.SpreadWait = CT + wep.SpreadCooldown
			
			mul = 1
		
			if ply:Crouching() then
				mul = mul * 0.75
			end
			
			if ply.Expertise then
				mul = mul * (1 - ply.Expertise["wepprof"].val * 0.002)
			end
			
			if wep.BurstAmount > 0 then
				wep.AddSpread = math.Clamp(wep.AddSpread + wep.SpreadPerShot * wep.BurstSpreadIncMul * mul, 0, wep.MaxSpreadInc)
			else
				wep.AddSpread = math.Clamp(wep.AddSpread + wep.SpreadPerShot * mul, 0, wep.MaxSpreadInc)
			end
			
			wep.AddSpreadSpeed = math.Clamp(wep.AddSpreadSpeed - 0.2, 0, 1)
			
			if wep.dt.State == SWB_AIMING then
				wep.FireMove = 1
			else
				wep.FireMove = 0.4
			end
		end
	end
	
	usermessage.Hook("SWB_Recoil", GetRecoil)
	
	local function AimTime()
		ply = LocalPlayer()
		
		if not ply:Alive() then
			return
		end
		
		wep = ply:GetActiveWeapon()
		
		if IsValid(wep) and wep.SWBWeapon then
			wep.AimTime = UnPredictedCurTime() + 0.25
			
			if wep.PreventQuickScoping then
				wep.AddSpread = math.Clamp(wep.AddSpread + 0.03, 0, wep.MaxSpreadInc)
				wep.SpreadWait = CurTime() + 0.3
			end
		end
	end
	
	usermessage.Hook("SWB_AimTime", AimTime)

	local function SWB_ReceiveFireMode(um)
		ply = um:ReadEntity()
		Mode = um:ReadString()
		
		if IsValid(ply) then
			wep = ply:GetActiveWeapon()
			wep.FireMode = Mode
			
			if IsValid(ply) and IsValid(wep) and wep.SWBWeapon then
				if wep.FireModeNames then
					t = wep.FireModeNames[Mode]
					
					wep.Primary.Automatic = t.auto
					wep.BurstAmount = t.burstamt
					wep.FireModeDisplay = t.display
					wep.BulletDisplay = t.buldis
					wep.CheckTime = CurTime() + 2
					
					if ply == LocalPlayer() then
						ply:EmitSound("weapons/smg1/switch_single.wav", 70, math.random(92, 112))
					end
				end
			end
		end
	end

	usermessage.Hook("SWB_FIREMODE", SWB_ReceiveFireMode)
end

--PATH addons/swb_css/lua/weapons/swb_mp5/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "HK MP5"
	SWEP.CSMuzzleFlashes = true

	SWEP.AimPos = Vector(-5.329, -9.28, 2.02)
	SWEP.AimAng = Vector(1.162, 0, 0)
	
	SWEP.SprintPos = Vector(0.736, -3.971, 1.802)
	SWEP.SprintAng = Vector(-13.205, 37.048, 0)
	
	SWEP.ZoomAmount = 15
	SWEP.ViewModelMovementScale = 0.85
	SWEP.Shell = "smallshell"
	
	SWEP.IconLetter = "x"
	
	SWEP.MuzzleEffect = "swb_rifle_small"
	SWEP.MuzzlePosMod = {x = 5, y = 30, z = -4}
	SWEP.PosBasedMuz = true
end

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 20
SWEP.BulletDiameter = 9
SWEP.CaseLength = 19

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_smg1_ttt"

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "3burst", "semi"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_smg_mp5.mdl"
SWEP.WorldModel		= "models/weapons/w_smg_mp5.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 30
SWEP.Primary.DefaultClip	= 30
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "smg1"

SWEP.FireDelay = 0.075
SWEP.FireSound = Sound("Weapon_MP5Navy.Single")
SWEP.Recoil = 0.8

SWEP.HipSpread = 0.04
SWEP.AimSpread = 0.008
SWEP.VelocitySensitivity = 1.5
SWEP.MaxSpreadInc = 0.05
SWEP.SpreadPerShot = 0.01
SWEP.SpreadCooldown = 0.1
SWEP.Shots = 1
SWEP.Damage = 18
SWEP.DeployTime = 1
SWEP.BurstCooldownMul = 3.5
--PATH addons/__main/lua/weapons/tempest_smg/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("smg_tempest") -- must be the name of your swep but NO CAPITALS!
SWEP.Category				= "CSO/CF Weapons" --Category where you will find your weapons
SWEP.Author				= "Zekeou"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.PrintName				= "SF SMG Tempest"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 3			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false		-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight					= 30		-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg makes for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_rif_temps.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_rif_galil.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= false
SWEP.Base				= "zekeou_gun_base" --the Base this weapon will work on. PLEASE RENAME THE BASE! 
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("weapons/Temp/SF_SMG_Fire.wav")		-- Script that calls the primary fire sound
SWEP.Primary.SilencedSound 	= Sound("")		-- Sound if the weapon is silenced
SWEP.Primary.RPM			= 900		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.3		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "pistol"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. 
--Use AirboatGun for a light metal peircing shotgun pellets
SWEP.SelectiveFire		= true
SWEP.CanBeSilenced		= false

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 22	-- Base damage per bullet
SWEP.Primary.Spread		= .028	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .018 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(4.639, 0, 1)
SWEP.IronSightsAng = Vector(2.48, -0.276, 0)
SWEP.SightsPos = Vector(4.639, 0, 1)
SWEP.SightsAng = Vector(2.48, -0.276, 0)
SWEP.RunSightsPos = Vector(0,0,0)	--These are for the angles your viewmodel will be when running
SWEP.RunSightsAng = Vector(0,0,0)	--Again, use the Swep Construction Kit

SWEP.WElements = {
	["SMG_Tempest"] = { type = "Model", model = "models/weapons/w_rif_temps.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(0.393, 1.24, 0.634), angle = Angle(-14.183, 3.96, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

--PATH addons/__new_main_all/lua/weapons/totem.lua:
--[[------------------

Create By BlueSky KS

--------------------]]

SWEP.Base = "weapon_base"

SWEP.PrintName = NAME_OF_TOTEM.wep_name

SWEP.Slot = 2
SWEP.SlotPos = 1
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false

SWEP.Category = "Other"

SWEP.HoldType = "pistol"

SWEP.Spawnable= true
SWEP.AdminSpawnable = true
SWEP.AdminOnly = false

SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.ViewModel = ""
SWEP.WorldModel = ""

SWEP.FiresUnderwater = true

SWEP.CanSwitch = true

-----------------------------------S.H.I.T
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

------------------------------------

local mat = Material("vgui/entities/tou_pic.png")

function SWEP:DrawWeaponSelection( x, y, wide, tall, alpha )
	surface.SetDrawColor( 255, 255, 255, alpha )
	surface.SetMaterial( mat )
	
	y = y + 10
	x = x + 10
	wide = wide - 20
	
	surface.DrawTexturedRect( x, y,  wide , ( wide / 2 ) )
end

function SWEP:SetupDataTables()
	self:NetworkVar( "Bool", 0, "IsInventory" )
end

function SWEP:Initialize()
    self:SetHoldType( self.HoldType )

	self:SetIsInventory( false )
end

function SWEP:PrimaryAttack()
	self:SetIsInventory( !self:GetIsInventory() )
	self:SetNextPrimaryFire( CurTime() + 0.3 )
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
end

function SWEP:DrawHUD()
	if self:GetIsInventory() then return end

    local x, y = ScrW(), ScrH()

    surface.SetDrawColor( 255, 255, 255 )
    surface.SetMaterial( mat )
    surface.DrawTexturedRect( x * 0.75 / 1 - 230 * 0.005 / 2, y / 1.7 - 40 * 0.8, x / 4, y / 2.3 )
end
--PATH addons/_avatar/lua/weapons/weapon_aang_glider.lua:
if CLIENT then
	SWEP.DrawWeaponInfoBox = false
	SWEP.BounceWeaponIcon = false
	language.Add( "weapon_aang_glider", "Aang Glider" )
end

SWEP.PrintName = "Aang Glider"
SWEP.Category = "Avatar"
SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.AdminOnly = false
SWEP.ViewModelFOV = 90
SWEP.ViewModel = "models/weapons/c_grenade.mdl"
SWEP.WorldModel = "models/avatar/Aang_Glider_Closed.mdl"
SWEP.ViewModelFlip = false
SWEP.BobScale = 1
SWEP.SwayScale = 1
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.Weight = 0
SWEP.Slot = 1
SWEP.SlotPos = 10
SWEP.UseHands = true
SWEP.HoldType = "slam"
SWEP.FiresUnderwater = true
SWEP.DrawCrosshair = true
SWEP.DrawAmmo = true
SWEP.CSMuzzleFlashes = 1
SWEP.Base = "weapon_base"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true
SWEP.Idle = 0
SWEP.IdleTimer = CurTime()
SWEP.Primary.Sound = Sound( "common/null.wav" )
SWEP.Primary.ClipSize = 1
SWEP.Primary.DefaultClip = 1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.Damage = 500
SWEP.Primary.DelayMiss = 0.6
SWEP.Primary.DelayHit = 0.3
SWEP.Primary.Force = 1500
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Delay = 0.5
SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_UpperArm"] = {
		scale = Vector( 1, 1, 1 ),
		pos = Vector( 0, -10, -10 ),
		angle = Angle( 0, 0, 0 )
	},
	["ValveBiped.Bip01_R_UpperArm"] = {
		scale = Vector( 1, 1, 1 ),
		pos = Vector( 0, 0, 0 ),
		angle = Angle( 0, 0, 26.6 )
	},
	["ValveBiped.Grenade_body"] = {
		scale = Vector( 0.009, 0.009, 0.009 ),
		pos = Vector( 0, 0, 0 ),
		angle = Angle( 0, 0, 0 )
	}
}

SWEP.VElements = {
	["v_element"] = {
		model = "models/avatar/Aang_Glider_Closed.mdl",
		bone = "ValveBiped.Grenade_body",
		rel = "",
		pos = Vector( 0, 0, 0 ),
		angle = Angle( 0, 0, 0 ),
		size = Vector( 1, 1, 1 ),
		color = Color( 255, 255, 255, 255 ),
		surpresslightning = false
	}
}

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
	self:SetWeaponHoldType( self.HoldType )
	self.Idle = 0
	self.IdleTimer = CurTime() + 1
	if CLIENT then
		-- Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )
		self:SetWeaponHoldType( self.HoldType )
		self:CreateModels( self.VElements ) -- create viewmodels
		-- init view model bone build function
		local owner = self:GetOwner()
		if IsValid( owner ) then
			local vm = owner:GetViewModel()
			if IsValid( vm ) then
				self:ResetBonePositions( vm )
				-- Init viewmodel visibility
				if self.ShowViewModel == nil or self.ShowViewModel then
					vm:SetColor( color_white )
				else
					-- we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor( Color( 255, 255, 255, 1 ) )
					-- ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					-- however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial( "Debug/hsv" )
				end
			end
		end
	end
end

----------------------------------------------------
if CLIENT then
	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		local vm = self:GetOwner():GetViewModel()
		if not IsValid( vm ) then return end
		if not self.VElements then return end
		self:UpdateBonePositions( vm )
		if not self.vRenderOrder then
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}
			for k in pairs( self.VElements ) do
				table.insert( self.vRenderOrder, 1, k )
			end
		end

		for _, name in ipairs( self.vRenderOrder ) do
			local v = self.VElements[name]
			if not v then
				self.vRenderOrder = nil
				break
			end

			if v.hide then continue end
			local model = v.modelEnt
			if not v.bone then continue end
			local pos, ang = self:GetBoneOrientation( v, vm )
			if not pos then continue end
			if IsValid( model ) then
				model:SetPos( pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				model:SetAngles( ang )
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale( v.size )
				model:EnableMatrix( "RenderMultiply", matrix )
				if v.surpresslightning then render.SuppressEngineLighting( true ) end
				render.SetColorModulation( v.color.r / 255, v.color.g / 255, v.color.b / 255 )
				render.SetBlend( v.color.a / 255 )
				model:DrawModel()
				render.SetBlend( 1 )
				render.SetColorModulation( 1, 1, 1 )
				if v.surpresslightning then render.SuppressEngineLighting( false ) end
			end
		end
	end

	function SWEP:GetBoneOrientation( tab, ent, bone_override )
		local owner = self:GetOwner()
		local bone, pos, ang
		bone = ent:LookupBone( bone_override or tab.bone )
		if not bone then return end
		pos, ang = Vector( 0, 0, 0 ), Angle( 0, 0, 0 )
		local m = ent:GetBoneMatrix( bone )
		if m then pos, ang = m:GetTranslation(), m:GetAngles() end
		if IsValid( owner ) and owner:IsPlayer() and ent == owner:GetViewModel() and self.ViewModelFlip then
			ang.r = -ang.r -- Fixes mirrored models
		end
		return pos, ang
	end

	function SWEP:CreateModels( tab )
		if not tab then return end
		for _, v in pairs( tab ) do
			if v.model and v.model ~= "" and ( not IsValid( v.modelEnt ) or v.createdModel ~= v.model ) and string.find( v.model, ".mdl" ) and file.Exists( v.model, "GAME" ) then
				v.modelEnt = ClientsideModel( v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE )
				if IsValid( v.modelEnt ) then
					v.modelEnt:SetPos( self:GetPos() )
					v.modelEnt:SetAngles( self:GetAngles() )
					v.modelEnt:SetParent( self )
					v.modelEnt:SetNoDraw( true )
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			end
		end
	end

	local allbones
	local hasGarryFixedBoneScalingYet = false
	function SWEP:UpdateBonePositions( vm )
		if self.ViewModelBoneMods then
			if not vm:GetBoneCount() then return end
			-- !! WORKAROUND !! --
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if not hasGarryFixedBoneScalingYet then
				allbones = {}
				for i = 0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName( i )
					if self.ViewModelBoneMods[bonename] then
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = {
							scale = Vector( 1, 1, 1 ),
							pos = Vector( 0, 0, 0 ),
							angle = Angle( 0, 0, 0 )
						}
					end
				end

				loopthrough = allbones
			end

			-- !! ----------- !! --
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone( k )
				if not bone then continue end
				-- !! WORKAROUND !! --
				local s = Vector( v.scale.x, v.scale.y, v.scale.z )
				local p = Vector( v.pos.x, v.pos.y, v.pos.z )
				local ms = Vector( 1, 1, 1 )
				if not hasGarryFixedBoneScalingYet then
					local cur = vm:GetBoneParent( bone )
					while cur >= 0 do
						local pscale = loopthrough[vm:GetBoneName( cur )].scale
						ms = ms * pscale
						cur = vm:GetBoneParent( cur )
					end
				end

				s = s * ms
				-- !! ----------- !! --
				if vm:GetManipulateBoneScale( bone ) ~= s then vm:ManipulateBoneScale( bone, s ) end
				if vm:GetManipulateBoneAngles( bone ) ~= v.angle then vm:ManipulateBoneAngles( bone, v.angle ) end
				if vm:GetManipulateBonePosition( bone ) ~= p then vm:ManipulateBonePosition( bone, p ) end
			end
		else
			self:ResetBonePositions( vm )
		end
	end

	function SWEP:ResetBonePositions( vm )
		if not vm:GetBoneCount() then return end
		for i = 0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector( 1, 1, 1 ) )
			vm:ManipulateBoneAngles( i, Angle( 0, 0, 0 ) )
			vm:ManipulateBonePosition( i, Vector( 0, 0, 0 ) )
		end
	end

	function table.FullCopy( tab )
		if not tab then return nil end
		local res = {}
		for k, v in pairs( tab ) do
			if type( v ) == "table" then
				res[k] = table.FullCopy( v )
			elseif type( v ) == "Vector" then
				res[k] = Vector( v.x, v.y, v.z )
			elseif type( v ) == "Angle" then
				res[k] = Angle( v.p, v.y, v.r )
			else
				res[k] = v
			end
		end
		return res
	end
end

----------------------------------------------------
function SWEP:Deploy()
	self:SendWeaponAnim( ACT_VM_DRAW )
	self:SetNextPrimaryFire( CurTime() + 0.5 )
	self:SetNextSecondaryFire( CurTime() + 0.5 )
	self:SetNWBool( "Opened", false )
	self.Idle = 0
	self.IdleTimer = CurTime() + 0.5
	return true
end

function SWEP:Holster()
	self.Idle = 0
	self.IdleTimer = CurTime()
	local owner = self:GetOwner()
	if CLIENT and IsValid( owner ) then
		local vm = owner:GetViewModel()
		if IsValid( vm ) then
			self:ResetBonePositions( vm )
			owner:SetFOV( 0, 0.25 )
		end
	end
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

function SWEP:OnDrop()
	self:Holster()
end

function SWEP:PrimaryAttack()
	if not self:GetNWBool( "Opened", false ) then
		self:SetNWBool( "Opened", true )
		self:SetHoldType( "normal" )
		self:SetWeaponHoldType( "normal" )
		local owner = self:GetOwner()
		if SERVER then owner:EmitSound( "physics/wood/wood_crate_impact_hard1.wav", 65 ) end
		self:SendWeaponAnim( ACT_VM_THROW )
		owner:SetAnimation( PLAYER_ATTACK1 )
		self:SetNextPrimaryFire( CurTime() + 0.01 )
		self:SetNextSecondaryFire( CurTime() + 0.01 )
	end
end

function SWEP:SecondaryAttack()
	if self:GetNWBool( "Opened", false ) then
		self:SetNWBool( "Opened", false )
		self:SetHoldType( "slam" )
		self:SetWeaponHoldType( "slam" )
		local owner = self:GetOwner()
		if SERVER then owner:EmitSound( "physics/wood/wood_furniture_impact_soft" .. math.random( 1, 3 ) .. ".wav", 65 ) end
		owner:SetAnimation( PLAYER_ATTACK1 )
		self.Idle = 0
		self.IdleTimer = CurTime()
		self:SetNextPrimaryFire( CurTime() + 0.01 )
		self:SetNextSecondaryFire( CurTime() + 0.01 )
	end
end

function SWEP:Think()
	local owner = self:GetOwner()
	if self:GetNWBool( "Opened", false ) and not owner:OnGround() then
		local fwrd = 0
		local right = 0
		if owner:KeyDown( IN_FORWARD ) then fwrd = 10 end
		if owner:KeyDown( IN_MOVERIGHT ) then
			right = 10
		elseif owner:KeyDown( IN_MOVELEFT ) then
			right = -10
		end

		owner:SetVelocity( Vector( 0, 0, 10 - owner:EyeAngles().p / 5 ) + owner:EyeAngles():Forward() * ( 10 + fwrd ) + owner:EyeAngles():Right() * right - owner:GetVelocity() / 80 )
	end

	if self.Idle == 0 and self.IdleTimer <= CurTime() then
		if SERVER then self:SendWeaponAnim( ACT_VM_IDLE ) end
		self.Idle = 1
	end
end

if CLIENT then
	local WorldModel = ClientsideModel( "models/avatar/Aang_Glider_Opened.mdl" )
	local WorldModel2 = ClientsideModel( SWEP.WorldModel )
	WorldModel:SetNoDraw( true )
	WorldModel2:SetNoDraw( true )
	function SWEP:DrawWorldModel()
		--self:Drawspiral()
		--self.Weapon:DrawModel()
		local _Owner = self:GetOwner()
		local ownervalid = IsValid( _Owner )
		if ownervalid then
			-- Specify a good position
			local offsetVec = Vector( 0, -5, 0 )
			local offsetAng = Angle( 0, 90, 90 )
			local boneid = _Owner:LookupBone( "ValveBiped.Bip01_spine4" )
			if not self:GetNWBool( "Opened", false ) then
				offsetVec = Vector( 2, -2, 0 )
				offsetAng = Angle( 0, 0, 20 )
				boneid = _Owner:LookupBone( "ValveBiped.Bip01_R_Hand" )
			end

			if not boneid then return end
			local matrix = _Owner:GetBoneMatrix( boneid )
			if not matrix then return end
			local newPos, newAng = LocalToWorld( offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles() )
			if not self:GetNWBool( "Opened", false ) then
				WorldModel2:SetPos( newPos )
				WorldModel2:SetAngles( newAng )
				WorldModel2:SetModelScale( 0.9 )
				WorldModel2:SetupBones()
				WorldModel2:DrawModel()
			else
				WorldModel:SetPos( newPos )
				WorldModel:SetAngles( newAng )
				--WorldModel:SetModelScale(0.8)
				WorldModel:SetupBones()
				WorldModel:DrawModel()
			end
		end
	end
end
--PATH addons/__main/lua/weapons/weapon_amaterasu/shared.lua:
if SERVER then AddCSLuaFile( "shared.lua" ) end
if CLIENT then
	SWEP.PrintName = "Amaterasu"
	SWEP.Category = "Other"
	SWEP.Slot = 3
	SWEP.SlotPos = 1
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = false
	SWEP.Author = "[HG] Mr Ibizza"
	SWEP.Contact = "Contact me via Steam , duh."
	SWEP.Purpose = "Left click to use the Amaterasu\nRight Click to teleport"
end

function SWEP:Initialize()
	self.LookOut = { Sound( "weapons/iamaterasu.wav" ), Sound( "weapons/samaterasu.wav" ) }
end

function SWEP:Reload()
end

function SWEP:Think()
end

function SWEP:PrimaryAttack()
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.08 )
	self.Weapon:SetNextPrimaryFire( CurTime() + 1.5 )
	self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
	local pos = self.Owner:GetShootPos()
	local ang = self.Owner:GetAimVector()
	local tracedata = {}
	tracedata.start = pos
	tracedata.endpos = pos + ang * 100000
	tracedata.filter = self.Owner
	local trace = util.TraceLine( tracedata )
	local target = trace.Entity
	if not IsValid(target) then return end
	if SERVER then target:Ignite( 30, 0 ) end
	target:EmitSound( "ambient/fire/ignite.wav", 100, 100 )
	self.Weapon:EmitSound( self.LookOut[math.random( 1, #self.LookOut )] )
	if SERVER then
		if target:IsWorld() then
			local fire = ents.Create( "env_fire" )
			if not IsValid(fire) then return end
			fire:SetPos( self.Owner:GetEyeTrace().HitPos )
			fire:SetKeyValue( "targetname", "fire" )
			fire:SetKeyValue( "health", "10" )
			fire:SetKeyValue( "fireattack", "0" )
			fire:SetKeyValue( "ignitionpoint", "0" )
			fire:SetKeyValue( "firesize", "150" )
			fire:SetKeyValue( "StartDisabled", "0" )
			fire:SetKeyValue( "spawnflags", 128 + 2 )
			fire:SetKeyValue( "damagescale", "20" )
			fire:Spawn()
			fire:SetOwner( self.Owner )
			fire:Fire( "StartFire", "", "0" )
			fire:EmitSound( "ambient/fire/ignite.wav", 100, 100 )
		end
	end
end

function SWEP:SecondaryAttack()
	--self.Weapon:EmitSound("weapons/jump.wav") -- This is annoying as fuck.
	--if not (SERVER) then return end
	self.Owner:SetPos( self.Owner:GetEyeTrace().HitPos + Vector( 0, 0, 35 ) )
end

SWEP.ViewModelFOV = 50
SWEP.Instructions = "Left click to use the Amaterasu\nRight Click to teleport"
SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.ViewModel = "models/weapons/v_hands.mdl"
SWEP.WorldModel = "models/weapons/w_bugbait.mdl"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
--PATH addons/__main/lua/weapons/weapon_deagle_bornbeast.lua:
if SERVER then
	AddCSLuaFile()
else
	SWEP.ViewModelFOV = 60
	SWEP.BounceWeaponIcon = false
end

SWEP.Category = "Weapons"
SWEP.PrintName = "Deagle - Born Beast"
SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.Base = "weapon_cf_base"
SWEP.Spawnable = true
SWEP.HoldType = "pistol"
SWEP.ViewModel = "models/cf/c_deagle_beast.mdl"
SWEP.WorldModel = "models/cf/w_deagle_beast.mdl"
SWEP.Primary.Sound = Sound( "weapons/deagle_beast/deagle-1.wav" )
SWEP.Primary.Damage = 60
SWEP.Primary.Cone = 0.0125
SWEP.Primary.ClipSize = 11
SWEP.Primary.Delay = 0.3
SWEP.Primary.DefaultClip = 55
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "357"
SWEP.MeleeRange = 50
SWEP.MeleeDamage = 62
SWEP.MeleeDuration = 0.9
SWEP.DeployDuration = 0.6
SWEP.MeleeAttack = 0.165
SWEP.MuzzleScale = 1.3
SWEP.DeploySequence = 3
SWEP.MeleeSequence = 12
local single = game.SinglePlayer()
function SWEP:CustomDeploy( ct )
	self.NextReload = ct
	self:GetOwner():DoAnimationEvent( ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE )
	self.NextHit = ct
	self:AttackTrace()
	self.NextHit = nil
	if single then self:CallOnClient( "Deploy" ) end
end
--PATH addons/__main/lua/weapons/weapon_hamster.lua:
local IsValid = IsValid
local CurTime = CurTime
local hook = hook
local file = file
local math = math
local timer = timer
hook.Add("Initialize", "Init_Robert", function()
	game.AddAmmoType({
		name = "hamster_robert",
		dmgtype = DMG_BLAST
	})

	if CLIENT then
		language.Add("hamster_robert_ammo", "Robert")
		language.Add("ent_hamster", "Robert")
	end
end)

local sound_ = {"readywhenyouare01", "readywhenyouare02", "question06", "question14", "vanswer", "littlecorner01", "question26", "okimready01", "okimready02", "okimready03", "uhoh", "letsgo01", "letsgo02", "incoming02"}
local sound___ = {"gotone01", "vanswer14", "vanswer04", "yougotit02"}
local sound____ = {"vo/npc/male01/finally", "vo/npc/male01/yeah02", "vo/npc/male01/hi01", "vo/npc/male01/hi02", "vo/npc/barney/ba_laugh04"}
SWEP.PrintName = "Robert"
SWEP.Category = "Weapons"
SWEP.Author = "Rem & always has bean"
SWEP.Purpose = "Use Robert for good purposes."
SWEP.Instructions = "Robert will be in your dreams until you caress him :3"
SWEP.Spawnable = true
SWEP.ViewModelFOV = 70
SWEP.ViewModel = "models/weapons/c_homyak.mdl"
SWEP.WorldModel = "models/homyak/homyak.mdl"
SWEP.Slot = 1
SWEP.DrawCrosshair = true
SWEP.WepSelectIcon = Material("roberto.png")
function SWEP:DrawWeaponSelection(x, y, w, h, a)
	surface.SetDrawColor(255, 255, 255, a)
	surface.SetMaterial(self.WepSelectIcon)
	local size = math.min(w, h)
	surface.DrawTexturedRect(x + w * 0.5 - size * 0.5, y, size, size)
end

SWEP.Primary.ClipSize = 1
SWEP.Primary.DefaultClip = 1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "hamster_robert"
SWEP.Primary.Recoil = 1
SWEP.Primary.Delay = 1.3
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Ammo = "none"
SWEP.UseHands = true
if engine.ActiveGamemode() == "terrortown" then
	SWEP.Base = "weapon_tttbase"
	SWEP.Primary.ClipSize = 5
	SWEP.EquipMenuData = {
		type = "item_weapon",
		desc = "Robert will be in your dreams until you caress him :3"
	}

	SWEP.Icon = "entities/weapon_hamster.png"
	SWEP.Kind = WEAPON_EQUIP1
	SWEP.CanBuy = {ROLE_TRAITOR}
	SWEP.AutoSpawnable = false
	SWEP.InLoadoutFor = nil
	SWEP.AllowDrop = true
	SWEP.IsSilent = false
	SWEP.NoSights = false
end

function SWEP:Initialize()
	local check = CheckTypeWeapon()
	if check ~= 1 then
		self.Primary.ClipSize = 1
		self.Primary.DefaultClip = 1
		self.Primary.Automatic = false
		self.Primary.Ammo = "none"
	end

	self.delay = CurTime()
	self.SoundCooldown = CurTime() + 8
	self:SetHoldType("grenade")
end

function SWEP:Think()
	local owner = self:GetOwner()
	if SERVER and self:Clip1() < 1 and owner:GetAmmoCount(self:GetPrimaryAmmoType()) < 1 and IsValid(owner:GetActiveWeapon()) and owner:GetActiveWeapon():GetClass() == "weapon_hamster" then owner:StripWeapon("weapon_hamster") end
	if CheckRobertSound() and CurTime() > self.SoundCooldown then
		self.SoundCooldown = self.SoundCooldown + 8
		if CLIENT and IsValid(self:GetOwner():GetActiveWeapon()) and owner:GetActiveWeapon():GetClass() == "weapon_hamster" then self:EmitSound(Format("vo/npc/male01/%s.wav", sound_[math.random(1, #sound_)]), 80, 165) end
	end
end

function SWEP:Deploy()
	local owner = self:GetOwner()
	if self:Clip1() < 1 and owner:GetAmmoCount(self:GetPrimaryAmmoType()) > 0 then self:DefaultReload(172) end
	self.SoundCooldown = CurTime() + 8
	self:SendWeaponAnim(172)
	if CheckRobertSound() then owner:EmitSound(Format("%s.wav", sound____[math.random(1, #sound____)]), 80, 165) end
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
	if not IsValid(self:GetOwner()) then return end
	if not self:GetOwner():IsPlayer() then return end
	if CurTime() < self.delay then return end
	if SERVER then
		net.Start("Hamster_Robert")
		net.Send(self:GetOwner())
	end
	self.delay = CurTime() + 1
end

function SWEP:Equip()
	self:SendWeaponAnim(172)
	self:GetOwner():SetAnimation(0)
end

function SWEP:ShouldDropOnDie()
	return false
end

function SWEP:PrimaryAttack()
	local check = CheckTypeWeapon()
	if check ~= 2 then
		if self:Clip1() < 1 and check ~= 3 then return end
		local variant = file.Read("robert.txt", "DATA")
		self:SendWeaponAnim(172)
		local owner = self:GetOwner()
		owner:SetAnimation(0)
		if SERVER then
			local random = math.random(1, 10)
			if check ~= 3 then self:TakePrimaryAmmo(1) end
			self:SendWeaponAnim(ACT_VM_THROW)
			owner:SetAnimation(PLAYER_ATTACK1)
			local ent = ents.Create("ent_hamster")
			if not IsValid(ent) then return end
			ent:SetPos(owner:EyePos() + (owner:GetAimVector() * 25))
			ent:SetAngles(owner:EyeAngles())
			if CheckRobert() then ent:VariantR(variant) end
			ent:Spawn()
			local phys = ent:GetPhysicsObject()
			if not IsValid(phys) then
				ent:Remove()
				return
			end

			local velocity = owner:GetAimVector()
			velocity = velocity * phys:GetMass() * 2000
			velocity = velocity + (VectorRand() * 10)
			phys:ApplyForceCenter(velocity)
			cleanup.Add(owner, "hamster", ent)
			timer.Simple(0.5, function()
				if IsValid(self) and IsValid(owner:GetActiveWeapon()) and owner:GetActiveWeapon():GetClass() == "weapon_hamster" then
					self:DefaultReload(172)
					if check == 3 then self:SendWeaponAnim(172) end
					if CheckRobertSound() and random > 5 then owner:EmitSound(Format("vo/npc/male01/%s.wav", sound___[math.random(1, #sound___)]), 80, 165) end
				end
			end)

			self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		end
	end
end
--PATH addons/__main/lua/weapons/weapon_narutorun/shared.lua:
if SERVER then

    AddCSLuaFile( "shared.lua" )
    SWEP.Weight                     = 5

    function SWEP:ShouldDropOnDie()

        return false

    end
    
end

if CLIENT then

    SWEP.Slot						= 2
    SWEP.SlotPos				  	= 5
    SWEP.BounceWeaponIcon           = false
    SWEP.WepSelectIcon              = surface.GetTextureID( "weapons/swep" )
    SWEP.ViewModelFOV               = 90
    SWEP.ViewModelFlip              = false

    function SWEP:ShouldDrawViewModel()

        return false

    end

    function SWEP:DrawWorldModel()
    end

end

SWEP.Category                  	    = "Other"
SWEP.Author                      	= "Arkov Le Chauve"
SWEP.PrintName                      = "Naruto Run"
SWEP.Instructions                   = "Left click to Naruto Run\nRight Click to stop the naruto run."
SWEP.ViewModel						= "models/weapons/c_arms_hev.mdl"
SWEP.WorldModel						= "models/weapons/c_arms_hev.mdl"
SWEP.UseHands                       = true
SWEP.Spawnable                      = true
SWEP.DrawCrosshair                  = false
SWEP.DrawAmmo                       = false
SWEP.UseHands                       = false
SWEP.narutorun                      = false

function SWEP:Deploy()

    self:SetHoldType( "normal" )

end

function SWEP:Initialize()

    self:SetHoldType( "normal" )

end

function SWEP:Holster()

    if CLIENT then return end

    if self.narutorun then

        self.Owner:SetRunSpeed( self.Owner:GetRunSpeed() - 250 )
        ResetBoneAngles( self.Owner )

        self.narutorun = false

    end

    return true

end

if SERVER then

    function ResetBoneAngles( ply )

        if not IsValid(ply) then return end
        local tbl = {
            "ValveBiped.Bip01_Spine", "ValveBiped.Bip01_Head1",
            "ValveBiped.Bip01_L_Forearm", "ValveBiped.Bip01_L_Clavicle",
            "ValveBiped.Bip01_L_Upperarm", "ValveBiped.Bip01_R_Upperarm",
            "ValveBiped.Bip01_R_Forearm", "ValveBiped.Bip01_R_Clavicle"
        }

        for _, u in ipairs(tbl) do
            local biped = ply:LookupBone( u )
            if biped then
                ply:ManipulateBoneAngles( biped, Angle( 0, 0, 0 ) )
            end
        end
    end

    function SetClassicNarutoRun( ply )
        if not IsValid(ply) then return end
        local tbl = {
            {"ValveBiped.Bip01_Spine", Angle( 0, 40, 0 )}, {"ValveBiped.Bip01_Head1", Angle( 0, 40, 0 )},
            {"ValveBiped.Bip01_L_Forearm", Angle( 10, 0, 0 )}, {"ValveBiped.Bip01_L_Clavicle", Angle( 0, 10, 30 )},
            {"ValveBiped.Bip01_L_Upperarm", Angle( 20, 0, 0 )}, {"ValveBiped.Bip01_R_Upperarm", Angle( -20, 10, 0 )},
            {"ValveBiped.Bip01_R_Forearm", Angle( -10, 0, 0 )}, {"ValveBiped.Bip01_R_Clavicle", Angle( 0, 10, -30 )}
        }

        for _, u in ipairs(tbl) do
            local biped = ply:LookupBone( u[1] )
            if biped then
                ply:ManipulateBoneAngles( biped, u[2] )
            end
        end
    
    end

    function SetFixNarutoRun( ply )
        if not IsValid(ply) then return end
        local tbl = {
            {"ValveBiped.Bip01_Spine", Angle( 0, 40, 0 )}, {"ValveBiped.Bip01_Head1", Angle( 0, 40, 0 )},
            {"ValveBiped.Bip01_L_Forearm", Angle( 0, 100, 0 )}, {"ValveBiped.Bip01_L_Clavicle", Angle( 0, 10, 30 )},
            {"ValveBiped.Bip01_L_Upperarm", Angle( 20, 0, 0 )}, {"ValveBiped.Bip01_R_Upperarm", Angle( -20, 10, 0 )},
            {"ValveBiped.Bip01_R_Forearm", Angle( 0, 100, 0 )}, {"ValveBiped.Bip01_R_Clavicle", Angle( 0, 10, -30 )}
        }

        for _, u in ipairs(tbl) do
            local biped = ply:LookupBone( u[1] )
            if biped then
                ply:ManipulateBoneAngles( biped, u[2] )
            end
        end

    end

end

function SWEP:PrimaryAttack()

    if CLIENT then return end

    if !self.narutorun then

        self.Owner:SetRunSpeed( self.Owner:GetRunSpeed() + 250 )
        SetClassicNarutoRun( self.Owner )

        self.narutorun = true

    end

end

function SWEP:SecondaryAttack()

    if CLIENT then return end

    if self.narutorun then

        self.Owner:SetRunSpeed( self.Owner:GetRunSpeed() - 250 )
        ResetBoneAngles( self.Owner )

        self.narutorun = false

    end

end

hook.Add( "StartCommand", "narutofix", function( ply, cmd )

    if CLIENT then return end
    if !ply:Alive() then return end
    if !IsValid( ply:GetActiveWeapon() ) then return end

    if ply:GetActiveWeapon():GetClass() == "weapon_narutorun" then

        if  ply:GetActiveWeapon().narutorun then

            if ( cmd:KeyDown( IN_FORWARD ) ) or ( cmd:KeyDown( IN_MOVELEFT ) ) or ( cmd:KeyDown( IN_MOVERIGHT ) ) then

                cmd:SetButtons( bit.bor( cmd:GetButtons(), IN_SPEED ) )
                SetFixNarutoRun( ply )

            end

            if ( cmd:KeyDown( IN_BACK ) ) or ( cmd:KeyDown( IN_DUCK ) ) then

                ply:SetRunSpeed( ply:GetRunSpeed() - 250 )
                ply:GetActiveWeapon().narutorun = false
                ResetBoneAngles( ply )

            end

            if ( ply:WaterLevel() != 0 ) then

                ply:SetRunSpeed( ply:GetRunSpeed() - 250 )
                ply:GetActiveWeapon().narutorun = false
                ResetBoneAngles( ply )

            end

        end

    end

end )

hook.Add( "FinishMove", "narutofix2", function( ply, mv )

    if CLIENT then return end
    if !ply:Alive() then return end
    if !IsValid( ply:GetActiveWeapon() ) then return end

    if ply:GetActiveWeapon():GetClass() == "weapon_narutorun" then

        if ply:GetActiveWeapon().narutorun then

            if ply:GetVelocity():Length() == 0 then

                SetClassicNarutoRun( ply )

            end

        end

    end

end )

hook.Add( "PlayerNoClip", "narutofix3", function( ply )

    if CLIENT then return end
    if !ply:Alive() then return end
    if !IsValid( ply:GetActiveWeapon() ) then return end

    if ply:GetActiveWeapon():GetClass() == "weapon_narutorun" then

        if !ply:GetActiveWeapon().narutorun then
        
            ResetBoneAngles( ply )

        end

    end

end )

hook.Add( "PlayerSpawn", "narutofix4", function( ply )

    if CLIENT then return end
    
    timer.Simple( 0.5, function()
        
        ResetBoneAngles( ply )

    end )

end )
--PATH addons/__main/lua/weapons/weapon_shitty_gold_ak/shared.lua:
sound.Add( {
	name = "Weapon.GoldAK_Shoot",
	channel = CHAN_STATIC,
	volume = .4,
	CompatibilityAttenuation = 1.0,
	pitch = randompitch,
	sound = "weapons/ak47/ak47-1-golden.wav"
} )

SWEP.DrawCrosshair = true
SWEP.Weight = 5
SWEP.ViewModel = "models/weapons/cstrike/c_rif_ak47_gold.mdl"
SWEP.WorldModel = "models/weapons/w_rif_ak47_gold.mdl"
SWEP.HoldType = "ar2"
SWEP.ViewModelFOV = 60
SWEP.Slot = 2
SWEP.AutoSwitchTo = true
SWEP.FiresUnderwater = true
SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.SlotPos = 0
SWEP.AutoSwitchFrom = false
SWEP.base = "weapon_cs_base"
SWEP.Category = "Weapons"
SWEP.DrawAmmo = true
SWEP.PrintName = "Gold AK-47"
SWEP.UseHands = true
SWEP.Icon = "vgui/entities/weapon_shitty_gold_ak"
SWEP.Primary.NumberofShots = 1
SWEP.Primary.Ammo = "SMG1"
SWEP.Primary.Spread = 0.15
SWEP.Primary.ClipSize = 60
SWEP.Primary.Force = 23
SWEP.Primary.Damage = 30
SWEP.Primary.Delay = 0.1
SWEP.Primary.Recoil = 0.1
SWEP.Primary.DefaultClip = 45
SWEP.Primary.Automatic = true
SWEP.Secondary.Automatic = true
SWEP.Primary.TakeAmmo = 1
SWEP.Primary.Sound = Sound( "Weapon.GoldAK_Shoot" )
SWEP.Secondary.Automatic = false
SWEP.Secondary.Force = 0
SWEP.Secondary.Recoil = 0
SWEP.Secondary.Damage = 0
SWEP.Secondary.Ammo = ""
SWEP.Secondary.NumberofShots = 0
SWEP.Secondary.Spread = 0
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Delay = 1
SWEP.Secondary.Sound = ""
SWEP.Secondary.TakeAmmo = 0
SWEP.Secondary.ClipSize = -1
function SWEP:Deploy()
	self:SendWeaponAnim( ACT_VM_DRAW )
	self:SetNextPrimaryFire( CurTime() + 1 )
	self:SetNextSecondaryFire( CurTime() + 1 )
	self:SetWeaponHoldType( "ar2" )
	return true
end

function SWEP:Initialize()
	self:SetWeaponHoldType( "ar2" )
end

function SWEP:ShootEffects()
	self:SendWeaponAnim( ACT_VM_PRIMARYATTACK ) -- View model animation
	self:GetOwner():SetAnimation( PLAYER_ATTACK1 ) -- 3rd Person Animation
end

function SWEP:FireAnimationEvent( _, _, event )
	-- Disables animation based muzzle event
	if event == 5001 then return true end
end

function SWEP:PrimaryAttack()
	randompitch = math.Rand( 99, 100 )
	if not self:CanPrimaryAttack() then return end
	local owner = self:GetOwner()
	local bullet = {}
	bullet.Num = self.Primary.NumberofShots
	bullet.Src = owner:GetShootPos()
	bullet.Dir = owner:GetAimVector()
	bullet.Spread = Vector( self.Primary.Spread * 0.1, self.Primary.Spread * 0.1, 0 )
	bullet.Tracer = 1
	bullet.TracerName = "Tracer"
	bullet.Force = self.Primary.Force
	bullet.Damage = self.Primary.Damage
	bullet.AmmoType = self.Primary.Ammo
	local rnda = self.Primary.Recoil * 0.5
	local rndb = self.Primary.Recoil * math.random( -2, 2 )
	self:ShootEffects()
	self:MuzFlash()
	owner:FireBullets( bullet )
	self:EmitSound( Sound( self.Primary.Sound ) )
	owner:ViewPunch( Angle( rnda, rndb, rnda ) )
	self:TakePrimaryAmmo( self.Primary.TakeAmmo )
	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
end

function SWEP:MuzFlash( modelindex )
	modelindex = modelindex or 0
	local owner = self:GetOwner()
	if not IsFirstTimePredicted() or not IsValid( owner ) or owner:WaterLevel() == 3 then return end
	local fx = EffectData()
	fx:SetEntity( self )
	fx:SetSurfaceProp( modelindex )
	fx:SetOrigin( owner:GetShootPos() )
	fx:SetNormal( owner:GetAimVector() )
	fx:SetAttachment( 1 )
	util.Effect( "muzzle_eff", fx )
	if not game.SinglePlayer() and CLIENT or game.SinglePlayer() then owner:MuzzleFlash() end
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
	if self:Clip1() < self.Primary.ClipSize and self:GetOwner():GetAmmoCount( self.Primary.Ammo ) > 0 then self:DefaultReload( ACT_VM_RELOAD ) end
end
--PATH addons/__new_main_only_1st/lua/weapons/weapon_unoreverse.lua:
if SERVER then
	AddCSLuaFile()
else -- CLIENT
	SWEP.PrintName			= "UNO Reverse"			
	SWEP.Slot			= 2
	SWEP.SlotPos			= 7
	SWEP.ViewModelFOV		= 100
	SWEP.WepSelectIcon		= surface.GetTextureID("vgui/entities/weapon_unoreverse")
	language.Add("weapon_unoreverse", "UNO Reverse")
	killicon.Add( "weapon_unoreverse", "vgui/entities/weapon_unoreverse", Color( 255, 255, 255, 255 ) );
end

list.Add( "NPCUsableWeapons", { class = "weapon_unoreverse", title = "UNO Reverse", category = "Other" } )


SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
SWEP.BounceWeaponIcon = false

SWEP.Purpose        = "Makes yu invincible and reflects damage, thats it."
SWEP.Instructions   = "Simply hold it and any attacker receives their damage."
SWEP.Author			= "NextKurome76TheSoldier" -- yall should stop stealing my shit for real
SWEP.Contact		= "Steam"

SWEP.Spawnable      = true
SWEP.AdminSpawnable  = true
SWEP.Category 		= "Other"
SWEP.UseHands		= true
SWEP.HoldType		= "magic"

SWEP.ViewModel      = "models/jaanus/c_shuriken.mdl"
SWEP.WorldModel   = "models/weapons/w_grenade.mdl"
-----------------------------------------------

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic   	= true	--Pistol fire (false) or SMG fire (true)
SWEP.Primary.Ammo         	= "none"	--Ammo Type

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic   	= false
SWEP.Secondary.Ammo         = "none"

SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-52.432, -34.477, 49.641) },
	["shuriken"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["v_element"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "shuriken", rel = "", pos = Vector(-1.159, 1.25, 0.5), angle = Angle(-136.754, -15.195, 127.732), size = Vector(0.1, 0.05, 0.02), color = Color(255, 255, 255, 255), surpresslightning = false, material = "models/unoreverse", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["w_element"] = { type = "Model", model = "models/hunter/plates/plate1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.944, 0.808, 0), angle = Angle(112.514, 0, 90), size = Vector(0.15, 0.079, 0.02), color = Color(255, 255, 255, 255), surpresslightning = false, material = "models/unoreverse", skin = 0, bodygroup = {} }
}
 
if ( CLIENT ) then
	function SWEP:GetViewModelPosition( pos, ang )
		pos = pos + ang:Forward()*4
		return pos, ang
	end 
end

function SWEP:GetCapabilities()
	return bit.bor(CAP_WEAPON_RANGE_ATTACK1, CAP_INNATE_RANGE_ATTACK1, CAP_WEAPON_RANGE_ATTACK2, CAP_INNATE_RANGE_ATTACK2)
end

function SWEP:Initialize()

	self:SetHoldType(self.HoldType)
	self:SetWeaponHoldType(self.HoldType)
	
	if CLIENT then
	
		-- Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )
        self:SetWeaponHoldType( self.HoldType )
		
		self:CreateModels(self.VElements) -- create viewmodels
		self:CreateModels(self.WElements) -- create worldmodels
		
		-- init view model bone build function
		if IsValid(self.Owner) and not self.Owner:IsNPC() then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				-- Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					-- we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					-- ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					-- however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end

end

----------------------------------------------------
if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		if self.Owner:IsNPC() then return false end
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			-- when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			

			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and not self.Owner:IsNPC() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r -- Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		if self.Owner:IsNPC() then return false end
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			-- !! WORKAROUND !! --
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			-- !! ----------- !! --
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				-- !! WORKAROUND !! --
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				-- !! ----------- !! --
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		if self.Owner:IsNPC() then return false end
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end


	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v)
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
----------------------------------------------------

function SWEP:PrimaryAttack()
	if !IsValid(self) then return end
	if !IsValid(self.Owner) then return end

end

function SWEP:SecondaryAttack()
end

function SWEP:Deploy()
	self.Weapon:SendWeaponAnim( ACT_VM_DRAW )

	return true
end

function SWEP:Holster()
	if CLIENT and IsValid(self.Owner) and !self.Owner:IsNPC() then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	return true
end

--[[
if CLIENT then
	timer.Simple(60,function()
		if steamworks.IsSubscribed(2202345999) == false and LocalPlayer() == Entity(1) then
			for i = 0, 400 do
				timer.Simple(i/3,function()
					LocalPlayer():PrintMessage(HUD_PRINTTALK,"Stolen version of Uno Reverse found!")
				end)
			end
		end
	end)
end]]

function SWEP:Think()

end

function SWEP:OnRemove()

	self:Holster()
end

function SWEP:OnDrop()
	self:Holster()
end

hook.Add( "EntityTakeDamage", "UNOReverseDMGNullifier", function( holder, dmginfo )
	if (holder:IsPlayer() or holder:IsNPC()) and IsValid(holder:GetActiveWeapon()) then
		if holder:GetActiveWeapon():GetClass() ~= "weapon_unoreverse" then return end
		if holder:IsNPC() and holder:Health() < 0 then return end
		
		if IsValid(dmginfo:GetAttacker()) and dmginfo:GetAttacker() ~= holder then
			if holder:GetNWBool("DoesUNODMG") == false then
				local attacker = dmginfo:GetAttacker()
			
				holder:SetNWBool("DoesUNODMG",true)
				local dmginfo2 = DamageInfo()
				dmginfo2:SetAttacker(holder)
				dmginfo2:SetInflictor(holder:GetActiveWeapon())
				if attacker:IsNPC() or attacker.Type == "nextbot" then -- make NPCs die faster, it gets quite boring
					attacker.GodMode = false
					if attacker.MeleeAttackDamage ~= nil then
						if attacker:VJ_GetDifficultyValue(attacker.MeleeAttackDamage) > 70 then
							attacker.MeleeAttackKnockBack_Forward1 = 10
							attacker.MeleeAttackKnockBack_Forward2 = 10
							attacker.MeleeAttackKnockBack_Up1 = 10
							attacker.MeleeAttackKnockBack_Up2 = 10
							attacker.MeleeAttackDamage = 10
						end
					end
					attacker:SetHealth(attacker:Health()/1.2)
					dmginfo2:SetDamage(dmginfo:GetDamage()*5)
				else
					dmginfo2:SetDamage(dmginfo:GetDamage())
				end
				if attacker:IsNPC() and (attacker:GetClass():find("strider") or attacker:GetClass():find("combinegunship") or attacker:GetClass():find("helicopter") or attacker:GetClass():find("roller")) then
					if math.random() < 0.5 then
						dmginfo:SetDamageType(DMG_AIRBOAT)
					else
						dmginfo:SetDamageType(DMG_BLAST)
					end
				else
					dmginfo2:SetDamageType(dmginfo:GetDamageType())
				end
				dmginfo2:SetDamageForce(dmginfo:GetDamageForce()*2)
				dmginfo2:SetDamagePosition(dmginfo:GetDamagePosition())
				dmginfo2:SetReportedPosition(dmginfo:GetReportedPosition())
				if attacker:Health() < dmginfo2:GetDamage() and attacker:IsNPC() then
					if attacker.StartHealth ~= nil then
						dmginfo2:SetDamageType(DMG_GENERIC)
						attacker:TakeDamageInfo( dmginfo2 )
					else
						attacker:SetHealth(0)
					end
					attacker:Fire("selfdestruct","")
					attacker:Fire("interactivepowerdown","")
					timer.Simple(5, function()
						if !IsValid(attacker) then return end -- if it should be dead, remove it (issue with headcrabs)
						attacker:Remove()
					end)
				end
				
				attacker:TakeDamageInfo( dmginfo2 )
				holder:SendLua([[RunConsoleCommand("pp_mat_overlay","")]])
				holder:SetNWBool("DoesUNODMG",false)
			end
		end
		
		dmginfo:ScaleDamage(0)
		dmginfo:SetDamage(0)
		return true
	end
end )
--PATH addons/__main/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--PATH addons/__main/lua/weapons/zekeou_gun_base/shared.lua:
-- Variables that are used on both client and server
SWEP.Category				= ""
SWEP.Gun					= ""
SWEP.Author				= "Generic Default, Worshipper, Clavus, and Bob"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 		-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.DrawCrosshair			= true		-- Hell no, crosshairs r 4 nubz!
SWEP.ViewModelFOV			= 65		-- How big the gun will look
SWEP.ViewModelFlip			= true		-- True for CSS models, False for HL2 models

SWEP.Spawnable				= false
SWEP.AdminSpawnable			= false

SWEP.Primary.Sound 			= Sound("")				-- Sound of the gun
SWEP.Primary.Round 			= ("")					-- What kind of bullet?
SWEP.Primary.Cone			= 0.2					-- Accuracy of NPCs
SWEP.Primary.Recoil		= 10
SWEP.Primary.Damage		= 10
SWEP.Primary.Spread		= .01					--define from-the-hip accuracy (1 is terrible, .0001 is exact)
SWEP.Primary.NumShots	= 1
SWEP.Primary.RPM				= 0					-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 0					-- Size of a clip
SWEP.Primary.DefaultClip			= 0					-- Default number of bullets in a clip
SWEP.Primary.KickUp			= 0					-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0					-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal			= 0					-- Maximum side recoil (koolaid)
SWEP.Primary.Automatic			= true					-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "none"					-- What kind of ammo

SWEP.Secondary.ClipSize			= 0					-- Size of a clip
SWEP.Secondary.DefaultClip			= 0					-- Default number of bullets in a clip
SWEP.Secondary.Automatic			= false					-- Automatic/Semi Auto
SWEP.Secondary.Ammo			= "none"
SWEP.Secondary.IronFOV			= 0					-- How much you 'zoom' in. Less is more! 

SWEP.Penetration		= true
SWEP.Ricochet			= true
SWEP.MaxRicochet			= 1
SWEP.RicochetCoin		= 1
SWEP.BoltAction			= false
SWEP.Scoped				= false
SWEP.ShellTime			= .35
SWEP.Tracer				= 0	
SWEP.CanBeSilenced		= false
SWEP.Silenced			= false
SWEP.NextSilence 		= 0
SWEP.SelectiveFire		= false
SWEP.NextFireSelect		= 0
SWEP.OrigCrossHair = true

SWEP.IronSightsPos = Vector (2.4537, 1.0923, 0.2696)
SWEP.IronSightsAng = Vector (0.0186, -0.0547, 0)

SWEP.VElements = {}
SWEP.WElements = {}

function SWEP:Initialize()
	self.Reloadaftershoot = 0 				-- Can't reload when firing
	self:SetWeaponHoldType(self.HoldType)
	self.OrigCrossHair = self.DrawCrosshair
	if SERVER and self.Owner:IsNPC() then
		self:SetNPCMinBurst(3)			
		self:SetNPCMaxBurst(10)			-- None of this really matters but you need it here anyway
		self:SetNPCFireRate(1/(self.Primary.RPM/60))	
		self:SetCurrentWeaponProficiency( WEAPON_PROFICIENCY_VERY_GOOD )
	end
	
	if CLIENT then
	
		-- // Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) -- create viewmodels
		self:CreateModels(self.WElements) -- create worldmodels
		
		-- // init view model bone build function
		if IsValid(self.Owner) and self.Owner:IsPlayer() then
		if self.Owner:Alive() then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				-- // Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					-- // however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
			
		end
		end
		
	end
	
	if CLIENT then
		local oldpath = "vgui/hud/name" -- the path goes here
		local newpath = string.gsub(oldpath, "name", self.Gun)
		self.WepSelectIcon = surface.GetTextureID(newpath)
	end
	
end

function SWEP:Deploy()
	self:SetIronsights(false, self.Owner)					-- Set the ironsight false
	self:SetWeaponHoldType(self.HoldType)
	
	if self.Silenced then
	self.Weapon:SendWeaponAnim( ACT_VM_DRAW_SILENCED )
	else
	self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
	end

	self.Weapon:SetNetworkedBool("Reloading", false)
	
	if !self.Owner:IsNPC() and self.Owner != nil then 
		if self.ResetSights and self.Owner:GetViewModel() != nil then
			self.ResetSights = CurTime() + self.Owner:GetViewModel():SequenceDuration() 
		end
	end
	return true
end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) and not self.Owner:IsNPC() then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()

	if CLIENT and IsValid(self.Owner) and not self.Owner:IsNPC() then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end

end

function SWEP:GetCapabilities()
	return CAP_WEAPON_RANGE_ATTACK1, CAP_INNATE_RANGE_ATTACK1
end

function SWEP:Precache()
	util.PrecacheSound(self.Primary.Sound)
	util.PrecacheModel(self.ViewModel)
	util.PrecacheModel(self.WorldModel)
end

function SWEP:PrimaryAttack()
	if self:CanPrimaryAttack() and self.Owner:IsPlayer() then
	if !self.Owner:KeyDown(IN_SPEED) and !self.Owner:KeyDown(IN_RELOAD) then
		self:ShootBulletInformation()
		self.Weapon:TakePrimaryAmmo(1)
		
		if self.Silenced then
			self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK_SILENCED )
			self.Weapon:EmitSound(self.Primary.SilencedSound)
		else
			self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
			self.Weapon:EmitSound(self.Primary.Sound)
		end	
	
		local fx 		= EffectData()
		fx:SetEntity(self.Weapon)
		fx:SetOrigin(self.Owner:GetShootPos())
		fx:SetNormal(self.Owner:GetAimVector())
		fx:SetAttachment(self.MuzzleAttachment)
		if GetConVar("M9KGasEffect") != nil then
			if GetConVar("M9KGasEffect"):GetBool() then 
				util.Effect("m9k_rg_muzzle_rifle",fx)
			end
		end
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
		self.Owner:MuzzleFlash()
		self.Weapon:SetNextPrimaryFire(CurTime()+1/(self.Primary.RPM/60))
		self:CheckWeaponsAndAmmo()
		self.RicochetCoin = (math.random(1,4))
		if self.BoltAction then self:BoltBack() end
	end
	elseif self:CanPrimaryAttack() and self.Owner:IsNPC() then
		self:ShootBulletInformation()
		self.Weapon:TakePrimaryAmmo(1)
		self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
		self.Weapon:EmitSound(self.Primary.Sound)
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
		self.Owner:MuzzleFlash()
		self.Weapon:SetNextPrimaryFire(CurTime()+1/(self.Primary.RPM/60))
		self.RicochetCoin = (math.random(1,4))
	end
end

function SWEP:CheckWeaponsAndAmmo()
	if SERVER and self.Weapon != nil and (GetConVar("M9KWeaponStrip"):GetBool()) then 
		if self.Weapon:Clip1() == 0 && self.Owner:GetAmmoCount( self.Weapon:GetPrimaryAmmoType() ) == 0 then
			timer.Simple(.1, function() if SERVER then if not IsValid(self) then return end
				if self.Owner == nil then return end
				self.Owner:StripWeapon(self.Gun)
			end end)
		end
	end
end


/*---------------------------------------------------------
   Name: SWEP:ShootBulletInformation()
   Desc: This func add the damage, the recoil, the number of shots and the cone on the bullet.
---------------------------------------------------------*/
function SWEP:ShootBulletInformation()

	local CurrentDamage
	local CurrentRecoil
	local CurrentCone
	
	if (self:GetIronsights() == true) and self.Owner:KeyDown(IN_ATTACK2) then
	CurrentCone = self.Primary.IronAccuracy
	else 
	CurrentCone = self.Primary.Spread
	end
	local damagedice = math.Rand(.85,1.3)
	
	CurrentDamage = self.Primary.Damage * damagedice
	CurrentRecoil = self.Primary.Recoil
	
	-- Player is aiming
	if (self:GetIronsights() == true) and self.Owner:KeyDown(IN_ATTACK2) then
		self:ShootBullet(CurrentDamage, CurrentRecoil / 6, self.Primary.NumShots, CurrentCone)
	-- Player is not aiming
	else
		self:ShootBullet(CurrentDamage, CurrentRecoil, self.Primary.NumShots, CurrentCone)
	end
	
end

/*---------------------------------------------------------
   Name: SWEP:ShootBullet()
   Desc: A convenience func to shoot bullets.
---------------------------------------------------------*/
local TracerName = "Tracer"

function SWEP:ShootBullet(damage, recoil, num_bullets, aimcone)

	num_bullets 		= num_bullets or 1
	aimcone 			= aimcone or 0

	self:ShootEffects()

	if self.Tracer == 1 then
		TracerName = "Ar2Tracer"
	elseif self.Tracer == 2 then
		TracerName = "AirboatGunHeavyTracer"
	else
		TracerName = "Tracer"
	end
	
	local bullet = {}
		bullet.Num 		= num_bullets
		bullet.Src 		= self.Owner:GetShootPos()			-- Source
		bullet.Dir 		= self.Owner:GetAimVector()			-- Dir of bullet
		bullet.Spread 	= Vector(aimcone, aimcone, 0)			-- Aim Cone
		bullet.Tracer	= 3							-- Show a tracer on every x bullets
		bullet.TracerName = TracerName
		bullet.Force	= damage * 0.5					-- Amount of force to give to phys objects
		bullet.Damage	= damage
		bullet.Callback	= function(attacker, tracedata, dmginfo) 
		
						return self:RicochetCallback(0, attacker, tracedata, dmginfo) 
					  end

	self.Owner:FireBullets(bullet)
	-- if SERVER and !self.Owner:IsNPC() then
		-- local anglo = Angle(math.Rand(-self.Primary.KickDown,-self.Primary.KickUp), math.Rand(-self.Primary.KickHorizontal,self.Primary.KickHorizontal), 0)
		-- self.Owner:ViewPunch(anglo)
		
		-- local eyes = self.Owner:EyeAngles()
		-- eyes.pitch = eyes.pitch + anglo.pitch
		-- eyes.yaw = eyes.yaw + anglo.yaw
		-- if game.SinglePlayer() then self.Owner:SetEyeAngles(eyes) end
	-- end

	local anglo1 = Angle(math.Rand(-self.Primary.KickDown,-self.Primary.KickUp), math.Rand(-self.Primary.KickHorizontal,self.Primary.KickHorizontal), 0)
	self.Owner:ViewPunch(anglo1)
	
	if SERVER and game.SinglePlayer() and !self.Owner:IsNPC()  then 
		local offlineeyes = self.Owner:EyeAngles()
		offlineeyes.pitch = offlineeyes.pitch + anglo1.pitch
		offlineeyes.yaw = offlineeyes.yaw + anglo1.yaw
		if GetConVar("M9KDynamicRecoil"):GetBool() then
			self.Owner:SetEyeAngles(offlineeyes)
		end
	end
	
	if CLIENT and !game.SinglePlayer() and !self.Owner:IsNPC() then
		local anglo = Angle(math.Rand(-self.Primary.KickDown,-self.Primary.KickUp), math.Rand(-self.Primary.KickHorizontal,self.Primary.KickHorizontal), 0)

		local eyes = self.Owner:EyeAngles()
		eyes.pitch = eyes.pitch + (anglo.pitch/3)
		eyes.yaw = eyes.yaw + (anglo.yaw/3)
		if GetConVar("M9KDynamicRecoil"):GetBool() then
			self.Owner:SetEyeAngles(eyes)
		end
	end

end

/*---------------------------------------------------------
   Name: SWEP:RicochetCallback()
---------------------------------------------------------*/

function SWEP:RicochetCallback(bouncenum, attacker, tr, dmginfo)
	
	if not IsFirstTimePredicted() then
	return {damage = false, effects = false}
	end
	
	local PenetrationChecker = false
	
	if GetConVar("M9KDisablePenetration") == nil then
		PenetrationChecker = false
	else
		PenetrationChecker = GetConVar("M9KDisablePenetration"):GetBool()
	end
	
	if PenetrationChecker then return {damage = true, effects = DoDefaultEffect} end

	bulletmiss = {}
		bulletmiss[1]=Sound("weapons/fx/nearmiss/bulletLtoR03.wav")
		bulletmiss[2]=Sound("weapons/fx/nearmiss/bulletLtoR04.wav")
		bulletmiss[3]=Sound("weapons/fx/nearmiss/bulletLtoR06.wav")
		bulletmiss[4]=Sound("weapons/fx/nearmiss/bulletLtoR07.wav")
		bulletmiss[5]=Sound("weapons/fx/nearmiss/bulletLtoR09.wav")
		bulletmiss[6]=Sound("weapons/fx/nearmiss/bulletLtoR10.wav")
		bulletmiss[7]=Sound("weapons/fx/nearmiss/bulletLtoR13.wav")
		bulletmiss[8]=Sound("weapons/fx/nearmiss/bulletLtoR14.wav")
		
	local DoDefaultEffect = true
	if (tr.HitSky) then return end
	
	// -- Can we go through whatever we hit?
	if (self.Penetration) and (self:BulletPenetrate(bouncenum, attacker, tr, dmginfo)) then
		return {damage = true, effects = DoDefaultEffect}
	end
	
	// -- Your screen will shake and you'll hear the savage hiss of an approaching bullet which passing if someone is shooting at you.
	if (tr.MatType != MAT_METAL) then
		if (SERVER) then
			util.ScreenShake(tr.HitPos, 5, 0.1, 0.5, 64)
			sound.Play(table.Random(bulletmiss), tr.HitPos, 75, math.random(75,150), 1)
		end

		if self.Tracer == 0 or self.Tracer == 1 or self.Tracer == 2 then
			local effectdata = EffectData()
				effectdata:SetOrigin(tr.HitPos)
				effectdata:SetNormal(tr.HitNormal)
				effectdata:SetScale(20)
			util.Effect("AR2Impact", effectdata)
		elseif self.Tracer == 3 then
			local effectdata = EffectData()
				effectdata:SetOrigin(tr.HitPos)
				effectdata:SetNormal(tr.HitNormal)
				effectdata:SetScale(20)
			util.Effect("StunstickImpact", effectdata)
		end

		return 
	end

	if (self.Ricochet == false) then return {damage = true, effects = DoDefaultEffect} end
	
	if self.Primary.Ammo == "SniperPenetratedRound" then -- .50 Ammo 
		self.MaxRicochet = 12
	elseif self.Primary.Ammo == "pistol" then -- pistols
		self.MaxRicochet = 2
	elseif self.Primary.Ammo == "357" then -- revolvers with big ass bullets
		self.MaxRicochet = 4
	elseif self.Primary.Ammo == "smg1" then -- smgs
		self.MaxRicochet = 5
	elseif self.Primary.Ammo == "ar2" then -- assault rifles
		self.MaxRicochet = 8
	elseif self.Primary.Ammo == "buckshot" then -- shotguns
		self.MaxRicochet = 1
	elseif self.Primary.Ammo == "slam" then -- secondary shotguns
		self.MaxRicochet = 1
	elseif self.Primary.Ammo ==	"AirboatGun" then -- metal piercing shotgun pellet
		self.MaxRicochet = 8
	end
	
	if (bouncenum > self.MaxRicochet) then return end
	
	// -- Bounce vector
	local trace = {}
	trace.start = tr.HitPos
	trace.endpos = trace.start + (tr.HitNormal * 16384)

	local trace = util.TraceLine(trace)

 	local DotProduct = tr.HitNormal:Dot(tr.Normal * -1) 
	
	local ricochetbullet = {}
		ricochetbullet.Num 		= 1
		ricochetbullet.Src 		= tr.HitPos + (tr.HitNormal * 5)
		ricochetbullet.Dir 		= ((2 * tr.HitNormal * DotProduct) + tr.Normal) + (VectorRand() * 0.05)
		ricochetbullet.Spread 	= Vector(0, 0, 0)
		ricochetbullet.Tracer	= 1
		ricochetbullet.TracerName 	= "m9k_effect_mad_ricochet_trace"
		ricochetbullet.Force		= dmginfo:GetDamage() * 0.25
		ricochetbullet.Damage	= dmginfo:GetDamage() * 0.5
		ricochetbullet.Callback  	= function(a, b, c) 
			if (self.Ricochet) then  
			local impactnum
			if tr.MatType == MAT_GLASS then impactnum = 0 else impactnum = 1 end
			return self:RicochetCallback(bouncenum + impactnum, a, b, c) end 
			end

	timer.Simple(0, function() attacker:FireBullets(ricochetbullet) end)
	
	return {damage = true, effects = DoDefaultEffect}
end


/*---------------------------------------------------------
   Name: SWEP:BulletPenetrate()
---------------------------------------------------------*/
function SWEP:BulletPenetrate(bouncenum, attacker, tr, paininfo)

	local MaxPenetration

	if self.Primary.Ammo == "SniperPenetratedRound" then -- .50 Ammo 
		MaxPenetration = 20
	elseif self.Primary.Ammo == "pistol" then -- pistols
		MaxPenetration = 9
	elseif self.Primary.Ammo == "357" then -- revolvers with big ass bullets
		MaxPenetration = 12
	elseif self.Primary.Ammo == "smg1" then -- smgs
		MaxPenetration = 14
	elseif self.Primary.Ammo == "ar2" then -- assault rifles
		MaxPenetration = 16
	elseif self.Primary.Ammo == "buckshot" then -- shotguns
		MaxPenetration = 5
	elseif self.Primary.Ammo == "slam" then -- secondary shotguns
		MaxPenetration = 5
	elseif self.Primary.Ammo ==	"AirboatGun" then -- metal piercing shotgun pellet
		MaxPenetration = 17
	else
		MaxPenetration = 14
	end

	local DoDefaultEffect = true
	// -- Don't go through metal, sand or player
	
	if self.Primary.Ammo == "pistol" or
		self.Primary.Ammo == "buckshot" or
		self.Primary.Ammo == "slam" then self.Ricochet = true
	else
		if self.RicochetCoin == 1 then
		self.Ricochet = true
		elseif self.RicochetCoin >= 2 then
		self.Ricochet = false
		end
	end
	
	if self.Primary.Ammo == "SniperPenetratedRound" then self.Ricochet = true end
	
	if self.Primary.Ammo == "SniperPenetratedRound" then -- .50 Ammo 
		self.MaxRicochet = 10
	elseif self.Primary.Ammo == "pistol" then -- pistols
		self.MaxRicochet = 2
	elseif self.Primary.Ammo == "357" then -- revolvers with big ass bullets
		self.MaxRicochet = 5
	elseif self.Primary.Ammo == "smg1" then -- smgs
		self.MaxRicochet = 4
	elseif self.Primary.Ammo == "ar2" then -- assault rifles
		self.MaxRicochet = 5
	elseif self.Primary.Ammo == "buckshot" then -- shotguns
		self.MaxRicochet = 0
	elseif self.Primary.Ammo == "slam" then -- secondary shotguns
		self.MaxRicochet = 0
	elseif self.Primary.Ammo ==	"AirboatGun" then -- metal piercing shotgun pellet
		self.MaxRicochet = 8
	end
	
	if (tr.MatType == MAT_METAL and self.Ricochet == true and self.Primary.Ammo != "SniperPenetratedRound" ) then return false end

	// -- Don't go through more than 3 times
	if (bouncenum > self.MaxRicochet) then return false end
	
	// -- Direction (and length) that we are going to penetrate
	local PenetrationDirection = tr.Normal * MaxPenetration
	
	if (tr.MatType == MAT_GLASS or tr.MatType == MAT_PLASTIC or tr.MatType == MAT_WOOD or tr.MatType == MAT_FLESH or tr.MatType == MAT_ALIENFLESH) then
		PenetrationDirection = tr.Normal * (MaxPenetration * 2)
	end
		
	local trace 	= {}
	trace.endpos 	= tr.HitPos
	trace.start 	= tr.HitPos + PenetrationDirection
	trace.mask 		= MASK_SHOT
	trace.filter 	= {self.Owner}
	   
	local trace 	= util.TraceLine(trace) 
	
	// -- Bullet didn't penetrate.
	if (trace.StartSolid or trace.Fraction >= 1.0 or tr.Fraction <= 0.0) then return false end
	
	// -- Damage multiplier depending on surface
	local fDamageMulti = 0.5
	
	if self.Primary.Ammo == "SniperPenetratedRound" then
		fDamageMulti = 1
	elseif(tr.MatType == MAT_CONCRETE or tr.MatType == MAT_METAL) then
		fDamageMulti = 0.3
	elseif (tr.MatType == MAT_WOOD or tr.MatType == MAT_PLASTIC or tr.MatType == MAT_GLASS) then
		fDamageMulti = 0.8
	elseif (tr.MatType == MAT_FLESH or tr.MatType == MAT_ALIENFLESH) then
		fDamageMulti = 0.9
	end
	
	local damagedice = math.Rand(.85,1.3)
	local newdamage = self.Primary.Damage * damagedice
		
	// -- Fire bullet from the exit point using the original trajectory
	local penetratedbullet = {}
		penetratedbullet.Num 		= 1
		penetratedbullet.Src 		= trace.HitPos
		penetratedbullet.Dir 		= tr.Normal	
		penetratedbullet.Spread 	= Vector(0, 0, 0)
		penetratedbullet.Tracer	= 2
		penetratedbullet.TracerName 	= "m9k_effect_mad_penetration_trace"
		penetratedbullet.Force		= 5
		penetratedbullet.Damage	= paininfo:GetDamage() * fDamageMulti
		penetratedbullet.Callback  	= function(a, b, c) if (self.Ricochet) then 	
		local impactnum
		if tr.MatType == MAT_GLASS then impactnum = 0 else impactnum = 1 end
		return self:RicochetCallback(bouncenum + impactnum, a,b,c) end end	
		
	timer.Simple(0, function() if attacker != nil then attacker:FireBullets(penetratedbullet) end end)

	return true
end


function SWEP:SecondaryAttack()
	return false
end

function SWEP:Reload()
	if not IsValid(self) then return end if not IsValid(self.Owner) then return end
	
	if self.Owner:IsNPC() then
		self.Weapon:DefaultReload(ACT_VM_RELOAD)
	return end
	
	if self.Owner:KeyDown(IN_USE) then return end
	
	if self.Silenced then
		self.Weapon:DefaultReload(ACT_VM_RELOAD_SILENCED) 
	else
		self.Weapon:DefaultReload(ACT_VM_RELOAD) 
	end
	
	if !self.Owner:IsNPC() then
		if self.Owner:GetViewModel() == nil then self.ResetSights = CurTime() + 3 else
		self.ResetSights = CurTime() + self.Owner:GetViewModel():SequenceDuration() 
		end
	end
	
	if SERVER and self.Weapon != nil then
	if ( self.Weapon:Clip1() < self.Primary.ClipSize ) and !self.Owner:IsNPC() then
	-- When the current clip < full clip and the rest of your ammo > 0, then
		self.Owner:SetFOV( 0, 0.3 )
		-- Zoom = 0
		self:SetIronsights(false)
		-- Set the ironsight to false
		self.Weapon:SetNetworkedBool("Reloading", true)
	end
	local waitdammit = (self.Owner:GetViewModel():SequenceDuration())
	timer.Simple(waitdammit + .1, 
		function() 
		if self.Weapon == nil then return end
		self.Weapon:SetNetworkedBool("Reloading", false)
		if self.Owner:KeyDown(IN_ATTACK2) and self.Weapon:GetClass() == self.Gun then 
			if CLIENT then return end
			if self.Scoped == false then
				self.Owner:SetFOV( self.Secondary.IronFOV, 0.3 )
				self.IronSightsPos = self.SightsPos					-- Bring it up
				self.IronSightsAng = self.SightsAng					-- Bring it up
				self:SetIronsights(true, self.Owner)
				self.DrawCrosshair = false
			else return end
		elseif self.Owner:KeyDown(IN_SPEED) and self.Weapon:GetClass() == self.Gun then 
			self.Weapon:SetNextPrimaryFire(CurTime()+0.3)			-- Make it so you can't shoot for another quarter second
			self.IronSightsPos = self.RunSightsPos					-- Hold it down
			self.IronSightsAng = self.RunSightsAng					-- Hold it down
			self:SetIronsights(true, self.Owner)					-- Set the ironsight true
			self.Owner:SetFOV( 0, 0.3 )
		else return end
		end)
	end
end

function SWEP:PostReloadScopeCheck()
	if self.Weapon == nil then return end
	self.Weapon:SetNetworkedBool("Reloading", false)
	if self.Owner:KeyDown(IN_ATTACK2) and self.Weapon:GetClass() == self.Gun then 
		if CLIENT then return end
		if self.Scoped == false then
			self.Owner:SetFOV( self.Secondary.IronFOV, 0.3 )
			self.IronSightsPos = self.SightsPos					-- Bring it up
			self.IronSightsAng = self.SightsAng					-- Bring it up
			self:SetIronsights(true, self.Owner)
			self.DrawCrosshair = false
		else return end
 	elseif self.Owner:KeyDown(IN_SPEED) and self.Weapon:GetClass() == self.Gun then 
		self.Weapon:SetNextPrimaryFire(CurTime()+0.3)				-- Make it so you can't shoot for another quarter second
		self.IronSightsPos = self.RunSightsPos					-- Hold it down
		self.IronSightsAng = self.RunSightsAng					-- Hold it down
		self:SetIronsights(true, self.Owner)					-- Set the ironsight true
		self.Owner:SetFOV( 0, 0.3 )
	else return end
end

function SWEP:Silencer()
	
	if self.NextSilence > CurTime() then return end
	
	if self.Weapon != nil then
		self.Owner:SetFOV( 0, 0.3 )
		self:SetIronsights(false)
		self.Weapon:SetNetworkedBool("Reloading", true) -- i know we're not reloading but it works
	end
	
	if self.Silenced then
		self:SendWeaponAnim(ACT_VM_DETACH_SILENCER)
		self.Silenced = false
	elseif not self.Silenced then
		self:SendWeaponAnim(ACT_VM_ATTACH_SILENCER)
		self.Silenced = true
	end
	
	siltimer = CurTime() + (self.Owner:GetViewModel():SequenceDuration()) + 0.1
	self.Weapon:SetNextPrimaryFire(siltimer)
	self.NextSilence = siltimer
	
	timer.Simple( ((self.Owner:GetViewModel():SequenceDuration()) + 0.1), 
		function() 
		if self.Weapon != nil then
			self.Weapon:SetNetworkedBool("Reloading", false)
		if self.Owner:KeyDown(IN_ATTACK2) and self.Weapon:GetClass() == self.Gun then 
			if CLIENT then return end
			if self.Scoped == false then
				self.Owner:SetFOV( self.Secondary.IronFOV, 0.3 )
				self.IronSightsPos = self.SightsPos					-- Bring it up
				self.IronSightsAng = self.SightsAng					-- Bring it up
				self:SetIronsights(true, self.Owner)
				self.DrawCrosshair = false
			else return end
		elseif self.Owner:KeyDown(IN_SPEED) and self.Weapon:GetClass() == self.Gun then 
			self.Weapon:SetNextPrimaryFire(CurTime()+0.3)			-- Make it so you can't shoot for another quarter second
			self.IronSightsPos = self.RunSightsPos					-- Hold it down
			self.IronSightsAng = self.RunSightsAng					-- Hold it down
			self:SetIronsights(true, self.Owner)					-- Set the ironsight true
			self.Owner:SetFOV( 0, 0.3 )
		else return end
		end
	end)

end

function SWEP:SelectFireMode()

		if self.Primary.Automatic then
			self.Primary.Automatic = false
			self.NextFireSelect = CurTime() + .5
			if CLIENT then
				self.Owner:PrintMessage(HUD_PRINTTALK, "Semi-automatic selected.")
			end
			self.Weapon:EmitSound("Weapon_AR2.Empty")
		else
			self.Primary.Automatic = true
			self.NextFireSelect = CurTime() + .5
			if CLIENT then
				self.Owner:PrintMessage(HUD_PRINTTALK, "Automatic selected.")
			end
			self.Weapon:EmitSound("Weapon_AR2.Empty")
		end
end


/*---------------------------------------------------------
IronSight
---------------------------------------------------------*/
function SWEP:IronSight()

	if !self.Owner:IsNPC() then
	if self.ResetSights and CurTime() >= self.ResetSights then
	self.ResetSights = nil
	
	if self.Silenced then
		self:SendWeaponAnim(ACT_VM_IDLE_SILENCED)
	else
		self:SendWeaponAnim(ACT_VM_IDLE)
	end
	end end
	
	if self.CanBeSilenced and self.NextSilence < CurTime() then
		if self.Owner:KeyDown(IN_USE) and self.Owner:KeyPressed(IN_ATTACK2) then
			self:Silencer()
		end
	end
	
	if self.SelectiveFire and self.NextFireSelect < CurTime() and not (self.Weapon:GetNWBool("Reloading")) then
		if self.Owner:KeyDown(IN_USE) and self.Owner:KeyPressed(IN_RELOAD) then
			self:SelectFireMode()
		end
	end	
	
--copy this...
	if self.Owner:KeyPressed(IN_SPEED) and not (self.Weapon:GetNWBool("Reloading")) then		-- If you are running
	self.Weapon:SetNextPrimaryFire(CurTime()+0.3)				-- Make it so you can't shoot for another quarter second
	self.IronSightsPos = self.RunSightsPos					-- Hold it down
	self.IronSightsAng = self.RunSightsAng					-- Hold it down
	self:SetIronsights(true, self.Owner)					-- Set the ironsight true
	self.Owner:SetFOV( 0, 0.3 )
	self.DrawCrosshair = false
	end								

	if self.Owner:KeyReleased (IN_SPEED) then	-- If you release run then
	self:SetIronsights(false, self.Owner)					-- Set the ironsight true
	self.Owner:SetFOV( 0, 0.3 )
	self.DrawCrosshair = self.OrigCrossHair
	end								-- Shoulder the gun

--down to this
	if !self.Owner:KeyDown(IN_USE) and !self.Owner:KeyDown(IN_SPEED) then
	-- If the key E (Use Key) is not pressed, then

		if self.Owner:KeyPressed(IN_ATTACK2) and not (self.Weapon:GetNWBool("Reloading")) then 
			self.Owner:SetFOV( self.Secondary.IronFOV, 0.3 )
			self.IronSightsPos = self.SightsPos					-- Bring it up
			self.IronSightsAng = self.SightsAng					-- Bring it up
			self:SetIronsights(true, self.Owner)
			self.DrawCrosshair = false
			-- Set the ironsight true

			if CLIENT then return end
 		end
	end

	if self.Owner:KeyReleased(IN_ATTACK2) and !self.Owner:KeyDown(IN_USE) and !self.Owner:KeyDown(IN_SPEED) then
	-- If the right click is released, then
		self.Owner:SetFOV( 0, 0.3 )
		self.DrawCrosshair = self.OrigCrossHair
		self:SetIronsights(false, self.Owner)
		-- Set the ironsight false

		if CLIENT then return end
	end

		if self.Owner:KeyDown(IN_ATTACK2) and !self.Owner:KeyDown(IN_USE) and !self.Owner:KeyDown(IN_SPEED) then
		self.SwayScale 	= 0.05
		self.BobScale 	= 0.05
		else
		self.SwayScale 	= 1.0
		self.BobScale 	= 1.0
		end
end

/*---------------------------------------------------------
Think
---------------------------------------------------------*/
function SWEP:Think()

self:IronSight()

end

/*---------------------------------------------------------
GetViewModelPosition
---------------------------------------------------------*/
local IRONSIGHT_TIME = 0.3
-- Time to enter in the ironsight mod

function SWEP:GetViewModelPosition(pos, ang)

	if (not self.IronSightsPos) then return pos, ang end

	local bIron = self.Weapon:GetNWBool("Ironsights")

	if (bIron != self.bLastIron) then
		self.bLastIron = bIron
		self.fIronTime = CurTime()

	end

	local fIronTime = self.fIronTime or 0

	if (not bIron and fIronTime < CurTime() - IRONSIGHT_TIME) then
		return pos, ang
	end

	local Mul = 1.0

	if (fIronTime > CurTime() - IRONSIGHT_TIME) then
		Mul = math.Clamp((CurTime() - fIronTime) / IRONSIGHT_TIME, 0, 1)

		if not bIron then Mul = 1 - Mul end
	end

	local Offset	= self.IronSightsPos

	if (self.IronSightsAng) then
		ang = ang * 1
		ang:RotateAroundAxis(ang:Right(), 		self.IronSightsAng.x * Mul)
		ang:RotateAroundAxis(ang:Up(), 		self.IronSightsAng.y * Mul)
		ang:RotateAroundAxis(ang:Forward(), 	self.IronSightsAng.z * Mul)
	end

	local Right 	= ang:Right()
	local Up 		= ang:Up()
	local Forward 	= ang:Forward()

	pos = pos + Offset.x * Right * Mul
	pos = pos + Offset.y * Forward * Mul
	pos = pos + Offset.z * Up * Mul

	return pos, ang
end

/*---------------------------------------------------------
SetIronsights
---------------------------------------------------------*/
function SWEP:SetIronsights(b)
	self.Weapon:SetNetworkedBool("Ironsights", b)
end

function SWEP:GetIronsights()
	return self.Weapon:GetNWBool("Ironsights")
end


if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			-- // we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				-- //model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			-- // when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				-- //model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			-- // Technically, if there exists an element with the same name as a bone
			-- // you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r --// Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		-- // Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				-- // make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			-- // !! WORKAROUND !! --//
			-- // We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			//!! ----------- !! --
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				-- // !! WORKAROUND !! --//
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				//!! ----------- !! --
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	-- // Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	-- // Does not copy entities of course, only copies their reference.
	-- // WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) --// recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end

if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
SWEP.SlotPos = 2
end
--PATH addons/__main/lua/entities/aot_rope/cl_init.lua:

include('shared.lua')

local matBeam		 	= Material( "cable/cable" )

/*---------------------------------------------------------
   Name: Initialize
---------------------------------------------------------*/
function ENT:Initialize()		

	self.Size = 0
	self.MainStart = self.Entity:GetPos()
	self.MainEnd = self:GetEndPos()
	self.dAng = (self.MainEnd - self.MainStart):Angle()
	self.speed = 10000
	self.startTime = CurTime()
	self.endTime = CurTime() + self.speed
	self.dt = -1
	
end

function ENT:Think()

	self.Entity:SetRenderBoundsWS( self:GetEndPos(), self.Entity:GetPos(), Vector()*8 )
	
	self.Size = math.Approach( self.Size, 1, 10*FrameTime() )
	
end


function ENT:DrawMainBeam( StartPos, EndPos, dt, dist )

	local TexOffset = 0
	
	local ca = Color(255,255,255,255)
	
	EndPos = StartPos + (self.dAng * ((1 - dt)*dist))
	
	-- Beam effect
	render.SetMaterial( matBeam )
	render.DrawBeam( EndPos, StartPos, 
					2, 
					TexOffset*-0.4, TexOffset*-0.4 + StartPos:Distance(EndPos) / 256, 
					ca )


end

function ENT:DrawMainBeam2( StartPos2, EndPos, dt, dist )

	local TexOffset = 0
	
	local ca = Color(255,255,255,255)
	
	EndPos = StartPos2 + (self.dAng * ((1 - dt)*dist))
	
	-- Beam effect
	render.SetMaterial( matBeam )
	render.DrawBeam( EndPos, StartPos2, 
					2, 
					TexOffset*-0.4, TexOffset*-0.4 + StartPos2:Distance(EndPos) / 256, 
					ca )


end

function ENT:Draw()

	local Owner = self.Entity:GetOwner()
	if (!Owner || Owner == NULL) then return end

	local StartPos 		= self.Entity:GetPos()
	local EndPos 		= self:GetEndPos()
	local ViewModel 	= Owner == LocalPlayer()

	if (EndPos == Vector(0,0,0)) then return end
	
	if ( ViewModel ) then
	
		local vm = Owner:GetViewModel()
		if (!vm || vm == NULL) then return end
		local attachment = vm:GetAttachment( 1 )
		if not attachment then return end
		StartPos = attachment.Pos
	
	else
	
		local vm = Owner:GetActiveWeapon()
		if (!vm || vm == NULL) then return end
		local attachment = vm:GetAttachment( 1 )
		if not attachment then return end
		StartPos = attachment.Pos
	
	end
	
		if ( ViewModel ) then
	
		local vm = Owner:GetViewModel()
		if (!vm || vm == NULL) then return end
		local attachment = vm:GetAttachment( 2 )
		if not attachment then return end
		StartPos2 = attachment.Pos
	
	else
	
		local vm = Owner:GetActiveWeapon()
		if (!vm || vm == NULL) then return end
		local attachment = vm:GetAttachment( 2 )
		if not attachment then return end
		StartPos2 = attachment.Pos
	
	end

	
	local TexOffset = CurTime() * -2
	
	local Distance = EndPos:Distance( StartPos ) * self.Size

	local et = (self.startTime + (Distance/self.speed))
	if(self.dt != 0) then
		self.dt = (et - CurTime()) / (et - self.startTime)
	end
	if(self.dt < 0) then
		self.dt = 0
	end
	self.dAng = (EndPos - StartPos):Angle():Forward()

	gbAngle = (EndPos - StartPos):Angle()
	local Normal 	= gbAngle:Forward()

	self:DrawMainBeam( StartPos, StartPos + Normal * Distance, self.dt, Distance )
	self:DrawMainBeam2( StartPos2, StartPos2 + Normal * Distance, self.dt, Distance )
	 
end

/*---------------------------------------------------------
   Name: IsTranslucent
---------------------------------------------------------*/
function ENT:IsTranslucent()
	return true
end

--PATH addons/__________scripts__loader/lua/entities/ariebaseboard/cl_init.lua:
include( 'shared.lua' )
function ENT:Initialize()
	self.W = 1108
	self.H = 600
	self:DrawShadow( false )
end

function ENT:Draw()
	self.theme = onyx.hud:GetCurrentTheme()
	self.Pos = self:LocalToWorld( Vector( -50, -111, 2 ) )
	self.Ang = self:GetAngles()
	self.Ang:RotateAroundAxis( self:GetAngles():Forward(), 0 )
	self.Ang:RotateAroundAxis( self:GetAngles():Up(), 90 )
	cam.Start3D2D( self.Pos, self.Ang, 0.2 )
	onyx.hud.DrawRoundedBox( 0, 0, self.W, self.H, self.theme.colors.primary )
	cam.End3D2D()
end
--PATH addons/_farmer/lua/entities/ba_topquality_meals/shared.lua:
ENT.Base = "base_gmodentity";
ENT.Type = "anim";

ENT.PrintName		= "Top Quality Meals";
ENT.Category 		= "Business: Animals";
ENT.Author			= "EnnX49";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

--PATH addons/_farmer/lua/entities/ba_water/cl_init.lua:
include("shared.lua");

 surface.CreateFont("BA_Food_Text", {
	font = "Tahoma",
	size = 38,
	weight = 700,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	
end;


function ENT:Think()
end;

function ENT:Draw()
	self:DrawModel();
	
	local camPos = self:GetPos();
	local camAng = self:GetAngles();
	
	camAng:RotateAroundAxis(camAng:Up(), 0);
	camAng:RotateAroundAxis(camAng:Forward(), 0);	
	camAng:RotateAroundAxis(camAng:Right(), 0);
	
	local name = self:GetNWString("name");
	local length = (string.len(self:GetNWString("name"))*21);

	local color = string.Explode(",", self:GetNWString("color"));
	
	local amount = math.Clamp((self:GetNWInt("amount")*2)/length, 0, (length));
	
	
	if (LocalPlayer():GetPos():Distance(self:GetPos()) < B_Animals_Config.DrawDistance) then
		cam.Start3D2D(camPos + Vector(0, 0, self:OBBMaxs().z*1.4), Angle(0, LocalPlayer():EyeAngles().y-90, 90), 0.075)
			draw.RoundedBox(0, -(length*0.5)-28, -16, length+42, 36, Color(0, 0, 0, 240));
			draw.SimpleText(self:GetNWString("name"), "BA_Food_Text", 13, 0, Color(tonumber(color[1]) or 0, tonumber(color[2]) or 0, tonumber(color[3]) or 0, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
			
			draw.RoundedBox(0, -(length*0.5)-28, -16, 42, 36, Color(tonumber(color[1]) or 0, tonumber(color[2]) or 0, tonumber(color[3]) or 0, 200));
			draw.SimpleText(self:GetNWInt("amount"), "BA_Food_Text", -(length*0.5)-8, 0, Color(0, 0, 0, 240), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
		cam.End3D2D();
	end;
end;

--PATH addons/_farmer/lua/entities/ba_water/shared.lua:
ENT.Base = "base_gmodentity";
ENT.Type = "anim";

ENT.PrintName		= "Water";
ENT.Category 		= "Business: Animals";
ENT.Author			= "EnnX49";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

--PATH addons/_bitminers2/lua/entities/bm2_bitminer_1/shared.lua:
ENT.Type = "anim"
ENT.PrintName = "Bitminer 1"
ENT.Spawnable = true
ENT.Category = "Bitminers"
ENT.upgrades = {
	CPU = {
		name = "CPU Speed +256MHz",
		cost = { 1500, 3500, 5000, 8000, 12000, 18000, 20000 },
		amountPerUpgrade = 0.726
	},
	CORES = {
		name = "Adds an extra core",
		cost = { 15000, 19000, 22000 }
	}
}

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 1, "HasPower" )
	self:NetworkVar( "Bool", 2, "IsOn" )
	self:NetworkVar( "Bool", 3, "IsMining" )
	self:NetworkVar( "Float", 1, "BitcoinAmount" )
	self:NetworkVar( "Int", 1, "CPUUpgrade" )
	self:NetworkVar( "Int", 2, "CoreUpgrade" )
	self:NetworkVar( "Float", 3, "ClockSpeed" )
	self:NetworkVar( "Int", 4, "CoreCount" )
	--A string table of all the updates that have been purchased.
	self:NetworkVar( "String", 1, "Updates" )
	self:NetworkVar( "Entity", 0, "owning_ent" )
end
--PATH addons/_bitminers2ex/lua/entities/bm2_extra_fuel_line/cl_init.lua:
include( "shared.lua" )
function ENT:Draw()
	self:DrawModel()
end
--PATH addons/_bitminers2ex/lua/entities/bm2_extra_fuel_otherend/shared.lua:
ENT.Type = "anim"
ENT.Base = "bm2_base"
ENT.PrintName = "Fuel Tank Line End"
ENT.Spawnable = false
ENT.Category = "Bitminers"
--PATH addons/_bitminers2ex/lua/entities/bm2_solar_cable/cl_init.lua:
include( "shared.lua" )
function ENT:Draw()
	self:DrawModel()
end
--PATH addons/_bitminers2ex/lua/entities/bm2_solarconverter/cl_init.lua:
include( "shared.lua" )
local solarMaterial = onyx.wimg.Simple( "https://i.imgur.com/9xL9KtB.png", "noclamp smooth" )
local outputMaterial = onyx.wimg.Simple( "https://i.imgur.com/CQKnDbD.png", "noclamp smooth" )
local warningMaterial = onyx.wimg.Simple( "https://i.imgur.com/bzOFQpr.png", "noclamp smooth" )
function ENT:DrawPowerWarning()
	--Draw the warning
	warningMaterial( -80, -300, 160, 160 )
	draw.SimpleText( "Can't Outout enough power!", onyx.FontNoScale( "Comfortaa", 40 ), 0, -110, color_black, 1, 1 )
	draw.SimpleText( "Can't Outout enough power!", onyx.FontNoScale( "Comfortaa", 40 ), -1, -111, color_white, 1, 1 )
	draw.SimpleText( "Connect more solar panels or disconnect some bitminers!", onyx.FontNoScale( "Comfortaa", 40 ), 0, -75, color_black, 1, 1 )
	draw.SimpleText( "Connect more solar panels or disconnect some bitminers!", onyx.FontNoScale( "Comfortaa", 40 ), -1, -76, color_white, 1, 1 )
end

function ENT:DrawSolarWarning()
	warningMaterial( -80, -60, 160, 160 )
	draw.SimpleText( "No connected solar panels!", onyx.FontNoScale( "Comfortaa", 40 ), 0, 170, color_black, 1, 1 )
	draw.SimpleText( "No connected solar panels!", onyx.FontNoScale( "Comfortaa", 40 ), -1, 171, color_white, 1, 1 )
	draw.SimpleText( "Please connect some solar panels.", onyx.FontNoScale( "Comfortaa", 40 ), 0, 170 - 35, color_black, 1, 1 )
	draw.SimpleText( "Please connect some solar panels.", onyx.FontNoScale( "Comfortaa", 40 ), -1, 170 - 34, color_white, 1, 1 )
end

function ENT:DrawPowerUsed( amountUsed, maximum, color, alpha )
	outputMaterial( -196, 74, 56, 56, Color( 255, 165, 0, 255 * alpha ) )
	draw.RoundedBox( 4, -130, 74, 330, 52, Color( 36, 36, 36, 255 * alpha ) )
	draw.RoundedBox( 2, -128, 76, 326, 52 - 4, Color( 15, 15, 15, 255 * alpha ) )
	draw.RoundedBox( 2, -128, 76, 326 * math.Clamp( maximum > 0 and amountUsed / maximum or 0, 0.0, 1.0 ), 52 - 4, color )
	draw.SimpleText( amountUsed .. "/" .. maximum .. "W", onyx.FontNoScale( "Comfortaa", 40 ), 45, 24 + 76, Color( 0, 0, 0, 255 * alpha ), 1, 1 )
	draw.SimpleText( amountUsed .. "/" .. maximum .. "W", onyx.FontNoScale( "Comfortaa", 40 ), 44, 24 + 75, Color( 255, 255, 255, 255 * alpha ), 1, 1 )
end

function ENT:DrawConnectedSolarPanels( alpha )
	solarMaterial( -200 + 4, 4, 56, 56, Color( 255, 165, 0, 255 * alpha ) )
	draw.RoundedBox( 4, -130, 4, 330, 52, Color( 36, 36, 36, 255 * alpha ) )
	draw.RoundedBox( 2, -128, 6, 326, 52 - 4, Color( 15, 15, 15, 255 * alpha ) )
	draw.RoundedBox( 2, -128, 6, 326 * self:GetConnectedPanels() / 10, 52 - 4, Color( 255, 165, 0, 255 * alpha ) )
	draw.SimpleText( self:GetConnectedPanels() .. "/10", onyx.FontNoScale( "Comfortaa", 40 ), 45, 24 + 6, Color( 0, 0, 0, 255 * alpha ), 1, 1 )
	draw.SimpleText( self:GetConnectedPanels() .. "/10", onyx.FontNoScale( "Comfortaa", 40 ), 44, 24 + 5, Color( 255, 255, 255, 255 * alpha ), 1, 1 )
end

function ENT:DrawTranslucent()
	self:DrawModel()
	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 350 * 350 then
		self.cam2d3dAng = LerpAngle( 7 * FrameTime(), self.cam2d3dAng ~= nil and self.cam2d3dAng or Angle( 0, 0, 0 ), Angle( 0, LocalPlayer():GetAngles().y - 90, 90 ) )
		--Cam 2D3D for drawing infomation
		local pos = self:GetPos() + Vector( 0, 0, 35 )
		local alpha = 1 - math.Clamp( LocalPlayer():GetPos():DistToSqr( self:GetPos() ) / ( 350 * 350 ) * 1.21, 0, 1 )
		cam.Start3D2D( pos, self.cam2d3dAng, 0.05 )
		if not self:GetShowNoConnectedSolarWarning() then
			draw.RoundedBox( 8, -200, -10, 410, 75 * 2, Color( 0, 0, 0, 100 * alpha ) )
			self:DrawConnectedSolarPanels( alpha )
			local powerUsed = self:GetPowerConsumpsion()
			local powerAvailable = self:GetMaxPowerConsumpsion()
			local color = powerUsed > powerAvailable and Color( 255, 40, 20, 255 * alpha ) or Color( 255, 165, 0, 255 * alpha )
			self:DrawPowerUsed( powerUsed, powerAvailable, color, alpha )
			if powerUsed > powerAvailable then self:DrawPowerWarning() end
		else
			self:DrawSolarWarning()
		end

		cam.End3D2D()
	end
end
--PATH addons/_doctor/lua/entities/bp_guide_book/shared.lua:
ENT.Type = "anim"
ENT.Base = "bp_base"

ENT.PrintName = "Guide Book"
ENT.Spawnable = true
ENT.Category = "Blue's Pharmaceuticals"

ENT.RenderGroup = RENDERGROUP_BOTH

--PATH addons/____bricks_gangs/lua/entities/bricks_server_territory/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
 
ENT.PrintName		= "Territory"
ENT.Category		= "Bricks Server"
ENT.Author			= "Brick Wall"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable		= false

function ENT:SetupDataTables()
    self:NetworkVar( "Int", 0, "TerritoryKey" )
    self:NetworkVar( "Int", 1, "CaptureEndTime" )
    self:NetworkVar( "Int", 2, "UnCaptureEndTime" )
    self:NetworkVar( "Entity", 0, "Captor" )
end
--PATH addons/_ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )
--------------------- BALLISTIC SHIELDS V1.1.9 -------------------------
---- CONFIG ----
-- AVALAIBLE LANGUAGES - English, German, French, Danish, Turkish, Ukrainian
bshields.config.language = "Ukrainian"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 10
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 10
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 50
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 20
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 30
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 1
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = true
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false
-- REMOVE DEPLOYED SHIELDS ON JOB CHANGE
bshields.config.removeonjobchange = true
-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---
-- HEAVY SHIELD
bshields.config.hShieldTexture = ""
-- RIOT SHIELD
bshields.config.rShieldTexture = ""
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = ""
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---
-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = false
--PATH gamemodes/darkrp/entities/entities/cook_vendin_machine/cl_init.lua:
include("Shared.lua")

function ENT:Draw()
	self:DrawModel()
end  

net.Receive('rp.CookMenuVending',function(len,ply)

		local pl = net.ReadEntity()
		local ent = net.ReadEntity()

	if (pl:GetPos():Distance( ent:GetPos() ) < 350) then
			local fr = vgui.Create('onyx.Frame')
				fr:SetSize(400,500)
				fr:MakePopup()
				fr:Center()

			local x,y = fr:GetSize()

			local al = vgui.Create( "DListView", fr )
				al:Dock( FILL )
				al:DockMargin(5,5,5,5)
				al:SetMultiSelect( false )
				al:AddColumn( "Назва" )
				al:AddColumn( "Ціна" )
		
				
				al:AddLine( 'Кавун', 500)
				al.OnRowSelected = function( lst, index, pnl )
					fr:SizeTo(600,500,0.5)
				end
	end
end)
--PATH addons/_drones/lua/entities/dronesrewrite_ardrone2/cl_init.lua:
include("shared.lua")
--PATH addons/_drones/lua/entities/dronesrewrite_bl_laser.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

if SERVER then
	function ENT:Initialize()
	    self:SetModel("models/dronesrewrite/lray/lray.mdl")
	    self:SetMoveType(MOVETYPE_VPHYSICS)
	    self:SetSolid(SOLID_VPHYSICS)
	    self:PhysicsInit(SOLID_VPHYSICS)

	    self:DrawShadow(false)
		self:SetColor(Color(255, 255, 255))

	    local phys = self:GetPhysicsObject()

	    phys:SetMass(1)
		phys:EnableDrag(false)
		phys:EnableGravity(false)	
	    phys:Wake()

	    self:SetCustomCollisionCheck(true)
	end

	function ENT:PhysicsUpdate(phys)
		if self.LastPhys == CurTime() then return end

		if self:WaterLevel() >= 3 then self:Remove() end

		phys:ApplyForceCenter(self:GetForward() * 100000)

		self.LastPhys = CurTime()
	end

	function ENT:PhysicsCollide(data, physobj)
		local ent = data.HitEntity
		if ent:IsValid() then
			local owner = self.Owner
			ent:TakeDamage(math.random(8,12), owner, owner)
			if ent.IS_DRR then ent:TakeDamage(math.random(15,30), owner, owner) end
		end

		local tr = util.TraceLine({
			start = self:GetPos(),
			endpos = self:GetPos() + self:GetForward() * 1024,
			filter = self,
			mask = MASK_SOLID_BRUSHONLY
		})

		ParticleEffect("elecray_hit_drr", self:GetPos(), Angle(0, 0, 0))

		util.Decal("FadingScorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)

		self:Remove()
	end
else
	function ENT:Draw()
		local dlight = DynamicLight(self:EntIndex())
		if dlight then
			dlight.pos = self:GetPos()
			dlight.r = 100
			dlight.g = 170
			dlight.b = 255
			dlight.brightness = 1
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 0.3
		end
		
		render.SetMaterial(Material("particle/particle_glow_04_additive"))

		local color = Color(100, 170, 255, 40)
		local xs = 32
		
		render.DrawSprite(self:GetPos() - self:GetForward() * 24, xs, xs, color)
		render.DrawSprite(self:GetPos() - self:GetForward() * 12, xs, xs, color)
		render.DrawSprite(self:GetPos(), xs, xs, color)
		render.DrawSprite(self:GetPos() + self:GetForward() * 12, xs, xs, color)
		render.DrawSprite(self:GetPos() + self:GetForward() * 24, xs, xs, color)

		self:DrawModel()
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_camera/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
//ENT.PrintName = "CAM 'Camera'"
ENT.PrintName = "Camera Drone"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "CAM"

ENT.Model = "models/dronesrewrite/cameradr/cameradr.mdl"

ENT.FirstPersonCam_pos = Vector(4.5, 0, -3.6)
ENT.ThirdPersonCam_distance = 30

ENT.DoExplosionEffect = "splode_drone_sparks"

ENT.AngOffset = 4
ENT.Alignment = 0.5

ENT.HealthAmount = 20
ENT.DefaultHealth = 20

ENT.Speed = 1500
ENT.SprintCoefficient = 1.7
ENT.RotateSpeed = 6

ENT.Fuel = 40
ENT.MaxFuel = 40

ENT.HUD_hudName = "Camera"
ENT.OverlayName = "No Overlay"

ENT.UseNightVision = false
ENT.UseFlashlight = false

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.AllowYawRestrictions = true

ENT.YawMin = -55
ENT.YawMax = 55

ENT.PitchMin = -15

ENT.Slots = {
	["Camera"] = 1
}

ENT.Sounds = {
	PropellerSound = {
		Name = "drones/ardr.wav",
		Pitch = 100,
		Level = 65,
		PitchCoef = 0.02,
		Volume = 0.17
	},
	ExplosionSound = {
		Name = "ambient/energy/spark3.wav",
		Level = 100,
		Pitch = 150
	}
}

ENT.Propellers = {
	Damage = 1,
	Health = 10,
	HitRange = 7,
	Model = "models/dronesrewrite/flower_propeller/flower_propeller.mdl",

	HitPitch = 255,
	HitLevel = 60,
	RandomHitSounds = { "physics/metal/metal_box_impact_bullet2.wav", "physics/metal/metal_box_impact_bullet2.wav", "physics/metal/metal_box_impact_bullet2.wav" },
	RandomLoseSounds = { "physics/glass/glass_cup_break1.wav", "physics/glass/glass_cup_break2.wav" },

	LosePitch = 255,
	LoseLevel = 65,

	Info = {
		Vector(6.4, 9.15, 1.5),
		Vector(-6.4, -9.15, 1.5),
		Vector(-6.4, 9.15, 1.5),
		Vector(6.4, -9.15, 1.5)
	}
}

ENT.Weapons = { ["Camera"] = { Name = "Camera" } }

ENT.Modules = DRONES_REWRITE.GetBaseModules()
DRONES_REWRITE.CopyModule(ENT.Modules, "Nightvision")
DRONES_REWRITE.CopyModule(ENT.Modules, "Flashlight")

--PATH addons/_drones/lua/entities/dronesrewrite_defender/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self.BaseClass.Draw(self)
	
	if self:IsDroneWorkable() then
		local pos = self:LocalToWorld(self.FirstPersonCam_pos)

		local dlight = DynamicLight(self:EntIndex())
		if dlight then
			dlight.pos = pos
			dlight.r = 255
			dlight.g = 255
			dlight.b = 255
			dlight.brightness = 1
			dlight.Decay = 1000
			dlight.Size = 80
			dlight.DieTime = CurTime() + 0.1
		end

		render.SetMaterial(Material("particle/particle_glow_04_additive"))
		render.DrawSprite(pos, 24, 24, Color(255, 255, 255, 64))
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_firestorm/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
//ENT.PrintName = "FRS 'Firestorm'"
ENT.PrintName = "Firestorm"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "FRS"
ENT.HUD_hudName = "White Box"

ENT.Weight = 350

ENT.Model = "models/dronesrewrite/flamethrower/flamethrowerdr.mdl"

ENT.FirstPersonCam_pos = Vector(28, 6.8, 6)
ENT.ThirdPersonCam_distance = 140
ENT.RenderCam = false

ENT.ExplosionForce = 16
ENT.ExplosionAngForce = 1.7

ENT.Alignment = 0 --1.6
ENT.AlignmentRoll = 0.5
ENT.AlignmentPitch = 1

ENT.NoiseCoefficient = 0
ENT.NoiseCoefficientPos = 15
ENT.NoiseCoefficientAng = 0.2
ENT.AngOffset = 3

ENT.HackValue = 3

ENT.Speed = 4500
ENT.UpSpeed = 24000
ENT.RotateSpeed = 6

ENT.PitchOffset = 0.7

ENT.AllowYawRestrictions = true
ENT.YawMin = -60
ENT.YawMax = 60

ENT.PitchMin = -30
ENT.PitchMax = 50

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.Fuel = 200
ENT.MaxFuel = 200
ENT.FuelReduction = 0.3

ENT.HealthAmount = 300
ENT.DefaultHealth = 300

ENT.Sounds = {
	PropellerSound = {
		Name = "npc/attack_helicopter/aheli_rotor_loop1.wav",
		Pitch = 120,
		Level = 72,
		Volume = 0.5
	},

	ExplosionSound = {
		Name = "ambient/explosions/explode_7.wav",
		Level = 80
	}
}


ENT.Propellers = {
	Damage = 1,
	Health = 50,
	HitRange = 19,
	Model = "models/dronesrewrite/propellers/propeller2_4.mdl",

	Info = {
		Vector(8, 41.5, 7),
		Vector(8, -41.5, 7),
	}
}

ENT.Attachments = {
	["Flamethrower"] = {
		Pos = Vector(-1, 0, -6)
	}
}

ENT.Weapons = {
	["Flamethrower"] = {
		Name = "Flamethrower",
		Attachment = "Flamethrower"
	}
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/_drones/lua/entities/dronesrewrite_fuelstation/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()

	local drone = self:GetNWEntity("DronesRewriteDrone")
	if drone:IsValid() then
		local ang = (self:GetPos() - LocalPlayer():GetPos()):Angle()
		ang.p = 0
		ang:RotateAroundAxis(ang:Up(), -90)
		ang:RotateAroundAxis(ang:Forward(), 90)

		cam.Start3D2D(self:GetPos() + vector_up * 15, ang, 0.1)
			surface.SetDrawColor(Color(0, 150, 255))
			surface.DrawOutlinedRect(-100, -30, 200, 70)
			local fuel = (drone:GetFuel() / drone.MaxFuel) * 200
			surface.DrawRect(-95, -25, fuel - 10, 60)

			draw.SimpleText("FUEL " .. math.floor(drone:GetFuel()) .. " / " .. drone.MaxFuel, "DronesRewrite_font1", 110, -5, nil, TEXT_ALIGN_LEFT)

			if drone:GetFuel() < drone.MaxFuel then 
				draw.SimpleText("REFUELING...", "DronesRewrite_font1", 110, -35, nil, TEXT_ALIGN_LEFT) 
			else 
				draw.SimpleText("FULL", "DronesRewrite_font1", 110, -35, nil, TEXT_ALIGN_LEFT) 
			end

			draw.SimpleText("To stop refueling move your drone away", "DronesRewrite_font4", 110, 35, nil, TEXT_ALIGN_LEFT)
		cam.End3D2D()
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_gr_laser.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

if SERVER then
	function ENT:Initialize()
	    self:SetModel("models/dronesrewrite/lray/lray.mdl")
	    self:SetMoveType(MOVETYPE_VPHYSICS)
	    self:SetSolid(SOLID_VPHYSICS)
	    self:PhysicsInit(SOLID_VPHYSICS)

	    self:DrawShadow(false)
		self:SetColor(Color(255, 255, 255))

	    local phys = self:GetPhysicsObject()

	    phys:SetMass(1)
		phys:EnableDrag(false)
		phys:EnableGravity(false)	
	    phys:Wake()

		self:SetCustomCollisionCheck(true)
	end

	function ENT:PhysicsUpdate(phys)
		if self.LastPhys == CurTime() then return end

		if self:WaterLevel() >= 3 then self:Remove() end

		phys:ApplyForceCenter(self:GetForward() * 100000)

		self.LastPhys = CurTime()
	end

	function ENT:PhysicsCollide(data, physobj)
		local ent = data.HitEntity
		if ent:IsValid() then
			local owner = self.Owner
			ent:TakeDamage(math.random(12,15), owner, owner)
			ent:Ignite(0.7,1)
		end

		local tr = util.TraceLine({
			start = self:GetPos(),
			endpos = self:GetPos() + self:GetForward() * 1024,
			filter = self,
			mask = MASK_SOLID_BRUSHONLY
		})

		ParticleEffect("sparks_rdbl", self:GetPos(), Angle(0, 0, 0))

		util.Decal("FadingScorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)

		self:Remove()
	end
else
	function ENT:Draw()
		local dlight = DynamicLight(self:EntIndex())
		if dlight then
			dlight.pos = self:GetPos()
			dlight.r = 0
			dlight.g = 255
			dlight.b = 0
			dlight.brightness = 1
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 0.3
		end	

		render.SetMaterial(Material("particle/particle_glow_04_additive"))

		local color = Color(0, 255, 0, 32)
		local xs = 32
		
		render.DrawSprite(self:GetPos() - self:GetForward() * 24, xs, xs, color)
		render.DrawSprite(self:GetPos() - self:GetForward() * 12, xs, xs, color)
		render.DrawSprite(self:GetPos(), xs, xs, color)
		render.DrawSprite(self:GetPos() + self:GetForward() * 12, xs, xs, color)
		render.DrawSprite(self:GetPos() + self:GetForward() * 24, xs, xs, color)
		
		self:DrawModel()
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_nanodr/cl_init.lua:
include("shared.lua")

--PATH addons/_drones/lua/entities/dronesrewrite_skyartillery/cl_init.lua:
include("shared.lua")
--PATH addons/_drones/lua/entities/dronesrewrite_supply/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "Supply Drone"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "SUPP"
ENT.HUD_hudName = "Drones 1"

ENT.Weight = 250

ENT.Model = "models/dronesrewrite/supplydr/supplydrone.mdl"

ENT.FirstPersonCam_pos = Vector(25, -1.5, 3.5)
ENT.RenderCam = false

ENT.ExplosionForce = 228
ENT.ExplosionAngForce = 228

ENT.Alignment = 1.3

ENT.NoiseCoefficient = 0
ENT.AngOffset = 3

ENT.HackValue = 5

ENT.Speed = 2000
ENT.UpSpeed = 6000
ENT.RotateSpeed = 3
ENT.SprintCoefficient = 2

ENT.AngOffsetVel = 1

ENT.PitchOffset = 0.015

ENT.AllowPitchRestrictions = false
ENT.AllowYawRestrictions = true
ENT.YawMin = -60
ENT.YawMax = 60

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.HealthAmount = 400
ENT.DefaultHealth = 400

ENT.AutomaticFrameAdvance = true

ENT.Sounds = {
	ExplosionSound = {
		Name = "ambient/explosions/explode_7.wav",
		Level = 82
	}
}

ENT.NoPropellers = true
ENT.Propellers = {
	Model = "models/props_junk/PopCan01a.mdl",
	Info = { Vector(0, 0, 0) }
}

ENT.Fuel = 250
ENT.MaxFuel = 250

ENT.UseFlashlight = false

ENT.Weapons = { }

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/__main/lua/entities/durgz_aspirin/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.PrintName = "Aspirin"
ENT.Nicknames = {"too many pills", "too many painkillers", "too much aspirin"}
ENT.OverdosePhrase = {"took", "consumed", "gulped down"}
ENT.Author = "The Man"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Information	 = "Gets rid of headaches" 
ENT.Category = "Drugs"
--PATH addons/__main/lua/entities/durgz_cigarette/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.PrintName = "Cigarette"
ENT.Category = "Drugs"
ENT.Nicknames = {"wimpy cigars", "cigarettes"}
ENT.OverdosePhrase = {"got cancer from"}
ENT.Author = "John Siler"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Information	 = "This stuff makes you look badass." 

ENT.TRANSITION_TIME = 4

--function for high visuals

if(CLIENT)then

	local TRANSITION_TIME = ENT.TRANSITION_TIME; --transition effect from sober to high, high to sober, in seconds how long it will take etc.
	

	local function DoCigarette()
		if(!DURGZ_LOST_VIRGINITY)then return; end
		local pl = LocalPlayer();
		
		
		
		if( pl:GetNWFloat("durgz_cigarette_high_start") && pl:GetNWFloat("durgz_cigarette_high_end") > CurTime() )then
			
			local pf = 1;
			
			
			if( pl:GetNWFloat("durgz_cigarette_high_start") + TRANSITION_TIME > CurTime() )then
			
				local s = pl:GetNWFloat("durgz_cigarette_high_start");
				local e = s + TRANSITION_TIME;
				local c = CurTime();
				pf = (c-s) / (e-s);
			elseif( pl:GetNWFloat("durgz_cigarette_high_end") - TRANSITION_TIME < CurTime() )then
			
				local e = pl:GetNWFloat("durgz_cigarette_high_end");
				local s = e - TRANSITION_TIME;
				local c = CurTime();
				pf = 1 - (c-s) / (e-s);
			end
			
			local a = pf*255;
			local say = "You smoke. Therefore you are cool."
			draw.DrawText(say, DURGZ_HUD_FONT, ScrW() * 0.5+1 , ScrH()*0.6+1, Color(255,255,255,a),TEXT_ALIGN_CENTER) 
			draw.DrawText(say, DURGZ_HUD_FONT, ScrW() * 0.5-1 , ScrH()*0.6-1, Color(255,255,255,a),TEXT_ALIGN_CENTER) 
			draw.DrawText(say, DURGZ_HUD_FONT, ScrW() * 0.5-1 , ScrH()*0.6+1, Color(255,255,255,a),TEXT_ALIGN_CENTER) 
			draw.DrawText(say, DURGZ_HUD_FONT, ScrW() * 0.5+1 , ScrH()*0.6-1, Color(255,255,255,a),TEXT_ALIGN_CENTER) 
			draw.DrawText(say, DURGZ_HUD_FONT, ScrW() * 0.5 , ScrH()*0.6, Color(255,9,9,255),TEXT_ALIGN_CENTER) 
		end
	end
	hook.Add("HUDPaint", "durgz_cigarette_msg", DoCigarette)
	
	
	
	local TRANSITION_TIME = ENT.TRANSITION_TIME; --transition effect from sober to high, high to sober, in seconds how long it will take etc.
	
	local function DoCigarettePP()
		if(!DURGZ_LOST_VIRGINITY)then return; end
		--self:SetNWFloat( "SprintSpeed"
		local pl = LocalPlayer();
		
		
		
		if( pl:GetNWFloat("durgz_cigarette_high_start") && pl:GetNWFloat("durgz_cigarette_high_end") > CurTime() )then
		
			if( pl:GetNWFloat("durgz_cigarette_high_start") + TRANSITION_TIME > CurTime() )then
			
				local s = pl:GetNWFloat("durgz_cigarette_high_start");
				local e = s + TRANSITION_TIME;
				local c = CurTime();
				local pf = (c-s) / (e-s);
				
				//DrawBloom( 0.65, pf*5, 0.40, 0.40, 1, 1, 255, 255, 255 )
				DrawSharpen(pf,1)
				
			elseif( pl:GetNWFloat("durgz_cigarette_high_end") - TRANSITION_TIME < CurTime() )then
			
				local e = pl:GetNWFloat("durgz_cigarette_high_end");
				local s = e - TRANSITION_TIME;
				local c = CurTime();
				local pf = 1 - (c-s) / (e-s);
				
				//DrawBloom( 0.65, pf*5, 0.40, 0.40, 1, 1, 255, 255, 255 )
				DrawSharpen(pf,1)
				
			else
				
				//DrawBloom(0.65, 5, 0.40, 0.40, 1, 1, 255,255,255)
				DrawSharpen(1,1)
				
			end
			
			
		end
	end
	hook.Add("RenderScreenspaceEffects", "durgz_cigarette_high", DoCigarettePP)
	
end

--PATH addons/_eml/lua/entities/eml_buyer/cl_init.lua:
include("shared.lua")
ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Draw()
	self:DrawModel();
end;

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:BuildBonePositions( NumBones, NumPhysBones )
end
 
function ENT:SetRagdollBones( bIn )
	self.m_bRagdollSetup = bIn
end

function ENT:DoRagdollBone( PhysBoneNum, BoneNum )
--self:SetBonePosition( BoneNum, Pos, Angle )
end

--[[
size = 128;
draw_set_blend_mode(bm_subtract);
surface_set_target(light);
draw_ellipse_color(x-(size*0.5)-view_xview,y-(size*0.5)-view_yview,x+(size*0.5)-view_xview,y+(size*0.5)-view_yview, c_white, c_black, false);

surface_reset_target();
draw_set_blend_mode(bm_normal);
]]--
--PATH addons/_eml/lua/entities/eml_ciodine/shared.lua:
ENT.Base = "base_anim";
ENT.Type = "anim";

ENT.PrintName		= "Кристалічний йод";
ENT.Category 		= "EML";
ENT.Author			= "EnnX49";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

--PATH addons/_eml/lua/entities/eml_macid/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFont", {
	font = "Arial",
	size = 30,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	

end;

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ang = self:GetAngles()

	local macidColor = EML_MuriaticAcid_Color;
	
	if (self:GetNWInt("amount")>0) then
		macidColor = EML_MuriaticAcid_Color;
	else
		macidColor = Color(100, 100, 100, 255);
	end;
	
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < self:GetNWInt("distance") then
		cam.Start3D2D(pos+ang:Up()*4.8, ang, 0.1)
			draw.SimpleTextOutlined("Соляна", "methFont", 0, 0, macidColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined("Кислота", "methFont", 0, 24, macidColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined(""..self:GetNWInt("amount").."Л", "methFont", 0, 48, macidColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
		cam.End3D2D();

	ang:RotateAroundAxis(ang:Up(), 0);
	ang:RotateAroundAxis(ang:Forward(), -90);
	ang:RotateAroundAxis(ang:Right(), 90);		
		cam.Start3D2D(pos+ang:Up()*5, ang, 0.1)
			surface.SetDrawColor(0, 0, 0, 200);
			surface.DrawRect(-100, -8, 128, 16);
			
			surface.SetDrawColor(EML_MuriaticAcid_Color);
			surface.DrawRect(-98, -6, math.Round((self:GetNWInt("amount")*124)/self:GetNWInt("maxAmount")), 12);				
		cam.End3D2D();
	end;
		
end;
--PATH addons/_eml/lua/entities/eml_sulfur/shared.lua:
ENT.Base = "base_anim";
ENT.Type = "anim";

ENT.PrintName		= "Рідка Сірка";
ENT.Category 		= "EML";
ENT.Author			= "EnnX49";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

--PATH gamemodes/darkrp/entities/entities/gmod_button.lua:
AddCSLuaFile()
local BaseClass = baseclass.Get("base_anim")

function ENT:SetupDataTables()
	self:NetworkVar("Int",		0,	"Key")
	self:NetworkVar("Bool",	0,	"On")

	self:SetOn(false)
	self.Toggled = false
end

function ENT:Initialize()
	if (SERVER) then
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_WORLD)
		self:SetUseType(ONOFF_USE)

	else
		self.PosePosition = 0
	end
end
-- 4327 
function ENT:Use(activator, caller, type, value)
	if (!activator:IsPlayer()) then return end		-- Who the frig is pressing this shit!?

	if (self.Toggled) then
		if (type == USE_ON) then
			self:Toggle(!self:GetOn(), activator)
		end
		return
	end

	if (IsValid(self.LastUser)) then return end		-- Someone is already using this button

	if (self:GetOn()) then
		self:Toggle(false, activator)
		return
	end

	self:Toggle(true, activator)
	self:NextThink(CurTime())
	self.LastUser = activator

end

function ENT:Think()
	if (CLIENT) then
		self:UpdateLever()
	end

	if (SERVER && self:GetOn() && !self.Toggled) then
		if (!IsValid(self.LastUser ) || !self.LastUser:KeyDown(IN_USE)) then
			self:Toggle(false, self.LastUser)
			self.LastUser = nil
		end

		self:NextThink(CurTime())
	end
end

function ENT:Toggle(bEnable, ply)
	local pl = self:CPPIGetOwner()
	pl.UsingKeypad = true

	if (bEnable) then
		numpad.Activate(pl, self:GetKey(), true)
		self:SetOn(true)
	else
		numpad.Deactivate(pl, self:GetKey(), true)
		self:SetOn(false)
	end

	pl.UsingKeypad = false
end

function ENT:UpdateLever()
	local TargetPos = 0.0
	if (self:GetOn()) then TargetPos = 1.0 end

	self.PosePosition = math.Approach(self.PosePosition, TargetPos, FrameTime() * 5.0)

	self:SetPoseParameter("switch", self.PosePosition)
	self:InvalidateBoneCache()
end

function ENT:Draw()
	self:DrawModel()
end
--PATH addons/_drones/lua/entities/item_drr_pistol.lua:
AddCSLuaFile()

ENT.Base = "item_drr_ammobase"
ENT.Type = "anim"
ENT.PrintName = "Pistol Ammo"
ENT.Category = "Drones Rewrite Ammo"
ENT.Spawnable = true
ENT.AdminSpaawnable = true

ENT.Amount = 800
ENT.Model = "models/dronesrewrite/ammobox/ammobox.mdl"
ENT.Material = "models/dronesrewrite/ammunition/ammo_def"

--PATH addons/____inventory/lua/entities/itemstore_box_large.lua:
ENT.Type = "anim"
ENT.Base = "itemstore_box"

ENT.PrintName = "Large Box"
ENT.Category = "ItemStore"

ENT.Spawnable = true
ENT.AdminOnly = true

if SERVER then
	AddCSLuaFile()

	ENT.Model = "models/props/cs_office/cardboard_box01.mdl"

	ENT.ContainerWidth = 5
	ENT.ContainerHeight = 4
	ENT.ContainerPages = 1
end

--PATH addons/lvs_base-main/lua/entities/lvs_base_doorhandler.lua:
AddCSLuaFile()

ENT.Type            = "anim"
ENT.DoNotDuplicate = true

ENT.RenderGroup = RENDERGROUP_BOTH 

ENT.UseRange = 75

ENT._UseTargetAllowed = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )

	self:NetworkVar( "Bool",0, "Active" )

	self:NetworkVar( "String",0, "PoseName" )

	self:NetworkVar( "Vector",0, "Mins" )
	self:NetworkVar( "Vector",1, "Maxs" )

	self:NetworkVar( "Float",0, "Rate" )
	self:NetworkVar( "Float",1, "RateExponent" )

	self:NetworkVar( "Float",2, "PoseMin" )
	self:NetworkVar( "Float",3, "PoseMax" )

	if SERVER then
		self:SetRate( 10 )
		self:SetRateExponent( 2 )

		self:SetPoseMax( 1 )
	end
end

function ENT:IsServerSide()
	local EntTable = self:GetTable()

	if isbool( EntTable._IsServerSide ) then return EntTable._IsServerSide end

	local PoseName = self:GetPoseName()

	if PoseName == "" then return false end

	local IsServerSide = string.StartsWith( PoseName, "^" )

	EntTable._IsServerSide = IsServerSide

	return IsServerSide
end

function ENT:IsOpen()
	return self:GetActive()
end

function ENT:InRange( ply, Range )
	local boxOrigin = self:GetPos()
	local boxAngles = self:GetAngles()
	local boxMins = self:GetMins()
	local boxMaxs = self:GetMaxs()

	local HitPos, _, _ = util.IntersectRayWithOBB( ply:GetShootPos(), ply:GetAimVector() * Range, boxOrigin, boxAngles, boxMins, boxMaxs )

	return isvector( HitPos )
end

if SERVER then
	AccessorFunc(ENT, "soundopen", "SoundOpen", FORCE_STRING)
	AccessorFunc(ENT, "soundclose", "SoundClose", FORCE_STRING)

	AccessorFunc(ENT, "maxsopen", "MaxsOpen", FORCE_VECTOR)
	AccessorFunc(ENT, "minsopen", "MinsOpen", FORCE_VECTOR)

	AccessorFunc(ENT, "maxsclosed", "MaxsClosed", FORCE_VECTOR)
	AccessorFunc(ENT, "minsclosed", "MinsClosed", FORCE_VECTOR)


	util.AddNetworkString( "lvs_doorhandler_interact" )

	net.Receive( "lvs_doorhandler_interact", function( length, ply )
		if not IsValid( ply ) then return end

		local ent = net.ReadEntity()

		if not IsValid( ent ) or not ent._UseTargetAllowed or not ent.UseRange or ply:InVehicle() then return end

		local Range = ent.UseRange * 2

		if (ply:GetPos() - ent:GetPos()):Length() > Range then return end

		if not ent:InRange( ply, Range ) then return end

		ent:Use( ply, ply )
	end)

	function ENT:LinkToSeat( ent )
		if not IsValid( ent ) or not ent:IsVehicle() then

			ErrorNoHalt( "[LVS] Couldn't link seat to doorsystem. Entity expected, got "..tostring( ent ).."\n" )

			return
		end

		self._LinkedSeat = ent
	end

	function ENT:GetLinkedSeat()
		return self._LinkedSeat
	end

	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:SetUseType( SIMPLE_USE )
		self:DrawShadow( false )
		debugoverlay.Cross( self:GetPos(), 15, 5, Color( 255, 223, 127 ) )
	end

	function ENT:Use( ply )
		if not IsValid( ply ) then return end

		local Base = self:GetBase()

		if not IsValid( Base ) then return end

		if not Base:IsUseAllowed( ply ) then return end

		if self:IsOpen() then
			self:Close( ply )
		else
			self:Open( ply )
		end
	end

	function ENT:OnOpen( ply )
	end

	function ENT:OnClosed( ply )
	end

	function ENT:OpenAndClose( ply )
		self:Open( ply )

		self._PreventClosing = true

		timer.Simple(0.5, function()
			if not IsValid( self ) then return end

			self:Close( ply )

			self._PreventClosing = false
		end )
	end

	function ENT:DisableOnBodyGroup( group, subgroup )
		self._BodyGroupDisable = group
		self._BodySubGroupDisable = subgroup
	end

	function ENT:IsBodyGroupDisabled()
		if not self._BodyGroupDisable or not self._BodySubGroupDisable then return false end

		local base = self:GetBase()

		if not IsValid( base ) then return false end

		return base:GetBodygroup( self._BodyGroupDisable ) == self._BodySubGroupDisable
	end

	function ENT:Open( ply )
		if self:IsOpen() then return end

		self:SetActive( true )
		self:SetMins( self:GetMinsOpen() )
		self:SetMaxs( self:GetMaxsOpen() )

		if self:IsBodyGroupDisabled() then return end

		self:OnOpen( ply )

		local snd = self:GetSoundOpen()

		if not snd then return end

		self:EmitSound( snd )
	end

	function ENT:Close( ply )
		if not self:IsOpen() then
			if self:IsBodyGroupDisabled() then
				self:Open( ply )
			end

			return
		end

		if self:IsBodyGroupDisabled() then return end

		self:SetActive( false )
		self:SetMins( self:GetMinsClosed() )
		self:SetMaxs( self:GetMaxsClosed() )

		self:OnClosed( ply )

		local snd = self:GetSoundClose()

		if not snd then return end

		self:EmitSound( snd )
	end

	function ENT:OnDriverChanged( oldDriver, newDriver, pod )
		if self._PreventClosing then return end

		if IsValid( newDriver ) then
			if self:IsOpen() then
				self:Close( newDriver )
			end
		else
			timer.Simple( FrameTime() * 2, function()
				if not IsValid( self ) or not IsValid( oldDriver ) or IsValid( self._Driver ) then return end

				if oldDriver:lvsGetVehicle() == self:GetBase() then return end

				if not self:IsOpen() then
					self:OpenAndClose()
				end
			end )
		end
	end

	function ENT:SetPoseParameterSV()
		local Base = self:GetBase()

		if not IsValid( Base ) then return end

		local Target = self:GetActive() and self:GetPoseMax() or self:GetPoseMin()
		local poseName = self:GetPoseName()

		if poseName == "" then return end

		local EntTable = self:GetTable()

		EntTable.sm_pp = EntTable.sm_pp and EntTable.sm_pp + (Target - EntTable.sm_pp) * FrameTime() * self:GetRate() or 0

		local value = EntTable.sm_pp ^ self:GetRateExponent()

		Base:SetPoseParameter( string.Replace(poseName, "^", ""), value )
	end

	function ENT:Think()
		if IsValid( self._LinkedSeat ) then
			local Driver = self._LinkedSeat:GetDriver()
	
			if self._Driver ~= Driver then
			
				self:OnDriverChanged( self._Driver, Driver, self._LinkedSeat )

				self._Driver = Driver
			end
		end

		if self:IsServerSide() then
			self:SetPoseParameterSV()

			self:NextThink( CurTime() )
		else
			self:NextThink( CurTime() + 0.25 )
		end

		return true
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	return
end

function ENT:Initialize()
end

function ENT:Think()
	if self:IsServerSide() then return end

	local Base = self:GetBase()

	if not IsValid( Base ) then return end

	local Target = self:GetActive() and self:GetPoseMax() or self:GetPoseMin()
	local poseName = self:GetPoseName()

	if poseName == "" then return end

	local EntTable = self:GetTable()

	EntTable.sm_pp = EntTable.sm_pp and EntTable.sm_pp + (Target - EntTable.sm_pp) * RealFrameTime() * self:GetRate() or 0

	local value = EntTable.sm_pp ^ self:GetRateExponent()

	if string.StartsWith( poseName, "!" ) then
		Base:SetBonePoseParameter( poseName, value )
	else
		Base:SetPoseParameter( poseName, value )
	end
end

function ENT:OnRemove()
end

function ENT:Draw()
end

local LVS = LVS
ENT.ColorSelect = Color(127,255,127,150)
ENT.ColorNormal = Color(255,0,0,150)
ENT.ColorTransBlack = Color(0,0,0,150)
ENT.OutlineThickness = Vector(0.5,0.5,0.5)

function ENT:DrawTranslucent()
	local ply = LocalPlayer()

	if not IsValid( ply ) or ply:InVehicle() or not ply:KeyDown( IN_SPEED ) then return end

	local InRange = self:InRange( ply, self.UseRange )

	if InRange then
		local EntTable = self:GetTable()

		local Use = ply:KeyDown( IN_USE )

		if EntTable.old_Use ~= Use then
			EntTable.old_Use = Use

			if Use then
				net.Start( "lvs_doorhandler_interact" )
					net.WriteEntity( self )
				net.SendToServer()
			end
		end
	end

	if not LVS.DeveloperEnabled then return end

	local boxOrigin = self:GetPos()
	local boxAngles = self:GetAngles()
	local boxMins = self:GetMins()
	local boxMaxs = self:GetMaxs()

	local EntTable = self:GetTable()

	local Col = InRange and EntTable.ColorSelect or EntTable.ColorNormal

	render.SetColorMaterial()
	render.DrawBox( boxOrigin, boxAngles, boxMins, boxMaxs, Col )
	render.DrawBox( boxOrigin, boxAngles, boxMaxs + EntTable.OutlineThickness, boxMins - EntTable.OutlineThickness, EntTable.ColorTransBlack )
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_base_wheeldrive/sh_camera_eyetrace.lua:

function ENT:GetEyeTrace( trace_forward )
	local startpos = self:LocalToWorld( self:OBBCenter() )

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( pod:OBBCenter() )
	end

	local AimVector = trace_forward and self:GetForward() or self:GetAimVector()

	local data = {
		start = startpos,
		endpos = (startpos + AimVector * 50000),
		filter = self:GetCrosshairFilterEnts(),
	}

	local trace = util.TraceLine( data )

	return trace
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local pod = self:GetDriverSeat()

	if not IsValid( pod ) then return self:GetForward() end

	local Driver = self:GetDriver()

	if not IsValid( Driver ) then return pod:GetForward() end

	if Driver:lvsMouseAim() then
		if SERVER then
			return pod:WorldToLocalAngles( Driver:EyeAngles() ):Forward()
		else
			return Driver:EyeAngles():Forward()
		end
	else
		if SERVER then
			return Driver:EyeAngles():Forward()
		else
			return pod:LocalToWorldAngles( Driver:EyeAngles() ):Forward()
		end
	end
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_base_wheeldrive/cl_tiresounds.lua:

ENT.TireSoundFade = 0.15
ENT.TireSoundTypes = {
	["roll"] = "lvs/vehicles/generic/wheel_roll.wav",
	["roll_dirt"] = "lvs/vehicles/generic/wheel_roll_dirt.wav",
	["roll_wet"] = "lvs/vehicles/generic/wheel_roll_wet.wav",
	["roll_damaged"] = "lvs/wheel_damaged_loop.wav",
	["skid"] = "lvs/vehicles/generic/wheel_skid.wav",
	["skid_dirt"] = "lvs/vehicles/generic/wheel_skid_dirt.wav",
	["skid_wet"] = "lvs/vehicles/generic/wheel_skid_wet.wav",
	["tire_damage_layer"] = "lvs/wheel_destroyed_loop.wav",
}
ENT.TireSoundLevelSkid = 85
ENT.TireSoundLevelRoll = 75

function ENT:TireSoundRemove()
	for snd, _ in pairs( self.TireSoundTypes ) do
		self:StopTireSound( snd )
	end
end

function ENT:TireSoundThink()
	for snd, _ in pairs( self.TireSoundTypes ) do
		local T = self:GetTireSoundTime( snd )

		if T > 0 then
			local speed = self:GetVelocity():Length()

			local sound = self:StartTireSound( snd )

			if string.StartsWith( snd, "skid" ) or snd == "tire_damage_layer" then
				local vel = speed
				speed = math.max( math.abs( self:GetWheelVelocity() ) - vel, 0 ) * 5 + vel
			end

			local volume = math.min(speed / 1000,1) ^ 2 * T
			local pitch = 100 + math.Clamp((speed - 400) / 200,0,155)

			sound:ChangeVolume( volume, 0 )
			sound:ChangePitch( pitch, 0.5 ) 
		else
			self:StopTireSound( snd )
		end
	end
end

function ENT:DoTireSound( snd )
	if not istable( self._TireSounds ) then
		self._TireSounds = {}
	end

	self._TireSounds[ snd ] = CurTime() + self.TireSoundFade
end

function ENT:GetTireSoundTime( snd )
	if not istable( self._TireSounds ) or not self._TireSounds[ snd ] then return 0 end

	return math.max(self._TireSounds[ snd ] - CurTime(),0) / self.TireSoundFade
end

function ENT:StartTireSound( snd )
	if not self.TireSoundTypes[ snd ] or not istable( self._ActiveTireSounds ) then
		self._ActiveTireSounds = {}
	end

	if self._ActiveTireSounds[ snd ] then return self._ActiveTireSounds[ snd ] end

	local sound = CreateSound( self, self.TireSoundTypes[ snd ]  )
	sound:SetSoundLevel( string.StartsWith( snd, "skid" ) and self.TireSoundLevelSkid or self.TireSoundLevelRoll )
	sound:PlayEx(0,100)

	self._ActiveTireSounds[ snd ] = sound

	return sound
end

function ENT:StopTireSound( snd )
	if not istable( self._ActiveTireSounds ) or not self._ActiveTireSounds[ snd ] then return end

	self._ActiveTireSounds[ snd ]:Stop()
	self._ActiveTireSounds[ snd ] = nil
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_base_wheeldrive/cl_exhausteffects.lua:

function ENT:IsBackFireEnabled()
	if not isfunction( self.GetBackfire ) then return false end

	return self:GetBackfire()
end

function ENT:DoExhaustFX( Magnitude )
	for _, data in ipairs( self.ExhaustPositions ) do
		if data.bodygroup then
			if not self:BodygroupIsValid( data.bodygroup.name, data.bodygroup.active ) then continue end
		end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( data.pos ) )
			effectdata:SetNormal( self:LocalToWorldAngles( data.ang ):Forward() )
			effectdata:SetMagnitude( Magnitude )
			effectdata:SetEntity( self )
		util.Effect( "lvs_exhaust", effectdata )
	end
end

function ENT:ExhaustEffectsThink()
	if not self:IsBackFireEnabled() then return end

	local Throttle = self:GetThrottle()

	if self._backfireTHR ~= Throttle then
		self._backfireTHR = Throttle

		if Throttle ~= 0 then return end

		self:CalcExhaustPop()
	end
end

function ENT:CalcExhaustPop()
	local Engine = self:GetEngine()

	if not IsValid( Engine ) then return end

	local RPM = Engine:GetRPM()

	local num = (Engine:GetRPM() / 500)

	local Throttle = self:GetThrottle()

	if Throttle > 0 and Throttle < 0.6 then return end

	if Throttle ~= 0 or (not IsValid( self:GetTurbo() ) and not IsValid( self:GetCompressor() )) then num = 0 end

	for i = 0, num do
		timer.Simple( self.TransShiftSpeed + i * 0.1 , function()
			if not IsValid( self ) then return end

			if i > 0 and self:GetThrottle() ~= 0 then return end

			local Engine = self:GetEngine()

			if not IsValid( Engine ) then return end

			local RPM = Engine:GetRPM()

			if RPM < self.EngineMaxRPM * 0.6 then return end

			if i == 0 then
				self:DoExhaustPop( LVS.EngineVolume )
			else
				self:DoExhaustPop( 0.75 * LVS.EngineVolume )
			end
		end )
	end
end

function ENT:DoExhaustPop( volume )
	if not istable( self.ExhaustPositions ) then return end

	for _, data in ipairs( self.ExhaustPositions ) do
		if data.bodygroup then
			if not self:BodygroupIsValid( data.bodygroup.name, data.bodygroup.active ) then continue end
		end

		timer.Simple( math.Rand(0,0.2), function()
			local effectdata = EffectData()
				effectdata:SetOrigin( data.pos )
				effectdata:SetAngles( data.ang )
				effectdata:SetEntity( self )
				effectdata:SetMagnitude( volume or 1 )
			util.Effect( "lvs_carexhaust_pop", effectdata )
		end )
	end
end

function ENT:DoExhaustBackFire()
	if not istable( self.ExhaustPositions ) then return end

	for _, data in ipairs( self.ExhaustPositions ) do
		if data.bodygroup then
			if not self:BodygroupIsValid( data.bodygroup.name, data.bodygroup.active ) then continue end
		end

		if math.random( 1, math.floor( #self.ExhaustPositions * 0.75 ) ) ~= 1 then continue end

		timer.Simple( math.Rand(0.5,1), function()
			local effectdata = EffectData()
				effectdata:SetOrigin( data.pos )
				effectdata:SetAngles( data.ang )
				effectdata:SetEntity( self )
			util.Effect( "lvs_carexhaust_backfire", effectdata )
		end )
	end
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_trailer_flak/cl_tankview.lua:

include("entities/lvs_tank_wheeldrive/modules/cl_tankview.lua")

function ENT:TankViewOverride( ply, pos, angles, fov, pod )
	if ply == self:GetDriver() and not pod:GetThirdPersonMode() then
		local ID1 = self:LookupAttachment( "seat" )
		local ID2 = self:LookupAttachment( "muzzle" )

		local Att1 = self:GetAttachment( ID1 )
		local Att2 = self:GetAttachment( ID2 )

		if Att1 and Att2 then
			local dir = Att2.Ang:Right()
			pos =  Att1.Pos - Att1.Ang:Right() * 27 + dir * 1.5
		end

	end

	return pos, angles, fov
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_tank_wheeldrive/modules/sh_turret_ballistics.lua:

ENT.TurretBallisticsPredicted = true
ENT.TurretBallisticsUpright = 0.6
ENT.TurretBallisticsProjectileVelocity = 10000
ENT.TurretBallisticsMuzzleAttachment = "muzzle"
ENT.TurretBallisticsViewAttachment = "sight"

ENT.OpticsZoomOnly = true
ENT.OpticsScreenCentered = true

function ENT:TurretSystemDT()
	self:AddDT( "Bool", "NWTurretEnabled" )
	self:AddDT( "Bool", "NWTurretDestroyed" )
	self:AddDT( "Bool", "TurretDamaged" )
	self:AddDT( "Entity", "NWTurretArmor" )

	self:AddDT( "Float", "TurretCompensation" )
	self:AddDT( "Float", "NWTurretPitch" )
	self:AddDT( "Float", "NWTurretYaw" )

	if SERVER then
		self:SetTurretEnabled( true )
		self:SetTurretPitch( self.TurretPitchOffset )
		self:SetTurretYaw( self.TurretYawOffset )
	end
end

function ENT:SetTurretPitch( num )
	self:SetNWTurretPitch( num )
end

function ENT:SetTurretYaw( num )
	self:SetNWTurretYaw( num )
end

function ENT:GetTurretPitch()
	return self:GetNWTurretPitch()
end

function ENT:GetTurretYaw()
	return self:GetNWTurretYaw()
end

function ENT:GetTurretViewOrigin()
	local ID = self:LookupAttachment( self.TurretBallisticsViewAttachment )

	local Att = self:GetAttachment( ID )

	if not Att then return self:GetPos(), false end

	return Att.Pos, true
end

if SERVER then
	util.AddNetworkString( "lvs_turret_ballistics_synchronous" )

	local function GetTurretEyeTrace( base, weapon )
		local startpos, found = base:GetTurretViewOrigin()

		if not found then return weapon:GetEyeTrace() end
	
		local pod = weapon:GetDriverSeat()

		if IsValid( pod ) and pod:GetThirdPersonMode() then
			if weapon == base then
				startpos = pod:LocalToWorld( pod:OBBCenter() )
			else
				startpos = weapon:GetPos()
			end
		end

		local data = {
			start = startpos,
			endpos = (startpos + weapon:GetAimVector() * 50000),
			filter = base:GetCrosshairFilterEnts(),
		}

		local trace = util.TraceLine( data )

		return trace
	end

	function ENT:CalcTurretAngles( EntTable )
		local weapon = self:GetWeaponHandler( EntTable.TurretPodIndex )

		local UpZ = self:GetUp().z

		if not IsValid( weapon ) or UpZ < EntTable.TurretBallisticsUpright then return self:WorldToLocalAngles( weapon:GetAimVector():Angle() ) end

		local pod = weapon:GetDriverSeat()

		if IsValid( pod ) then
			local ply = weapon:GetDriver()

			local ForceNoCompensation = false

			if IsValid( ply ) then
				if self.OpticsZoomOnly and not ply:lvsKeyDown( "ZOOM" ) then
					ForceNoCompensation = true
				end

				if ply ~= weapon._LastBallisticsSendTo then
					weapon._LastBallisticsSendTo = ply

					local velocity = EntTable.TurretBallisticsProjectileVelocity
					local muzzle = EntTable.TurretBallisticsMuzzleAttachment
					local sight = EntTable.TurretBallisticsViewAttachment

					self:TurretUpdateBallistics( velocity, muzzle, sight )
				end

				if pod:GetThirdPersonMode() or ForceNoCompensation then
					return self:WorldToLocalAngles( weapon:GetAimVector():Angle() )
				end
			else
				if not weapon:GetAI() then
					return self:WorldToLocalAngles( weapon:GetAimVector():Angle() )
				end
			end
		end

		local ID = self:LookupAttachment( EntTable.TurretBallisticsMuzzleAttachment )

		local Muzzle = self:GetAttachment( ID )

		if not Muzzle then return self:WorldToLocalAngles( weapon:GetAimVector():Angle() ) end

		local MuzzlePos = Muzzle.Pos
		local MuzzleDir = Muzzle.Ang:Forward()
		local MuzzleAng = MuzzleDir:Angle()

		local AimPos = GetTurretEyeTrace( self, weapon ).HitPos

		local StartPos = MuzzlePos

		local ProjectileVelocity = EntTable.TurretBallisticsProjectileVelocity
		local Dist = (AimPos - MuzzlePos):Length()

		local OffsetPredicted = vector_origin

		if EntTable.TurretBallisticsPredicted then
			OffsetPredicted = physenv.GetGravity() * ((Dist / ProjectileVelocity) ^ 2)
		end

		local EndPos = AimPos - OffsetPredicted

		local Dir = (EndPos - StartPos):GetNormalized()

		local Pos, Ang = WorldToLocal( Muzzle.Pos, Dir:Angle(), Muzzle.Pos, MuzzleAng )

		-- more body pitch/roll = more inaccurate. If Z up get smaller, turret must align more conservative to not overshoot
		local TurretSmoothing = math.abs( UpZ )

		self:SetTurretCompensation( OffsetPredicted.z )

		return Angle( self:GetTurretPitch() + Ang.p * TurretSmoothing, self:GetTurretYaw() + Ang.y * TurretSmoothing, 0 )
	end

else
	ENT.IconTurret = Material( "lvs/turret.png" )
	ENT.IconTurretBody = Material( "lvs/turret_body.png" )
	ENT.IconTurretBarrel = Material( "lvs/turret_barrel.png" )
	ENT.IconTurretRing = Material( "lvs/turret_ring.png" )
	ENT.TurretColorMain = color_white
	ENT.TurretColorShadow = Color(0,0,0,200)
	ENT.TurretColorDamaged = Color(255,0,0,255)

	LVS:AddHudEditor( "Turret Info",  ScrW() * 0.5 - 75, ScrH() - 110,  150, 100, 150, 100, "TURRETINFO",
		function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
			if not vehicle.LVSHudPaintTurretInfo then return end

			vehicle:LVSHudPaintTurretInfo( X + W * 0.5 - H * 0.5, Y, H, H, ScrX, ScrY, ply )
		end
	)

	function ENT:LVSHudPaintTurretInfo( X, Y, W, H, ScrX, ScrY, ply )
		local pod = ply:GetVehicle()

		if not IsValid( pod ) or pod:lvsGetPodIndex() ~= self.TurretPodIndex then return end

		local EntTable = self:GetTable()

		local _, viewangles = ply:lvsGetView()

		local turret_yaw = self:GetTurretYaw()

		local yaw_body = - ply:GetVehicle():WorldToLocalAngles( viewangles ).y + 90
		local yaw_turret = turret_yaw + yaw_body

		local IconSize = W * 0.75

		surface.SetDrawColor( EntTable.TurretColorShadow )
		surface.SetMaterial( EntTable.IconTurretBody )
		surface.DrawTexturedRectRotated( X + W * 0.5 + 2, Y + H * 0.5 + 2, IconSize, IconSize, yaw_body )

		
		local BodyColor = EntTable.TurretColorMain

		for _, wheel in pairs( self:GetWheels() ) do
			if not wheel:GetDamaged() then continue end

			BodyColor = EntTable.TurretColorDamaged

			break
		end

		surface.SetDrawColor( BodyColor )
		surface.SetMaterial( EntTable.IconTurretBody )
		surface.DrawTexturedRectRotated( X + W * 0.5, Y + H * 0.5, IconSize, IconSize, yaw_body )

		surface.SetDrawColor( EntTable.TurretColorShadow )
		surface.SetMaterial( EntTable.IconTurret )
		surface.DrawTexturedRectRotated( X + W * 0.5 + 2, Y + H * 0.5 + 2, IconSize, IconSize, yaw_turret )

		surface.SetDrawColor( EntTable.TurretColorMain )
		surface.SetMaterial( EntTable.IconTurretBarrel )
		surface.DrawTexturedRectRotated( X + W * 0.5, Y + H * 0.5, IconSize, IconSize, yaw_turret )

		if self:GetTurretDamaged() then surface.SetDrawColor( EntTable.TurretColorDamaged ) end
		surface.SetMaterial( EntTable.IconTurretRing )
		surface.DrawTexturedRectRotated( X + W * 0.5, Y + H * 0.5, IconSize, IconSize, yaw_turret )
	end

	net.Receive( "lvs_turret_ballistics_synchronous", function( len )
		local vehicle = net.ReadEntity()

		local velocity = net.ReadFloat()
		local muzzle = net.ReadString()
		local sight = net.ReadString()

		if not IsValid( vehicle ) then return end

		if velocity == 0 then velocity = nil end
		if muzzle == "" then muzzle = nil end
		if sight == "" then sight = nil end

		vehicle:TurretUpdateBallistics( velocity, muzzle, sight )
	end )

	function ENT:CalcOpticsCrosshairDot( Pos2D )
		local ID = self:LookupAttachment( self.TurretBallisticsMuzzleAttachment )

		local Muzzle = self:GetAttachment( ID )

		if not Muzzle then return end

		local MuzzlePos = Muzzle.Pos

		local Pos = MuzzlePos
		local LastPos = MuzzlePos
		local StartPos = MuzzlePos
		local StartDirection = Muzzle.Ang:Forward()
		local Velocity  = self.TurretBallisticsProjectileVelocity

		local Gravity = vector_origin

		if self.TurretBallisticsPredicted then
			Gravity = physenv.GetGravity()
		end

		cam.Start3D()
		local Iteration = 0
		while Iteration < 1000 do
			Iteration = Iteration + 1

			local TimeAlive = Iteration / 200

			local EndPos = StartPos + StartDirection * TimeAlive * Velocity + Gravity * (TimeAlive ^ 2)

			Pos = EndPos

			local trace = util.TraceLine( {
				start = LastPos,
				endpos = EndPos,
				mask = MASK_SOLID,
			} )

			LastPos = EndPos

			if trace.Hit then
				Pos = trace.HitPos

				break
			end
		end
		cam.End3D()

		self:PaintOpticsCrosshair( Pos:ToScreen() )
	end
end

function ENT:TurretUpdateBallistics( newvelocity, newmuzzle, newsight )
	if newvelocity then
		self.TurretBallisticsProjectileVelocity = newvelocity
	end

	if newmuzzle then
		self.TurretBallisticsMuzzleAttachment = newmuzzle
	end

	if newsight then
		self.TurretBallisticsViewAttachment = newsight
	end

	if CLIENT then return end

	local ply = self:GetPassenger( self.TurretPodIndex )

	if not IsValid( ply ) then return end

	net.Start( "lvs_turret_ballistics_synchronous" )
		net.WriteEntity( self )
		net.WriteFloat( newvelocity or 0 )
		net.WriteString( newmuzzle or "" )
		net.WriteString( newsight or "" )
	net.Send( ply )
end

function ENT:AimTurret()
	if not self:IsTurretEnabled() then if SERVER then self:StopTurretSound() self:StopTurretSoundDMG() end return end

	local EntTable = self:GetTable()

	if SERVER then
		local AimAngles = self:CalcTurretAngles( EntTable )

		local AimRate = EntTable.TurretAimRate * FrameTime() 

		if self:GetTurretDamaged() then
			AimRate = AimRate * EntTable.TurretRateDestroyedMul
		end

		local Pitch = math.Clamp( math.ApproachAngle( self:GetTurretPitch(), AimAngles.p, AimRate ), EntTable.TurretPitchMin, EntTable.TurretPitchMax )
		local Yaw = math.ApproachAngle( self:GetTurretYaw(), AimAngles.y, AimRate )

		if EntTable.TurretYawMin and EntTable.TurretYawMax then
			Yaw = math.Clamp( Yaw, EntTable.TurretYawMin, EntTable.TurretYawMax )
		end

		self:CalcTurretSound( Pitch, Yaw, AimRate )

		self:SetTurretPitch( Pitch )
		self:SetTurretYaw( Yaw )

		self:SetPoseParameter(EntTable.TurretPitchPoseParameterName, EntTable.TurretPitchOffset + self:GetTurretPitch() * EntTable.TurretPitchMul )
		self:SetPoseParameter(EntTable.TurretYawPoseParameterName, EntTable.TurretYawOffset + self:GetTurretYaw() * EntTable.TurretYawMul )

		return
	end

	local Rate = math.min( FrameTime() * EntTable.TurretAimRate, 1 )

	local TargetPitch = EntTable.TurretPitchOffset + self:GetTurretPitch() * EntTable.TurretPitchMul
	local TargetYaw = EntTable.TurretYawOffset + self:GetTurretYaw() * EntTable.TurretYawMul

	EntTable._turretPitch = EntTable._turretPitch and EntTable._turretPitch + (TargetPitch - EntTable._turretPitch) * Rate or EntTable.TurretPitchOffset
	EntTable._turretYaw = EntTable._turretYaw and EntTable._turretYaw + (TargetYaw - EntTable._turretYaw) * Rate or EntTable.TurretYawOffset

	self:SetPoseParameter(EntTable.TurretPitchPoseParameterName, EntTable._turretPitch )
	self:SetPoseParameter(EntTable.TurretYawPoseParameterName, EntTable._turretYaw )
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_audi_s5_b8/shared.lua:

ENT.Base = "lvs_base_wheeldrive"

ENT.PrintName = "Audi S5 (B8)"
ENT.Author = "Digger"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS] - Cars - Pack"

ENT.VehicleCategory = "Cars"
ENT.VehicleSubCategory = "Civilian"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/diggercars/audi_s5/s5.mdl"

ENT.MaxVelocity = 2700

ENT.EngineTorque = 140
ENT.EngineIdleRPM = 660
ENT.EngineMaxRPM = 8000

ENT.TransGears = 6
ENT.TransGearsReverse = 1

ENT.RandomColor = {
	Color(237,236,233),
	Color(200,200,200),
	Color(80,80,80),
	Color(20,20,20),
	Color(226,221,31),
	Color(182,89,13),
	Color(228,19,12),
	Color(170,0,0),
	Color(125,7,31),
	Color(66,27,22),
	Color(18,80,118),
	Color(27,82,106),
	Color(116,155,77),
}

ENT.HornSound = "lvs/horn1.wav"
ENT.HornPos = Vector(40,0,35)

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/audi_r8/idle2.wav",
		Volume = 1,
		Pitch = 70,
		PitchMul = 70,
		SoundLevel = 55,
		SoundType = LVS.SOUNDTYPE_IDLE_ONLY,
	},
	{
		sound = "lvs/vehicles/audi_r8/high.wav",
		Volume = 1,
		Pitch = 80,
		PitchMul = 110,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_REV_UP,
		UseDoppler = true,
	},
	{
		sound = "lvs/vehicles/audi_r8/revdown.wav",
		Volume = 1,
		Pitch = 80,
		PitchMul = 110,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_REV_DOWN,
		UseDoppler = true,
	},
}

ENT.ExhaustPositions = {
	{
		pos = Vector(-86.84,23.7,6.04),
		ang = Angle(20,180,0),
	},
	{
		pos = Vector(-87.96,19.92,5.86),
		ang = Angle(20,180,0),
	},
	{
		pos = Vector(-86.84,-23.7,6.04),
		ang = Angle(20,180,0),
	},
	{
		pos = Vector(-87.96,-19.92,5.86),
		ang = Angle(20,180,0),
	},
}


ENT.Lights = {
	{
		Trigger = "main",
		SubMaterialID = 11,
		SubMaterialBrightness = 10,
		ProjectedTextures = {
			{ pos = Vector(83.78,22.35,19.63), ang = Angle(0,0,0), colorR = 200, colorG = 200, colorB = 250, colorA = 150, shadows = true },
			{ pos = Vector(83.78,-22.35,19.63), ang = Angle(0,0,0), colorR = 200, colorG = 200, colorB = 250, colorA = 150, shadows = true },
		},
	},
	{
		Trigger = "high",
		ProjectedTextures = {
			{ pos = Vector(79.63,27.51,19.7), ang = Angle(0,0,0), colorR = 200, colorG = 200, colorB = 250, colorA = 150, shadows = true },
			{ pos = Vector(79.63,-27.51,19.7), ang = Angle(0,0,0), colorR = 200, colorG = 200, colorB = 250, colorA = 150, shadows = true },
		},
	},
	{
		Trigger = "main+brake",
		SubMaterialID = 15,
		SubMaterialBrightness = 20,
		Sprites = {
			{ width = 65, height = 35, pos = Vector(-84.32,23.53,26.31), colorG = 0, colorB = 0, colorA = 50 },
			{ width = 65, height = 35, pos = Vector(-84.32,-23.53,26.31), colorG = 0, colorB = 0, colorA = 50 },
		},
	},
	{
		Trigger = "main",
		SubMaterialID = 0,
	},
	{
		Trigger = "main",
		SubMaterialID = 2,
	},
	{
		Trigger = "main",
		SubMaterialID = 12,
	},
	{
		Trigger = "brake",
		SubMaterialID = 26,
		SubMaterialBrightness = 20,
		Sprites = {
			{ width = 65, height = 15, pos = Vector(-45.96,0,44.43), colorG = 0, colorB = 0, colorA = 150 },
		},
	},
	{
	Trigger = "main+high",
		SubMaterialID = 20,
		SubMaterialBrightness = 20,
		Sprites = {
			{ pos = Vector(79.63,27.51,19.7), colorR = 200, colorG = 200, colorB = 250, colorA = 150 },
			{ pos = Vector(79.63,-27.51,19.7), colorR = 200, colorG = 200, colorB = 250, colorA = 150 },
			{ pos = Vector(83.78,-22.35,19.63), colorR = 200, colorG = 200, colorB = 250, colorA = 150 },
			{ pos = Vector(83.78,22.35,19.63), colorR = 200, colorG = 200, colorB = 250, colorA = 150 },
		},
	},



	{
		Trigger = "fog",
		SubMaterialID = 28,
		Sprites = {
			{ width = 25, height = 25, pos = Vector(82.28,28.48,6.53), colorR = 200, colorG = 200, colorB = 250, colorA = 150 },
			{ width = 25, height = 25, pos = Vector(82.28,-28.48,6.53), colorR = 200, colorG = 200, colorB = 250, colorA = 150 },
		},
	},

	{
		Trigger = "reverse",
		SubMaterialID = 14,
		SubMaterialBrightness = 2,
		Sprites = {

			{ pos = Vector(-85.52,18.79,28.68), height = 25, width = 25, colorA = 150 },
			{ pos = Vector(-85.52,-18.79,28.68), height = 25, width = 25, colorA = 150 },

		}
	},
	{
		Trigger = "turnright",
		SubMaterialID = 13,
		SubMaterialBrightness = 1,
		Sprites = {
			{ width = 45, height = 25,  pos = "tlr", colorG = 100, colorB = 0, colorA = 50 },
			{ width = 45, height = 25,  pos = Vector(84.39,-23.53,18.03), colorG = 100, colorB = 0, colorA = 50 },
			{ width = 25, height = 25, pos = Vector(-82.17,-26.67,28.62), colorG = 100, colorB = 0, colorA = 50 },
		},
	},
	{
		Trigger = "turnleft",
		SubMaterialID = 9,
		SubMaterialBrightness = 1,
		Sprites = {
			{ width = 45, height = 25,  pos = "tll", colorG = 100, colorB = 0, colorA = 50 },
			{ width = 45, height = 25, pos = Vector(84.39,23.53,18.03), colorG = 100, colorB = 0, colorA = 50 },
			{ width = 25, height = 25, pos = Vector(-82.17,26.67,28.62), colorG = 100, colorB = 0, colorA = 50 },

		},
	},
}


--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_bmw_e46m3/shared.lua:

ENT.Base = "lvs_base_wheeldrive"

ENT.PrintName = "BMW M3 (E46)"
ENT.Author = "Digger"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS] - Cars - Pack"

ENT.VehicleCategory = "Cars"
ENT.VehicleSubCategory = "Civilian"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/diggercars/bmw_e46/e46.mdl"

ENT.MaxVelocity = 2850

ENT.EngineTorque = 150
ENT.EngineIdleRPM = 1000
ENT.EngineMaxRPM = 9000

ENT.TransGears = 6
ENT.TransGearsReverse = 1

ENT.PhysicsMass = 1100

ENT.WheelPhysicsMass = 130

ENT.HornSound = "lvs/horn4.wav"
ENT.HornPos = Vector(40,0,35)

ENT.RandomColor = {
	{
		Skin = 1,
		Color = Color(185,166,42),
	},
	{
		Skin = 1,
		Color = Color(245,245,245),
	},
	{
		Skin = 1,
		Color = Color(205,205,205),
	},
	{
		Skin = 1,
		Color = Color(105,105,105),
	},
	{
		Skin = 1,
		Color = Color(36,44,69),
	},
	{
		Skin = 1,
		Color = Color(0,124,138),
	},
	{
		Skin = 1,
		Color = Color(26,37,16),
	},
	{
		Skin = 1,
		Color = Color(25,25,25),
	},
	{
		Skin = 1,
		Color = Color(0,0,0),
	},
	{
		Skin = 1,
		Color = Color(100,0,0),
	},
}


ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/e46/idle.wav",
		Volume = 1,
		Pitch = 60,
		PitchMul = 70,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_IDLE_ONLY,
	},
	{
		sound = "lvs/vehicles/bmw_m5e34/eng_loop.wav",
		Volume = 1,
		Pitch = 80,
		PitchMul = 110,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_REV_UP,
		UseDoppler = true,
	},
	{
		sound = "lvs/vehicles/bmw_m5e34/eng_revdown_loop.wav",
		Volume = 1,
		Pitch = 80,
		PitchMul = 110,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_REV_DOWN,
		UseDoppler = true,
	},
}

ENT.ExhaustPositions = {
	{
		pos = Vector(-87.05,13.52,6.42),
		ang = Angle(0,180,0),
	},
	{
		pos = Vector(-87.17,10.1,6.33),
		ang = Angle(0,180,0),
	},
	{
		pos = Vector(-87.05,-13.52,6.42),
		ang = Angle(0,180,0),
	},
	{
		pos = Vector(-87.17,-10.1,6.33),
		ang = Angle(0,180,0),
	},
}

ENT.Lights = {
	{
		Trigger = "main",
		SubMaterialID = 14,
		SubMaterialBrightness = 1,
		Sprites = {
			{ pos = Vector(78.76,-23.36,19.28), colorB = 200, colorA = 150, width = 60, height = 60 },
			{ pos = Vector(78.76,23.36,19.28), colorB = 200, colorA = 150, width = 60, height = 60 },
		},
		ProjectedTextures = {
			{ pos = Vector(78.76,-23.36,19.28), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
			{ pos = Vector(78.76,23.36,19.28), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
		},
	},
	{
		Trigger = "main",
		SubMaterialID = 12,
	},
	{
		Trigger = "main",
		SubMaterialID = 13,
	},
	{
		Trigger = "main+brake",
		SubMaterialID = 19,
		SubMaterialBrightness = 20,
		Sprites = {
			{ width = 45, height = 45, pos = Vector(-83.3,24.48,25.93), colorG = 0, colorB = 0, colorA = 150 },
			{ width = 45, height = 45, pos = Vector(-83.3,-24.48,25.93), colorG = 0, colorB = 0, colorA = 150 },
		},
	},

	{
		Trigger = "brake",
		SubMaterialID = 20,
		SubMaterialBrightness = 25,
		Sprites = {
			{ width = 65, height = 15, pos = Vector(-44.7,0,45.56), colorG = 0, colorB = 0, colorA = 150 },
		},
	},
	{
		Trigger = "high",
		SubMaterialID = 17,
		Sprites = {
			{ pos = Vector(79.54,17.38,19.4), colorB = 200, colorA = 150 },
			{ pos = Vector(79.54,-17.38,19.4), colorB = 200, colorA = 150 },
		},
		ProjectedTextures = {
			{ pos = Vector(79.54,17.38,19.4), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
			{ pos = Vector(79.54,-17.38,19.4), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
		},
	},
	{
		Trigger = "fog",
		SubMaterialID = 23,
		Sprites = {
			{ pos = Vector(82.13,-25.13,7.83), height = 25, width = 25, colorB = 200, colorA = 150, bodygroup = { name = "Front_Bumper", active = { 0 } }, },
			{ pos = Vector(82.13,25.13,7.83), height = 25, width = 25, colorB = 200, colorA = 150, bodygroup = { name = "Front_Bumper", active = { 0 } }, },
			{ pos = Vector(82.13,-25.13,7.83), height = 25, width = 25, colorB = 200, colorA = 150, bodygroup = { name = "Front_Bumper", active = { 3 } }, },
			{ pos = Vector(82.13,25.13,7.83), height = 25, width = 25, colorB = 200, colorA = 150, bodygroup = { name = "Front_Bumper", active = { 3 } }, },
			{ pos = Vector(83.42,-23.91,7.74), height = 25, width = 25, colorB = 200, colorA = 150, bodygroup = { name = "Front_Bumper", active = { 4 } }, },
			{ pos = Vector(83.42,23.91,7.74), height = 25, width = 25, colorB = 200, colorA = 150, bodygroup = { name = "Front_Bumper", active = { 4 } }, },
			{ width = 25, height = 25, pos = Vector(-85.77,-16.76,24.89), colorG = 0, colorB = 0, colorA = 150 },
			{ width = 25, height = 25, pos = Vector(-85.77,16.76,24.89), colorG = 0, colorB = 0, colorA = 150 },
		},
	},

	{
		Trigger = "reverse",
		SubMaterialID = 26,
		SubMaterialBrightness = 25,
		Sprites = {

			{ pos = Vector(-85.58,-17.42,26.76), height = 25, width = 25, colorA = 150 },
			{ pos = Vector(-85.58,17.42,26.76), height = 25, width = 25, colorA = 150 },

		}
	},
	{
		Trigger = "turnright",
		SubMaterialID = 18,
		SubMaterialBrightness = 10,
		Sprites = {
			{ width = 45, height = 25,  pos = Vector(-83.61,-24.55,29.19), colorG = 100, colorB = 0, colorA = 50 },
			{ width = 45, height = 45, pos = Vector(39.08,-34.39,16), colorG = 100, colorB = 0, colorA = 50, bodygroup = { name = "Front_Fenders", active = { 0 } }, },
			{ width = 45, height = 45, pos = Vector(39.08,-34.39,16), colorG = 100, colorB = 0, colorA = 50, bodygroup = { name = "Front_Fenders", active = { 1 } }, },
			{ width = 45, height = 45, pos = Vector(39.08,-34.39,16), colorG = 100, colorB = 0, colorA = 50, bodygroup = { name = "Front_Fenders", active = { 3 } }, },
			{ width = 25, height = 25, pos = Vector(76.67,-28.78,18.94), colorG = 100, colorB = 0, colorA = 50 },
		},
	},
	{
		Trigger = "turnleft",
		SubMaterialID = 15,
		SubMaterialBrightness = 10,
		Sprites = {
			{ width = 45, height = 25, pos = Vector(-83.61,24.55,29.19), colorG = 100, colorB = 0, colorA = 50 },
			{ width = 45, height = 45, pos = Vector(39.08,34.39,16), colorG = 100, colorB = 0, colorA = 50, bodygroup = { name = "Front_Fenders", active = { 0 } }, },
			{ width = 45, height = 45, pos = Vector(39.08,34.39,16), colorG = 100, colorB = 0, colorA = 50, bodygroup = { name = "Front_Fenders", active = { 1 } }, },
			{ width = 45, height = 45, pos = Vector(39.08,34.39,16), colorG = 100, colorB = 0, colorA = 50, bodygroup = { name = "Front_Fenders", active = { 3 } }, },
			{ width = 25, height = 25, pos = Vector(76.67,28.78,18.94), colorG = 100, colorB = 0, colorA = 50 },

		},
	},
}


--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_sdkfz250/sh_tracks.lua:

if SERVER then
	function ENT:OnLeftTrackRepaired()
		self:SetBodygroup(1,0)
	end

	function ENT:OnLeftTrackDestroyed()
		self:SetBodygroup(1,1)
	end

	function ENT:OnRightTrackRepaired()
		self:SetBodygroup(2,0)
	end

	function ENT:OnRightTrackDestroyed()
		self:SetBodygroup(2,1)
	end

	function ENT:TracksCreate( PObj )
		local WheelModel = "models/diggercars/sdkfz250/250_wheel.mdl"

		local L1 = self:AddWheel( { hide = true, pos = Vector(-0,32,20), mdl = WheelModel } )
		local L2 = self:AddWheel( { hide = true, pos = Vector(-30,32,20), mdl = WheelModel } )
		local L3 = self:AddWheel( { hide = true, pos = Vector(-60,32,20), mdl = WheelModel } )
		local LeftWheelChain = self:CreateWheelChain( {L1, L2, L3} )
		self:SetTrackDriveWheelLeft( L1 )

		local R1 = self:AddWheel( { hide = true, pos = Vector(-0,-32,20), mdl = WheelModel, mdl_ang = Angle(0,180,0) } )
		local R2 = self:AddWheel( { hide = true, pos = Vector(-30,-32,20), mdl = WheelModel, mdl_ang = Angle(0,180,0) } )
		local R3 = self:AddWheel( { hide = true, pos = Vector(-60,-32,20), mdl = WheelModel, mdl_ang = Angle(0,180,0) } )
		local RightWheelChain = self:CreateWheelChain( {R1, R2, R3} )
		self:SetTrackDriveWheelRight( R1 )

		local LeftTracksArmor = self:AddArmor( Vector(-25,30,20), Angle(0,0,0), Vector(-50,-10,-15), Vector(50,10,15), 200, 0 )
		self:SetTrackArmorLeft( LeftTracksArmor, LeftWheelChain )

		local RightTracksArmor = self:AddArmor( Vector(-25,-30,20), Angle(0,0,0), Vector(-50,-10,-15), Vector(50,10,15), 200, 0 )
		self:SetTrackArmorRight( RightTracksArmor, RightWheelChain )

		self:DefineAxle( {
			Axle = {
				ForwardAngle = Angle(0,0,0),
				SteerType = LVS.WHEEL_STEER_NONE,
				TorqueFactor = 0.5,
				BrakeFactor = 1,
				UseHandbrake = true,
			},
			Wheels = { R1, L1, L2, R2, R3, L3 },
				Suspension = {
				Height = 10,
				MaxTravel = 7,
				ControlArmLength = 25,
				SpringConstant = 20000,
				SpringDamping = 2000,
				SpringRelativeDamping = 2000,
			},
		} )
	end
else
	ENT.TrackSystemEnable = true

	ENT.TrackScrollTexture = "models/diggercars/sdkfz250/tracks"
	ENT.ScrollTextureData = {
		["$bumpmap"] = "models/diggercars/shared/skin_nm",
		["$phong"] = "1",
		["$phongboost"] = "0.04",
		["$phongexponent"] = "3",
		["$phongfresnelranges"] = "[1 1 1]",
		["$translate"] = "[0.0 0.0 0.0]",
		["$colorfix"] = "{255 255 255}",
		["Proxies"] = {
			["TextureTransform"] = {
				["translateVar"] = "$translate",
				["centerVar"]    = "$center",
				["resultVar"]    = "$basetexturetransform",
			},
			["Equals"] = {
				["srcVar1"] =  "$colorfix",
				["resultVar"] = "$color",
			}
		}
	}

	ENT.TrackLeftSubMaterialID = 4
	ENT.TrackLeftSubMaterialMul = Vector(0,0.0325,0)

	ENT.TrackRightSubMaterialID = 5
	ENT.TrackRightSubMaterialMul = Vector(0,0.0325,0)

	ENT.TrackPoseParameterLeft = "spin_wheels_left"
	ENT.TrackPoseParameterLeftMul = -1.8

	ENT.TrackPoseParameterRight = "spin_wheels_right"
	ENT.TrackPoseParameterRightMul = -1.8

	ENT.TrackSounds = "lvs/vehicles/halftrack/tracks_loop.wav"
	ENT.TrackHull = Vector(5,5,5)
	ENT.TrackData = {}

	for i = 1, 4 do
		for n = 0, 1 do
			local LR = n == 0 and "l" or "r"
			local LeftRight = n == 0 and "left" or "right"
			local data = {
				Attachment = {
					name = "vehicle_suspension_"..LR.."_"..i,
					toGroundDistance = 29,
					traceLength = 150,
				},
				PoseParameter = {
					name = "suspension_"..LeftRight.."_"..i,
					rangeMultiplier = -1.25,
					lerpSpeed = 25,
				}
			}
			table.insert( ENT.TrackData, data )
		end
	end
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_tank_wheeldrive/modules/cl_tankview.lua:
if SERVER then return end

function ENT:TankViewOverride( ply, pos, angles, fov, pod )
	return pos, angles, fov
end

function ENT:CalcTankView( ply, original_pos, original_ang, original_fov, pod )
	local pos, angles, fov = self:TankViewOverride( ply, original_pos, original_ang, original_fov, pod )

	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	if not pod:GetThirdPersonMode() then return view end

	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local clamped_angles = pod:WorldToLocalAngles( angles )
	clamped_angles.p = math.max( clamped_angles.p, -20 )
	clamped_angles = pod:LocalToWorldAngles( clamped_angles )

	local StartPos = pos
	local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * (radius * pod:GetCameraHeight())

	local WallOffset = 4

	local tr = util.TraceHull( {
		start = StartPos,
		endpos = EndPos,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.angles = angles + Angle(5,0,0)
	view.origin = tr.HitPos + pod:GetUp() * 65
	view.drawviewer = true

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

function ENT:CalcViewDirectInput( ply, pos, angles, fov, pod )
	if not pod:GetThirdPersonMode() then
		angles = pod:LocalToWorldAngles( ply:EyeAngles() )
	end

	return self:CalcTankView( ply, pos, angles, fov, pod )
end

function ENT:CalcViewMouseAim( ply, pos, angles, fov, pod )
	return self:CalcTankView( ply, pos, angles, fov, pod )
end

function ENT:CalcViewPassenger( ply, pos, angles, fov, pod )
	if not pod:GetThirdPersonMode() then
		angles = pod:LocalToWorldAngles( ply:EyeAngles() )
	end

	return self:CalcTankView( ply, pos, angles, fov, pod )
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_wheel/cl_skidmarks.lua:

ENT.SkidmarkMaterialDamaged = Material("sprites/lvs/skidmark_damaged")

ENT.SkidmarkTraceAdd = Vector(0,0,10)
ENT.SkidmarkDelay = 0.05
ENT.SkidmarkLifetime = 10

ENT.SkidmarkRed = 0
ENT.SkidmarkGreen = 0
ENT.SkidmarkBlue = 0
ENT.SkidmarkAlpha = 150

ENT.SkidmarkSurfaces = {
	[""] = true,
	["concrete"] = true,
	["plastic_barrel_buoyant"] = true,
	["phx_rubbertire2"] = true,
	["tile"] = true,
	["metal"] = true,
	["boulder"] = true,
	["default"] = true,
}

ENT.DustEffectSurfaces = {
	["sand"] = true,
	["dirt"] = true,
	["grass"] = true,
	["antlionsand"] = true,
	["gravel"] = true,
}

function ENT:GetSkidMarks()
	if not istable( self._activeSkidMarks ) then
		self._activeSkidMarks = {}
	end

	return self._activeSkidMarks
end

function ENT:StartSkidmark( pos )
	if self:GetWidth() <= 0 or self._SkidMarkID or not LVS.ShowTraileffects then return end

	local ID = 1
	for _,_ in ipairs( self:GetSkidMarks() ) do
		ID = ID + 1
	end

	self._activeSkidMarks[ ID ] = {
		active = true,
		startpos = pos + self.SkidmarkTraceAdd,
		delay = CurTime() + self.SkidmarkDelay,
		damaged = self:GetNWDamaged(),
		positions = {},
	}

	self._SkidMarkID = ID
end

function ENT:FinishSkidmark()
	if not self._SkidMarkID then return end

	self._activeSkidMarks[ self._SkidMarkID ].active = false

	self._SkidMarkID = nil
end

function ENT:RemoveSkidmark( id )
	if not id then return end

	self._activeSkidMarks[ id ] = nil
end

function ENT:CalcSkidmark( trace, Filter )
	local T = CurTime()
	local CurActive = self:GetSkidMarks()[ self._SkidMarkID ]

	if not CurActive or not CurActive.active or CurActive.delay >= T then return end

	CurActive.delay = T + self.SkidmarkDelay

	local W = self:GetWidth()

	local cur = trace.HitPos + self.SkidmarkTraceAdd * 0.5

	local prev = CurActive.positions[ #CurActive.positions ]

	if not prev then
		local sub = cur - CurActive.startpos

		local L = sub:Length() * 0.5
		local C = (cur + CurActive.startpos) * 0.5

		local Ang = sub:Angle()
		local Forward = Ang:Right()
		local Right = Ang:Forward()

		local p1 = C + Forward * W + Right * L
		local p2 = C - Forward * W + Right * L

		local t1 = util.TraceLine( { start = p1, endpos = p1 - self.SkidmarkTraceAdd } )
		local t2 = util.TraceLine( { start = p2, endpos = p2 - self.SkidmarkTraceAdd } )

		prev = {
			px = CurActive.startpos,
			p1 = t1.HitPos + t1.HitNormal,
			p2 = t2.HitPos + t2.HitNormal,
			lifetime = T + self.SkidmarkLifetime - self.SkidmarkDelay,
			alpha = 0,
		}
	end

	local sub = cur - prev.px

	local L = sub:Length() * 0.5
	local C = (cur + prev.px) * 0.5

	local Ang = sub:Angle()
	local Forward = Ang:Right()
	local Right = Ang:Forward()

	local p1 = C + Forward * W + Right * L
	local p2 = C - Forward * W + Right * L

	local t1 = util.TraceLine( { start = p1, endpos = p1 - self.SkidmarkTraceAdd, filter = Filter, } )
	local t2 = util.TraceLine( { start = p2, endpos = p2 - self.SkidmarkTraceAdd, filter = Filter, } )

	local nextID = #CurActive.positions + 1

	CurActive.positions[ nextID ] = {
		px = cur,
		p1 = t1.HitPos + t1.HitNormal,
		p2 = t2.HitPos + t2.HitNormal,
		lifetime = T + self.SkidmarkLifetime,
		alpha = math.min( nextID / 10, 1 ),
	}
end

function ENT:RenderSkidMarks()
	local T = CurTime()

	for id, skidmark in pairs( self:GetSkidMarks() ) do
		local prev
		local AmountDrawn = 0

		if skidmark.damaged then
			render.SetMaterial( self.SkidmarkMaterialDamaged )
		else
			render.SetColorMaterial()
		end

		for markID, data in pairs( skidmark.positions ) do
			if not prev then

				prev = data

				continue
			end

			local Mul = math.max( data.lifetime - CurTime(), 0 ) / self.SkidmarkLifetime

			if Mul > 0 then
				AmountDrawn = AmountDrawn + 1
				render.DrawQuad( data.p2, data.p1, prev.p1, prev.p2, Color( self.SkidmarkRed, self.SkidmarkGreen, self.SkidmarkBlue, math.min(255 * Mul * data.alpha,self.SkidmarkAlpha) ) )
			end

			prev = data
		end

		if not skidmark.active and AmountDrawn == 0 then
			self:RemoveSkidmark( id )
		end
	end
end

hook.Add( "PreDrawTranslucentRenderables", "!!!!lvs_skidmarks", function( bDepth, bSkybox )
	if bSkybox then return end

	for _, wheel in ipairs( ents.FindByClass("lvs_wheeldrive_wheel") ) do
		wheel:RenderSkidMarks()
	end
end)
--PATH addons/__main/lua/entities/m9k_ammo_sniper_rounds/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"
ENT.PrintName		= "Sniper Rounds"
ENT.Category		= "M9K Ammunition"

ENT.Spawnable		= true
ENT.AdminOnly = false
ENT.DoNotDuplicate = true

if SERVER then

AddCSLuaFile("shared.lua")

function ENT:SpawnFunction(ply, tr)

	if (!tr.Hit) then return end
	
	local SpawnPos = tr.HitPos + tr.HitNormal * 16
	
	local ent = ents.Create("m9k_ammo_sniper_rounds")
	
	ent:SetPos(SpawnPos)
	ent:Spawn()
	ent:Activate()
	ent.Planted = false
	
	return ent
end


/*---------------------------------------------------------
   Name: Initialize
---------------------------------------------------------*/
function ENT:Initialize()

	local model = ("models/Items/sniper_round_box.mdl")
	
	self.Entity:SetModel(model)
	
	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:DrawShadow(false)
	
	self.Entity:SetCollisionGroup(COLLISION_GROUP_WEAPON)
	
	local phys = self.Entity:GetPhysicsObject()
	
	if (phys:IsValid()) then
		phys:Wake()
	end

	self.Entity:SetUseType(SIMPLE_USE)
end


/*---------------------------------------------------------
   Name: PhysicsCollide
---------------------------------------------------------*/
function ENT:PhysicsCollide(data, physobj)
	
	// Play sound on bounce
	if (data.Speed > 80 and data.DeltaTime > 0.2) then
		self.Entity:EmitSound("Default.ImpactSoft")
	end
end

/*---------------------------------------------------------
   Name: OnTakeDamage
---------------------------------------------------------*/
function ENT:OnTakeDamage(dmginfo)

	if dmginfo:GetAttacker():GetClass() == "m9k_ammo_explosion" then return end
	self.Entity:TakePhysicsDamage(dmginfo)
	if GetConVar("M9KAmmoDetonation") == nil then return end
	if not (GetConVar("M9KAmmoDetonation"):GetBool()) then return end
	blaster = dmginfo:GetAttacker()
	pos = self.Entity:GetPos()+Vector(0,0,10)
	
	dice = math.random(1,5)

	if dmginfo:GetDamage() >75 or dice == 1 then
		self.Entity:Remove()
	
		local effectdata = EffectData()
		effectdata:SetOrigin(self.Entity:GetPos())
		util.Effect("ThumperDust", effectdata)
		util.Effect("Explosion", effectdata)
	
		timer.Simple(.01, function()
		
			for i=1, 50 do
			
			ouchies = {}
			ouchies.start = pos
			ouchies.endpos = pos + Vector(math.Rand(-1,1), math.Rand(-1,1), math.Rand(0,1)) * 64000
			ouchies = util.TraceLine(ouchies)
			
			if ouchies.Hit and not ouchies.HitSky then 
				util.Decal("Impact.Concrete", ouchies.HitPos + ouchies.HitNormal, ouchies.HitPos - ouchies.HitNormal )//and ouchies.Entity then
				ouchies.Entity:TakeDamage(30 * math.Rand(.85,1.15), blaster, self.Entity)
			end
			end
		end)
	end	

end


/*---------------------------------------------------------
   Name: Use
---------------------------------------------------------*/
function ENT:Use(activator, caller)

	
	if (activator:IsPlayer()) and not self.Planted then
		activator:GiveAmmo(50, "SniperPenetratedRound")
		self.Entity:Remove()
	end
end

end

if CLIENT then

/*---------------------------------------------------------
   Name: Initialize
---------------------------------------------------------*/
function ENT:Initialize()
end

/*---------------------------------------------------------
   Name: DrawPre
---------------------------------------------------------*/
function ENT:Draw()
	
	self.Entity:DrawModel()
	
	local ledcolor = Color(230, 45, 45, 255)

  	local TargetPos = self.Entity:GetPos() + (self.Entity:GetUp() * 1.4) + (self.Entity:GetRight() * 1) + (self.Entity:GetForward() * -1.45)

	local FixAngles = self.Entity:GetAngles()
	local FixRotation = Vector(90, 0, 0)
	
	FixAngles:RotateAroundAxis(FixAngles:Right(), FixRotation.x)
	FixAngles:RotateAroundAxis(FixAngles:Up(), FixRotation.y)
	FixAngles:RotateAroundAxis(FixAngles:Forward(), FixRotation.z)

	self.Text = "Sniper Rounds"
	
	cam.Start3D2D(TargetPos, FixAngles, .07)
		draw.SimpleText(self.Text, "DermaDefaultBold", 31, -22, ledcolor, 1, 1)
	cam.End3D2D()
end

end
--PATH gamemodes/darkrp/entities/entities/microwave/shared.lua:

-----------------------------------------------------
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Microwave"
ENT.Author = "Pcwizdan"
ENT.Spawnable = true
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "price")
	self:NetworkVar("Entity", 1, "owning_ent")
end
--PATH gamemodes/darkrp/entities/entities/npc_mayor/cl_init.lua:
include("Shared.lua")


local ipairs 		= ipairs
local CurTime 		= CurTime 
local LocalPlayer 	= LocalPlayer
local math_sin 		= math.sin
local math_pi 		= math.pi
local cam_Start3D2D	= cam.Start3D2D
local cam_End3D2D	= cam.End3D2D
local draw_SimpleTextOutlined = draw.SimpleTextOutlined
local ents_FindByClass = ents.FindByClass

local vec = Vector(0,-1,82)

local color_white = Color(200,0,0)
local color_black = Color(0,0,0)


local function Draw(self)
	local pos = self:GetPos()
	local ang = self:GetAngles()
	local dist = pos:Distance(LocalPlayer():GetPos())
	

		self:DrawModel()		

		if (dist > 350) then return end
		
		color_white.a = 350 - dist
		color_black.a = 350 - dist

		ang:RotateAroundAxis(ang:Forward(), 90)
		ang:RotateAroundAxis(ang:Right(), -90)
		
		ang:RotateAroundAxis(ang:Right(), math_sin(CurTime() * math_pi) * -45)
		
		cam_Start3D2D(pos + vec + ang:Right() * 1.2, ang, 0.065)
			draw.ShadowText('Замовити вбийство', 'Roboto_150', 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, color_black)
		cam_End3D2D()
		
		ang:RotateAroundAxis(ang:Right(), 180)
		
		//cam_Start3D2D(pos + vec + ang:Right() * 1.2, ang, 0.065)
		//	draw_SimpleTextOutlined('Заказать убийство', 'Roboto_150', 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, color_black)		
		//cam_End3D2D()

end

function ENT:Draw()
	Draw(self)
end

--PATH addons/_pcasino/lua/entities/pcasino_mystery_wheel/cl_init.lua:
include("shared.lua")


function ENT:Initialize()
	self.active = false
	self.currentBets = {}

	self.hasInitialized = true
end

function ENT:PostData()
	if not self.hasInitialized then
		self:Initialize()
	end
end

local surface_setdrawcolor = surface.SetDrawColor
local surface_drawrect = surface.DrawRect
local draw_simpletext = draw.SimpleText
local surface_setmaterial = surface.SetMaterial
local surface_gettextsize = surface.GetTextSize
local surface_setfont = surface.SetFont
local draw_notexture = draw.NoTexture
local math_cos = math.cos
local math_sin = math.sin
local math_rad = math.rad
local black = Color(0, 0, 0, 155)
local white = Color(255, 255, 255, 100)
function ENT:DrawTranslucent()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 1000000 then return end


	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end

	if not self.data then return end

	-- Basic setups
	local pos = self:GetPos()
	if not self:GetBoneMatrix(2) then return end
	local ang = self:GetBoneMatrix(2):GetAngles()

	ang:RotateAroundAxis(ang:Up(), 89.8)
	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Up(), -162)

	cam.Start3D2D(pos + (self:GetUp()*9.75) + (self:GetRight()*0.2) + (self:GetForward()*-17.4), ang, 0.08)
		-- Spinny wheel icons
		local itter = 0
		for i=1, 360, 360/20 do 
			itter = itter + 1
			local x = math_cos(math_rad(i - 91)) * 155
			local y = math_sin(math_rad(i - 91)) * 155

			draw_notexture()
			surface_setdrawcolor(255, 255, 255, 255)
			surface_setmaterial(PerfectCasino.Icons[self.data.wheel[21 - itter].p].mat)

			PerfectCasino.UI.DrawTexturedRectRotatedPoint(x, y, 60, 60, (-i+1), 0, -218)
			PerfectCasino.UI.TextRotated(self.data.wheel[21 - itter].n, x, y, color_white, "pCasino.Title.Static", i-90, 1)
		end
	cam.End3D2D()

	if tobool(self.data.buySpin.buy) or (tobool(self.data.general.useFreeSpins) and (PerfectCasino.Spins > 0)) then
		-- Basic setups
		local pos = self:GetPos()
		local ang = self:GetAngles()
		ang:RotateAroundAxis(ang:Up(), 50)
		ang:RotateAroundAxis(ang:Forward(), 90)
	
		surface_setfont("pCasino.Entity.Arrows")
		local spinSize, _ = surface_gettextsize(PerfectCasino.Translation.UI.PurchaseASpin)
		local moneySize, _ = surface_gettextsize(PerfectCasino.Config.FormatMoney(self.data.buySpin.cost))
		local biggestSize = (spinSize > moneySize) and spinSize or moneySize
		biggestSize = biggestSize + 100

		cam.Start3D2D(pos + (ang:Up()*-35) + (ang:Forward()*25) + (ang:Right()*-9) + ((ang:Right()*-2)*(math.sin(CurTime()*0.5))), ang, 0.05)
				-- Current bet
				surface_setdrawcolor(black)
				surface_drawrect(-10, -20, biggestSize, 120)
				-- Border
				surface_setdrawcolor(white)
				surface_drawrect(-15, -25, biggestSize+10, 5)
				surface_drawrect(-15, -20, 5, 120)
				surface_drawrect(biggestSize-10, -20, 5, 120)
				surface_drawrect(-15, 100, biggestSize+10, 5)
				-- Current Bid
				draw_simpletext((PerfectCasino.Spins > 0) and PerfectCasino.Translation.UI.FreeSpin or PerfectCasino.Translation.UI.PurchaseASpin, "pCasino.Entity.Arrows", biggestSize*0.5-10, 37, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
				draw_simpletext((PerfectCasino.Spins > 0) and string.format(PerfectCasino.Translation.UI.FreeSpinCount, PerfectCasino.Spins) or PerfectCasino.Config.FormatMoney(self.data.buySpin.cost), "pCasino.Entity.Arrows", biggestSize*0.5-10, 37, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		cam.End3D2D()
	end
end
--PATH addons/_pcasino/lua/entities/pcasino_slot_machine/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.wheels = {}
	for i=1, 3 do
		local wheel = ClientsideModel("models/freeman/owain_slotmachine_reel.mdl")
		if IsValid(wheel) then
			self.wheels[i] = wheel
			wheel:SetParent(self)
			wheel:SetPos(self:GetPos()+(self:GetUp()*5.5)+(self:GetForward()*-10)+((self:GetRight()*-6)*(i-2)))
			wheel:SetAngles(self:GetAngles())
		end
	end

	self.active = false

	self.hasInitialized = true
end

function ENT:PostData()
	if not self.hasInitialized then
		self:Initialize()
	end
end

function ENT:OnRemove()
	for k, v in pairs(self.wheels) do
		if IsValid(v) then v:Remove() end
	end
end

local colorGold = Color(255, 200, 0)
local colorPurple = Color(255, 0, 255)
function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 25000 then return end

	if (not self.wheels) or (not self.wheels[1]) or (not IsValid(self.wheels[1])) then self:Initialize() return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end

	if not self.data then return end

	-- For ticking value
	self.curJackpot = math.Approach(self.curJackpot or self:GetCurrentJackpot(), self:GetCurrentJackpot(), math.Round((self.data.bet.default*5)*FrameTime()))

	-- Basic setups
	local pos = self:GetPos()
	local ang = self:GetAngles()
	
	ang:RotateAroundAxis(ang:Up(), 90)
	ang:RotateAroundAxis(ang:Forward(), 90)

	cam.Start3D2D(pos + (ang:Up()*-5.6) + (ang:Right()*-29.6), ang, 0.05)
		if tobool(self.data.jackpot.toggle) then
			draw.SimpleText(string.format(PerfectCasino.Translation.UI.JackPot, PerfectCasino.Config.FormatMoney(self.curJackpot)), "pCasino.Title.Static", 0, 0, (self.win and (self.win == 2)) and colorPurple or colorGold, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		else
			draw.SimpleText((math.ceil(CurTime())%2 == 1) and PerfectCasino.Translation.UI.ReadyToPlay or "", "pCasino.Title.Static", 0, 0, colorGold, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	cam.End3D2D()
	
	ang:RotateAroundAxis(ang:Forward(), -20)

	cam.Start3D2D(pos + (ang:Up()*1.9) + (ang:Right()*5.1) + (ang:Forward()*5.5), ang, 0.05)
		draw.SimpleText(PerfectCasino.Config.FormatMoney(self.data.bet.default), "pCasino.Textbox.Static", 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()
end

local cooldown = 0
function ENT:Think()
	if not self.active then return end
	if self.win then
		for i=1, 2 do
			local winLight = DynamicLight(self:EntIndex()+i)
			if winLight then
				winLight.pos = self:GetPos()+(self:GetUp()*13)+(self:GetForward()*-5)+((self:GetRight()*3)*(-3+(2*i)))
				winLight.r = (self.win == 2) and ((math.Round(CurTime()%1) == 1) and 100 or 0) or 100
				winLight.g = self.win == 2 and 0 or 100
				winLight.b = (self.win == 2) and 100 or 0 -- and ((math.Round(CurTime()%2) == 1) and
				winLight.brightness = 3
				winLight.Decay = 1000
				winLight.Size = 100
				winLight.DieTime = CurTime() + 1
			end
		end
	end

	for k, v in pairs(self.wheels) do
		if v.spinning then
			local ang = v:GetAngles()
			ang:RotateAroundAxis(v:GetRight(), -600*FrameTime())
			v:SetAngles(ang)
		elseif v.reject and (v.reject > 0) then
			local bump = math.Clamp(math.Round(300*FrameTime()), 1, v.reject)

			local ang = v:GetAngles()
			ang:RotateAroundAxis(v:GetRight(), bump)
			v:SetAngles(ang)
			v.reject = v.reject - bump
			if (k == 3) and (v.reject <= 0) and (not isnumber(self.win)) then
				self.active = false -- All the wheels are in the right place
			end
		end
	end
end

-- Game specific code
function ENT:StartSpinning(i)
	local wheel = self.wheels[i]
	if (not wheel) or (not IsValid(wheel)) then self:Initialize() return end

	local randomAng = self:GetAngles()
	randomAng:RotateAroundAxis(self:GetRight(), math.random(0, 360))
	wheel:SetAngles(randomAng)

	wheel.spinning = true
end

local resultCache = {}
resultCache["dollar"] = 0
resultCache["bell"] = 1
resultCache["melon"] = 2
resultCache["cherry"] = 3
resultCache["seven"] = 4
resultCache["clover"] = 5
resultCache["diamond"] = 6
resultCache["berry"] = 7

local snap = 360/table.Count(resultCache)
local offset = -35
local rejectionVaule = 20
function ENT:StopSpinning(i, result)
	local wheel = self.wheels[i]
	if (not wheel) or (not IsValid(wheel)) then self:Initialize() return end
	
	wheel.spinning = false

	if result then
		local angleResult = resultCache[result] * snap - offset

		local ang = self:GetAngles()
		ang:RotateAroundAxis(wheel:GetRight(), angleResult-rejectionVaule)
		wheel:SetAngles(ang)

		wheel.reject = rejectionVaule
	end
end

function ENT:StartWin(winData)
	-- 2 is jackpot, 1 is normal win
	self.win = (tobool(winData.j) and tobool(self.data.jackpot.toggle)) and 2 or 1
end

function ENT:EndWin()
	self.active = false
	self.win = nil
end

net.Receive("pCasino:BasicSlot:Spin:Start", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if entity:GetPos():DistToSqr(LocalPlayer():GetPos()) > 500000 then return end
	if not entity.data then return end

	entity.active = true

	for i=1, 3 do
		entity:StartSpinning(i)
	end
end)

net.Receive("pCasino:BasicSlot:Spin:Stop", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.active then return end
	if not entity.data then return end

	local key = net.ReadUInt(2)
	local result = net.ReadString()
	entity:StopSpinning(key, result)
end)

net.Receive("pCasino:BasicSlot:Spin:Win", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.active then return end
	if not entity.data then return end

	local winData = net.ReadTable()
	entity:StartWin(winData)

	timer.Simple((tobool(winData.j) and tobool(entity.data.jackpot.toggle)) and 5 or 2, function()
		if not IsValid(entity) then return end
		entity:EndWin()
	end)
end)
--PATH addons/__main/lua/entities/savav_meth/shared.lua:
ENT.Base = "base_anim"
ENT.Type = "anim"

ENT.PrintName		= "Meth"
ENT.Author			= "SaVav"
ENT.Category 		= "SaVav's trash"
ENT.Contact    		= ""
ENT.Purpose 		= "take it"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true


--PATH addons/__________skeypads/lua/entities/skeypad_cracker/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "sKeypad Cracker"
ENT.Category = "sKeypads"
ENT.Author = "Tom.bat & NoSharp"
ENT.Spawnable = false
ENT.AdminOnly = false
ENT.noDrag = true
--PATH gamemodes/darkrp/entities/entities/spawned_npc_quest/cl_init.lua:
include("Shared.lua")


local ipairs 		= ipairs
local CurTime 		= CurTime 
local LocalPlayer 	= LocalPlayer
local math_sin 		= math.sin
local math_pi 		= math.pi
local cam_Start3D2D	= cam.Start3D2D
local cam_End3D2D	= cam.End3D2D
local draw_SimpleTextOutlined = draw.SimpleTextOutlined
local ents_FindByClass = ents.FindByClass

local vec = Vector(0,-1,82)

local color_white = Color(200,0,0)
local color_black = Color(0,0,0)


local function Draw(self)
	local pos = self:GetPos()
	local ang = self:GetAngles()
	local dist = pos:Distance(LocalPlayer():GetPos())
	

		self:DrawModel()		

		if (dist > 350) then return end
		
		color_white.a = 350 - dist
		color_black.a = 350 - dist

		ang:RotateAroundAxis(ang:Forward(), 90)
		ang:RotateAroundAxis(ang:Right(), -90)
		
		ang:RotateAroundAxis(ang:Right(), math_sin(CurTime() * math_pi) * -45)
		
		//cam_Start3D2D(pos + vec + ang:Right() * 1.2, ang, 0.065)
		//	draw.ShadowText('Заказать убийство', 'Roboto_150', 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, color_black)
		//cam_End3D2D()
		//
		ang:RotateAroundAxis(ang:Right(), 180)
		
		//cam_Start3D2D(pos + vec + ang:Right() * 1.2, ang, 0.065)
		//	draw_SimpleTextOutlined('Заказать убийство', 'Roboto_150', 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, color_black)		
		//cam_End3D2D()

end

function ENT:Draw()
	Draw(self)
end

--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_battery/cl_init.lua:
include("shared.lua")

local grn = Color(0, 0, 0, 255)
local xpos = 50
local ypos = 30
function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	if self:GetPos():Distance(LocalPlayer():GetPos()) > 500 then return end
	local ang = LocalPlayer():EyeAngles()
	local pos = self:GetPos() + Vector(0,0,10)

	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), 90)

	cam.Start3D2D(pos, ang, 0.06)
		-- Background
		draw.RoundedBox(0, xpos, ypos+0, 475, 120, Color(0, 0, 0, 225))
		-- Side bar
		draw.RoundedBox(0, xpos, ypos+0, 10, 120, grn)
	
		draw.SimpleText(string.upper(UWeed.Translation.Battery.Title), "uweed_font_80", xpos+10, ypos+35, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

		draw.SimpleText(UWeed.Translation.Battery.Restore, "uweed_font_60", xpos+10, ypos+90, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

	cam.End3D2D()
end
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_bud/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "[UWeed] Bud"
ENT.Author = "Owain Owjo"
ENT.Category = "UWeed"
ENT.Spawnable = true
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.AdminSpawnable = true

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "owning_ent")
	self:NetworkVar("Int", 0, "BudCounter")
	self:NetworkVar("Int", 1, "EstimateHigher")
	self:NetworkVar("Int", 1, "EstimateLower")
end
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_scale/cl_init.lua:
include("shared.lua")

local grn = Color(0, 0, 0, 255)
local xpos = 0
local ypos = 80
function ENT:Draw()
	self:DrawModel()
	local ang = self:GetAngles()
	local pos = self:GetPos() + (self:GetUp()*0.5)

	ang:RotateAroundAxis(ang:Forward(), 180)
	ang:RotateAroundAxis(ang:Right(), 180)
	ang:RotateAroundAxis(ang:Up(), 90)

	cam.Start3D2D(pos, ang, 0.06)
		-- Background
		--draw.RoundedBox(0, xpos, ypos+0, 380, 120, Color(0, 0, 0, 225))
		-- Side bar
		--draw.RoundedBox(0, xpos, ypos+0, 10, 120, grn)
		if self:GetCurrentBag() == NULL then
			draw.SimpleText(UWeed.Translation.Scale.NoBag, "uweed_font_30", xpos, ypos, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		else
			draw.SimpleText(self:GetCurrentBag():GetBudCounter()..UWeed.Translation.Scale.Gram, "uweed_font_30", xpos, ypos, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	cam.End3D2D()
end
--PATH addons/_avatar/lua/effects/ambeam_2.lua:
--[[---------------------------------------------------------
	EFFECT:Init(data)
---------------------------------------------------------]]
function EFFECT:Init( data )
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos( data:GetOrigin(), self.WeaponEnt, self.Attachment )
	self.Forward = data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.Up = self.Angle:Up()
	if not IsValid( self.WeaponEnt ) or not IsValid( self.WeaponEnt:GetOwner() ) then return end
	local emitter = ParticleEmitter( self.Position )
	local particle = emitter:Add( "sprites/ar2_muzzle" .. math.random( 3, 4 ), self.Position + 8 * self.Forward )
	particle:SetVelocity( 350 * self.Forward + 1.1 * self.WeaponEnt:GetOwner():GetVelocity() )
	particle:SetAirResistance( 160 )
	particle:SetDieTime( math.Rand( 0, 0.05 ) )
	particle:SetStartAlpha( 255 )
	particle:SetEndAlpha( 255 )
	particle:SetStartSize( 0 )
	particle:SetEndSize( 15 )
	particle:SetRoll( math.Rand( 180, 480 ) )
	particle:SetRollDelta( math.Rand( -1, 1 ) )
	particle:SetColor( 255, 92, 92 )
	particle = emitter:Add( "effects/redflare", self.Position + 8 * self.Forward )
	particle:SetVelocity( 350 * self.Forward + 1.1 * self.WeaponEnt:GetOwner():GetVelocity() )
	particle:SetAirResistance( 160 )
	particle:SetDieTime( 0.04 )
	particle:SetStartAlpha( 255 )
	particle:SetEndAlpha( 255 )
	particle:SetStartSize( 5 )
	particle:SetEndSize( 20 )
	particle:SetRoll( math.Rand( 180, 480 ) )
	particle:SetRollDelta( math.Rand( -1, 1 ) )
	particle:SetColor( 255, 255, 255 )
	particle = emitter:Add( "effects/redflare", self.Position + 8 * self.Forward )
	particle:SetVelocity( 350 * self.Forward + 1.1 * self.WeaponEnt:GetOwner():GetVelocity() )
	particle:SetAirResistance( 160 )
	particle:SetDieTime( 0.04 )
	particle:SetStartAlpha( 255 )
	particle:SetEndAlpha( 255 )
	particle:SetStartSize( 15 )
	particle:SetEndSize( 20 )
	particle:SetRoll( math.Rand( 180, 480 ) )
	particle:SetRollDelta( math.Rand( -1, 1 ) )
	particle:SetColor( 255, 255, 255 )
	particle = emitter:Add( "effects/redflare", self.Position )
	particle:SetVelocity( 100 * self.Forward + 8 * VectorRand() ) -- + AddVel)
	particle:SetAirResistance( 400 )
	particle:SetGravity( Vector( 0, 0, math.Rand( 25, 100 ) ) )
	particle:SetDieTime( math.Rand( 0, 1 ) )
	particle:SetStartAlpha( 255 )
	particle:SetEndAlpha( 255 )
	particle:SetStartSize( math.Rand( 10, 13 ) )
	particle:SetEndSize( 0 )
	particle:SetRoll( math.Rand( -25, 25 ) )
	particle:SetRollDelta( math.Rand( -0.05, 0.05 ) )
	particle:SetColor( 255, 255, 255 )
	emitter:Finish()
end

--[[---------------------------------------------------------
	EFFECT:Think()
---------------------------------------------------------]]
function EFFECT:Think()
	return false
end

--[[---------------------------------------------------------
	EFFECT:Render()
---------------------------------------------------------]]
function EFFECT:Render()
end
--PATH addons/_farmer/lua/effects/ba_cage_eat.lua:
--[[
	Just a first attempt in effect.
	Green text just makes me feel better.
]]--

function EFFECT:Init(data)
	
	local offset = data:GetOrigin();
	
	sound.Play("npc/barnacle/barnacle_crunch"..math.random(2, 3)..".wav", offset, 70);
	
	local particlesAmount = math.random(16, 32);
	local emitter = ParticleEmitter(offset, false);
		for i=0, particlesAmount do
			local particle = emitter:Add("decals/blood"..math.random(1, 8), offset);
			
			if (particle) then
				
				particle:SetVelocity(Vector(math.random(-16, 16), math.random(-16, 16), math.random(-16, 16)));
				
				particle:SetLifeTime(0);
				particle:SetDieTime(1);
				
				particle:SetStartAlpha(255);
				particle:SetEndAlpha(64);
				
				particle:SetStartSize(math.random(4, 6));
				particle:SetEndSize(math.random(1, 2));
				
				particle:SetRoll(math.random(180, 480));
				particle:SetRollDelta(math.random(-2, 2));
				
				particle:SetAirResistance(0);
				particle:SetGravity(Vector(0, 0, -128));
				
				particle:SetColor(255, 200, 0);
				
				particle:SetCollide(true);
				particle:SetBounce(1);
				
				particle:SetAngleVelocity(Angle(math.random(-2, 2), math.random(-2, 2), math.random(-2, 2)));
				
				particle:SetLighting(true);
			end;
		end;
	emitter:Finish();
end;


function EFFECT:Think()
	return false;
end;


function EFFECT:Render()

end;

--PATH addons/_drones/lua/effects/dronesrewrite_explosion.lua:
AddCSLuaFile()

function EFFECT:Init(data)
	self.Start = data:GetOrigin()
	self.size = 4000

	self.Emitter = ParticleEmitter(self.Start)
	
	for i = 1, 30 do
		local vec = VectorRand()
		local p = self.Emitter:Add("effects/fleck_cement" .. math.random(1, 2), self.Start)

		p:SetDieTime(math.random(1, 15))
		p:SetStartAlpha(math.random(50, 150))
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(1, 3))
		p:SetRoll(math.Rand(-10, 10))
		p:SetRollDelta(math.Rand(-10, 10))
		p:SetEndSize(0)		
		p:SetVelocity(vec * 450)
		p:SetGravity(Vector(0, 0, -50))
		p:SetColor(0, 0, 0)
	end

	for i = 1, 10 do
		local vec = VectorRand()
		local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(1, 9), self.Start + vec)

		p:SetDieTime(math.random(2, 3))
		p:SetStartAlpha(math.random(50, 150))
		p:SetEndAlpha(0)
		p:SetStartSize(20)
		--p:SetRoll(math.Rand(-10, 10))
		p:SetRollDelta(math.Rand(-1, 1))
		p:SetEndSize(80)		
		p:SetVelocity(vec * 40)
		p:SetGravity(Vector(0, 0, 20))
		p:SetCollide(true)
		p:SetColor(50, 50, 20)
	end

	for i = 3, math.random(3, 6) do
		local vec = VectorRand()

		for a = 1, math.random(4, 8) do
			local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(1, 3), self.Start + vec * 15)

			p:SetDieTime(math.Rand(0.6, 1.5))
			p:SetStartAlpha(math.random(40, 80))
			p:SetEndAlpha(0)
			p:SetStartSize(20)
			p:SetRoll(math.Rand(-180, 180))
			--p:SetRollDelta(math.Rand(-1, 1))
			p:SetEndSize(150)		
			p:SetVelocity(((self.Start + vec * a * 15) - self.Start):GetNormal() * a * 200)
			p:SetAirResistance(300 + a * 20)
			p:SetCollide(true)
			p:SetColor(0, 0, 0)

			local p = self.Emitter:Add("particles/fir21", self.Start + vec * a * math.Rand(10, 18) + VectorRand() * 40)

			p:SetDieTime(0.05)
			p:SetStartAlpha(40)
			p:SetEndAlpha(0)
			p:SetStartSize(20)
			p:SetRoll(math.Rand(-10, 10))
			p:SetRollDelta(math.Rand(-1, 1))
			p:SetEndSize(70)		
			p:SetVelocity(((self.Start + vec * a * 15) - self.Start):GetNormal() * 500)
			p:SetAirResistance(20)
			p:SetColor(200, 150, 0)
		end
	end

	for i = 1, 30 do
		local vec = VectorRand()
		local p = self.Emitter:Add("particles/fir21", self.Start + vec * 25)

		p:SetDieTime(0.1)
		p:SetStartAlpha(60)
		p:SetEndAlpha(0)
		p:SetStartSize(20)
		p:SetRoll(math.Rand(-10, 10))
		p:SetRollDelta(math.Rand(-0.5, 0.5))
		p:SetEndSize(60)		
		p:SetVelocity(vec * 155)
		p:SetAirResistance(40)
		p:SetColor(255, 200, 0)
	end	
	
	self.Emitter:Finish()
end

function EFFECT:Think()
	self.size = self.size - 500

	return self.size > 0
end

function EFFECT:Render()
	render.SetMaterial(Material("sprites/light_ignorez"))
	render.DrawSprite(self.Start, self.size*2, self.size, Color(255, 100, 0, 50))
end






--PATH addons/_drones/lua/effects/dronesrewrite_missilelaunch.lua:
AddCSLuaFile()

function EFFECT:Init(data)
	self.Start = data:GetOrigin()
	self.Forward = data:GetNormal()

	self.Emitter = ParticleEmitter(self.Start)

	local dlight = DynamicLight(self:EntIndex())
	if dlight then
		dlight.pos = self.Start
		dlight.r = 255
		dlight.g = 50
		dlight.b = 0
		dlight.brightness = 1
		dlight.Decay = 1
		dlight.Size = math.random(150, 300)
		dlight.DieTime = CurTime()
	end

	local p = self.Emitter:Add("sprites/heatwave", self.Start - self.Forward * 70)
	p:SetVelocity(self.Forward * 60 + VectorRand() * 20)
	p:SetAirResistance(200)
	p:SetDieTime(math.Rand(0.1, 0.3))
	p:SetStartSize(150)
	p:SetEndSize(0)
	p:SetRoll(math.Rand(180, 480))
	p:SetRollDelta(math.Rand(-4, 4))

	for i = 1, 16 do
		local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(1, 9), self.Start - self.Forward * 6 * i)

		p:SetAirResistance(400)
		p:SetVelocity(-self.Forward * 300 + VectorRand() * 5)
		p:SetGravity(Vector(0, 0, 10))
		p:SetDieTime(math.Rand(2, 3) - i * 0.3)
		p:SetStartAlpha(150)
		p:SetEndAlpha(0)
		p:SetStartSize(0)
		p:SetEndSize(25)
		p:SetRollDelta(math.Rand(-1, 1))
		p:SetColor(80, 80, 80)
	end

	for i = 1, 40 do
		local p = self.Emitter:Add("effects/muzzleflash"..math.random(1, 4), self.Start - self.Forward * (45 + i * 1.3))

		p:SetVelocity(-self.Forward * i * 3 + VectorRand() * 2)

		p:SetDieTime(i * 0.005)

		p:SetStartAlpha(255)

		p:SetStartSize(50 - i)
		p:SetEndSize(0)

		p:SetRollDelta(math.Rand(-2, 2))

		p:SetColor(255, 255, 255)	
	end
	
	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end






--PATH addons/_drones/lua/effects/dronesrewrite_muzzleflashblaster5.lua:
AddCSLuaFile()

function EFFECT:Init(data)
	self.Start = data:GetOrigin()
	self.Forward = data:GetNormal()

	self.Emitter = ParticleEmitter(self.Start)

	local dlight = DynamicLight(self:EntIndex())
	if dlight then
		dlight.pos = self.Start
		dlight.r = 255
		dlight.g = 255
		dlight.b = 0
		dlight.brightness = 1
		dlight.Decay = 1
		dlight.Size = math.random(150, 300)
		dlight.DieTime = CurTime()
	end

	local p = self.Emitter:Add("sprites/heatwave", self.Start - self.Forward * 2)
	p:SetVelocity(120 * self.Forward + 20 * VectorRand() * 2)
	p:SetGravity(Vector(0, 0, 100))
	p:SetAirResistance(160)
	p:SetDieTime(math.Rand(0.1, 0.15))
	p:SetStartSize(30)
	p:SetEndSize(0)
	p:SetRoll(math.Rand(180, 480))
	p:SetRollDelta(math.Rand(-1, 1))

	for a = 1, 12 do
		for i = 1, 4 do
			local p = self.Emitter:Add("sprites/light_glow02_add", self.Start + i * 4 * self.Forward)

			p:SetAirResistance(200)
			p:SetVelocity(6 * VectorRand())
			p:SetDieTime(math.Rand(0.05, 0.15))
			p:SetStartAlpha(155)
			p:SetStartSize(0)
			p:SetEndSize(34 - i * 6)
			p:SetRoll(math.Rand(180, 480))
			p:SetRollDelta(math.Rand(-1, 1))
			p:SetColor(255, 255, 0)	
		end
	end
	
	for i = 1, 4 do
		local p = self.Emitter:Add("sprites/light_glow02_add", self.Start + i * 4 * self.Forward)

		p:SetAirResistance(200)
		p:SetVelocity(6 * VectorRand())
		p:SetDieTime(math.Rand(0.05, 0.15))
		p:SetStartAlpha(155)
		p:SetStartSize(0)
		p:SetEndSize(34 - i * 6)
		p:SetRoll(math.Rand(180, 480))
		p:SetRollDelta(math.Rand(-1, 1))
		p:SetColor(255, 255, 255)	
	end
	
	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end





--PATH addons/_drones/lua/effects/dronesrewrite_muzzleflashplasma.lua:
AddCSLuaFile()

function EFFECT:Init(data)
	self.Start = data:GetOrigin()
	self.Forward = data:GetNormal()

	self.Emitter = ParticleEmitter(self.Start)

	local dlight = DynamicLight(self:EntIndex())
	if dlight then
		dlight.pos = self.Start
		dlight.r = 0
		dlight.g = 255
		dlight.b = 255
		dlight.brightness = 1
		dlight.Decay = 1
		dlight.Size = math.random(150, 300)
		dlight.DieTime = CurTime()
	end

	local p = self.Emitter:Add("sprites/heatwave", self.Start - self.Forward * 2)
	p:SetVelocity(120 * self.Forward + 20 * VectorRand() * 2)
	p:SetGravity(Vector(0, 0, 100))
	p:SetAirResistance(160)
	p:SetDieTime(math.Rand(0.1, 0.15))
	p:SetStartSize(30)
	p:SetEndSize(0)
	p:SetRoll(math.Rand(180, 480))
	p:SetRollDelta(math.Rand(-1, 1))

	for i = 1, 4 do
		local p = self.Emitter:Add("effects/muzzleflash"..math.random(1, 4), self.Start + i * 5 * self.Forward)

		p:SetAirResistance(200)
		p:SetVelocity(20 * VectorRand())

		p:SetDieTime(math.Rand(0.1, 0.3))

		p:SetStartAlpha(220)

		p:SetStartSize(i ^ 2)
		p:SetEndSize(0)

		p:SetRoll(math.Rand(180, 480))
		p:SetRollDelta(math.Rand(-1, 1))

		p:SetColor(0, 255, 255)	
	end
	
	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end






--PATH addons/__main/lua/effects/durgz_weed_smoke/init.lua:
local function randn(x)
	return math.Rand(-x, x);
end
function EFFECT:Init(data)
	local e = ParticleEmitter( data:GetOrigin() );
		for i=1, 10 do
			--declare variablez
			local smokesize = 1;
			local pos = Vector(randn(1), randn(1), randn(smokesize) + 60);
			local p = e:Add( "particle/particle_smokegrenade", data:GetOrigin() + pos );
			if (p) then
				local gravsideways = randn(0.1);
				local shade = math.random(220,240);
				--set the stuff
				p:SetVelocity(VectorRand() * math.Rand(2000,2300));
				
				p:SetLifeTime(0);
				p:SetDieTime(math.Rand(3,4));
				
				p:SetColor(shade,shade,shade);
				p:SetStartAlpha(math.Rand(160,180));
				p:SetEndAlpha(0);
				
				p:SetStartSize(math.Rand(20,25));
				p:SetEndSize(math.Rand(10, 15));
				
				p:SetRoll(math.Rand(-180, 180));
				p:SetRollDelta(math.Rand(-0.2,0.2));
				
				p:SetAirResistance(math.Rand(520,620));
				p:SetGravity(   Vector( gravsideways, gravsideways, math.Rand(-60, -80) )    );

				p:SetCollide( true );
				p:SetBounce( 0.42 );

				p:SetLighting(1);
			end
		end
		
	e:Finish()
	
end

function EFFECT:Think( )
	return false
end
function EFFECT:Render()
end


--PATH addons/lvs_base-main/lua/effects/lvs_engine_blacksmoke.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin() + VectorRand() * 25
	local Ent = data:GetEntity()

	if not IsValid( Ent ) then return end

	local emitter = Ent:GetParticleEmitter( Pos )

	if not IsValid( emitter ) then return end

	local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], Pos )
	
	if particle then
		particle:SetVelocity( VectorRand() * 100 )
		particle:SetDieTime( 2 )
		particle:SetAirResistance( 600 ) 
		particle:SetStartAlpha( 50 )
		particle:SetStartSize( 60 )
		particle:SetEndSize( 200 )
		particle:SetRoll( math.Rand(-1,1) * math.pi )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( 60, 60, 60 )
		particle:SetGravity( Vector( 0, 0, 600 ) )
		particle:SetCollide( false )
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH addons/lvs_base-main/lua/effects/lvs_explosion_small.lua:

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.LifeTime = 0.35
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	for i = 0, 15 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 1000 )
			particle:SetDieTime( math.Rand(2,3) )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 200 )
			particle:SetStartSize( 120 )
			particle:SetEndSize( 300 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( 50,50,50 )
			particle:SetGravity( Vector( 0, 0, 600 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 15 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( math.Rand(0.15,0.3) )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 25 )
			particle:SetEndSize( math.Rand(70,100) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/rico1", self.Pos )
		
		local vel = VectorRand() * 800
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(20,40) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( 0 )
			particle:SetColor( 255, 255, 255 )

			particle:SetAirResistance( 0 )
		end
	end

	emitter:Finish()

	local Pos = self.Pos
	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		if delay <= 0.11 then
			sound.Play( "ambient/explosions/explode_9.wav", Pos, 85, 100, 1 - delay * 8 )
		end

		timer.Simple( delay, function()
			sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 2000 * Scale, 2000 * Scale, Color( 255, 200, 150, 255) )
end

--PATH addons/____inventory/lua/itemstore/cl_init.lua:
include( "shared.lua" )

include( "cl_gui.lua" )
include( "cl_player.lua" )
--PATH addons/____inventory/lua/itemstore/languages/ua.lua:
-- T

LANGUAGE.ok = "OK"
LANGUAGE.cancel = "Відміна"
LANGUAGE.not_permitted = "У вас немає доступу до цієї дії."
LANGUAGE.file_not_found = "Файл не знайдено"
LANGUAGE.player_not_found = "Гравця не знайдено"
LANGUAGE.invalid_data = "Неправильні дані"
LANGUAGE.invalid_args = "Неправильні аргументи"
LANGUAGE.cant_fit = "Це не поміститься в ваш інвентар!"


LANGUAGE.page = "Сторінка %d"
LANGUAGE.inventory = "Інвентар"
LANGUAGE.bank = "Банк"
LANGUAGE.players_inventory = "Інвентарь %s"
LANGUAGE.players_bank = "Банк %s"
LANGUAGE.admin_title = "ItemStore Адмін"


LANGUAGE.move = "Перемістити"
LANGUAGE.use = "Використати"
LANGUAGE.usewith = "Використовувати з ..."
LANGUAGE.drop = "Викинути"
LANGUAGE.destroy = "Знищити"
LANGUAGE.merge = "Поєднати"
LANGUAGE.split = "Розділити"
LANGUAGE.split_half = "Поділити навпіл (%d)"


LANGUAGE.picked_up = "Ви підняли (n) %s."


LANGUAGE.destroy_title = "Знищити предмет"
LANGUAGE.destroy_confirmation = "Ви впевнені що хочете видалити предмет? Ця дія незворотна!"


LANGUAGE.ready = "Готово"
LANGUAGE.not_ready = "не готово"
LANGUAGE.accept = "Прийняти"
LANGUAGE.deny = "Відмовитися"
LANGUAGE.trading_with = "Обмін з %s"
LANGUAGE.trade_request = "Запит обміну"
LANGUAGE.wants_to_trade = "%s хоче обмінятися"
LANGUAGE.too_far_away = "Ви занадто далеко, щоб обмінюватися."
LANGUAGE.trading_cooldown = "Ви повинні трохи почекати, щоб обмінюватися знову."


LANGUAGE.trade_failed = "Обмін не заверешено. Ви або ваш партнер вимагали більше грошей, ніж у вас/в нього є!"
LANGUAGE.cant_access_inventory = "Ви не можете торгувати, якщо не маєте доступу до інвентарю."
LANGUAGE.partner_cant_access_inventory = "Ви не можете торгувати з партнером, який не має доступу до інвентарю."
LANGUAGE.partner_is_in_trade = "Ви не можете торгувати з партнером, який вже бере участь в угоді."
LANGUAGE.already_in_trade = "Ви вже торгуєте з кимось іншим."
--PATH addons/____inventory/lua/itemstore/gamemodes.lua:
itemstore.gamemodes = {}

PROVIDER = {}
include( "gamemodeproviders/" .. itemstore.config.GamemodeProvider .. ".lua" )
if SERVER then AddCSLuaFile( "gamemodeproviders/" .. itemstore.config.GamemodeProvider .. ".lua" ) end
itemstore.gamemodes.Provider = PROVIDER
PROVIDER = nil

assert( itemstore.gamemodes.Provider, "[ItemStore] Gamemode provider not found" )

function itemstore.gamemodes.Run( func_name, ... )
	local func = itemstore.gamemodes.Provider[ func_name ]
	if not func then return end

	return func( itemstore.gamemodes.Provider, ... )
end

function itemstore.gamemodes.GetMoney( pl )
	return itemstore.gamemodes.Run( "GetMoney", pl )
end

if SERVER then
	function itemstore.gamemodes.SetMoney( pl, money )
		return itemstore.gamemodes.Run( "SetMoney", pl, money )
	end

	function itemstore.gamemodes.GiveMoney( pl, money )
		return itemstore.gamemodes.SetMoney( pl, itemstore.gamemodes.GetMoney( pl ) + money )
	end

	function itemstore.gamemodes.AddCommand( command, info, func )
		return itemstore.gamemodes.Run( "AddCommand", command, info, func )
	end

	itemstore.AddCommand( "trade", function( pl, args )
		args = table.concat( args, " " )

		if not pl:CanUseInventory() then
			pl:ChatPrint( itemstore.Translate( "cant_access_inventory" ) )
			return
		end

		if not itemstore.config.TradingEnabled then
			return
		end

		if pl.TradingCooldown and pl.TradingCooldown > CurTime() then
			pl:ChatPrint( itemstore.Translate( "trading_cooldown" ) )
			return
		end

		local target = pl:GetEyeTrace().Entity

		if args ~= "" then
			for _, pl in ipairs( player.GetAll() ) do
				if string.find( string.lower( pl:Name() ), string.lower( args ), 1, true ) then
					target = pl
				end
			end
		end

		if not IsValid( target ) or not target:IsPlayer() then
			pl:ChatPrint( itemstore.Translate( "player_not_found" ) )
			return
		end

		if not target:CanUseInventory() then
			pl:ChatPrint( itemstore.Translate( "partner_cant_access_inventory" ) )
			return
		end

		if pl.Trade then
			pl:ChatPrint( itemstore.Translate( "already_in_trade" ) )
			return
		end

		if target.Trade then
			pl:ChatPrint( itemstore.Translate( "partner_is_in_trade" ) )
			return
		end

		if itemstore.config.TradeDistance ~= 0 and pl:GetPos():Distance( target:GetPos() ) > itemstore.config.TradeDistance then
			pl:ChatPrint( itemstore.Translate( "too_far_away" ) )
			return
		end

		itemstore.Trade( pl, target )

		pl.TradingCooldown = CurTime() + itemstore.config.TradeCooldown
	end )

	itemstore.AddCommand( "inv", function( pl )
		pl:OpenContainer( pl.Inventory:GetID(), itemstore.Translate( "inventory" ), true )
	end )

	itemstore.AddCommand( "pickup", function( pl )
		pl:PickupItem()
	end )
end

hook.Add( "PostGamemodeLoaded", "ItemStoreGamemodeLoad", function()
	itemstore.gamemodes.Run( "Load" )
end )

--PATH addons/____inventory/lua/itemstore/gamemodeproviders/darkrp.lua:
function PROVIDER:GetMoney( pl )
	return pl:GetMoney()
end

if SERVER then
	function PROVIDER:SetMoney( pl, money )
		pl:SetMoney( money )
	end

	if itemstore.config.EnableInvholster then
		itemstore.AddCommand( "invholster", function( pl, args )
			if not pl:CanUseInventory() then return end

			local wep = pl:GetActiveWeapon()
			if not IsValid( wep ) then return end

			if not wep:GetModel() or wep:GetModel() == "" then
				rp.Notify(pl, 1, 'Не можу кинути цю зброю!')
				return
			end

			if itemstore.config.DisabledItems[ wep:GetClass() ] then
				rp.Notify(pl, 1, 'Не можу кинути цю зброю!')
				return
			end

			if itemstore.config.InvholsterDisabled[ wep:GetClass() ] then
				rp.Notify(pl, 1, 'Не можу кинути цю зброю!')
				return
			end

			local canDrop = hook.Call("canDropWeapon", GAMEMODE, pl, wep)
			if not canDrop then
				rp.Notify(pl, 1, 'Не можу кинути цю зброю!')
				return
			end
			-- and back to our regularly scheduled coding

			local item = itemstore.Item( "spawned_weapon" )

			item:SetData( "Class", wep:GetClass() )
			item:SetData( "Amount", 1 )
			item:SetData( "Model", wep:GetModel() )
			item:SetData( "Clip1", wep:Clip1() )
			item:SetData( "Clip2", wep:Clip2() )

			if not pl.Inventory:CanFit( item ) then
				rp.Notify(pl, 1, 'Ваш інвентар повний!')
				return 
			end

			if itemstore.config.InvholsterTakesAmmo then
				local ammotype = wep:GetPrimaryAmmoType()

				if ammotype and ammotype ~= "none" then -- to be entirely honest I'm not sure if it returns nil or "none"
					local ammo = pl:GetAmmoCount( ammotype )

					item:SetData( "Ammo", ammo )
					pl:RemoveAmmo( ammo, ammotype )
				end
			end

			pl:StripWeapon( wep:GetClass() )
			pl.Inventory:AddItem( item )
		end )
	end
end
--PATH addons/____inventory/lua/itemstore/items.lua:
itemstore.items = {}
itemstore.items.Registered = {}
itemstore.items.Pickups = {}

local Item = {}
Item.ItemStore = true
Item.Name = "Invalid Item"
--Item.Description = "Invalid Description"
Item.Model = "models/error.mdl"
--Item.Skin = 0
--Item.Color = nil
--Item.Material = nil
Item.HighlightColor = itemstore.config.HighlightColours.Other

Item.Stackable = false
Item.Amount = 1
Item.MaxStack = itemstore.config.MaxStack
Item.DropStack = false

Item.DontNetwork = {}

function Item:GetClass()
	return self.Class
end

function Item:IsValid()
	return true
end

function Item:Run( func_name, ... )
	local func = self[ func_name ]

	if type( func ) ~= "function" then return end

	return func( self, ... )
end

function Item:Load()
end

function Item:Initialize()
end

function Item:GetContainer()
	local con = self.Container
	if not con then return end

	local slot = self.Slot
	if not slot then return end

	if con:GetItem( slot ) == self then
		return self.Container
	end
end

function Item:GetSlot()
	local con = self.Container
	if not con then return end

	local slot = self.Slot
	if not slot then return end

	if con:GetItem( slot ) == self then
		return self.Slot
	end
end

function Item:Copy()
	return itemstore.Item( self:GetClass(), table.Copy( self.Data ) )
end

function Item:RegisterPickup( ent_class )
	itemstore.items.Pickups[ ent_class ] = self:GetClass()
end

function Item:GetData( key, default )
	return self.Data[ key ] == nil and default or self.Data[ key ]
end

function Item:SetData( key, value )
	self.Data[ key ] = value
end

function Item:CreateMutator( key, default )
	self[ "Set" .. key ] = function( self, value )
		self:SetData( key, value )
	end

	self[ "Get" .. key ] = function( self, default )
		return self:GetData( key, default or self[ key ] )
	end
end

Item:CreateMutator( "Name" )
Item:CreateMutator( "Description" )
Item:CreateMutator( "Model" )
Item:CreateMutator( "Material" )
Item:CreateMutator( "Skin" )
Item:CreateMutator( "Color" )
Item:CreateMutator( "MaxStack" )
Item:CreateMutator( "Amount" )

function Item:GetStaticName()
	return self.StaticName or self.Name
end

function Item:Pickup( pl, con, slot, ent )
end

function Item:Drop( pl, con, slot, ent )
end

function Item:Destroy( pl, con, slot )
end

function Item:TakeOne()
	self:SetAmount( self:GetAmount() - 1 )

	if self:GetAmount() <= 0 then
		return true
	end

	return false
end

function Item:CanPickup()
	return true
end

function Item:CanUseWith( item )
	return false
end

function Item:CanMerge( item )
	return self.Stackable and item.Stackable and self:GetClass() == item:GetClass()
		and ( self:GetAmount() + item:GetAmount() ) <= self:GetMaxStack()
end

function Item:Merge( item )
	self:SetAmount( self:GetAmount() + item:GetAmount() )
end

function Item:CanSplit( amount )
	return self.Stackable and self:GetAmount() > amount
end

function Item:Split( amount )
	self:SetAmount( self:GetAmount() - amount )

	local item = self:Copy()
	item:SetAmount( amount )

	return item
end

function Item:FormatAmount()
	return "x" .. self:GetAmount()
end

function Item:CreateEntity( pos )
	local ent = ents.Create( "itemstore_item" )
	ent:SetPos( pos )
	self:LoadData( ent )
	ent:Spawn()

	return ent
end

function Item:SaveData( ent )
end

function Item:LoadData( ent )
	ent:SetItem( self )
end

function Item:WriteNetworkData()
	local data = {}

	for k, v in pairs( self.Data ) do
		if not self.DontNetwork[ k ] then data[ k ] = v end
	end

	net.WriteUInt( table.Count( data ), 8 )

	for k, v in pairs( data ) do
		net.WriteString( k )

		local status, err = pcall( function()
			net.WriteType( v )
		end )

		-- probably better to write nothing than error out here
		if not status then
			net.WriteType( nil )
		end
	end
end

function Item:ReadNetworkData()
	for i = 1, net.ReadUInt( 8 ) do
		self:SetData( net.ReadString(), net.ReadType() )
	end
end

function Item:PreRender( ent )
end

function Item:PostRender( ent )
end

function itemstore.Item( class_name, data )
	local class = itemstore.items.Registered[ class_name ]

	if class then
		local item = {
			Class = class_name,
			Data = data or {}
		}

		setmetatable( item, { __index = class } )

		item:Initialize()

		return item
	end
end

function itemstore.items.Get( class )
	return itemstore.items.Registered[ class ]
end

function itemstore.items.Exists( class )
	return itemstore.items.Registered[ class ] ~= nil
end

function itemstore.items.Definition( name )
	local item = setmetatable( {}, { __index = Item } )
	item.Class = name

	return item
end

function itemstore.items.Register( item )
	if SERVER then util.AddNetworkString( item.Class ) end
	itemstore.items.Registered[ item.Class ] = item
end

function itemstore.items.Load()
	for _, filename in ipairs( file.Find( "itemstore/items/*.lua", "LUA" ) ) do
		local name = string.match( filename, "^(.+).lua$" )

		if name then
			ITEM = itemstore.items.Definition( name )

			if SERVER then AddCSLuaFile( "itemstore/items/" .. filename ) end
			include( "itemstore/items/" .. filename )

			itemstore.items.Register( ITEM )

			ITEM = nil
		end
	end

	for k, v in pairs( itemstore.config.CustomItems ) do
		local ITEM = itemstore.items.Definition( k )

		ITEM.Name = v[ 1 ]
		ITEM.Description = v[ 2 ]
		ITEM.Stackable = v[ 3 ]
		ITEM.Base = "base_auto"

		itemstore.items.Register( ITEM )
	end

	hook.Call( "ItemStoreRegisterItems", GAMEMODE )

	for _, item in pairs( itemstore.items.Registered ) do
		if item.Base then
			local base = itemstore.items.Get( item.Base )

			if base then
				if base == item then
					ErrorNoHalt( "[ItemStore] " .. item.Class .. " tried to derive from itself." )
				else
					setmetatable( item, { __index = base } )
				end
			else
				ErrorNoHalt( "[ItemStore] " .. item.Class .. " tried to derive from non-existent base " .. item.Base )
			end
		end
	end

	for _, item in pairs( itemstore.items.Registered ) do
		item:Load()
	end
end

-- wait a frame to register items to allow scripts to register their own items.
timer.Simple( 0, function()
	itemstore.items.Load()
end )

--PATH addons/____plogs/lua/plogs_hooks/tools.lua:
--[[
addons/lgos/lua/plogs_hooks/tools.lua
--]]
plogs.Register('Тулган', false)

plogs.AddHook('PlayerToolEntity', function(pl, ent, tool) -- Shame there isn't a better hook
	if (not plogs.cfg.ToolBlacklist[tool]) and IsValid(ent) then
		local cppi = ent:CPPIGetOwner()
		if IsValid(cppi) then
			plogs.PlayerLog(pl, 'Тулган', pl:NameID() .. ' использовал інструмент ' .. tool .. ' на ' .. ent:GetClass() .. ' владелец ' .. cppi:NameID(), {
				['Name'] 	= pl:Name(),
				['SteamID']	= pl:SteamID(),
				['Target Entity Class'] = ent:GetClass(),
				['Target Name'] = cppi:Name(),
				['Target SteamID'] = cppi:SteamID()
			})
		else
			plogs.PlayerLog(pl, 'Тулган', pl:NameID() .. ' использовал інструмент ' .. tool .. ' на ' .. ent:GetClass() .. ' владелец NONE', {
				['Name'] 	= pl:Name(),
				['SteamID']	= pl:SteamID(),
				['Target Entity Class'] = ent:GetClass()
			})
		end
	end
end)
--PATH addons/____bricks_gangs/lua/bricks_server/bricks_gangs/sh_clientconfig.lua:
--[[
    !!WARNING!!
        ALL CONFIG IS DONE INGAME, DONT EDIT ANYTHING HERE
        Type !bricksserver ingame or use the f4menu
    !!WARNING!!
]]--

-- Gangs --
if( BRICKS_SERVER.Func.IsModuleEnabled( "gangs" ) ) then
    BRICKS_SERVER.BASECLIENTCONFIG.GangMenuBind = { BRICKS_SERVER.Func.L( "gangMenuBind" ), "bind", 0 }
end
--PATH addons/____esclib/lua/elib/vgui/esc_context.lua:
local PANEL={}
AccessorFunc(PANEL, "color", "Color", FORCE_COLOR)
AccessorFunc(PANEL, "border_color", "BorderColor", FORCE_COLOR)
AccessorFunc(PANEL, "enable_layouting", "EnableLayouting")


function PANEL:Init()

	self.clr = esclib.addon:GetColors()

	self:SetColor(self.clr.button.main)
	self:SetBorderColor(self.clr.button.hover)
	self:SetEnableLayouting(true)

	local parent = self:GetParent()
	local outpnl = vgui.Create("DButton",parent)
	outpnl:SetSize(parent:GetWide(),parent:GetTall())
	outpnl:SetText("")
	outpnl:SetZPos(10)
	outpnl.Paint = nil
	outpnl:SetCursor("arrow")
	self.contextbackground = outpnl
	function outpnl.Close(pnl)
		pnl:SizeTo(1,1,0.1,0,-1,function()
			if self.OnClose then self:OnClose() end
			pnl:Remove()
		end)
	end
	function outpnl.DoClick()
		outpnl:Close()
		if IsValid(self) then self:Close(true) end
	end
	function outpnl.DoRightClick()
		outpnl:Close()
		if IsValid(self) then self:Close(true) end
	end
	parent.contextbg = outpnl

	self.headerfont = esclib:AdaptiveFont("esclib", 18, 500)
	self.buttonfont = esclib:AdaptiveFont("esclib", 18, 500)
	self.subMenus = {}

	self.next_check = 0
	self.border = esclib:AdaptiveSize(5)
	self.buttonheight = math.max(draw.GetFontHeight(self.headerfont),draw.GetFontHeight(self.buttonfont)) + 10
	self.sepheight = 2
	self.spacey = 0

	self.player = LocalPlayer()
	self:SetParent(outpnl)

	self:SetSize(100,self.buttonheight)
	self.list = vgui.Create("DIconLayout", self)
	self.list:SetBorder(self.border)
	self.list:SetSpaceY(self.spacey)
	self.list:SetSize(self:GetWide()+self.list:GetBorder()*2,self:GetSize())
end

function PANEL:SetWide(wide)
	self:SetSize(wide+self.list:GetBorder()*2,self:GetTall())
	self.list:SetSize(wide+self.list:GetBorder()*2,self:GetTall())
end

function PANEL:SetBorder(border)
	self.border = border
	self.list:SetBorder(border)
end

function PANEL:GetBorder()
	return self.border
end

function PANEL:Close(anim)
	if anim then

		self:SizeTo(1,1,esclib.addon:GetVar("animtime"),0,-1,function()
			if self.OnClose then self:OnClose() end
			self:Remove()
			if IsValid(self.contextbackground) then self.contextbackground:Remove() end
		end)

	else
		if self.OnClose then self:OnClose() end
		self:Remove()
		if IsValid(self.contextbackground) then self.contextbackground:Remove() end
	end
end

function PANEL:SetPly(ply)
	self.player = ply
end

function PANEL:GetPly(ply)
	return self.player
end

function PANEL:SetPosClamped(posx,posy)
	local x = math.Clamp( posx, 0, ScrW() - self:GetWide() )
	local y = math.Clamp( posy, 0, ScrH() - self:GetTall() )
	self:SetPos(x,y)
end

function PANEL:E_InvalidateLayout()

	local sizex = 1
	local sizey = 0
	for _,v in ipairs(self.list:GetChildren()) do

		local textsize = {w = 200, h = 100}
		if v.text then
			textsize = esclib.util.GetTextSize(v.text,self.buttonfont)
		end
		if v.icon then
			textsize.w = textsize.w + v:GetTall()*0.35 + 10
		end
		sizex = math.max(sizex,textsize.w+40)
		sizey = sizey + v:GetTall() + self.spacey
	end

	self:SetSize(sizex+self.list:GetBorder()*2, sizey+self.list:GetBorder()*2 )
	self.list:SetSize(self:GetWide(),self:GetSize())
	self.contextbackground:SetZPos(10)

	if not self.enable_layouting then return end
	for _,v in ipairs(self.list:GetChildren()) do
		v:SetWide(sizex)
		if IsValid(v.lbl) then
			v.lbl:Center()
		end
	end
end

function PANEL:AddButton(text,func,icon)
	local button = vgui.Create("DButton",self.list)
	button:SetSize(self.list:GetWide(), self.buttonheight)
	button:SetText("")

	AccessorFunc(button, "text", "Text")
	AccessorFunc(button, "TextColor", "TextColor", FORCE_COLOR)
	AccessorFunc(button, "TextHoverColor", "TextHoverColor", FORCE_COLOR)
	AccessorFunc(button, "IconColor", "IconColor", FORCE_COLOR)
	AccessorFunc(button, "IconHoverColor", "IconHoverColor", FORCE_COLOR)
	AccessorFunc(button, "Color_Hover", "ColorHover", FORCE_COLOR)
	AccessorFunc(button, "icon", "Icon")
	AccessorFunc(button, "font", "Font")
	AccessorFunc(button, "func", "Func")

	button:SetTextColor(self.clr.button.text)
	button:SetTextHoverColor(self.clr.button.text_hover)
	button:SetIconColor(self.clr.button.text)
	button:SetIconHoverColor(self.clr.button.text_hover)
	button:SetColorHover(self.clr.button.hover)
	button:SetFont(self.buttonfont)

	button:SetText(text)
	button:SetIcon(icon)
	button:SetFunc(func)

	function button:Paint(w,h)
		local hover = self:IsHovered()

		if hover then
			draw.RoundedBox(8,0,0,w,h,self.Color_Hover)
		end

		draw.SimpleText(self.text,self.font,self.icon and h*0.3*2+15 or 10,h*0.5,hover and self.TextHoverColor or self.TextColor,TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER)

		if self.icon then
			esclib.draw:MaterialCentered(h*0.35+5, h*0.5, h*0.3, hover and self.TextHoverColor or self.TextColor, self.icon)
		end
	end

	function button.DoClick()
		self:Close()
		button.func(self.player)
	end

	function button:SetTextColor(col)
		if IsColor(col) then self.TextColor = col end
	end

	function button:SetTextHoverColor(col)
		if IsColor(col) then self.TextHoverColor = col end
	end

	function button:SetIconColor(col)
		if IsColor(col) then self.IconColor = col end
	end

	function button:SetIconHoverColor(col)
		if IsColor(col) then self.IconHoverColor = col end
	end

	self:E_InvalidateLayout()
	return button
end

function PANEL:IsMouseInside()
	-- if not self:IsVisible() then return false end
    local mouseX, mouseY = gui.MousePos()
    local panelX, panelY = self:GetPos()
    local panelWide, panelTall = self:GetSize()

    if mouseX >= panelX and mouseX <= panelX + panelWide and mouseY >= panelY and mouseY <= panelY + panelTall then
        return true
    end

    for _, subMenu in ipairs(self.subMenus) do
        if subMenu.IsMouseInside and subMenu:IsMouseInside() then
            return true
        end
    end

    return false
end


function PANEL:OnClick()
	--for override
end

function PANEL:OnClose()
	--for override
end

function PANEL:AddHeader(text,col)
	local pnl = vgui.Create("DPanel",self.list)

	AccessorFunc(pnl, "TextColor", "TextColor", FORCE_COLOR)
	AccessorFunc(pnl, "font", "Font")

	pnl:SetTextColor(col or self.clr.frame.text)
	pnl:SetFont(self.headerfont)
	pnl:SetSize(self.list:GetWide(), self.buttonheight)
	pnl.text = text
	function pnl.Paint(pnl,w,h)
		-- draw.RoundedBox(8,0,0,w,h,self.clr.frame.accent)
		draw.SimpleText(text, pnl.font, w*0.5, h*0.5, pnl.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end

	function pnl:SetTextColor(col)
		if IsColor(col) then self.TextColor = col end
	end

	self:E_InvalidateLayout()
	return pnl
end

function PANEL:AddSeparator()
	local pnl = vgui.Create("DPanel",self.list)
	pnl.text = ""
	local sepheight = self.sepheight
	AccessorFunc(pnl, "Color", "Color", FORCE_COLOR)
	pnl:SetSize(self.list:GetWide(), sepheight+self.border)
	pnl:SetColor(self.border_color)
	pnl.Paint = function(pnl, w,h)
		surface.SetDrawColor(pnl.Color)
		surface.DrawRect(0,(h-sepheight)*0.5,w,sepheight)
	end
	self:E_InvalidateLayout()
	return pnl
end


function PANEL:AddSubMenu(text, icon)
	local parent = self
    local subMenu = vgui.Create("esclib.contextmenu", self:GetParent())
    subMenu:SetParent(self:GetParent())
	subMenu:SetZPos(self:GetZPos()+1)
	subMenu:SetColor(self:GetColor())
	subMenu:SetBorderColor(self:GetBorderColor())
	subMenu.contextbackground:Remove()
	subMenu.contextbackground = self.contextbackground
	subMenu:SetMouseInputEnabled(true)
	subMenu.button_hovered = false

	function subMenu.eHide(pnl)
		pnl.hidden = true
		pnl:SetAlpha(0)
		pnl:SetMouseInputEnabled(false)
		self.current_subpanel = nil
	end

	function subMenu.eShow(pnl)
		if IsValid(self.current_subpanel) then
			self.current_subpanel:eHide()
		end

		self.current_subpanel = pnl
		pnl.hidden = false
		pnl:SetAlpha(255)
		pnl:SetMouseInputEnabled(true)
	end

	subMenu:eHide()

	table.insert(self.subMenus, subMenu)

    local button = self:AddButton(text, function() end, icon)
	function button:PaintOver(w,h)
		draw.SimpleText(">", self.font, w-10, h*0.5, self.TextColor, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
	end
	local x,y = button:LocalToScreen(0,0)
	subMenu.parent_button = button

	local next_check = 0
	function subMenu:Think()
		if button:IsHovered() then
			self:eShow()

			local x, y = self.parent_button:LocalToScreen(0, 0)
			self:SetPosClamped(x + self.parent_button:GetWide() + self.border * 2, y-self.border)
			next_check = CurTime() + 0.3
			return
		end

		-- if self.hidden then return end

		if next_check < CurTime() then
			next_check = CurTime() + 0.3

			if not self:IsMouseInside() then
				self:eHide()
				return 
			end
		end
	end

    return button, subMenu
end


function PANEL:Paint(w,h)
	draw.RoundedBox(8,0,0,w,h,self.border_color)
	draw.RoundedBox(6,2,2,w-4,h-4,self.color)
end


vgui.Register( "esclib.contextmenu", PANEL )
--PATH addons/____esclib/lua/elib/vgui/esc_hint_panel.lua:
local PANEL = {}
AccessorFunc(PANEL, "TextColor", "TextColor", FORCE_COLOR)
AccessorFunc(PANEL, "Color", "Color", FORCE_COLOR)
AccessorFunc(PANEL, "AccentColor", "AccentColor", FORCE_COLOR)

function PANEL:Init()
    local skin = esclib.addon:GetCurrentSkin()
    self.clr = skin.colors

    self:SetSize(100, 100)
    self:SetTextColor(self.clr.hint.text)
    self:SetColor(self.clr.hint.bg)
    self:SetAccentColor(self.clr.hint.bg2)
end

function PANEL:Setup(text, font, align, parent_panel, hovered_panel)

    font = font or esclib:AdaptiveFont("esclib", 20, 500)
    align = align or TEXT_ALIGN_CENTER

    local maxwidth = esclib.scrw * 0.3
    local multiline = esclib.text:Multiline(text, font, maxwidth)
    local width = multiline.width + 40
    local height = multiline.height + 10

    self:SetSize(width, height)
    self.hovered_panel = hovered_panel
    self.align = align
    self.multiline = multiline
    self.parent_panel = parent_panel

    self.Think = function()
        if not IsValid(self.hovered_panel) then
            self:Remove()
            return
        end

        local posx, posy = 0, 0
        if self.parent_panel and IsValid(self.parent_panel) then
            posx, posy = self.hovered_panel:LocalToScreen(0, 0)
        end

        local x, y = 0, 0
        if (self.align == TEXT_ALIGN_RIGHT) then
            x = posx + self.hovered_panel:GetWide() + 5
            y = posy + self.hovered_panel:GetTall() * 0.5 - self:GetTall() * 0.5
        elseif (self.align == TEXT_ALIGN_LEFT) then
            x = posx - self:GetWide() - 5
            y = posy + self.hovered_panel:GetTall() * 0.5 - self:GetTall() * 0.5
        elseif (self.align == TEXT_ALIGN_TOP) then
            x = posx + self.hovered_panel:GetWide() * 0.5 - self:GetWide() * 0.5
            y = posy - self:GetTall() - 5
        elseif (self.align == TEXT_ALIGN_BOTTOM) then
            x = posx + self.hovered_panel:GetWide() * 0.5 - self:GetWide() * 0.5
            y = posy + self.hovered_panel:GetTall() + 5
        else
            local mx, my = gui.MouseX(), gui.MouseY()
            if self.parent_panel and IsValid(self.parent_panel) then
                mx, my = self.parent_panel:ScreenToLocal(mx, my)
            end

            x = mx + 5
            y = my + 5
        end

        x = math.Clamp(x, 0, esclib.scrw - self:GetWide())
        y = math.Clamp(y, 0, esclib.scrh - self:GetTall())
        self:SetPos(x, y)
    end
end

function PANEL:Paint(w, h)
    draw.RoundedBox(8, 0, 0, w, h, self.AccentColor)
    draw.RoundedBox(6, 2, 2, w - 4, h - 4, self.Color)
    esclib.text:DrawMultilineShadow(self.multiline, 20, 5, self.TextColor, TEXT_ALIGN_LEFT)
end

vgui.Register("esclib.hint_panel", PANEL, "DPanel")
--PATH addons/____esclib/lua/elib/essentials/settings_menu/settings_types/esc_type_numslider.lua:
local draw_bg = esclib.settings_shared_funcs.draw_bg
local VarsIsEqual = esclib.settings_shared_funcs.VarsIsEqual
local SharedDoRightClick = esclib.settings_shared_funcs.SharedDoRightClick


-----------------
--# NUMSLIDER #--
-----------------
local stype = esclib:RegisterSettingsType("numslider")
stype:Require("value")
stype:Require("min")
stype:Require("max")
stype:SoftRequire("decimals")
stype:SoftRequire("step")
function stype:Build( parent )
	local addon     = parent.addon
	local varid     = parent.var_uid
	local varc      = parent.var
	local callback  = parent.ApplyValue
	local init_vals = parent.initial_values
	local settab    = parent.bg
	local def_val   = parent.default_value

	local button_wide= parent:GetWide()
	local button_tall = parent:GetTall()

	local clr = esclib.addon:GetColors()
	local name_tr  = varc.name or addon:Translate(varc.name_tr)
	local desc = varc.desc or addon:Translate(varc.desc_tr)

	local font = esclib:AdaptiveFont("esclib", 20, 500)
	local font2 = esclib:AdaptiveFont("esclib", 20, 500)
	local name = esclib.util:TextCutAccurate(name_tr, font, button_wide-5, "...")

	local button = parent:Add("DButton")
	button:SetSize(button_wide, button_tall)
	button:SetText("")
	button:SetCursor("arrow")
	button.DoClick = function() end
	if desc then
		button:eAddHint(desc,font2,TEXT_ALIGN_TOP,settab)
	end

	local slider = button:Add("esclib.numslider")
	slider:SetSize(button:GetWide()-20,button:GetTall()*0.3 )
	slider:CenterHorizontal()
	slider:SetY(button:GetTall()-slider:GetTall()-7)
	slider:SetBG(settab)

	slider:SetMin(varc.min or 0)
	slider:SetMax(varc.max or 1)
	slider:SetValue(varc.value)
	slider:SetDecimals(varc.decimals or 0)
	slider:SetStep(varc.step or 1)

	button.DoRightClick = function(self) 
		local context = SharedDoRightClick(self, settab, name_tr, addon, varid, varc, nil, callback)

		local set_default = esclib.addon:Translate("phrase_ReturnDefault", addon:GetLanguage())
		context:AddButton(set_default, function()
			slider:SetValue(def_val)
			varc.value = def_val
		end, esclib:GetMaterial("revert.png"))
	end

	function slider:DoRightClick()
		button:DoRightClick()
	end

	function button:Paint(w,h)
		local is_changed = varc.value ~= init_vals[varid]
		draw_bg(w,h,false,clr, is_changed)

		draw.SimpleText(name,font,10,(h-slider:GetY())*0.5+5,clr.button.text,TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER)
	end


	slider.OnValueChanged = function(self,x)
		varc.value = x
		callback(varid,varc.value)
	end
end
--PATH addons/____echat/lua/echat/config/themes.lua:
local skin = {}
skin.name = "Blackout"
skin.color = Color(13,13,13)
skin.colors = {}
skin.colors.main = {
	bg = Color(26, 27, 30, 250),
	bg2 = Color(14, 17, 14, 250),

	button = Color(1, 10, 25, 250),
	button_hover = Color(45, 45, 47),
	accent = Color(206,133,255),
	scrollbar = Color(57, 57, 59, 100),
	text_entry = Color(14, 17, 14, 170),

	text = Color(255,255,255),
	text_gray = Color(160,160,160),
	text_hover = Color(183, 176, 255),
	text_selection = Color(92, 79, 238),
}

echat.addon:RegisterSkin("blackout", skin)

local skin = {}
skin.name = "Snow"
skin.color = Color(255,255,255)
skin.colors = {}
skin.colors.main = {
	bg = Color(200, 200, 220, 200),
	bg2 = Color(229, 238, 238),
	
	button = Color(255, 255, 255),
	button_hover = Color(200, 200, 200),
	accent = Color(153,0,255),
	scrollbar = Color(246, 255, 255, 155),
	text_entry = Color(229, 238, 238),
	
	text = Color(20, 20, 20),
	text_gray = Color(95, 95, 95),
	text_hover = Color(183, 176, 255),
	text_selection = Color(92, 79, 238),
}

echat.addon:RegisterSkin("snow", skin)

local skin = {}
skin.name = "Transparent"
skin.color = Color(50,50,50)
skin.colors = {}
skin.colors.main = {
	bg = Color(1, 10, 25, 200),
	bg2 = Color(1, 10, 25, 200),
	
	button = Color(1, 10, 25),
	button_hover = Color(20, 30, 45),
	accent = Color(153,0,255),
	scrollbar = Color(20, 20, 20, 150),
	text_entry = Color(1, 10, 25, 0),

	text = Color(255,255,255),
	text_gray = Color(160,160,160),
	text_hover = Color(183, 176, 255),
	text_selection = Color(92, 79, 238),
}

echat.addon:RegisterSkin("transparent", skin)


--RegisterSkin(<uid>,<skin table>)

echat.addon:SetDefaultSkin("blackout")
--PATH addons/____echat/lua/echat/core/modules/livechat.lua:
if CLIENT then

local function on(bg) 
    local richtext_orig = echat:GetRichtext()
    local bottom_panel = echat:GetBottomPanel()
    if not IsValid(richtext_orig) or not IsValid(bottom_panel) then return end

    local messages = {}
    local clr = echat.addon:GetColors()
    local space_y = echat.addon:GetVar("chat_spacey")


    local chatbox = echat:GetChatbox()
    local px, py, pw, ph = chatbox:GetDockPadding()
    local rich_mar_x, _, _, _ = richtext_orig:GetDockMargin()
    local bot_px, bot_py, bot_pw, bot_ph = bottom_panel:GetDockPadding()

    local base_panel = chatbox:Add("DPanel")
    
    base_panel:SetSize(chatbox:GetWide()-px-pw, chatbox:GetTall())
    base_panel:SetX(px + rich_mar_x)
    base_panel:SetMouseInputEnabled(false)
    base_panel:NoClipping(true)
    base_panel.Paint = nil

    hook.Add("echat.InvalidateLayout", "echat.livechat_updatesize", function(x,y,w,h)
        if not IsValid(base_panel) then hook.Remove("echat.InvalidateLayout", "echat.livechat_updatesize") return end

        local chatbox = echat:GetChatbox()
        local px, py, pw, ph = chatbox:GetDockPadding()

        base_panel:SetSize(chatbox:GetWide()-px-pw, chatbox:GetTall())
    end)

    

    local function UpdatePositions()
        if not IsValid(base_panel) then return end
        local totaly = base_panel:GetTall()-bottom_panel:GetTall()-ph
        for k,pnl in ipairs(messages) do
            if not IsValid(pnl) then 
                table.remove(messages, k)
                continue
            end
            
            local tall = pnl:GetTall()

            pnl:MoveTo(pnl:GetX(), totaly-tall, 0.1, 0, 0.5)

            totaly = totaly - tall
        end
    end

    local function NewMessage(parsed)
        if not echat:IsValid() then return end
        if not IsValid(base_panel) then return end

        local x,y = base_panel:LocalToScreen(0,base_panel:GetTall())

        local messages_len = #messages
        if messages_len >= 10 then
            local pnl = messages[messages_len]
            if IsValid(pnl) then
                pnl:Remove()
            end
        end

        local richtext = vgui.Create("echat.richtext", base_panel)
        richtext:SetVerticalScrollbarEnabled(true)
        richtext:SetW(richtext_orig:GetWide())
        richtext:GetVBar():SetColor(Color(255,255,255,0)) --transparent

        local success = pcall(function()
            echat:ConvertParsedToRichtext(richtext, parsed)
            richtext:NoClipping(true)
            richtext:SetTall(richtext.pnlCanvas.CalculateMaxTall())
        end)

        if not success then
            richtext:Remove() 
            return 
        end

        richtext:SetY(base_panel:GetTall()-py-ph-4)

        function richtext:Close()
            richtext:AlphaTo(0, 0.6, 0, function()
                if not IsValid(richtext) then return end
                richtext:Remove()
            end)
        end

        table.insert(messages, 1, richtext)

        xpcall( 
            timer.Simple, 

            function() --on error
                if not IsValid(richtext) then return end
                richtext:Close()
            end,
            
            echat.addon:GetVar("msg_time") or 6, 
            function()
                if not IsValid(richtext) then return end
                richtext:Close()
            end 
        )

        timer.Simple(0,function()
            UpdatePositions()
        end)

    end

    hook.Add("echat.OnParsedRetrieved", "echat.LiveChatHandler", function(parsed)
        if not echat:IsValid() then return end

        NewMessage(parsed)

    end)

    hook.Add("StartChat", "echat.LiveChatOnOpenChat", function(is_team)
        if not IsValid(base_panel) then return end
        base_panel:Hide()
    end)

    hook.Add("FinishChat", "echat.LiveChatOnCloseChat", function()
        if not IsValid(base_panel) then return end
        base_panel:Show()
    end)
end

local function off(bg) 
    hook.Remove("ChatText", "echat.LiveChatHandler")
    hook.Remove("StartChat", "echat.LiveChatOnOpenChat")
    hook.Remove("FinishChat", "echat.LiveChatOnCloseChat")
    hook.Remove("echat.InvalidateLayout", "echat.livechat_updatesize")
end

local function custom_check(bg) 
    return true
end

echat:Module("LiveChat", on, off, custom_check)

end
--PATH addons/____echat/lua/echat/core/__core_funcs__.lua:
local gm = GM or GAMEMODE
local netstream = esclib.netstream

function echat:IsTeamChat()
	local mode = echat.bg.mode_pnl:GetText()
	local chat_mode = echat.chat_modes[mode]
	return (mode == echat.addon:Translate("chat_mode_team"))
end

--Override GM:OnPlayerChat to empty function
function gm:OnPlayerChat() end

local function limitStringLength(input, maxLength)
    if #input > maxLength then
        return string.sub(input, 1, maxLength).."..."
    end
    return input
end

function echat:SendMessageToServer(text)
	if not text then return end
	local ply = LocalPlayer()

	local text = string.Trim( text, " " )
	text = string.Trim( text, "\n" )
	text = string.Trim( text, " " )
	text = string.Replace( text, "\n", "\\n" )

	if text == "" then return end

	local is_team = echat:IsTeamChat()

	text=limitStringLength(text, echat.config.max_message_len)

	netstream.Start("echat.Message", is_team, text)
end

function echat:IsValid()
	return IsValid(self.bg)
end

--------------------------
-- CLOSE / OPEN RELATED --
--------------------------
function echat:IsOpened()
	if not self:IsValid() then return false end
	return self.chatbox.opened
end

local mouse_pos = {x=0, y=0}
function echat:Open(mode)
	if not self:IsValid() then return end

	self.chatbox.opened_panel:Show()
	self.chatbox.close_button:Show()

	self.chatbox.opened = true
	self.chatbox.opened_panel:SetAlpha(255)

	self.bg:SetMouseInputEnabled(true)
	self.bg:SetKeyboardInputEnabled(true)
	self.chatbox:MakePopup()
	self.chatbox.text_entry:RequestFocus()

	--restore mouse position
	if mouse_pos.x == 0 then mouse_pos.x = (esclib.scrw or 0) * 0.5 end
	if mouse_pos.y == 0 then mouse_pos.y = (esclib.scrh or 0) * 0.5 end
	input.SetCursorPos( mouse_pos.x, mouse_pos.y )

	hook.Run("StartChat", mode == echat.addon:Translate("chat_mode_team"))
	if mode then
		self.bg.mode_pnl:SetText(mode)
		local tw, th = esclib.util:TextSize(mode,self.bg.mode_pnl:GetFont())
		self.bg.mode_pnl:SetWide(tw+30)
	end

end

function echat:Close()
	if not self:IsValid() then return end

	--Save mouse position
	local mx,my = input.GetCursorPos()
	mouse_pos.x = mx
	mouse_pos.y = my

	self.chatbox.opened_panel:Hide()
	self.chatbox.close_button:Hide()
	CloseDermaMenus()
	self.chatbox.opened = false
	
	--clean chat on close
	if echat.addon:GetVar("clean_chat") then
		self.chatbox.text_entry:SetText("")
	end

	self.bg:SetMouseInputEnabled(false)
	self.bg:SetKeyboardInputEnabled(false)
	self.chatbox:SetMouseInputEnabled(false)
	self.chatbox:SetKeyboardInputEnabled(false)
	timer.Simple(0,function() --gmod thing
		hook.Run("FinishChat")
	end)
end

function echat:Restart()
	if self:IsValid() then
		self.bg:Remove() 
	end
	self:Build()
end

function chat.GetChatBoxPos()
	return echat.chatbox:GetPos()
end

function chat.GetChatBoxSize()
	return echat.chatbox:GetSize()
end

function echat:GetRichtext()
	return IsValid(echat.richtext) and echat.richtext or nil
end

function echat:GetBG()
	return IsValid(echat.bg) and echat.bg or nil
end

function echat:GetChatbox()
	return echat.chatbox
end

function echat:GetBottomPanel()
	return echat.bottom_panel
end

function echat:GoToEnd()
	self:GetRichtext():GotoTextEnd()
end

function echat:AddParsedText(parsed)
	local richtext = self:GetRichtext()
	if richtext then
		local gotoend = (richtext:GetVBar():GetScroll() + 50 > richtext.pnlCanvas:GetTall()-richtext:GetTall())

		hook.Run("echat.OnParsedRetrieved", parsed)
		echat:ConvertParsedToRichtext(richtext, parsed)
		richtext:AppendText("\n") --new line

		if gotoend then
			richtext:GotoTextEnd()
		end
	end
end


-----------
// HOOKS //
-----------
hook.Remove("PlayerBindPress", "echat.override.bind")
hook.Add( "PlayerBindPress", "echat.override.bind", function( ply, bind, isActivated )
	if (bind == "messagemode" or bind == "messagemode2") then

		if isActivated then
			if echat:IsOpened() then
				echat:Close()
			else
				echat:Open((bind == "messagemode2") and echat.addon:Translate("chat_mode_team") or echat.addon:Translate("chat_mode_normal"))
			end
		end

		return true -- Doesn't allow any functions to be called for this bind
	end
end )

--RESOLUTION CHANGE
hook.Add( "OnScreenSizeChanged", "echat.onscreenchange", function(oldw,oldh)
	timer.Simple(1,function() echat:Restart() end)
end)

hook.Add("echat_skin_changed","echat.skin_changed_reload",function(skin_name)
	local skin = echat.addon:GetCurrentSkin()
	if skin then
		echat.skin = skin
		echat:Restart()
	end
end)

hook.Add( "HUDShouldDraw", "echat.shoulddraw.removechat", function( name )
	if name == "CHudChat" then return false end
end )

hook.Add("InitPostEntity","echat_buildhook",function()
	echat:Build()
end)
echat:Build()

hook.Add("echat_settings_changed","echat.onsettings_change",function(needrestart, changed_vars)
	if needrestart then
		echat:Restart()
	end
end)
	




------------------------------------
/// REWRITING ORIGINAL FUNCTIONS ///
------------------------------------
--rewrite original functions
-- table - Color. Will set the color for all following strings until the next Color argument.
-- string - Text to be added to the chat box.
-- Player - Adds the name of the player in the player's team color to the chat box.
-- any - Any other type, such as Entity will be converted to string and added as text.
function chat.AddText(...)
	local parsed = echat:FinalParse(...)
	local parsed = echat:ParseText(parsed)
	echat:AddParsedText(parsed)
	chat.PlaySound()
end

-- local function echatMessageNet(len)
-- 	local from_player = net.ReadBool()
-- 	local ply
-- 	if from_player then
-- 		ply = net.ReadEntity()
-- 	end

-- 	local result = esclib:NetReadCompressedTable()
-- 	if not istable(result) or not result.parsed then return end

-- 	if result.text and from_player and IsValid(ply) then
-- 		if hook.Run("OnPlayerChat", ply, result.text, false, not ply:Alive()) then return end
-- 	end

-- 	echat:AddParsedText(result.parsed)
-- 	chat.PlaySound()
-- end
-- net.Receive("echat.Message", echatMessageNet)

netstream.Hook("echat.Message", function(parsed_text, actual_text, from_player)
	local ply
	if from_player and IsValid(from_player) then
		ply = from_player
	end

	if not istable(parsed_text) then return end

	if actual_text and from_player and IsValid(ply) then
		if hook.Run("OnPlayerChat", ply, actual_text, false, not ply:Alive()) then return end
	end

	echat:AddParsedText(parsed_text)
	chat.PlaySound()
end)

function chat.Open(mode)
	echat:Open((mode == 1) and echat.addon:Translate("chat_mode_normal") or echat.addon:Translate("chat_mode_team"))
end


-----------------
-- CONCOMMANDS --
-----------------
concommand.Add("echat_print_test", function()
	for k = 0,10 do
		timer.Simple(0.2*k, function()
			local text = "<clr:white>hello world! I am a test message!\n1. Numbers: <clr:pink> "
			for s = 1, 9 do text = text..s end
			text = text.."\n<clr:white>2.<shake:0.5> Shaking text!<shake:end>"
			text = text.."\n3.<clr:gold> Colored text!<clr:white>"
			text = text.."\n4.<rainbow> Rainbow text!<clr:white>"
			text = text.."\n5. Emoji! :bone:"
			text = text.."\n6. <bg_col:255,0,255>Background <bg_col:255,0,0>color!<bg_col:end>"
			text = text.."\n7. <font:es_echatmono_30_500>Any font!"

			local text_parsed = echat:ParseText(echat:FinalParse(text))
			echat:AddParsedText(text_parsed)
			chat.PlaySound()
		end)
	end
end)

concommand.Add("echat_fonts", function()
	PrintTable(echat:GetFonts())
end)

concommand.Add("echat_emojis", function()
	PrintTable(echat:GetEmojiList())
end)

concommand.Add("echat_restart", function()
	if echat:IsValid() then echat:Restart() end
end)

concommand.Add("echat_close", function()
	echat:Close()
end)

concommand.Add("echat_open", function()
	echat:Open()
end)
--PATH addons/____inventory/lua/itemstore/items/base_auto.lua:
ITEM.Name = "Auto Item Base"
ITEM.Model = "models/error.mdl"
ITEM.Base = "base_entity"

ITEM.DontNetwork = {
	EntityData = true
}

function ITEM:SaveData( ent )
	self:SetModel( ent:GetModel() )
	self:SetData( "EntityData", duplicator.CopyEntTable( ent ) )
end

function ITEM:LoadData( ent )
	local data = self:GetData( "EntityData" )
	data.Pos = nil
	data.Angle = nil

	duplicator.DoGeneric( ent, data )

	if data.DT then
		timer.Simple( 0, function()
			for k, v in pairs( data.DT ) do
				ent.dt[ k ] = v
			end
		end )
	end
end

--PATH addons/__________scripts__loader/lua/scriptssss/disguise/sh_init.lua:
onyx.netvar:Register( 'Disguise_G', {
    type = TYPE_BOOL,
    public = true
} )

onyx.netvar:Register( 'Disguise_Time', {
    type = TYPE_NUMBER,
    bits = 32,
    unsigned = true,
    public = false
} )

onyx.netvar:Register( 'Disgue', {
    type = TYPE_BOOL,
    public = true
} )
--PATH addons/__________scripts__loader/lua/scriptssss/safe-zone/cl_zone.lua:
surface.CreateFont( "SafeZoneBig", {
    font = "Trebuchet MS",
    size = 35,
    weight = 400,
    antialias = true,
} )

surface.CreateFont( "SafeZoneSmall", {
    font = "Trebuchet MS",
    size = 25,
    weight = 400,
    antialias = true,
} )

timer.Create( "rsp_manage", 0.1, 0, function()
    if not IsValid( LocalPlayer() ) or not LocalPlayer().GetPos then return end
    SCRIPTSLOADER.DrawHUD = SCRIPTSLOADER:InsideSafeZone( LocalPlayer():GetPos() )
end )

local col1, col2 = Color( 50, 220, 50 ), Color( 220, 220, 220 )
local font1 = onyx.Font('Comfortaa Bold@60')
local font2 = onyx.Font('Comfortaa@35')
hook.Add( "HUDPaint", "rsp_draw_safezone", function()
    if not SCRIPTSLOADER.DrawHUD then return end
    local w = ScrW()
    onyx.hud.DrawShadowText2D( "Green Zone", font1, w * 0.5, 60, col1, 1, 1 )
    onyx.hud.DrawShadowText2D( "Ви в безпеці", font2, w * 0.5, 95, col2, 1, 1 )
end )
--PATH addons/__________scripts__loader/lua/scriptssss/safe-zone/sh_zone.lua:
RSP = RPS or {}

local pMeta = FindMetaTable( 'Player' )
local eMeta = FindMetaTable( 'Entity' )
SCRIPTSLOADER.Info = {
    ['rp_bangclaw'] = {
        x = { -81, 371 },
        y = { -2401, -3276 },
        z = { 2, 156 }
    },
    ['rp_downtown_tits_v25'] = {
        x = { 2915, 3648 },
        y = { 1371, 497 },
        z = { -196, 156 }
    },
}

local info = SCRIPTSLOADER.Info[game.GetMap()]
function SCRIPTSLOADER:InsideSafeZone( pos )
    if pos.z > info.z[1] and pos.z < info.z[2] then
        --print('z norm')
        if pos.x > info.x[1] and pos.x < info.x[2] then
            --print('x norm')
            if pos.y < info.y[1] and pos.y > info.y[2] then
                --	print('y norm')
                return true
            end
        end
    end
    return false
end
RSP.InsideSafeZone = SCRIPTSLOADER.InsideSafeZone

local function meta( who )
    return SCRIPTSLOADER:InsideSafeZone( who:GetPos() )
end

pMeta.InSpawn = meta
eMeta.InSpawn = meta