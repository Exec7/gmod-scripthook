--[[
███████╗██╗░░██╗███████╗░█████╗░██╗░░██╗░█████╗░░█████╗░██╗░░██╗░░░░█████╗░░█████╗░
██╔════╝╚██╗██╔╝██╔════╝██╔══██╗██║░░██║██╔══██╗██╔══██╗██║░██╔╝░░░██╔══██╗██╔══██╗
█████╗░░░╚███╔╝░█████╗░░██║░░╚═╝███████║███████║██║░░╚═╝█████═╝░░░░██║░░╚═╝██║░░╚═╝
██╔══╝░░░██╔██╗░██╔══╝░░██║░░██╗██╔══██║██╔══██║██║░░██╗██╔═██╗░░░░██║░░██╗██║░░██╗
███████╗██╔╝╚██╗███████╗╚█████╔╝██║░░██║██║░░██║╚█████╔╝██║░╚██╗██╗╚█████╔╝╚█████╔╝
╚══════╝╚═╝░░╚═╝╚══════╝░╚════╝░╚═╝░░╚═╝╚═╝░░╚═╝░╚════╝░╚═╝░░╚═╝╚═╝░╚════╝░░╚════╝░

HOSTNAME: Ψ UkraineRP #1 ◈ Оновлення◈ Набiр ◈ M9K
IP: 146.59.47.149:27015
GAMEMODE: darkrp
MAP: rp_bangclaw
MAXPLAYERS: 128
ALL SERVER NETS: Undo_Undone, Undo_AddUndo, Undo_FireUndo, umsg.SendLua, umsg.UnPooled, properties, drive_base, drive_noclip, editvariable, player_default, PlayerKilledNPC, NPCKilledNPC, PlayerKilled, PlayerKilledSelf, PlayerKilledByPlayer, DeathNoticeEvent, TPerson:ToServer, RemovePermaList, AddPermaList, Permalist, FixDoorStart, AddFixDoor, RemoveFixDoor, GiveDataFixDoor, FixDoors, SH_ACC_READY, SH_ACC_PURCHASE, SH_ACC_SELL, SH_ACC_MENU, SH_ACC_EQUIP, SH_ACC_EQUIPS, SH_ACC_CHANGE, SH_ACC_INV, SH_ACC_NOTIFY, SH_ACC_ADJUST, SH_ACC_ADJUST_RESET, SH_ACC_REQUEST, cats.dispatchMessage, cats.syncTickets, cats.claimTicket, cats.closeTicket, cats.setRating, cats.getAdminList, cats.getAdminData, DoTotemAnimation, dronesrewrite_keyvalue, dronesrewrite_addweapon, dronesrewrite_addfriend, dronesrewrite_controldr, dronesrewrite_controllerlookup, dronesrewrite_conexit, dronesrewrite_concmd, dronesrewrite_makebind, dronesrewrite_requestweapons, dronesrewrite_addfriends, dronesrewrite_removeweapon, dronesrewrite_changewep, dronesrewrite_addmodule, dronesrewrite_clickkey, FProfile_startProfiling, FProfile_stopProfiling, FProfile_focusObj, FProfile_getSource, FProfile_printFunction, FProfile_fullModelUpdate, FProfile_focusUpdate, FProfile_unsubscribe, FSpectate, FSpectateTarget, ChatPrintColor, IGS.nw.PlayerSync, IGS.nw.NilEntityVar, IGS.nw.NilPlayerVar, IGS.nw.EntityRemoved, IGS.nw.PlayerRemoved, IGS.nw_igs_lvl, IGS.nw_igs_balance, IGS.nw_igs_total_transactions, IGS.nw_igs_purchases, IGS.nw_igs_settings, IGS.nw_igs_servers, IGS.GiveOnSpawnWep, IGS.PaymentStatusUpdated, IGS.UI, IGS.Purchase, IGS.Activate, IGS.UseCoupon, IGS.GetPaymentURL, IGS.GetLatestPurchases, IGS.GetMyTransactions, IGS.GetMyPurchases, IGS.GetInventory, IGS.DropItem, IGS.InvLog, IGS.NameRequest, IGS.DeactivateItem, lvs_admin_setconvar, lvs_toggle_mouseaim, lvs_car_turnsignal, Voting_NewVote, Voting_EndVote, Voting_VoteCast, VOTING_Confirm, MEDIAPLAYER.Update, MEDIAPLAYER.Media, MEDIAPLAYER.Remove, MEDIAPLAYER.Pause, MEDIAPLAYER.Seek, MEDIAPLAYER.RequestListen, MEDIAPLAYER.RequestUpdate, MEDIAPLAYER.RequestMedia, MEDIAPLAYER.RequestPause, MEDIAPLAYER.RequestSkip, MEDIAPLAYER.RequestSeek, MEDIAPLAYER.RequestRemove, MEDIAPLAYER.RequestRepeat, MEDIAPLAYER.RequestShuffle, MEDIAPLAYER.RequestLock, NetStreamWrite, NetStreamRead, netchunk[onyx:SyncConfig]:Send, onyx.inconfig:Set, onyx.inconfig:SetTable, onyx.inconfig:SyncSingle, onyx.netvar:Sync, onyx.netvar:Clear, onyx.netvar:DeleteEntity, onyx:Notify, onyx.creditstore:OpenStore, onyx.creditstore:CreateItem, onyx.creditstore:CreateCategory, onyx.creditstore:EditCategory, onyx.creditstore:EditItem, onyx.creditstore:DeleteItem, onyx.creditstore:DeleteCategory, onyx.creditstore:AdminRequestInventory, onyx.creditstore:AdminGiveItem, onyx.creditstore:AdminTakeItem, onyx.creditstore:Convert, netchunk[onyx.creditstore:SyncInventory]:Send, onyx.creditstore:PurchaseItem, onyx.creditstore:SyncInventoryItemData, onyx.creditstore:UseOption, netchunk[onyx.creditstore:SyncItems]:Send, netchunk[onyx.creditstore:SyncCategories]:Send, onyx.creditstore:Refund, onyx.hud::SendAlert, onyx.scoreboard:SyncColumns, onyx.scoreboard:SetColumn, onyx.scoreboard:SetColumns, netchunk[onyx.scoreboard:SyncBrickGangs]:Send, onyx.scoreboard(Bricks.Gangs):Replace, onyx.scoreboard(Bricks.Gangs):Remove, onyx.scoreboard(Bricks.Gangs):SyncAll, onyx.scoreboard:SyncRanks, onyx.scoreboard:ReplaceRank, onyx.scoreboard:DeleteRank, OF, OFSKin, pCasino:Msg, pCasino:FreeSpin, pCasino:RequestData:Send, pCasino:RequestData:Respond, pCasino:Menu:Config, pCasino:ToolGun:CreateEntity, pCasino:BasicSlot:Spin:Start, pCasino:BasicSlot:Spin:Stop, pCasino:BasicSlot:Spin:Win, pCasino:Roulette:Bet:Change, pCasino:Roulette:Bet:Place, pCasino:Roulette:Bet:Clear, pCasino:WheelSlot:Spin:Start, pCasino:WheelSlot:Spin:Stop, pCasino:WheelSlot:Spin:Win, pCasino:WheelSlot:Spin:Spin, plogs.Console, plogs.OpenMenu, plogs.LogData, Hamster_Robert, SAM.NetStreamDS.Sending, TellAllMessage, EmergencyDispatch:DispatchCallout:VictimMenu, EmergencyDispatch:DispatchCallout:VictimNet, EmergencyDispatch:DispatchCallout:ServerReception, EmergencyDispatch:DispatchCallout:SendingCalloutToUnit, RetroBoombox:ChangeSound, RetroBoombox:TurnPower, RetroBoombox:TurnPlaying, RetroBoombox:ChangeFrequence, RetroBoombox:ChangeLightMode, RetroBoombox:GrabBoombox, RetroBoombox:SendBoomboxInfos, sKeypads::SendFriends, sKeypads::RemoveFriends, sKeypads::SendConnectedDoors, sKeypads::Notify, sKeypads::PressKey, sP:Networking, Cuffs_BlindPlayer, Cuffs_FreePlayer, Cuffs_DragPlayer, Cuffs_TiePlayers, Cuffs_UntiePlayers, wOS.Fortnite.StartTauntCamera, wOS.Fortnite.CancelEmote, wOS.Fortnite.WeaponSelect, XeninUI.FullClientInit, XeninUI.OSTime, XeninUI.Notification, XeninUI.Language, Xenin.Framework.Scripts, Xenin.Framework.UpdateScriptsMessage, XeninUI.Configuator.Settings, XeninUI.Configuator.SaveSettings, XeninUI.Configuator.SaveSetting, XeninUI.Configuator.GetSettings, XeninUI.Configuator.Entity, XeninUI.Configuator.SaveEntity, XeninUI.Configuator.GetEntities, XeninUI.Configuator.CreateEntity, XeninUI.Configuator.DeleteEntity, Xenin.Config, Xenin.RequestConfig, Xenin.Players.notification, Xenin.Players.notifications, Xenin.Players.readNotifications, BATTLEPASS.TotalSync, BATTLEPASS.SyncChallengeProgress, BATTLEPASS.AddTier, BATTLEPASS.ClaimItem, BattlePass.OpenMenu, BATTLEPASS.SyncProgress, BATTLEPASS.GivePass, BATTLEPASS.SetTiers, BATTLEPASS.RemovePass, ChallengeNet, sv_anticrash_RemoveEntitiesFrom, sv_anticrash_FreezeEntitiesFrom, sv_anticrash_GlobalCleanup, sv_anticrash_TriggerAntiLagMeasures, cl_anticrash_ConsolePrint, AdvDupe2_ReportClass, AdvDupe2_ReportModel, AdvDupe2Notify, AdvDupe2_RemoveGhosts, AdvDupe2_ResetDupeInfo, AdvDupe2_StartGhosting, AdvDupe2_InitProgressBar, AdvDupe2_DrawSelectBox, AdvDupe2_RemoveSelectBox, AdvDupe2_UpdateProgressBar, AdvDupe2_RemoveProgressBar, AdvDupe2_ResetOffsets, AdvDupe2_SetDupeInfo, AdvDupe2_ReceiveFile, AdvDupe2_SendGhosts, AdvDupe2_AddGhost, BRS.Net.SendConfig, BRS.Net.RequestConfig, BRS.Net.UpdateConfig, BRS.Net.ProfileAdminRequest, BRS.Net.ProfileAdminSend, BRS.Net.OpenBrickServer, BRS.Net.SendNetworkReady, BRS.Net.SendServerTime, BRS.Net.SendTopNotification, BRS.Net.SendNotification, BRS.Net.SendChatNotification, BRS.Net.UseMenuNPC, BRS.Net.AddGangAdminMail, BRS.Net.RequestAdminGangs, BRS.Net.SendAdminGangTables, BRS.Net.RequestAdminGangData, BRS.Net.SendAdminGangData, BRS.Net.AdminGangCMD, BRS.Net.SetGangTableValue, BRS.Net.SetGangTableValues, BRS.Net.SetGangTable, BRS.Net.SendGangInbox, BRS.Net.SendGangInboxEntry, BRS.Net.RemoveGangInboxEntry, BRS.Net.DeleteGangInboxEntry, BRS.Net.OpenGangMenu, BRS.Net.CreateGang, BRS.Net.SaveGangRoles, BRS.Net.GangSetRank, BRS.Net.SaveGangSettings, BRS.Net.GangKick, BRS.Net.GangInvite, BRS.Net.GangInviteSend, BRS.Net.GangInviteAccept, BRS.Net.GangDepositMoney, BRS.Net.GangWithdrawMoney, BRS.Net.GangDisband, BRS.Net.GangTransfer, BRS.Net.GangLeave, BRS.Net.GangNetworkMessage, BRS.Net.GangSendMessage, BRS.Net.RequestPlyGangInfo, BRS.Net.SendPlyGangInfo, BRS.Net.GangUpgrade, BRS.Net.SetGangID, BRS.Net.GangAchievementClaim, BRS.Net.GangDepositLoadout, BRS.Net.GangStorageDrop, BRS.Net.GangStorageUse, BRS.Net.SendGangAssociations, BRS.Net.SendGangAssociationValue, BRS.Net.RequestAssociationGangs, BRS.Net.SendAssociationGangTables, BRS.Net.RequestGangAssociation, BRS.Net.AcceptGangAssociation, BRS.Net.DissolveGangAssociation, BRS.Net.SendLeaderboardGangTables, BRS.Net.RequestLeaderboardGangs, BRS.Net.SendGangLeaderboardTables, BRS.Net.RequestGangLeaderboards, BRS.Net.SendTerritoryGangTables, BRS.Net.SendGangTerritoriesTable, BRS.Net.SendGangTerritoriesValue, BRS.Net.SendTerritoryGangValues, BRS.Net.RequestTerritoryGangs, BRS.Net.SetCurrencies, BRS.Net.Admin_AddCurrency, BRS.Net.Admin_SetCurrency, ne_obyazan2, bot, PlayerDisplayChat, NetData, BodyGroupData, BM2.OpenTerminal, BM2.Client.TerminalPrint, BM2.Command.Mining, BM2.Command.SellBitcoins, BM2.Command.Upgrade, BM2.Command.Eject, BM2.Command.RemoteInstall, BM2.Command.ChangeRemoteName, BM2.OpenPhone, BM2.TerminalPrintEnum, BLUES_PHARMA_SELECT, BLUES_PHARMA_OPEN_MEASURE, BLUES_PHARMA_POUR, BLUES_PHARMA_BEAKER_CONTENTS, BLUES_PHARMA_BEAKER_CONTENTS_ALL, BLUES_PHARMA_UPDATE_MAT, BLUES_PHARMA_OPEN_BOOK, Contract::Give, Contract::Open, Contract::Claim, ContractSignature::Open, Contract::HistoryRequest, Contract::HistorySend, dn_name, dn_deathtype, pp_info_send, phone, PhonePlaySound, PhoneStopSound, CreateDrone, GiveDroneWeapon, NazzLinNet, PlayCloakLoop, StopCloakLoop, ub_purchase, BeginSpin, StartClientSpinAnimation, SpinEnded, ub_equipweapon, ub_deleteItem, ub_spawnEntity, ub_giftitem, ub_admingiveitems, StartClientUpgradeAnimation, Vape, VapeArm, VapeTalking, DragonVapeIgnite, nw.PlayerSync, nw.NilEntityVar, nw.NilPlayerVar, nw.EntityRemoved, nw.PlayerRemoved, nw_Statistic_Money, rp.Voice, rp.keysMenu, nw_Hitman_Table, nw_LockDown, nw_LockDown_I, rp.NotifyString, rp.Notify, rp.NotifyTerm, rp.ChatPrint, ClimbRoll, BRS.Net.ToolEntityPlacer, BRS.Net.ToolNPCPlacer, BRS.Net.ToolTerritoryPlacer, KOSTIL, StackGhost, UnstackGhost, Grabej, EndGrab, sKeypads::SendKeypadCheckerData, StunStickFlash, Maranzo_AbilitySWEP_ninjaskunai_Cast, Maranzo_AbilitySWEP_ninjaskunai_CastCancel, wanted_radio, VapeUpdateCustomColor, VapeTankColor, VapeMessage, WeaponChecker, ZEN_NET_H_MAGIC_BLAST, ZEN_NET_H_MAGIC_RADIUS, ZEN_NET_H_MAGIC_RADIUS_HEAL, Z_NET_REGEN_EFFECTS, Z_NET_REGEN_EFFECTS_STOP, Z_NET_CLEAR_SPELL_EFFECTS, Z_NET_MARK_INVUN, ZEN_NET_H_MAGIC_RADIUS_SHIELD, BRS.Net.GangPrinterIncomeTrackRequest, BRS.Net.GangPrinterIncomeTrackSend, BRS.Net.GangPrinterToggle, BRS.Net.GangPrinterWithdraw, BRS.Net.GangPrinterPlace, BRS.Net.GangPrinterPurchase, BRS.Net.GangPrinterBuyServer, BRS.Net.GangPrinterBuyServerUpgrade, BRS.Net.GangPrinterBuyUpgrade, rp.CookMenu, rp.CookMe
LUA TOTAL: 2355
--]]
--Stealed clientside server code by exechack.cc
--Hostname: Ψ UkraineRP #1 ◈ Оновлення◈ Набiр ◈ M9K - Part 1/10 - 06/04/2025


--PATH addons/dash/lua/dash/init.lua:
dash = {
	Modules = {},
	LoadedModules = {},
	BadModules = {}
}

_R = debug.getregistry()

dash.IncludeSV = (SERVER) and include or function() end
dash.IncludeCL = (SERVER) and AddCSLuaFile or include
dash.IncludeSH = function(f) AddCSLuaFile(f) return include(f) end

function dash.LoadDir(...)
	local ret = {}
	for _, dir in ipairs({...}) do
		local files, folders = file.Find('dash/' .. dir .. '/*', 'LUA')
		for _, f in ipairs(files) do
			if (f:sub(f:len() - 2, f:len()) == 'lua') then
				ret[f:sub(1, f:len() - 4)] = 'dash/' .. dir .. '/' .. f
			end
		end
		for _, f in ipairs(folders) do
			if (f ~= 'client') and (f ~= 'server') then
				ret[f] = 'dash/' .. dir .. '/' .. f .. '/' .. f ..'.lua'
			end
		end
	end
	return ret
end


local preshared = dash.LoadDir('preload')
local preserver = (SERVER) and dash.LoadDir('preload/server') or {}
local preclient = dash.LoadDir('preload/client')

local modshared = dash.LoadDir('libraries', 'thirdparty')
local modserver = (SERVER) and dash.LoadDir('libraries/server', 'thirdparty/server') or {}
local modclient = dash.LoadDir('libraries/client', 'thirdparty/client')

for k, v in pairs(preshared) do
	dash.IncludeSH(v)
end

for k, v in pairs(preclient) do
	dash.IncludeCL(v)
end

if (SERVER) then
	for k, v in pairs(preserver) do
		dash.IncludeSV(v)
	end

	for k, v in pairs(modserver) do
		dash.Modules[k] = v
	end
end

for k, v in pairs(modshared) do
	if (SERVER) then
		AddCSLuaFile(v)
	end
	dash.Modules[k] = v
end

for k, v in pairs(modclient) do
	if (SERVER) then
		AddCSLuaFile(v)
	else
		dash.Modules[k] = v
	end
end

_require = require
function require(name)
	local lib = dash.Modules[name]
	if lib and (not dash.LoadedModules[name]) and (not dash.BadModules[name]) then
		dash.LoadedModules[name] = true
		return include(lib)
	elseif (not dash.LoadedModules[name]) and (not dash.BadModules[name]) then
		return _require(name)
	end
end
--PATH addons/__________tperson/lua/3tcore/lib/cl_lib.lua:
local TActive = true
function TPerson.Update()
	TActive = not TActive
end

function TPerson.IsActive()
	if not TPerson.GetConfig()['allow']['third'] then return false end
	return TActive
end

function TPerson.IsScopping()
	local swep = LocalPlayer():GetActiveWeapon()
	if not IsValid(swep) then return end
	local isTableSwepDT = istable(swep.dt)
	-- DarkRP && M9K
	if type(swep.GetIronsights) == 'function' then
		return swep:GetIronsights()
		-- FAS ( swep.dt.Status == 0 is using by TFA Weapons but not for scopping )
	elseif isTableSwepDT and swep.dt.Status and swep.dt.Status ~= 0 then
		return swep.dt.Status == FAS_STAT_ADS
		--	CW 2.0
	elseif string.find(swep:GetClass(), 'cw_', 0) and swep.dt and swep.dt.State then
		return swep.dt.State == 2
		-- ARcCW
	elseif swep.ArcCW then
		return swep:GetState() == ArcCW.STATE_SIGHTS
		-- TFA
	elseif type(swep.GetIronSights) == 'function' then
		return swep:GetIronSights()
	else
		return false
	end
end

function TPerson.OnPlayerSpawn(data)
	if LocalPlayer():UserID() ~= data['userid'] then return end
	local config = TPerson.GetConfig()
	if not config then return end
	if config['allow']['tOnSpawn'] and not TPerson.IsActive() or not config['allow']['tOnSpawn'] and TPerson.IsActive() then TPerson.Update() end
end

-- On player button press
function TPerson.OnPlayerButtonDown(ply, button)
	if LocalPlayer() ~= ply then return end
	if not IsFirstTimePredicted() then return end
	local config = TPerson.GetConfig()
	if not config then return end
	local trKey = config['key']
	if config['allow']['third'] and button == trKey and input.IsButtonDown(trKey) then
		TPerson.Update()
		return true
	end
end

function TPerson.IsHoldingWeapon()
	local swep = LocalPlayer():GetActiveWeapon()
	if not IsValid(swep) then return false end
	if TPerson.DisableOnHolding[swep:GetClass()] then return true end
end

function TPerson.DrawCrossHair()
	local config = table.Copy(TPerson.GetConfig())
	if not config then return end
	local CrossHair = TPerson.GetChrossHair()
	local w, h = ScrW(), ScrH()
	local x, y = w * 0.5, h * 0.5
	if TPerson.IsActive() then
		local tr = LocalPlayer():GetEyeTraceNoCursor()
		if tr.HitPos then
			local scr = tr.HitPos:ToScreen()
			x, y = scr.x, scr.y
		end
	end

	if CrossHair then
		local shouldDraw = true
		if not config['allow']['cOnAiming'] and TPerson.IsScopping() then shouldDraw = false end
		if TPerson.IsActive() then
			if not config['allow']['crosshair3p'] then shouldDraw = false end
		else
			if not config['allow']['crosshair1p'] then shouldDraw = false end
		end

		if shouldDraw then CrossHair['paint'](x, y, w, h, config['crosshair']['color'], config['crosshair']['sSpace'], config['crosshair']['sWidth'], config['crosshair']['sHeight']) end
	end
end

function TPerson.HUDShouldDraw(element)
	if element == 'CHudCrosshair' then return false end
end

function TPerson.CalcView(ply, pos, angles, fov)
	if not TActive then return end
	if ply:InVehicle() then return end
	local config = TPerson.GetConfig()
	if not config then return end
	if TPerson.IsHoldingWeapon() then return end
	if config['allow']['third'] then
		local bl = TPerson.IsScopping()
		if bl and not config['allow']['tOnAiming'] then return end
		local right = not bl and -config['view']['right'] or -17.7
		local fw = not bl and -config['view']['forward'] or 15
		local up = not bl and -config['view']['up'] or 2.5
		local newPos = pos
		newPos = newPos - (angles:Right() * right)
		newPos = newPos - (angles:Forward() * fw)
		newPos = newPos - (angles:Up() * up)
		local tr = util.TraceHull({
			start = pos,
			endpos = newPos,
			filter = ply,
			maxs = Vector(5, 5, 5),
			mins = Vector(-5, -5, -5)
		})

		pos = tr.HitPos
		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = true
		return view
	end
end
--PATH addons/ukrp_main_content/lua/autorun/akuldfunnyratpm.lua:
player_manager.AddValidModel( "Funny Rat", "models/akuld/funnyrat/rat.mdl" )
list.Set( "PlayerOptionsModel", "Funny Rat", "models/akuld/funnyrat/rat.mdl" )

player_manager.AddValidModel( "Funny Rat (Colorable)", "models/akuld/funnyrat/ratcolorable.mdl" )
list.Set( "PlayerOptionsModel", "Funny Rat (Colorable)", "models/akuld/funnyrat/ratcolorable.mdl" )

player_manager.AddValidHands( "Funny Rat", "models/akuld/funnyrat/ratarms.mdl", 0, "00000000" )
player_manager.AddValidHands( "Funny Rat (Colorable)", "models/akuld/funnyrat/ratarms_c.mdl", 0, "00000000" )
--PATH addons/_ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}
bshields.shields = {
	{
		[1] = {
			["angles"] = Angle( 4, 6, -14 ),
			["position"] = Vector( 0, 8, -1 )
		},
		[2] = {
			["angles"] = Angle( 6, 6, -12 ),
			["position"] = Vector( 8, 10, -4 )
		},
		[3] = {
			["angles"] = Angle( -3, 7, -16 ),
			["position"] = Vector( -1, 4, -3 )
		}
	},
	{
		[1] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 6, -4, -8 )
		},
		[2] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 16, -3, -12 )
		},
		[3] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 6, -3, -12 )
		}
	},
	{
		[1] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -7, -13 )
		},
		[2] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -6, -22 )
		},
		[3] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -8, -12 )
		}
	}
}
--PATH addons/_ballistic_shields/lua/libraries/cl_surfacegeturl.lua:
--[[
MIT License

Copyright (c) 2016 Matt Krins

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
]]
--[[ Helper Function by StealthPaw/101kl/MattKrins. --]]
if SERVER then return end
local WebMaterials = {}
function surface.GetURL( url, w, h, time )
	if not url or not w or not h then return Material( "error" ) end
	if WebMaterials[url] then return WebMaterials[url] end
	local WebPanel = vgui.Create( "HTML" )
	WebPanel:SetAlpha( 0 )
	WebPanel:SetSize( tonumber( w ), tonumber( h ) )
	WebPanel:OpenURL( url )
	WebPanel.Paint = function( self )
		if not WebMaterials[url] and self:GetHTMLMaterial() then
			WebMaterials[url] = self:GetHTMLMaterial()
			self:Remove()
		end
	end

	timer.Simple( 1 or tonumber( time ), function()
		if IsValid( WebPanel ) then -- In case we do not render
			WebPanel:Remove()
		end
	end )
	return Material( "error" )
end
--PATH addons/_________report_system/lua/autorun/cats-load.lua:
include "cats/shared.lua"

if SERVER then

    AddCSLuaFile "cats/client.lua"

    AddCSLuaFile "cats/shared.lua"

    include "cats/mysqlite.lua"

    include "cats/server.lua"

else

    include "cats/client.lua"

end
--PATH addons/_drones/lua/dronesrewrite/ammotypes.lua:
DRONES_REWRITE.AmmoTypes = { }

DRONES_REWRITE.AmmoTypes.Pistol = "item_drr_pistol"
--DRONES_REWRITE.AmmoTypes.Pistol = "item_drr_pistol"

DRONES_REWRITE.AmmoTypes.CannonAmmo = "item_drr_cannon"
DRONES_REWRITE.AmmoTypes.GuidedMis = "item_drr_gmissiles"
DRONES_REWRITE.AmmoTypes.Rockets = "item_drr_rockets"
DRONES_REWRITE.AmmoTypes.Missiles = "item_drr_missiles"

DRONES_REWRITE.AmmoTypes.Rifle = "item_drr_rifle"
DRONES_REWRITE.AmmoTypes.Mines = "item_drr_mines"

DRONES_REWRITE.AmmoTypes.Grenades = "item_drr_grenades"
DRONES_REWRITE.AmmoTypes.ElectroGrenades = "item_drr_grenadeselec"
DRONES_REWRITE.AmmoTypes.FireGrenades = "item_drr_grenadesfire"

DRONES_REWRITE.AmmoTypes.Plasma = "item_drr_plasma"
DRONES_REWRITE.AmmoTypes.Blaster = "item_drr_blaster"
DRONES_REWRITE.AmmoTypes.RailgunSticks = "item_drr_rgun"

DRONES_REWRITE.AmmoTypes.SpyDrones = "item_drr_spydr"
--PATH addons/_drones/lua/dronesrewrite/properties.lua:
properties.Add("drr-openupgr", {
	MenuLabel =	"Upgrades and Modules",
	MenuIcon = "icon16/cog.png",

	Filter = function(self, ent, ply)
		return ent.IS_DRR
	end,

	Action = function(self, ent)
		ent:OpenUpgradesMenu()
	end
})

properties.Add("drr-openweps", {
	MenuLabel =	"Add / Remove weapons",
	MenuIcon = "icon16/add.png",

	Filter = function(self, ent, ply)
		return ent.IS_DRR
	end,

	Action = function(self, ent)
		ent:CallWeaponsMenu()
	end
})

properties.Add("drr-openbinds", {
	MenuLabel =	"Add additional weapons' keys",
	MenuIcon = "icon16/key_add.png",

	Filter = function(self, ent, ply)
		return ent.IS_DRR
	end,

	Action = function(self, ent)
		ent:CallBindMenu()
	end
})

properties.Add("drr-openguide", {
	MenuLabel =	"Drones Help",
	MenuIcon = "icon16/book.png",

	Filter = function(self, ent, ply)
		return ent.IS_DRR
	end,

	Action = function(self, ent)
		DRONES_REWRITE.ShowHelpWindow("F.A.Q.")
	end
})
--PATH addons/_drones/lua/dronesrewrite/client/hud/gpros.lua:
DRONES_REWRITE.HUD["GPROSupport"] = function(drone)
	local shouldDrawCrosshair = drone.HUD_shouldDrawCrosshair
	local shouldDrawHealth = drone.HUD_shouldDrawHealth
	local shouldDrawTargets = drone.HUD_shouldDrawTargets
	local shouldDrawFuel = drone.HUD_shouldDrawFuel
	local shouldDrawCenter = drone.HUD_shouldDrawCenter
	local shouldDrawWeps = drone.HUD_shouldDrawWeps

	local x, y = ScrW(), ScrH()

	local pos = (drone:GetForward() * 10 + drone:LocalToWorld(drone.FirstPersonCam_pos)):ToScreen()

	if shouldDrawCrosshair then
		surface.SetMaterial(Material("stuff/gprohud/cross_inner"))
		surface.SetDrawColor(Color(255, 255, 255))
		surface.DrawTexturedRect(x * 0.5 - 64, y * 0.5 - 64, 128, 128)
	end

	if shouldDrawTargets then
		for k, v in ipairs(ents.FindInSphere(drone:GetCameraTraceLine(nil, Vector(-50, -50, 0), Vector(50, 50, 0)).HitPos, 400)) do
			if not v:IsPlayer() and not v:IsNPC() and not v.IS_DRONE then continue end
			if v.IS_DRONE and v:IsDroneDestroyed() then continue end
			if v == drone then continue end

			-- Calculating target position
			local pos = v:LocalToWorld(v:OBBCenter())
			local bone = v:LookupBone("ValveBiped.Bip01_Head1")
			if bone then pos = v:GetBonePosition(bone) end

			pos = pos:ToScreen()

			surface.SetMaterial(Material("stuff/gprohud/human_t"))
			surface.SetDrawColor(Color(255, 255, 255, 100))
			surface.DrawTexturedRect(pos.x - 32, pos.y - 32, 64, 64)
		end
	end

	if shouldDrawCenter then


		surface.SetMaterial(Material("stuff/gprohud/cross_frame"))
		surface.DrawTexturedRectRotated(pos.x, pos.y, 128, 128, 0)

		local newy = 30

		if shouldDrawHealth then
			surface.SetMaterial(Material("stuff/bar"))
			surface.SetDrawColor(Color(255, 100, 100, 200))
			
			surface.DrawOutlinedRect(pos.x - 378, pos.y - 15 + newy, 251, 30)
			for i = 1, (drone:GetHealth() / drone:GetDefaultHealth()) * 16 do
				surface.DrawTexturedRect(pos.x + i * 15 - 400, pos.y - 15 + newy, 40, 30)
			end

			draw.SimpleText("HEALTH", "DronesRewrite_font1", pos.x - 378, pos.y + 15 + newy, Color(255, 255, 255, 200), TEXT_ALIGN_LEFT)
		end

		if shouldDrawFuel then
			surface.SetMaterial(Material("stuff/bar"))
			surface.SetDrawColor(Color(255, 200, 100, 200))
			
			surface.DrawOutlinedRect(pos.x + 127, pos.y - 15 + newy, 251, 30)
			for i = 1, (drone:GetFuel() / drone.MaxFuel) * 16 do
				surface.DrawTexturedRect(pos.x + i * 15 + 105, pos.y - 15 + newy, 40, 30)
			end

			draw.SimpleText("FUEL", "DronesRewrite_font1", pos.x + 375, pos.y + 15 + newy, Color(255, 255, 255, 200), TEXT_ALIGN_RIGHT)
		end

		if shouldDrawWeps then
			-- Primary
			surface.SetMaterial(Material("stuff/bar"))
			surface.SetDrawColor(Color(100, 255, 100, 200))
			
			surface.DrawOutlinedRect(pos.x - 378, pos.y - 15 - newy, 251, 30)
			for i = 1, (drone:GetPrimaryAmmo() / drone:GetPrimaryMax()) * 16 do
				surface.DrawTexturedRect(pos.x + i * 15 - 400, pos.y - 15 - newy, 40, 30)
			end

			draw.SimpleText("PRM AMMO", "DronesRewrite_font1", pos.x - 378, pos.y - 60 - newy, Color(255, 255, 255, 200), TEXT_ALIGN_LEFT)


			-- Secondary
			surface.SetMaterial(Material("stuff/bar"))
			surface.SetDrawColor(Color(100, 255, 100, 200))
			
			surface.DrawOutlinedRect(pos.x + 127, pos.y - 15 - newy, 251, 30)
			for i = 1, (drone:GetSecondaryAmmo() / drone:GetSecondaryMax()) * 16 do
				surface.DrawTexturedRect(pos.x + i * 15 + 105, pos.y - 15 - newy, 40, 30)
			end

			draw.SimpleText("SCND AMMO", "DronesRewrite_font1", pos.x + 375, pos.y - 60 - newy, Color(255, 255, 255, 200), TEXT_ALIGN_RIGHT)

			local curWep = drone:GetNWString("CurrentWeapon")
			draw.SimpleText("WEAPON: " .. curWep, "DronesRewrite_font1", pos.x, pos.y + 100, Color(255, 255, 255, 200), TEXT_ALIGN_CENTER)
		end
	end

	
end
--PATH addons/_drones/lua/dronesrewrite/client/hud/nohud.lua:
DRONES_REWRITE.HUD["No HUD"] = function(drone)
end
--PATH addons/_drones/lua/dronesrewrite/weapons/dmgun.lua:
DRONES_REWRITE.Weapons["Double Gun"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, "models/dronesrewrite/doublegun/doublegun.mdl", pos, ang, "models/dronesrewrite/attachment4/attachment4.mdl", pos)

		DRONES_REWRITE.Weapons["Template"].SpawnSource(ent, Vector(40, 0, 3))

		ent.PrimaryAmmo = 2000
		ent.PrimaryAmmoMax = 2000
		ent.PrimaryAmmoType = { DRONES_REWRITE.AmmoTypes.Pistol }

		return ent
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)
	end,

	Attack = function(self, gun)
		if CurTime() > gun.NextShoot and gun:HasPrimaryAmmo() then
			local damage = 8
			local force = 25

			local tr = self:GetCameraTraceLine()

			local bullet = {}
			bullet.Num = 1
			bullet.Src = gun.Source:GetPos()
			bullet.Dir = gun:GetLocalCamDir()
			bullet.Spread = Vector(0.02, 0.02, 0.02)
			bullet.Tracer = 1
			bullet.Force = force
			bullet.Damage = damage
			bullet.Attacker = self:GetDriver()
			
			gun.Source:FireBullets(bullet)
			gun:EmitSound("weapons/shotgun/shotgun_fire" .. math.random(6, 7) .. ".wav", 85, math.random(150, 180), 1, CHAN_WEAPON)

			local bullet = {}
			bullet.Num = 1
			bullet.Src = gun.Source:LocalToWorld(Vector(0, 0, -3))
			bullet.Dir = gun:GetLocalCamDir()
			bullet.Spread = Vector(0.02, 0.02, 0.02)
			bullet.Tracer = 1
			bullet.Force = force
			bullet.Damage = damage
			bullet.Attacker = self:GetDriver()
			
			gun.Source:FireBullets(bullet)
			gun:EmitSound("weapons/shotgun/shotgun_fire" .. math.random(6, 7) .. ".wav", 85, math.random(150, 180), 1, CHAN_WEAPON)

			local phys = self:GetPhysicsObject()
			phys:ApplyForceCenter((gun:GetPos() - tr.HitPos):GetNormal() * 200)
			phys:AddAngleVelocity(VectorRand() * 1.2)
			
			local ef = EffectData()
			ef:SetOrigin(gun.Source:GetPos())
			ef:SetNormal(gun:GetForward())
			util.Effect("dronesrewrite_muzzleflash", ef)

			gun:SetPrimaryAmmo(-1)
			gun.NextShoot = CurTime() + 0.07
		end
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/shield.lua:
DRONES_REWRITE.Weapons["Shield"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].InitializeNoHandler(self, "models/dronesrewrite/shieldgen/shieldgen.mdl", pos, ang)

		ent.ShieldActive = false
		ent.ShieldEnergy = 100
		ent.WaitEffect = 0
		ent.WaitShieldSlow = 0

		ent.SetShield = function(ent, n)
			ent.ShieldActive = n

			if n then
				hook.Add("EntityTakeDamage", "dronesrewrite_shielddmgdec" .. ent:EntIndex(), function(target, dmgInfo)
					if target:GetPos():Distance(ent:GetPos()) < 400 then
						dmgInfo:ScaleDamage(0.5)
					end
				end)

				self:SwitchLoopSound("Shield", true, "ambient/energy/force_field_loop1.wav", 255)

				local e = ents.Create("prop_physics")
				e:SetPos(ent:GetPos())
				e:SetAngles(ent:GetAngles())
				e:SetModel("models/dronesrewrite/shield_draw/shield.mdl")
				e:SetMaterial("models/props_combine/stasisshield_sheet_dx7")
				e:Spawn()
				e:Activate()
				e:DrawShadow(false)
				e:SetParent(ent)
				e:SetNotSolid(true)
				e:PhysicsDestroy()

				ParticleEffectAttach("vapor_drr", 1, e, 1)

				ent.ShieldMdl = e

				self:AddHookClient("HUD", "ShieldDraw", [[
					local drone = LocalPlayer():GetNWEntity("DronesRewriteDrone")

					if drone:IsValid() then
						drone:DrawIndicator("Shield sphere", drone:GetNWInt("ShieldEnergy"))
					end
				]])
			else
				hook.Remove("EntityTakeDamage", "dronesrewrite_shielddmgdec" .. ent:EntIndex())
				self:SwitchLoopSound("Shield", false)
				SafeRemoveEntity(ent.ShieldMdl)
			end
		end

		ent.Healths = { }

		return ent
	end,

	Think = function(self, gun)
		if self:IsDroneDestroyed() then
			gun:SetShield(false)
			return
		end

		local num = math.floor(gun.ShieldEnergy)
		self:SetNWInt("ShieldEnergy", num)

		if gun.ShieldActive then
			gun.ShieldEnergy = math.Approach(gun.ShieldEnergy, 0, 0.02)

			local ef = EffectData()
			ef:SetStart(Vector(0, 0, 0))
			ef:SetOrigin(gun:GetPos() + VectorRand() * 400)
			ef:SetEntity(gun)
			ef:SetAngles(Angle(0, 255, 255)) -- Color
			util.Effect("dronesrewrite_beam", ef)

			if CurTime() > gun.WaitEffect then
				ParticleEffect("electrical_arc_01_parent", gun:GetPos(), Angle(0, 0, 0))

				gun.WaitEffect = CurTime() + math.Rand(0.1, 0.4)
			end

			if CurTime() > gun.WaitShieldSlow then
				local projs = ents.FindInSphere(gun:GetPos(), 400)
				for _, v in pairs(projs) do
					if v == self then continue end
					
					local phys = v:GetPhysicsObject()
					local slowCoefficient = 0.3
						
					if phys:IsValid() then
						phys:SetVelocity(phys:GetVelocity() * slowCoefficient)
						phys:SetAngleVelocity(phys:GetAngleVelocity() * slowCoefficient)
					else
						v:SetVelocity(v:GetVelocity() * slowCoefficient)
						v:SetLocalAngularVelocity(v:GetLocalAngularVelocity() * slowCoefficient)
					end
				end

				gun.WaitShieldSlow = CurTime() + 0.1
			end

			if gun.ShieldEnergy <= 0 then
				gun:SetShield(false)
			end
		else
			gun.ShieldEnergy = math.Approach(gun.ShieldEnergy, 100, 0.02)
		end
	end,

	Attack = function(self, gun)
		if CurTime() > gun.NextShoot then
			if not gun.ShieldActive and gun.ShieldEnergy >= 20 then
				gun:SetShield(true)
			else
				gun:SetShield(false)
			end

			gun:EmitSound("items/suitchargeok1.wav", 85, math.random(180, 200), 1, CHAN_WEAPON)

			gun.NextShoot = CurTime() + 0.5
		end
	end,

	OnRemove = function(self, gun)
		gun:SetShield(false)
		self:RemoveHookClient("HUD", "ShieldDraw")
	end
}
--PATH addons/_fpr/lua/fprofiler/ui/clientcontrol.lua:
local get, update, onUpdate = FProfiler.UI.getModelValue, FProfiler.UI.updateModel, FProfiler.UI.onModelUpdate

--[[-------------------------------------------------------------------------
(Re)start clientside profiling
---------------------------------------------------------------------------]]
local function restartProfiling()
    if get({"client", "shouldReset"}) then
        FProfiler.Internal.reset()
        update({"client", "recordTime"}, 0)
    end

    local focus = get({"client", "focusObj"})

    update({"client", "sessionStart"}, CurTime())
    update({"client", "sessionStartSysTime"}, SysTime())
    FProfiler.Internal.start(focus)
end

--[[-------------------------------------------------------------------------
Stop profiling
---------------------------------------------------------------------------]]
local function stopProfiling()
    FProfiler.Internal.stop()

    local newTime = get({"client", "recordTime"}) + SysTime() - (get({"client", "sessionStartSysTime"}) or 0)

    -- Get the aggregated data
    local mostTime = FProfiler.Internal.getAggregatedResults(100)

    update({"client", "bottlenecks"}, mostTime)
    update({"client", "topLagSpikes"}, FProfiler.Internal.getMostExpensiveSingleCalls())

    update({"client", "recordTime"}, newTime)
    update({"client", "sessionStart"}, nil)
    update({"client", "sessionStartSysTime"}, nil)
end

--[[-------------------------------------------------------------------------
Start/stop recording when the recording status is changed
---------------------------------------------------------------------------]]
onUpdate({"client", "status"}, function(new, old)
    if new == old then return end
    (new == "Started" and restartProfiling or stopProfiling)()
end)

--[[-------------------------------------------------------------------------
Update the current selected focus object when data is entered
---------------------------------------------------------------------------]]
onUpdate({"client", "focusStr"}, function(new)
    update({"client", "focusObj"}, FProfiler.funcNameToObj(new))
end)

--[[-------------------------------------------------------------------------
Update info when a different line is selected
---------------------------------------------------------------------------]]
onUpdate({"client", "currentSelected"}, function(new)
    if not new or not new.info or not new.info.linedefined or not new.info.lastlinedefined or not new.info.short_src then return end

    update({"client", "sourceText"}, FProfiler.readSource(new.info.short_src, new.info.linedefined, new.info.lastlinedefined))
end)

--[[-------------------------------------------------------------------------
When a function is to be printed to console
---------------------------------------------------------------------------]]
onUpdate({"client", "toConsole"}, function(data)
    if not data then return end

    update({"client", "toConsole"}, nil)
    show(data)

    file.CreateDir("fprofiler")
    file.Write("fprofiler/profiledata.txt", showStr(data))
    MsgC(Color(200, 200, 200), "-----", Color(120, 120, 255), "NOTE", Color(200, 200, 200), "---------------\n")
    MsgC(Color(200, 200, 200), "If the above function does not fit in console, you can find it in data/fprofiler/profiledata.txt\n\n")
end)

--[[-------------------------------------------------------------------------
API function: start profiling
---------------------------------------------------------------------------]]
function FProfiler.start(focus)
    update({"client", "focusStr"}, tostring(focus))
    update({"client", "focusObj"}, focus)
    update({"client", "shouldReset"}, true)
    update({"client", "status"}, "Started")
end

--[[-------------------------------------------------------------------------
API function: stop profiling
---------------------------------------------------------------------------]]
function FProfiler.stop()
    update({"client", "status"}, "Stopped")
end

--[[-------------------------------------------------------------------------
API function: continue profiling
---------------------------------------------------------------------------]]
function FProfiler.continueProfiling()
    update({"client", "shouldReset"}, false)
    update({"client", "status"}, "Started")
end

--PATH addons/____bricks_framework/lua/sh_cami.lua:
--[[
CAMI - Common Admin Mod Interface.
Copyright 2020 CAMI Contributors

Makes admin mods intercompatible and provides an abstract privilege interface
for third party addons.

Follows the specification on this page:
https://github.com/glua/CAMI/blob/master/README.md

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

-- Version number in YearMonthDay format.
local version = 20201130

if CAMI and CAMI.Version >= version then return end

CAMI = CAMI or {}
CAMI.Version = version


--- @class CAMI_USERGROUP
--- defines the charactaristics of a usergroup
--- @field Name string @The name of the usergroup
--- @field Inherits string @The name of the usergroup this usergroup inherits from

--- @class CAMI_PRIVILEGE
--- defines the charactaristics of a privilege
--- @field Name string @The name of the privilege
--- @field MinAccess "'user'" | "'admin'" | "'superadmin'" @Default group that should have this privilege
--- @field Description string | nil @Optional text describing the purpose of the privilege
local CAMI_PRIVILEGE = {}
--- Optional function to check if a player has access to this privilege
--- (and optionally execute it on another player)
---
--- ⚠ **Warning**: This function may not be called by all admin mods
--- @param actor GPlayer @The player
--- @param target GPlayer | nil @Optional - the target
--- @return boolean @If they can or not
--- @return string | nil @Optional reason
function CAMI_PRIVILEGE:HasAccess(actor, target)
end

--- Contains the registered CAMI_USERGROUP usergroup structures.
--- Indexed by usergroup name.
--- @type CAMI_USERGROUP[]
local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
    user = {
        Name = "user",
        Inherits = "user"
    },
    admin = {
        Name = "admin",
        Inherits = "user"
    },
    superadmin = {
        Name = "superadmin",
        Inherits = "admin"
    }
}

--- Contains the registered CAMI_PRIVILEGE privilege structures.
--- Indexed by privilege name.
--- @type CAMI_PRIVILEGE[]
local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}

--- Registers a usergroup with CAMI.
---
--- Use the source parameter to make sure CAMI.RegisterUsergroup function and
--- the CAMI.OnUsergroupRegistered hook don't cause an infinite loop
--- @param usergroup CAMI_USERGROUP @The structure for the usergroup you want to register
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return CAMI_USERGROUP @The usergroup given as an argument
function CAMI.RegisterUsergroup(usergroup, source)
    usergroups[usergroup.Name] = usergroup

    hook.Call("CAMI.OnUsergroupRegistered", nil, usergroup, source)
    return usergroup
end

--- Unregisters a usergroup from CAMI. This will call a hook that will notify
--- all other admin mods of the removal.
---
--- ⚠ **Warning**: Call only when the usergroup is to be permanently removed.
---
--- Use the source parameter to make sure CAMI.UnregisterUsergroup function and
--- the CAMI.OnUsergroupUnregistered hook don't cause an infinite loop
--- @param usergroupName string @The name of the usergroup.
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterUsergroup(usergroupName, source)
    if not usergroups[usergroupName] then return false end

    local usergroup = usergroups[usergroupName]
    usergroups[usergroupName] = nil

    hook.Call("CAMI.OnUsergroupUnregistered", nil, usergroup, source)

    return true
end

--- Retrieves all registered usergroups.
--- @return CAMI_USERGROUP[] @Usergroups indexed by their names.
function CAMI.GetUsergroups()
    return usergroups
end

--- Receives information about a usergroup.
--- @param usergroupName string
--- @return CAMI_USERGROUP | nil @Returns nil when the usergroup does not exist.
function CAMI.GetUsergroup(usergroupName)
    return usergroups[usergroupName]
end

--- Checks to see if potentialAncestor is an ancestor of usergroupName.
--- All usergroups are ancestors of themselves.
---
--- Examples:
--- * `user` is an ancestor of `admin` and also `superadmin`
--- * `admin` is an ancestor of `superadmin`, but not `user`
--- @param usergroupName string @The usergroup to query
--- @param potentialAncestor string @The ancestor to query
--- @return boolean @Whether usergroupName inherits potentialAncestor.
function CAMI.UsergroupInherits(usergroupName, potentialAncestor)
    repeat
        if usergroupName == potentialAncestor then return true end

        usergroupName = usergroups[usergroupName] and
                         usergroups[usergroupName].Inherits or
                         usergroupName
    until not usergroups[usergroupName] or
          usergroups[usergroupName].Inherits == usergroupName

    -- One can only be sure the usergroup inherits from user if the
    -- usergroup isn't registered.
    return usergroupName == potentialAncestor or potentialAncestor == "user"
end

--- Find the base group a usergroup inherits from.
---
--- This function traverses down the inheritence chain, so for example if you have
--- `user` -> `group1` -> `group2`
--- this function will return `user` if you pass it `group2`.
---
--- ℹ **NOTE**: All usergroups must eventually inherit either user, admin or superadmin.
--- @param usergroupName string @The name of the usergroup
--- @return "'user'" | "'admin'" | "'superadmin'" @The name of the root usergroup
function CAMI.InheritanceRoot(usergroupName)
    if not usergroups[usergroupName] then return end

    local inherits = usergroups[usergroupName].Inherits
    while inherits ~= usergroups[usergroupName].Inherits do
        usergroupName = usergroups[usergroupName].Inherits
    end

    return usergroupName
end

--- Registers an addon privilege with CAMI.
---
--- ⚠ **Warning**: This should only be used by addons. Admin mods must *NOT*
---  register their privileges using this function.
--- @param privilege CAMI_PRIVILEGE
--- @return CAMI_PRIVILEGE @The privilege given as argument.
function CAMI.RegisterPrivilege(privilege)
    privileges[privilege.Name] = privilege

    hook.Call("CAMI.OnPrivilegeRegistered", nil, privilege)

    return privilege
end

--- Unregisters a privilege from CAMI.
--- This will call a hook that will notify any admin mods of the removal.
---
--- ⚠ **Warning**: Call only when the privilege is to be permanently removed.
--- @param privilegeName string @The name of the privilege.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterPrivilege(privilegeName)
    if not privileges[privilegeName] then return false end

    local privilege = privileges[privilegeName]
    privileges[privilegeName] = nil

    hook.Call("CAMI.OnPrivilegeUnregistered", nil, privilege)

    return true
end

--- Retrieves all registered privileges.
--- @return CAMI_PRIVILEGE[] @All privileges indexed by their names.
function CAMI.GetPrivileges()
    return privileges
end

--- Receives information about a privilege.
--- @param privilegeName string
--- @return CAMI_PRIVILEGE | nil
function CAMI.GetPrivilege(privilegeName)
    return privileges[privilegeName]
end

-- Default access handler
local defaultAccessHandler = {["CAMI.PlayerHasAccess"] =
    function(_, actorPly, privilegeName, callback, targetPly, extraInfoTbl)
        -- The server always has access in the fallback
        if not IsValid(actorPly) then return callback(true, "Fallback.") end

        local priv = privileges[privilegeName]

        local fallback = extraInfoTbl and (
            not extraInfoTbl.Fallback and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "user" and true or
            extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())


        if not priv then return callback(fallback, "Fallback.") end

        local hasAccess =
            priv.MinAccess == "user" or
            priv.MinAccess == "admin" and actorPly:IsAdmin() or
            priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()

        if hasAccess and priv.HasAccess then
            hasAccess = priv:HasAccess(actorPly, targetPly)
        end

        callback(hasAccess, "Fallback.")
    end,
    ["CAMI.SteamIDHasAccess"] =
    function(_, _, _, callback)
        callback(false, "No information available.")
    end
}

--- @class CAMI_ACCESS_EXTRA_INFO
--- @field Fallback "'user'" | "'admin'" | "'superadmin'" @Fallback status for if the privilege doesn't exist. Defaults to `admin`.
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a player has access to a privilege
--- (and optionally can execute it on targetPly)
---
--- This function is designed to be asynchronous but will be invoked
---  synchronously if no callback is passed.
---
--- ⚠ **Warning**: If the currently installed admin mod does not support
---                 synchronous queries, this function will throw an error!
--- @param actorPly GPlayer @The player to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive the answer, or nil for synchronous
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
--- @return boolean | nil @Synchronous only - if the player has the privilege
--- @return string | nil @Synchronous only - optional reason from admin mod
function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly,
extraInfoTbl)
    local hasAccess, reason = nil, nil
    local callback_ = callback or function(hA, r) hasAccess, reason = hA, r end

    hook.Call("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly,
        privilegeName, callback_, targetPly, extraInfoTbl)

    if callback ~= nil then return end

    if hasAccess == nil then
        local err = [[The function CAMI.PlayerHasAccess was used to find out
        whether Player %s has privilege "%s", but an admin mod did not give an
        immediate answer!]]
        error(string.format(err,
            actorPly:IsPlayer() and actorPly:Nick() or tostring(actorPly),
            privilegeName))
    end

    return hasAccess, reason
end

--- Get all the players on the server with a certain privilege
--- (and optionally who can execute it on targetPly)
---
--- ℹ **NOTE**: This is an asynchronous function!
--- @param privilegeName string @The privilege to query
--- @param callback fun(players: GPlayer[]) @Callback to receive the answer
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly,
extraInfoTbl)
    local allowedPlys = {}
    local allPlys = player.GetAll()
    local countdown = #allPlys

    local function onResult(ply, hasAccess, _)
        countdown = countdown - 1

        if hasAccess then table.insert(allowedPlys, ply) end
        if countdown == 0 then callback(allowedPlys) end
    end

    for _, ply in ipairs(allPlys) do
        CAMI.PlayerHasAccess(ply, privilegeName,
            function(...) onResult(ply, ...) end,
            targetPly, extraInfoTbl)
    end
end

--- @class CAMI_STEAM_ACCESS_EXTRA_INFO
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a (potentially offline) SteamID has access to a privilege
--- (and optionally if they can execute it on a target SteamID)
---
--- ℹ **NOTE**: This is an asynchronous function!
--- @param actorSteam string | nil @The SteamID to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive  the answer
--- @param targetSteam string | nil @Optional - target SteamID for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_STEAM_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback,
targetSteam, extraInfoTbl)
    hook.Call("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam,
        privilegeName, callback, targetSteam, extraInfoTbl)
end

--- Signify that your admin mod has changed the usergroup of a player. This
--- function communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param ply GPlayer @The player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalUserGroupChanged(ply, old, new, source)
    hook.Call("CAMI.PlayerUsergroupChanged", nil, ply, old, new, source)
end

--- Signify that your admin mod has changed the usergroup of a disconnected
--- player. This communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param steamId string @The steam ID of the player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
    hook.Call("CAMI.SteamIDUsergroupChanged", nil, steamId, old, new, source)
end

--PATH addons/__main/lua/autorun/heavycombine_playermodels.lua:
player_manager.AddValidHands("Heavy Combine01", "models/weapons/c_arms_combine.mdl", 0, "00000000")
list.Set("PlayerOptionsModel", "Heavy Combine01", "models/player/01AR_combine_soldier01.mdl")
player_manager.AddValidModel("Heavy Combine01", "models/player/01AR_combine_soldier01.mdl")
--PATH addons/__main_only_1st/lua/autorun/jumpforceryuk.lua:
player_manager.AddValidModel( "Jump Force - Ryuk", "models/konnie/jumpforce/ryuk.mdl" )
player_manager.AddValidHands( "Jump Force - Ryuk", "models/weapons/arms/v_arms_ryuk.mdl", 0, "00000000" )
--PATH addons/igs-core/lua/autorun/l_ingameshop.lua:
--[[-------------------------------------------------------------------------
	Веб загрузчик IGS 13.03.2021
	https://blog.amd-nick.me/github-workshop-garrysmod/
	Изначально эта задача представлялась в 3 строки
---------------------------------------------------------------------------]]
IGS = IGS or {}
 
local function log(patt, ...)
	if cookie.GetNumber("igs_verbose", 0) == 1 then
		print(string.format("[IGS] " .. patt, ...))
	end
end

concommand.Add("igs_verbose", function(pl)
	if SERVER and IsValid(pl) then return end

	local enable = cookie.GetNumber("igsverbose", 0) == 0
	cookie.Set("igsverbose", enable and 1 or 0)
	print("IGS Logging " .. (enable and "enabled" or "disabled"))
end)

local i = {} -- lua files only
i.sv = SERVER and include or function() end
i.cl = SERVER and AddCSLuaFile or include
i.sh = function(f) return i.cl(f) or i.sv(f) end


local function include_mount(sRealm, sAbsolutePath)
	if (sRealm == "sh")
	or (sRealm == "sv" and SERVER)
	or (sRealm == "cl" and CLIENT) then
		-- Чистый RunString не воспринимает return внутри файлов
		-- Но CompileString 9 апреля 2021 теоретически был причиной ошибок
		-- Пока пусть будет RunString без ретурна
		-- Заметки: https://t.me/c/1353676159/55852

		-- local executer = CompileString(content, sAbsolutePath)
		-- return executer()

		local content  = IGS_MOUNT[sAbsolutePath]
		RunString(content, sAbsolutePath)
	end
end

-- "Костыль" для работы IGS.sh/sv/cl изнутри модульных _main.lua файлов и энтити
-- с указанием относительного пути
-- не работает с ../file (наверн. Не чекал)
local iam_inside

local function incl(sRealm, sPath)
	-- Не сработает, если например в лаунчере в sh() для файлов убрать приставку "igs/"
	local isRelativePath = iam_inside and not sPath:StartWith(iam_inside)
	local sAbsolutePath  = isRelativePath and iam_inside .. "/" .. sPath or sPath
	-- /\ Мб внутри модуля уже указан full путь, а не относительный
	-- (обычно путь к _main.lua)

	-- print(sAbsolutePath)

	if IGS_MOUNT and IGS_MOUNT[sAbsolutePath] then -- 1st check for lua load (not web)
		log("%s Иклюд с MOUNT. Путь: %s", sRealm, sAbsolutePath)
		return include_mount(sRealm, sAbsolutePath)
	else
		log("%s Иклюд с LUA. Путь: %s", sRealm, sAbsolutePath)
		local fIncluder = i[sRealm]
		return fIncluder(sAbsolutePath)
	end
end

function IGS.sh(sPath) return incl("sh", sPath) end
function IGS.sv(sPath) return incl("sv", sPath) end
function IGS.cl(sPath) return incl("cl", sPath) end

local function findKeys(arr, patt)
	local found = {}
	for key,val in pairs(arr) do
		local match = key:match(patt)
		if match then
			table.insert(found, match)
		end
	end
	return found
end

-- Тяжелая, но пока в оптимизации не нуждается
-- При выборке модулей и энтити элементы повторяются
local function unique(arr)
	local ret = {}
	for _,v in ipairs(arr) do
		if not table.HasValue(ret, v) then
			table.insert(ret, v)
		end
	end
	return ret
end

local function findInMount(patt)
	return IGS_MOUNT and findKeys(IGS_MOUNT, patt) or {}
end

function IGS.include_files(sPath, fIncluder) -- igs/extensions
	local data_files = findInMount("^" .. sPath:PatternSafe() .. "/(.*%.lua)$")
	local lua_files  = file.Find(sPath .. "/*.lua","LUA")
	table.Add(data_files, lua_files)

	for _,fileName in ipairs(data_files) do
		fIncluder(sPath .. "/" .. fileName)
	end
end

function IGS.load_modules(sBasePath) -- igs/modules
	local data_modules  = findInMount("^" .. sBasePath .. "/([^/]*)/_main%.lua$")
	data_modules = unique(data_modules)
	local _,lua_modules = file.Find(sBasePath .. "/*","LUA")
	table.Add(data_modules, lua_modules)

	for _,mod in ipairs(data_modules) do
		local sModPath = sBasePath .. "/" .. mod
		iam_inside = sModPath
		IGS.sh(sModPath .. "/_main.lua") -- igs/modules/inv_log/_main.lua
	end
	iam_inside = nil
end

function IGS.load_entities()
	log("Загрузка энтити")
	local entities = findInMount("^entities/([^/]*)/(.*%.lua)$")
	entities = unique(entities) -- {ent_igs, npc_igs}

	for _,ent_class in ipairs(entities) do
		iam_inside = "entities/" .. ent_class
		ENT = {}
		ENT.Folder = iam_inside

		if SERVER then IGS.sv("init.lua")
		else IGS.cl("cl_init.lua") end
		scripted_ents.Register(ENT, ent_class)

		iam_inside = nil
		ENT = nil
	end
end


concommand.Add("igs_flushversion", function(pl)
	if IsValid(pl) then print("console only") return end
	cookie.Set("igs_version", nil)
	print("OK. После перезагрузки сервер скачает новую версию")
end)

-- мб ему место в launcher?
local igs_version = CreateConVar("igs_version", "", {FCVAR_NOTIFY, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE})

if SERVER and igs_version:GetString() == "" then
	local version = cookie.GetString("igs_version")
	igs_version:SetString(version or "777") -- "or" for case when igsmod isn't ran (core hosted locally)
end

IGS.sh("igs/launcher.lua")
IGS.load_entities()

--PATH addons/igs-core/lua/igs/dependencies/plurals.lua:
local plural_type = function(i)
	return i % 10 == 1 and i % 100 ~= 11 and 1
		or (i % 10 >= 2 and i % 10 <= 4 and (i % 100 < 10 or i % 100 >= 20) and 2
			or 3
		)
end

function util.formatPlural(plurals, num)
	local type = plural_type(num)
	local suffix = plurals[type]
	return num .. " " .. suffix, suffix
end

function PLUR(plurals)
	return function(num)
		return util.formatPlural(plurals, num)
	end
end

-- local P = PLUR({"пост", "поста", "постов"})
-- PRINT(P(1), P(2), P(5))

--PATH addons/igs-core/lua/igs/dependencies/dash/hash.lua:
if hash then return end

if (SERVER) and file.Exists('lua/bin/gmsv_hash_' .. (system.IsWindows() and 'win32' or 'linux') .. '.dll', 'MOD') then -- Use gm_hash if we have it since it's a faster https://github.com/SuperiorServers/gm_hash
	_require 'hash'
	return
end

hash = {}

-- MD5 modified from https://github.com/kikito/md5.lua
do
	local char, byte, format, rep, sub = string.char, string.byte, string.format, string.rep, string.sub
	local bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift = bit.bor, bit.band, bit.bnot, bit.bxor, bit.rshift, bit.lshift

	-- convert little-endian 32-bit int to a 4-char string
	local function lei2str(i)
	  local f=function (s) return char( bit_and( bit_rshift(i, s), 255)) end
	  return f(0)..f(8)..f(16)..f(24)
	end

	-- convert raw string to big-endian int
	local function str2bei(s)
	  local v=0
	  for i=1, #s do
	    v = v * 256 + byte(s, i)
	  end
	  return v
	end

	-- convert raw string to little-endian int
	local function str2lei(s)
	  local v=0
	  for i = #s,1,-1 do
	    v = v*256 + byte(s, i)
	  end
	  return v
	end

	-- cut up a string in little-endian ints of given size
	local function cut_le_str(s,...)
	  local o, r = 1, {}
	  local args = {...}
	  for i=1, #args do
	    table.insert(r, str2lei(sub(s, o, o + args[i] - 1)))
	    o = o + args[i]
	  end
	  return r
	end

	local swap = function (w) return str2bei(lei2str(w)) end

	-- An MD5 mplementation in Lua, requires bitlib (hacked to use LuaBit from above, ugh)
	-- 10/02/2001 jcw@equi4.com

	local CONSTS = {
	  0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
	  0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
	  0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
	  0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
	  0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
	  0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
	  0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
	  0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
	  0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
	  0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
	  0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
	  0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
	  0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
	  0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
	  0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
	  0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391,
	  0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476
	}

	local f=function (x,y,z) return bit_or(bit_and(x,y),bit_and(-x-1,z)) end
	local g=function (x,y,z) return bit_or(bit_and(x,z),bit_and(y,-z-1)) end
	local h=function (x,y,z) return bit_xor(x,bit_xor(y,z)) end
	local i=function (x,y,z) return bit_xor(y,bit_or(x,-z-1)) end
	local z=function (f,a,b,c,d,x,s,ac)
	  a=bit_and(a+f(b,c,d)+x+ac,0xFFFFFFFF)
	  -- be *very* careful that left shift does not cause rounding!
	  return bit_or(bit_lshift(bit_and(a,bit_rshift(0xFFFFFFFF,s)),s),bit_rshift(a,32-s))+b
	end

	local function transform(A,B,C,D,X)
	  local a,b,c,d=A,B,C,D
	  local t=CONSTS

	  a=z(f,a,b,c,d,X[ 0], 7,t[ 1])
	  d=z(f,d,a,b,c,X[ 1],12,t[ 2])
	  c=z(f,c,d,a,b,X[ 2],17,t[ 3])
	  b=z(f,b,c,d,a,X[ 3],22,t[ 4])
	  a=z(f,a,b,c,d,X[ 4], 7,t[ 5])
	  d=z(f,d,a,b,c,X[ 5],12,t[ 6])
	  c=z(f,c,d,a,b,X[ 6],17,t[ 7])
	  b=z(f,b,c,d,a,X[ 7],22,t[ 8])
	  a=z(f,a,b,c,d,X[ 8], 7,t[ 9])
	  d=z(f,d,a,b,c,X[ 9],12,t[10])
	  c=z(f,c,d,a,b,X[10],17,t[11])
	  b=z(f,b,c,d,a,X[11],22,t[12])
	  a=z(f,a,b,c,d,X[12], 7,t[13])
	  d=z(f,d,a,b,c,X[13],12,t[14])
	  c=z(f,c,d,a,b,X[14],17,t[15])
	  b=z(f,b,c,d,a,X[15],22,t[16])

	  a=z(g,a,b,c,d,X[ 1], 5,t[17])
	  d=z(g,d,a,b,c,X[ 6], 9,t[18])
	  c=z(g,c,d,a,b,X[11],14,t[19])
	  b=z(g,b,c,d,a,X[ 0],20,t[20])
	  a=z(g,a,b,c,d,X[ 5], 5,t[21])
	  d=z(g,d,a,b,c,X[10], 9,t[22])
	  c=z(g,c,d,a,b,X[15],14,t[23])
	  b=z(g,b,c,d,a,X[ 4],20,t[24])
	  a=z(g,a,b,c,d,X[ 9], 5,t[25])
	  d=z(g,d,a,b,c,X[14], 9,t[26])
	  c=z(g,c,d,a,b,X[ 3],14,t[27])
	  b=z(g,b,c,d,a,X[ 8],20,t[28])
	  a=z(g,a,b,c,d,X[13], 5,t[29])
	  d=z(g,d,a,b,c,X[ 2], 9,t[30])
	  c=z(g,c,d,a,b,X[ 7],14,t[31])
	  b=z(g,b,c,d,a,X[12],20,t[32])

	  a=z(h,a,b,c,d,X[ 5], 4,t[33])
	  d=z(h,d,a,b,c,X[ 8],11,t[34])
	  c=z(h,c,d,a,b,X[11],16,t[35])
	  b=z(h,b,c,d,a,X[14],23,t[36])
	  a=z(h,a,b,c,d,X[ 1], 4,t[37])
	  d=z(h,d,a,b,c,X[ 4],11,t[38])
	  c=z(h,c,d,a,b,X[ 7],16,t[39])
	  b=z(h,b,c,d,a,X[10],23,t[40])
	  a=z(h,a,b,c,d,X[13], 4,t[41])
	  d=z(h,d,a,b,c,X[ 0],11,t[42])
	  c=z(h,c,d,a,b,X[ 3],16,t[43])
	  b=z(h,b,c,d,a,X[ 6],23,t[44])
	  a=z(h,a,b,c,d,X[ 9], 4,t[45])
	  d=z(h,d,a,b,c,X[12],11,t[46])
	  c=z(h,c,d,a,b,X[15],16,t[47])
	  b=z(h,b,c,d,a,X[ 2],23,t[48])

	  a=z(i,a,b,c,d,X[ 0], 6,t[49])
	  d=z(i,d,a,b,c,X[ 7],10,t[50])
	  c=z(i,c,d,a,b,X[14],15,t[51])
	  b=z(i,b,c,d,a,X[ 5],21,t[52])
	  a=z(i,a,b,c,d,X[12], 6,t[53])
	  d=z(i,d,a,b,c,X[ 3],10,t[54])
	  c=z(i,c,d,a,b,X[10],15,t[55])
	  b=z(i,b,c,d,a,X[ 1],21,t[56])
	  a=z(i,a,b,c,d,X[ 8], 6,t[57])
	  d=z(i,d,a,b,c,X[15],10,t[58])
	  c=z(i,c,d,a,b,X[ 6],15,t[59])
	  b=z(i,b,c,d,a,X[13],21,t[60])
	  a=z(i,a,b,c,d,X[ 4], 6,t[61])
	  d=z(i,d,a,b,c,X[11],10,t[62])
	  c=z(i,c,d,a,b,X[ 2],15,t[63])
	  b=z(i,b,c,d,a,X[ 9],21,t[64])

	  return A+a,B+b,C+c,D+d
	end

	function hash.MD5(s)
	  local msgLen = #s
	  local padLen = 56 - msgLen % 64

	  if msgLen % 64 > 56 then padLen = padLen + 64 end

	  if padLen == 0 then padLen = 64 end

	  s = s .. char(128) .. rep(char(0),padLen-1) .. lei2str(8*msgLen) .. lei2str(0)
	  local t = CONSTS
	  local a,b,c,d = t[65],t[66],t[67],t[68]

	  for i=1,#s,64 do
	    local X = cut_le_str(sub(s,i,i+63),4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4)
	    X[0] = table.remove(X,1) -- zero based!
	    a,b,c,d = transform(a,b,c,d,X)
	  end

	  return format("%08x%08x%08x%08x",swap(a),swap(b),swap(c),swap(d))
	end
end


-- SHA2 modified from http://lua-users.org/wiki/SecureHashAlgorithm
do
	local bit_band 		= bit.band
	local bit_ror     = bit.ror
	local bit_bxor 		= bit.bxor
	local bit_rshift 	= bit.rshift
	local bit_bnot		= bit.bnot

	local string_gsub 	= string.gsub
	local string_format = string.format
	local string_byte 	= string.byte
	local string_char   = string.char
	local string_rep	= string.rep


	local k = {
		0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
		0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
		0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
		0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
		0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
		0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
		0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
		0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
		0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
		0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
		0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
		0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
		0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
		0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
		0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
		0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
	}

	local function str2hexa (s)
		return string_gsub(s, ".", function(c)
			return string_format("%02x", string_byte(c))
		end)
	end

	local function num2s (l, n)
		local s = ""
		for i = 1, n do
			local rem = l % 256
			s = string_char(rem) .. s
			l = (l - rem) / 256
		end
		return s
	end

	local function s232num (s, i)
		local n = 0
		for i = i, i + 3 do
			n = n*256 + string_byte(s, i)
		end
		return n
	end

	local function preproc (msg, len)
		local extra = -(len + 1 + 8) % 64
		len = num2s(8 * len, 8)
		msg = msg .. "\128" .. string_rep("\0", extra) .. len
		return msg
	end

	local function initH256 (H)
		H[1] = 0x6a09e667
		H[2] = 0xbb67ae85
		H[3] = 0x3c6ef372
		H[4] = 0xa54ff53a
		H[5] = 0x510e527f
		H[6] = 0x9b05688c
		H[7] = 0x1f83d9ab
		H[8] = 0x5be0cd19
		return H
	end

	local function digestblock (msg, i, H)
		local w = {}
		for j = 1, 16 do
			w[j] = s232num(msg, i + (j - 1)*4)
		end

		for j = 17, 64 do
			local v = w[j - 15]
			local s0 = bit_bxor(bit_ror(v, 7), bit_ror(v, 18), bit_rshift(v, 3))
			v = w[j - 2]
			local s1 = bit_bxor(bit_ror(v, 17), bit_ror(v, 19), bit_rshift(v, 10))
			w[j] = w[j - 16] + s0 + w[j - 7] + s1
		end

		local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]

		for i = 1, 64 do
			local s0 = bit_bxor(bit_ror(a, 2), bit_ror(a, 13), bit_ror(a, 22))
			local maj = bit_bxor(bit_band(a, b), bit_band(a, c), bit_band(b, c))
			local t2 = s0 + maj
			local s1 = bit_bxor(bit_ror(e, 6), bit_ror(e, 11), bit_ror(e, 25))
			local ch = bit_bxor (bit_band(e, f), bit_band(bit_bnot(e), g))
			local t1 = h + s1 + ch + k[i] + w[i]

			h = g
			g = f
			f = e
			e = d + t1
			d = c
			c = b
			b = a
			a = t1 + t2
		end

		H[1] = bit_band(H[1] + a)
		H[2] = bit_band(H[2] + b)
		H[3] = bit_band(H[3] + c)
		H[4] = bit_band(H[4] + d)
		H[5] = bit_band(H[5] + e)
		H[6] = bit_band(H[6] + f)
		H[7] = bit_band(H[7] + g)
		H[8] = bit_band(H[8] + h)
	end

	local HH = {}
	function hash.SHA256(msg)
		msg = preproc(msg, #msg)
		local H = initH256(HH)
		for i = 1, #msg, 64 do
			digestblock(msg, i, H)
		end

		return str2hexa(num2s(H[1], 4)..num2s(H[2], 4)..num2s(H[3], 4)..num2s(H[4], 4)..num2s(H[5], 4)..num2s(H[6], 4)..num2s(H[7], 4)..num2s(H[8], 4))
	end
end

do
	local band = bit.band
	local bnot = bit.bnot
	local bor = bit.bor
	local bxor = bit.bxor
	local floor = math.floor

	// The four core functions - F1 is optimized somewhat
	// local function f1(x, y, z) bit.bor( bit.band( x, y ), bit.band( bit.bnot( x ), z )) end
	local function f1( x, y, z ) return bxor( z, band( x, bxor( y, z ))) end
	local function f2( x, y, z ) return bxor( y, band( z, bxor( x, y ))) end
	local function f3( x, y, z ) return bxor( bxor( x, y ), z ) end
	local function f4( x, y, z ) return bxor( y, bor( x, bnot( z ))) end

	// This is the central step in the MD5 algorithm.
	local function Step( func, w, x, y, z, flData, iStep )
		w = w + func(x, y, z) + flData

		return bor( (w * 2^iStep) % 0x100000000, floor(w % 0x100000000 * 0.5^(0x20 - iStep)) ) + x
	end

	-- This is called every tick so it has to be super optimised
	function hash.PseudoRandom( nSeed )
		nSeed = nSeed % 0x100000000

		local a = Step(f1, 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, nSeed + 0xd76aa478, 7)
		local d = Step(f1, 0x10325476, a, 0xefcdab89, 0x98badcfe, 0xe8c7b7d6, 12)
		local c = Step(f1, 0x98badcfe, d, a, 0xefcdab89, 0x242070db, 17)
		local b = Step(f1, 0xefcdab89, c, d, a, 0xc1bdceee, 22)
		a = Step(f1, a, b, c, d, 0xf57c0faf, 7)
		d = Step(f1, d, a, b, c, 0x4787c62a, 12)
		c = Step(f1, c, d, a, b, 0xa8304613, 17)
		b = Step(f1, b, c, d, a, 0xfd469501, 22)
		a = Step(f1, a, b, c, d, 0x698098d8, 7)
		d = Step(f1, d, a, b, c, 0x8b44f7af, 12)
		c = Step(f1, c, d, a, b, 0xffff5bb1, 17)
		b = Step(f1, b, c, d, a, 0x895cd7be, 22)
		a = Step(f1, a, b, c, d, 0x6b901122, 7)
		d = Step(f1, d, a, b, c, 0xfd987193, 12)
		c = Step(f1, c, d, a, b, 0xa67943ae, 17)
		b = Step(f1, b, c, d, a, 0x49b40821, 22)

		a = Step(f2, a, b, c, d, 0xf61e25e2, 5)
		d = Step(f2, d, a, b, c, 0xc040b340, 9)
		c = Step(f2, c, d, a, b, 0x265e5a51, 14)
		b = Step(f2, b, c, d, a, nSeed + 0xe9b6c7aa, 20)
		a = Step(f2, a, b, c, d, 0xd62f105d, 5)
		d = Step(f2, d, a, b, c, 0x02441453, 9)
		c = Step(f2, c, d, a, b, 0xd8a1e681, 14)
		b = Step(f2, b, c, d, a, 0xe7d3fbc8, 20)
		a = Step(f2, a, b, c, d, 0x21e1cde6, 5)
		d = Step(f2, d, a, b, c, 0xc33707f6, 9)
		c = Step(f2, c, d, a, b, 0xf4d50d87, 14)
		b = Step(f2, b, c, d, a, 0x455a14ed, 20)
		a = Step(f2, a, b, c, d, 0xa9e3e905, 5)
		d = Step(f2, d, a, b, c, 0xfcefa3f8, 9)
		c = Step(f2, c, d, a, b, 0x676f02d9, 14)
		b = Step(f2, b, c, d, a, 0x8d2a4c8a, 20)

		a = Step(f3, a, b, c, d, 0xfffa3942, 4)
		d = Step(f3, d, a, b, c, 0x8771f681, 11)
		c = Step(f3, c, d, a, b, 0x6d9d6122, 16)
		b = Step(f3, b, c, d, a, 0xfde5382c, 23)
		a = Step(f3, a, b, c, d, 0xa4beeac4, 4)
		d = Step(f3, d, a, b, c, 0x4bdecfa9, 11)
		c = Step(f3, c, d, a, b, 0xf6bb4b60, 16)
		b = Step(f3, b, c, d, a, 0xbebfbc70, 23)
		a = Step(f3, a, b, c, d, 0x289b7ec6, 4)
		d = Step(f3, d, a, b, c, nSeed + 0xeaa127fa, 11)
		c = Step(f3, c, d, a, b, 0xd4ef3085, 16)
		b = Step(f3, b, c, d, a, 0x04881d05, 23)
		a = Step(f3, a, b, c, d, 0xd9d4d039, 4)
		d = Step(f3, d, a, b, c, 0xe6db99e5, 11)
		c = Step(f3, c, d, a, b, 0x1fa27cf8, 16)
		b = Step(f3, b, c, d, a, 0xc4ac5665, 23)

		a = Step(f4, a, b, c, d, nSeed + 0xf4292244, 6)
		d = Step(f4, d, a, b, c, 0x432aff97, 10)
		c = Step(f4, c, d, a, b, 0xab9423c7, 15)
		b = Step(f4, b, c, d, a, 0xfc93a039, 21)
		a = Step(f4, a, b, c, d, 0x655b59c3, 6)
		d = Step(f4, d, a, b, c, 0x8f0ccc92, 10)
		c = Step(f4, c, d, a, b, 0xffeff47d, 15)
		b = Step(f4, b, c, d, a, 0x85845e51, 21)
		a = Step(f4, a, b, c, d, 0x6fa87e4f, 6)
		d = Step(f4, d, a, b, c, 0xfe2ce6e0, 10)
		c = Step(f4, c, d, a, b, 0xa3014314, 15)
		b = Step(f4, b, c, d, a, 0x4e0811a1, 21)
		a = Step(f4, a, b, c, d, 0xf7537e82, 6)
		d = Step(f4, d, a, b, c, 0xbd3af235, 10)
		c = (0x98badcfe + Step(f4, c, d, a, b, 0x2ad7d2bb, 15)) % 0x100000000
		b = (0xefcdab89 + Step(f4, b, c, d, a, 0xeb86d391, 21)) % 0x100000000

		return floor( b / 0x10000 ) % 0x100 + floor( b / 0x1000000 ) % 0x100 * 0x100 + c % 0x100 * 0x10000 + floor( c / 0x100 ) % 0x100 * 0x1000000
	end
end

--PATH addons/igs-modification/lua/igs/settings/config_sh.lua:

-- \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/
--[[-------------------------------------------------------------------------
	ПРЕДМЕТЫ ДОБАВЛЯЮТСЯ В sh_additems.lua
---------------------------------------------------------------------------]]
-- /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\


--[[-------------------------------------------------------------------------
	Настройки валюты
---------------------------------------------------------------------------]]
IGS.C.CURRENCY_NAME = "₴" -- Фановое название. Можете изменить
IGS.C.CURRENCY_SIGN = "₴"

-- Множественные названия валюты.
-- Пример 1: Доллар, Доллара, Долларов
-- Пример 2: Поинт,  Поинта,  Поинтов
IGS.C.CurrencyPlurals = {
	"₴",  -- 1 алкобакс
	"₴", -- 3 алкобакса
	"₴" -- 5 алкобаксов
}


--[[-------------------------------------------------------------------------
	Настройки активации интерфейса
---------------------------------------------------------------------------]]
-- На какую кнопку будет открываться донат менюшка
-- https://wiki.facepunch.com/gmod/Enums/KEY
IGS.C.MENUBUTTON = KEY_F6


-- /команда для открытия донат менюшки
IGS.C.COMMANDS = {
	["donate"] = true,
	["донат"]  = true,
}


--[[-------------------------------------------------------------------------
	Донат инвентарь
---------------------------------------------------------------------------]]
-- Если отключить, вкладка инвентаря исчезнет, а предметы при покупке сразу будут активироваться
-- Станут недоступны некоторые методы, вроде :SetItems(, так как используют инвентарь
IGS.C.Inv_Enabled = true

-- Разрешить выбрасывать предметы с инвентаря на пол
-- Это позволит игрокам покупать донат подарки для друзей или вам делать донат раздачи
IGS.C.Inv_AllowDrop = false



if SERVER then return end -- не смотрите так на меня :)


-- Показывать ли уведомление о новых предметах в донат меню
-- Выглядит вот так https://img.qweqwe.ovh/1526574184864.png
IGS.C.NotifyAboutNewItems = true


-- Эта иконка будет отображена для предмета, если для него не будет установлена кастомная через :SetIcon()
-- Отображается вот тут: https://img.qweqwe.ovh/1494088609445.png
IGS.C.DefaultIcon = "https://i.imgur.com/mLoHaCE.jpg"




-- Уберите "--" с начала строки, чтобы отключить появление определенного фрейма
IGS.C.DisabledFrames = {
	-- ["faq_and_help"] = true, -- Чат бот (страница помощи)
	-- ["profile"]      = true, -- Страница профиля игрока (с транзакциями)
	-- ["purchases"]    = true, -- Активные покупки
}


-- Оставьте так, если не уверены
-- Инфо: https://vk.cc/6xaFOe
IGS.C.DATE_FORMAT = "%d.%m.%y %H:%M:%S"
IGS.C.DATE_FORMAT_SHORT = "%d.%m.%y"

--PATH addons/igs-core/lua/igs/interface/skin.lua:
--[[-------------------------------------------------------------------------
	Через этот файл невозможно повсеместно изменить скин.
	Да и вообще, все в говно на самом деле, но мне лень уже делать все правильно.
	Это куча геммора, который, скорее всего, никому не нужен
---------------------------------------------------------------------------]]

IGS.S = IGS.S or {}

IGS.S.COLORS = {
	FRAME_HEADER        = Color(255,255,255), -- Фон верхушки фреймов в т.ч. пополнения счета и т.д. https://img.qweqwe.ovh/1491950958825.png
	ACTIVITY_BG         = Color(255,255,255), -- Фон в каждой вкладке (основной) https://img.qweqwe.ovh/1509370647204.png
	TAB_BAR             = Color(250,250,250), -- Фон таб бара https://img.qweqwe.ovh/1509370669492.png

	PASSIVE_SELECTIONS  = Color(240,240,240), -- Фон панели тегов, цвет кнопки с балансом, верхушки таблиц, не выделенные кнопки https://img.qweqwe.ovh/1509370720597.png
	INNER_SELECTIONS    = Color(255,255,255), -- Фон иконок на плашках, фон панелек последних покупок... https://img.qweqwe.ovh/1509370766148.png

	SOFT_LINE           = Color(240,240,240), -- Линия между секциями, типа "Информация" и "Описание" в инфе об итеме
	HARD_LINE           = Color(200,200,200), -- Обводки панелей

	HIGHLIGHTING        = Color(0,122,255),   -- Обводка кнопок, цвет текста не активной кнопки
	HIGHLIGHT_INACTIVE  = Color(160,160,160), -- Цвет иконки неактивной кнопки таббара, мигающая иконка на фрейме помощи https://img.qweqwe.ovh/1509371884592.png

	TEXT_HARD           = Color(0,0,0),       -- Заголовки, выделяющиеся тексты https://img.qweqwe.ovh/1509372019687.png
	TEXT_SOFT           = Color(140,140,150), -- Описания, значения чего-то
	TEXT_ON_HIGHLIGHT   = Color(255,255,255), -- Цвет текста на выделенных кнопках

	LOG_SUCCESS         = Color(76,217,100),  -- В логах пополнения цвет успешных операций
	LOG_ERROR           = Color(220,30,70),   -- В логах пополнения цвет ошибок
	LOG_NORMAL          = Color(0,0,0),       -- В логах пополнения обычные записи

	ICON                = Color(255,255,255), -- цвет иконок на плашечках
}

-- Вариант раскраски от Павел Тумачев (vk.com/id240371602)
-- Демо: https://img.qweqwe.ovh/1626714494454.jpg
-- IGS.S.COLORS = {
-- 	FRAME_HEADER        = Color(0,0,0),
-- 	ACTIVITY_BG         = Color(10,10,10,180),
-- 	TAB_BAR             = Color(0,0,0),

-- 	PASSIVE_SELECTIONS  = Color(0,0,0),
-- 	INNER_SELECTIONS    = Color(0,0,0),

-- 	SOFT_LINE           = Color(51,128,255),
-- 	HARD_LINE           = Color(51,128,255),

-- 	HIGHLIGHTING        = Color(51,128,255),
-- 	HIGHLIGHT_INACTIVE  = Color(255,255,255),

-- 	TEXT_HARD           = Color(255,255,255),
-- 	TEXT_SOFT           = Color(255,255,255),
-- 	TEXT_ON_HIGHLIGHT   = Color(255,255,255),

-- 	LOG_SUCCESS         = Color(76,217,100),
-- 	LOG_ERROR           = Color(255,45,85),
-- 	LOG_NORMAL          = Color(255,255,255),

-- 	ICON                = Color(255,255,255),
-- }

-- Попытки сделать темный скин интерфейса
-- IGS.S.COLORS = {
-- 	FRAME_HEADER        = Color(23,23,23),
-- 	ACTIVITY_BG         = Color(13,13,13),
-- 	TAB_BAR             = Color(23,23,23),

-- 	PASSIVE_SELECTIONS  = Color(23,23,23),
-- 	INNER_SELECTIONS    = Color(23,23,23),

-- 	SOFT_LINE           = Color(50,50,50),
-- 	HARD_LINE           = Color(66,66,66),

-- 	HIGHLIGHTING        = Color(230,130,35),
-- 	HIGHLIGHT_INACTIVE  = Color(130,130,130),

-- 	TEXT_HARD           = Color(255,255,255),
-- 	TEXT_SOFT           = Color(140,140,150),
-- 	TEXT_ON_HIGHLIGHT   = Color(255,255,255),

-- 	LOG_SUCCESS         = Color(76,217,100),
-- 	LOG_ERROR           = Color(255,45,85),
-- 	LOG_NORMAL          = Color(140,140,150),

-- 	ICON                = Color(255,255,255),
-- }

IGS.col = IGS.S.COLORS

-- https://img.qweqwe.ovh/1486557631077.png
IGS.S.Panel = function(s,w,h,lL,tL,rL,bL)
	draw.RoundedBox(0,0,0,w,h,IGS.col.PASSIVE_SELECTIONS) -- bg

	surface.SetDrawColor(IGS.col.HARD_LINE) -- outline

	if lL then surface.DrawLine(0,0,0,h) end -- left line
	if tL then surface.DrawLine(0,0,w,0) end -- top line
	if rL then surface.DrawLine(w,0,w,h) end -- right line
	if bL then surface.DrawLine(0,h - 1,w,h - 1) end -- bottom line
end

-- https://img.qweqwe.ovh/1486557676799.png
IGS.S.RoundedPanel = function(s,w,h)
	draw.RoundedBox(3,0,0,w,h,        IGS.col.HARD_LINE) -- outline
	draw.RoundedBox(3,1,1,w - 2,h - 2,IGS.col.INNER_SELECTIONS) -- bg

	return true
end

-- igs\vgui\igs_frame.lua
IGS.S.Frame = function(s,w,h)
	draw.RoundedBox(0,0,0,w,h,IGS.col.ACTIVITY_BG) -- bg

	-- /header
	local th = s:GetTitleHeight()
	draw.RoundedBox(0,0,0,w,th,IGS.col.FRAME_HEADER)
	surface.SetDrawColor(IGS.col.HARD_LINE)
	surface.DrawLine(0,th - 1,w,th - 1)
	-- \header
end

-- igs\vgui\igs_table.lua
IGS.S.TablePanel = function(s,w,h)
	if s.header_tall then
		IGS.S.Panel(s,w,s.header_tall) -- header
	end
end

-- igs_table, igs_frame
IGS.S.Outline = function(s,w,h)
	surface.SetDrawColor(IGS.col.HARD_LINE)

	-- https://img.qweqwe.ovh/1486830692390.png
	surface.DrawLine(0,h,0,0)
	surface.DrawLine(0,0,w,0)
	surface.DrawLine(w - 1,0,w - 1,h)
	surface.DrawLine(w,h - 1,0,h - 1)
end

--PATH addons/igs-core/lua/igs/interface/vgui/igs_table.lua:
local PANEL = {}

function PANEL:Init()
	self.columns = {}
	self.lines   = {}

	self.header_tall = 0

	-- Колонки, для которых указаны iWidePx
	self.nonAdjustableSpace = 0
	self.nonAdjustableItems = 0

	self.scroll = uigs.Create("igs_scroll", self)
end

function PANEL:SetTitle(sText)
	self.title = self.title or uigs.Create("DLabel", function(t)
		t:Dock(TOP)
		t:SetTall(20)
		t:SetFont("igs.20")
		t:SetTextColor(IGS.col.TEXT_HARD)
		t:SetContentAlignment(5)
		-- t:SetWrap(true) -- если раскомментить, то не будет работать SetContentAlignment
		t:SetAutoStretchVertical(true)
	end, self)

	self.title:SetText(sText)
end

function PANEL:AddColumn(sName,iWidePx)
	self.columns_panel = self.columns_panel or uigs.Create("Panel", function(p)
		p:SetTall(15)

		self.header_tall = self.header_tall + p:GetTall()
	end, self)

	table.insert(self.columns, uigs.Create("Panel", function(clmn)
		clmn.staticWide = iWidePx

		-- 10 не обязательно. Просто для заметности при отладке
		-- clmn:SetSize(clmn.staticWide or 10, self.columns_panel:GetTall())
		clmn.Paint = function(s,w,h)
			surface.SetDrawColor(IGS.col.HARD_LINE)
			surface.DrawLine(3,h - 1,w - 2,h - 1)

			surface.DrawLine(0,0,0,h)
			surface.DrawLine(w,0,w,h)

			surface.SetFont("igs.15")
			surface.SetTextColor(IGS.col.TEXT_SOFT)
			surface.SetTextPos((w - surface.GetTextSize(sName)) * 0.5,0)
			surface.DrawText(sName)
		end
	end, self.columns_panel))

	if iWidePx then
		self.nonAdjustableItems = self.nonAdjustableItems + 1
		self.nonAdjustableSpace = self.nonAdjustableSpace + iWidePx
	end

	self:PerformLayout()
end

function PANEL:AddLine(...)
	local rows = {...}

	local iKek = table.insert(self.lines,
		self.scroll:AddItem(uigs.Create("Panel", function(line)
			line:SetTall(18)
			line:Dock(TOP)
			line.columns = {}

			-- self.columns[i]:GetWide()
			for i,val in ipairs(rows) do
				line.columns[i] = uigs.Create("DButton", function(row) -- Было Panel
					row:SetText(val)
					row.DoClick = function() if line.DoClick then line.DoClick(row) end end
					row:SetCursor("arrow")
					row:SetTall( line:GetTall() )
					-- row:SetPos(self.columns[i]:GetPos())
					row.Paint = function(s,w,h)
						surface.SetDrawColor(IGS.col.HARD_LINE)
						surface.DrawLine(3,h - 1,w - 2,h - 1)

						surface.DrawLine(0,0,0,h)
						surface.DrawLine(w,0,w,h)

						surface.SetFont("igs.18")
						surface.SetTextColor(s.text_color or IGS.col.TEXT_HARD)
						surface.SetTextPos((w - surface.GetTextSize(s:GetText())) * 0.5,0)
						surface.DrawText(s:GetText())
						return true -- override
					end
				end, line)
			end
		end))
	)

	-- self:PerformLayout()
	return self.lines[iKek] -- вставленная строка
end

function PANEL:Clear()
	-- for i,linePan in ipairs(self.lines) do
	-- 	linePan:Remove()
	-- 	table.remove(self.lines,i)
	-- end

	for i = #self.lines,1,-1 do
		local linePan = self.lines[i]
		linePan:Remove()
		table.remove(self.lines,i)
	end
end

PANEL.Paint     = IGS.S.TablePanel
PANEL.PaintOver = IGS.S.Outline

function PANEL:PerformLayout()
	if self.title then
		self.header_tall = self.title:GetTall()
	end

	if self.columns_panel then
		self.columns_panel:SetPos(0,self.header_tall)
		self.columns_panel:SetWide(self:GetWide())

		--PrintTable(self.columns)

		local x = 0
		local cell_wide = (self:GetWide() - self.nonAdjustableSpace) / (#self.columns - self.nonAdjustableItems)
		-- print("#self.columns",#self.columns)
		-- print("self.nonAdjustableItems",self.nonAdjustableItems)
		-- print("self.nonAdjustableSpace",self.nonAdjustableSpace)
		for _,v in ipairs(self.columns) do
			-- print(v,v:GetPos())
			-- print(v:GetSize())
			v:SetPos(x,0)
			v:SetSize(v.staticWide or cell_wide, self.columns_panel:GetTall())

			x = x + (v.staticWide or v:GetWide())
		end

		self.header_tall = self.header_tall + self.columns_panel:GetTall()
	end

	self.scroll:SetPos(0,self.header_tall)
	self.scroll:SetSize(self:GetWide(),self:GetTall() - self.header_tall)

	for _,linePan in ipairs(self.lines) do
		for i,rowPan in ipairs(linePan.columns) do
			rowPan:SetWide(self.columns[i]:GetWide())
			rowPan:SetPos(self.columns[i]:GetPos())
		end
	end
end

vgui.Register("igs_table", PANEL, "Panel")
-- IGS.UI()

--PATH addons/igs-core/lua/igs/interface/activities/purchases.lua:
hook.Add("IGS.CatchActivities","purchases",function(activity,sidebar)
	local bg = sidebar:AddPage("Активні покупки")


	--[[-------------------------------------------------------------------------
		Основная часть фрейма
	---------------------------------------------------------------------------]]
	uigs.Create("igs_table", function(pnl)
		pnl:Dock(FILL)
		pnl:DockMargin(5,5,5,5)

		pnl:SetTitle("Активні покупки")

		local multisv = IGS.SERVERS.TOTAL > 1
		if multisv then
			pnl:AddColumn("Сервер",100)
		else
			pnl:AddColumn("#",40)
		end

		pnl:AddColumn("Предмет")
		pnl:AddColumn("Куплений",90)
		pnl:AddColumn("Закінчиться",90)


		IGS.GetMyPurchases(function(d)
			if not IsValid(pnl) then return end -- Долго данные получались, фрейм успели закрыть

			IGS.AddTextBlock(bg.side,"Що тут?",
				#d == 0 and
					"Тут будуть Відображатися ваші активні покупки\n\n" ..
					"Хіба не найкращий час, щоб зробити першу?\n\n" ..
					"Табличка зразу стане красивішою. Чесно-чесно"
					or
					"Ліворуч відображаються ваші активні послуги.\n\n" ..
					"Чим больше послуг, тим красивіше ця табличка виглядає, а адміністрація більша щастлива;)"
			)

			IGS.AddButton(bg.side,"Купити плюшку",function()
				if #IGS.GetItems() == 0 then -- если NULL уберу
					LocalPlayer():ChatPrint("Налаштуйте предмети автодоната в sh_additems.lua")
					return
				end

				while true do
					local random_ITEM = table.Random(IGS.GetItems())
					if not random_ITEM:IsHidden() then
						IGS.WIN.Item(random_ITEM:UID())
						break
					end
				end
			end)

			for i,v in ipairs(d) do
				local sv_name = IGS.ServerName(v.server)
				local ITEM    = IGS.GetItemByUID(v.item)
				local sName   = ITEM.isnull and v.item or ITEM:Name()

				pnl:AddLine(
					-- v.id,
					multisv and sv_name or #d - i + 1,
					sName,
					IGS.TimestampToDate(v.purchase) or "Ніколи",
					IGS.TimestampToDate(v.expire)   or "Ніколи"
				):SetTooltip("ім'я сервера: " .. sv_name .. "\nID в системі: " .. v.id .. "\nОригінальна назва: " .. v.item)
			end
		end)
	end, bg)

	activity:AddTab("Покупки",bg,"materials/ukrainerp/log.png")
end)

-- IGS.UI()

--PATH addons/_hitreg/lua/leyhitreg/client/sendshots/sendshots.lua:

local IsValid = IsValid
local inputIsMouseDown = input.IsMouseDown
local vector_origin = vector_origin

IN_LEYHITREG1 = bit.lshift(1, 27)

function LeyHitreg:ShouldPrimaryAttack()
    return inputIsMouseDown(MOUSE_LEFT) or inputIsMouseDown(MOUSE_RIGHT)
end

local lastPrim = nil
function LeyHitreg:CanShoot(cmd, wep, primary)
    local canShoot = true

    local nextPrim = wep:GetNextPrimaryFire()

    if (primary) then
        if (nextPrim == lastPrim or wep:Clip1() == 0) then
            canShoot = false
        else
            lastPrim = nextPrim
        end
    end

    return canShoot
end

local bitbor = bit.bor
local trace = {}
local traceres = {}
trace.filter = LocalPlayer()
trace.mask = MASK_SHOT
trace.output = traceres

local lply = nil

timer.Create("LeyHitreg.LocalPlayerGet", 0.1, 0, function()
    if (not lply and IsValid(LocalPlayer())) then
        lply = LocalPlayer()
        trace.filter = lply
        timer.Remove("LeyHitreg.LocalPlayerGet")
    end
end)

LeyHitreg.WeaponSpreads = {}

function LeyHitreg:IsAutoWep(wep)
    if (wep.Primary) then
        return wep.Primary.Automatic
    end

    return true
end

local NeedsPrimReset = false

function LeyHitreg:CreateMove(cmd)
    if (not lply or LeyHitreg.Disabled or LeyHitreg.DisabledOnlyOnClient) then
        return
    end

    local spreadWep = lply.LeyHitreg_NeedsSpreadForce

    if (spreadWep and IsValid(spreadWep)) then
        LeyHitreg:SetFittingValidClip(spreadWep)
    end

    if (cmd:CommandNumber() == 0) then
        return
    end

    local cmdAttack1 = cmd:KeyDown(IN_ATTACK)

    if (not cmdAttack1) then
        NeedsPrimReset = false
        return
    elseif (NeedsPrimReset and not cmdAttack1) then
        NeedsPrimReset = false
    end

    local shouldPrimary = self:ShouldPrimaryAttack()

    if (not shouldPrimary) then
        return
    end

    local wep = lply:GetActiveWeapon()

    if (not IsValid(wep)) then
        return
    end

    if (self:IsIgnoreWep(wep)) then
        return
    end

    if (not self:CanShoot(cmd, wep, shouldPrimary)) then
        return
    end

    local primAuto = self:IsAutoWep(wep)

    if (NeedsPrimReset and shouldPrimary) then
        return
    end

    if (not primAuto and shouldPrimary) then
        NeedsPrimReset = true
    end

    if (shouldPrimary) then
        cmd:SetButtons(bitbor(cmd:GetButtons(), IN_LEYHITREG1))
    end

    trace.start = lply:GetShootPos()
    local viewang = cmd:GetViewAngles()
    local dir = viewang:Forward()

    local weaponSpread = self:GetWeaponSpread(lply, wep)

    if (weaponSpread) then
        local applied, newDir = self:ApplyBulletSpread(lply, dir, weaponSpread)
 
        if (applied) then
            dir = newDir
        end
    else
        -- LocalPlayer():ChatPrint("NO WEAPONSPREAD")
    end

    trace.endpos = trace.start + (dir * (56756 * 8))
    traceres.Entity = nil
    traceres.HitGroup = nil
    traceres.HitBox = nil

    util.TraceLine(trace)

    local target = traceres.Entity 

    if (not IsValid(target) or not (target:IsNPC() or target:IsPlayer())) then
        cmd:SetUpMove(-1)
        if (LeyHitreg.AnnounceClientHits) then
            LocalPlayer():ChatPrint("It's a miss!")
            -- PrintTable(trace)
        end
        return
    end

    local hitgroup = traceres.HitGroup
    local hitbox = traceres.HitBox
    local hitbone = target:GetHitBoxBone(hitbox, 0)

    if (not hitbone or not hitgroup) then
        print("[/LeyHitreg/] Bone not found")
        return
    end

    cmd:SetUpMove(target:EntIndex())
    cmd:SetMouseWheel(hitbone)

    if (LeyHitreg.AnnounceClientHits) then
        LocalPlayer():ChatPrint("It's a hit!")
    end
end

hook.Add("CreateMove", "LeyHitreg:CreateMove", function(...)
    LeyHitreg:CreateMove(...)
end)

function LeyHitreg:EntityFireBullets(plyorwep, bullet)
    if (LeyHitreg.Disabled or LeyHitreg.DisabledOnlyOnClient) then
        return
    end

    if (bullet.Num >= 2) then
        return
    end

    local ply, wep = self:GetPlayerFromPlyOrBullet(plyorwep, bullet)

    if (not ply) then
        return
    end

    if (not wep or self:IsIgnoreWep(wep)) then
        return
    end

    if (not LeyHitreg.ShotDirForceDisabled) then
        bullet.Dir = ply:GetAimVector()
    end

    local forcedShot = LeyHitreg:FetchSpreadFireBullets(ply, wep, bullet)

    if (forcedShot != nil) then
        return forcedShot
    end

    local ret = LeyHitreg:SpreadedEntityFireBullets(ply, wep, bullet)

    if (ret != nil) then
        return ret
    end
end

hook.Add("EntityFireBullets", "LeyHitreg:EntityFireBullets", function(plyorwep, bullet)
    local ret = LeyHitreg:EntityFireBullets(plyorwep, bullet)

    if (ret != nil) then
        return ret
    end
end)

--PATH addons/_hitreg/lua/leyhitreg/shared/spreadsystem/bulletspread.lua:
local Vector = Vector
local mathmodf = math.modf
local mathrandomseed = math.randomseed
local mathrandom = math.random
local mathsqrt = math.sqrt
local isnumber = isnumber
local vector_origin = vector_origin

local timefn = function()
    return 1 -- os.date("%S")
end

function LeyHitreg:ApplyBulletSpread(ply, dir, spread)
	if (LeyHitreg.NoSpread) then
		return true, dir, vector_origin
	end

	if (not spread or spread == vector_origin or LeyHitreg.BrokenSpread) then
		return false
	end

	if (isnumber(spread)) then
		spread = Vector(spread, spread, spread)
	end

	local add = (8969 * timefn())

	mathrandomseed(add + CurTime())

	local ang = dir:Angle()

	local appliedSpread, rgt, up = Vector(), ang:Right(), ang:Up()

	local x, y, z

	repeat
		x = mathrandom() + mathrandom() - 1
		y = mathrandom() + mathrandom() - 1

		z = x * x + y * y
	until z <= 1

	for i = 1, 3 do
		appliedSpread[i] = x * spread.x * rgt[i] + y * spread.y * up[i]
	end

	dir = dir + appliedSpread

	return true, dir, appliedSpread
end

--PATH addons/lvs_base-main/lua/lvs_framework/init.lua:

local StartTime = SysTime()

if SERVER then
	AddCSLuaFile("includes/circles/circles.lua")
end

local function FileIsEmpty( filename )
	if file.Size( filename, "LUA" ) <= 1 then -- this is suspicous
		local data = file.Read( filename, "LUA" )

		if data and string.len( data ) <= 1 then -- confirm its empty

			print("[LVS] - refusing to load '"..filename.."'! File is Empty!" )

			return true
		end
	end

	return false
end

for _, filename in pairs( file.Find("lvs_framework/autorun/*.lua", "LUA") ) do
	if FileIsEmpty( "lvs_framework/autorun/"..filename ) then continue end

	if string.StartWith( filename, "sv_") then -- sv_ prefix only load serverside
		if SERVER then
			include("lvs_framework/autorun/"..filename)
		end

		continue
	end

	if string.StartWith( filename, "cl_") then -- cl_ prefix only load clientside
		if SERVER then
			AddCSLuaFile("lvs_framework/autorun/"..filename)
		else
			include("lvs_framework/autorun/"..filename)
		end

		continue
	end

	-- everything else is shared
	if SERVER then
		AddCSLuaFile("lvs_framework/autorun/"..filename)
	end
	include("lvs_framework/autorun/"..filename)
end

hook.Run( "LVS:Initialize" )

print("[LVS] - initialized ["..math.Round((SysTime() - StartTime) * 1000,2).."ms]")

if CLIENT then
	hook.Add( "InitPostEntity", "!!!lvscheckupdates", function()
		timer.Simple(20, function()
			LVS.CheckUpdates()

			local convar = GetConVar( "no_error_hitboxes" )

			if not convar then return end

			convar:SetBool( false )
		end)
	end )

	return
end

resource.AddWorkshop("2912816023")

local ValveWierdBlastDamageClass = {
	["npc_strider"] = true, -- takes 70 damage for each blast damage as constant value ...
	["npc_combinegunship"] = true, -- takes 44 damage as constant value ...
	["func_breakable_surf"] = true, -- this entity dont care about anything that isnt a trace attack or blast damage
}

function LVS:BlastDamage( pos, forward, attacker, inflictor, damage, damagetype, radius, force )

	local dmginfo = DamageInfo()
	dmginfo:SetAttacker( attacker )
	dmginfo:SetInflictor( inflictor )
	dmginfo:SetDamage( damage )
	dmginfo:SetDamageType( damagetype == DMG_BLAST and DMG_SONIC or damagetype )

	if damagetype ~= DMG_BLAST then
		dmginfo:SetDamagePosition( pos )
		dmginfo:SetDamageForce( forward * force )

		util.BlastDamageInfo( dmginfo, pos, radius )

		return
	end

	util.BlastDamageInfo( dmginfo, pos, radius )

	local FragmentAngle = 10
	local NumFragments = 16
	local NumFragmentsMissed = 0

	local RegisteredHits = {}

	local trace = util.TraceLine( {
		start = pos,
		endpos = pos - forward * radius,
		filter = { attacker, inflictor },
	} )

	local startpos = trace.HitPos

	for i = 1, NumFragments do
		local ang = forward:Angle() + Angle( math.random(-FragmentAngle,FragmentAngle), math.random(-FragmentAngle,FragmentAngle), 0 )
		local dir = ang:Forward()

		local endpos = pos + dir * radius

		local trace = util.TraceLine( {
			start = startpos,
			endpos = endpos,
			filter = { attacker, inflictor },
		} )

		debugoverlay.Line( startpos, trace.HitPos, 10, Color( 255, 0, 0, 255 ), true )

		if not trace.Hit then
			NumFragmentsMissed = NumFragmentsMissed + 1

			continue
		end

		if not IsValid( trace.Entity ) then continue end

		if not RegisteredHits[ trace.Entity ] then
			RegisteredHits[ trace.Entity ] = {}
		end

		table.insert( RegisteredHits[ trace.Entity ], {
			origin = trace.HitPos,
			force = forward * force,
		} )
	end

	local Hull = Vector(10,10,10)

	for _, ent in ipairs( ents.FindInSphere( pos, radius ) ) do
		if not ent.LVS or ent == inflictor or ent == attacker then continue end

		local trace = util.TraceHull( {
			start = pos,
			endpos = ent:LocalToWorld( ent:OBBCenter() ),
			mins = -Hull,
			maxs = Hull,
			whitelist = true,
			ignoreworld = true,
			filter = ent,
		} )

		debugoverlay.Line( pos, trace.HitPos, 10, Color( 255, 0, 0, 255 ), true )

		NumFragments = NumFragments + 1

		if not RegisteredHits[ ent ] then
			RegisteredHits[ ent ] = {}
		end

		table.insert( RegisteredHits[ ent ], {
			origin = trace.HitPos,
			force = forward * force,
		} )
	end

	if NumFragmentsMissed == NumFragments then return end

	local DamageBoost = NumFragments / ( NumFragments - NumFragmentsMissed )

	for ent, data in pairs( RegisteredHits ) do
		local NumHits = #data
		local AverageOrigin = vector_origin
		local AverageForce = vector_origin

		for _, HitData in pairs( data ) do
			AverageOrigin = AverageOrigin + HitData.origin
			AverageForce = AverageForce + HitData.force
		end

		AverageOrigin = AverageOrigin / NumHits
		AverageForce = AverageForce / NumHits

		local TotalDamage = ( ( NumHits * DamageBoost ) / NumFragments ) * damage

		--debugoverlay.Cross( AverageOrigin, 50, 10, Color( 255, 0, 255 ) )

		-- hack
		if ValveWierdBlastDamageClass[ ent:GetClass() ] then

			util.BlastDamage( inflictor, attacker, pos, radius, damage )

			continue
		end

		local dmginfo = DamageInfo()
		dmginfo:SetAttacker( attacker )
		dmginfo:SetInflictor( inflictor )
		dmginfo:SetDamage( TotalDamage )
		dmginfo:SetDamageForce( AverageForce )
		dmginfo:SetDamagePosition( AverageOrigin )
		dmginfo:SetDamageType( DMG_BLAST )

		ent:TakeDamageInfo( dmginfo )
	end
end

function LVS:FixVelocity()
	local tbl = physenv.GetPerformanceSettings()

	if tbl.MaxVelocity < 4000 then
		local OldVel = tbl.MaxVelocity

		tbl.MaxVelocity = 4000
		physenv.SetPerformanceSettings(tbl)

		print("[LVS] Low MaxVelocity detected! Increasing! "..OldVel.." => 4000")
	end

	if tbl.MaxAngularVelocity < 7272 then
		local OldAngVel = tbl.MaxAngularVelocity

		tbl.MaxAngularVelocity = 7272
		physenv.SetPerformanceSettings(tbl)

		print("[LVS] Low MaxAngularVelocity detected! Increasing! "..OldAngVel.." => 7272")
	end
end

hook.Add( "InitPostEntity", "!!!lvscheckupdates", function()
	timer.Simple(20, function()
		LVS.CheckUpdates()
	end)
end )
--PATH addons/__main/lua/autorun/m9k_small_arms_11_07_15.lua:
/*------------------------------------------------------

If you're reading this, then that mean's you've extracted this addon, probably with intentions 
of editing it for your own needs, or that you're using a legacy addon.

I have no problem with that, but you must understand that I cannot offer support for legacy addons.
If you've extracted this addon, I cannot offer any help fixing problems that come up. It's impossible
to know what you've changed, and thus impossible to know what to fix.

"But Bob!" you might say. "I only changed one thing!" 

Well, that's a shame. Everybody is going to say this, and I know that some of those people will be
lying to me. The only thing I can do is to refuse support to everyone using legacy addons.

So, by using a legacy addon, you accept the fact that I cannot help fix anything that might be broken.

I know it's tough love, but that's the way it's got to be.

------------------------------------------------------*/

--I'm pretty sure we don't need these anymore...
--Almost 99 percent sure that's I'm 100 percent sure...
	
-- if GetConVar("M9KDisableHolster") == nil then
	-- CreateConVar("M9KDisableHolster", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Disable my totally worthless and broken holster system? Won't hurt my feelings any. 1 for true, 2 for false. A map change may be required.")
	-- print("Holster Disable con var created")
-- end

if GetConVar("DebugM9K") == nil then
	CreateConVar("DebugM9K", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE }, "Debugging for some m9k stuff, turning it on won't change much.")
end

if GetConVar("M9KWeaponStrip") == nil then
	CreateConVar("M9KWeaponStrip", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Allow empty weapon stripping? 1 for true, 0 for false")
	print("Weapon Strip con var created")
end
	
if GetConVar("M9KDisablePenetration") == nil then
	CreateConVar("M9KDisablePenetration", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Disable Penetration and Ricochets? 1 for true, 0 for false")
	print("Penetration/ricochet con var created")
end
	
if GetConVar("M9KDynamicRecoil") == nil then
	CreateConVar("M9KDynamicRecoil", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Use Aim-modifying recoil? 1 for true, 0 for false")
	print("Recoil con var created")
end
	
if GetConVar("M9KAmmoDetonation") == nil then
	CreateConVar("M9KAmmoDetonation", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Enable detonatable M9K Ammo crates? 1 for true, 0 for false.")
	print("Ammo crate detonation con var created")
end

if GetConVar("M9KDamageMultiplier") == nil then
	CreateConVar("M9KDamageMultiplier", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Multiplier for M9K bullet damage.")
	print("Damage Multiplier con var created")
end

if GetConVar("M9KDefaultClip") == nil then
	CreateConVar("M9KDefaultClip", "-1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "How many clips will a weapon spawn with? Negative reverts to default values.")
	print("Default Clip con var created")
end
	
if GetConVar("M9KUniqueSlots") == nil then
	CreateConVar("M9KUniqueSlots", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Give M9K Weapons unique slots? 1 for true, 2 for false. A map change may be required.")
	print("Unique Slots con var created")
end
	
if !game.SinglePlayer() then

	if GetConVar("M9KClientGasDisable") == nil then
		CreateConVar("M9KClientGasDisable", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Turn off gas effect for all clients? 1 for yes, 0 for no. ")
	end
	
	if SERVER then
	
		function ClientSideGasDisabler()
			timer.Create("ClientGasBroadcastTimer", 15, 0, 
				function() BroadcastLua("RunConsoleCommand(\"M9KGasEffect\", \"0\")") end )
		end
	
		if GetConVar("M9KClientGasDisable"):GetBool() then
			ClientSideGasDisabler()
		end

		function M9K_Svr_Gas_Change_Callback(cvar, previous, new)
			if tobool(new) == true then
				ClientSideGasDisabler()
				BroadcastLua("print(\"Gas effects disabled on this server!\")")
			elseif tobool(new) == false then
				BroadcastLua("print(\"Gas effects re-enabled on this server.\")")
				BroadcastLua("print(\"You may turn on M9KGasEffect if you wish.\")")
				if timer.Exists("ClientGasBroadcastTimer") then
					timer.Destroy("ClientGasBroadcastTimer")
				end
			end				
		end
		cvars.AddChangeCallback("M9KClientGasDisable", M9K_Svr_Gas_Change_Callback)
	
	end
	
	if CLIENT then
		if GetConVar("M9KGasEffect") == nil then
			CreateClientConVar("M9KGasEffect", "1", true, true)
			print("Client-side Gas Effect Con Var created")
		end		
	end

else
	if GetConVar("M9KGasEffect") == nil then
		CreateConVar("M9KGasEffect", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Use gas effect when shooting? 1 for true, 0 for false")
		print("Gas effect con var created")
	end
end

//MP40
sound.Add({
	name = 			"mp40.single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/mp40/mp5-1.wav"
})

sound.Add({
	name = 			"Weapon_mp40m9k.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/mp40/magout.mp3"
})

sound.Add({
	name = 			"Weapon_mp40m9k.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/mp40/magin.mp3"
})

sound.Add({
	name = 			"Weapon_mp40m9k.Slideback",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/mp40/boltback.mp3"
})

//Magpul PDR
sound.Add({
	name = 			"MAG_PDR.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			{"weapons/pdr/pdr-1.wav",
						"weapons/pdr/pdr-2.wav",
						"weapons/pdr/pdr-3.wav"}
})

sound.Add({
	name = 			"Weapon_PDR.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/pdr/pdr_clipin.mp3"
})

sound.Add({
	name = 			"Weapon_PDR.Clipin2",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/pdr/pdr_clipin2.mp3"
})

sound.Add({
	name = 			"Weapon_PDR.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/pdr/pdr_boltpull.mp3"
})

sound.Add({
	name = 			"Weapon_PDR.Boltrelease",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/pdr/pdr_boltrelease.mp3"
})

sound.Add({
	name = 			"Weapon_PDR.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/pdr/pdr_clipout.mp3"
})

//KAC PDW
sound.Add({
	name = 			"KAC_PDW.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/kac_pdw/m4a1_unsil-1.wav"
})

sound.Add({
	name = 			"KAC_PDW.SilentSingle",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/kac_pdw/m4a1-1.wav"
})

sound.Add({
	name = 			"kac_pdw_001.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/kac_pdw/m4a1_clipout.mp3"
})

sound.Add({
	name = 			"kac_pdw_001.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/kac_pdw/m4a1_clipin.mp3"
})

sound.Add({
	name = 			"kac_pdw_001.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/kac_pdw/m4a1_boltpull.mp3"
})

sound.Add({
	name = 			"kac_pdw_001.Deploy",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/kac_pdw/m4a1_deploy.mp3"
})

sound.Add({
	name = 			"kac_pdw_001.Silencer_On",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/kac_pdw/m4a1_silencer_on.mp3"
})

sound.Add({
	name = 			"kac_pdw_001.Silencer_Off",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/kac_pdw/m4a1_silencer_off.mp3"
})

//MP5
sound.Add({
	name = 			"mp5_navy_Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/brightmp5/mp5-1.wav"
})

sound.Add({
	name = 			"mp5_foley",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/brightmp5/foley.mp3"
})

sound.Add({
	name = 			"mp5_magout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/brightmp5/magout.mp3"
})

sound.Add({
	name = 			"mp5_magin1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/brightmp5/magin1.mp3"
})

sound.Add({
	name = 			"mp5_magin2",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/brightmp5/magin2.mp3"
})

sound.Add({
	name = 			"mp5_boltback",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/brightmp5/boltback.mp3"
})

sound.Add({
	name = 			"mp5_boltslap",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/brightmp5/boltslap.mp3"
})

sound.Add({
	name = 			"mp5_cloth",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/brightmp5/cloth.mp3"
})

sound.Add({
	name = 			"mp5_safety",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/brightmp5/safety.mp3"
})

//tec9
sound.Add({
	name = 			"Weapon_Tec9.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/tec9/ump45-1.wav"
})

sound.Add({
	name = 			"Weapon_Tec9.Magin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/tec9/tec9_magin.mp3"
})

sound.Add({
	name = 			"Weapon_Tec9.Magout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/tec9/tec9_magout.mp3"
})

sound.Add({
	name = 			"Weapon_Tec9.NewMag",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/tec9/tec9_newmag.mp3"
})

sound.Add({
	name = 			"Weapon_Tec9.Charge",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/tec9/tec9_charge.mp3"
})

//Kriss
sound.Add({
	name = 			"kriss_vector.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/Kriss/ump45-1.wav"
})

sound.Add({
	name = 			"kriss_vector.Magrelease",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/Kriss/magrel.mp3"
})

sound.Add({
	name = 			"kriss_vector.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/Kriss/clipout.mp3"
})

sound.Add({
	name = 			"kriss_vector.Dropclip",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/Kriss/dropclip.mp3"
})

sound.Add({
	name = 			"kriss_vector.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/Kriss/clipin.mp3"
})


sound.Add({
	name = 			"kriss_vector.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/Kriss/boltpull.mp3"
})

sound.Add({
	name = 			"kriss_vector.unfold",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/Kriss/unfold.mp3"
})

//MP9
sound.Add({
	name = 			"Weapon_mp9.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/mp9/tmp-1.wav"
})

sound.Add({
	name = 			"Weapon_mp9.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/mp9/tmp_clipin.mp3"
})

sound.Add({
	name = 			"Weapon_mp9.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/mp9/tmp_clipout.mp3"
})

//ump45 
sound.Add({
	name = 			"m9k_hk_ump45.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/hk_ump45/ump45-1.wav"
})

sound.Add({
	name = 			"m9k_hk_ump45.Clipout1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hk_ump45/ump45_clipout1.mp3"
})

sound.Add({
	name = 			"m9k_hk_ump45.Clipout2",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hk_ump45/ump45_clipout2.mp3"
})

sound.Add({
	name = 			"m9k_hk_ump45.Clipin1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hk_ump45/ump45_clipin1.mp3"
})

sound.Add({
	name = 			"m9k_hk_ump45.Clipin2",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hk_ump45/ump45_clipin2.mp3"
})

sound.Add({
	name = 			"m9k_hk_ump45.Boltslap",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hk_ump45/ump45_boltslap.mp3"
})

sound.Add({
	name = 			"m9k_hk_ump45.Cloth",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hk_ump45/ump45_cloth.mp3"
})


//p19 Bizon
sound.Add({
	name = 			"Weapon_P19.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/p19/p90-1.wav"
})

sound.Add({
	name = 			"Weapon_P19.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/p19/p90_clipout.mp3"
})

sound.Add({
	name = 			"Weapon_P19.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/p19/p90_clipin.mp3"
})

sound.Add({
	name = 			"Weapon_P19.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/p19/p90_boltpull.mp3"
})

//p90
sound.Add({
	name = 			"P90_weapon.single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/p90_smg/p90-1.wav"
})

sound.Add({
	name = 			"P90_weapon.unlock",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/p90_smg/p90_unlock.mp3"
})

sound.Add({
	name = 			"P90_weapon.magout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/p90_smg/p90_magout.mp3"
})

sound.Add({
	name = 			"P90_weapon.magin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/p90_smg/p90_magin.mp3"
})

sound.Add({
	name = 			"P90_weapon.cock",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/p90_smg/p90_cock.mp3"
})

//sten
sound.Add({
	name = 			"Weaponsten.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/sten/mp5-1.wav"
	
})

sound.Add({
	name = 			"Weaponsten.clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/sten/mp5_clipout.mp3"
	
})

sound.Add({
	name = 			"Weaponsten.clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/sten/mp5_clipin.mp3"
	
})

sound.Add({
	name = 			"Weaponsten.boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/sten/mp5_boltpull.mp3"	
})

sound.Add({
	name = 			"Weaponsten.boltslap",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/sten/mp5_boltslap.mp3"
	
})

sound.Add({
	name = 			"Weapon_stengun.Slideback",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/sten/mp5_slideback.mp3"
	
})

//tommy gun
sound.Add({
	name = 			"Weapon_tmg.single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/tmg/tmg_1.wav"
})

sound.Add({
	name = 			"Weapon_tmg.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/tmg/tmg_magout.mp3"
})

sound.Add({
	name = 			"Weapon_tmg.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/tmg/tmg_magin.mp3"
})

sound.Add({
	name = 			"Weapon_tmg.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/tmg/tmg_cock.mp3"
})

//MP7
sound.Add({
	name =			"Weapon_MP7.single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound =				"weapons/mp7/usp1.wav"
})

sound.Add({
	name =			"Weapon_MP7.magout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/mp7/mp7_magout.mp3"
})

sound.Add({
	name =			"Weapon_MP7.magin" ,
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/mp7/mp7_magin.mp3"
})

sound.Add({
	name =			"Weapon_MP7.charger" ,
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/mp7/mp7_charger.mp3"
})

//uzi
sound.Add({
	name = 			"Weapon_uzi.single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/uzi/mac10-1.wav"
})

sound.Add({
	name = 			"imi_uzi_09mm.boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/uzi/mac10_boltpull.mp3"
})

sound.Add({
	name = 			"imi_uzi_09mm.clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/uzi/mac10_clipin.mp3"
})

sound.Add({
	name = 			"imi_uzi_09mm.clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/uzi/mac10_clipout.mp3"
})

//MP5SD
sound.Add({
	name = 			"Weapon_hkmp5sd.single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/hkmp5sd/mp5-1.wav"
})

sound.Add({
	name = 			"Weapon_hkmp5sd.magout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hkmp5sd/magout.mp3"
})

sound.Add({
	name = 			"Weapon_hkmp5sd.magfiddle",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hkmp5sd/magfiddle.mp3"
})

sound.Add({
	name = 			"Weapon_hkmp5sd.magin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hkmp5sd/magin.mp3"
})

sound.Add({
	name = 			"Weapon_hkmp5sd.boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hkmp5sd/boltpull.mp3"
})

sound.Add({
	name = 			"Weapon_hkmp5sd.boltrelease",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hkmp5sd/boltrelease.mp3"
})

sound.Add({
	name = 			"Weapon_hkmp5sd.cloth",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hkmp5sd/cloth.mp3"
})

sound.Add({
	name = 			"Weapon_hkmp5sd.safety",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hkmp5sd/safety.mp3"
})

//Honey Badger
sound.Add({
	name = 			"Weapon_HoneyB.single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/hb/hb_fire.wav"
})

sound.Add({
	name = 			"Weapon_HoneyB.Magout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hb/magout.mp3"
})

sound.Add({
	name = 			"Weapon_HoneyB.Magin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hb/magin.mp3"
})

sound.Add({
	name = 			"Weapon_HoneyB.Boltcatch",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hb/boltcatch.mp3"
})

sound.Add({
	name = 			"Weapon_HoneyB.Boltforward",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hb/boltforward.mp3"
})

sound.Add({
	name = 			"Weapon_HoneyB.Boltback",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/hb/boltback.mp3"
})

//colt python
sound.Add({
	name = 			"Weapon_ColtPython.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/coltpython/python-1.wav"
})

sound.Add({
	name = 			"WepColtPython.clipdraw",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/coltpython/clipdraw.mp3"
})

sound.Add({
	name = 			"WepColtPython.blick",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/coltpython/blick.mp3"
})

sound.Add({
	name = 			"WepColtPython.bulletsout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/coltpython/bulletsout.mp3"
})

sound.Add({
	name = 			"WepColtPython.bulletsin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/coltpython/bulletsin.mp3"
})

//Raging Bull
sound.Add({
	name = 			"weapon_r_bull.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/r_bull/r-bull-1.wav"
})

sound.Add({
	name = 			"weapons_r_bull_bullreload_wav",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/r_bull/bullreload.mp3"
})

sound.Add({
	name = 			"weapons_r_bull_draw_gun_wav",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/r_bull/draw_gun.mp3"
})

//smith and wesson model 3
sound.Add({
	name = 			"Model3.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/model3/model3-1.wav" 
})

sound.Add({
	name = 			"Model3.Hammer",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/model3/Hammer.mp3" 
})

sound.Add({
	name = 			"Model3.Break_Eject",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/model3/Break_eject.mp3" 
})

sound.Add({
	name = 			"Model3.bulletout_1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/model3/bulletout_1.mp3"
})

sound.Add({
	name = 			"Model3.bulletout_2",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/model3/bulletout_2.mp3"
})

sound.Add({
	name = 			"Model3.bulletout_3",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/model3/bulletout_3.mp3"
})

sound.Add({
	name = 			"Model3.bullets_in",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/model3/bullets_in.mp3"
})

sound.Add({
	name = 			"Model3.Break_close",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/model3/Break_CLose.mp3"	
})

//m29 satan
sound.Add({
	name = 			"Weapon_satan1.single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/satan1/satan-1.wav"
})

sound.Add({
	name = 			"Weapon_satan1.blick",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/satan1/blick.mp3"
})

sound.Add({
	name = 			"Weapon_satan1.unfold",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/satan1/unfold.mp3"
})

sound.Add({
	name = 			"Weapon_satan1.bulletsin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/satan1/bulletsin.mp3"
})

sound.Add({
	name = 			"Weapon_satan1.bulletsout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/satan1/bulletsout.mp3"
})

//Remington 1858
sound.Add({
	name = 			"Remington.single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/remington/remington-1.wav" 
})

sound.Add({
	name = 			"Remington.cylinderhit",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/remington/cylinderhit.mp3" 
})

sound.Add({
	name = 			"Remington.cylinderswap",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/remington/cylinderswap.mp3" 
})

sound.Add({
	name = 			"Remington.bounce1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/remington/bounce1.mp3" 
})

sound.Add({
	name = 			"Remington.bounce1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/remington/bounce2.mp3" 
})

sound.Add({
	name = 			"Remington.bounce1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/remington/bounce3.mp3" 
})

sound.Add({
	name = 			"Remington.Hammer",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/remington/hammer.mp3" 
})

//BERETTAM92
sound.Add({
	name = 			"Weapon_m92b.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			")weapons/beretta92/berettam92-1.wav"
})

sound.Add({
	name = 			"Weapon_beretta92.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/beretta92/berettam92_clipout.mp3"
})

sound.Add({
	name = 			"Weapon_beretta92.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/beretta92/berettam92_clipin.mp3"
})

sound.Add({
	name = 			"Weapon_beretta92.Sliderelease",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/beretta92/berettam92_sliderelease.mp3"
})

sound.Add({
	name = 			"Weapon_beretta92.Slidepull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/beretta92/berettam92_slidepull.mp3"
})

sound.Add({
	name = 			"Weapon_beretta92.Slideback",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/beretta92/berettam92_slideback.mp3"
})

//hk45c
sound.Add({
	name = 			"Weapon_hk45.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/hk45/hk45-1.wav"
})

sound.Add({
	name = 			"HK45C.Deploy",
	channel =		CHAN_ITEM,
	volume =		1,	
	sound =			"weapons/hk45/draw.mp3"
})

sound.Add({
	name = 			"HK45C.Magout",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/hk45/magout.mp3"
})

sound.Add({
	name = 			"HK45C.Magin",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/hk45/magin.mp3"
})

sound.Add({
	name = 			"HK45C.Release",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/hk45/sliderelease.mp3"
})

sound.Add({
	name = 			"HK45C.Slidepull",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/hk45/slidepull.mp3"
})

//usp
sound.Add({
	name = 			"Weapon_fokkususp.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_usp/fiveseven-1.wav" 
})

sound.Add({
	name = 			"Weapon_fokkususp.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_usp/fiveseven_clipout.mp3" 
})

sound.Add({
	name = 			"Weapon_fokkususp.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_usp/fiveseven_clipin.mp3" 
})

sound.Add({
	name = 			"Weapon_fokkususp.Slideback",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_usp/fiveseven_slideback.mp3" 
})

sound.Add({
	name = 			"Weapon_fokkususp.Slidepull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_usp/fiveseven_slidepull.mp3" 
})

// Sig P228
sound.Add({
	name = 			"Sauer1_P228.Single",
	channel =		CHAN_USER_BASE+10,
	volume =		1,
	sound =			"weapons/sig_p228/p228-1.wav"
})

sound.Add({
	name = 			"Sauer1_P228.Magout",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/sig_p228/magout.mp3" 
})

sound.Add({
	name = 			"Sauer1_P228.Magin",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/sig_p228/magin.mp3" 
})

sound.Add({
	name = 			"Sauer1_P228.MagShove",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/sig_p228/magshove.mp3" 
})

sound.Add({
	name = 			"Sauer1_P228.Sliderelease",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/sig_p228/sliderelease.mp3"
})

sound.Add({
	name = 			"Sauer1_P228.Cloth",
	channel =		CHAN_ITEM,
	volume =		.5,
	sound =			"weapons/sig_p228/cloth.mp3"
})

sound.Add({
	name = 			"Sauer1_P228.Shift",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/sig_p228/shift.mp3"
})

//glock 18
sound.Add({
	name = 			"Dmgfok_glock.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/dmg_glock/mac10-1.wav" 
})

sound.Add({
	name = 			"Dmgfok_glock.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_glock/magout.mp3" 
})

sound.Add({
	name = 			"Dmgfok_glock.clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_glock/magin.mp3" 
})

sound.Add({
	name = 			"Dmgfok_glock.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_glock/boltpull.mp3" 
})

sound.Add({
	name = 			"Dmgfok_glock.Boltrelease",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_glock/boltrelease.mp3" 
})

sound.Add({
	name = 			"Dmgfok_glock.Deploy",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_glock/mac10_deploy.mp3" 
})

//colt 1911
sound.Add({
	name = 			"Dmgfok_co1911.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/dmg_colt1911/deagle-1.wav"
})

sound.Add({
	name = 			"Dmgfok_co1911.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_colt1911/draw.mp3"
})

sound.Add({
	name = 			"Dmgfok_co1911.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_colt1911/de_clipin.mp3"
})

sound.Add({
	name = 			"Dmgfok_co1911.Slideback",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_colt1911/de_slideback.mp3"
})

sound.Add({
	name = 			"Dmgfok_co1911.Draw",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/dmg_colt1911/draw.mp3"
})

//luger
sound.Add({
	name = 			"Weapon_luger.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/luger/luger-1.wav"
})

sound.Add({
	name = 			"Weapon_luger.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/luger/luger_clipout.mp3"
})

sound.Add({
	name = 			"Weapon_luger.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/luger/luger_clipin.mp3"
})

sound.Add({
	name = 			"Weapon_luger.Sliderelease",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/luger/luger_sliderelease.mp3"
})

//desert eagle
sound.Add({
	name = 			"Weapon_TDegle.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_deagle/deagle-1.wav" 
})

sound.Add({
	name = 			"Weapon_TDegle.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_deagle/de_clipout.mp3" 
})

sound.Add({
	name = 			"Weapon_TDegle.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_deagle/de_clipin.mp3" 
})

sound.Add({
	name = 			"Weapon_TDegle.Slideback",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_deagle/de_slideback.mp3" 
})

sound.Add({
	name = 			"Weapon_TDegle.Deploy",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/fokku_tc_deagle/de_deploy.mp3" 
})

// Sig P229R
sound.Add({
	name = 			"Sauer1_P228.Single",
	channel =		CHAN_USER_BASE+10,
	volume =		1,
	sound =			"weapons/sig_p228/p228-1.wav"
})

sound.Add({
	name = 			"Sauer1_P228.Magout",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/sig_p228/magout.mp3" 
})

sound.Add({
	name = 			"Sauer1_P228.Magin",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/sig_p228/magin.mp3" 
})

sound.Add({
	name = 			"Sauer1_P228.MagShove",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/sig_p228/magshove.mp3" 
})

sound.Add({
	name = 			"Sauer1_P228.Sliderelease",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/sig_p228/sliderelease.mp3"
})

sound.Add({
	name = 			"Sauer1_P228.Cloth",
	channel =		CHAN_ITEM,
	volume =		.5,
	sound =			"weapons/sig_p228/cloth.mp3"
})

sound.Add({
	name = 			"Sauer1_P228.Shift",
	channel =		CHAN_ITEM,
	volume =		1,
	sound =			"weapons/sig_p228/shift.mp3"
})

//Model 500
sound.Add({
	name = 			"Model_500.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound =			"weapons/model500/deagle-1.wav"		
})

sound.Add({
	name = 			"saw_model_500.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/model500/de_clipin.mp3"	
})

sound.Add({
	name = 			"saw_model_500.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/model500/de_clipout.mp3"	
})

sound.Add({
	name = 			"saw_model_500.Deploy",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/model500/de_deploy.mp3"	
})

sound.Add({
	name = 			"saw_model_500.Slideback",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/model500/de_slideback.mp3"	
})

//S&W 627
sound.Add({
	name = 			"model_627perf.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/627/deagle-1.wav"
})

sound.Add({
	name = 			"model_627perf.wheel_in",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/627/wheel_in.mp3"
})

sound.Add({
	name = 			"model_627perf.bullets_in",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/627/bullets_in.mp3"
})

sound.Add({
	name = 			"model_627perf.bulletout_3",
	channel = 		CHAN_USER_BASE+11,
	volume = 		1.0,
	sound = 			"weapons/627/bulletout_3.mp3"
})

sound.Add({
	name = 			"model_627perf.bulletout_2",
	channel = 		CHAN_USER_BASE+12,
	volume = 		1.0,
	sound = 			"weapons/627/bulletout_2.mp3"
})

sound.Add({
	name = 			"model_627perf.bulletout_1",
	channel = 		CHAN_USER_BASE+13,
	volume = 		1.0,
	sound = 			"weapons/627/bulletout_1.mp3"
})

sound.Add({
	name = 			"model_627perf.wheel_out",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/627/wheel_out.mp3"
})

//usc
sound.Add({
	name = 			"Weapon_hkusc.Single",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			{"weapons/usc/ump45-1.wav",
						"weapons/usc/ump45-2.wav"}
})

sound.Add({
	name = 			"Weapon_hkusc.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/usc/ump45_clipout.mp3"
})

sound.Add({
	name = 			"Weapon_hkusc.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/usc/ump45_clipin.mp3"
})

sound.Add({
	name = 			"Weapon_hkusc.Boltslap",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/usc/ump45_boltslap.mp3"
})

m9knpw = {}
table.insert(m9knpw, "m9k_davy_crockett_explo")
table.insert(m9knpw, "m9k_gdcwa_matador_90mm")
table.insert(m9knpw, "m9k_gdcwa_rpg_heat")
table.insert(m9knpw, "m9k_improvised_explosive")
table.insert(m9knpw, "m9k_launched_davycrockett")
table.insert(m9knpw, "m9k_launched_ex41")
table.insert(m9knpw, "m9k_launched_m79")
table.insert(m9knpw, "m9k_m202_rocket")
table.insert(m9knpw, "m9k_mad_c4")
table.insert(m9knpw, "m9k_milkor_nade")
table.insert(m9knpw, "m9k_nervegasnade")
table.insert(m9knpw, "m9k_nitro_vapor")
table.insert(m9knpw, "m9k_oribital_cannon")
table.insert(m9knpw, "m9k_poison_parent")
table.insert(m9knpw, "m9k_proxy")
table.insert(m9knpw, "m9k_released_poison")
table.insert(m9knpw, "m9k_sent_nuke_radiation")
table.insert(m9knpw, "m9k_thrown_harpoon")
table.insert(m9knpw, "m9k_thrown_knife")
table.insert(m9knpw, "m9k_thrown_m61")
table.insert(m9knpw, "m9k_thrown_nitrox")
table.insert(m9knpw, "m9k_thrown_spec_knife")
table.insert(m9knpw, "m9k_thrown_sticky_grenade")
table.insert(m9knpw, "bb_dod_bazooka_rocket")
table.insert(m9knpw, "bb_dod_panzershreck_rocket")
table.insert(m9knpw, "bb_garand_riflenade")
table.insert(m9knpw, "bb_k98_riflenade")
table.insert(m9knpw, "bb_planted_dod_tnt")
table.insert(m9knpw, "bb_thrownalliedfrag")
table.insert(m9knpw, "bb_thrownaxisfrag")
table.insert(m9knpw, "bb_thrownsmoke_axis")
table.insert(m9knpw, "bb_thrownaxisfrag")
table.insert(m9knpw, "bb_planted_alt_c4")
table.insert(m9knpw, "bb_planted_css_c4")
table.insert(m9knpw, "bb_throwncssfrag")
table.insert(m9knpw, "bb_throwncsssmoke")
table.insert(m9knpw, "m9k_ammo_40mm")
table.insert(m9knpw, "m9k_ammo_40mm_single")
table.insert(m9knpw, "m9k_ammo_357")
table.insert(m9knpw, "m9k_ammo_ar2")
table.insert(m9knpw, "m9k_ammo_buckshot")
table.insert(m9knpw, "m9k_ammo_c4")
table.insert(m9knpw, "m9k_ammo_frags")
table.insert(m9knpw, "m9k_ammo_ieds")
table.insert(m9knpw, "m9k_ammo_nervegas")
table.insert(m9knpw, "m9k_ammo_nuke")
table.insert(m9knpw, "m9k_ammo_pistol")
table.insert(m9knpw, "m9k_ammo_proxmines")
table.insert(m9knpw, "m9k_ammo_rockets")
table.insert(m9knpw, "m9k_ammo_smg")
table.insert(m9knpw, "m9k_ammo_sniper_rounds")
table.insert(m9knpw, "m9k_ammo_stickynades")
table.insert(m9knpw, "m9k_ammo_winchester")

function PocketM9KWeapons(ply, wep)

	if not IsValid(wep) then return end
	class = wep:GetClass()
	m9knopocket = false
	
	for k, v in pairs(m9knpw) do
		if v == class then
			m9knopocket = true
			break
		end
	end
	
	if m9knopocket then
		return false
	end
	
	--goddammit i hate darkrp
	
end
hook.Add("canPocket", "PocketM9KWeapons", PocketM9KWeapons )

small_autorun_mounted = true
--PATH addons/media_player/lua/autorun/includes/modules/htmlmaterial.lua:
local ipairs = ipairs
local table = table
local timer = timer
local ceil = math.ceil
local log = math.log
local pow = math.pow

local tblconcat = table.concat

local cache = {}
local downloads = {}
local styles = {}

local embedHtml = [[
<!doctype html>
<html>
<head>
	<meta charset="utf-8">
</head>
<body>
	<script>
	var src = '%s';
	</script>
	<img id="mat">

	<style>
	html, body {
		width: 100%%;
		height: 100%%;
		margin: 0;
		padding: 0;
		overflow: hidden;
	}
	%s
	</style>

	<script>
	var mat = document.getElementById('mat');
	mat.onload = function() {
		setTimeout(function() {
			gmod.imageLoaded();
		}, 100);
	};
	mat.onerror = function() {
		gmod.imageLoaded();
	};
	mat.src = src;
	</script>
</body>
</html>]]

local UpdateTimerName = "HtmlMatUpdate"
local TimerRunning = false

local function updateCache(download)
	download.browser:UpdateHTMLTexture()
	cache[download.key] = download.browser:GetHTMLMaterial()
end

local function updateMaterials()
	for _, download in ipairs(downloads) do
		updateCache(download)
	end
end

local function onImageLoaded(key, browser)
	local idx

	for k, v in pairs(downloads) do
		if v.key == key then
			idx = k
			break
		end
	end

	if idx > 0 then
		-- html materials are unique to each browser; re-using a browser will
		-- result in previous materials being updated. Therefore, used browsers
		-- must be destroyed rather than pooled.
		local download = downloads[idx]
		browserpool.release(browser, true)
		table.remove(downloads, idx)
	end

	if #downloads == 0 and TimerRunning then
		timer.Destroy(UpdateTimerName)
		TimerRunning = false
	end
end

local DefaultMat = Material("vgui/white")
local DefaultWidth = 128
local DefaultStyle = {}

local function enqueueUrl( url, styleName, key, callback )
	cache[key] = DefaultMat

	browserpool.get(function(browser)
		local style = styles[styleName] or DefaultStyle
		local w = style.width or DefaultWidth
		local h = style.height or w

		browser:SetSize( w, h )

		local download = {
			url = url,
			key = key,
			browser = browser
		}

		table.insert(downloads, download)

		browser:AddFunction("gmod", "imageLoaded", function()
			updateCache(download)
			onImageLoaded(key, browser)

			if type(callback) == "function" then
				callback( cache[key] )
			end
		end)

		if not TimerRunning then
			timer.Create(UpdateTimerName, 0.05, 0, updateMaterials)
			timer.Start(UpdateTimerName)
			TimerRunning = true
		end

		local html = (style.html or embedHtml):format(url, style.css or '')
		browser:SetHTML( html )
	end)
end

-- cached for performance
local MAT_STR_TABLE = { '', '@', '' }

---
-- Renders a URL as a material.
--
-- @param url		URL.
-- @param style		HTMLMaterial style.
--
function HTMLMaterial( url, style, callback )
	if not url then
		return DefaultMat
	end

	local key

	-- Build unique key for material
	if style then
		MAT_STR_TABLE[1] = url
		MAT_STR_TABLE[3] = style
		key = tblconcat( MAT_STR_TABLE )
	else
		key = url
	end

	-- Enqueue the URL to be downloaded if it hasn't been loaded yet.
	if cache[key] == nil then
		enqueueUrl( url, style, key, callback )
	elseif callback then
		callback( cache[key] )
	end

	-- Return cached URL
	return cache[key]
end

local SetDrawColor = surface.SetDrawColor
local SetMaterial = surface.SetMaterial
local DrawTexturedRect = surface.DrawTexturedRect

function CeilPower2(n)
	return pow(2, ceil(log(n) / log(2)))
end

function DrawHTMLMaterial( url, styleName, w, h )
	local mat = HTMLMaterial( url, styleName )
	local style = styles[styleName] or DefaultStyle

	-- Desired dimensions
	local width = style.width or DefaultWidth
	local height = style.height or w

	-- Convert to scalar
	w = w / width
	h = h / height

	-- Fix for non-power-of-two html panel size
	width = CeilPower2(width)
	height = CeilPower2(height)

	SetDrawColor( color_white )
	SetMaterial( mat )
	DrawTexturedRect( 0, 0, w * width, h * height )
end

---
-- Registers a style that can be used with `HTMLMaterial`
--
-- @param name		Style name.
-- @param params	Table of style parameters.
--
function AddHTMLMaterialStyle( name, params, base )
	params = params or {}

	if base then
		table.Merge( params, table.Copy( styles[base] or {} ) )
	end

	styles[name] = params
end

HTMLMAT_STYLE_BLUR       = 'htmlmat.style.blur'
HTMLMAT_STYLE_GRAYSCALE  = 'htmlmat.style.grayscale'
HTMLMAT_STYLE_SEPIA      = 'htmlmat.style.sepia'
HTMLMAT_STYLE_INVERT     = 'htmlmat.style.invert'
HTMLMAT_STYLE_CIRCLE     = 'htmlmat.style.circle'
HTMLMAT_STYLE_COVER      = 'htmlmat.style.cover'
HTMLMAT_STYLE_COVER_IMG  = 'htmlmat.style.coverimg'

AddHTMLMaterialStyle( HTMLMAT_STYLE_BLUR, {
	css = [[img {
	-webkit-filter: blur(8px);
	-webkit-transform: scale(1.1, 1.1);
}]]
})
AddHTMLMaterialStyle( HTMLMAT_STYLE_GRAYSCALE, {
	css = [[img { -webkit-filter: grayscale(1); }]]
})
AddHTMLMaterialStyle( HTMLMAT_STYLE_SEPIA, {
	css = [[img { -webkit-filter: sepia(1); }]]
})
AddHTMLMaterialStyle( HTMLMAT_STYLE_INVERT, {
	css = [[img { -webkit-filter: invert(1); }]]
})
AddHTMLMaterialStyle( HTMLMAT_STYLE_CIRCLE, {
	css = [[img { border-radius: 50%; }]]
})
AddHTMLMaterialStyle( HTMLMAT_STYLE_COVER, {
	html = [[
<script>
var src = '%s';
</script>

<style type="text/css">
html, body {
	width: 100%%;
	height: 100%%;
	margin: 0;
	padding: 0;
	overflow: hidden;
}

#mat {
	background: no-repeat 50%% 50%%;
	background-size: cover;
	width: 100%%;
	height: 100%%;
}

%s
</style>

<div id="mat"></div>

<script type="application/javascript">
var mat = document.getElementById('mat');
mat.style.backgroundImage = 'url('+src+')';

var img = new Image();
img.onload = function() {
	setTimeout(function() {
		gmod.imageLoaded();
	}, 100);
};
img.onerror = gmod.imageLoaded.bind(gmod);
img.src = src;
</script>
]]
})

-- Use this if you want to use -webkit-filter blur on the image;
-- you'll also need to use a transform to scale it a bit. This prevents
-- the edges from blurring as seen with background-size cover.
AddHTMLMaterialStyle( HTMLMAT_STYLE_COVER_IMG, {
	html = [[
<script>
var src = '%s';
</script>

<style type="text/css">
html, body {
	width: 100%%;
	height: 100%%;
	margin: 0;
	padding: 0;
	overflow: hidden;
}
img {
	width: auto;
	height: auto;
	position: absolute;
	top: 50%%;
	left: 50%%;
	-webkit-transform: translate(-50%%, -50%%);
}
%s
</style>

<img id="mat">

<script type="application/javascript">
var mat = document.getElementById('mat');
mat.onload = function() {
	if (mat.width > mat.height) {
		mat.style.height = '100%%';
	} else {
		mat.style.width = '100%%';
	}
	setTimeout(function() {
		gmod.imageLoaded();
	}, 100);
};
mat.onerror = function() {
	gmod.imageLoaded();
};
mat.src = src;
</script>
]]
})

--PATH addons/media_player/lua/mediaplayer/sh_cvars.lua:
MediaPlayer.Cvars = {}

MediaPlayer.Cvars.Debug = CreateConVar( "mediaplayer_debug", 0, FCVAR_DONTRECORD, "Enables media player debug mode; logs a bunch of actions into the console." )
MediaPlayer.DEBUG = MediaPlayer.Cvars.Debug:GetBool()
cvars.AddChangeCallback( "mediaplayer_debug", function(name, old, new)
	MediaPlayer.DEBUG = new == 1
end)

MediaPlayer.Cvars.AllowWebpages = CreateConVar( "mediaplayer_allow_webpages", 0, {
	FCVAR_ARCHIVE,
	FCVAR_NOTIFY,
	FCVAR_REPLICATED,
	FCVAR_SERVER_CAN_EXECUTE
}, "Allows any webpage to be requested." )

MediaPlayer.Cvars.QueueLimit = CreateConVar( "mediaplayer_queue_limit", 64, {
	FCVAR_REPLICATED,
	FCVAR_SERVER_CAN_EXECUTE
}, "Maximum size of a media player queue." )

if CLIENT then

	MediaPlayer.Cvars.Resolution	= CreateClientConVar( "mediaplayer_resolution", 480, true, false )
	MediaPlayer.Cvars.Audio3D		= CreateClientConVar( "mediaplayer_3daudio", 1, true, false )
	MediaPlayer.Cvars.Volume		= CreateClientConVar( "mediaplayer_volume", 0.15, true, false )
	MediaPlayer.Cvars.MuteUnfocused	= CreateClientConVar( "mediaplayer_mute_unfocused", 1, true, false )
	MediaPlayer.Cvars.Fullscreen	= CreateClientConVar( "mediaplayer_fullscreen", 0, false, false )
	MediaPlayer.Cvars.DrawThumbnails = CreateClientConVar( "mediaplayer_draw_thumbnails", 0, true, false )

end

--PATH addons/media_player/lua/mediaplayer/players/base/cl_draw.lua:
local pcall = pcall
local Color = Color
local RealTime = RealTime
local ValidPanel = ValidPanel
local Vector = Vector
local cam = cam
local draw = draw
local math = math
local string = string
local surface = surface

local DrawHTMLPanel = MediaPlayerUtils.DrawHTMLPanel
local FormatSeconds = MediaPlayerUtils.FormatSeconds

local TEXT_ALIGN_CENTER	= draw.TEXT_ALIGN_CENTER
local TEXT_ALIGN_TOP	= draw.TEXT_ALIGN_TOP
local TEXT_ALIGN_BOTTOM	= draw.TEXT_ALIGN_BOTTOM
local TEXT_ALIGN_LEFT	= draw.TEXT_ALIGN_LEFT
local TEXT_ALIGN_RIGHT	= draw.TEXT_ALIGN_RIGHT

local TextPaddingX = 12
local TextPaddingY = 12

local TextBoxPaddingX = 8
local TextBoxPaddingY = 2

local TextBgColor = Color(0, 0, 0, 200)
local BarBgColor = Color(0, 0, 0, 200)
local BarFgColor = Color(255, 255, 255, 255)

local function DrawText( text, font, x, y, xalign, yalign )
	return draw.SimpleText( text, font, x, y, color_white, xalign, yalign )
end

local function DrawTextBox( text, font, x, y, xalign, yalign )

	xalign = xalign or TEXT_ALIGN_LEFT
	yalign = yalign or TEXT_ALIGN_TOP

	surface.SetFont( font )
	tw, th = surface.GetTextSize( text )

	if xalign == TEXT_ALIGN_CENTER then
		x = x - tw*0.5
	elseif xalign == TEXT_ALIGN_RIGHT then
		x = x - tw
	end

	if yalign == TEXT_ALIGN_CENTER then
		y = y - th*0.5
	elseif yalign == TEXT_ALIGN_BOTTOM then
		y = y - th
	end

	surface.SetDrawColor( TextBgColor )
	surface.DrawRect( x, y,
		tw + TextBoxPaddingX * 2,
		th + TextBoxPaddingY * 2 )

end

local UTF8SubLastCharPattern = "[^\128-\191][\128-\191]*$"
local OverflowString = "..." -- ellipsis

---
-- Limits a rendered string's width based on a maximum width.
--
-- @param text		Text string.
-- @param font		Font.
-- @param w			Maximum width.
-- @return String	String fitting the maximum required width.
--
local function RestrictStringWidth( text, font, w )

	-- TODO: Cache this

	surface.SetFont( font )
	local curwidth = surface.GetTextSize( text )
	local overflow = false

	-- Reduce text by one character until it fits
	while curwidth > w do

		-- Text has overflowed, append overflow string on return
		if not overflow then
			overflow = true
		end

		-- Cut off last character
		text = string.gsub(text, UTF8SubLastCharPattern, "")

		-- Check size again
		curwidth = surface.GetTextSize( text .. OverflowString )

	end

	return overflow and (text .. OverflowString) or text

end

function MEDIAPLAYER:DrawHTML( browser, w, h )
	surface.SetDrawColor( 0, 0, 0, 255 )
	surface.DrawRect( 0, 0, w, h )
	DrawHTMLPanel( browser, w, h )
end

function MEDIAPLAYER:DrawMediaInfo( media, w, h )

	-- TODO: Fadeout media info instead of just hiding
	if not vgui.CursorVisible() and RealTime() - self._LastMediaUpdate > 3 then
		return
	end

	-- Text dimensions
	local tw, th

	-- Title background
	local titleStr = RestrictStringWidth( media:Title(), "MediaTitle",
		w - (TextPaddingX * 2 + TextBoxPaddingX * 2) )

	DrawTextBox( titleStr, "MediaTitle", TextPaddingX, TextPaddingY )

	-- Title
	DrawText( titleStr, "MediaTitle",
		TextPaddingX + TextBoxPaddingX,
		TextPaddingY + TextBoxPaddingY )

	-- Track bar
	if media:IsTimed() then

		local duration = media:Duration()
		local curTime = media:CurrentTime()
		local percent = math.Clamp( curTime / duration, 0, 1 )

		-- Bar height
		local bh = math.Round(h * 1/32)

		-- Bar background
		draw.RoundedBox( 0, 0, h - bh, w, bh, BarBgColor )

		-- Bar foreground (progress)
		draw.RoundedBox( 0, 0, h - bh, w * percent, bh, BarFgColor )

		local timeY = h - bh - TextPaddingY * 2

		-- Current time
		local curTimeStr = FormatSeconds(math.Clamp(math.Round(curTime), 0, duration))

		DrawTextBox( curTimeStr, "MediaTitle", TextPaddingX, timeY,
			TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM )
		DrawText( curTimeStr, "MediaTitle", TextPaddingX * 2, timeY,
			TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM )

		-- Duration
		local durationStr = FormatSeconds( duration )

		DrawTextBox( durationStr, "MediaTitle", w - TextPaddingX * 2, timeY,
			TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM )
		DrawText( durationStr, "MediaTitle", w - TextBoxPaddingX * 2, timeY,
			TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM )

	end

	-- Volume
	local volume = MediaPlayer.Volume()
	local volumeStr = tostring( math.Round( volume * 100 ) )

	-- DrawText( volumeStr, "MediaTitle", w - TextPaddingX, h*0.5,
		-- TEXT_ALIGN_CENTER )


	-- Loading indicator

end

--PATH addons/media_player/lua/mediaplayer/services/webpage.lua:
DEFINE_BASECLASS( "mp_service_browser" )

SERVICE.Name 	= "Webpage"
SERVICE.Id 		= "www"
SERVICE.Base 	= "res"
SERVICE.Abstract = true -- This service must be handled as a special case.

if CLIENT then

	function SERVICE:OnBrowserReady( browser )
		BaseClass.OnBrowserReady( self, browser )
		browser:OpenURL( self.url )
	end

	function SERVICE:IsMouseInputEnabled()
		return IsValid( self.Browser )
	end

else

	function SERVICE:Match( url )
		return false
	end

end

--PATH addons/media_player/lua/mp_menu/sidebar.lua:
include "icons.lua"
include "common.lua"
include "sidebar_tabs.lua"
include "volume_control.lua"
include "playback.lua"
include "queue.lua"
include "horizontal_list.lua"


--[[--------------------------------------------
	Sidebar root panel
----------------------------------------------]]

local PANEL = {}

function PANEL:Init()

	self:SetName( "MediaPlayerSidebar" )

	self:SetPaintBackgroundEnabled( true )
	self:SetPaintBorderEnabled( false )

	self:SetZPos( -99 )
	self:SetSize( 385, 580 )

	self.Tabs = vgui.Create( "MP.SidebarTabs", self )
	self.Tabs:Dock( FILL )

	local curplaytab = vgui.Create( "MP.CurrentlyPlayingTab" )
	self.Tabs:AddSheet( "CURRENTLY PLAYING", curplaytab, nil, false, false )

	-- TODO: Implement clientside media history for recently viewed tab
	-- local panel = vgui.Create( "Panel" )
	-- self.Tabs:AddSheet( "RECENTLY VIEWED", panel, nil, false, false )

	self.VolumeControls = vgui.Create( "MP.VolumeControl", self )
	self.VolumeControls:Dock( BOTTOM )
	self.VolumeControls:SetHeight( 48 )

	self:InvalidateLayout( true )

end

function PANEL:Paint(w, h)

	surface.SetDrawColor( 0, 0, 0, 140 )
	surface.DrawRect( 0, 0, w, h )

end

function PANEL:PerformLayout()

	self:CenterVertical()
	self:AlignLeft( 10 )

	self.Tabs:SizeToContentWidth()

end

local MP_SIDEBAR = vgui.RegisterTable( PANEL, "EditablePanel" )


--[[--------------------------------------------
	Sidebar presenter
----------------------------------------------]]

local SidebarPresenter = {
	hooks = {}
}

AccessorFunc( SidebarPresenter, "m_Media", "Media" )

function SidebarPresenter:RegisterHook( hookname, callback )

	table.insert( self.hooks, hookname )

	hook.Add( hookname, "MP.SidebarPresenter", function(...)
		if MediaPlayer.DEBUG then
			print("MP.EVENTS.UI", hookname)
			PrintTable({...})
		end

		return callback(...)
	end )

end

function SidebarPresenter:SetupEvents()

	local mp = self:GetMedia()

	self:RegisterHook( MP.EVENTS.UI.OPEN_REQUEST_MENU, function()
		self:HideSidebar()
		MediaPlayer.OpenRequestMenu( mp )
	end )

	self:RegisterHook( MP.EVENTS.UI.FAVORITE_MEDIA, function( media )
		-- TODO
	end )

	self:RegisterHook( MP.EVENTS.UI.REMOVE_MEDIA, function( media )
		if not media then return end
		MediaPlayer.RequestRemove( mp, media:UniqueID() )
	end )

	self:RegisterHook( MP.EVENTS.UI.SKIP_MEDIA, function()
		MediaPlayer.Skip( mp )
	end )

	self:RegisterHook( MP.EVENTS.UI.TOGGLE_LOCK, function()
		MediaPlayer.RequestLock( mp )
	end )

	self:RegisterHook( MP.EVENTS.UI.TOGGLE_PAUSE, function()
		MediaPlayer.Pause( mp )
	end )

	self:RegisterHook( MP.EVENTS.UI.TOGGLE_REPEAT, function()
		MediaPlayer.RequestRepeat( mp )
	end )

	self:RegisterHook( MP.EVENTS.UI.TOGGLE_SHUFFLE, function()
		MediaPlayer.RequestShuffle( mp )
	end )

	self:RegisterHook( MP.EVENTS.UI.SEEK, function( seekTime )
		MediaPlayer.Seek( mp, seekTime )
	end )

	self:RegisterHook( MP.EVENTS.UI.PRIVILEGED_PLAYER, function()
		local ply = LocalPlayer()
		return mp:IsPlayerPrivileged(ply)
	end )

end

function SidebarPresenter:ClearEvents()

	for _, hookname in ipairs(self.hooks) do
		hook.Remove( hookname, "MP.SidebarPresenter" )
	end

end

function SidebarPresenter:ShowSidebar( mp )

	self:SetMedia( mp )

	if ValidPanel(self.Sidebar) then
		self:HideSidebar()
	end

	self:SetupEvents()

	-- Can be used to extend sidebar functionality
	hook.Run( MP.EVENTS.UI.SETUP_SIDEBAR, self, mp )

	local sidebar = vgui.CreateFromTable( MP_SIDEBAR )
	sidebar:MakePopup()

	-- sidebar:SetKeyboardInputEnabled( false )
	sidebar:SetMouseInputEnabled( true )

	hook.Run( MP.EVENTS.UI.MEDIA_PLAYER_CHANGED, mp )

	self.Sidebar = sidebar

end

function SidebarPresenter:HideSidebar()

	if not self.Sidebar then return end

	self:ClearEvents()

	if ValidPanel(self.Sidebar) then
		self.Sidebar:Remove()
	end

	self.Sidebar = nil

end


--[[--------------------------------------------
	MediaPlayer library sidebar helpers
----------------------------------------------]]

function MediaPlayer.ShowSidebar( mp )

	--
	-- Find a valid media player to use for the sidebar
	--

	-- First check if we're looking at a media player
	if not mp then
		local ent = LocalPlayer():GetEyeTrace().Entity
		if IsValid(ent) then
			mp = MediaPlayer.GetByObject( ent )
		end
	end

	-- Else, maybe the gamemode handles this some other way (location system, etc.)
	if not mp then
		mp = hook.Run( "GetMediaPlayer" )
	end

	-- If we still can't find a media player, give up..
	if not IsValid(mp) then return end

	SidebarPresenter:ShowSidebar( mp )

end

function MediaPlayer.HideSidebar()

	SidebarPresenter:HideSidebar()

end

hook.Add( "OnContextMenuOpen", "MP.ShowSidebar", function()
	MediaPlayer.ShowSidebar()
end )
hook.Add( "OnContextMenuClose", "MP.HideSidebar", function()
	MediaPlayer.HideSidebar()
end )

--[[--------------------------------------------
	Sidebar UI test - remove this eventually
----------------------------------------------]]

--[[inputhook.AddKeyPress( KEY_PAGEUP, "MP.ShowSidebarTest", function()
	-- Create test fixture
	local mp = MediaPlayer.Create( 'ui-test-player' )
	mp:SetPlayerState( MP_STATE_PLAYING )

	local function CreateMedia( title, duration, url, ownerName, ownerSteamID, startTime )
		local media = MediaPlayer.GetMediaForUrl( url )

		media._metadata = {
			title = title,
			duration = duration
		}

		media._OwnerName = ownerName
		media._OwnerSteamID = ownerSteamID
		media:StartTime( startTime or RealTime() )

		return media
	end

	---------------------------------
	-- Create current media object
	---------------------------------

	mp:SetMedia( CreateMedia(
		"Test media - really long title test asdfljkasdfasdjfgasdf",
		10,
		"https://www.youtube.com/watch?v=IMorTE0lFLc",
		"WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW",
		"STEAM_0:1:15862026"
	) )


	---------------------------------
	-- Create queued media
	---------------------------------

	mp:AddMedia( CreateMedia(
		"Test media - really long title test asdfljkasdfasdjfgasdf",
		86400,
		"https://www.youtube.com/watch?v=IMorTE0lFLc",
		"WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW",
		"STEAM_0:1:15862026"
	) )

	mp:AddMedia( CreateMedia(
		"Hello world",
		1800,
		"https://www.youtube.com/watch?v=IMorTE0lFLc",
		"Sam",
		"STEAM_0:1:15862026"
	) )

	mp:AddMedia( CreateMedia(
		"ASDSDFawcasiudcg awlieufgawlie",
		180,
		"https://www.youtube.com/watch?v=IMorTE0lFLc",
		"(╯°□°）╯︵ ┻━┻",
		"STEAM_0:1:15862026",
		RealTime() - 1800
	) )

	-- Display UI using fixture
	MediaPlayer.ShowSidebar( mp )
end )]]

--PATH addons/media_player/lua/mp_menu/icons.lua:
local spritesheet = spritesheet

--[[--------------------------------------------
	Icons spritesheet
----------------------------------------------]]

local mpSpritesheetMat = Material( "mediaplayer/ui/spritesheet2015-10-7.png" )
local blockSize = 24

local function mpIcon( name, i, j, w, h )
	return {
		name = name,
		mat = mpSpritesheetMat,
		w = w,
		h = h,
		xoffset = i * blockSize,
		yoffset = j * blockSize
	}
end

spritesheet.Register {
	mpIcon( "mp-thumbs-up",			0, 0, 18, 21 ),
	mpIcon( "mp-thumbs-down",		1, 0, 18, 21 ),
	mpIcon( "mp-delete",			2, 0, 15, 20 ),
	mpIcon( "mp-favorite",			3, 0, 21, 21 ),
	mpIcon( "mp-favorite-outline", 	4, 0, 21, 21 ),
	mpIcon( "mp-volume-mute", 		0, 1, 18, 17 ),
	mpIcon( "mp-volume", 			1, 1, 18, 17 ),
	mpIcon( "mp-back", 				2, 1, 16, 17 ),
	mpIcon( "mp-forward", 			3, 1, 16, 17 ),
	mpIcon( "mp-home", 				4, 1, 19, 17 ),
	mpIcon( "mp-close", 			0, 2, 16, 16 ),
	mpIcon( "mp-skip", 				1, 2, 16, 16 ),
	mpIcon( "mp-refresh", 			2, 2, 16, 15 ),
	mpIcon( "mp-plus", 				3, 2, 14, 14 ),
	mpIcon( "mp-repeat", 			4, 2, 18, 18 ),
	mpIcon( "mp-shuffle", 			0, 3, 16, 16 ),
	mpIcon( "mp-replay", 			1, 3, 13, 16 ),
	mpIcon( "mp-lock", 			    2, 3, 12, 16 ),
	mpIcon( "mp-lock-open", 		3, 3, 12, 16 ),

	mpIcon( "mp-play", 				3, 4, 19, 25 ),
	mpIcon( "mp-pause",				4, 4, 22, 24 ),
}


--[[--------------------------------------------
	DIcon
----------------------------------------------]]

local DICON = {}

AccessorFunc( DICON, "m_strIcon", 				"Icon" )
AccessorFunc( DICON, "m_Color", 				"IconColor" )
AccessorFunc( DICON, "m_bKeepAspect", 			"KeepAspect" )

function DICON:Init()

	self:SetIconColor( color_white )
	self:SetMouseInputEnabled( false )
	self:SetKeyboardInputEnabled( false )

	self:SetKeepAspect( false )

	self.IconWidth = 10
	self.IconHeight = 10

end

function DICON:SetIcon( icon )

	self.m_strIcon = icon

	self.IconWidth, self.IconHeight = spritesheet.GetIconSize( icon )

end

function DICON:SizeToContents( strImage )

	self:SetSize( self.IconWidth, self.IconHeight )

end

function DICON:Paint( w, h )
	self:PaintAt( 0, 0, w, h )
end

function DICON:PaintAt( x, y, dw, dh )

	if not self.m_strIcon then return end

	if ( self.m_bKeepAspect ) then

		local w = self.IconWidth
		local h = self.IconHeight

		-- Image is bigger than panel, shrink to suitable size
		if ( w > dw and h > dh ) then

			if ( w > dw ) then

				local diff = dw / w
				w = w * diff
				h = h * diff

			end

			if ( h > dh ) then

				local diff = dh / h
				w = w * diff
				h = h * diff

			end

		end

		if ( w < dw ) then

			local diff = dw / w
			w = w * diff
			h = h * diff

		end

		if ( h < dh ) then

			local diff = dh / h
			w = w * diff
			h = h * diff

		end

		local OffX = ceil((dw - w) * 0.5)
		local OffY = ceil((dh - h) * 0.5)

		spritesheet.DrawIcon( self.m_strIcon, OffX+y, OffY+y, w, h, self.m_Color )
		return true

	end

	spritesheet.DrawIcon( self.m_strIcon, x, y, dw, dh, self.m_Color )
	return true

end

derma.DefineControl( "DIcon", "", DICON, "DPanel" )


--[[--------------------------------------------
	DIconButton
----------------------------------------------]]

local DICONBTN = {}

AccessorFunc( DICONBTN, "m_strIcon", "Icon" )
AccessorFunc( DICONBTN, "m_bStretchToFit", 			"StretchToFit" )

function DICONBTN:Init()

	self:SetDrawBackground( false )
	self:SetDrawBorder( false )
	self:SetStretchToFit( false )

	self:SetCursor( "hand" )
	self.m_Icon = vgui.Create( "DIcon", self )

	self:SetText( "" )

	self:SetColor( Color( 255, 255, 255, 255 ) )

end

function DICONBTN:SetIconVisible( bBool )

	self.m_Icon:SetVisible( bBool )

end

function DICONBTN:SetIcon( strIcon )

	self.m_Icon:SetIcon( strIcon )

end

function DICONBTN:SetColor( col )

	self.m_Icon:SetIconColor( col )

end

function DICONBTN:GetIcon()

	return self.m_Icon:GetIcon()

end

function DICONBTN:SetKeepAspect( bKeep )

	self.m_Icon:SetKeepAspect( bKeep )

end

function DICONBTN:SizeToContents( )

	self.m_Icon:SizeToContents()
	self:SetSize( self.m_Icon:GetWide(), self.m_Icon:GetTall() )

end

function DICONBTN:PerformLayout()

	if ( self.m_bStretchToFit ) then

		self.m_Icon:SetPos( 0, 0 )
		self.m_Icon:SetSize( self:GetSize() )

	else

		self.m_Icon:SizeToContents()
		self.m_Icon:Center()

	end

end

derma.DefineControl( "DIconButton", "", DICONBTN, "DButton" )


--[[--------------------------------------------
	DIconButton
----------------------------------------------]]

local DICONLBLBTN = {}

AccessorFunc( DICONLBLBTN, "m_LabelSpacing", "LabelSpacing" )
AccessorFunc( DICONLBLBTN, "m_Padding", "Padding" )

function DICONLBLBTN:Init()

	self.BaseClass.Init( self )

	self.BtnLbl = vgui.Create( "DLabel", self )
	self.BtnLbl:SetText( "" )

	self:SetLabelSpacing( 4 )
	self:SetPadding( 4 )

end

function DICONLBLBTN:PerformLayout()

	self.m_Icon:SizeToContents()
	self.m_Icon:AlignLeft( self.m_Padding )

	self.BtnLbl:SizeToContents()
	self.BtnLbl:MoveRightOf( self.m_Icon, self.m_LabelSpacing )

	local w = self.BtnLbl:GetPos() + self.BtnLbl:GetWide() + self.m_Padding
	local h = math.max( self.m_Icon:GetTall(), self.BtnLbl:GetTall() )
	self:SetWide( w, h )

	self.m_Icon:CenterVertical()
	self.BtnLbl:CenterVertical()

end

derma.DefineControl( "DIconLabeledButton", "", DICONLBLBTN, "DIconButton" )

--PATH addons/ukrp_main_content/lua/autorun/one_punch_man_saitama.lua:
player_manager.AddValidModel( "Saitama", "models/pacagma/one_punch_man/saitama/saitama_player.mdl" );
player_manager.AddValidHands( "Saitama", "models/pacagma/one_punch_man/saitama/saitama_arms.mdl", 0, "00000000" )
--PATH addons/____onyx_framework_2/lua/onyx/framework/sh_init_framework.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

AddCSLuaFile('onyx/framework/libs/thirdparty/data/utf8_chunk_1.lua')
AddCSLuaFile('onyx/framework/libs/thirdparty/data/utf8_chunk_2.lua')
AddCSLuaFile('onyx/framework/libs/thirdparty/data/utf8_chunk_3.lua')
AddCSLuaFile('onyx/framework/libs/thirdparty/data/utf8_chunk_4.lua')

onyx.IncludeFolder('onyx/framework/libs/thirdparty/')
onyx.IncludeFolder('onyx/framework/libs/')
onyx.IncludeFolder('onyx/framework/core/')

if (SERVER) then
    onyx.lang = {Get = function(phraseID)
        return phraseID
    end}
    onyx.lang.GetWFallback = onyx.lang.Get
end
--PATH addons/____onyx_framework_2/lua/onyx/framework/libs/thirdparty/sh_pon.lua:
--[[

DEVELOPMENTAL VERSION;

VERSION 1.2.2
Copyright thelastpenguin™

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author, thelastpenguin™, if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above still applies to the modified code.

	The author is not held responsible for any damages incured from the use of pon, you use it at your own risk.

DATA TYPES SUPPORTED:
 - tables  - 		k,v - pointers
 - strings - 		k,v - pointers
 - numbers -		k,v
 - booleans- 		k,v
 - Vectors - 		k,v
 - Angles  -		k,v
 - Entities- 		k,v
 - Players - 		k,v

CHANGE LOG
V 1.1.0
 - Added Vehicle, NPC, NextBot, Player, Weapon
V 1.2.0
 - Added custom handling for k,v tables without any array component.
V 1.2.1
 - fixed deserialization bug.

THANKS TO...
 - VERCAS for the inspiration.
]]


local pon = {};
_G.pon = pon;

local type, count = type, table.Count ;
local tonumber = tonumber ;
local format = string.format;
do
	local type, count = type, table.Count ;
	local tonumber = tonumber ;
	local format = string.format;

	local encode = {};

	local tryCache ;

	local cacheSize = 0;

	encode['table'] = function( self, tbl, output, cache )

		if( cache[ tbl ] )then
			output[ #output + 1 ] = format('(%x)',  cache[tbl] );
			return ;
		else
			cacheSize = cacheSize + 1;
			cache[ tbl ] = cacheSize;
		end


    local first = next(tbl, nil)
    local predictedNumeric = 1
    local lastKey = nil
    -- starts with a numeric dealio
    if first == 1 then
      output[#output + 1] = '{'

      for k,v in next, tbl do
        if k == predictedNumeric then
          predictedNumeric = predictedNumeric + 1

          local tv = type(v)
          if tv == 'string' then
            local pid = cache[v]
            if pid then
              output[#output + 1] = format('(%x)', pid)
            else
              cacheSize = cacheSize + 1
              cache[v] = cacheSize
              self.string(self, v, output, cache)
            end
          else
            self[tv](self, v, output, cache)
          end

        else
          break
        end
      end

			predictedNumeric = predictedNumeric - 1
    else
      predictedNumeric = nil
    end

    if predictedNumeric == nil then
      output[#output + 1] = '[' -- no array component
    else
      output[#output + 1] = '~' -- array component came first so shit needs to happen
    end

    for k, v in next, tbl, predictedNumeric do
      local tk, tv = type(k), type(v)

      -- WRITE KEY
      if tk == 'string' then
        local pid = cache[ k ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ k ] = cacheSize;

          self.string( self, k, output, cache );
        end
      else
        self[tk](self, k, output, cache)
      end

      -- WRITE VALUE
      if( tv == 'string' )then
        local pid = cache[ v ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ v ] = cacheSize;

          self.string( self, v, output, cache );
        end
      else
        self[ tv ]( self, v, output, cache );
      end
    end

    output[#output + 1] = '}'
	end
	--    ENCODE STRING
	local gsub = string.gsub ;
	encode['string'] = function( self, str, output )
		--if tryCache( str, output ) then return end
		local estr, count = gsub( str, ";", "\\;");
		if( count == 0 )then
			output[ #output + 1 ] = '\''..str..';';
		else
			output[ #output + 1 ] = '"'..estr..'";';
		end
	end
	--    ENCODE NUMBER
	encode['number'] = function( self, num, output )
		if num%1 == 0 then
			if num < 0 then
				output[ #output + 1 ] = format( 'x%x;', -num );
			else
				output[ #output + 1 ] = format('X%x;', num );
			end
		else
			output[ #output + 1 ] = tonumber( num )..';';
		end
	end
	--    ENCODE BOOLEAN
	encode['boolean'] = function( self, val, output )
		output[ #output + 1 ] = val and 't' or 'f'
	end
	--    ENCODE VECTOR
	encode['Vector'] = function( self, val, output )
		output[ #output + 1 ] = ('v'..val.x..','..val.y)..(','..val.z..';');
	end
	--    ENCODE ANGLE
	encode['Angle'] = function( self, val, output )
		output[ #output + 1 ] = ('a'..val.p..','..val.y)..(','..val.r..';');
	end
	encode['Entity'] = function( self, val, output )
		output[ #output + 1] = 'E'..(IsValid( val ) and (val:EntIndex( )..';') or '#');
	end
	encode['Player']  = encode['Entity'];
	encode['Vehicle'] = encode['Entity'];
	encode['Weapon']  = encode['Entity'];
	encode['NPC']     = encode['Entity'];
	encode['NextBot'] = encode['Entity'];
	encode['PhysObj'] = encode['Entity'];

	encode['nil'] = function()
		output[ #output + 1 ] = '?';
	end
	encode.__index = function( key )
		ErrorNoHalt('Type: '..key..' can not be encoded. Encoded as as pass-over value.');
		return encode['nil'];
	end

	do
		local empty, concat = table.Empty, table.concat ;
		function pon.encode( tbl )
			local output = {};
			cacheSize = 0;
			encode[ 'table' ]( encode, tbl, output, {} );
			local res = concat( output );

			return res;
		end
	end
end

do
	local tonumber = tonumber ;
	local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode ;
	local Vector, Angle, Entity = Vector, Angle, Entity ;

	local decode = {};
	decode['{'] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tv = sub( str, index, index );
			if( not tv or tv == '~' )then
				index = index + 1;
				break ;
			end
			if( tv == '}' )then
				return index + 1, cur;
			end

			-- READ THE VALUE
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );
			cur[ k ] = v;

			k = k + 1;
		end

		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY

			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end
	decode['['] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY
			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );
			if not k then continue end

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			if not self[tv] then
				print('did not find type: '..tv)
			end
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end

	-- STRING
	decode['"'] = function( self, index, str, cache )
		local finish = find( str, '";', index, true );
		local res = gsub( sub( str, index, finish - 1 ), '\\;', ';' );
		index = finish + 2;

		cache[ #cache + 1 ] = res;
		return index, res;
	end
	-- STRING NO ESCAPING NEEDED
	decode['\''] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local res = sub( str, index, finish - 1 )
		index = finish + 1;

		cache[ #cache + 1 ] = res;
		return index, res;
	end

	-- NUMBER
	decode['n'] = function( self, index, str, cache )
		index = index - 1;
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, num;
	end
	decode['0'] = decode['n'];
	decode['1'] = decode['n'];
	decode['2'] = decode['n'];
	decode['3'] = decode['n'];
	decode['4'] = decode['n'];
	decode['5'] = decode['n'];
	decode['6'] = decode['n'];
	decode['7'] = decode['n'];
	decode['8'] = decode['n'];
	decode['9'] = decode['n'];
	decode['-'] = decode['n'];
	-- positive hex
	decode['X'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end
	-- negative hex
	decode['x'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = -tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end

	-- POINTER
	decode['('] = function( self, index, str, cache )
		local finish = find( str, ')', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, cache[ num ];
	end

	-- BOOLEAN. ONE DATA TYPE FOR YES, ANOTHER FOR NO.
	decode[ 't' ] = function( self, index )
		return index, true;
	end
	decode[ 'f' ] = function( self, index )
		return index, false;
	end

	-- VECTOR
	decode[ 'v' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local vecStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', vecStr, false );
		return index, Vector( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ANGLE
	decode[ 'a' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local angStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', angStr, false );
		return index, Angle( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ENTITY
	decode[ 'E' ] = function( self, index, str, cache )
		if( str[index] == '#' )then
			index = index + 1;
			return index, NULL ;
		else
			local finish = find( str, ';', index, true );
			local num = tonumber( sub( str, index, finish - 1 ) );
			index = finish + 1;
			return index, Entity( num );
		end
	end
	-- PLAYER
	decode[ 'P' ] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, Entity( num ) or NULL;
	end
	-- NIL
	decode['?'] = function( self, index, str, cache )
		return index + 1, nil;
	end


	function pon.decode( data )
		local _, res = decode[sub(data,1,1)]( decode, 2, data, {});
		return res;
	end
end

--PATH addons/____onyx_framework_2/lua/onyx/ui/core/cl_panel_functions.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

15/04/2022

--]]

local ABSTRACT = {}

--[[------------------------------
Functions
--------------------------------]]
function ABSTRACT:GetX()
    local x = self:GetPos()
    return x
end

function ABSTRACT:GetY()
    local _, y = self:GetPos()
    return y
end

function ABSTRACT:SetX(x)
    self:SetPos(x, self:GetY())
end

function ABSTRACT:SetY(y)
    self:SetPos(self:GetX(), y)
end

-- Traits

function ABSTRACT:Import(name)
    onyx.trait.Import(self, name)
end

-- Events

function ABSTRACT:On(name, fn)
    return onyx.gui.AddEvent(self, name, fn)
end

function ABSTRACT:Call(name, ignoreRaw, ...)
    onyx.gui.CallEvent(self, name, ignoreRaw, ...)
end

function ABSTRACT:InjectEventHandler(name)
    onyx.gui.InjectEventHandler(self, name)
end

-- Misc

function ABSTRACT:Combine(pnl2, fnName)
    self[fnName] = function(_, ...)
        return pnl2[fnName](pnl2, ...)
    end
end

function ABSTRACT:CombineMutator(pnl2, mutatorName)
    self:Combine(pnl2, 'Set' .. mutatorName)
    self:Combine(pnl2, 'Get' .. mutatorName)
end

function ABSTRACT:MakeDispatchFn(pnl2, fnName)
    pnl2[fnName] = function(_, ...)
        return self:Call(fnName, nil, ...)
    end
end

function ABSTRACT:SquareInContainer(class, width, height, size, dock)
    self._Container = self:Add('Panel')
    self._Container:Dock(dock)
    self._Container:SetSize(width, height)

    self._Container.Child = self._Container:Add(class)

    self._Container.PerformLayout = function(panel, w, h)
        local size = size < 1 and math.ceil(math.min(w * size, h * size)) or size

        panel.Child:SetWide(size)
        panel.Child:SetTall(size)
        panel.Child:Center()
    end

    return self._Container.Child
end

function ABSTRACT:Padding(padding)
    self:DockPadding(padding, padding, padding, padding)
end

onyx.abstract = ABSTRACT

--[[------------------------------
Register
--------------------------------]]
for name, fn in pairs(ABSTRACT) do
    onyx.gui.RegisterFunc(name, fn)
end
--PATH addons/____onyx_framework_2/lua/onyx/ui/elements/cl_image.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

local PANEL = {}

AccessorFunc(PANEL, 'm_Material', 'Material')
AccessorFunc(PANEL, 'm_colColor', 'Color')
AccessorFunc(PANEL, 'm_iImageAngle', 'ImageAngle')
AccessorFunc(PANEL, 'm_iImageScale', 'ImageScale')
AccessorFunc(PANEL, 'm_iImageWide', 'ImageWide')
AccessorFunc(PANEL, 'm_iImageTall', 'ImageTall')

function PANEL:Init()
    self:SetImageScale(1)
    self:SetImageAngle(0)
    self:SetColor(color_white)
    self:SetURL('https://i.imgur.com/PnE3dNf.png', 'smooth mips')
end

function PANEL:SetImageSize(w, h)
    h = h or w -- square

    self:SetImageWide(w)
    self:SetImageTall(h)
end

function PANEL:SetURL(url, parameters)
    self.m_WebImage = onyx.wimg.Simple(url, parameters)
end

function PANEL:SetWebImage(id, parameters)
    self.m_WebImage = onyx.wimg.Create(id, parameters)
end

function PANEL:SetSVG(id, w, h, colorable)
    self.m_SVG = onyx.svg.Create(id, w, (h or w), colorable)
end

function PANEL:SetImage(path, params)
    self:SetMaterial(Material(path, params))
end

function PANEL:GetWebImage()
    return self.m_WebImage
end

function PANEL:GetSVG()
    return self.m_SVG
end

function PANEL:Paint(w, h)
    self:Call('PaintBackground', nil, w, h)

    local webImage = self:GetWebImage()
    local material = self:GetMaterial()
    local svg = self:GetSVG()
    local color = self:GetColor()
    local scale = self:GetImageScale()
    local angle = self:GetImageAngle()
    local iw, ih = self:GetImageWide() or w, self:GetImageTall() or h
    local ix, iy = w * .5, h * .5

    iw = iw * scale
    ih = ih * scale

    if svg then
    --     print(svg:GetWide(), svg:GetMaterial())
        svg:Draw(w * .5 - svg:GetWide() * .5, h * .5 - svg:GetTall() * .5, nil, nil, color)
    elseif webImage then
        webImage:DrawRotated(ix, iy, iw, ih, angle, color)
    elseif material then
        onyx.DrawMaterialRotated(material, ix, iy, iw, ih, angle, color)
    end
end

onyx.gui.Register('onyx.Image', PANEL)

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .65, .65, function(self)
--     local test = self:Add('onyx.Image')
--     test:SetSVG('user-outline', 128, nil, true)
--     test:SetSize(256, 256)
--     test:Center()
--     test.PaintBackground = function(panel, w, h)
--         surface.SetDrawColor(0, 0, 0)
--         surface.DrawRect(0, 0, w, h)
--     end
-- end)
--PATH addons/____onyx_framework_2/lua/onyx/ui/elements/cl_pie_chart.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/01/2024

--]]

local CIRCLE_FULL_ANGLE = 360

local PANEL = {}

AccessorFunc(PANEL, 'm_Data', 'Data')
AccessorFunc(PANEL, 'm_LegendFont', 'LegendFont')
AccessorFunc(PANEL, 'm_iSum', 'Sum')
AccessorFunc(PANEL, 'm_bDonut', 'Donut')
AccessorFunc(PANEL, 'm_flRadius', 'Radius')
AccessorFunc(PANEL, 'm_colCircleBackgroundColor', 'CircleBackgroundColor')

function PANEL:Init()
    self:SetData({})
    self:SetCircleBackgroundColor(Color(100, 100, 100))
    self:SetDonut(false)
    self:SetRadius(.33)
    self:SetLegendFont(onyx.Font('Comfortaa@16'))

    self.divBody = self:Add('Panel')
    self.divBody.Paint = function(panel, w, h)
        self:DrawChart(w, h)
    end
    self.divBody.PerformLayout = function(panel, w, h)
        self:PerformChart(w, h)
    end

    self.divLegend = self:Add('Panel')
    self.divLegend.Paint = function(panel, w, h)
        self:DrawLegend(w, h)
    end
end

function PANEL:PerformLayout(w, h)
    self.divBody:Dock(FILL)

    self.divLegend:Dock(RIGHT)
    self.divLegend:SetWide(w * .5)
end

function PANEL:SetLegendVisible(bVisible)
    self.divLegend:SetVisible(bVisible)
end

function PANEL:AddRecord(text, amount, color)
    onyx.AssertType(text, 'string', 'AddRecord', 1)
    onyx.AssertType(amount, 'number', 'AddRecord', 2)

    local color = color or onyx.ColorEditHSV(color_white, math.random(360), .8, .8)

    local data = self:GetData()
    table.insert(data, {
        text = text,
        amount = amount,
        color = color
    })

    table.sort(data, function(a, b)
        return a.amount > b.amount
    end)

    self:UpdateSum()
end

function PANEL:UpdateSum()
    local data = self:GetData()
    local sum = 0

    for _, record in ipairs(data) do
        sum = sum + record.amount
    end

    for _, record in ipairs(data) do
        record.fraction = (record.amount / sum)
    end

    self:SetSum(sum)
    self.divBody:InvalidateLayout(true)

    return sum
end

function PANEL:DrawLegend(w, h)
    local data = self:GetData()
    local amount = #data
    local font = self:GetLegendFont()
    local y = 0

    surface.SetFont(font)
    local _, textH = surface.GetTextSize('A')
    local space = onyx.ScaleTall(5)
    local iconMargin = onyx.ScaleWide(5)

    for index = 1, amount do
        local record = data[index]

        onyx.DrawCircle(textH * .5, y + textH * .5, textH * .5, record.color)

        draw.SimpleText(record.text, font, textH + iconMargin, y, color_white, 0, 0)
        draw.SimpleText(math.Round(record.fraction * 100, 1) .. '%', font, w, y, color_white, 2, 0)

        y = y + textH + space
    end
end

function PANEL:DrawChart(w, h)
    local data = self:GetData()
    local radius = math.min(w, h) * self:GetRadius()
    local isDonut = self:GetDonut()
    local outlineThickness = 4

    if (isDonut) then
        onyx.DrawOutlinedCircle(w * .5, h * .5, radius, outlineThickness, self.m_colCircleBackgroundColor)
    else
        onyx.DrawCircle(w * .5, h * .5, radius, self.m_colCircleBackgroundColor)
    end

    for _, record in ipairs(data) do
        onyx.DrawWithPolyMask(record.poly, function()
            if (isDonut) then
                onyx.DrawOutlinedCircle(w * .5, h * .5, radius, outlineThickness, record.color)
            else
                onyx.DrawCircle(w * .5, h * .5, radius, record.color)
            end
        end)
    end

    self:PostDrawChart(w, h)
end

function PANEL:PostDrawChart(w, h)

end

function PANEL:PerformChart(w, h)
    local data = self:GetData()
    local startAngle = 0
    local radius = math.min(w, h) * self:GetRadius()

    for _, record in ipairs(data) do
        if (not record.fraction) then break end

        local segmentAngle = math.Round(record.fraction * CIRCLE_FULL_ANGLE)

        record.poly = onyx.CalculateArc(w * .5, h * .5, startAngle, segmentAngle, radius + 2, 24, true)

        startAngle = startAngle + segmentAngle
    end
end

onyx.gui.Register('onyx.PieChart', PANEL)

--[[------------------------------
DEBUG
--------------------------------]]
-- onyx.gui.Test('onyx.Frame', .65, .65, function(self, w, h)
--     self:MakePopup()
--     local content = self:Add('onyx.PieChart')
--     content:DockPadding(10, 10, 10, 10)
--     content:Dock(FILL)
--     -- content:SetLegendVisible(false)
--     content:AddRecord('Apple', 10, Color(220, 31, 31))
--     content:AddRecord('Pear', 10, Color(113, 193, 78))
--     content:AddRecord('Banana', 5, Color(255, 224, 48))
--     content:AddRecord('Orange', 2, Color(255, 143, 15))
--     content:SetDonut(true)
-- end)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/sh_init.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2023

--]]

onyx:Addon('creditstore', {
    color = Color(0, 89, 255),
    author = 'tochnonement',
    version = '1.3.8',
    licensee = '76561198843434426'
})

----------------------------------------------------------------

if (CLIENT) then
    onyx.wimg.Register('creditstore_currency', 'https://i.imgur.com/MrgKOkL.png')
end

onyx.Include('sv_sql.lua')
onyx.IncludeFolder('onyx/modules/creditstore/languages/')
onyx.IncludeFolder('onyx/modules/creditstore/core/', true)
onyx.IncludeFolder('onyx/modules/creditstore/cfg/', true)
onyx.IncludeFolder('onyx/modules/creditstore/ui/')

onyx.creditstore:Print('Finished loading.')
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/languages/cl_french.lua:
-- Translated using DeepL
-- Required a native speaker to validate the translation

local LANG = {}

-- TABS
LANG.store_u = 'BOUTIQUE'
LANG.inventory_u = 'INVENTAIRE'
LANG.refunds_u = 'REMBOURSEMENT'
LANG.convert_u = 'ÉCHANGER'
LANG.admin_u = 'ADMIN'
LANG.donate_u = 'SUIVRE'

-- ADMIN TABS
LANG.players_u = 'JOUEURS'
LANG.items_u = 'POINTS'
LANG.settings_u = 'PARAMÈTRES'
LANG.return_u = 'RETOUR'

-- WORDS
LANG.active_u = 'ACTIVE'
LANG.unactive_u = 'UNACTIVE'
LANG.owned_u = 'PROPRIÉTÉ'
LANG.credits = 'Crédits'
LANG.money = 'Argent'
LANG.both = 'Les deux'
LANG.convert = 'Convertir'
LANG.single = 'Unique'
LANG.half = 'Moitié'
LANG.all = 'Tous'
LANG.icon = 'Icône'
LANG.model = 'Modèle'

-- OPTIONS
LANG.use = 'Utiliser'
LANG.equip = 'Equiper'
LANG.unequip = 'Unquip'
LANG.spawn = 'Spawn'
LANG.confirm = 'Confirmer'
LANG.cancel = 'Annuler'
LANG.delete = 'Supprimer'

-- PHRASES
LANG.purchaseItem = 'Achat "{item}"'
LANG.notEnoughCredits = 'Pas assez de crédits!'
LANG.youMustBeAlive = 'Vous devez être en vie!'
LANG.requestRefund = 'Demande de remboursement'
LANG.refundableUntil = 'PEUT ÊTRE RENVOYÉE À'
LANG.currentRate = 'Taux actuel : 1 crédit = {rate}'
LANG.youGive = 'VOUS DONNEZ'
LANG.youReceive = 'VOUS OBTENEZ'
LANG.giveItem = 'PRATIQUE EXÉCUTIVE'
LANG.nothingToRefund = 'PAS DE LOCAUX'
LANG.healthIsFull = 'Votre santé est complète!'
LANG.armorIsFull = 'Votre armure est pleine!'
LANG.youRefunded = 'Vous avez retourné {item} et reçu des crédits de {price}!'
LANG.youPurchased = 'Vous avez acquis {item}!'
LANG.youConverted = 'Vous avez converti {A} в {B}!'
LANG.cantAfford = 'Vous n\'avez pas assez d\'argent pour cela!'

LANG.createCategory = 'CRÉER UNE CATÉGORIE'
LANG.newItem = 'NOUVELLE PRATIQUE'
LANG.edit_u = 'EDIT'
LANG.delete_u = 'DELETE'
LANG.create_u = 'CRÉER'

LANG.searchName = 'Recherche par nom...'
LANG.searchNameSteamID = 'Recherche par Nom/SteamID...'

-- ERRORS
LANG.idMustBeUnique = 'L\'identifiant doit être unique!'
LANG.fieldMustNumber = 'Le {field} doit être un nombre !'
LANG.fieldMustPositive = 'Le {field} doit être un nombre positif !'
LANG.fieldMustChoose = 'Vous devez choisir {field} !'
LANG.fieldEnter = 'Vous devez entrer dans {field} !'
LANG.invalidModel = 'Le modèle n\'est pas valide !'
LANG.iconMustURL = 'L\'icône doit être une URL !'
LANG.invalidIconFormat = 'L\'icône doit être au format .png ou .jpg !'
LANG.notEnoughSymbols = 'Le {field} doit contenir au moins {min} symboles !'
LANG.tooManySymbols = 'Le {field} ne peut contenir plus de {max} symboles !'

--[[------------------------------
FOR OTHER LANGUAGES
--------------------------------]]

LANG['Select an option'] = 'Choisir une option'

-- Types
LANG['Vehicle'] = 'Véhicule'
LANG['Health'] = 'Santé'
LANG['Armor'] = 'Armure'
LANG['Tool'] = 'Outil'
LANG['Trail'] = 'Sentier'
LANG['Permanent Booster'] = 'Booster permanent'
LANG['Permanent Weapon'] = 'Arme permanente'
LANG['Permanent Rank'] = 'Rang permanent'
LANG['Permanent Suit'] = 'Costume permanent'
LANG['Permanent Model'] = 'Modèle permanent'
LANG['Suit'] = 'Costume'
LANG['Accessory'] = 'Accessoire'
LANG['Entity'] = 'Entité'
LANG['Experience'] = 'Expérience'
LANG['Job'] = 'Emploi'
LANG['Money'] = 'Argent'
LANG['Weapon'] = 'Arme'
LANG['Console Command'] = 'Commande de la console'
LANG['Key'] = 'Clé'
LANG['Case'] = 'Caisse'

-- Fields
LANG['IDENTIFIER'] = 'IDENTIFIER'
LANG['TYPE'] = 'TYPE'
LANG['NAME'] = 'NOM'
LANG['PRICE'] = 'PRIX'
LANG['ICON'] = 'ICON'
LANG['ORDER'] = 'COMMANDE'
LANG['CATEGORY'] = 'CATÉGORIE'

LANG['IDENTIFIER_Desc'] = 'Saisir un identifiant unique.'
LANG['TYPE_Desc'] = 'Sélectionner le type de sujet.'
LANG['NAME_Desc'] = 'Saisir le nom.'
LANG['PRICE_Desc'] = 'Saisir la valeur de l\'élément.'
LANG['ICON_Desc'] = 'Saisir l\'image.'
LANG['ORDER_Desc'] = 'Saisissez un numéro pour classer les catégories.'
LANG['CATEGORY_Desc'] = 'Sélectionner une catégorie d\'articles.'

onyx.lang:AddPhrases('french', LANG)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/core/refund/sh_refund.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com
Licensee: 76561198843434426

02/05/2023

--]]

local creditstore = onyx.creditstore

function creditstore:GetRefundEndTime(purchaseTime)
    local hours = onyx.creditstore:GetOptionValue('refunds_hours')
    local time = 3600 * hours
    local refundEndTime = purchaseTime + time
    return refundEndTime
end

function creditstore:GetRefundPrice(price)
    local percents = onyx.creditstore:GetOptionValue('refunds_percent')
    local fraction = percents / 100
    local newPrice = math.ceil(price * fraction)
    return newPrice
end

creditstore:RegisterOption('refunds_enabled', {
    title = 'Enabled',
    desc = 'Enable refunds module',
    category = 'Refunds',
    cami = 'onyx_creditstore_edit',
    type = 'bool',
    default = false
})

creditstore:RegisterOption('refunds_percent', {
    title = 'Percentage',
    desc = 'Percentage of the original cost',
    category = 'Refunds',
    cami = 'onyx_creditstore_edit',
    type = 'int',
    min = 1,
    max = 100,
    default = 65
})

creditstore:RegisterOption('refunds_hours', {
    title = 'Time',
    desc = 'How many hours is it possible to refund an item',
    category = 'Refunds',
    cami = 'onyx_creditstore_edit',
    type = 'int',
    min = 1,
    max = 24 * 30,
    default = 12
})
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/cfg/integrations/sh_sandbox.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

01/05/2023

--]]

local INTEGRATION = {}

INTEGRATION.Name = 'Sandbox'
INTEGRATION.Color = Color(184, 162, 63)
INTEGRATION.Desc = 'The Sandbox essentials'

function INTEGRATION:Check()
    return true
end

function INTEGRATION:Load()
    onyx.creditstore:RegisterType('sandbox_tool', {
        name = 'Tool',
        color = Color(150, 134, 46),
        equip = true,
        defaultIcon = 'https://files.facepunch.com/rust/item/toolgun_512.png',
        noDuplicates = true,
        settings = {
            {
                key = 'tool',
                name = 'TOOL',
                desc = 'The tool.',
                icon = 'https://i.imgur.com/zgt3zea.png',
                type = 'combo',
                getOptions = function()
                    local options = {}
            
                    local tool = weapons.Get('gmod_tool')
                    if (not tool) then return {} end -- oopsie

                    local tools = tool.Tool

                    for id, data in pairs(tools) do
                        if (data.Name and data.LeftClick and data.AddToMenu ~= false) then
                            local category = data.Category or 'Other'
                            local printName = language.GetPhrase(data.Name)
                            local name = category and (category .. ' | ' .. printName) or printName
                
                            table.insert(options, {
                                text = name,
                                data = id
                            })
                        end
                    end
            
                    table.sort(options, function(a, b)
                        return a.text < b.text
                    end)
            
                    return options
                end,
                validateOption = function(data)
                    -- do not be lazy to do this function, it is also used on the server side to validate value
                    if (not data) then return false, 'You must choose a tool!' end

                    local tool = weapons.Get('gmod_tool')
                    if (not tool) then return end -- oopsie

                    local tools = tool.Tool
                    if (not tools[data]) then return false end
            
                    return true
                end
            }
        }
    })

    hook.Add('CanTool', 'onyx.creditstore', function(ply, tr, toolName)
        for id, itemTable in pairs(onyx.creditstore.items) do
            if (itemTable.type == 'sandbox_tool' and itemTable.data.tool == toolName) then
                
                local inventory = onyx.creditstore:GetPlayerInventory(ply)
                local hasItem = false
                local itemActivated = false

                for _, it in ipairs(inventory) do
                    if (it.id == id) then
                        hasItem = true
                        itemActivated = it.data and it.data.equipped
                        break
                    end
                end

                
                local bCanUse = hasItem and itemActivated or false

                if (CLIENT and not bCanUse and IsFirstTimePredicted()) then
                    if (hasItem) then
                        notification.AddLegacy('The tool is restricted, activate in !store inventory', 1, 5)
                    else
                        notification.AddLegacy('The tool is restricted, purchase access in !store', 1, 5)
                    end
                end

                return bCanUse
            end
        end
    end)
end

onyx.creditstore:RegisterIntegration('sandbox', INTEGRATION)
--PATH addons/____onyx_f4/lua/onyx/modules/f4/sh_init.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

25/12/2023

--]]

onyx:Addon('f4', {
    color = Color(65, 162, 211),
    author = 'tochnonement',
    version = '1.2.6',
    licensee = '76561198843434426'
})

----------------------------------------------------------------

onyx.Include('sv_sql.lua')
onyx.IncludeFolder('onyx/modules/f4/languages/')
onyx.IncludeFolder('onyx/modules/f4/core/', true)
onyx.IncludeFolder('onyx/modules/f4/cfg/', true)
onyx.IncludeFolder('onyx/modules/f4/ui/')

onyx.f4:Print('Finished loading.')
--PATH addons/____onyx_f4/lua/onyx/modules/f4/languages/cl_polish.lua:
--[[
Kayzed @ 2024
--]]

local LANG = {}

-- TABS
LANG.f4_jobs_u = 'PRACE'
LANG.f4_jobs_desc = 'Wybierz swój zawód'

LANG.f4_dashboard_u = 'PULPIT'
LANG.f4_dashboard_desc = 'Ogólne informacje'

LANG.f4_shop_u = 'SKLEP'
LANG.f4_shop_desc = 'Zakup dowolne dobra'

LANG.f4_admin_u = 'ADMIN'
LANG.f4_admin_desc = 'Skonfiguruj dodatek'

LANG.f4_donate_u = 'DONACJA'
LANG.f4_donate_desc = 'Wspieraj serwer'

LANG.addon_settings_u = 'USTAWIENIA'
LANG.addon_settings_desc = 'Skonfiguruj dodatek'

LANG.addon_return_u = 'POWRÓT'
LANG.addon_return_desc = 'Wróć do poprzedniej zakładki'

-- Other
LANG.f4_salary = 'Pensja'
LANG.f4_price = 'Cena'
LANG.f4_loading = 'Ładowanie'
LANG.f4_purchases = 'Zakupy'
LANG.f4_switches = 'Przełączniki'
LANG.f4_unavailable = 'Niedostępne'
LANG.f4_description_u = 'OPIS'
LANG.f4_weapons_u = 'BROŃ'
LANG.f4_entities_u = 'BYTY'
LANG.f4_ammo_u = 'AMUNICJA'
LANG.f4_food_u = 'JEDZENIE'
LANG.f4_shipments_u = 'PACZKI'
LANG.f4_become_u = 'ZOSTAŃ'
LANG.f4_create_vote_u = 'UTWÓRZ GŁOSOWANIE'
LANG.f4_general_u = 'OGÓLNE'
LANG.f4_police_u = 'POLICJA'
LANG.f4_mayor_u = 'BURMISTRZ'
LANG.f4_confirm_u = 'POTWIERDŹ'
LANG.f4_cancel_u = 'ANULUJ'
LANG.f4_mostpopular_u = 'NAJPOPULARNIEJSZE'
LANG.f4_chart_u = 'WYKRES'
LANG.f4_loading_u = 'ŁADOWANIE'
LANG.f4_empty_u = 'PUSTE'
LANG.f4_favorite_u = 'ULUBIONE'

LANG.f4_playersonline_u = 'GRACZE ONLINE'
LANG.f4_totalmoney_u = 'CAŁKOWITA KASA'
LANG.f4_staffonline_u = 'ADMINISTRACJA ONLINE'
LANG.f4_actions_u = 'AKCJE'

LANG.f4_show_favorite = 'Pokaż Ulubione'

LANG.requires_level = 'Wymaga Poziomu {level}'

-- Actions
LANG['f4_action_input_amount'] = 'Wprowadź ilość'
LANG['f4_action_input_text'] = 'Wprowadź tekst'
LANG['f4_action_input_reason'] = 'Podaj powód'
LANG['f4_action_choose_player'] = 'Wybierz gracza'

LANG['f4_action_confirm_action'] = 'Potwierdź akcję'
LANG['f4_action_drop_money'] = 'Upuść Pieniądze'
LANG['f4_action_give_money'] = 'Daj Pieniądze'
LANG['f4_action_change_name'] = 'Zmień Imię'
LANG['f4_action_drop_weapon'] = 'Upuść Broń'
LANG['f4_action_sell_doors'] = 'Sprzedaj Wszystkie Drzwi'

LANG['f4_action_warrant'] = 'Wystaw Nakaz'
LANG['f4_action_wanted'] = 'Oznacz jako Poszukiwany'

LANG['f4_toggle_lockdown'] = 'Przełącz Blokadę'
LANG['f4_give_license'] = 'Daj Licencję'

-- Phrases
LANG['f4_search_text'] = 'Szukaj po imieniu...'

-- Settings
LANG['f4.option_url_desc'] = 'Podaj URL (pozostaw puste, aby wyłączyć)'

LANG['f4.discord_url.name'] = 'Discord'
LANG['f4.discord_url.desc'] = 'Dołącz do naszego serwera Discord'

LANG['f4.forum_url.name'] = 'Forum'
LANG['f4.forum_url.desc'] = 'Poznaj naszą społeczność'

LANG['f4.steam_url.name'] = 'Steam'
LANG['f4.steam_url.desc'] = 'Dołącz do naszej grupy Steam'

LANG['f4.rules_url.name'] = 'Zasady'
LANG['f4.rules_url.desc'] = 'Poznaj zasady'

LANG['f4.donate_url.name'] = 'Donacja'

LANG['f4.website_ingame.name'] = 'Przeglądarka'
LANG['f4.website_ingame.desc'] = 'Użyj przeglądarki w grze, aby otworzyć URL strony'

LANG['f4.title.name'] = 'Tytuł'
LANG['f4.title.desc'] = 'Tytuł dla ramki'

LANG['f4.hide_donate_tab.name'] = 'Ukryj zakładkę Donacja'
LANG['f4.hide_donate_tab.desc'] = 'Ukryj zakładkę integracji sklepu kredytowego'

LANG['f4.edit_job_colors.name'] = 'Modyfikuj Kolory Prac'
LANG['f4.edit_job_colors.desc'] = 'Czy kolory prac mają być jaśniejsze'

LANG['f4.hide_admins.name'] = 'Ukryj Sekcję Administratorów'
LANG['f4.hide_admins.desc'] = 'Ukryj sekcję listy adminów na pulpicie'

LANG['f4.admin_on_duty.name'] = 'Włączona Praca Administratora'
LANG['f4.admin_on_duty.desc'] = 'Wyświetlaj jako administrator tylko osoby z określoną pracą'

LANG['f4.admin_on_duty_job.name'] = 'Nazwa Pracy Administratora'
LANG['f4.admin_on_duty_job.desc'] = 'Nazwa pracy administratora*'

LANG['f4.colored_items.name'] = 'Kolorowy Gradient'
LANG['f4.colored_items.desc'] = 'Włącz delikatny gradient dla przedmiotów/prac'

LANG['f4.item_columns.name'] = 'Kolumny'
LANG['f4.item_columns.desc'] = 'Liczba kolumn dla Przedmiotów'

LANG['f4.job_columns.name'] = 'Kolumny'
LANG['f4.job_columns.desc'] = 'Liczba kolumn dla Prac'

LANG['f4.model_3d.name'] = 'Modele 3D'
LANG['f4.model_3d.desc'] = 'Włącz renderowanie w czasie rzeczywistym dla ikon Przedmiotów/Prac'

LANG['f4.item_show_unavailable.name'] = 'Niedostępne Przedmioty'
LANG['f4.item_show_unavailable.desc'] = 'Pokaż przedmioty, które nie przeszły customCheck'

LANG['f4.job_show_unavailable.name'] = 'Niedostępne Prace'
LANG['f4.job_show_unavailable.desc'] = 'Pokaż prace, które nie przeszły customCheck'

LANG['f4.job_show_requirejob.name'] = 'Zależne Prace'
LANG['f4.job_show_requirejob.desc'] = 'Pokaż prace, których nie można wybrać z powodu niewłaściwej pracy gracza'

onyx.lang:AddPhrases('polish', LANG)
--PATH addons/____onyx_f4/lua/onyx/modules/f4/cfg/cl_ranks.lua:
--[[

Contact: filipovskis@proton.me
GitHub: https://github.com/filipovskis
Date: 29/09/2024

This code was written by Aleksandrs Filipovskis. Contact via email or GitHub.

--]]

--[[
    **WARNING**
    All defined ranks are considered admins.
--]]

onyx.f4.ranks = {}

onyx.f4:DefineRank('superadmin', {
    name = 'Owner',
    color = Color(255, 71, 71)
})
--PATH addons/____onyx_hud/lua/onyx/modules/hud/core/cl_level_support.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

21/08/2024

--]]

onyx.hud.levelling = onyx.hud.levelling or {}

local function validateDataValue( data, key )
    assert( data[ key ], Format( '`onyx.hud.RegisterLevelSystem` bad data (missing value for \'%s\')', key ) )
    assert( isfunction( data[ key ] ), Format( '`onyx.hud.RegisterLevelSystem` bad data (the value should be function \'%s\')', type( data ), key ) )
end

function onyx.hud.RegisterLevelSystem( id, data )
    assert( isstring( id ), Format( '`onyx.hud.RegisterLevelSystem` bad argument #1 (expected string, got %s)', type( id ) ) )
    assert( istable( data ), Format( '`onyx.hud.RegisterLevelSystem` bad argument #2 (expected table, got %s)', type( data ) ) )
    validateDataValue( data, 'getLevel' )
    validateDataValue( data, 'getMaxXP' )
    validateDataValue( data, 'getXP' )
    validateDataValue( data, 'customCheck' )

    data.id = id
    onyx.hud.levelling[ id ] = data
end

function onyx.hud.IsLevellingEnabled()
    return ( onyx.hud.levelSystem ~= nil )
end

function onyx.hud.GetLevelData( client )
    local sysTable = onyx.hud.levelSystem
    if ( sysTable ) then
        local level = math.Round( sysTable.getLevel( client ) )
        local maxXP = math.Round( sysTable.getMaxXP( client ) )
        local xp = math.Round( sysTable.getXP( client ) )

        return level, xp, maxXP
    end
end

onyx.WaitForGamemode( 'onyx.hud.CheckLevelSystem', function()
    for sysID, sysTable in pairs( onyx.hud.levelling ) do
        if ( sysTable.customCheck() ) then
            if ( not sysTable.detected and sysTable.onDetected ) then
                sysTable.detected = true
                sysTable.onDetected()
            end

            onyx.hud.levelSystem = sysTable
        end
    end
end )
--PATH addons/____onyx_hud/lua/onyx/modules/hud/elements/cl_own_info.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

16/08/2024

--]]

local L = function( ... ) return onyx.lang:Get( ... ) end
local MAX_RANGE = 128 ^ 2

local hud = onyx.hud

local traceEntity = NULL
local showFraction = 0
local traceData

timer.Create( 'onyx.hud.CatchTraceVehicle', 1 / 6, 0, function()
    local client = LocalPlayer()
    if ( IsValid( client ) ) then
        local origin = client:GetPos()
        local trace = client:GetEyeTrace()
        local ent = trace.Entity

        if ( IsValid( ent ) and ent:IsVehicle() and not client:InVehicle() and ent:GetPos():DistToSqr( origin ) <= MAX_RANGE ) then
            local class = ent:GetVehicleClass()
            local vehTable = list.Get( 'Vehicles' )[ class ]
            if ( not vehTable and simfphys ) then
                vehTable = list.Get( "simfphys_vehicles" )[ class ]
            end

            local name = vehTable and ( vehTable.Name or class ) or class
        
            local owner = ent:DoorGetOwner()
            local group = ent:DoorGetGroup()
            local info = L( 'hud_door_owner', { name = IsValid( owner ) and owner:Name() or L( 'unknown' ) } )

            if ( group ) then
                info = group
            end

            if ( traceEntity ~= ent ) then showFraction = 0 end
            
            traceEntity = ent

            -- it will be set to nil when the animation's fraction reaches 0
            traceData = {
                name = name,
                owner = owner,
                info = info
            }
        else
            traceEntity = NULL
        end
    end
end )

local function drawOwnInfo( element, client, scrW, scrH )
    local validTarget = IsValid( traceEntity )

    showFraction = math.Approach( showFraction, validTarget and 1 or 0, FrameTime() * 8 )
    
    if ( showFraction <= 0 or not traceData ) then 
        traceData = nil
        return 
    end

    local x0 = scrW * .5
    local y0 = scrH * .85

    local theme = hud:GetCurrentTheme()
    local colors = theme.colors
    local infoW = hud.ScaleWide( 200 )
    local infoH = hud.ScaleTall( 50 )    
    local infoX, infoY = x0 - infoW * .5, y0 - infoH * .5

    hud.OverrideAlpha( showFraction, function()

        hud.DrawRoundedBox( infoX, infoY, infoW, infoH, colors.primary )
        draw.SimpleText( traceData.name, hud.fonts.SmallBold, x0, y0, colors.textPrimary, 1, 4 )
        draw.SimpleText( traceData.info, hud.fonts.Tiny, x0, y0, colors.textSecondary, 1, 0 )

    end )
end

onyx.hud:RegisterElement( 'owner_info', { drawFn = drawOwnInfo } )
--PATH addons/____onyx_hud/lua/onyx/modules/hud/elements/cl_vehicle_hud.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

20/08/2024

--]]

local COLOR_GREEN, COLOR_RED = Color( 96, 230, 39), Color( 252, 30, 30 )
local COLOR_SHADOW = Color( 0, 0, 0, 100 )
local COLOR_FUEL = Color( 196, 88, 0)
local CONVAR_BLUR = CreateClientConVar( 'cl_onyx_hud_speedometer_blur', '1', true, false, '', 0, 1 )

local STATUS_ICONS = {
    [ 'simfphys' ] = {
        {
            id = 'parking-brake',
            icons = { { url = 'https://i.imgur.com/DhZNMqx.png', color = Color( 255, 0, 0 ) } },
            getState = function( vehicle )
                return ( vehicle:GetHandBrakeEnabled() and 1 or 0 )
            end
        },
        {
            id = 'cruise-control',
            icons = { { url = 'https://i.imgur.com/rSkZck6.png', color = Color( 166, 255, 0) } },
            getState = function( vehicle )
                return ( vehicle:GetIsCruiseModeOn() and 1 or 0 )
            end
        },
        {
            id = 'fog-light',
            icons = { { url = 'https://i.imgur.com/DgPmV27.png', color = Color( 255, 204, 0) } },
            getState = function( vehicle )
                return ( vehicle:GetFogLightsEnabled() and 1 or 0 )
            end
        },
        {
            id = 'low-beam',
            icons = {
                [ 1 ] = { 
                    url = 'https://i.imgur.com/ckEQdme.png',
                    color = Color( 51, 255, 0)
                },
                [ 2 ] = { 
                    url = 'https://i.imgur.com/DKVPVJd.png',
                    color = Color( 0, 38, 255)
                },
            },
            getState = function( vehicle )
                if ( vehicle:GetLightsEnabled() ) then
                    if ( vehicle:GetLampsEnabled() ) then
                        return 2
                    else
                        return 1
                    end
                else
                    return 0
                end
            end
        },
    }
}

local VehicleMods = {}

VehicleMods[ 'simfphys' ] = {
    verify = function( vehicle )
        if ( simfphys and simfphys.IsCar( vehicle ) ) then
            if ( cvars.Bool( 'cl_simfphys_hud' ) ) then RunConsoleCommand( 'cl_simfphys_hud', 0 ) end -- we cannot just turn block their hook, because there are things beside hud (for example turn signal controls :\)
            return true
        end

        return false
    end,
    hasFuel = function()
        return cvars.Bool( 'sv_simfphys_fuel' )
    end,
    getFuel = function( vehicle )
        return vehicle:GetFuel(), vehicle:GetMaxFuel()
    end,
    icons = STATUS_ICONS[ 'simfphys' ]
}

VehicleMods[ 'svmod' ] = {
    verify = function( vehicle )
        return ( SVMOD and SVMOD:IsVehicle( vehicle ) )
    end,
    hasFuel = function()
        return true -- no way to check, variable is server-side
    end,
    getFuel = function( vehicle )
        return vehicle:SV_GetFuel(), vehicle:SV_GetMaxFuel()
    end,
    icons = {
        {
            id = 'blinker-left',
            blinking = true,
            icons = { { url = 'https://i.imgur.com/F7qUV0j.png', color = Color( 157, 255, 0), rotation = 180 } },
            getState = function( vehicle )
                local states = ( vehicle.SV_States or {} )
                return ( ( states.LeftBlinkers or states.HazardLights ) and 1 or 0 )
            end
        },
        {
            id = 'blinker-right',
            blinking = true,
            icons = { { url = 'https://i.imgur.com/F7qUV0j.png', color = Color( 157, 255, 0) } },
            getState = function( vehicle )
                local states = ( vehicle.SV_States or {} )
                return ( ( states.RightBlinkers or states.HazardLights ) and 1 or 0 )
            end
        },
        {
            id = 'low-beam',
            icons = { { 
                url = 'https://i.imgur.com/ckEQdme.png',
                color = Color( 51, 255, 0)
            } },
            getState = function( vehicle )
                local states = vehicle.SV_States or {}
                if ( states.Headlights ) then
                    return 1
                else
                    return 0
                end
            end
        },
    }
}

local hud = onyx.hud
local lerpSpeed

local function drawLine( x1, y1, x2, y2, wide, color )
	local diffX, diffY = x1 - x2, y1 - y2
    local rad = math.atan2( diffX, diffY )
	local rotation = math.deg( rad )
    local height = Vector( x1, y1 ):Distance( Vector( x2, y2 ) )
	
	x1 = x1 - math.floor( diffX * .5 )
	y1 = y1 - math.floor( diffY * .5 )
	
	draw.NoTexture()
    surface.SetDrawColor( color )
	surface.DrawTexturedRectRotated( x1, y1, wide, height, rotation )
end

local function convertToMPH( kmh )
    return kmh * 0.621371
end

local function getMaxSpeed( vehicle, useMPH )
    local maxSpeed = vehicle.GetMaxSpeed and vehicle:GetMaxSpeed() or hud:GetOptionValue( 'speedometer_max_speed' )
    if ( ( maxSpeed / 10 ) % 2 ~= 0 ) then maxSpeed = maxSpeed + 10 end

    local clampedSpeed = math.min( maxSpeed, 300 )

    if ( useMPH ) then
        return math.floor( convertToMPH( clampedSpeed ) / 10 ) * 10
    else
        return clampedSpeed
    end
end

local function drawFuelHUD( element, client, vehicle, scrW, scrH, theme, vehicleModTable )
    local curFuel, maxFuel = vehicleModTable.getFuel( vehicle )
	local fuel = curFuel / maxFuel

    local w = hud.ScaleWide( 200 )
    local h = hud.ScaleTall( 40 )
    local x0 = scrW * .5
    local x = x0 - w * .5
    local y = scrH - h - hud.GetScreenPadding()
    local colors = theme.colors

    local horPadding = hud.ScaleTall( 10 )
    local verPadding = hud.ScaleTall( 7.5 )
    local lineW = w - horPadding * 2
    local lineH = hud.ScaleTall( 5 )
    local lineX = x + horPadding
    local lineY = y + h - lineH - verPadding
    local textY = y + verPadding * .5

    hud.DrawRoundedBox( x, y, w, h, colors.primary )
    hud.DrawRoundedBox( lineX, lineY, lineW, lineH, colors.textTertiary  )

    draw.SimpleText( onyx.lang:Get( 'fuel' ), hud.fonts.TinyBold, x + horPadding, textY, colors.textPrimary, 0, 0 )

    local textW = draw.SimpleText( ' / ' .. maxFuel, hud.fonts.Tiny, x + w - horPadding, textY, colors.textSecondary, 2, 0 )
    draw.SimpleText( math.Round( curFuel, 1 ), hud.fonts.TinyBold, x + w - horPadding - textW, textY, COLOR_FUEL, 2, 0 )

    render.SetScissorRect( lineX, lineY, lineX + lineW * fuel, lineY + lineH, true )
        hud.DrawRoundedBox( lineX, lineY, lineW, lineH, COLOR_FUEL  )
    render.SetScissorRect( 0, 0, 0, 0, false )
end

local function drawVehicleHUD( element, client, scrW, scrH )
    local cache = element.cache
    local vehicle = client:GetVehicle()
    if ( not IsValid( vehicle ) ) then return end

    local parent = vehicle:GetParent()
    if ( IsValid( parent ) ) then
        vehicle = parent
    elseif ( vehicle:GetClass() == 'prop_vehicle_prisoner_pod' ) then
        return
    end

    if ( vehicle.GetDriver == nil ) then return end
    if ( vehicle:GetDriver() ~= client ) then return end

    local vehicleModTable
    for modID, modTable in pairs( VehicleMods ) do
        if ( modTable.verify( vehicle ) ) then
            vehicleModTable = modTable
            break
        end
    end

    local isAdvanced = vehicleModTable ~= nil

    local size = hud.ScaleTall( 250 )
    local screenPadding = hud.GetScreenPadding()
    local x, y = scrW - size - screenPadding, scrH - size - screenPadding
    local x0, y0 = x + size * .5, y + size * .5

    local theme = hud:GetCurrentTheme()
    local colors = theme.colors

    local outerRadius = math.floor( size * .5 )
    local innerRadius = math.floor( outerRadius * .9 )
    local arcLength = 270

    cache.outerMask = cache.outerMask or onyx.CalculateCircle( x0, y0, outerRadius + 1, 24 )
    cache.innerMask = cache.innerMask or onyx.CalculateArc( x0, y0, 180 + 45, arcLength, outerRadius + 1, 24, true )

    local outerMask = cache.outerMask
    local innerMask = cache.innerMask

    local speed = vehicle:GetVelocity():Length()
    local useMPH = hud:GetOptionValue( 'speedometer_mph' )
    local maxSpeed = getMaxSpeed( vehicle, useMPH )

    local dividers = math.floor( maxSpeed / ( useMPH and 10 or 20 ) )

    local rawSpeed = speed * .09141 * .75
    if ( useMPH ) then rawSpeed = convertToMPH( rawSpeed ) end

	local converted = math.min( maxSpeed, rawSpeed )

    lerpSpeed = Lerp( FrameTime() * 8, lerpSpeed or converted, converted )

    local circFraction = lerpSpeed / maxSpeed
    local colorLine = onyx.LerpColor( circFraction, COLOR_GREEN, COLOR_RED )

    -- Draw blur
    if ( CONVAR_BLUR:GetBool() ) then
        onyx.DrawWithPolyMask( outerMask, function()
            onyx.DrawBlurExpensive( vgui.GetWorldPanel(), 6 )
        end )
    end

    -- Draw background
    onyx.DrawCircle( x0, y0, outerRadius, ColorAlpha( colors.primary, theme.dark and 200 or 100 ) )

    local _, textH = draw.SimpleText( math.Round( lerpSpeed ), hud.fonts.Speedometer, x0, y + size, colors.textPrimary, 1, 4 )
    draw.SimpleText( useMPH and 'mph' or 'km/h', hud.fonts.SmallBold, x0, y + size - textH * .8, colors.textSecondary, 1, 4 )

    -- Draw lines & numbers
    local angStep = 270 / ( dividers )
    local lineLength = hud.ScaleTall( 15 )
    local lineCircRadius = innerRadius - 1
    local lineWidth = hud.ScaleTall( 2 )

    for index = 0, dividers do
        local curAng = angStep * index + 90 + 45
        local rad = math.rad( curAng )
        local cos, sin = math.cos( rad ), math.sin( rad )
        local raw = index * math.Round( maxSpeed / dividers )
        local value = math.Round( raw )
        local textColor = ( math.floor( lerpSpeed ) > 0 and lerpSpeed >= value ) and colorLine or colors.textSecondary
    
        drawLine( x0 + cos * lineCircRadius, y0 + sin * lineCircRadius, x0 + cos * ( lineCircRadius - lineLength ), y0 + sin * ( lineCircRadius - lineLength ), lineWidth, textColor )

        draw.SimpleText( value, hud.fonts.SmallBold, x0 + cos * innerRadius * .75 + 1, y0 + sin * innerRadius * .75 + 1, COLOR_SHADOW, 1, 1 )
        draw.SimpleText( value, hud.fonts.SmallBold, x0 + cos * innerRadius * .75, y0 + sin * innerRadius * .75, textColor, 1, 1 )
    end

    -- Draw line background
    onyx.DrawWithPolyMask( innerMask, function()
        onyx.DrawOutlinedCircle( x0, y0, innerRadius, 1, colors.textSecondary )
    end )

    -- Draw line fill
    local innerMaskFill = onyx.CalculateArc( x0, y0, 180 + 45, arcLength * circFraction, innerRadius, 24, true )

    onyx.DrawWithPolyMask( innerMaskFill, function()
        onyx.DrawOutlinedCircle( x0, y0, innerRadius, 2, colorLine )
    end )

    -- Draw additional info ( simfphys )
    if ( isAdvanced ) then
        local statusTable = vehicleModTable.icons

        -- it is replicated
        if ( vehicleModTable.hasFuel( vehicle ) ) then
            drawFuelHUD( element, client, vehicle, scrW, scrH, theme, vehicleModTable )
        end

        if ( LVS and LVS.HudEditorsHide ) then
            LVS.HudEditorsHide[ 'VehicleHealth' ] = true
        end

        if ( statusTable ) then
            local iconSize = hud.ScaleTall( 20 )
            local iconSpace = hud.ScaleTall( 10 )
            local amount = #statusTable
            local totalW = iconSize * 2 + iconSpace
            local totalH = iconSize * 2 + iconSpace
            local row = 0
            local column = 0

            for index, status in ipairs( statusTable ) do
                local state = status.getState( vehicle )
                local icon = status.icons[ state ] or status.icons[ 1 ]
                local url = icon.url or status.icons[ 1 ].url
                local color = state == 0 and colors.textSecondary or icon.color

                if ( status.blinking and state == 1 ) then
                    color = ColorAlpha( color, 255 * math.abs( math.sin( CurTime() * 5 ) ) )
                end

                column = column + 1

                icon.wimg = icon.wimg or onyx.wimg.Simple( url, 'smooth mips' )

                icon.wimg:DrawRotated( x0 - totalW * .5 + ( column - 1 ) * ( iconSize + iconSpace ) + iconSize * .5, y0 - totalW * .5 + row * ( iconSize + iconSpace ) + iconSize * .5, iconSize, iconSize, icon.rotation or 0, color )

                if ( column >= 2 ) then
                    row = row + 1
                    column = 0
                end
            end

        end
    
    end
end

onyx.hud:RegisterElement( 'vehicle', { 
    drawFn = drawVehicleHUD, 
    priority = 40,
    initFunc = function( element )
        element.cache = {}
    end,
    onSizeChanged = function( element )
        element.cache = {}
    end
} )
--PATH addons/____onyx_hud/lua/onyx/modules/hud/elements/cl_weapon_selector.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

local SHOW_DURATION = 1.5
local MAX_SLOTS = 6
local CONVAR_SOUNDS = CreateClientConVar( 'cl_onyx_hud_wpnsel_sounds', '1', true, false, '', 0, 1 )

local hud = onyx.hud
local toggleFraction = 0
local toggleState = false
local slotsCache = {}
local selectorData = {
    selectedSlot = 1,
    selectedPos = 0,
    activeWeapon = NULL
}

local quickSwitchEnabled = GetConVar( 'hud_fastswitch' ):GetBool()

cvars.AddChangeCallback( 'hud_fastswitch', function(cname, old, new)
    quickSwitchEnabled = tobool( new )
end, 'onyx.hud' )

local function resetSlotsCache()
    slotsCache = {}
    for index = 1, MAX_SLOTS do
        slotsCache[ index ] = {}
    end
end

local function toggleWeaponSelector( state, bScroll )
    local oldState = toggleState
    
    toggleState = state

    if ( not state ) then
        toggleFraction = 0
        timer.Remove( 'onyx.hud.HideWeaponSelector' )
    else
        timer.Create( 'onyx.hud.HideWeaponSelector', SHOW_DURATION, 1, function()
            toggleWeaponSelector( false )
        end )

        if ( bScroll and not oldState and toggleFraction == 0 ) then
            local activeWeapon = selectorData.activeWeapon
            for slotIndex, slotWeapons in ipairs( slotsCache ) do
                for pos, weapon in ipairs( slotWeapons ) do
                    if ( weapon == activeWeapon ) then
                        selectorData.selectedSlot = slotIndex
                        selectorData.selectedPos = pos
                        break
                    end
                end
            end
        end
    end
end

local function drawWeaponSelector( client, scrW, scrH )
    toggleFraction = math.Approach( toggleFraction, toggleState and 1 or 0, FrameTime() * 8 )
    if ( toggleFraction <= 0 ) then return end 

    local prevAlpha = surface.GetAlphaMultiplier()
    local screenPadding = onyx.hud.GetScreenPadding()

    local activeSlots, emptySlots = 0, 0
    for _, cachedWeapons in ipairs( slotsCache ) do
        if ( #cachedWeapons > 0 ) then
            activeSlots = activeSlots + 1
        else
            emptySlots = emptySlots + 1
        end
    end

    local slotSpace = onyx.hud.ScaleTall( 3 )
    local baseSlotH = onyx.hud.ScaleTall( 27.5 )
    local slotActiveW = onyx.hud.ScaleWide( 150 )
    local slotEmptyW = baseSlotH

    local totalW = slotSpace * ( MAX_SLOTS - 1) + activeSlots * slotActiveW + emptySlots * slotEmptyW

    local theme = hud:GetCurrentTheme()
    local colors = theme.colors
    local colorPrimary = colors.primary
    local colorSecondary = colors.secondary
    local colorTertiary = colors.tertiary
    local colorAccent = colors.accent
    local colorPrimaryText = colors.textPrimary
    local colorSecondaryText = colors.textSecondary
    local colorTertiaryText = colors.textTertiary
    local isDark = theme.dark

    local y = screenPadding
    local x = scrW * .5 - totalW * .5
    
    surface.SetAlphaMultiplier( toggleFraction )

    for slotIndex = 1, MAX_SLOTS do
        local slotWeapons = slotsCache[ slotIndex ]
        if ( not slotWeapons ) then break end

        local amount = #slotWeapons
        local isEmpty = amount == 0
        local isSlotSelected = selectorData.selectedSlot == slotIndex
        local slotW = isEmpty and slotEmptyW or slotActiveW
        local slotY = y

        hud.DrawRoundedBox( x, slotY, slotW, baseSlotH, isEmpty and colorPrimary or colorSecondary )
        draw.SimpleText( slotIndex, onyx.hud.fonts.SmallBold, x + slotW * .5, slotY + baseSlotH * .5, isEmpty and colorTertiaryText or colorSecondaryText, 1, 1 )

        slotY = slotY + baseSlotH + slotSpace

        if ( not isEmpty ) then
            for index = 1, amount do
                local wep = slotWeapons[ index ]
                if ( IsValid( wep ) ) then
                    local wepName = wep:GetPrintName()
                    local isSelected = isSlotSelected and ( index == selectorData.selectedPos )
                    local isActive = selectorData.activeWeapon == wep
                    local textColor = isSelected and ( isDark and colorAccent or onyx.LerpColor( .5, colorAccent, colorPrimaryText ) ) or ( isActive and colorPrimaryText or colorSecondaryText)
                    local slotH = isSelected and baseSlotH * 1.33 or baseSlotH
                    local slotFont = onyx.hud.fonts.TinyBold

                    if ( isSelected ) then
                        hud.DrawRoundedBox( x, slotY, slotW, slotH, colorAccent )
                        hud.DrawRoundedBox( x + 1, slotY + 1, slotW - 2, slotH - 2, colorPrimary )
                        hud.DrawRoundedBox( x + 1, slotY + 1, slotW - 2, slotH - 2, ColorAlpha( colorAccent, isDark and 5 or 150 ) )
                    else
                        hud.DrawRoundedBox( x, slotY, slotW, slotH, colorPrimary )
                    end
                    
                    -- This guarantee that weapon's name won't render outside slot's bounds
                    render.SetScissorRect( x, slotY, x + slotW, slotY + slotH, true )
                        draw.SimpleText( wepName, slotFont, x + slotW * .5, slotY + slotH * .5, textColor, 1, 1 )
                    render.SetScissorRect( 0, 0, 0, 0, false )

                    slotY = slotY + slotH + slotSpace
                end
            end
        end

        x = x + slotW + slotSpace
    end

    surface.SetAlphaMultiplier( prevAlpha )
end

local playSelectSound do
    local soundStation
    function playSelectSound()
        if ( not CONVAR_SOUNDS:GetBool() ) then return end

        soundStation = soundStation or CreateSound( LocalPlayer(), 'common/wpn_moveselect.wav' )
    
        if ( soundStation:IsPlaying() ) then
            soundStation:Stop()
        end
    
        soundStation:PlayEx( .5, 100 )
    end
end

do
    local binds = {}
    for index = 1, MAX_SLOTS do
        binds[ ( 'slot' .. index ) ] = index
    end

    local lastWeapon = NULL

    local function selectWeapon()
        local data = selectorData
        local slotWeapons = slotsCache[ data.selectedSlot ]
    
        if ( slotWeapons ) then
            local weapon = slotWeapons[ data.selectedPos ]
            if ( IsValid( weapon ) ) then
                lastWeapon = LocalPlayer():GetActiveWeapon()
                input.SelectWeapon( weapon )
                toggleWeaponSelector( false )
            end
        end
    end

    local function cycleWeapons( slot )
        local data = selectorData
        local wasActive = toggleState
        local prevSlot = data.selectedSlot
        
        toggleWeaponSelector( true )
        playSelectSound()

        if ( not wasActive and prevSlot == slot and not quickSwitchEnabled ) then return end

        local slotData = slotsCache[ slot ]
        local pos = data.selectedPos or 0
        local weaponsAmount = #slotData

        if ( prevSlot ~= slot ) then
            pos = 0
        end
        
        data.selectedSlot = slot
        data.selectedPos = pos + 1

        if ( data.selectedPos > weaponsAmount ) then
            data.selectedPos = 1
        end

        if ( quickSwitchEnabled ) then
            selectWeapon()
        end
    end

    local function scrollWeapons( delta )
        toggleWeaponSelector( true, true )
        playSelectSound()

        local data = selectorData
        local slot = data.selectedSlot or 1
        local slotData = slotsCache[ slot ]
        local pos = data.selectedPos or 0
        local weaponsAmount = #slotData

        data.selectedPos = pos + delta

        local bNext = data.selectedPos > weaponsAmount
        local bPrev = data.selectedPos < 1

        if ( bNext or bPrev ) then
            local newSlot = data.selectedSlot
            for _ = 1, MAX_SLOTS do
                newSlot = newSlot + delta
                if ( newSlot < 1 ) then newSlot = MAX_SLOTS end 
                if ( newSlot > MAX_SLOTS ) then newSlot = 1 end

                local amount = #slotsCache[ newSlot ]

                if ( amount > 0 ) then
                    data.selectedPos = ( bPrev and amount or 1 )
                    data.selectedSlot = newSlot
                    break
                end
            end
        end

        if ( quickSwitchEnabled ) then
            selectWeapon()
        end
    end

    hook.Add( 'PlayerBindPress', 'onyx.hud.HandleBinds', function( ply, bind, pressed, code )
        local slot = binds[ bind ]

        if ( ply:InVehicle() ) then return end
        if ( vgui.CursorVisible() ) then return end -- an attempt to fix super weird customer's bug

        if ( slot ) then
            cycleWeapons( slot )
        elseif ( bind == '+attack' and not quickSwitchEnabled ) then
            if ( toggleState ) then
                selectWeapon()
                return true
            end
        elseif ( not ply:KeyDown( IN_ATTACK ) ) then
            if ( bind == 'invprev' ) then
                scrollWeapons( -1 )
            elseif ( bind == 'invnext' ) then
                scrollWeapons( 1 )
            elseif ( bind == 'lastinv' ) then
                if ( IsValid( lastWeapon ) ) then
                    local wep = ply:GetActiveWeapon()
                    input.SelectWeapon( lastWeapon )
                    lastWeapon = wep
                end
            end
        end
    end )
end

hook.Add( 'PostDrawHUD', 'onyx.hud.DrawWeaponSelector', function()
    -- cam.Start2D fixes weird font issue in this hook
    cam.Start2D()
        drawWeaponSelector( LocalPlayer(), ScrW(), ScrH() )
    cam.End2D()
end )

hook.Add( 'HUDShouldDraw', 'onyx.hud.HideWeaponSelector', function( name )
    if ( name == 'CHudWeaponSelection' ) then
        return false
    end
end )

hook.Add( 'Think', 'onyx.hud.UpdateWeaponSelector', function()
    local client = LocalPlayer()
    local weaponsList = client:GetWeapons()
    
    resetSlotsCache()

    selectorData.activeWeapon = client:GetActiveWeapon()

    for _, wep in ipairs( weaponsList ) do
        if ( IsValid( wep ) ) then
            local slotIndex = math.Clamp( wep:GetSlot() + 1, 1, MAX_SLOTS )
            local slotWeapons = slotsCache[ slotIndex ]
            assert( slotWeapons, string.format( 'invalid slot index %d', slotIndex ) )
            table.insert( slotWeapons, wep )
        end
    end

    for index, cacheList in ipairs( slotsCache ) do
        table.sort( cacheList, function( a, b )
            return a:GetSlotPos() < b:GetSlotPos()
        end )
    end
end )
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_french.lua:
--[[

Author: VeaTime
Steam Profile: https://steamcommunity.com/id/VeaTime/

07/03/2024

--]]

local LANG = {}

-- Phrases
LANG['copied_clipboard'] = 'Copier dans le presse-papier'
LANG['scoreboard_search'] = 'Recherche... (Nom/SteamID)'
LANG['you'] = 'Toi'
LANG['friend'] = 'Amie'

-- Columns
LANG['scoreboard_col_team'] = 'Team'
LANG['scoreboard_col_job'] = 'Métier'
LANG['scoreboard_col_money'] = 'Argent'
LANG['scoreboard_col_rank'] = 'Rank'
LANG['scoreboard_col_karma'] = 'Karma'
LANG['scoreboard_col_playtime'] = 'Playtime'
LANG['scoreboard_col_health'] = 'Santé'
LANG['scoreboard_col_level'] = 'Niveau'
LANG['scoreboard_col_none'] = 'Rien'
LANG['scoreboard_col_gang'] = 'Gang'
LANG['scoreboard_col_ashop_badges'] = 'Badges'

-- Name Effects
LANG['scoreboard_eff_default'] = 'Défaut'
LANG['scoreboard_eff_glow'] = 'Briller'
LANG['scoreboard_eff_rainbow'] = 'Arc en ciel'

-- Buttons
LANG['scoreboard_btn_profile'] = 'Ouvrir le profile'
LANG['scoreboard_btn_freeze'] = 'Freeze'
LANG['scoreboard_btn_goto'] = 'Goto'
LANG['scoreboard_btn_bring'] = 'Bring'
LANG['scoreboard_btn_return'] = 'Return'
LANG['scoreboard_btn_respawn'] = 'Respawn'
LANG['scoreboard_btn_slay'] = 'Slay'

-- Words
LANG['rank_id'] = 'Rank Identifier'
LANG['name'] = 'Nom'
LANG['effect'] = 'Effet'
LANG['color'] = 'Couleur'
LANG['preview'] = 'Aperçu'
LANG['creation'] = 'Creation'
LANG['save'] = 'Sauvegarder'
LANG['dead'] = 'Mort'
LANG['create_new'] = 'Créer un nouveau'
LANG['column'] = 'Colonne'

-- Settings
LANG['addon_settings_u'] = 'PARAMÈTRES'
LANG['scoreboard_ranks_u'] = 'RANKS'
LANG['scoreboard_columns_u'] = 'COLONNES'

LANG['scoreboard.title.name'] = 'Titre'
LANG['scoreboard.title.desc'] = 'Saisissez le titre'

LANG['scoreboard.group_teams.name'] = 'Group Teams'
LANG['scoreboard.group_teams.desc'] = '(DarkRP) Group teams par catégories de métier'

LANG['scoreboard.colored_players.name'] = 'Dégradé colorisé'
LANG['scoreboard.colored_players.desc'] = 'Afficher le dégradé colorisé sur la ligne du joueur'

LANG['scoreboard.blur.name'] = 'Theme Blur'
LANG['scoreboard.blur.desc'] = 'Activer le theme blur'

onyx.lang:AddPhrases('french', LANG)
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/core/ranks/cl_ranks.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/03/2024

--]]

onyx.scoreboard.nameEffects = {}

function onyx.scoreboard:RegisterNameEffect(id, func)
    table.insert(onyx.scoreboard.nameEffects, {
        id = id,
        func = func,
        name = ('scoreboard_eff_' .. id)
    })
end

function onyx.scoreboard:FindNameEffect(id)
    for index, data in ipairs(self.nameEffects) do
        if (data.id == id) then
            return data, index
        end
    end
end

do
    local fontCommon = onyx.Font('Comfortaa SemiBold@16') -- the size got dynamically changed
    local fontGlow = onyx.Font('Comfortaa SemiBold@16', 'blursize:2') -- the size got dynamically changed

    local COLOR_SHADOW = Color(0, 0, 0, 100)
    local SHADOW_DISTANCE = 2

    local ColorAlpha = ColorAlpha
    local SimpleText = draw.SimpleText

    -- Common (colorized)
    onyx.scoreboard:RegisterNameEffect('default', function(text, x, y, color, ax, ay)
        SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)
        SimpleText(text, fontCommon, x, y, color, ax, ay)
    end)

    -- Glow (colorized)
    onyx.scoreboard:RegisterNameEffect('glow', function(text, x, y, color, ax, ay)
        SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)
        SimpleText(text, fontGlow, x, y, ColorAlpha(color, 80 + 80 * math.abs(math.sin(CurTime() * 2))), ax, ay)
        SimpleText(text, fontCommon, x, y, color, ax, ay)
    end)

    -- Rainbow
    onyx.scoreboard:RegisterNameEffect('rainbow', function(text, x, y, color, ax, ay)
        local lastX = x
        local counter = 0
        local speed = CurTime() * 50

        SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)

        for _, code in utf8.codes(text) do
            local offset = counter * 5
            local color = HSVToColor((speed + offset) % 360, 1, 1)

            counter = counter + 1
            lastX = lastX + select(1, SimpleText(utf8.char(code), fontCommon, lastX, y, color, ax, ay))
        end
    end)

    -- Wavy Dual
    onyx.scoreboard:RegisterNameEffect('wavy_dual', function(text, x, y, color, ax, ay)
        local lastX = x
        local counter = 0
        local speed = CurTime() * 5

        -- draw.SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)

        for _, code in utf8.codes(text) do
            local offset = math[counter % 2 == 0 and 'cos' or 'sin'](speed)
            local fraction = math.abs(offset)
            local color1 = color
            local h, s, v = ColorToHSV(color1)
            local color2 = onyx.ColorEditHSV(color1, (h + 90) % 360)
            local color = onyx.LerpColor(fraction, color1, color2)
            local char = utf8.char(code)

            counter = counter + 1

            SimpleText(char, fontCommon, lastX + SHADOW_DISTANCE, y + offset * .05 + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)
            lastX = lastX + select(1, SimpleText(char, fontCommon, lastX, y + offset * .05, color, ax, ay))
        end
    end)

    -- Gradient
    onyx.scoreboard:RegisterNameEffect('gradient_invert', function(text, x, y, color, ax, ay, realX, realY)
        local color1 = color
        local h, s, v = ColorToHSV(color1)
        local color2 = onyx.ColorEditHSV(color1, (h + 180) % 360)

        SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)
        local textW, textH = SimpleText(text, fontCommon, x, y, color, ax, ay)

        local realYStart = realY - textH * .5

        render.SetScissorRect(realX, realYStart + textH * .65, realX + textW, realYStart + textH, true)
            SimpleText(text, fontCommon, x, y, color2, ax, ay)
        render.SetScissorRect(0, 0, 0, 0, false)
    end)

    -- Scanning
    onyx.scoreboard:RegisterNameEffect('scanning_vertical', function(text, x, y, color, ax, ay, realX, realY)
        SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)
        SimpleText(text, fontGlow, x, y, ColorAlpha(color, 30), ax, ay)
        local textW, textH = SimpleText(text, fontCommon, x, y, color_black, ax, ay)

        local realYStart = realY - textH * .5
        local animYStart = realYStart + textH * ((CurTime() * .5) % 1.5)
        local scanLineHeight = textH
        local scanLineRadius = scanLineHeight * .15

        render.SetScissorRect(realX, animYStart, realX + textW, animYStart + scanLineRadius, true)
            SimpleText(text, fontCommon, x, y, color, ax, ay)
        render.SetScissorRect(0, 0, 0, 0, false)
    end)

    onyx.scoreboard:RegisterNameEffect('scanning_horizontal', function(text, x, y, color, ax, ay, realX, realY)
        SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)
        SimpleText(text, fontGlow, x, y, ColorAlpha(color, 30), ax, ay)
        local textW, textH = SimpleText(text, fontCommon, x, y, color_black, ax, ay)

        local realYStart = realY - textH * .5
        local animXStart = realX + textW * ((CurTime() * 1) % 1.5)
        local scanLineWidth = textW
        local scanLineRadius = scanLineWidth * .1

        render.SetScissorRect(animXStart, realYStart, animXStart + scanLineRadius, realYStart + textH, true)
            SimpleText(text, fontCommon, x, y, color, ax, ay)
        render.SetScissorRect(0, 0, 0, 0, false)
    end)
end

net.Receive('onyx.scoreboard:SyncRanks', function(length)
    local rawData = net.ReadData(length)
    local parsedData = pon.decode(rawData)

    onyx.scoreboard.ranks = parsedData
    onyx.scoreboard:Print('Synchronized ranks.')

    hook.Run('onyx.scoreboard.SyncedRanks')
end)
--PATH addons/_outfitter/lua/includes/modules/coext.lua:

local Tag='coext'
if SERVER then AddCSLuaFile() end


if not co then require"co" end

local function http_wrap(ok,err,okerr,...)
	if okerr==ok then
		return true,...
	elseif okerr==err then
		return false,...
	else
		error"Invalid fetch callback called"
	end
end

function co.post(url,data,hdr)
	
	local ok,err = co.newcb(),co.newcb()
	http.Post(url,data,ok,err,hdr)
	
	return http_wrap(ok,err,co.waitone())

end

function co.fetch(url,hdr)
	
	local ok,err = co.newcb(),co.newcb()
	http.Fetch(url,ok,err,hdr)
	
	return http_wrap(ok,err,co.waitone())

end


co.PlayURL=function(url,params)
	local cb=co.newcb()
	sound.PlayURL(url,params or '',cb)
	return co.waitcb(cb)
end

co.PlayFile=function(url,params)
	local cb=co.newcb()
	sound.PlayFile(url,params or '',cb)
	return co.waitcb(cb)
end



-- server info query
-- TODO: Validate IP
do
	local cbs={}

	local _sinfo
	local function runcbs(entry,...)
		local ip,port = entry[1],entry[2]
		local callbacks = cbs[ip] and cbs[ip][port]
		
		if not callbacks then return end
		
		cbs[ip][port]=nil
		if not next(cbs[ip]) then
			cbs[ip]=nil
		end
		
		local ncallbacks = #callbacks
		for i=1,ncallbacks do
			local func = callbacks[i]
			local ok,err = xpcall(func,debug.traceback,...)
			if not ok then ErrorNoHalt(err..'\n') end
		end
	end

	local function sinfo()
		_sinfo = _sinfo or serverquery.getServerInfoWorker(function(ret,entry,err)
			--print(">",ret,entry,err)
			if ret then
				
				assert(entry,"entry missing??")
			
				runcbs(entry,entry)
				
				return
			end
			
			if ret==false then
				if entry==true then
					return -- worker started
				elseif entry==false then
					return --worker ended
				else
					-- error
					runcbs(entry,nil,err or "timeout",entry)
					
					return
					
				end
			end
		
			if err then
				ErrorNoHalt(tostring(err)..'\n')
			end
		end)
		return _sinfo
	end

	function co.serverinfo(ip,port)
		if not port then port=27015 end
		local a,b = ip:match'^(.+)%:(%d+)$'
		if b then
			ip,port = a,tonumber(b)
		end
		assert(not ip:find(":",1,true))
		assert(ip and port)
		
		local cb = co.newcb()
		
		cbs[ip] = cbs[ip] or {}
		cbs[ip][port] = cbs[ip][port] or {}
		local t = cbs[ip][port]
		t[#t+1]=cb
		
		sinfo().add_queue(ip, port)
		
		return co.waitcb(cb)
		
	end

	--co(function()
	--	print("1",co.serverinfo"195.154.166.219".name)
	--	print("2",co.serverinfo"195.154.166.219".name)
	--	print("7",co.serverinfo"46.174.53.218:27015".name)
	--	co(function()
	--		print("3",co.serverinfo"94.23.170.2".name)
	--		print("4",co.serverinfo"94.23.170.2".name)
	--	end)
	--	print("8",co.serverinfo"94.23.170.2".name)
	--end)
	--co(function()
	--	print("5",co.serverinfo"46.174.53.218:27015".name)
	--	print("6",co.serverinfo"46.174.53.218:27015".name)
	--end)
end


-- server players query
-- TODO: Validate IP
do

	local cbs={}

	local _sinfo
	local function runcbs(entry,...)
		local ip,port = entry[1],entry[2]
		local callbacks = cbs[ip] and cbs[ip][port]
		
		if not callbacks then return end
		
		cbs[ip][port]=nil
		if not next(cbs[ip]) then
			cbs[ip]=nil
		end
		
		local ncallbacks = #callbacks
		for i=1,ncallbacks do
			local func = callbacks[i]
			local ok,err = xpcall(func,debug.traceback,...)
			if not ok then ErrorNoHalt(err..'\n') end
		end
	end

	local function sinfo()
		_sinfo = _sinfo or serverquery.playerListFetcher(function(ret,entry,err)
			--print(">",ret,entry,err)
			if ret then
				
				assert(entry,"entry missing??")
			
				runcbs(entry,entry)
				
				return
			end
			
			if ret==false then
				if entry==true then
					return -- worker started
				elseif entry==false then
					return --worker ended
				else
					-- error
					runcbs(entry,nil,err or "timeout",entry)
					
					return
					
				end
			end
		
			if err then
				ErrorNoHalt(tostring(err)..'\n')
			end
		end)
		return _sinfo
	end

	function co.serverplayers(ip,port)
		if not port then port=27015 end
		local a,b = ip:match'^(.+)%:(%d+)$'
		if b then
			ip,port = a,tonumber(b)
		end
		assert(not ip:find(":",1,true))
		assert(ip and port)
		
		local cb = co.newcb()
		
		cbs[ip] = cbs[ip] or {}
		cbs[ip][port] = cbs[ip][port] or {}
		local t = cbs[ip][port]
		t[#t+1]=cb
		
		sinfo().add_queue(ip, port)
		
		return co.waitcb(cb)
		
	end

	--co(function()
	--	PrintTable(co.serverplayers"195.154.166.219")
	--end)
end

local function shuffle( t )
    local rand = math.random
    local iterations = #t
    local j
    
    for i = iterations, 2, -1 do
        j = rand(i)
        t[i], t[j] = t[j], t[i]
    end
end


function co.dns(a,b)
	local cb = co.newcb()
	b=b or 'A'
	http.ResolveDNS(a,b,cb)
	
	local ret,err = co.waitcb(cb)
	if not ret then return nil,err end
	if ret.errstr then
		return nil,ret.errstr,ret.errcode
	end
	if not ret[1] then
		return ret
	end
	
	shuffle(ret)
	for _,v in next,ret do
		if (b=='A' or b=='AAAA') and v.address then
			return v.address,ret
		elseif b=='TXT' and v.txt then
			return v.txt,ret
		elseif b~='A' and b~='AAAA' and v.address then
			return v.address,ret
		end
	end
	return true,ret
	
end
--[[
co(function()
	local ip = assert(co.dns("g1.metastruct.net"))
	PrintTable(assert(co.serverinfo(ip)))
end)
--]]








if not CLIENT then return end

function steamworks.coGetList(a,b,c,d,e,f)
	local cb = co.newcb()
	steamworks.GetList(a,b,c,d,e,f,cb)
	return co.waitcb(cb)
end


function steamworks.coFileInfo(a)
	local cb = co.newcb()
	steamworks.FileInfo(a,cb)
	return co.waitcb(cb)
end

function steamworks.coFileInfos(idlist)
	if not idlist[1] then return end
	local cb = co.newcb()
	local t = {}
	for _,id in next,idlist do
		t[id]=false
	end
	
	for id,state in next,t do
		steamworks.FileInfo(id,cb)
	end
	
	local any
	for id,state in next,t do
		local _,data = co.waitone(cb)
		if data then
			local id = data.id
			if nil == t[id] then
				print("WTF",id)
			else
				any = true
				t[id] = data
			end
			
		end
	end
	return any and t
end

function steamworks.coDownload( fileid, uncomp )
	local instant
	local path
	local cb = co.newcb()
	local function cb2(...)
		if instant==nil then
			path = ...
			instant = true
			return
		end
		return cb(...)
	end
	steamworks.Download( fileid, uncomp, cb2 )

	if instant==nil then
		instant = false
		path = co.waitcb(cb)
	end
	return path
end


function steamworks.coDownloadUGC( fileid )
	local instant
	local path,fd
	local cb = co.newcb()
	local function cb2(...)
		if instant==nil then
			path,fd = ...
			instant = true
			return
		end
		return cb(...)
	end
	steamworks.DownloadUGC( fileid, cb2 )

	if instant==nil then
		instant = false
		path,fd = co.waitcb(cb)
	end
	return path,fd
end



gameevent.Listen"player_disconnect"
local disconnected = {}
local waiters = {}

local function DoWaiters(userid,res)
	local t = waiters[userid]
	if not t then return end
	waiters[userid] = nil
	for i=1,#t do
		local callback = t[i]
		callback(res,not res and "disconnect" or nil)
	end
end

hook.Add("player_disconnect",Tag,function(t)
	local userid = t.userid
	disconnected[userid]= true
	DoWaiters(userid,false)
end)

local pl_to_userid = setmetatable({},{__mode='k'})
local function NetworkEntityCreated(pl)
	if pl:IsPlayer() then
		local userid = pl:UserID()
		pl_to_userid[pl]=userid or -1
		DoWaiters(userid,true)
	end
end

hook.Add("NetworkEntityCreated",Tag,NetworkEntityCreated)

function player.HasDisconnected(userid)
	if not isnumber(userid) then
		local usrid = pl_to_userid[pl]
		if usrid == nil then
			return nil,"invalid"
		end
		userid = usrid
	end
	assert(userid>=0)
	return disconnected[userid] or false
end

local localplayer
local OnLocalPlayer = util.OnLocalPlayer or function() end
OnLocalPlayer(function(ent)
	localplayer = ent or LocalPlayer()
end)

function co.wait_player(pl) -- or player
	
	if pl and pl:IsValid() then return true end
	
	assert(pl~=NULL)
	
	if not pl then
		if not localplayer then
			while not localplayer do
				co.waittick() -- TODO: hack
				localplayer = localplayer or (LocalPlayer():IsValid() and LocalPlayer())
			end
			pl = localplayer
			local userid = pl:UserID()
			pl_to_userid[pl]=userid
		else
			return nil,"invalidplayer"
		end
	end
	
	local userid = pl_to_userid[pl]
	if userid == nil then
		return nil,"invalid"
	end
	
	assert(userid>=0)
	
	local disconnected = player.HasDisconnected(userid)
	
	if disconnected then return false,"disconnected" end
	
	local t = waiters[userid] if t==nil then t = {} waiters[userid] = t end
	
	local cb = co.newcb()
	t[#t+1]=cb
	
	return co.waitcb(cb)
	
end

local function inv_1(a,...)
	return not a,...
end

co.waitpl = function(...)
	return inv_1(co.wait_player(...))
end


-- steam nicks fetching

local bad = '[unknown]'
local noexist = '< blank >'
local function GetPlayerName(sid64)
	local ret = steamworks.GetPlayerName(sid64)
	if ret == noexist then
		return nil,'profile'
	end
	if ret == bad then
		return nil,'request'
	end
	if not ret or ret=="" then
		return nil,'invalid'
	end
	return ret
end

function co.steamnick(sid64,timeout)
	local res,err = GetPlayerName(sid64)
	if res or (err and err ~= 'request') then return res,err end
	
	steamworks.RequestPlayerInfo(sid64)
	
	for i=0,timeout or 10,0.2 do
		local res,err = GetPlayerName(sid64)
		if res or (err and err ~= 'request') then return res,err end
		co.sleep(0.2)
	end
	return nil,'timeout'
end


function co.steamnick_promise(sid64)
	local res,err = GetPlayerName(sid64)
	if res or (err and err ~= 'request') then return function() return res,err end end
	
	steamworks.RequestPlayerInfo(sid64)
	
	return function(timeout)
		for i=0,timeout or 10,0.2 do
			local res,err = GetPlayerName(sid64)
			if res or (err and err ~= 'request') then return res,err end
			co.sleep(0.2)
		end
		return nil,'timeout'
	end
end

--[[ testing
co(function()
	local sid = LocalPlayer():SteamID64()
	local nick,err = co.steamnick(sid)
	print("me",sid,"\n\t",('%q'):format(tostring(nick)),err)
	
	local sid = tostring(os.time()%99999)
	local nick,err = co.steamnick(sid)
	print("invalidsid",sid,"\n\t",('%q'):format(tostring(nick)),err)
	local sid = '76561198599860287'
	local nick,err = co.steamnick(sid)
	print("noprofile",sid,"\n\t",('%q'):format(tostring(nick)),err)
	local sid = table.Random(player.GetHumans()):SteamID64()
	local nick,err = co.steamnick(sid)
	print("rndplayer",sid,"\n\t",('%q'):format(tostring(nick)),err)
	local sid = '76561197960287930'
	local nick,err = co.steamnick(sid)
	print("gaben",sid,"\n\t",('%q'):format(tostring(nick)),err)
	local t={}
	for i=1,4 do
		local sid = "76561".. math.random(197960265730,201356655932)
		t[i]={sid,co.steamnick_promise(sid)}
	end
	for i=1,#t do
		local sid,promise = t[i][1],t[i][2]
		print("promise"..i,sid,"\n\t",promise())
	end
end)
--]]

--PATH addons/_outfitter/lua/outfitter/cl.lua:
local Tag='outfitter'
local NTag = 'OF'

module(Tag,package.seeall)
	
	
-- Incoming new outfit
-- We dont' know if model or download_info exist
local function RESET(pl)
	pl:EnforceModel(false)
	pl.outfitter_mdl = nil
	pl.outfitter_download_info = nil
	
	hook.Run("OutfitApply",pl,"","")
	
end
local function SET(pl)
	
	local mdl,download_info = pl:OutfitInfo()
	
	if mdl and not IsEnabled() then return false,"disabled" end
	if hook.Run("PreOutfitApply",pl,mdl,download_info)==false then return false,"hook" end
	
	if DidCrash('setmdl',mdl) then
		dbge("EnforceModel","CRASH",mdl,download_info)
		return false,"crash"
	end
	
	CRITICAL("setmdl",mdl)
	local ret = pl:EnforceModel(mdl)
	CRITICAL(false)
	
	pl.outfitter_mdl = mdl
	pl.outfitter_download_info = download_info
	if not ret then
		dbge("SET FAIL?",ret,mdl,download_info)
	end
	UIOnEnforce(pl)
	
	hook.Run("OutfitApply",pl,mdl,download_info)
	
	return ret
end

function RefreshPlayers()
	for _,pl in next,player.GetAll() do
		OnPlayerVisible(pl)
	end
end

function EnableEverything()
	dbg("EnableEverything")
	RefreshPlayers()
end


local Player = FindMetaTable"Player"

------- player outfit changing --------

function Player.SetWantOutfit(pl,mdl,download_info,skin,bodygroups)
	dbg("SetWantOutfit",pl,not mdl and "unset" or ('%q'):format(tostring(mdl)),not download_info and "-" or ('%q'):format(tostring(download_info)))
	
	assert(pl and pl:IsValid())
	pl:GetModel()
	assert((mdl and download_info~=nil) or (not mdl and download_info==nil))
	assert(mdl~="")
	assert(tonumber(download_info)~=0)
	
	mdl = mdl or false
	
	pl:OutfitSetInfo(mdl,download_info,skin,bodygroups)

	local thread = pl.outfitter_co_thread
	
	assert(thread~=true)
	
	local status = thread and coroutine.status(thread)
	
	if status and status ~= "dead" then
		return
	end
	
	local status = pl.outfitter_changing
	if status then
		dbge("ChangeOutfitThread","was already changing?",pl)
	end
	
	pl.outfitter_co_thread = true
	pl.outfitter_co_thread = co(ChangeOutfitThread,pl)
end

function OnChangeOutfit(pl,...)
	
	pl:SetWantOutfit(...)
	
end

function ChangeOutfitThread(pl)
	
	pl.outfitter_changing = true
	
	co.waittick() -- detach, need to check player validity after this
	
	for i=1,8192 do
		assert(i<8000,"loop fuckup")
		
		if i>1 then
			co.sleep(.5)
		end
		
		local ok,err = co.wait_player(pl)
		if not ok then dbg("ChangeOutfitThread","ABORT",pl,"VANISH",err) return end
		
		local hash  = pl:OutfitHash()
		local ret,err = ChangeOutfitThreadWorker(pl,hash)
			
		local ok,err2 = co.wait_player(pl) -- Check for player validity
		if not ok then
			dbg("ChangeOutfitThread","ABORT",pl,"VANISH",err2)
			return
		end
		
		if not ret then
			dbg("ChangeOutfit",pl,"ChangeOutfitThreadWorker ERROR:",err or "???")
		end
		
		local newhash = pl:OutfitHash()
		if pl:OutfitCheckHash(hash) then
			if i>1 then
				dbgn(3,"ChangeOutfitThread","finished changing after",i,"iterations",pl)
			end
			break
		end
	end
	pl.outfitter_changing = false
	
end
local function HBAD(pl,hash)
	local ok = pl:OutfitCheckHash(hash)
	return not ok
end
-- DoChangeOutfit: NO callback. NOT to be called from coroutine.

--TODO: change to iterative to fix shit
function ChangeOutfitThreadWorker(pl,hash)
	
	assert(pl:OutfitCheckHash(hash))
	assert(not HBAD(pl,hash))
	
	local mdl,download_info,skin,bodygroups = pl:OutfitInfo()
	mdl = mdl or false

	dbg("ChangeOutfit","BEGIN",pl,mdl or "unset",download_info)
	
	-- 1. Check whether we just want to reset
	if not mdl then RESET(pl) return true end
	
	-- 2. If model exists then just apply it
	local exists = HasMDL(mdl)
	if exists then
		
		local ret = hook.Run("CanOutfit",pl,pl:OutfitInfo())
		if ret == false then
			return false,"canoutfit"
		end
		
		if HBAD(pl,hash) then return false,"outdated" end
		
		local ok,err = SET(pl,mdl,download_info,skin,bodygroups)
		if not ok and IsEnabled() then
			dbge("DoChangeOutfit","Setting model failed, but file.Existed",err,mdl)
		end
		
		return true
	end
	
	------------ TIME PASSES ONLY HERE -------------
	local ok, err = AcquireAssets(download_info,pl,mdl)
	if not ok then
		dbg("DoChangeOutfit","NeedWS failed",err,"continuing...",pl,mdl,download_info)
		if err == 'oversize' then
			coUIOversizeMsg(pl,download_info)				
		end
	end
	
	local ok,err = co.wait_player(pl) -- so check for player validity
	if not ok then
		dbg("ChangeOutfit","ABORT",pl,"VANISH",err)
		return false,"noplayer"
	end
	------------------------------------------------
	
	-- 3. Time passed, we may need to abort if some new outfit is waiting
	if HBAD(pl,hash) then return false,"outdated" end
	
	-- 4. if model doesnt exist then screw it
	if not HasMDL(mdl) then
		dbg("DoChangeOutfit","HasMDL()=false",pl,mdl,download_info)
		RESET(pl)
		return false,"mdl"
	end
	
	-- 5. Check CanOutfit
	local ret = hook.Run("CanOutfit",pl,pl:OutfitInfo())
	if ret == false then
		return false,"canoutfit"
	end
	
	-- 6. The hook may have changed our outfit
	if HBAD(pl,hash) then return false,"outdated" end
	
	-- 7. Actually set the outfit!
	SET(pl,mdl,download_info,skin,bodygroups)
	
	dbg("ChangeOutfit","FINISHED",pl,mdl or "unset",download_info)
	
	return true
end

function AcquireAssets(download_info,pl,mdl)
	if download_info and tonumber(download_info) then
		return NeedWS(download_info,pl,mdl)
	end
	if IsHTTPURL(download_info) then
		if AllowedHTTPURL(download_info) then
			return NeedHTTPGMA(download_info,pl,mdl)
		else
			return nil,'URL not allowed: '..tostring(download_info)
		end
	end
	return nil,'invalid download_info'
end

function RemoveOutfit()
	NetworkOutfit()
	OnChangeOutfit(LocalPlayer())
end

function BroadcastMyOutfit(a)
	assert(not a)
	local mdl,download_info,s,bg = LocalPlayer():OutfitInfo()
	dbg("BroadcastMyOutfit",mdl,download_info,s,bg)
	
	NetworkOutfit(mdl,download_info)
	
	return mdl,download_info
	
end

hook.Add("PlayerSlowThink",Tag,function(pl)
	if pl:InPVS() then
		OnPlayerVisible(pl)
	end
end)
--PATH addons/_pcasino/lua/perfectcasino/config/sh_language.lua:
-- Config Menu
PerfectCasino.Translation.ConfigMenu = {}
PerfectCasino.Translation.ConfigMenu.Title = "pCasino Entity Creator"
PerfectCasino.Translation.ConfigMenu.EntityToConfig = "Entity To Config"
PerfectCasino.Translation.ConfigMenu.EntityToConfigComboBox = "Виберіть сутність!"
PerfectCasino.Translation.ConfigMenu.RewardComboBox = "Виберіть винагороду!"
PerfectCasino.Translation.ConfigMenu.SpawnEntity = "Створити сутність"
PerfectCasino.Translation.ConfigMenu.ResetButton = "Повернутися назад"
PerfectCasino.Translation.ConfigMenu.AddComboButton = "Нова комбінація"
PerfectCasino.Translation.ConfigMenu.TableHeaderChance = "Комбінація"
PerfectCasino.Translation.ConfigMenu.TableHeaderActions = "Дії"
PerfectCasino.Translation.ConfigMenu.TakeoutBonusMultiplier = "Множник бонусу на виведення:"
PerfectCasino.Translation.ConfigMenu.IsJackpot = "Чи є джекпот:"
PerfectCasino.Translation.ConfigMenu.Delete = "ВИДАЛИТИ"

-- Entities
PerfectCasino.Translation.Entities = {}
PerfectCasino.Translation.Entities["pcasino_slot_machine"] = "Основний ігровий автомат"
PerfectCasino.Translation.Entities["pcasino_roulette_table"] = "Стіл рулетки"
PerfectCasino.Translation.Entities["pcasino_mystery_wheel"] = "Загадкове колесо"
PerfectCasino.Translation.Entities["pcasino_sign_plaque"] = "Табличка з вивіскою"
PerfectCasino.Translation.Entities["pcasino_sign_stand"] = "Підставка для вивіски"
PerfectCasino.Translation.Entities["pcasino_sign_wall_logo"] = "Логотип вивіски на стіні"
PerfectCasino.Translation.Entities["pcasino_sign_interior_standing"] = "Вивіска інтер'єрна"
PerfectCasino.Translation.Entities["pcasino_sign_interior_wall"] = "Вивіска внутрішня стіна"
PerfectCasino.Translation.Entities["pcasino_chair"] = "Стілець"
PerfectCasino.Translation.Entities["pcasino_npc"] = "NPC"

-- Rewards
PerfectCasino.Translation.Rewards = {}
PerfectCasino.Translation.Rewards["nothing"] = "Нічого"
PerfectCasino.Translation.Rewards["money"] = "Гроші"
PerfectCasino.Translation.Rewards["jackpot"] = "Джекпот"
PerfectCasino.Translation.Rewards["prize_wheel"] = "Безкоштовне обертання колеса Mystery"
PerfectCasino.Translation.Rewards["weapon"] = "Зброя"
PerfectCasino.Translation.Rewards["health"] = "Здоров'я"
PerfectCasino.Translation.Rewards["armor"] = "Броня"
PerfectCasino.Translation.Rewards["kill"] = "Вбивство"
PerfectCasino.Translation.Rewards["kill"] = "Видача професії"

-- Config Options
PerfectCasino.Translation.Config = {}
PerfectCasino.Translation.Config.general = {}
PerfectCasino.Translation.Config.general.Title = "Загальні налаштування"
PerfectCasino.Translation.Config.general.Desc = "Загальні налаштування гри"
PerfectCasino.Translation.Config.general.betPeriod = "Період після першої ставки до початку гри"
PerfectCasino.Translation.Config.general.useFreeSpins = "Можливість використовувати виграні безкоштовні обертання на цьому колесі"
PerfectCasino.Translation.Config.general.rope = "Додати мотузку по краю"
PerfectCasino.Translation.Config.general.model = "Модель для демонстрації"
PerfectCasino.Translation.Config.general.spin = "Зробити так, щоб платформа оберталася"
PerfectCasino.Translation.Config.general.bow = "Симпатичний бантик зверху (це не спрацює з моделями, які мають великі поля зіткнень)"
PerfectCasino.Translation.Config.general.bowOffset = "Якщо увімкнено бантик, тут можна встановити вертикальне зміщення. (Негативне або позитивне)"
PerfectCasino.Translation.Config.general.limitUse = "Дозволити використання лише 1 машини одночасно"

PerfectCasino.Translation.Config.buySpin = {}
PerfectCasino.Translation.Config.buySpin.Title = "Налаштування купівлі обертань"
PerfectCasino.Translation.Config.buySpin.Desc = "Купівля обертань для колеса"
PerfectCasino.Translation.Config.buySpin.buy = "Можливість придбати обертання за гроші"
PerfectCasino.Translation.Config.buySpin.cost = "Якщо так, то ціна, яку коштує спін"
PerfectCasino.Translation.Config.jackpot = {}
PerfectCasino.Translation.Config.jackpot.Title = "Налаштування джекпоту"
PerfectCasino.Translation.Config.jackpot.Desc = "Налаштування джекпоту"
PerfectCasino.Translation.Config.jackpot.toggle = "Чи повинен джекпот бути виграшним?"
PerfectCasino.Translation.Config.jackpot.startValue = "Початкове значення джекпоту"
PerfectCasino.Translation.Config.jackpot.betAdd = "Відсоток ставки для додавання до джекпоту. 0.1 = 10%, 0.5 = 50%, 1 = 100% і т.д."
PerfectCasino.Translation.Config.reward = {}
PerfectCasino.Translation.Config.reward.Title = "Налаштування винагороди"
PerfectCasino.Translation.Config.reward.Desc = "Виберіть, які комбінації нагород надаються"
PerfectCasino.Translation.Config.combo = {}
PerfectCasino.Translation.Config.combo.Title = "Налаштування комбо"
PerfectCasino.Translation.Config.combo.Desc = "Створити комбо для виплат"
PerfectCasino.Translation.Config.wheel = {}
PerfectCasino.Translation.Config.wheel.Title = "Налаштування колеса"
PerfectCasino.Translation.Config.wheel.Desc = "Встановити, які винагороди даються на колесі"
PerfectCasino.Translation.Config.bet = {}
PerfectCasino.Translation.Config.bet.Title = "Налаштування ставок"
PerfectCasino.Translation.Config.bet.Desc = "Встановити ліміти ставок"
PerfectCasino.Translation.Config.bet.default = "Значення ставки за замовчуванням"
PerfectCasino.Translation.Config.bet.max = "Максимальне значення ставки"
PerfectCasino.Translation.Config.bet.min = "Мінімальне значення ставки"
PerfectCasino.Translation.Config.bet.iteration = "Збільшення ставки при натисканні стрілки"
PerfectCasino.Translation.Config.bet.betLimit = "Максимальна ставка на раунд на користувача (0 для безліміту)"
PerfectCasino.Translation.Config.chance = {}
PerfectCasino.Translation.Config.chance.Title = "Налаштування шансів"
PerfectCasino.Translation.Config.chance.Desc = "Встановіть шанси потрапляння на цей предмет. Вище значення = більше шансів"
PerfectCasino.Translation.Config.chance.Bar = "Візуалізація коефіцієнтів шансів"
PerfectCasino.Translation.Config.other = {}
PerfectCasino.Translation.Config.other.Title = "Інші налаштування"
PerfectCasino.Translation.Config.other.Desc = "Інші налаштування"
PerfectCasino.Translation.Config.turn = {}
PerfectCasino.Translation.Config.turn.Title = "Налаштування перекладу"
PerfectCasino.Translation.Config.turn.Desc = "Налаштування для кожного повороту"
PerfectCasino.Translation.Config.turn.timeout = "Кількість секунд до завершення ходу"
PerfectCasino.Translation.Config.payout = {}
PerfectCasino.Translation.Config.payout.Title = "Налаштування виплат"
PerfectCasino.Translation.Config.payout.Desc = "Налаштування виплат"
PerfectCasino.Translation.Config.payout.win = "Множник виплат за виграш"
PerfectCasino.Translation.Config.text = {}
PerfectCasino.Translation.Config.text.Title = "Налаштування тексту"
PerfectCasino.Translation.Config.text.Desc = "Налаштування тексту"
PerfectCasino.Translation.Config.text.overhead = "Текст для відображення над NPC"
PerfectCasino.Translation.Config.text.chat = "Чат-повідомлення, яке буде виводитися при взаємодії з NPC"

-- Toolgun
PerfectCasino.Translation.ToolGun = {}
PerfectCasino.Translation.ToolGun.NoEntity = "Будь ласка, спочатку налаштуйте сутність з правою кнопкою миші"
PerfectCasino.Translation.ToolGun.DeletePermissions = "FPP блокує ваші дозволи на використання інструментарію казино"
PerfectCasino.Translation.ToolGun.FPPCheck = "Перевірте, чи можете ви використовувати цю сутність за допомогою FPP!"

-- Entity Interfaces
PerfectCasino.Translation.UI = {}
PerfectCasino.Translation.UI.JackPot = "JackPot: %s"
PerfectCasino.Translation.UI.Number = "Number: %i"
PerfectCasino.Translation.UI.Start = "Start: %is"
PerfectCasino.Translation.UI.PlaceBet = "Зробити ставку"
PerfectCasino.Translation.UI.Waiting = "Очікування"
PerfectCasino.Translation.UI.DoubleDown = "Подвоїти ставку"
PerfectCasino.Translation.UI.Split = "Спліт"
PerfectCasino.Translation.UI.Hit = "Хіт"
PerfectCasino.Translation.UI.Stand = "Стояти"
PerfectCasino.Translation.UI.Bust = "%i (Bust)"
PerfectCasino.Translation.UI.CurrentHandTotalValue = "Значення руки: %s"
PerfectCasino.Translation.UI.CurrentHand = "Поточна рука: %s"
PerfectCasino.Translation.UI.SpinThatWheel = "Крути це колесо!"
PerfectCasino.Translation.UI.ReadyToPlay = "Готовий до гри!"
PerfectCasino.Translation.UI.PurchaseASpin = "Придбати обертання!"
PerfectCasino.Translation.UI.FreeSpin = "Безкоштовне обертання!"
PerfectCasino.Translation.UI.FreeSpinCount = "Безкоштовні обертання: %s"
PerfectCasino.Translation.UI.Play = "Грати: %s"
PerfectCasino.Translation.UI.LeaveSeat = "Утримуйте E, щоб залишити місце"
PerfectCasino.Translation.UI.BetLimit = "Ліміт ставки: %s"

-- Chat messages
PerfectCasino.Translation.Chat = {}
PerfectCasino.Translation.Chat.NoMoney = "У вас недостатньо коштів, щоб зробити цю ставку..."
PerfectCasino.Translation.Chat.Payout = "Ви виграли %s!"
PerfectCasino.Translation.Chat.RouletteFail = "Жодна з ваших ставок не була виплачена..."
PerfectCasino.Translation.Chat.PayoutJackpot = "Ви зірвали джекпот на суму %s!"
PerfectCasino.Translation.Chat.AlreadyPlaced = "Ви вже зробили ставку..."
PerfectCasino.Translation.Chat.BetPlaced = "Ви зробили ставку!"
PerfectCasino.Translation.Chat.HandBust = "Ваша рука розбита, ви не отримаєте виплату..."
PerfectCasino.Translation.Chat.DealerHandBust = "У дилера баст, виплата становить %s!"
PerfectCasino.Translation.Chat.HandDraw = "Ви зіграли в нічию з закладом, ваша ставка повернута вам."
PerfectCasino.Translation.Chat.HandLose = "Рука закладу побила вашу руку, ви не отримаєте виплату..."
PerfectCasino.Translation.Chat.HandWin = "Ви виграли у закладу, ваша виплата становить %s!"
PerfectCasino.Translation.Chat.SlotWheelSpin = "Ви обернули колесо і отримали %s!"
PerfectCasino.Translation.Chat.UsedFreeSpin = "Ви використали безкоштовне обертання!"
PerfectCasino.Translation.Chat.UsedPaidSpin = "Ви заплатили %s за обертання!"
PerfectCasino.Translation.Chat.BetLimit = "Ви досягли ліміту ставок для цього раунду!"
PerfectCasino.Translation.Chat.WillReachBetLimit = "Ця ставка перевищить ліміт ставки. Ви не можете поставити більше, ніж %s..."
PerfectCasino.Translation.Chat.LimitMachineUse = "Ви намагаєтеся використовувати інший автомат занадто швидко..."
PerfectCasino.Translation.Chat.LimitMachineUsedByOther = "Цим автоматом зараз користується хтось інший!"

--PATH addons/____plogs/lua/plogs/console.lua:
--[[
addons/lgos/lua/plogs/console.lua
--]]
local color_white = Color(245,245,245)

net.Receive('plogs.Console', function()
	local id 	= net.ReadString()
	local str 	= net.ReadString()

	local log = plogs.types[id]
	if log then
		MsgC(log.Color, '[' .. id .. ' | ' .. os.date('%I:%M:%S', os.time()) ..  ']', color_white, str .. '\n')
	end
end)


--PATH addons/____plogs/lua/plogs/vgui/skin.lua:
--[[
addons/lgos/lua/plogs/vgui/skin.lua
--]]
local surface 				= surface
local draw 					= draw

local SKIN 		= {}

SKIN.PrintName 	= 'pLogs'
SKIN.Author 	= 'aStonedPenguin'

if plogs.cfg.DarkUI then
	-- Not finished
	SKIN.Background 			= Color(0,0,0,170)
	SKIN.Header 				= Color(0,0,0,170)
	SKIN.Outline 				= Color(0,0,0,170)

	SKIN.Panel 					= Color(0,0,0,170)

	SKIN.Button 				= Color(0,0,0,170)
	SKIN.ButtonHovered			= Color(50,50,50,170)
	SKIN.ButtonText				= Color(255,255,255)

	SKIN.Close 					= SKIN.ButtonText
	SKIN.CloseHovered 			= Color(255,255,255)

	SKIN.TabButton 				= SKIN.Header

	SKIN.TextEntry 				= SKIN.Button
	SKIN.TextEntryOutline 		= SKIN.Outline
	SKIN.TextEntryText 			= SKIN.ButtonText
	SKIN.TextEntryHighlight 	= Color(152, 25, 29)

	SKIN.ListBackground			= SKIN.TextEntry
	SKIN.ListViewLine 			= SKIN.Button
	SKIN.ListViewLineAlt 		= SKIN.ButtonHovered
	SKIN.ListViewLineHighlight 	= SKIN.TextEntryHighlight
	SKIN.ListViewText			= SKIN.ButtonText

else

	SKIN.Background 			= Color(41,41,41,170)
	SKIN.Header 				= Color(41,41,41,170)
	SKIN.Outline 				= Color(151,151,151,175)

	SKIN.Panel 					= Color(0,0,0,170)

	SKIN.Button 				= Color(41,41,41,170)
	SKIN.ButtonHovered			= Color(151, 151, 151)

	SKIN.Close 					= Color(255,255,255)
	SKIN.CloseHovered 			= Color(152, 25, 29)

	SKIN.TabButton 				= SKIN.Header

	SKIN.TextEntry 				= SKIN.Button
	SKIN.TextEntryOutline 		= SKIN.Outline
	SKIN.TextEntryText 			= Color(255,255,255)
	SKIN.TextEntryHighlight 	= Color(152, 25, 29)

	SKIN.ListBackground			= SKIN.TextEntry
	SKIN.ListViewLine 			= SKIN.Button
	SKIN.ListViewLineAlt 		= Color(75,75,75,170)
	SKIN.ListViewLineHighlight 	= Color(151, 151, 151)
	SKIN.ListViewText			= Color(255,255,255)
	SKIN.ProgressBar 			= Color(151, 151, 151)
end

plogs.ui					= SKIN

----------------------------------------------------------------
-- Frames
----------------------------------------------------------------
function SKIN:PaintFrame(self, w, h)
	--plogs.draw.Blur(self)
	plogs.draw.OutlinedBox(0, 0, w, h, SKIN.Background, SKIN.Outline)
	plogs.draw.OutlinedBox(0, 0, w, 30, SKIN.Header, SKIN.Outline)
end

function SKIN:PaintPanel(self, w, h)
	if not (self.m_bBackground) then return end

	plogs.draw.OutlinedBox(0, 0, w, h, SKIN.Panel, SKIN.Outline)
end

function SKIN:PaintShadow() end

----------------------------------------------------------------
-- Buttons                                                     
----------------------------------------------------------------
function SKIN:PaintButton(self, w, h)
	if not (self.m_bBackground) then return end 

	plogs.draw.OutlinedBox(0, 0, w, h, self.Hovered and SKIN.ButtonHovered or SKIN.Button, SKIN.Outline)

	if not self.fontset then
		self:SetTextColor(SKIN.Close)
		self:SetFont('plogs.ui.20')
		self.fontset = true
	end
end

----------------------------------------------------------------
-- Close Button
----------------------------------------------------------------
function SKIN:PaintWindowCloseButton(panel, w, h)
	if not (panel.m_bBackground) then return end

	draw.SimpleText('x', 'plogs.ui.26', 11, 0, (self.Hovered and SKIN.CloseHovered or SKIN.Close), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP) 
end

----------------------------------------------------------------
-- Text Entry                                                 
----------------------------------------------------------------
function SKIN:PaintTextEntry(self, w, h)
	plogs.draw.OutlinedBox(0, 0, w, h, SKIN.TextEntry, SKIN.TextEntryOutline)
	
	self:DrawTextEntryText(SKIN.TextEntryText, SKIN.TextEntryHighlight, SKIN.TextEntryText)
end

----------------------------------------------------------------
-- List View                                                 
----------------------------------------------------------------
function SKIN:PaintListView(self, w, h)
	--plogs.draw.Box(0, 0, w, h, SKIN.ListBackground)
end

function SKIN:PaintListViewLine(self, w, h)
	local col = ((self:IsSelected() or self:IsHovered()) and SKIN.ListViewLineHighlight or SKIN.ListViewLine)

	plogs.draw.Box(0, 0, w, h, ((self.m_bAlt and not (self:IsSelected() or self:IsHovered())) and SKIN.ListViewLineAlt or col))

	for k, v in ipairs(self.Columns) do
		if (self:IsSelected() or self:IsHovered()) then
			
			v:SetFont('plogs.ui.18')
			v:SetTextColor(SKIN.ListViewTextHighlight)
		else
			v:SetFont('plogs.ui.16')
			v:SetTextColor(SKIN.ListViewText)
		end	
	end
end


----------------------------------------------------------------
-- Scrollbar                                                  --
----------------------------------------------------------------
function SKIN:PaintScrollBarGrip(self, w, h)
	plogs.draw.OutlinedBox(0, 0, w, h, self.Hovered and SKIN.ButtonHovered or SKIN.Button, SKIN.Outline)
end
SKIN.PaintButtonDown 	= SKIN.PaintScrollBarGrip
SKIN.PaintButtonUp 		= SKIN.PaintScrollBarGrip

function SKIN:PaintScrollPanel(self, w, h) end
function SKIN:PaintVScrollBar(self, w, h) end

----------------------------------------------------------------
-- Tabs                                                 
----------------------------------------------------------------
/*
function SKIN:PaintTabListPanel(self, w, h)
	surface.SetDrawColor(SKIN.Outline)
	surface.DrawOutlinedRect(0, 0, w, h)
end

SKIN.PaintTabPanel = SKIN.PaintTabListPanel
*/
function SKIN:PaintTabListButton(self, w, h)
	if (self.Active or self.Hovered) then
		plogs.draw.OutlinedBox(0, 0, w, h, SKIN.TabButton, SKIN.Outline)
		if self.Hovered then
			plogs.draw.Box(1, 1, 6, h - 2, SKIN.ProgressBar)
		else
			plogs.draw.Box(1, 1, 3, h - 2, SKIN.ProgressBar)
		end
	else
		plogs.draw.Outline(0, 0, w, h, SKIN.Outline)
	end
	self:SetTextColor(SKIN.Close)
end

----------------------------------------------------------------
-- ComboBox                                                 
----------------------------------------------------------------
function SKIN:PaintComboBox(self, w, h)
	if IsValid(self.Menu) and not self.Menu.SkinSet then
		self.Menu:SetSkin('pLogs')
		self.Menu.SkinSet = true
	end

	plogs.draw.OutlinedBox(0, 0, w, h, ((self.Hovered or self.Depressed or self:IsMenuOpen()) and SKIN.ButtonHovered or SKIN.Button), SKIN.Outline)
end

function SKIN:PaintComboDownArrow(self, w, h)
	surface.SetDrawColor(SKIN.ListViewLineHighlight)
	draw.NoTexture()
	surface.DrawPoly({
		{x = 0, y = w * .5},
		{x = h, y = 0},
		{x = h, y = w}
	})

end

----------------------------------------------------------------
-- DMenu                                                 
----------------------------------------------------------------
function SKIN:PaintMenu(self, w, h)
	plogs.draw.OutlinedBox(0, 0, w, h, SKIN.Button, SKIN.Outline)
end

function SKIN:PaintMenuOption(self, w, h)
	if not self.FontSet then
		self:SetFont('plogs.ui.20')
		self:SetTextInset(5, 0)
		self.FontSet = true
	end
	
	self:SetTextColor(SKIN.Close)

	plogs.draw.OutlinedBox(0, 0, w, h, SKIN.Button, SKIN.Outline)
	
	if self.m_bBackground and  (self.Hovered or self.Highlight) then
		plogs.draw.OutlinedBox(0, 0, w, h, SKIN.ButtonHovered , SKIN.Outline)
	end
end

derma.DefineSkin('pLogs', 'pLogs\'s derma skin', SKIN)



--PATH addons/____plogs/lua/plogs/vgui/frame.lua:
--[[
addons/lgos/lua/plogs/vgui/frame.lua
--]]
local PANEL = {}

function PANEL:Init()
	self.btnMaxim:Remove()
	self.btnMinim:Remove()
	
	self.lblTitle:SetText('pLogs')
	self.lblTitle:SetColor(plogs.ui.Close)
	self.lblTitle:SetFont('plogs.ui.22')
	
	self:SetSkin('pLogs')
	self:SetDraggable(true)
	self:MakePopup()

	self:SetAlpha(0)
end

function PANEL:PerformLayout()
	self.lblTitle:SizeToContents()
	self.lblTitle:SetPos(5, 3)

	self.btnClose:SetPos(self:GetWide() - 30, 0)
	self.btnClose:SetSize(30, 30)
end

vgui.Register('plogs_frame', PANEL, 'onyx.Frame')


--PATH addons/__main/lua/autorun/robert.lua:
-- OTHER
local CLIENT = CLIENT
local SERVER = SERVER
local util = util
local net = net
local bit = bit
local file = file
local hook = hook
local ScrW = ScrW
local ScrH = ScrH
local ColorAlpha = ColorAlpha
local IsValid = IsValid
local ipairs = ipairs
local draw_RoundedBox
if CLIENT then draw_RoundedBox = draw.RoundedBox end
-- OTHER
local ccc = bit.bor(8192, 128)
local cvar = CreateConVar("sv_robert_explosive_change", 0, ccc, nil, 0, 1)
local cvarw = CreateConVar("sv_robert_type", 1, ccc, nil, 1, 3)
local cvarww = CreateConVar("sv_robert_explosive_default", 1, ccc, nil, 1, 3)
local cvarwww = CreateConVar("sv_robert_sound", 1, ccc, nil, 0, 1)
function CheckRobert()
    return cvar and cvar:GetBool() or false
end

function CheckTypeWeapon()
    return cvarw and cvarw:GetInt() or 1
end

function CheckDefault()
    return cvarww and cvarww:GetInt() or 1
end

function CheckRobertSound()
    return cvarwww and cvarwww:GetBool() or false
end

if not file.Exists("robert.txt", "DATA") then file.Write("robert.txt", cvarww) end
if SERVER then
    util.AddNetworkString("Hamster_Robert")
    -- resource.AddWorkshop('2887601862')
else
    net.Receive("Hamster_Robert", function(len, ply)
        if CheckRobert() then
            if IsValid(Robert) then
                Robert:Close()
                CL:Remove()
                return
            end

            local btn = {
                {
                    name = "Default",
                    variant = 1
                },
                {
                    name = "Strong",
                    variant = 2
                },
                {
                    name = "Nuke",
                    variant = 3
                },
            }

            CL = vgui.Create("DButton")
            CL:SetSize(ScrW(), ScrH())
            CL:SetText("")
            CL.Paint = function(self, w, h) draw_RoundedBox(5, 0, 0, w, h, ColorAlpha(color_black, 100)) end
            CL.DoClick = function(self)
                self:Remove()
                Robert:Close()
            end

            Robert = vgui.Create("DFrame")
            Robert:SetTitle("")
            Robert:SetSize(250, 50)
            Robert:MakePopup()
            Robert:ShowCloseButton(false)
            Robert:SetDraggable(false)
            Robert:Center()
            Robert.Paint = function(self, w, h) draw_RoundedBox(5, 0, 0, w, h, ColorAlpha(color_black, 200)) end
            local p = 5
            for _, b in ipairs(btn) do
                local RobertB = vgui.Create("DButton", Robert)
                RobertB:SetText(b.name)
                RobertB:SetPos(10 + p, 10)
                RobertB:SetSize(60, 30)
                RobertB.DoClick = function(self)
                    CL:Remove()
                    Robert:Close()
                    file.Write("robert.txt", b.variant)
                end

                p = p + 80
            end
        else
            chat.AddText("Creator turned it off")
        end
    end)

    hook.Add("PopulateToolMenu", "CustomMenuSettings", function()
        spawnmenu.AddToolMenuOption("Utilities", "Admin", "Robert", "#Robert Menu", "", "", function(panel)
            panel:ClearControls()
            panel:Help("Here are the basic settings for Robert")
            panel:CheckBox("Ability for players to change Robert's explosion mode", "sv_robert_explosive_change")
            panel:NumSlider("Robert's type of work", "sv_robert_type", 1, 3, 0)
            panel:ControlHelp("1 - Normal mode\n2 - No Weapon mode\n3 - Infinity mode")
            panel:NumSlider("Robert's default explosion option", "sv_robert_explosive_default", 1, 3, 0)
            panel:ControlHelp("1 - Normal mode\n2 - Strong mode\n3 - Nuke mode")
            panel:CheckBox("Robert Sounds", "sv_robert_sound")
        end)
    end)
end
--PATH addons/____sam/lua/sam/libs/message_pack/sh_messagepack.lua:
if SAM_LOADED then return end
--
-- lua-MessagePack : <https://fperrad.frama.io/lua-MessagePack/>
--
local SIZEOF_NUMBER = string.pack and #string.pack('n', 0.0) or 8
local maxinteger
local mininteger
local assert = assert
local error = error
local pairs = pairs
local pcall = pcall
local setmetatable = setmetatable
local tostring = tostring
local char = string.char
local format = string.format
local floor = math.floor
local tointeger = floor
local frexp = math.frexp
local ldexp = math.ldexp
local huge = math.huge
local tconcat = table.concat
local type = sam.type
local isnumber = sam.isnumber
local _ENV = nil
local m = {}

--[[ debug only
local function hexadump (s)
	return (s:gsub('.', function (c) return format('%02X ', c:byte()) end))
end
m.hexadump = hexadump
--]]
local function argerror(caller, narg, extramsg)
	error("bad argument #" .. tostring(narg) .. " to " .. caller .. " (" .. extramsg .. ")")
end

local function typeerror(caller, narg, arg, tname)
	argerror(caller, narg, tname .. " expected, got " .. type(arg))
end

local function checktype(caller, narg, arg, tname)
	if type(arg) ~= tname then
		typeerror(caller, narg, arg, tname)
	end
end

local packers = setmetatable({}, {
	__index = function(t, k)
		if k == 1 then return end -- allows ipairs
		error("pack '" .. k .. "' is unimplemented")
	end
})

m.packers = packers

packers["nil"] = function(buffer)
	buffer[#buffer + 1] = char(0xC0) -- nil
end

packers["boolean"] = function(buffer, bool)
	if bool then
		buffer[#buffer + 1] = char(0xC3) -- true
	else
		buffer[#buffer + 1] = char(0xC2) -- false
	end
end

packers["string_compat"] = function(buffer, str)
	local n = #str

	if n <= 0x1F then
		buffer[#buffer + 1] = char(0xA0 + n) -- fixstr
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDA, floor(n / 0x100), n % 0x100) -- str16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDB, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- str32
	else
		error"overflow in pack 'string_compat'"
	end

	buffer[#buffer + 1] = str
end

packers["_string"] = function(buffer, str)
	local n = #str

	if n <= 0x1F then
		buffer[#buffer + 1] = char(0xA0 + n) -- fixstr
	elseif n <= 0xFF then
		buffer[#buffer + 1] = char(0xD9, n) -- str8
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDA, floor(n / 0x100), n % 0x100) -- str16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDB, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- str32
	else
		error("overflow in pack 'string'")
	end

	buffer[#buffer + 1] = str
end

packers["binary"] = function(buffer, str)
	local n = #str

	if n <= 0xFF then
		buffer[#buffer + 1] = char(0xC4, n) -- bin8
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xC5, floor(n / 0x100), n % 0x100) -- bin16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xC6, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- bin32
	else
		error("overflow in pack 'binary'")
	end

	buffer[#buffer + 1] = str
end

local set_string = function(str)
	if str == "string_compat" then
		packers["string"] = packers["string_compat"]
	elseif str == "string" then
		packers["string"] = packers["_string"]
	elseif str == "binary" then
		packers["string"] = packers["binary"]
	else
		argerror("set_string", 1, "invalid option '" .. str .. "'")
	end
end

m.set_string = set_string

packers["map"] = function(buffer, tbl, n)
	if n <= 0x0F then
		buffer[#buffer + 1] = char(0x80 + n) -- fixmap
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDE, floor(n / 0x100), n % 0x100) -- map16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDF, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- map32
	else
		error("overflow in pack 'map'")
	end

	for k, v in pairs(tbl) do
		packers[type(k)](buffer, k)
		packers[type(v)](buffer, v)
	end
end

packers["array"] = function(buffer, tbl, n)
	if n <= 0x0F then
		buffer[#buffer + 1] = char(0x90 + n) -- fixarray
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDC, floor(n / 0x100), n % 0x100) -- array16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDD, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- array32
	else
		error("overflow in pack 'array'")
	end

	for i = 1, n do
		local v = tbl[i]
		packers[type(v)](buffer, v)
	end
end

local set_array = function(array)
	if array == "without_hole" then
		packers["_table"] = function(buffer, tbl)
			local is_map, n, max = false, 0, 0

			for k in pairs(tbl) do
				if isnumber(k) and k > 0 then
					if k > max then
						max = k
					end
				else
					is_map = true
				end

				n = n + 1
			end

			-- there are holes
			if max ~= n then
				is_map = true
			end

			if is_map then
				packers["map"](buffer, tbl, n)
			else
				packers["array"](buffer, tbl, n)
			end
		end
	elseif array == "with_hole" then
		packers["_table"] = function(buffer, tbl)
			local is_map, n, max = false, 0, 0

			for k in pairs(tbl) do
				if isnumber(k) and k > 0 then
					if k > max then
						max = k
					end
				else
					is_map = true
				end

				n = n + 1
			end

			if is_map then
				packers["map"](buffer, tbl, n)
			else
				packers["array"](buffer, tbl, max)
			end
		end
	elseif array == "always_as_map" then
		packers["_table"] = function(buffer, tbl)
			local n = 0

			for k in pairs(tbl) do
				n = n + 1
			end

			packers["map"](buffer, tbl, n)
		end
	else
		argerror("set_array", 1, "invalid option '" .. array .. "'")
	end
end

m.set_array = set_array

packers["table"] = function(buffer, tbl)
	packers["_table"](buffer, tbl)
end

packers["unsigned"] = function(buffer, n)
	if n >= 0 then
		if n <= 0x7F then
			buffer[#buffer + 1] = char(n) -- fixnum_pos
		elseif n <= 0xFF then
			buffer[#buffer + 1] = char(0xCC, n) -- uint8
		elseif n <= 0xFFFF then
			buffer[#buffer + 1] = char(0xCD, floor(n / 0x100), n % 0x100) -- uint16
		elseif n <= 4294967295.0 then
			buffer[#buffer + 1] = char(0xCE, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- uint32
		else
			buffer[#buffer + 1] = char(0xCF, 0, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- uint64 -- only 53 bits from double
		end
	else
		if n >= -0x20 then
			buffer[#buffer + 1] = char(0x100 + n) -- fixnum_neg
		elseif n >= -0x80 then
			buffer[#buffer + 1] = char(0xD0, 0x100 + n) -- int8
		elseif n >= -0x8000 then
			n = 0x10000 + n
			buffer[#buffer + 1] = char(0xD1, floor(n / 0x100), n % 0x100) -- int16
		elseif n >= -0x80000000 then
			n = 4294967296.0 + n
			buffer[#buffer + 1] = char(0xD2, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int32
		else
			buffer[#buffer + 1] = char(0xD3, 0xFF, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int64 -- only 53 bits from double
		end
	end
end

packers["signed"] = function(buffer, n)
	if n >= 0 then
		if n <= 0x7F then
			buffer[#buffer + 1] = char(n) -- fixnum_pos
		elseif n <= 0x7FFF then
			buffer[#buffer + 1] = char(0xD1, floor(n / 0x100), n % 0x100) -- int16
		elseif n <= 0x7FFFFFFF then
			buffer[#buffer + 1] = char(0xD2, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int32
		else
			buffer[#buffer + 1] = char(0xD3, 0, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int64 -- only 53 bits from double
		end
	else
		if n >= -0x20 then
			buffer[#buffer + 1] = char(0xE0 + 0x20 + n) -- fixnum_neg
		elseif n >= -0x80 then
			buffer[#buffer + 1] = char(0xD0, 0x100 + n) -- int8
		elseif n >= -0x8000 then
			n = 0x10000 + n
			buffer[#buffer + 1] = char(0xD1, floor(n / 0x100), n % 0x100) -- int16
		elseif n >= -0x80000000 then
			n = 4294967296.0 + n
			buffer[#buffer + 1] = char(0xD2, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int32
		else
			buffer[#buffer + 1] = char(0xD3, 0xFF, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int64 -- only 53 bits from double
		end
	end
end

local set_integer = function(integer)
	if integer == "unsigned" then
		packers["integer"] = packers["unsigned"]
	elseif integer == "signed" then
		packers["integer"] = packers["signed"]
	else
		argerror("set_integer", 1, "invalid option '" .. integer .. "'")
	end
end

m.set_integer = set_integer

packers["float"] = function(buffer, n)
	local sign = 0

	if n < 0.0 then
		sign = 0x80
		n = -n
	end

	local mant, expo = frexp(n)

	if mant ~= mant then
		buffer[#buffer + 1] = char(0xCA, 0xFF, 0x88, 0x00, 0x00) -- nan
	elseif mant == huge or expo > 0x80 then
		if sign == 0 then
			buffer[#buffer + 1] = char(0xCA, 0x7F, 0x80, 0x00, 0x00) -- inf
		else
			buffer[#buffer + 1] = char(0xCA, 0xFF, 0x80, 0x00, 0x00) -- -inf
		end
	elseif (mant == 0.0 and expo == 0) or expo < -0x7E then
		buffer[#buffer + 1] = char(0xCA, sign, 0x00, 0x00, 0x00) -- zero
	else
		expo = expo + 0x7E
		mant = floor((mant * 2.0 - 1.0) * ldexp(0.5, 24))
		buffer[#buffer + 1] = char(0xCA, sign + floor(expo / 0x2), (expo % 0x2) * 0x80 + floor(mant / 0x10000), floor(mant / 0x100) % 0x100, mant % 0x100)
	end
end

packers["double"] = function(buffer, n)
	local sign = 0

	if n < 0.0 then
		sign = 0x80
		n = -n
	end

	local mant, expo = frexp(n)

	if mant ~= mant then
		buffer[#buffer + 1] = char(0xCB, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- nan
	elseif mant == huge or expo > 0x400 then
		if sign == 0 then
			buffer[#buffer + 1] = char(0xCB, 0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- inf
		else
			buffer[#buffer + 1] = char(0xCB, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- -inf
		end
	elseif (mant == 0.0 and expo == 0) or expo < -0x3FE then
		buffer[#buffer + 1] = char(0xCB, sign, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- zero
	else
		expo = expo + 0x3FE
		mant = floor((mant * 2.0 - 1.0) * ldexp(0.5, 53))
		buffer[#buffer + 1] = char(0xCB, sign + floor(expo / 0x10), (expo % 0x10) * 0x10 + floor(mant / 0x1000000000000), floor(mant / 0x10000000000) % 0x100, floor(mant / 0x100000000) % 0x100, floor(mant / 0x1000000) % 0x100, floor(mant / 0x10000) % 0x100, floor(mant / 0x100) % 0x100, mant % 0x100)
	end
end

local set_number = function(number)
	if number == "float" then
		packers["number"] = function(buffer, n)
			if floor(n) == n and n < maxinteger and n > mininteger then
				packers["integer"](buffer, n)
			else
				packers["float"](buffer, n)
			end
		end
	elseif number == "double" then
		packers["number"] = function(buffer, n)
			if floor(n) == n and n < maxinteger and n > mininteger then
				packers["integer"](buffer, n)
			else
				packers["double"](buffer, n)
			end
		end
	else
		argerror("set_number", 1, "invalid option '" .. number .. "'")
	end
end

m.set_number = set_number

for k = 0, 4 do
	local n = tointeger(2 ^ k)
	local fixext = 0xD4 + k

	packers["fixext" .. tostring(n)] = function(buffer, tag, data)
		assert(#data == n, "bad length for fixext" .. tostring(n))
		buffer[#buffer + 1] = char(fixext, tag < 0 and tag + 0x100 or tag)
		buffer[#buffer + 1] = data
	end
end

packers["ext"] = function(buffer, tag, data)
	local n = #data

	if n <= 0xFF then
		buffer[#buffer + 1] = char(0xC7, n, tag < 0 and tag + 0x100 or tag) -- ext8
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xC8, floor(n / 0x100), n % 0x100, tag < 0 and tag + 0x100 or tag) -- ext16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xC9, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100, tag < 0 and tag + 0x100 or tag) -- ext&32
	else
		error("overflow in pack 'ext'")
	end

	buffer[#buffer + 1] = data
end

function m.pack(data)
	local buffer = {}
	packers[type(data)](buffer, data)

	return tconcat(buffer)
end

local unpackers -- forward declaration

local function unpack_cursor(c)
	local s, i, j = c.s, c.i, c.j

	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end

	local val = s:byte(i)
	c.i = i + 1

	return unpackers[val](c, val)
end

m.unpack_cursor = unpack_cursor

local function unpack_str(c, n)
	local s, i, j = c.s, c.i, c.j
	local e = i + n - 1

	if e > j or n < 0 then
		c:underflow(e)
		s, i, j = c.s, c.i, c.j
		e = i + n - 1
	end

	c.i = i + n

	return s:sub(i, e)
end

local function unpack_array(c, n)
	local t = {}

	for i = 1, n do
		t[i] = unpack_cursor(c)
	end

	return t
end

local function unpack_map(c, n)
	local t = {}

	for i = 1, n do
		local k = unpack_cursor(c)
		local val = unpack_cursor(c)

		if k == nil or k ~= k then
			k = m.sentinel
		end

		if k ~= nil then
			t[k] = val
		end
	end

	return t
end

local function unpack_float(c)
	local s, i, j = c.s, c.i, c.j

	if i + 3 > j then
		c:underflow(i + 3)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4 = s:byte(i, i + 3)
	local sign = b1 > 0x7F
	local expo = (b1 % 0x80) * 0x2 + floor(b2 / 0x80)
	local mant = ((b2 % 0x80) * 0x100 + b3) * 0x100 + b4

	if sign then
		sign = -1
	else
		sign = 1
	end

	local n

	if mant == 0 and expo == 0 then
		n = sign * 0.0
	elseif expo == 0xFF then
		if mant == 0 then
			n = sign * huge
		else
			n = 0.0 / 0.0
		end
	else
		n = sign * ldexp(1.0 + mant / 0x800000, expo - 0x7F)
	end

	c.i = i + 4

	return n
end

local function unpack_double(c)
	local s, i, j = c.s, c.i, c.j

	if i + 7 > j then
		c:underflow(i + 7)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i + 7)
	local sign = b1 > 0x7F
	local expo = (b1 % 0x80) * 0x10 + floor(b2 / 0x10)
	local mant = ((((((b2 % 0x10) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8

	if sign then
		sign = -1
	else
		sign = 1
	end

	local n

	if mant == 0 and expo == 0 then
		n = sign * 0.0
	elseif expo == 0x7FF then
		if mant == 0 then
			n = sign * huge
		else
			n = 0.0 / 0.0
		end
	else
		n = sign * ldexp(1.0 + mant / 4503599627370496.0, expo - 0x3FF)
	end

	c.i = i + 8

	return n
end

local function unpack_uint8(c)
	local s, i, j = c.s, c.i, c.j

	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end

	local b1 = s:byte(i)
	c.i = i + 1

	return b1
end

local function unpack_uint16(c)
	local s, i, j = c.s, c.i, c.j

	if i + 1 > j then
		c:underflow(i + 1)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2 = s:byte(i, i + 1)
	c.i = i + 2

	return b1 * 0x100 + b2
end

local function unpack_uint32(c)
	local s, i, j = c.s, c.i, c.j

	if i + 3 > j then
		c:underflow(i + 3)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4 = s:byte(i, i + 3)
	c.i = i + 4

	return ((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4
end

local function unpack_uint64(c)
	local s, i, j = c.s, c.i, c.j

	if i + 7 > j then
		c:underflow(i + 7)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i + 7)
	c.i = i + 8

	return ((((((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
end

local function unpack_int8(c)
	local s, i, j = c.s, c.i, c.j

	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end

	local b1 = s:byte(i)
	c.i = i + 1

	if b1 < 0x80 then
		return b1
	else
		return b1 - 0x100
	end
end

local function unpack_int16(c)
	local s, i, j = c.s, c.i, c.j

	if i + 1 > j then
		c:underflow(i + 1)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2 = s:byte(i, i + 1)
	c.i = i + 2

	if b1 < 0x80 then
		return b1 * 0x100 + b2
	else
		return ((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) - 1
	end
end

local function unpack_int32(c)
	local s, i, j = c.s, c.i, c.j

	if i + 3 > j then
		c:underflow(i + 3)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4 = s:byte(i, i + 3)
	c.i = i + 4

	if b1 < 0x80 then
		return ((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4
	else
		return ((((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) * 0x100 + (b3 - 0xFF)) * 0x100 + (b4 - 0xFF)) - 1
	end
end

local function unpack_int64(c)
	local s, i, j = c.s, c.i, c.j

	if i + 7 > j then
		c:underflow(i + 7)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i + 7)
	c.i = i + 8

	if b1 < 0x80 then
		return ((((((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
	else
		return ((((((((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) * 0x100 + (b3 - 0xFF)) * 0x100 + (b4 - 0xFF)) * 0x100 + (b5 - 0xFF)) * 0x100 + (b6 - 0xFF)) * 0x100 + (b7 - 0xFF)) * 0x100 + (b8 - 0xFF)) - 1
	end
end

function m.build_ext(tag, data)
	return nil
end

local function unpack_ext(c, n, tag)
	local s, i, j = c.s, c.i, c.j
	local e = i + n - 1

	if e > j or n < 0 then
		c:underflow(e)
		s, i, j = c.s, c.i, c.j
		e = i + n - 1
	end

	c.i = i + n

	return m.build_ext(tag, s:sub(i, e))
end

local fn_1 = function(c, val) return val end
local fn_2 = function(c, val) return unpack_map(c, val % 0x10) end
local fn_3 = function(c, val) return unpack_array(c, val % 0x10) end
local fn_4 = function(c, val) return unpack_str(c, val % 0x20) end
local fn_5 = function(c, val) return val - 0x100 end

unpackers = setmetatable({
	[0xC0] = function() return nil end,
	[0xC2] = function() return false end,
	[0xC3] = function() return true end,
	[0xC4] = function(c) return unpack_str(c, unpack_uint8(c)) end, -- bin8
	[0xC5] = function(c) return unpack_str(c, unpack_uint16(c)) end, -- bin16
	[0xC6] = function(c) return unpack_str(c, unpack_uint32(c)) end, -- bin32
	[0xC7] = function(c) return unpack_ext(c, unpack_uint8(c), unpack_int8(c)) end,
	[0xC8] = function(c) return unpack_ext(c, unpack_uint16(c), unpack_int8(c)) end,
	[0xC9] = function(c) return unpack_ext(c, unpack_uint32(c), unpack_int8(c)) end,
	[0xCA] = unpack_float,
	[0xCB] = unpack_double,
	[0xCC] = unpack_uint8,
	[0xCD] = unpack_uint16,
	[0xCE] = unpack_uint32,
	[0xCF] = unpack_uint64,
	[0xD0] = unpack_int8,
	[0xD1] = unpack_int16,
	[0xD2] = unpack_int32,
	[0xD3] = unpack_int64,
	[0xD4] = function(c) return unpack_ext(c, 1, unpack_int8(c)) end,
	[0xD5] = function(c) return unpack_ext(c, 2, unpack_int8(c)) end,
	[0xD6] = function(c) return unpack_ext(c, 4, unpack_int8(c)) end,
	[0xD7] = function(c) return unpack_ext(c, 8, unpack_int8(c)) end,
	[0xD8] = function(c) return unpack_ext(c, 16, unpack_int8(c)) end,
	[0xD9] = function(c) return unpack_str(c, unpack_uint8(c)) end,
	[0xDA] = function(c) return unpack_str(c, unpack_uint16(c)) end,
	[0xDB] = function(c) return unpack_str(c, unpack_uint32(c)) end,
	[0xDC] = function(c) return unpack_array(c, unpack_uint16(c)) end,
	[0xDD] = function(c) return unpack_array(c, unpack_uint32(c)) end,
	[0xDE] = function(c) return unpack_map(c, unpack_uint16(c)) end,
	[0xDF] = function(c) return unpack_map(c, unpack_uint32(c)) end
}, {
	__index = function(t, k)
		if k < 0xC0 then
			if k < 0x80 then
				return fn_1
			elseif k < 0x90 then
				return fn_2
			elseif k < 0xA0 then
				return fn_3
			else
				return fn_4
			end
		elseif k > 0xDF then
			return fn_5
		else
			return function()
				error("unpack '" .. format("%#x", k) .. "' is unimplemented")
			end
		end
	end
})

local function cursor_string(str)
	return {
		s = str,
		i = 1,
		j = #str,
		underflow = function()
			error"missing bytes"
		end
	}
end

local function cursor_loader(ld)
	return {
		s = '',
		i = 1,
		j = 0,
		underflow = function(self, e)
			self.s = self.s:sub(self.i)
			e = e - self.i + 1
			self.i = 1
			self.j = 0

			while e > self.j do
				local chunk = ld()

				if not chunk then
					error"missing bytes"
				end

				self.s = self.s .. chunk
				self.j = #self.s
			end
		end
	}
end

function m.unpack(s)
	checktype("unpack", 1, s, "string")
	local cursor = cursor_string(s)
	local data = unpack_cursor(cursor)

	if cursor.i <= cursor.j then
		error("extra bytes")
	end

	return data
end

function m.unpacker(src)
	if type(src) == "string" then
		local cursor = cursor_string(src)

		return function()
			if cursor.i <= cursor.j then return cursor.i, unpack_cursor(cursor) end
		end
	elseif type(src) == "function" then
		local cursor = cursor_loader(src)

		return function()
			if cursor.i > cursor.j then
				pcall(cursor.underflow, cursor, cursor.i)
			end

			if cursor.i <= cursor.j then return true, unpack_cursor(cursor) end
		end
	else
		argerror("unpacker", 1, "string or function expected, got " .. type(src))
	end
end

set_string("string")
set_integer("unsigned")

if SIZEOF_NUMBER == 4 then
	maxinteger = 16777215
	mininteger = -maxinteger
	m.small_lua = true
	unpackers[0xCB] = nil -- double
	unpackers[0xCF] = nil -- uint64
	unpackers[0xD3] = nil -- int64
	set_number("float")
else
	maxinteger = 9007199254740991
	mininteger = -maxinteger
	set_number("double")

	if SIZEOF_NUMBER > 8 then
		m.long_double = true
	end
end

set_array("always_as_map")
m._VERSION = "0.5.2"
m._DESCRIPTION = "lua-MessagePack : a pure Lua implementation"
m._COPYRIGHT = "Copyright (c) 2012-2019 Francois Perrad"

return m
--
-- This library is licensed under the terms of the MIT/X11 license,
-- like Lua itself.
--

--PATH addons/____sam/lua/sam/libs/sh_promises.lua:
if SAM_LOADED then return end
-- not real promises, just really simple one

local isfunction = sam and sam.isfunction or isfunction

local null = {}

local Promise = {}

local PromiseMethods = {}
local Promise_meta = {__index = PromiseMethods}

function Promise.new()
	return setmetatable({
		value = null,
		null = null
	}, Promise_meta)
end

function Promise.IsPromise(v)
	return getmetatable(v) == Promise_meta
end

function PromiseMethods:resolve(v)
	if self.value ~= null then return end
	if self.done_callback then
		self.done_callback(v)
	else
		self.value = v
		self.callback = 0
	end
end

function PromiseMethods:reject(v)
	if self.value ~= null then return end
	if self.catch_callback then
		self.catch_callback(v)
	else
		self.value = v
		self.callback = 1
	end
end

function PromiseMethods:done(func)
	if isfunction(func) then
		if self.value ~= null and self.callback == 0 then
			func(self.value)
		else
			self.done_callback = func
		end
	end
	return self
end

function PromiseMethods:catch(func)
	if isfunction(func) then
		if self.value ~= null and self.callback == 1 then
			func(self.value)
		else
			self.catch_callback = func
		end
	end
	return self
end

return Promise
--PATH addons/____sui/lua/sui/vgui/sui_frame.lua:
local math = math
local gui = gui
local draw = draw
local surface = surface

local ScrW = ScrW
local ScrH = ScrH
local IsValid = IsValid
local ipairs = ipairs

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local FRAME_FONT = SUI.CreateFont("Frame", "Roboto", 18)

local Panel = FindMetaTable("Panel")

local PANEL = {}

AccessorFunc(PANEL, "m_bHeaderHeight", "HeaderHeight", FORCE_NUMBER)
AccessorFunc(PANEL, "m_bTitleFont", "TitleFont", FORCE_STRING)
AccessorFunc(PANEL, "m_bSizable", "Sizable", FORCE_BOOL)
AccessorFunc(PANEL, "m_iMinWidth", "MinWidth", FORCE_NUMBER)
AccessorFunc(PANEL, "m_iMinHeight", "MinHeight", FORCE_NUMBER)

local header_Think = function(s)
	local parent = s.parent
	local sw, sh = ScrW(), ScrH()

	if s.dragging then
		local x, y = input.GetCursorPos()
		x, y = math.Clamp(x, 1, sw - 1), math.Clamp(y, 1, sh - 1)
		x, y = x - s.dragging[1], y - s.dragging[2]

		parent:SetPos(x, y)
		parent:InvalidateLayout(true)
		parent:OnPosChanged()
	else
		local x, y, w, h = parent:GetBounds()
		parent:SetPos(math.Clamp(x, 5, sw - w - 5), math.Clamp(y, 5, sh - h - 5))
	end
end

local header_OnMousePressed = function(s)
	local parent = s.parent
	s.dragging = {gui.MouseX() - parent.x, gui.MouseY() - parent.y}
	s:MouseCapture(true)
end

local header_OnMouseReleased = function(s)
	s.dragging = nil
	s:MouseCapture(false)
end

local title_SetBGColor = function(s, c)
	s:SetVisible(c and true or false)
end

local title_update_color = function(s)
	s:SetTextColor(SUI.GetColor("title"))
end

local close_DoClick = function(s)
	s.frame:Remove()
end

function PANEL:Init()
	local header_buttons = {}
	self.header_buttons = header_buttons

	self:Center()
	self:SetHeaderHeight(28)

	local header = self:Add("PANEL")
	header:Dock(TOP)
	header.Paint = self.HeaderPaint
	header:SetCursor("sizeall")

	header.parent = self
	header.Think = header_Think
	header.OnMousePressed = header_OnMousePressed
	header.OnMouseReleased = header_OnMouseReleased
	self.header = header

	local title = header:Add(NAME .. ".Label")
	title:Dock(LEFT)
	title:DockMargin(6, 2, 0, 2)
	title:SetText("")
	title:SetTextColor(SUI.GetColor("title"))
	title:SizeToContents()
	title.SetBGColor = title_SetBGColor
	hook.Add(NAME .. ".ThemeChanged", title, title_update_color)
	self.title = title

	self.close = self:AddHeaderButton("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/close.png", "close", close_DoClick)
	self.close.frame = self

	self:SetSize(SUI.Scale(520), SUI.Scale(364))
	self:SetTitleFont(FRAME_FONT)
	SUI.OnScaleChanged(self, self.ScaleChanged)

	function self:PerformLayout(w, h)
		if IsValid(title) then
			title:SizeToContents()
		end

		if IsValid(header) then
			header:SetTall(SUI.Scale(self:GetHeaderHeight()))
		end

		for k, v in ipairs(header_buttons) do
			if IsValid(v) then
				v:SetWide(v:GetTall())
				local margin = SUI.Scale(4)
				v.image:DockMargin(margin, margin, margin, margin)
			end
		end
	end
end

function PANEL:SetSize(w, h)
	self.real_w, self.real_h = w, h
	self:ScaleChanged()
end

function PANEL:HeaderPaint(w, h)
	draw.RoundedBoxEx(3, 0, 0, w, h, SUI.GetColor("header"), true, true)
end

local SetSize = Panel.SetSize
PANEL.RealSetSize = SetSize
function PANEL:ScaleChanged()
	if self.sizing then return end

	local new_w, new_h = SUI.Scale(self.real_w), SUI.Scale(self.real_h)
	self.x, self.y = self.x + (self:GetWide() * 0.5 - new_w * 0.5), self.y + (self:GetTall() * 0.5 - new_h * 0.5)
	SetSize(self, new_w, new_h)
	self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
	if SUI.GetColor("frame_blur") then
		TDLib.BlurPanel(self)
	end

	self:RoundedBox("Background", 3, 0, 0, w, h, SUI.GetColor("frame"))
end

function PANEL:SetTitleFont(font)
	self.m_bTitleFont = font
	self.title:SetFont(font)
end

function PANEL:SetTitle(text)
	self.title:SetText(text)
	self.title:SizeToContents()
end

function PANEL:AddHeaderButton(image_name, name, callback)
	local button = self.header:Add("DButton")
	button:SetText("")
	button:Dock(RIGHT)
	button:DockMargin(0, 2, #self.header:GetChildren() == 1 and 4 or 2, 2)

	local hover = name .. "_hover"
	local press = name .. "_press"
	local circle = {}
	button.Paint = function(s, w, h)
		if s:IsHovered() then
			TDLib.DrawCircle(circle, w * 0.5, h * 0.5, w * 0.5, SUI.GetColor(hover))
		end

		if s.Depressed then
			TDLib.DrawCircle(circle, w * 0.5, h * 0.5, w * 0.5, SUI.GetColor(press))
		end
	end
	button.DoClick = callback

	local image = button:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetMouseInputEnabled(false)
	image:SetImage(image_name)

	button.image = image

	table.insert(self.header_buttons, button)

	return button
end

function PANEL:OnMousePressed(_, checking)
	if not self.m_bSizable then return end

	local x, y = self:LocalToScreen(0, 0)
	local w, h = self:GetSize()
	if gui.MouseX() > (x + w - 20) and gui.MouseY() > (y + h - 20) then
		if not checking then
			self.sizing = {gui.MouseX() - w, gui.MouseY() - h}
			self:MouseCapture(true)
		end

		self:SetCursor("sizenwse")

		return
	end

	if checking then
		self:SetCursor("arrow")
	end
end

function PANEL:OnMouseReleased()
	if not self.m_bSizable then return end

	self:MouseCapture(false)
	SUI.CallScaleChanged()
	self.sizing = nil
end

function PANEL:Think()
	if not self.m_bSizable then return end

	self:OnMousePressed(nil, true)

	if not self.sizing then return end

	local sw, sh = ScrW(), ScrH()

	local cx, cy = input.GetCursorPos()
	local mousex = math.Clamp(cx, 1, sw - 1)
	local mousey = math.Clamp(cy, 1, sh - 1)

	local x = mousex - self.sizing[1]
	x = math.Clamp(x, self.m_iMinWidth, sw - 10)

	local y = mousey - self.sizing[2]
	y = math.Clamp(y, self.m_iMinHeight, sh - 10)

	self.real_w, self.real_h = x, y
	SetSize(self, x, y)
	self:InvalidateLayout(true)
	self:SetCursor("sizenwse")
end

function PANEL:OnPosChanged()
end

local SetVisible = Panel.SetVisible
local Remove = Panel.Remove

local anim_speed = 0.2

local show = function(s)
	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	SetVisible(s, true)

	SetSize(s, w * 1.1, h * 1.1)
	s:Center()

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() * 0.5) - (w * 0.5), (ScrH() * 0.5) - (h * 0.5), anim_speed, 0, -1)
	s:AlphaTo(255, anim_speed + 0.02, 0)
	s:MakePopup()
end

local remove = function(s, hide)
	if not hide and not s:IsVisible() then
		Remove(s)
		return
	end

	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	w, h = w * 1.1, h * 1.1

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() * 0.5) - (w * 0.5), (ScrH() * 0.5) - (h * 0.5), anim_speed, 0, -1)
	s:SetMouseInputEnabled(false)
	s:SetKeyboardInputEnabled(false)
	s:AlphaTo(0, anim_speed + 0.02, 0, function()
		if hide then
			SetVisible(s, false)
		else
			Remove(s)
		end
	end)
end

local hide = function(s)
	remove(s, true)
end

function PANEL:AddAnimations(w, h, no_scale)
	self.anim_scale = not no_scale
	self.real_w, self.real_h = w, h

	self:SetAlpha(0)
	show(self)

	self.Remove = remove
	self.Hide = hide
	self.Show = show
end

sui.register("Frame", PANEL, "EditablePanel")
--PATH addons/____sui/lua/sui/vgui/sui_zbutton.lua:
local draw = draw
local render = render

local TDLib = sui.TDLib
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local lerp_color = sui.lerp_color
local contrast_color = sui.contrast_color

local BUTTON_FONT = SUI.CreateFont("Button", "Roboto Medium", 16)

local color_white = color_white
local color_transparent = Color(0, 0, 0, 0)

local PANEL = {}

AccessorFunc(PANEL, "m_Background", "Background")
AccessorFunc(PANEL, "m_bContained", "Contained", FORCE_BOOL)

sui.TDLib.Install(PANEL)
sui.scaling_functions(PANEL)

PANEL:ClearPaint()
PANEL:SetContained(true)

local Panel = FindMetaTable("Panel")
local SetMouseInputEnabled = Panel.SetMouseInputEnabled
local IsMouseInputEnabled = Panel.IsMouseInputEnabled
local SetCursor = Panel.SetCursor
local SetContentAlignment = Panel.SetContentAlignment
function PANEL:Init()
	self:ScaleInit()

	self.vertices, self.vertices_2 = {}, {}

	SetMouseInputEnabled(self, true)
	SetCursor(self, "hand")
	SetContentAlignment(self, 5)

	self:SetSize(90, 30)
	self:SetFont(BUTTON_FONT)

	self:CircleClick(nil, 7)

	self.OldPaint, self.Paint = self.Paint, self.Paint2

	self.cur_col = Color(0, 0, 0, 0)
end

function PANEL:SetEnabled(b)
	SetMouseInputEnabled(self, b)
end

function PANEL:IsEnabled()
	return IsMouseInputEnabled(self)
end

function PANEL:ContainedPaint(w, h)
	local enabled = self:IsEnabled()
	local col
	if enabled then
		col = self:GetBackground() or SUI.GetColor("button")
		self:SetTextColor(SUI.GetColor("button_text"))
	else
		col = SUI.GetColor("button_disabled")
		self:SetTextColor(SUI.GetColor("button_disabled_text"))
	end
	self:RoundedBox("Background", 4, 0, 0, w, h, col)

	if not enabled then return end

	self.circle_click_color = SUI.GetColor("button_click")

	if self.Hovered or self.Selected then
		self:RoundedBox("Hover", 4, 0, 0, w, h, SUI.GetColor("button_hover"))
	end
end

function PANEL:SetColors(hover_color, text_color)
	self.hover = hover_color
	self.text_color = text_color
end

function PANEL:Paint2(w, h)
	if self:GetContained() then
		self:ContainedPaint(w, h)
		self:OldPaint(w, h)
		return
	end

	render.ClearStencil()
	render.SetStencilEnable(true)

	render.SetStencilWriteMask(1)
	render.SetStencilTestMask(1)

	render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilPassOperation(STENCILOPERATION_ZERO)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
	render.SetStencilReferenceValue(1)

	TDLib.RoundedBox(self.vertices, 4, 0, 0, w, h, color_white)

	render.SetStencilFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	render.SetStencilReferenceValue(1)

	local cur_col = self.cur_col
	if self.Selected then
		lerp_color(cur_col, SUI.GetColor("button2_selected"))
	elseif self.Hovered then
		lerp_color(cur_col, self.hover or SUI.GetColor("button2_hover"))
	else
		lerp_color(cur_col, color_transparent)
	end

	TDLib.RoundedBox(self.vertices_2, 4, 0, 0, w, h, cur_col)

	if self.text_color then
		self.circle_click_color = self.text_color
		self:SetTextColor(self.text_color)
	else
		local col = contrast_color(cur_col)
		self.circle_click_color = col
		self:SetTextColor(col)
	end

	self:OldPaint(w, h)

	render.SetStencilEnable(false)
	render.ClearStencil()
end

sui.register("Button", PANEL, NAME .. ".Label")
--PATH addons/____sui/lua/sui/vgui/sui_zmenu.lua:
local BSHADOWS = sui.BSHADOWS
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local RoundedBox = sui.TDLib.LibClasses.RoundedBox
local TextColor = sui.TDLib.LibClasses.TextColor

local OPTION_FONT = SUI.CreateFont("MenuOption", "Roboto Medium", 15, 500)

local PANEL = {}

AccessorFunc(PANEL, "m_bIsMenuComponent", "IsMenu")
AccessorFunc(PANEL, "m_bDeleteSelf", "DeleteSelf")
AccessorFunc(PANEL, "m_iMinimumWidth", "MinimumWidth")
AccessorFunc(PANEL, "m_SetInternal", "Internal")

PANEL:SetIsMenu(true)
PANEL:SetDeleteSelf(true)

local pad = 4
local max_height = 300

local PerformLayout = function(s)
	local w, h = s:ChildrenSize()
	if h > SUI.Scale(max_height) then
		h = SUI.Scale(max_height)
	end
	s:SetSize(math.max(s:GetMinimumWidth(), w), h)
end

function PANEL:Init()
	self:GetCanvas():DockPadding(0, pad, 0, pad)
	self:SetMinimumWidth(SUI.Scale(100))
	self:SetKeyboardInputEnabled(false)
	self:SetTall(pad * 2)
	self:SetAlpha(0)
	self.tall = pad * 2
	RegisterDermaMenuForClose(self)
	self:On("PerformLayoutInternal", PerformLayout)
end

function PANEL:Paint(w, h)
	local x, y = self:LocalToScreen()

	BSHADOWS.BeginShadow()
		self:RoundedBox("Background", pad, x, y, w, h, GetColor("menu"))
	BSHADOWS.EndShadow(1, 3, 3)

	self:MoveToFront()
end

function PANEL:Open(x, y)
	self:SizeToChildren(true, false)

	local w, h = self:GetSize()
	if h > SUI.Scale(max_height) then
		h = SUI.Scale(max_height)
	end

	local internal = self:GetInternal()
	internal:On("OnRemove", function()
		self:Remove()
	end)
	if not x then
		x, y = internal:LocalToScreen(0, 0)
		y = y + (internal:GetTall() + 2)
	end

	if y + h > ScrH() then
		y = y - h
	end

	if x + w > ScrW() then
		x = x - w
	end

	if y < 1 then
		y = 1
	end

	if x < 1 then
		x = 1
	end

	self:SetPos(x, y)
	self:MakePopup()
	self:AlphaTo(255, 0.23)
	self:SetDrawOnTop(true)
	self:MoveToFront()
end

local option_OnMouseReleased = function(s, mousecode)
	if s.Depressed and mousecode == MOUSE_LEFT then
		CloseDermaMenus()
	end
	DButton.OnMouseReleased(s, mousecode)
end

function PANEL:AddOption(str, callback)
	local option = self:Add("DButton")
	option:Dock(TOP)
	option:SetFont(OPTION_FONT)
	option:SetText(str)
	option:SizeToContentsX(20)
	option:SizeToContentsY(10)
	option:InvalidateLayout(true)
	option.OnMouseReleased = option_OnMouseReleased

	function option:Paint(w, h)
		RoundedBox(self, "Background", 0, 0, 0, w, h, self.Hovered and GetColor("menu_option_hover") or GetColor("menu_option"))
		TextColor(self, self.Hovered and GetColor("menu_option_hover_text") or GetColor("menu_option_text"))
	end

	option.DoClick = callback

	self.tall = self.tall + option:GetTall()
	self:SetTall(self.tall)

	return option
end

function PANEL:AddSpacer()
	local spacer = self:Add("Panel")
	spacer:Dock(TOP)
	spacer:DockMargin(0, 1, 0, 1)
	spacer:SetTall(2)

	function spacer:Paint(w, h)
		RoundedBox(self, "Background", 0, 0, 0, w, h, GetColor("menu_spacer"))
	end

	spacer:InvalidateLayout(true)
end

sui.register("Menu", PANEL, NAME .. ".ScrollPanel")
--PATH addons/____sam/lua/sam/modules/murder.lua:
if SAM_LOADED then return end

local add = not GAMEMODE and hook.Add or function(_, _, fn)
	fn()
end

-- Thanks to https://github.com/boxama/addons/blob/master/addons/ULX_Murder/lua/ulx/modules/sh/murder.lua
add("PostGamemodeLoaded", "SAM.Murder", function()
	if GAMEMODE.Author ~= "MechanicalMind" then return end
	if not isstring(GAMEMODE.Version) or GAMEMODE.Version < "28" then return end

	local sam, command = sam, sam.command

	command.set_category("Murder")

	local autoslain_players = {}

	command.new("slaynr")
		:SetPermission("slaynr", "admin")

		:AddArg("player")
		:AddArg("number", {hint = "rounds", optional = true, default = 1, min = 1, max = 100, round = true})

		:Help("Slays the target(s) at the beggining of the next round.")

		:OnExecute(function(ply, targets, rounds)
			for i = 1, #targets do
				local v = targets[i]
				v.MurdererChance = 0

				if not v:IsBot() then
					autoslain_players[v:AccountID()] = rounds
				end
			end

			sam.player.send_message(nil, "{A} set {T} to be autoslain for {V} round(s)", {
				A = ply, T = targets, V = rounds
			})
		end)
	:End()

	command.new("unslaynr")
		:SetPermission("unslaynr", "admin")

		:AddArg("player")

		:Help("Remove target(s) autoslays.")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				local v = targets[i]
				v.MurdererChance = 1

				if not v:IsBot() then
					autoslain_players[v:AccountID()] = nil
				end
			end

			sam.player.send_message(nil, "Removed all autoslays for {T} ", {
				A = ply, T = targets
			})
		end)
	:End()

	hook.Add("OnStartRound", "SAM.Murder", function()
		timer.Simple(3, function()
			local players = team.GetPlayers(2)
			local targets = {admin = sam.console}
			for i = 1, #players do
				local v = players[i]
				if not v:IsBot() then continue end

				local slays = autoslain_players[v:AccountID()]
				if not slays then continue end

				v:Kill()

				slays = slays - 1

				targets[1] = v
				sam.player.send_message(nil, "{A} autoslayed {T}, autoslays left: {V}.", {
					A = sam.console, T = targets, V = slays
				})

				autoslain_players[v:AccountID()] = slays > 0 and slays or nil
			end
		end)
	end)

	hook.Add("PlayerInitialSpawn", "SAM.Murder", function(ply)
		if autoslain_players[ply:AccountID()] then
			ply.MurdererChance = 0
		end
	end)

	command.new("respawn")
		:SetPermission("respawn", "admin")

		:AddArg("player", {single_target = true})

		:Help("Respawn a target.")

		:OnExecute(function(ply, targets)
			local target = targets[1]

			if target:Team() ~= 2 then
				return ply:sam_add_text("You cannot respawn a spectator!")
			end

			target:Spectate(OBS_MODE_NONE)
			target:Spawn()

			sam.player.send_message(nil, "respawn", {
				A = ply, T = targets
			})
		end)
	:End()

	local get_admins = function()
		local admins = {}

		local players = player.GetHumans()
		for i = 1, #players do
			local v = players[i]
			if v:IsAdmin() then
				table.insert(admins, v)
			end
		end

		return admins
	end

	command.new("givemagnum")
		:SetPermission("givemagnum", "superadmin")

		:AddArg("player", {single_target = true, optional = true})

		:Help("Give the target a magnum.")

		:OnExecute(function(ply, targets)
			local target = targets[1]

			if target:Team() ~= 2 then
				return ply:sam_add_text("You cannot give spectator a magnum!")
			end

			target:Give("weapon_mu_magnum")

			sam.player.send_message(get_admins(), "{A} gave {T} a {V}", {
				A = ply, T = targets, V = "magnum"
			})
		end)
	:End()

	command.new("giveknife")
		:SetPermission("giveknife", "superadmin")

		:AddArg("player", {single_target = true, optional = true})

		:Help("Give the target a knife.")

		:OnExecute(function(ply, targets)
			local target = targets[1]

			if target:Team() ~= 2 then
				return ply:sam_add_text("You cannot give spectator a knife!")
			end

			target:Give("weapon_mu_knife")

			sam.player.send_message(get_admins(), "{A} gave {T} a {V}", {
				A = ply, T = targets, V = "knife"
			})
		end)
	:End()

	command.new("forcemurderer")
		:SetPermission("forcemurderer", "admin")

		:AddArg("player", {single_target = true, optional = true})

		:Help("Force the target to me a murderer next round.")

		:OnExecute(function(ply, targets)
			GAMEMODE.ForceNextMurderer = targets[1]

			sam.player.send_message(get_admins(), "{A} set {T} to be the Murderer next round!", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("getmurderers")
		:SetPermission("getmurderers", "admin")

		:Help("Print all murderers in chat.")

		:OnExecute(function(ply)
			local murderers = {admin = ply}

			local players = team.GetPlayers(2)
			for i = 1, #players do
				local v = players[i]
				if v:GetMurderer() then
					table.insert(murderers, v)
				end
			end

			sam.player.send_message(ply, "Murderers are: {T}", {
				T = murderers
			})
		end)
	:End()
end)
--PATH addons/____sam/lua/sam/reports/cl_reports.lua:
if SAM_LOADED then return end

local sam = sam
local netstream = sam.netstream
local SUI = sam.SUI

local config = sam.config

local Trim = string.Trim

local muted_var = CreateClientConVar("sam_mute_reports", "0", false, false, "", 0, 1)

local position = config.get_updated("Reports.Position", "Left")
local max_reports = config.get_updated("Reports.MaxReports", 4)
local always_show = config.get_updated("Reports.AlwaysShow", true)
local pad_x = config.get_updated("Reports.XPadding", 5)
local pad_y = config.get_updated("Reports.YPadding", 5)

local duty_jobs = {}
config.hook({"Reports.DutyJobs"}, function()
	local jobs = config.get("Reports.DutyJobs", ""):Split(",")
	for i = #jobs, 1, -1 do
		local v = Trim(jobs[i])
		if v ~= "" then
			jobs[v] = true
		end
		jobs[i] = nil
	end
	duty_jobs = jobs
end)

local commands = {}
config.hook({"Reports.Commands"}, function()
	local cmds = config.get("Reports.Commands", ""):Split(",")
	for i = 1, #cmds do
		local v = Trim(cmds[i])
		if v ~= "" then
			cmds[i] = {
				name = v,
				func = function(_, ply)
					if IsValid(ply) then
						RunConsoleCommand("sam", v, "#" .. ply:EntIndex())
					end
				end
			}
		end
	end
	commands = cmds
end)

local reports = {}
local queued_reports = {}

local new_report, remove_report, check_queued, get_report, append_report

get_report = function(ply, index)
	for i = 1, #reports do
		local v = reports[i]
		local _ply = index and v.index or v.ply
		if _ply == ply then return v end
	end

	for i = 1, #queued_reports do
		local v = queued_reports[i]
		local _ply = index and v.index or v.ply
		if _ply == ply then return v, i end
	end
end

remove_report = function(ply)
	local report, delayed_i = get_report(ply)

	if delayed_i then
		return table.remove(queued_reports, delayed_i)
	end

	local panel = report.panel
	panel:MoveToNewX(position.value == "Right" and ScrW() or -panel:GetWide(), function()
		for i = report.pos + 1, #reports do
			local v = reports[i]
			v.pos = v.pos - 1
			v.panel:MoveToNewY(v.panel:GetY())
		end

		panel:Remove()
		table.remove(reports, report.pos)

		check_queued()
	end)
end

check_queued = function()
	while (max_reports.value - #reports > 0 and #queued_reports > 0) do
		new_report(table.remove(queued_reports, 1))
	end
end

append_report = function(ply, text)
	local report, delayed = get_report(ply)
	if delayed then
		table.insert(report.comments, text)
	else
		report.panel:AddComment(text)
	end
end

new_report = function(report)
	if #reports >= max_reports.value then
		return table.insert(queued_reports, report)
	end

	report.pos = table.insert(reports, report)

	local panel = vgui.Create("SAM.Report")
	panel:SetReport(report)

	for k, v in ipairs(commands) do
		panel:AddButton(v.name:gsub("^%l", string.upper), v.func)
	end

	local claim = panel:AddButton("Claim", function(self, ply)
		if panel:HasReport() then
			return LocalPlayer():sam_send_message("You have an active case, close it first.")
		end

		self.DoClick = function()
		end

		local claim_query = netstream.async.Start("ClaimReport", nil, ply)
		claim_query:done(function(claimed)
			if not IsValid(panel) then return end

			if claimed then
				panel:SetHasReport(ply)

				self:SetText("Close")

				self.background = Color(231, 76, 60, 200)
				self.hover = Color(255, 255, 255, 25)

				panel:FixWide()

				for k, v in ipairs(panel:GetChildren()[3]:GetChildren()) do
					v:SetDisabled(false)
					v:SetCursor("hand")
				end

				self.DoClick = function()
					panel:Close()
				end
			else
				panel:SetClaimed()
			end
		end)
	end)

	panel.claim = claim

	claim:SetCursor("hand")
	claim:SetDisabled(false)

	claim.background = Color(39, 174, 96, 200)
	claim.hover = Color(255, 255, 255, 25)

	panel:FixWide()

	local x = pad_x.value
	if position.value == "Right" then
		x = (ScrW() - panel:GetWide()) - x
	end

	panel:MoveToNewX(x)
	panel:MoveToNewY(panel:GetY())

	panel.new = true
	for k, v in ipairs(report.comments) do
		panel:AddComment(v)
	end
	panel.new = nil
end

netstream.Hook("Report", function(ply, comment)
	if not IsValid(ply) then return end

	if muted_var:GetBool() then return end

	local report = get_report(ply)
	if not report then
		report = {
			ply = ply,
			index = ply:EntIndex(),
			comments = {comment}
		}

		if not always_show.value and not duty_jobs[team.GetName(LocalPlayer():Team())] then
			LocalPlayer():sam_send_message("({S Blue}) {S_2 Red}: {S_3}", {
				S = "Report", S_2 = ply:Name(), S_3 = comment
			})
		else
			new_report(report)
		end
	else
		append_report(ply, comment)
	end
end)

netstream.Hook("ReportClaimed", function(ply)
	local report, delayed = get_report(ply)
	if not report then return end

	if delayed then
		table.remove(queued_reports, delayed)
	else
		report.panel:SetClaimed()
	end
end)

netstream.Hook("ReportClosed", function(index)
	local report, delayed = get_report(index, true)
	if not report then return end

	if delayed then
		table.remove(queued_reports, delayed)
	else
		report.panel:SetClosed()
	end
end)

do
	local REPORTS_HEADER = SUI.CreateFont("ReportHeader", "Roboto", 14, 540)
	local REPORT_COMMENT = SUI.CreateFont("ReportComment", "Roboto", 13, 540)
	local REPORT_BUTTONS = SUI.CreateFont("ReportButtons", "Roboto", 13, 550)

	local Panel = {}

	function Panel:Init()
		sui.TDLib.Start()

		self:Blur()
			:Background(Color(30, 30, 30, 240))

		local p_w, p_h = SUI.Scale(300), SUI.Scale(125)
		self:SetSize(p_w, p_h)

		local x = p_w * 2

		if position.value == "Right" then
			x = ScrW() + x
		else
			x = -x
		end

		self:SetPos(x, -p_h)

		local top_panel = self:Add("Panel")
		top_panel:Dock(TOP)
		top_panel:SetTall(SUI.Scale(24))
		top_panel:Background(Color(60, 60, 60, 200))

		local ply_name = top_panel:Add("DLabel")
		ply_name:Dock(LEFT)
		ply_name:DockMargin(5, 0, 0, 0)
		ply_name:SetTextColor(Color(200, 200, 200))
		ply_name:SetFont(REPORTS_HEADER)
		self.ply_name = ply_name

		local scroll = self:Add("SAM.ScrollPanel")
		scroll:Dock(FILL)
		scroll:DockMargin(5, 5, 5, 5)
		scroll.Paint = nil
		self.scroll = scroll

		local comment = scroll:Add("DLabel")
		comment:Dock(TOP)
		comment:SetText("")
		comment:SetTextColor(Color(200, 200, 200))
		comment:SetFont(REPORT_COMMENT)
		comment:SetMultiline(true)
		comment:SetWrap(true)
		comment:SetAutoStretchVertical(true)
		self.comment = comment

		local bottom = self:Add("Panel")
		bottom:Dock(BOTTOM)
		bottom:SetTall(SUI.Scale(24))
		self.bottom = bottom

		sui.TDLib.End()
	end

	function Panel:GetY()
		return (self:GetTall() + 5) * (self.report.pos - 1) + pad_y.value
	end

	function Panel:Close()
		remove_report(self.report.ply)
	end

	local change_state = function(self, text)
		self.claim:SetText(text)
		self.claim.DoClick = function() end

		self.claim:SUI_TDLib()
			:Background(Color(41, 128, 185, 200))

		timer.Simple(5, function()
			if IsValid(self) then
				self:Close()
			end
		end)

		if self:HasReport() == self.report.ply then
			self:SetHasReport()
		end

		self:FixWide()
	end

	function Panel:SetClaimed()
		change_state(self, "Case clamied!")
	end

	function Panel:SetClosed()
		change_state(self, "Case closed!")
	end

	function Panel:SetReport(report)
		surface.PlaySound("garrysmod/balloon_pop_cute.wav")

		report.panel = self

		self.report = report
		self.ply_name:SetText(report.ply:Name())
		self.ply_name:SetWide(self:GetWide())
	end

	local disabled = Color(60, 60, 60, 200)
	local click = Color(255, 255, 255, 30)
	local button_paint = function(self, w, h)
		draw.RoundedBox(0, 0, 0, w, h, self.background)

		if self:GetDisabled() then
			draw.RoundedBox(0, 0, 0, w, h, disabled)
		else
			if self:IsHovered() then
				draw.RoundedBox(0, 0, 0, w, h, self.hover)
			end

			if self.Depressed then
				draw.RoundedBox(0, 0, 0, w, h, click)
			end
		end
	end

	local button_click = function(self)
		self.cb(self, self.report.ply)
	end

	local background = Color(60, 60, 60, 200)
	local hover = Color(14, 134, 204, 100)
	function Panel:AddButton(text, cb)
		local button = self.bottom:Add("DButton")
		button:Dock(LEFT)
		button:SetText(text)
		button:SetTextColor(Color(200, 200, 200))
		button:SetFont(REPORT_BUTTONS)
		button:SetDisabled(true)
		button:SetCursor("arrow")

		button.Paint = button_paint
		button.DoClick = button_click

		button.background = background
		button.hover = hover

		button.cb = cb
		button.report = self.report

		return button
	end

	function Panel:FixWide()
		local wide = 0

		for _, v in ipairs(self.bottom:GetChildren()) do
			v:SizeToContents()
			v:SetWide(v:GetWide() + 6)
			wide = wide + v:GetWide()
		end

		self:SetWide(wide)

		return wide
	end

	function Panel:OnRemove()
		local reporter = self:HasReport()
		if reporter then
			netstream.Start("CloseReport", reporter)
			self:SetHasReport()
		end
	end

	function Panel:AddComment(text)
		local comment = self.comment

		local old_text = comment:GetText()
		if old_text ~= "" then
			old_text = old_text .. "\n"
		end

		if not self.new then
			surface.PlaySound("ambient/water/drip4.wav")
		end

		comment:SetText(old_text .. "- " .. text)
		comment:SizeToContents()

		self.scroll:ScrollToBottom()
	end

	function Panel:HasReport()
		return LocalPlayer().sam_has_report
	end

	function Panel:SetHasReport(v)
		LocalPlayer().sam_has_report = v
	end

	local new_animation = function(panel, name)
		local new_name = "anim_" .. name
		panel["MoveToNew" .. name:upper()] = function(self, new, cb)
			if self[new_name] then
				table.RemoveByValue(self.m_AnimList, self[new_name])
			end

			self[new_name] = self:NewAnimation(0.2, 0, -1, function()
				self[new_name] = nil
				if cb then cb() end
			end)

			self[new_name].Think = function(_, _, frac)
				self[name] = Lerp(frac, self[name], new)
			end
		end
	end

	new_animation(Panel, "x")
	new_animation(Panel, "y")

	vgui.Register("SAM.Report", Panel, "EditablePanel")
end
--PATH addons/__________911emergencyresponse/lua/emergencyresponse/client/cl_init.lua:
local c_background = ColorAlpha( color_black, 200 )
local c_bars = Color( 222, 0, 0 )
local c_text = ColorAlpha( color_white, 255 )
hook.Add( 'HUDPaint', 'EmergencyMod:Notifications', function()
	for k, v in ipairs( emergencymodNotificationSave ) do
		if v.ytimer - CurTime() < 0 then
			table.remove( emergencymodNotificationSave, k )
			continue
		end

		surface.SetFont( onyx.Font( 'Comfortaa@30' ) )
		local x, y = surface.GetTextSize( v.text )
		local alpha = math.Clamp( CurTime() - v.wtime, 0, 1 )
		local posy = ( ScrH() - y ) / 4 - 40 * k * k - 120 * ( 1 - math.Clamp( CurTime() - v.wtime, 0, 1 ) )
		local posx = math.Clamp( v.ytimer - CurTime(), 0, 0.25 ) * 4 * 30 + ( 0.25 - math.Clamp( v.ytimer - CurTime(), 0, 0.25 ) ) * 4 * -340
		c_background.a = 200 * alpha
		c_bars.a = 255 * alpha
		c_text.a = 255 * alpha
		draw.RoundedBox( 0, posx, posy - 40, 90 + x, 80, c_background )
		draw.RoundedBox( 0, posx, posy + 40, 90 + x, 2, c_bars )
		draw.RoundedBox( 0, posx, posy - 41, 90 + x, 3, c_bars )
		surface.SetTextPos( posx + 13, posy + 40 * 0.5 - y * 0.5 )
		surface.SetTextColor( c_text )
		surface.DrawText( v.text )
		surface.SetFont( onyx.Font( 'Comfortaa Bold@30' ) )
		surface.SetTextPos( posx + 13, posy - 46 * 0.5 - y * 0.5 )
		surface.SetTextColor( c_text )
		surface.DrawText( '112 СЛУЖБА ОПЕРАТИВНОГО РЕАГУВАННЯ' )
	end
end )
--PATH addons/_boombox/lua/retroboombox/languages/ru.lua:
return {
	["AlreadyCarryBoombox"] = "Вы уже несете бумбокс.",
	["TurnPower"] = "ВКЛ/ВЫКЛ",
	["Frequency"] = "Частота",
	["Drop"] = "Выкинуть",
	["Volume"] = "Громкость",
	["LMB"] = "ЛКМ",
	["RMB"] = "ПКМ",
}
--PATH addons/_boombox/lua/retroboombox/shared/sh_functions.lua:
local sMaterialPrefix = "sterling/retro_boombox_"
local subMaterials = {
	[ sMaterialPrefix .. "main" ] = {
		index = 0,
		folder = "main"
	},
	[ sMaterialPrefix .. "metalic" ] = {
		index = 1,
		folder = "main"
	},
	[ sMaterialPrefix .. "lights_main" ] = {
		index = 5,
		folder = "light"
	},
	[ sMaterialPrefix .. "light_tube" ] = {
		index = 3,
		folder = "light"
	},
	[ sMaterialPrefix .. "vol_light_09" ] = {
		index = 16,
		folder = "light"
	},
	[ sMaterialPrefix .. "vol_light_08" ] = {
		index = 15,
		folder = "light"
	},
	[ sMaterialPrefix .. "vol_light_07" ] = {
		index = 14,
		folder = "light"
	},
	[ sMaterialPrefix .. "vol_light_06" ] = {
		index = 13,
		folder = "light"
	},
	[ sMaterialPrefix .. "vol_light_05" ] = {
		index = 12,
		folder = "light"
	},
	[ sMaterialPrefix .. "vol_light_04" ] = {
		index = 11,
		folder = "light"
	},
	[ sMaterialPrefix .. "vol_light_03" ] = {
		index = 10,
		folder = "light"
	},
	[ sMaterialPrefix .. "vol_light_02" ] = {
		index = 9,
		folder = "light"
	},
	[ sMaterialPrefix .. "vol_light_01" ] = {
		index = 8,
		folder = "light"
	},
}

local tLightsModes = {
	[ 1 ] = {
		onStart = function( eBoombox )
			RetroBoombox:SetMainLights( eBoombox, false )
			RetroBoombox:SetTubeLights( eBoombox, false )
			RetroBoombox:SetSoundLights( eBoombox, 0 )
		end,
	},
	[ 2 ] = {
		onStart = function( eBoombox )
			RetroBoombox:SetMainLights( eBoombox, true )
			RetroBoombox:SetTubeLights( eBoombox, true )
			RetroBoombox:SetSoundLights( eBoombox, 9 )
		end,
	},
	[ 3 ] = {
		onStart = function( eBoombox )
			local index = eBoombox:EntIndex()
			local current = false

			-- If the player is too far from the timer, we check his distance only each 5 seconds.
			local isAdjusted = false
			local function timerFunc()
				if not IsValid( eBoombox ) then timer.Remove( "lightBoombox:" .. index ) return end

				if CLIENT then
					if eBoombox:GetPos():DistToSqr( LocalPlayer():GetPos() ) > 695000 then
						isAdjusted = true
						timer.Adjust( "lightBoombox:" .. index, 5, 0, timerFunc )
						return
					elseif isAdjusted then
						isAdjusted = false
						timer.Adjust( "lightBoombox:" .. index, 0.3, 0, timerFunc )
					end
				end

				RetroBoombox:SetMainLights( eBoombox, not current )
				RetroBoombox:SetTubeLights( eBoombox, not current )
				RetroBoombox:SetSoundLights( eBoombox, current and 0 or 9 )
				current = not current
			end

			timer.Create( "lightBoombox:" .. index, 0.3, 0, timerFunc )
		end,
		onFinish = function( eBoombox )
			timer.Remove( "lightBoombox:" .. eBoombox:EntIndex() )
		end
	},
	[ 4 ] = {
		onStart = function( eBoombox )
			local index = eBoombox:EntIndex()
			RetroBoombox:SetMainLights( eBoombox, true )
			RetroBoombox:SetTubeLights( eBoombox, true )

			-- If the player is too far from the timer, we check his distance only each 5 seconds.
			local isAdjusted = false
			local function timerFunc()
				if not IsValid( eBoombox ) then timer.Remove( "lightBoombox:" .. index ) return end

				if CLIENT then
					if eBoombox:GetPos():DistToSqr( LocalPlayer():GetPos() ) > 695000 then
						isAdjusted = true
						timer.Adjust( "lightBoombox:" .. index, 5, 0, timerFunc )
						return
					elseif isAdjusted then
						isAdjusted = false
						timer.Adjust( "lightBoombox:" .. index, 0.01, 0, timerFunc )
					end
				end
				RetroBoombox:SetSoundLights( eBoombox, eBoombox.LightLevel or 9 )
				current = not current
			end

			timer.Create( "lightBoombox:" .. index, 0.01, 0, timerFunc )
		end,
		onFinish = function( eBoombox )
			timer.Remove( "lightBoombox:" .. eBoombox:EntIndex() )
		end
	},
}

function RetroBoombox:ChangeColor( eBoombox, sType, sColor )
	local sColor = sColor or "white"
	local materialName = sMaterialPrefix .. sType
	eBoombox:SetSubMaterial( subMaterials[ materialName ].index, "sterling/colors/" .. subMaterials[ materialName ].folder .. "/retro_boombox_" .. subMaterials[ materialName ].folder .. "_" .. sColor )
end

function RetroBoombox:GetSoundLights()
	return eBoombox.SoundLights
end

function RetroBoombox:SetMainLights( eBoombox, bPower )
	eBoombox.MainLights = bPower
	RetroBoombox:ChangeColor( eBoombox, "lights_main", bPower and eBoombox.MainLightsColor or "zero" )
end

function RetroBoombox:SetTubeLights( eBoombox, bPower )
	eBoombox.MainLights = bPower
	RetroBoombox:ChangeColor( eBoombox, "light_tube", bPower and eBoombox.TubeLightsColor or "zero" )
end

function RetroBoombox:SetSoundLights( eBoombox, iPower )
	eBoombox.SoundLights = iPower
	for i=1, 9 do
		if i <= iPower then
			RetroBoombox:ChangeColor( eBoombox, "vol_light_0" .. i, eBoombox.SoundLightsColor )
		else
			RetroBoombox:ChangeColor( eBoombox, "vol_light_0" .. i, "zero" )
		end
	end
end

function RetroBoombox:ChangeLightMode( eBoombox, iMode )
	iMode = tLightsModes[ iMode or -1 ] and iMode or 1

	if eBoombox.LightMode and tLightsModes[ eBoombox.LightMode ].onFinish then
		tLightsModes[ eBoombox.LightMode ].onFinish( eBoombox )
	end

	eBoombox.LightMode = iMode

	if SERVER then
		eBoombox:SetLightMode( iMode )
	end

	if tLightsModes[ eBoombox.LightMode ] and tLightsModes[ eBoombox.LightMode ].onStart then
		tLightsModes[ eBoombox.LightMode ].onStart( eBoombox )
	end
end

--PATH addons/__________skeypads/lua/skeypads/config/sh_config.lua:
sKeypads.Config = {
    door_halo_color = Color( 255, 255, 255 ),
    output_types = {
        -- Enable/disable output types here
        ["fadingdoor"] = true, -- Fading doors
        ["keybind"] = true, -- Keybinds (works with sandbox tools such as thrusters)
    },
    max_distance_from_placement = 500, -- What is the furthest distance from the player that a keypad can be placed at?
    max_keypad_open_time = 15, -- The length of time a keypad can be open for.
    min_keypad_open_time = 4, -- The MINIMUM length oftime a keypad can be open for.
    keypads_crackers = {
        {
            name = "Pro Keypad Cracker",
            class_name = "pro_keypadcracker",
            deployable = true, -- Should the cracker be placed on the keypad while it cracks?
            time = 15 -- The time in seconds it takes to crack
        },
        {
            name = "Keypad Cracker",
            class_name = "base_keypadcracker",
            deployable = false, -- Should the cracker be placed on the keypad while it cracks?
            time = 22, -- The time in seconds it takes to crack
        }
    },
}
--PATH addons/____slib/lua/slib/vgui/cl_ssearchbar.lua:
local PANEL = {}

local maincolor_15, accentcolor, margin = slib.getTheme("maincolor", 15), slib.getTheme("accentcolor"), slib.getTheme("margin")

function PANEL:Init()
    self:Dock(TOP)
    self:SetTall(slib.getScaledSize(25, "y"))
    self.font = slib.createFont("Roboto", 15)
    self.material = Material("slib/icons/search32.png", "noclamp smooth")
    self.bg = maincolor_15

    self.entry = vgui.Create( "STextEntry", self )
    self.entry:Dock(FILL)

    slib.wrapFunction(self, "SetZPos", nil, function() return self end, true)
    slib.wrapFunction(self, "Dock", nil, function() return self end, true)
    slib.wrapFunction(self, "DockMargin", nil, function() return self end, true)
    slib.wrapFunction(self, "SetWide", nil, function() return self end, true)
end

function PANEL:addIcon()
    self.icon = true
    self.entry:DockMargin(slib.getScaledSize(25, "y") + margin,0,0,0)
    self.entry:AccentSideLine(true)
    
    return self
end

function PANEL:SetPlaceholder(str)
    self.entry:SetPlaceholder(str)
end

function PANEL:Paint(w,h)
    local size = h * .65
    local pos = h * .5 - (size * .5)

    if self.bg then
        surface.SetDrawColor(self.bg)
        surface.DrawRect(0, 0, w, h)
    end

    local wantedcolor = accentcolor
    wantedcolor.a = self.entry:HasFocus() and 120 or 20

    surface.SetDrawColor(slib.lerpColor(self, wantedcolor))
    surface.DrawRect(h - 1, margin, 1, h - (margin * 2))

    if self.icon then
        surface.SetDrawColor(color_white)
        surface.SetMaterial(self.material)
        surface.DrawTexturedRect(pos, pos, size, size)
    end
end

vgui.Register("SSearchBar", PANEL, "EditablePanel")
--PATH addons/__main/lua/autorun/sv_mas_ninjaskunai_init.lua:
/*

 ██████╗██████╗ ███████╗ █████╗ ████████╗███████╗██████╗     ██████╗ ██╗   ██╗    ███╗   ███╗ █████╗ ██████╗  █████╗ ███╗   ██╗███████╗ ██████╗ 
██╔════╝██╔══██╗██╔════╝██╔══██╗╚══██╔══╝██╔════╝██╔══██╗    ██╔══██╗╚██╗ ██╔╝    ████╗ ████║██╔══██╗██╔══██╗██╔══██╗████╗  ██║╚══███╔╝██╔═══██╗
██║     ██████╔╝█████╗  ███████║   ██║   █████╗  ██║  ██║    ██████╔╝ ╚████╔╝     ██╔████╔██║███████║██████╔╝███████║██╔██╗ ██║  ███╔╝ ██║   ██║
██║     ██╔══██╗██╔══╝  ██╔══██║   ██║   ██╔══╝  ██║  ██║    ██╔══██╗  ╚██╔╝      ██║╚██╔╝██║██╔══██║██╔══██╗██╔══██║██║╚██╗██║ ███╔╝  ██║   ██║
╚██████╗██║  ██║███████╗██║  ██║   ██║   ███████╗██████╔╝    ██████╔╝   ██║       ██║ ╚═╝ ██║██║  ██║██║  ██║██║  ██║██║ ╚████║███████╗╚██████╔╝
 ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═════╝     ╚═════╝    ╚═╝       ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝ ╚═════╝ 

------------------------------------------------------------------------------------------------------------------------------------------------------

██████╗  ██████╗     ███╗   ██╗ ██████╗ ████████╗    ██████╗ ███████╗██╗   ██╗██████╗ ██╗      ██████╗  █████╗ ██████╗                               
██╔══██╗██╔═══██╗    ████╗  ██║██╔═══██╗╚══██╔══╝    ██╔══██╗██╔════╝██║   ██║██╔══██╗██║     ██╔═══██╗██╔══██╗██╔══██╗                              
██║  ██║██║   ██║    ██╔██╗ ██║██║   ██║   ██║       ██████╔╝█████╗  ██║   ██║██████╔╝██║     ██║   ██║███████║██║  ██║                              
██║  ██║██║   ██║    ██║╚██╗██║██║   ██║   ██║       ██╔══██╗██╔══╝  ██║   ██║██╔═══╝ ██║     ██║   ██║██╔══██║██║  ██║                              
██████╔╝╚██████╔╝    ██║ ╚████║╚██████╔╝   ██║       ██║  ██║███████╗╚██████╔╝██║     ███████╗╚██████╔╝██║  ██║██████╔╝                              
╚═════╝  ╚═════╝     ╚═╝  ╚═══╝ ╚═════╝    ╚═╝       ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝     ╚══════╝ ╚═════╝ ╚═╝  ╚═╝╚═════╝                               

██╗███╗   ██╗     █████╗ ███╗   ██╗██╗   ██╗    ███████╗██╗  ██╗ █████╗ ██████╗ ███████╗     ██████╗ ██████╗     ███████╗ ██████╗ ██████╗ ███╗   ███╗
██║████╗  ██║    ██╔══██╗████╗  ██║╚██╗ ██╔╝    ██╔════╝██║  ██║██╔══██╗██╔══██╗██╔════╝    ██╔═══██╗██╔══██╗    ██╔════╝██╔═══██╗██╔══██╗████╗ ████║
██║██╔██╗ ██║    ███████║██╔██╗ ██║ ╚████╔╝     ███████╗███████║███████║██████╔╝█████╗      ██║   ██║██████╔╝    █████╗  ██║   ██║██████╔╝██╔████╔██║
██║██║╚██╗██║    ██╔══██║██║╚██╗██║  ╚██╔╝      ╚════██║██╔══██║██╔══██║██╔═══╝ ██╔══╝      ██║   ██║██╔══██╗    ██╔══╝  ██║   ██║██╔══██╗██║╚██╔╝██║
██║██║ ╚████║    ██║  ██║██║ ╚████║   ██║       ███████║██║  ██║██║  ██║██║     ███████╗    ╚██████╔╝██║  ██║    ██║     ╚██████╔╝██║  ██║██║ ╚═╝ ██║
╚═╝╚═╝  ╚═══╝    ╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝       ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚══════╝     ╚═════╝ ╚═╝  ╚═╝    ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝

-------------------------------------------------------- DO NOT REUPLOAD IN ANY SHAPE OR FORM -------------------------------------------------------- 
-------------------------------------------------------- DO NOT REUPLOAD IN ANY SHAPE OR FORM -------------------------------------------------------- 
-------------------------------------------------- IF YOU EDIT ANYTHING YOU ARE VOID OF MY SUPPORT --------------------------------------------------- 
-------------------------------------------------- IF YOU EDIT ANYTHING YOU ARE VOID OF MY SUPPORT --------------------------------------------------- 

*/

if (SERVER) then
	AddCSLuaFile( "autorun/sh_mas_ninjaskunai_fonts.lua" )
	IncludeCS( "autorun/cl_mas_ninjaskunai_options.lua" )
	
	local MaxHP = tobool( GetConVarNumber( "sk_mas_setmaxhealth_onspawn" ) )
	local LCNPC = tobool ( GetConVarNumber( "sk_mas_lagcompensate_npc" ) )
	
	if MaxHP then
		// Spawn Hook, Set Max HP
		local function spawn( ply )
			ply:SetMaxHealth( ply:Health() )
		end
		hook.Add( "PlayerSpawn", "Maranzo_PlySpawnHP", spawn )
	else
		hook.Remove( "PlayerSpawn", "Maranzo_PlySpawnHP" )
	end
	
	if LCNPC then
		// NPC Spawn Hook, Set Lag Compensation
		local function NPCspawn( ply, npc )
			npc:SetLagCompensated( true )
		end
		hook.Add( "PlayerSpawnedNPC", "Maranzo_PlySpawnNPCLag", NPCspawn )
	else
		hook.Remove( "PlayerSpawnedNPC", "Maranzo_PlySpawnNPCLag" ) 
	end
	
end // end If SERVER
--PATH addons/____plogs/lua/ui/theme.lua:
if SERVER then return end

surface.CreateFont("category_buttons", {
    font = "Robot",
    size = 20,
    weight = 750,
	antialias = true,
})

local SKIN 	= {
	PrintName 	= 'SUP',
	Author 	 	= 'aStonedPenguin'
}

local color_sup 			= ui.col.SUP
local color_background 		= ui.col.Background
local color_outline 		= ui.col.Outline
local color_hover 			= ui.col.Hover
local color_button 			= ui.col.Button
local color_button_hover	= ui.col.ButtonHover
local color_close 			= ui.col.Close
local color_close_bg 		= ui.col.CloseBackground
local color_close_hover 	= ui.col.CloseHovered

local color_offwhite 		= ui.col.OffWhite
local color_flat_black 		= ui.col.FlatBlack
local color_black 			= ui.col.Black
local color_white 			= ui.col.White
local color_red 			= ui.col.Red

-- Frames    
function SKIN:PaintFrame(self, w, h)
	--draw.Blur(self)
	EQRoundBox(0, 0, w, h, color_background, color_outline)
	EQRoundBox(0, 0, w, 28, color_background, color_outline)
end

function SKIN:PaintPanel(self, w, h)
	EQRoundBox(0, 0, w, h, color_background, color_outline)
end

function SKIN:PaintShadow() end


-- Buttons    
function SKIN:PaintButton(self, w, h)
	if (not self.m_bBackground) then return end

	if self:GetDisabled() then
		EQRoundBox(0, 0, w, h, color_flat_black, color_outline)
	elseif (self.Active == true) then
		EQRoundBox(0, 0, w, h, self.BackgroundColor or color_sup, color_outline)
	else
		EQRoundBox(0, 0, w, h, (self.Hovered and color_button_hover or color_button), color_outline)
	end

	self:SetTextColor((self.Hovered and (not self:GetDisabled()) and (not self.Active)) and color_black or color_white)

	if (not self.fontset) then
		self:SetFont('ui.20')
		self.fontset = true
	end
end

function SKIN:PaintAvatarImage(self, w, h)
	if self.Hovered then
		EQRoundBox(0, 0, w, h, color_hover, color_outline)
	end
end


-- Close Button                                               
function SKIN:PaintWindowCloseButton(panel, w, h)
	if (not panel.m_bBackground) then return end
	
	EQRoundBox(0, 0, w, h, (panel.Hovered and color_close_hover or color_close_bg), color_outline)
	
	draw.SimpleText("X", "category_buttons", w*0.5, h*0.5, (panel.Hovered and Color(255,255,255,151) or Color(255,255,255)), 1, 1)
	
end


-- Scrollbar
function SKIN:PaintVScrollBar(self, w, h) end
function SKIN:PaintButtonUp(self, w, h) end
function SKIN:PaintButtonDown(self, w, h) end
function SKIN:PaintButtonLeft(self, w, h) end
function SKIN:PaintButtonRight(self, w, h) end

function SKIN:PaintScrollBarGrip(self, w, h)
	EQRoundBox(0, 0, w, h, color_sup, color_outline)
end

function SKIN:PaintScrollPanel(self, w, h)
	EQRoundBox(0, 0, w, h, color_background, color_outline)
end

function SKIN:PaintUIScrollBar(self, w, h)
	EQRoundBox(0, self.scrollButton.y, w, self.height, color_sup, color_outline)
end


-- Slider
function SKIN:PaintUISlider(self, w, h)
	SKIN:PaintPanel(self, w, h)
	EQRoundBox(1, 1, self:GetValue() * w - self:GetValue() * 16, h - 2, color_sup, color_outline)
end


-- Text Entry
function SKIN:PaintTextEntry(self, w, h)
	EQRoundBox(0, 0, w, h, color_offwhite, color_outline)
	
	self:DrawTextEntryText(color_black, color_sup, color_black)
end


-- List View
function SKIN:PaintUIListView(self, w, h) 
	EQRoundBox(0, 0, w, h, color_offwhite, color_outline)
end


function SKIN:PaintListView(self, w, h) 
end

function SKIN:PaintListViewLine(self, w, h) -- todo, just make a new control and never use this
	if self.m_bAlt then
		EQRoundBox(0, 0, w, h, (self:IsSelected() or self:IsHovered()) and color_sup or color_hover, color_outline)
	else
		EQRoundBox(0, 0, w, h, (self:IsSelected() or self:IsHovered()) and color_sup or color_background, color_outline)
	end

	for k, v in ipairs(self.Columns) do
		if (self:IsSelected() or self:IsHovered()) then
			v:SetTextColor(color_black)
			v:SetFont('ui.20')
		else
			v:SetTextColor(color_white)
			v:SetFont('ui.17')
		end
	end
end


-- Checkbox
function SKIN:PaintCheckBox(self, w, h)
	EQRoundBox(0, 0, w, h, color_background, color_outline)

	if self:GetChecked() then 
		EQRoundBox(4, 4, w - 8, h - 8, color_sup, color_outline)
	end
end


-- Tabs
function SKIN:PaintTabButton(self, w, h)
	draw.OutlinedBox(0, 0, w, h, color_background, color_outline)
	
	self:SetTextColor(color_white)

	if self.Hovered then
		draw.Box(1, 1, 6, h - 2, color_sup)
		draw.Box(w - 6, 1, 6, h - 2, color_sup)
	elseif self.Active then
		draw.Box(1, 1, 3, h - 2, color_sup)
		draw.Box(w - 3, 1, 6, h - 2, color_sup)
	end
end

function SKIN:PaintTabListPanel(self, w, h)
	draw.OutlinedBox(149, 0, w - 149, h, color_background, color_outline)
end


-- ComboBox
function SKIN:PaintComboBox(self, w, h)
	if IsValid(self.Menu) and (not self.Menu.SkinSet) then
		self.Menu:SetSkin('SUP')
		self.Menu.SkinSet = true
	end

	self:SetTextColor(((self.Hovered or self.Depressed or self:IsMenuOpen()) and color_black or color_white))

	draw.Box(0, 0, w, h, ((self.Hovered or self.Depressed or self:IsMenuOpen()) and color_button_hover or color_background))
end

function SKIN:PaintComboDownArrow(self, w, h)
	surface.SetDrawColor(color_sup)
	draw.NoTexture()
	surface.DrawPoly({
		{x = 0, y = w * .5},
		{x = h, y = 0},
		{x = h, y = w}
	})
end


-- DMenu
function SKIN:PaintMenu(self, w, h)
	draw.Box(0, 0, w, h, color_background)
end

function SKIN:PaintMenuOption(self, w, h)
	if (not self.FontSet) then
		self:SetFont('ui.22')
		self:SetTextInset(5, 0)
		self.FontSet = true
	end
	
	self:SetTextColor(color_white)

	draw.Box(0, 0, w, h + 1, color_backgroun)
	
	if self.m_bBackground and (self.Hovered or self.Highlight) then
		draw.Box(0, 0, w, h + 1, color_sup)
		self:SetTextColor(color_button_hover)
	end
end

-- DPropertySheet
local propbackground = Color(200, 200, 200)
local prophovered = ui.col.ButtonHover
local propactive = Color(color_sup.r, color_sup.g, color_sup.b - 20)

function SKIN:PaintPropertySheet(self, w, h)
	draw.Box(0, self:GetActiveTab():GetTall(), w, h - self:GetActiveTab():GetTall(), propbackground)
end

function SKIN:PaintTab(self, w, h)
	local active = self:GetPropertySheet():GetActiveTab() == self
	
	if (active) then
		self:SetTextColor(propactive)
		draw.Box(0, 0, w, h, propbackground)
	elseif (self:IsHovered()) then
		self:SetTextColor(prophovered)
	else
		self:SetTextColor(propbackground)
	end
end

derma.DefineSkin('SUP', 'SUP\'s derma skin', SKIN)
--PATH addons/____plogs/lua/ui/controls/settings.lua:

-----------------------------------------------------
local PANEL = {}

Derma_Hook(PANEL, 'Paint', 'Paint', 'Panel')

function PANEL:Init()
	self:SetPadding(5)
	self:SetSpacing(5)
	
	self:Populate()
end

function PANEL:Populate() -- do the hack do the hack
	self:Reset()

	for k, v in pairs(cvar.GetTable()) do
		local title = ((self.State == 'All') and v:GetMetadata('Menu')) or (self.State and ((v:GetMetadata('State') or "") == self.State) and v:GetMetadata('Menu'))
		if title then
			local typ = v:GetMetadata('Type') or 'bool'
			if (typ == 'bool') then
				local chk = ui.Create('ui_checkbox', function(self)
					self:SetText(title)
					self:SetConVar(v:GetName())
					self:SizeToContents()
				end)
			
				self:AddItem(chk)
			elseif (typ == 'number') then
				self:AddItem(ui.Create('DLabel', function(self)
					self:SetFont('ui.18')
					self:SetColor(ui.col.ButtonText)
					self:SetText(title)
					self:SizeToContents()
					self:SetTall(14)
				end))
				self:AddItem(ui.Create('ui_slider', function(self)
					self:SetValue(v:GetValue())
					self.OnChange = function(s, val) v:SetValue(val) end
					self:SetWide(150)
				end))
			end
		end
	end
end

function PANEL:SetState(state)
	self.State = state
	self:Populate()
end

function PANEL:DockToFrame()
	local p = self:GetParent()
	local x, y = p:GetDockPos()
	self:SetPos(x, y)
	self:SetSize(p:GetWide() - 10, p:GetTall() - (y + 5))
end

vgui.Register('ui_settingspanel', PANEL, 'ui_scrollpanel')
--PATH addons/____plogs/lua/ui/controls/tablist.lua:

-----------------------------------------------------
local PANEL = {}

function PANEL:Init()
	self.tabList = ui.Create('ui_scrollpanel', function(list)
		list:SetSize(150, 0)
		list:Dock(LEFT)
		list:SetPadding(-1)
	end, self)
	self.Buttons = {}
end

function PANEL:SetActiveTab(num)
	for k, v in ipairs(self.Buttons) do
		v.Active = (num == k)
		
		if (v.Tab:IsVisible()) then
			v.Tab:Dock(NODOCK)
			v.Tab:SetVisible(false)
		end
		
		if (num == k) then
			v.Tab:SetVisible(true)
			v.Tab:DockMargin(0, 0, 0, 0)
			v.Tab:Dock(FILL)
		end
	end
end

function PANEL:AddTab(title, tab, active)
	tab.Paint = function(tab, w, h) end
	tab:SetSize(self:GetWide() - 150, self:GetTall())
	tab:SetVisible(false)
	tab:SetParent(self)
	tab:SetSkin(self:GetSkin().PrintName)

	local button = ui.Create('DButton', function(btn)
		btn:SetSize(0, 35)
		btn:SetText(title)

		btn:SetFont('ui.24')
		btn:SetTextColor(ui.col.White)
		
		btn.DoClick = function(s)
			self:SetActiveTab(s.ID)
		end

		btn.Paint = function(btn, w, h)
			derma.SkinHook('Paint', 'TabButton', btn, w, h)
		end
		
		btn.Tab = tab
	end)

	self.tabList:AddItem(button)
	button.ID = table.insert(self.Buttons, button)
	
	if (active) then
		self:SetActiveTab(button.ID)
	end
end


local fr
function PANEL:AddButton(title, func)
	local button = ui.Create('DButton', function(btn)
		btn:SetSize(0, 35)
		btn:SetText(title)
		
		btn:SetFont('ui.24')
		btn:SetTextColor(ui.col.White)
		
		btn.DoClick = function(self)
			func(self)
		end
		
		btn.Paint = function(btn, w, h)
			derma.SkinHook('Paint', 'TabButton', btn, w, h)
		end
	end)
	
	self.tabList:AddItem(button)
	table.insert(self.Buttons, btn)
	
	fr = self
end
function PANEL:AddButtonHSV(title, func)
	local button = ui.Create('DButton', function(btn)
		btn:SetSize(0, 35)
		btn:SetText(title)
		
		btn:SetFont('ui.24')
		btn:SetTextColor(HSVToColor(CurTime()%6*60,1,1)) 
		
		btn.DoClick = function(self)
			func(self)
		end
		
		btn.Paint = function(btn, w, h)
			derma.SkinHook('Paint', 'TabButton', btn, w, h)
			btn:SetTextColor(HSVToColor(CurTime()%6*60,1,1)) 
		end
	end)
	
	self.tabList:AddItem(button)
	table.insert(self.Buttons, btn)
	
	fr = self
end
function PANEL:DockToFrame()
	local p = self:GetParent()
	local x, y = p:GetDockPos()
	y = y - 6
	self:SetPos(0, y)
	self:SetSize(p:GetWide(), p:GetTall() - y)
end

function PANEL:Paint(w, h)
	derma.SkinHook('Paint', 'TabListPanel', self, w, h)
end

vgui.Register('ui_tablist', PANEL, 'Panel')
--PATH addons/__main/lua/wos/anim_extension/extensions/wos_famdance.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Familiar Dances" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted animation extension: Familiar Dances\n" )
--PATH addons/__main/lua/wos/anim_extension/core/sh_holdtypes.lua:
--[[-------------------------------------------------------------------
	wiltOS Hold Type Register:
		The core files needed to make your own hold types
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.HoldTypes = wOS.AnimExtension.HoldTypes or {}
wOS.AnimExtension.TranslateHoldType = wOS.AnimExtension.TranslateHoldType or {}

wOS.AnimExtension.ActIndex = {
	[ "pistol" ] 		= ACT_HL2MP_IDLE_PISTOL,
	[ "smg" ] 			= ACT_HL2MP_IDLE_SMG1,
	[ "grenade" ] 		= ACT_HL2MP_IDLE_GRENADE,
	[ "ar2" ] 			= ACT_HL2MP_IDLE_AR2,
	[ "shotgun" ] 		= ACT_HL2MP_IDLE_SHOTGUN,
	[ "rpg" ]	 		= ACT_HL2MP_IDLE_RPG,
	[ "physgun" ] 		= ACT_HL2MP_IDLE_PHYSGUN,
	[ "crossbow" ] 		= ACT_HL2MP_IDLE_CROSSBOW,
	[ "melee" ] 		= ACT_HL2MP_IDLE_MELEE,
	[ "slam" ] 			= ACT_HL2MP_IDLE_SLAM,
	[ "normal" ]		= ACT_HL2MP_IDLE,
	[ "fist" ]			= ACT_HL2MP_IDLE_FIST,
	[ "melee2" ]		= ACT_HL2MP_IDLE_MELEE2,
	[ "passive" ]		= ACT_HL2MP_IDLE_PASSIVE,
	[ "knife" ]			= ACT_HL2MP_IDLE_KNIFE,
	[ "duel" ]			= ACT_HL2MP_IDLE_DUEL,
	[ "camera" ]		= ACT_HL2MP_IDLE_CAMERA,
	[ "magic" ]			= ACT_HL2MP_IDLE_MAGIC,
	[ "revolver" ]		= ACT_HL2MP_IDLE_REVOLVER
}

function wOS.AnimExtension:RegisterHoldtype( data )

	self.TranslateHoldType[ data.HoldType ] = data
    self.HoldTypeMeta:CreateMetaType( self.TranslateHoldType[ data.HoldType ] )
	
	if data.BaseHoldType then
		if prone then
			if prone.animations then
				if prone.animations.WeaponAnims then
					prone.animations.WeaponAnims.moving[ data.HoldType ] = prone.animations.WeaponAnims.moving[ data.BaseHoldType ]
					prone.animations.WeaponAnims.idle[ data.HoldType ] = prone.animations.WeaponAnims.idle[ data.BaseHoldType ]
				end
			end
		end
	end

	print( "[wOS] Registered new Hold Type: " .. data.Name )
	
end

local meta = FindMetaTable( "Player" )
local ENTITY = FindMetaTable( "Entity" )

local AttackTable = {
[ ACT_MP_ATTACK_STAND_PRIMARYFIRE  ] = true,
[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE  ] = true,
[ ACT_MP_ATTACK_STAND_SECONDARYFIRE  ] = true,
[ ACT_MP_ATTACK_CROUCH_SECONDARYFIRE  ] = true,
}

local _TranslateWeaponActivity = meta.TranslateWeaponActivity
function meta:TranslateWeaponActivity( act )

	if AttackTable[ act ] then
		local wep = self:GetActiveWeapon()
		if IsValid( wep ) then  
			local holdtype = wep:GetHoldType()
			if wOS.AnimExtension.TranslateHoldType[ holdtype ] then
				local ATTACK_DATA = wOS.AnimExtension.TranslateHoldType[ holdtype ]:GetActData( act )
				if ATTACK_DATA then
					local anim = self:LookupSequence( ATTACK_DATA.Sequence )
					self:AddVCDSequenceToGestureSlot( GESTURE_SLOT_VCD, anim, 0, true ) //Figure out weight to make it balanced!
					self:AnimSetGestureWeight( GESTURE_SLOT_VCD, ATTACK_DATA.Weight or 1 )
				end
			end
		end
	end
	
	return _TranslateWeaponActivity( self, act )

end


-- local _DoAnimationEvent = meta.DoAnimationEvent
-- function meta:DoAnimationEvent( ply, event, data )

-- 	local act = _DoAnimationEvent( self, ply, event, data )
-- 	print( act )
-- 	local wep = self:GetActiveWeapon()
-- 	if IsValid( wep ) then  
-- 		local holdtype = wep:GetHoldType()
-- 		if wOS.AnimExtension.TranslateHoldType[ holdtype ] then
-- 			local result = wOS.AnimExtension.TranslateHoldType[ holdtype ][ act ]
-- 			if result then
-- 				if istable( result ) then
-- 					result = table.Random( result )
-- 				end
-- 				if isstring( result ) then
-- 					local anim = ply:LookupSequence( result )	
-- 					ply.ActOverrider = act
-- 					ply.SequenceTime = CurTime() + ply:SequenceDuration( anim )
-- 				end
-- 			end
-- 		end
-- 	end
	
-- 	return act
-- end

hook.Add( "DoAnimationEvent", "wOS.AnimExtension.CustomTriggers", function( ply, event, data ) 

	local wep = ply:GetActiveWeapon()
	if !IsValid( wep ) then return end
	local holdtype = wep:GetHoldType()
	if !wOS.AnimExtension.TranslateHoldType[ holdtype ] then return end

	local act = 9999
	local crouch = ply:Crouching()
	if event == PLAYERANIMEVENT_RELOAD then
		act = ( crouch and ACT_MP_RELOAD_CROUCH ) or ACT_MP_RELOAD_STAND
	elseif event == PLAYERANIMEVENT_ATTACK_SECONDARY then
		act = ( crouch and ACT_MP_ATTACK_CROUCH_SECONDARYFIRE ) or ACT_MP_ATTACK_STAND_SECONDARYFIRE
	end

	local ATTACK_DATA = wOS.AnimExtension.TranslateHoldType[ holdtype ]:GetActData( act )
	if !ATTACK_DATA then return end

	local anim = ply:LookupSequence( ATTACK_DATA.Sequence )
	ply:AddVCDSequenceToGestureSlot( GESTURE_SLOT_VCD, anim, 0, true ) //Figure out weight to make it balanced!
	ply:AnimSetGestureWeight( GESTURE_SLOT_VCD, ATTACK_DATA.Weight or 1 )

	return ACT_INVALID
end )

hook.Add( "Initialize", "wOS.AnimExtension.CustomSequenceHoldtypes", function()

	local _CalcMainActivity = GAMEMODE.CalcMainActivity
	function GAMEMODE:CalcMainActivity( ply, vel )
		
		local act, seq = _CalcMainActivity( self, ply, vel )
		local pr = false
		if prone then
			if ply.IsProne then
				pr = ply:IsProne()
			end
		end

		if not pr then
			local wep = ply:GetActiveWeapon()
			if IsValid( wep ) then  
				local holdtype = wep:GetHoldType()
				if wOS.AnimExtension.TranslateHoldType[ holdtype ] then
					local ATTACK_DATA = wOS.AnimExtension.TranslateHoldType[ holdtype ]:GetActData( act )
					if act == ACT_MP_RUN and ply:KeyDown( IN_SPEED ) then
						ATTACK_DATA = wOS.AnimExtension.TranslateHoldType[ holdtype ]:GetActData( ACT_MP_SPRINT ) or ATTACK_DATA
					end
					if ATTACK_DATA then
						seq = ply:LookupSequence( ATTACK_DATA.Sequence )
					end
				end
			end

			
			if act != ply.LastAct then
				ply:SetCycle( 0 )
			end
		end
		
		ply.LastAct = act
		
		return act, seq
		
	end
	
end )

if SERVER then return end

concommand.Add( "wos_base_help", function( ply, cmd, args )
	MsgC( Color( 255, 255, 255 ), "------------------ ", Color( 133, 173, 219 ), "wiltOS HELP PRINT", Color( 255, 255, 255 ), " ----------------------\n" )
	MsgC( Color( 255, 255, 255 ), "Addon Path Check: " )
	LocalPlayer():ConCommand( "whereis models/m_anm.mdl" )
	timer.Simple( 0.01, function()
	
		MsgC( color_white, "\nPlease ensure the addon path above points to ", Color( 0, 255, 0 ), "'[wOS] Animation Extension - Base'\n")
		MsgC( color_white, "If it does not, unsubscribe to the addon it does point to and get the Animation Base\n")
		print("\n")

		local seq = LocalPlayer():LookupSequence( "_base_wiltos_enabled_" )
		local resp = ( seq >= 0 and Color( 0, 255, 0 ) ) or Color( 255, 0, 0 )
		MsgC( color_white, "Sequence Check: ", resp, "\t", seq, "\n" )
		MsgC( color_white, "If the above sequence check is ", Color( 255, 0, 0 ), -1, color_white, " and the addon above points to the correct location,\nensure your model is a ", Color( 0, 255, 0 ), "PLAYER MODEL", color_white, " and not an ", Color( 255, 0, 0 ), "NPC MODEL\n" )
		MsgC( color_white, "Run this commmand again as a default GMod player model. If it still prints ", Color( 255, 0, 0 ), -1, color_white, " your Animation Base may be outdated\n" )

		print( "\n" )
		MsgC( color_white, "You can find the link here: https://steamcommunity.com/sharedfiles/filedetails/?id=757604550\n")
		MsgC( Color( 255, 255, 255 ), "-----------------------------------------------------------\n" )
	end )
end )
--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/debug.lua:
CreateClientConVar("xenin_debug_print_file_enabled", "1", true, false)
CreateClientConVar("xenin_debug_print_console_enabled", "0", true, false)

function XeninUI:HasDebugFilePrintEnabled()
  return GetConVar("xenin_debug_print_file_enabled"):GetBool() or ply:IsSuperAdmin()
end

function XeninUI:HasDebugConsolePrintEnabled()
  return GetConVar("xenin_debug_print_console_enabled"):GetBool()
end

function XeninUI:EnsureDebugFileExists()
  local ply = LocalPlayer()

  local path = self.debugPath or "xenin/debug/"
  local time = os.time()
  local date = os.date("%d_%m_%Y_%H_%M_%S", time)
  local realPath = path .. date .. ".txt"

  if (!file.IsDir(path, "DATA")) then
    file.CreateDir(path)
  end

  if (!file.Exists(realPath, "DATA")) then
    local str = "Debug log for " .. ply:Nick() .. " [" .. ply:SteamID() .. "] initialised at " .. os.date("%d/%m/%Y %H:%M:%S", time) .. "\n"
    file.Write(realPath, str)

    ply.debug = realPath
  end
end

hook.Add("InitPostEntity", "XeninUI.Debug", function()
  XeninUI:EnsureDebugFileExists()
end)

function XeninUI:DebugPrint(prefix, ...)
  local rawPrefix = prefix
  local args = {
  ... }
  local ply = LocalPlayer()
  local printEnabled = XeninUI:HasDebugConsolePrintEnabled()
  local fileEnabled = XeninUI:HasDebugFilePrintEnabled()

  if (!printEnabled and !fileEnabled) then return end
  local path = ply.debug
  if (!path) then print("ERROR AT DEBUG PRINT")end
  local time = os.time()
  local date = os.date("%H:%M:%S", time)
  prefix = "[" .. prefix:upper() .. " ENTRANCE AT " .. date .. "]"

  local str = prefix .. "\n	-	"

  for i, v in ipairs(args) do
    if istable(v) then
      local json = util.TableToJSON(v, true)
      local exploded = string.Explode("\n", json)

      for i, v in ipairs(exploded) do
        if (i == 1) then continue end

        exploded[i] = "	-	" .. v
      end

      json = table.concat(exploded, "\n")
      str = str .. "Table: " .. json .. "\n	- "

      continue
    end

    str = str .. v .. "\n	-	"
  end
  str = str:sub(1, str:len() - 3)

  if fileEnabled then
    file.Append(path, str)
  end

  if printEnabled then
    ply.debugTbl = ply.debugTbl or {}
    ply.debugTbl[rawPrefix] = ply.debugTbl[rawPrefix] or {}

    table.insert(ply.debugTbl[rawPrefix], {
      time = CurTime(),
      str = str
    })
  end
end

function XeninUI:DebugQuery(prefix, secs)
  if (!prefix) then
    print("You need a category!")

    return
  end

  secs = secs or 300

  local ply = LocalPlayer()
  if (!ply.debugTbl) then
    print("No debug info at all")

    return
  end
  if (!ply.debugTbl[prefix]) then
    print("No debug info for " .. prefix)

    return
  end

  local tbl = ply.debugTbl[prefix]
  local size = #tbl

  if (size == 0) then
    print("The category exists, but there's no info")

    return
  end

  local curTime = CurTime() - secs
  local infoTbl = {}

  for i = size, 1, -1 do
    if (tbl[i] and tbl[i].time > curTime) then
      table.insert(infoTbl, tbl[i])

      continue
    end

    break
  end

  return infoTbl
end

concommand.Add("xenin_debug_query", function(ply, cmd, args)
  local prefix = args[1]
  local secs = args[2]
  local tbl = XeninUI:DebugQuery(args[1], args[2])

  if tbl then
    local str = ""

    for i, v in ipairs(tbl) do
      str = str .. v.str .. "\n"

      if (i == #tbl) then str = str:sub(1, str:len() - 2)end
    end

    print(str)
    MsgC(XeninUI.Theme.Accent, "Results: ")
    MsgC(XeninUI.Theme.Green, #tbl .. "\n")
  end
end)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/shadows.lua:
local scrW, scrH = ScrW(), ScrH()

local function Load()
	BSHADOWS = {}

	local resStr = scrW .. "" .. scrH

	BSHADOWS.RenderTarget = GetRenderTarget("bshadows_original_" .. resStr, scrW, scrH)


	BSHADOWS.RenderTarget2 = GetRenderTarget("bshadows_shadow_" .. resStr, scrW, scrH)


	BSHADOWS.ShadowMaterial = CreateMaterial("bshadows", "UnlitGeneric", {
		["$translucent"] = 1,
		["$vertexalpha"] = 1,
		["alpha"] = 1
	})



	BSHADOWS.ShadowMaterialGrayscale = CreateMaterial("bshadows_grayscale", "UnlitGeneric", {
		["$translucent"] = 1,
		["$vertexalpha"] = 1,
		["$alpha"] = 1,
		["$color"] = "0 0 0",
		["$color2"] = "0 0 0"
	})


	BSHADOWS.BeginShadow = function()


		render.PushRenderTarget(BSHADOWS.RenderTarget)


		render.OverrideAlphaWriteEnable(true, true)
		render.Clear(0, 0, 0, 0)
		render.OverrideAlphaWriteEnable(false, false)


		cam.Start2D()


	end


	BSHADOWS.EndShadow = function(intensity, spread, blur, opacity, direction, distance, _shadowOnly)


		opacity = opacity or 255
		direction = direction or 0
		distance = distance or 0
		_shadowOnly = _shadowOnly or false


		render.CopyRenderTargetToTexture(BSHADOWS.RenderTarget2)


		if blur > 0 then
			render.OverrideAlphaWriteEnable(true, true)
			render.BlurRenderTarget(BSHADOWS.RenderTarget2, spread, spread, blur)
			render.OverrideAlphaWriteEnable(false, false)
		end


		render.PopRenderTarget()


		BSHADOWS.ShadowMaterial:SetTexture('$basetexture', BSHADOWS.RenderTarget)


		BSHADOWS.ShadowMaterialGrayscale:SetTexture('$basetexture', BSHADOWS.RenderTarget2)


		local xOffset = math.sin(math.rad(direction)) * distance
		local yOffset = math.cos(math.rad(direction)) * distance


		BSHADOWS.ShadowMaterialGrayscale:SetFloat("$alpha", opacity / 255)
		render.SetMaterial(BSHADOWS.ShadowMaterialGrayscale)
		for i = 1, math.ceil(intensity) do
			render.DrawScreenQuadEx(xOffset, yOffset, scrW, scrH)
		end

		if not _shadowOnly then

			BSHADOWS.ShadowMaterial:SetTexture('$basetexture', BSHADOWS.RenderTarget)
			render.SetMaterial(BSHADOWS.ShadowMaterial)
			render.DrawScreenQuad()
		end

		cam.End2D()
	end


	BSHADOWS.DrawShadowTexture = function(texture, intensity, spread, blur, opacity, direction, distance, shadowOnly)


		opacity = opacity or 255
		direction = direction or 0
		distance = distance or 0
		shadowOnly = shadowOnly or false


		render.CopyTexture(texture, BSHADOWS.RenderTarget2)


		if blur > 0 then
			render.PushRenderTarget(BSHADOWS.RenderTarget2)
			render.OverrideAlphaWriteEnable(true, true)
			render.BlurRenderTarget(BSHADOWS.RenderTarget2, spread, spread, blur)
			render.OverrideAlphaWriteEnable(false, false)
			render.PopRenderTarget()
		end


		BSHADOWS.ShadowMaterialGrayscale:SetTexture('$basetexture', BSHADOWS.RenderTarget2)


		local xOffset = math.sin(math.rad(direction)) * distance
		local yOffset = math.cos(math.rad(direction)) * distance


		BSHADOWS.ShadowMaterialGrayscale:SetFloat("$alpha", opacity / 255)
		render.SetMaterial(BSHADOWS.ShadowMaterialGrayscale)
		for i = 1, math.ceil(intensity) do
			render.DrawScreenQuadEx(xOffset, yOffset, scrW, scrH)
		end
		if not shadowOnly then

			BSHADOWS.ShadowMaterial:SetTexture('$basetexture', texture)
			render.SetMaterial(BSHADOWS.ShadowMaterial)
			render.DrawScreenQuad()
		end
	end
end

Load()

timer.Create("XeninUI.BShadows.ResolutionCheck", 1, 0, function()
	if (ScrW() != scrW or ScrH() != scrH) then
		scrW = ScrW()
		scrH = ScrH()

		Load()
	end
end)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/languages/network/client.lua:
local LanguagesNetwork
do
  local _class_0
  local _parent_0 = XeninUI.Network
  local _base_0 = {
    __name = "LanguagesNetwork",
    __base = XeninUI.Network.__base,
    receiveLanguage = function(self, ply)
      local addonId = net.ReadString()
      local lang = net.ReadString()
      local data = self:decompress()

      XeninUI.LanguageAddons[addonId]:SetLocalLanguage(lang, data)
    end,
    sendRequestLanguage = function(self, addonId, lang)
      self:send("XeninUI.Language", function(self)
        net.WriteString(addonId)
        net.WriteString(lang)
      end)
    end,
    __type = function(self)
      return "XeninUI.LanguagesNetwork"end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__index)
  _class_0 = setmetatable({
    __init = function(self)
      LanguagesNetwork.__parent.__init(self)

      self:receiver("XeninUI.Language", self.receiveLanguage)
    end,
    __base = _base_0,
    __parent = _parent_0
  }, {
    __index = function(cls, parent)
      local val = rawget(_base_0, parent)
      if val == nil then local _parent = rawget(cls, "__parent")
        if _parent then return _parent[parent]
        end
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0)
  end
  LanguagesNetwork = _class_0
end

XeninUI.LanguagesNetwork = LanguagesNetwork()

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/entities/entity.lua:
local PANEL = {}

function PANEL:Init() end

function PANEL:GetEntities()
  return {
  i }
end

function PANEL:SetScript(script)
  self.script = script
  self.ctr = XeninUI.Configurator:FindControllerByScriptName(script)
end

function PANEL:OnSearch(text)
  XeninUI.Configurator.Network:sendGetEntities(self.BaseEnt, nil, nil, text)
end

function PANEL:SetData(tbl)
  assert(tbl ~= nil, "cannot destructure nil value")
  local __entity, name, script = tbl.__entity, tbl.name, tbl.script

  self:SetScript(script)
  self.Entity = __entity
  self:SetTitle(name)
  self.Navbar:SetVisible(false)
  self.BaseEnt = XeninUI.Configurator.Entities:create(self.Entity)
  XeninUI.Configurator.Network:sendGetEntities(self.BaseEnt)

  self.TopBar = self:Add("Panel")
  self.TopBar:Dock(TOP)
  self.TopBar:DockMargin(0, 16, 0, 0)

  self.Subtitle = self.TopBar:Add("DLabel")
  self.Subtitle:SetFont("Xenin.Configurator.Admin.Panel.Navbar")
  self.Subtitle:SetText("Loading")

  self.Create = self.TopBar:Add("XeninUI.ButtonV2")
  self.Create:Dock(RIGHT)
  self.Create:SetText("Create New")
  self.Create:SetFont("Xenin.Configurator.Admin.Panel.Navbar")
  self.Create:SetRoundness(6)
  self.Create:SetSolidColor(XeninUI.Theme.Primary)
  self.Create:SetHoverColor(XeninUI.Theme.Navbar)
  self.Create:SetTextColor(Color(182, 182, 182))
  self.Create.DoClick = function(pnl)
    local ent = XeninUI.Configurator.Entities:create(self.Entity)
    XeninUI.Configurator.Network:sendCreateEntity(ent)
  end
  self.Save.DoClick = function(pnl)
    for _, row in ipairs(self.Rows) do
      local ent = XeninUI.Configurator.Entities:create(self.Entity)
      local settings = IsValid(row.Settings) and row.Settings:GetSettings()
      if (!settings) then continue end

      for i, v in pairs(settings) do
        ent["set" .. tostring(i)](ent, v)
      end

      ent:save(true)
    end
  end

  hook.Add("XeninUI.Configurator.CreatedEntity", self, function(self, ent)
    local entity = ent:getDatabaseEntity()
    if (entity != self.Entity) then return end

    local id = ent.getId and ent:getId() or #self.Rows + 1
    self:CreateEntity(ent, id)
    self:UpdateTitle(#self.Rows)
  end)
  self.Scroll:DockMargin(0, 16, 0, 0)

  self.Rows = {}

  self.RowController = self.Body:Add("Panel")
  self.RowController:Dock(TOP)
  self.RowController.Think = function(pnl, w, h)
    w = pnl:GetWide()
    h = pnl:GetTall()

    local y = 0
    for i, v in ipairs(self.Rows) do
      if (!IsValid(v)) then continue end

      v:SizeToChildren(false, true)
      local height = v:GetTall() >= 48 and v:GetTall() or 48
      v:SetSize(w, height)
      v:SetPos(0, y)

      y = y + v:GetTall()
    end

    pnl:SizeToChildren(false, true)
  end

  hook.Add("XeninUI.Configurator.GetEntities", self, function(self, entities)
    if entities == nil then entities = {}
    end
    self:UpdateTitle(#entities)

    self.Rows = {}
    for i, v in ipairs(entities) do
      self:CreateEntity(v, i)
    end
  end)
end

function PANEL:UpdateTitle(size)
  size = size or #self.Rows
  if (!IsValid(self.Title)) then return end

  local name = self.Title:GetText()
  name = name:sub(1, 1):lower() .. name:sub(2, #name - 1)
  if (size != 1) then name = name .. "s"
  end

  self.Subtitle:SetText(tostring(size) .. " " .. tostring(name))
end

function PANEL:CreateEntity(entity, id)
  local columns = entity:getColumns()
  local name = entity.__name

  local panel = self.RowController:Add("Xenin.Configurator.Admin.Entity.Row")
  panel:SetEntity(entity)
  panel.OnRemove = function(pnl)
    table.remove(self.Rows, id)

    self:UpdateTitle(#self.Rows - 1)
  end

  local id = table.insert(self.Rows, panel)
  self.Rows[id].RowId = id
end

function PANEL:Paint(w, h)
  self.BaseClass.Paint(self, w, h)

  if (self.Subtitle:GetText() != "Loading") then return end

  XeninUI:DrawLoadingCircle(w * 0.5, h * 0.5, h / 4)
end

function PANEL:PerformLayout(w, h)
  self.BaseClass.PerformLayout(self, w, h)

  self.TopBar:SetTall(32)
  self.Subtitle:SizeToContents()
  self.Create:SizeToContentsX(24)
end

vgui.Register("Xenin.Configurator.Admin.Entity", PANEL, "Xenin.Configurator.Admin.Panel")

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/inputs/range.lua:
local x

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/inputs/textentrywithlabel.lua:
local x

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/players/ui/notifications/row.lua:
local PANEL = {}

function PANEL:Init()
  self.OnPaint = {}
  self.BackgroundColor = XeninUI.Theme.Primary
end

function PANEL:SetNotification(notification)
  self.Notification = notification
  if self.Notification.readAt then
    self.BackgroundColor = XeninUI.Theme.Navbar
  end
  self.TypeData = XeninUI.Notification:getType(notification.scriptId, notification.type)

  self.Hooks = self.TypeData.hooks and self.TypeData.hooks(notification)
  local hooks = self.Hooks
  if (hooks and hooks.preInit) then
    hooks.preInit(notification, self)
  end

  local img = self.TypeData.img(notification)
  if img.custom then
    img.custom(notification, self)
  elseif img.src then
    XeninUI:DownloadIcon(self, img.src, "Image")
    self:AddPaint(function(self, w, h)
      XeninUI:DrawIcon(8, 8, 48 - 16, 48 - 16, self, self.color, self.color, "Image")
    end)
  elseif img.ply then
    self.PlayerAvatar = self:Add("XeninUI.Avatar")
    self.PlayerAvatar:SetSteamID(img.ply.sid64, 64)
    self.PlayerAvatar:SetVertices(30)
  end

  self.Title = {
    text = self.Notification.content,
    font = "XeninUI.Players.Notifications.Row.Title",
    color = Color(232, 232, 232)
  }
  self.Subtitle = {
    text = XeninUI:DateToString(self.Notification.createdAt),
    font = "XeninUI.Players.Notifications.Row.Subtitle",
    color = Color(175, 175, 175)
  }

  self.Button = self:Add("DButton")
  self.Button:SetText("")
  self.Button.Color = Color(87, 87, 87)
  XeninUI:DownloadIcon(self.Button, "oRwjOoj")
  self.Button.Paint = function(pnl, w, h)
    local s = 48 - 19
    XeninUI:DrawIcon(h * 0.5 - s / 4, h * 0.5 - s * 0.5, s, s, pnl, pnl.Color)
  end
  self.Button.OnCursorEntered = function(pnl)
    pnl:LerpColor("Color", XeninUI.Theme.Accent)
  end
  self.Button.OnCursorExited = function(pnl)
    pnl:LerpColor("Color", Color(87, 87, 87))
  end
  self.Button.DoClick = function(pnl)
    if self.TypeData.options then
      local options = XeninUI.Options(pnl)
      for i, v in ipairs(self.TypeData.options) do
        v(notification, options, self)
      end
      options:create()
    end
  end
  self.Button:SetVisible(self.TypeData.options)

  if (hooks and hooks.postInit) then
    hooks.postInit(notification, self)
  end
end

function PANEL:AddPaint(func)
  table.insert(self.OnPaint, func)
end

function PANEL:CalculateHeight()
  local h = 7 + draw.GetFontHeight(self.Subtitle.font) + 4
  local w = self:GetWide()

  if (w == 64) then
    w = 719
  end
  local lines = XeninUI:TextToLines(self.Title.text, self.Title.font, w - 48 - 24 - 8)
  h = h + (#lines * (draw.GetFontHeight(self.Title.font) - 2))

  return h
end

XeninUI:CreateFont("XeninUI.Players.Notifications.Row.Title", 18)
XeninUI:CreateFont("XeninUI.Players.Notifications.Row.Subtitle", 12)

function XeninUI:TextToLines(text, font, maxWidth)
  surface.SetFont(font)

  local strings = text:Split("\n")
  local lines = {}

  for i, str in ipairs(strings) do
    local buffer = {}
    for word in str:gmatch("%S+") do
      local w, h = surface.GetTextSize(table.concat(buffer, " ") .. " " .. word)
      if (w > maxWidth) then
        table.insert(lines, table.concat(buffer, " "))
        buffer = {}
      end

      table.insert(buffer, word)
    end

    if (#buffer > 0) then
      table.insert(lines, table.concat(buffer, " "))
    end
  end

  return lines
end

function XeninUI:DrawTextMultiline(text, font, x, y, col, xAlign, yAlign, maxWidth, spacing)
  if spacing == nil then spacing = draw.GetFontHeight(font)
  end
  local lines = self:TextToLines(text, font, maxWidth)

  local offset = y
  for i, v in ipairs(lines) do
    draw.SimpleText(v, font, x, offset, col, xAlign, yAlign)

    offset = offset + (spacing - 3)
  end
end

function PANEL:Paint(w, h)
  draw.RoundedBox(6, 0, 0, w, h, self.BackgroundColor)

  for i, v in ipairs(self.OnPaint) do
    v(self, w, h)
  end

  local x = 48
  draw.SimpleText("Job Disabled - " .. self.Subtitle.text, self.Subtitle.font, x, 7, self.Subtitle.color, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
  XeninUI:DrawTextMultiline(self.Title.text, self.Title.font, x, 7 + draw.GetFontHeight(self.Subtitle.font) * 2 + 4, self.Title.color, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM, w - 48 - 24 - 8)
end

function PANEL:PerformLayout(w, h)
  if IsValid(self.PlayerAvatar) then
    self.PlayerAvatar:SetPos(8, 8)
    self.PlayerAvatar:SetSize(h - 16, h - 16)
  end

  if IsValid(self.Button) then
    self.Button:SetSize(h - 8, h - 8)
    self.Button:AlignRight(0)
    self.Button:CenterVertical()
  end
end

vgui.Register("XeninUI.Players.Notifications.Row", PANEL)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/players/network/client.lua:
local NetworkClient
do
  local _class_0
  local _parent_0 = XeninUI.Network
  local _base_0 = {
    __name = "NetworkClient",
    __base = XeninUI.Network.__base,
    receiveNotification = function(self, ply)
      local noti = XeninUI.Players.NetworkHelper.receiveNotification()

      local str = noti.content:Split("\n")[1]
      local len = math.max(4, #str * 0.065)
      XeninUI:Notify(str, NOTIFY_HINT, len)
    end,
    receiveNotifications = function(self, ply)
      local amt = net.ReadUInt(8)
      local tbl = {}
      for i = 1, amt do
        table.insert(tbl, XeninUI.Players.NetworkHelper.receiveNotification())
      end

      hook.Run("XeninUI.Players.GotNotifications", tbl)
    end,
    sendReceiveNotifications = function(self)
      self:send("notifications", function(self) end)
    end,
    sendReadNotifications = function(self, ids)
      self:send("readNotifications", function(self)
        net.WriteUInt(#ids, 8)
        for i = 1, #ids do
          net.WriteUInt(ids[i], 32)
        end
      end)
    end,
    receiveReadNotifications = function(self, ply) end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__index)
  _class_0 = setmetatable({
    __init = function(self, ...)
      NetworkClient.__parent.__init(self, ...)

      self:setPrefix("Xenin.Players.")

      self:receiver("notification", self.receiveNotification)
      self:receiver("notifications", self.receiveNotifications)
      self:receiver("readNotifications", self.receiveReadNotifications)
    end,
    __base = _base_0,
    __parent = _parent_0
  }, {
    __index = function(cls, parent)
      local val = rawget(_base_0, parent)
      if val == nil then local _parent = rawget(cls, "__parent")
        if _parent then return _parent[parent]
        end
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0)
  end
  NetworkClient = _class_0
end

XeninUI.Players.Network = NetworkClient()

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/dropdown_popup.lua:
XeninUI:CreateFont("XeninUI.DropdownPopup", 19)

local PANEL = {}

AccessorFunc(PANEL, "m_backgroundColor", "BackgroundColor")
AccessorFunc(PANEL, "m_textColor", "TextColor")
AccessorFunc(PANEL, "m_accentColor", "AccentColor")
AccessorFunc(PANEL, "m_iconColor", "IconColor")

function PANEL:Init()
  self.choices = {}

  self.Alpha = 0
  self:LerpAlpha(255, 0.15)
  self:SetBackgroundColor(XeninUI.Theme.Primary)
  self:SetTextColor(color_white)
  self:SetAccentColor(XeninUI.Theme.Accent)
  self:SetIconColor(color_white)
  self:DockPadding(0, 8, 0, 8)
end

function PANEL:Paint(w, h)
  local aX, aY = self:LocalToScreen()

  BSHADOWS.BeginShadow()
  draw.RoundedBox(6, aX, aY, w, h, self:GetBackgroundColor())
  BSHADOWS.EndShadow(1, 2, 2)
end

function PANEL:AddChoice(name, onClick, textColor, accentColor, icon, iconColor)
  onClick = onClick or function()
    return true end

  local panel = vgui.Create("DButton", self)
  panel:Dock(TOP)
  panel:SetTall(48)
  panel:SetText(name)
  panel:SetFont("XeninUI.DropdownPopup")
  panel:SetTextInset(icon and 64 or 16, 0)
  panel:SetContentAlignment(4)
  panel:SetTextColor(textColor or self:GetTextColor())
  panel.alpha = 0
  panel.Paint = function(pnl, w, h)
    surface.SetDrawColor(ColorAlpha(accentColor or self:GetAccentColor(), pnl.alpha))
    surface.DrawRect(0, 0, w, h)
  end
  panel.OnCursorEntered = function(pnl)
    pnl:Lerp("alpha", 200)
  end
  panel.OnCursorExited = function(pnl)
    pnl:Lerp("alpha", 0)
  end
  panel.DoClick = function(pnl)
    onClick(pnl)

    self:Remove()
  end

  if icon then
    panel.icon = panel:Add("Panel")
    panel.icon:SetMouseInputEnabled(false)
    panel.icon.icon = icon
    panel.icon.CalculatePoly = function(self, w, h, vertices)
      local poly = {}

      local x = w * 0.5
      local y = h * 0.5
      local radius = h * 0.5

      table.insert(poly, {
        x = x,
        y = y
      })

      for i = 0, vertices do
        local a = math.rad((i / vertices) * -360)
        table.insert(poly, {
          x = x + math.sin(a) * radius,
          y = y + math.cos(a) * radius
        })
      end

      local a = math.rad(0)
      table.insert(poly, {
        x = x + math.sin(a) * radius,
        y = y + math.cos(a) * radius
      })
      self.data = poly
    end
    panel.icon.DrawPoly = function(self, w, h, vertices)
      if (!self.data) then
        self:CalculatePoly(w, h, vertices)
      end

      surface.DrawPoly(self.data)
    end
    panel.icon.Paint = function(pnl, w, h)
      render.ClearStencil()
      render.SetStencilEnable(true)

      render.SetStencilWriteMask(1)
      render.SetStencilTestMask(1)

      render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
      render.SetStencilPassOperation(STENCILOPERATION_ZERO)
      render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
      render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
      render.SetStencilReferenceValue(1)

      draw.NoTexture()
      surface.SetDrawColor(color_white)
      pnl:DrawPoly(w, h, 90)

      render.SetStencilFailOperation(STENCILOPERATION_ZERO)
      render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
      render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
      render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
      render.SetStencilReferenceValue(1)

      if pnl.icon then
        surface.SetDrawColor(iconColor or self:GetIconColor())
        surface.SetMaterial(pnl.icon)
        surface.DrawTexturedRect(0, 0, w, h)
      end

      render.SetStencilEnable(false)
      render.ClearStencil()
    end
    panel.PerformLayout = function(pnl, w, h)
      pnl.icon:SetPos(16, 6)
      pnl.icon:SetSize(h - 12, h - 12)
    end
  end

  local i = table.insert(self.choices, {
    panel = panel,
    str = name
  })

  self:InvalidateLayout()

  return panel
end

function PANEL:PerformLayout(w, h)
  local longest = 0

  surface.SetFont("XeninUI.DropdownPopup")
  for i, v in pairs(self.choices) do
    local tw = surface.GetTextSize(v.str)
    tw = tw + 16
    tw = tw + 16
    if v.panel.icon then
      tw = tw + 48
    end

    if (tw > longest) then
      longest = math.max(112, tw)
    end
  end

  self:SetWide(longest)
  self:SetTall(8 + #self.choices * 48 + 8)
end

function PANEL:OnFocusChanged(gained)
  if (!IsValid(self)) then return end
  if gained then return end
  if self.ignore then return end

  self:Remove()
end

function PANEL:Think()
  local w, h = self:GetSize()
  local x, y = self.x, self.y
  x = math.Clamp(x, 0, ScrW() - w)
  y = math.Clamp(y, 0, ScrH() - h)

  self:SetPos(x, y)
end

vgui.Register("XeninUI.DropdownPopup", PANEL, "EditablePanel")

function XeninUI:DropdownPopup(x, y)
  local panel = vgui.Create("XeninUI.DropdownPopup", vgui.GetWorldPanel())
  panel:SetDrawOnTop(true)
  panel:SetPos(x + 12, y + 12)
  panel:MakePopup()

  return panel
end

XeninUI:CreateFont("XeninUI.QueryPopup.Title", 19, 800)
XeninUI:CreateFont("XeninUI.QueryPopup.Subtitle", 16, 800)
XeninUI:CreateFont("XeninUI.QueryPopup.Button", 18, 800)

local PANEL = {}

AccessorFunc(PANEL, "m_title", "Title")
AccessorFunc(PANEL, "m_subtitle", "Subtitle")
AccessorFunc(PANEL, "m_subtitleColor", "SubtitleColor")

function PANEL:Init()
  self:DockPadding(8, 8, 8, 8)
  self:SetTall(96)

  self.onCancel = function() end
  self.onAccept = function() end

  self.title = vgui.Create("DLabel", self)
  self.title:Dock(TOP)
  self.title:SetText("Equip this booster?")
  self.title:SetFont("XeninUI.QueryPopup.Title")
  self.title:SetTextColor(color_black)

  self.subtitle = vgui.Create("DLabel", self)
  self.subtitle:Dock(TOP)
  self.subtitle:DockMargin(0, -2, 0, 0)
  self.subtitle:SetTextColor(Color(75, 75, 75))
  self.subtitle:SetFont("XeninUI.QueryPopup.Subtitle")

  self.bottom = vgui.Create("Panel", self)
  self.bottom:Dock(BOTTOM)
  self.bottom:SetTall(32)

  self.cancel = vgui.Create("DButton", self.bottom)
  self.cancel:Dock(RIGHT)
  self.cancel:DockMargin(8, 0, 0, 0)
  self.cancel:SetText("Cancel")
  self.cancel:SetTextColor(XeninUI.Theme.Red)
  self.cancel:SetFont("XeninUI.QueryPopup.Button")
  self.cancel.Paint = function(pnl, w, h)
    draw.RoundedBox(6, 0, 0, w, h, Color(220, 220, 220))
  end
  self.cancel.DoClick = function(pnl)
    self:onCancel()

    self:Remove()
  end
  local tw, th = surface.GetTextSize(self.cancel:GetText())
  self.cancel:SetWide(tw + 24)

  self.unlock = vgui.Create("DButton", self.bottom)
  self.unlock:Dock(RIGHT)
  self.unlock:SetText("Accept")
  self.unlock:SetTextColor(XeninUI.Theme.Green)
  self.unlock:SetFont("XeninUI.QueryPopup.Button")
  self.unlock.Paint = function(pnl, w, h)
    draw.RoundedBox(6, 0, 0, w, h, Color(220, 220, 220))
  end
  self.unlock.DoClick = function(pnl)
    self:onAccept()

    self:Remove()
  end
  surface.SetFont(self.unlock:GetFont())
  local tw, th = surface.GetTextSize(self.unlock:GetText())
  self.unlock:SetWide(tw + 16)

  surface.SetFont(self.title:GetFont())
  local tw, th = surface.GetTextSize(self.title:GetText())
  self:SetWide(tw + 16)
end

function PANEL:Paint(w, h)
  draw.RoundedBox(6, 0, 0, w, h, color_white)
end

function PANEL:OnFocusChanged(gained)
  if (!IsValid(self)) then return end
  if gained then return end
  if self.ignore then return end

  self:Remove()
end

vgui.Register("XeninUI.QueryPopup", PANEL, "EditablePanel")

function XeninUI:Popup(x, y, title, subtitle, onUnlock, onCancel, hideUnlock, titleColor, subtitleColor, acceptText)
  local panel = vgui.Create("XeninUI.QueryPopup")
  panel:SetDrawOnTop(true)
  panel:SetMouseInputEnabled(true)
  panel:SetPos(x + 12, y + 12 - 12)
  panel.title:SetText(title or "Title")
  panel.subtitle:SetText(subtitle or "Subtitle")

  if subtitleColor then
    panel.subtitle:SetTextColor(subtitleColor)
  end

  if titleColor then
    panel.title:SetTextColor(titleColor)
  end

  if acceptText then
    panel.unlock:SetText(acceptText)
  end

  if onUnlock then
    panel.onAccept = onUnlock

    local tw, th = surface.GetTextSize(panel.unlock:GetText())
    panel.unlock:SetWide(tw + 16)
  end
  if onCancel then
    panel.onCancel = onCancel

    local tw, th = surface.GetTextSize(panel.cancel:GetText())
    panel.cancel:SetWide(tw + 24)
  end
  if hideUnlock then
    panel.unlock:Remove()
    panel:InvalidateLayout()
  end

  surface.SetFont(panel.unlock:GetFont())
  local tw, th = surface.GetTextSize(panel.unlock:GetText())
  panel.unlock:SetWide(tw + 16)

  surface.SetFont(panel.title:GetFont())
  local tw, th = surface.GetTextSize(panel.title:GetText())
  panel:SetWide(math.max(192, tw + 16))

  return panel
end

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/options.lua:
local function __laux_concat_0(...)
  local arr = {
  ...
  }
  local result = {}
  for _, obj in ipairs(arr) do
    for i = 1, #obj do
      result[#result + 1] = obj[i]
    end
    for k, v in pairs(obj) do
      if type(k) == "number" and k > #obj then result[k] = v
      elseif type(k) ~= "number" then
        result[k] = v
      end
    end
  end
  return result
end
local PANEL = {}

AccessorFunc(PANEL, "m_font", "Font")

XeninUI:CreateFont("XeninUI.Options.Button", 22)

function PANEL:Init()
  self:SetDrawOnTop(true)
  self:SetZPos(125)
  self:DockPadding(8, 8, 8, 8)
  self.Alpha = 0
  self:LerpAlpha(255, 0.3)
  self:SetFont("XeninUI.Options.Button")
end

function PANEL:OnFocusChanged(gained)
  if (gained) then return end

  self:Close()
end

function PANEL:Close()
  if (self.Removing) then return end

  self.Removing = true
  self:LerpAlpha(255, 0.1)
  self:LerpHeight(0, 0.1, function()
    if (!IsValid(self)) then return end

    self:Remove()
  end)
end

function PANEL:GetNewSize()
  local width = 16
  local height = 16

  local children = self:GetChildren()
  local size = #children
  for i, v in ipairs(children) do
    if (v.RowType == self.Options.BUTTON) then
      surface.SetFont(v.Font)
      local tW = surface.GetTextSize(v.Text)

      tW = tW + 32

      if v.IconBackground then tW = tW + 53
      end

      width = math.max(width, tW)
    end

    height = height + v:GetTall()
    if (i != size) then height = height + 8
    end
  end

  return math.max(150, width), height
end

function PANEL:UpdatePos()
  local parent = self.Parent
  if (!IsValid(parent)) then self:Remove()end

  local aX, aY = parent:LocalToScreen()
  local x = self:GetWide() - parent:GetWide()
  local y = parent:GetTall()
  self:SetPos(aX - x, aY + y)
end

function PANEL:CreateButton(data)
  local btn = self:Add("DButton")
  btn:SetTall(53)
  btn:SetText("")
  local hoverColor = data.hoverColor or XeninUI.Theme.Primary
  btn.Background = ColorAlpha(hoverColor, 0)
  btn.Text = data.text
  btn.TextColor = data.textColor or color_white
  btn.Font = data.font or self:GetFont()
  if data.icon then
    XeninUI:DownloadIcon(btn, data.icon)
    btn.IconBackground = Color(58, 58, 58)
    btn.IconColor = data.iconColor or btn.TextColor
    btn.IconHoverColor = data.iconHoverColor or btn.IconColor
  end
  btn.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.Background)

    local x = 8
    if pnl.Icon then
      local size = h - 16
      XeninUI:DrawCircle(x + size * 0.5, size * 0.5 + x, size * 0.5, 30, pnl.IconBackground)
      size = size - 16
      XeninUI:DrawIcon(x + 8, 16, size, size, pnl, pnl.IconColor)

      x = x + h
    end

    draw.SimpleText(pnl.Text, pnl.Font, x, h * 0.5, pnl.TextColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
  end
  btn.PaintOver = function(pnl, w, h)
    if (!pnl.Pressing) then return end
    local frac = math.TimeFraction(pnl.Pressing, pnl.End, CurTime())
    local col = XeninUI:LerpColor(frac, XeninUI.Theme.Red, XeninUI.Theme.Green)

    local aX, aY = pnl:LocalToScreen()
    render.SetScissorRect(aX, aY, aX + (w * frac), aX + h, true)
    XeninUI:DrawRoundedBox(6, 0, 0, w, h, ColorAlpha(data.hold.color, 100))
    render.SetScissorRect(0, 0, ScrW(), ScrH(), false)
  end
  btn.OnCursorEntered = function(pnl)
    pnl:LerpColor("Background", ColorAlpha(hoverColor, 100))
    if data.icon then
      pnl:LerpColor("IconColor", pnl.IconHoverColor)
    end
  end
  btn.OnCursorExited = function(pnl)
    pnl:LerpColor("Background", ColorAlpha(hoverColor, 0))
    if data.icon then
      pnl:LerpColor("IconColor", data.iconColor or btn.TextColor)
    end
  end
  if data.hold then
    btn.Think = function(pnl)
      if (!pnl.Pressing) then return end
      local frac = math.Clamp(math.TimeFraction(pnl.Pressing, pnl.End, CurTime()), 0, 1)
      if (frac < 1) then return end
      if (pnl.Clicked) then return end
      pnl.Clicked = true

      if data.onClick then
        data:onClick(pnl)
      end

      self:Close()
    end
    btn.OnMousePressed = function(pnl)
      local wait = data.hold.time
      local time = CurTime()

      pnl.Clicked = nil
      pnl.Pressing = time
      pnl.End = CurTime() + wait
    end
    btn.OnMouseReleased = function(pnl)
      pnl.Clicked = nil
      pnl.Pressing = nil
      pnl.End = nil
    end
  else
    btn.DoClick = function(pnl)
      if data.onClick then
        local stop = data:onClick(pnl) != nil

        if (stop) then return end
      end

      self:Close()
    end
  end

  return btn
end

function PANEL:CreateDivider(data)
  local divider = self:Add("DPanel")
  divider:SetTall(data.thickness or 1)
  divider.Color = data.color or Color(64, 64, 64)
  divider.Paint = function(pnl, w, h)
    surface.SetDrawColor(pnl.Color)
    surface.DrawRect(0, 0, w, h)
  end

  return divider
end

function PANEL:SetOptions(options)
  self.Options = options
  assert(options ~= nil, "cannot destructure nil value")
  local rows, BUTTON, DIVIDER = options.rows, options.BUTTON, options.DIVIDER

  for i, v in ipairs(rows) do
    local row
    if (v.rowType == BUTTON) then
      row = self:CreateButton(v)
    elseif (v.rowType == DIVIDER) then
      row = self:CreateDivider(v)
    end

    row:Dock(TOP)
    row:DockMargin(0, 0, 0, 8)
    row.RowType = v.rowType
  end

  local width, height = self:GetNewSize()
  self:SetWide(width)
  self:SetTall(0)
  self:LerpHeight(height, 0.3)
  self:MakePopup()
  self:UpdatePos()
end

function PANEL:Think()
  if (!self.Parent) then return end

  if (!IsValid(self.Parent)) then
    return self:Close()
  end

  if (!self.Parent:IsVisible()) then
    return self:Close()
  end
end

function PANEL:Paint(w, h)
  local aX, aY = self:LocalToScreen()

  BSHADOWS.BeginShadow()
  XeninUI:DrawRoundedBox(6, aX, aY, w, h, XeninUI.Theme.Background)
  BSHADOWS.EndShadow(1, 1, 1, 150 * (255 / self:GetAlpha()))

  XeninUI:MaskInverse(function()
    XeninUI:DrawRoundedBox(6, 1, 1, w - 2, h - 2, XeninUI.Theme.Background)
  end, function()
    XeninUI:DrawRoundedBox(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Primary, self:GetAlpha()))
  end)
end

vgui.Register("XeninUI.Options", PANEL, "EditablePanel")

do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Options",
    addButton = function(self, data)
      table.insert(self.rows, __laux_concat_0({
      rowType = self.BUTTON
      }, data))

      return self
    end,
    addDivider = function(self, data)
      if data == nil then data = {}
      end
      table.insert(self.rows, __laux_concat_0({
      rowType = self.DIVIDER
      }, data))

      return self
    end,
    create = function(self)
      self.panel = vgui.Create("XeninUI.Options")
      self.panel.Parent = self.parent
      self.panel:SetOptions(self)

      return self.panel
    end,
    __type = function(self)
      return "XeninUI.Options"end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, parent)
      self.rows = {}
      self.DIVIDER = 1
      self.BUTTON = 0
      self.parent = parent
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Options = _class_0
end

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/sidebar.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.Sidebar.Category.Title", 22)

AccessorFunc(PANEL, "m_body", "Body")
AccessorFunc(PANEL, "m_backgroundColor", "BackgroundColor")

function PANEL:Init()
  self:SetBackgroundColor(XeninUI.Theme.Navbar)

  self.buttons = {}
  self.panels = {}

  self:DockPadding(0, 0, 0, 0)
end

function PANEL:AddCategory(name)
  local panel = self:Add("Panel")
  panel:Dock(TOP)
  panel:DockMargin(0, 8, 0, 8)
  panel:SetTall(25)
  panel.color = Color(202, 202, 202)
  panel.Paint = function(pnl, w, h)
    draw.SimpleText(name, "XeninUI.Sidebar.Category.Title", w * 0.5, 0, pnl.color, TEXT_ALIGN_CENTER)
    surface.SetFont("XeninUI.Sidebar.Category.Title")
    local tw, th = surface.GetTextSize(name)

    surface.SetDrawColor(pnl.color)
    surface.DrawLine(10, th + 2, w - 10, th + 2)
  end
end

function PANEL:AddTab(name, icon, panelClass, panelFunc)
  local button = self:Add("XeninUI.Sidebar.Category")
  button:Dock(TOP)
  button:SetName(name)
  button:SetIcon(icon)
  button.OnMouseReleased = function(pnl)
    self:SetActive(pnl.Id)
  end
  button.panelClass = panelClass
  button.OnPanelCreated = function(pnl, panel)
    panelFunc(pnl, panel)
  end

  local id = table.insert(self.buttons, button)
  button.Id = id
end

function PANEL:SetActive(id, instant)
  if (self.active == id) then return end
  if (self.active and self.buttons[self.active]) then
    self.buttons[self.active].active = false
    self.buttons[self.active]:OnCursorExited()

    if IsValid(self.panels[self.active]) then
      self.panels[self.active]:SetVisible(false)
    end
  end

  self.active = id
  self.buttons[id].active = true

  if (!IsValid(self.panels[id])) then
    local panel = self:GetBody():Add(self.buttons[id].panelClass)
    panel:Dock(FILL)

    self.panels[id] = panel
    self.buttons[id]:OnPanelCreated(self.panels[id])
  else
    self.panels[id]:SetVisible(true)
  end

  if self.panels[id].OnSwitchedTo then
    self.panels[id]:OnSwitchedTo(self.buttons[id]:GetName())
  end

  if instant then
    self.buttons[id].Color = color_white
    self.buttons[id].Alpha = 255
  else
    self.buttons[id]:LerpColor("Color", color_white)
    self.buttons[id]:Lerp("Alpha", 255)
  end

  self:OnActiveChanged(id)
end

function PANEL:OnActiveChanged(id) end

function PANEL:PerformLayout(w, h)
  local width = 0

  surface.SetFont("XeninUI.Sidebar.Category")
  for i, v in pairs(self.buttons) do
    local tw = surface.GetTextSize(v:GetName())
    tw = tw + 64

    if (tw > width) then
      width = tw
    end

    v:SetTall(48)
  end

  self:SetWide(width)
end

function PANEL:Paint(w, h)
  draw.RoundedBoxEx(6, 0, 0, w, h, self:GetBackgroundColor(), false, false, true, false)
end

vgui.Register("XeninUI.Sidebar", PANEL)


local PANEL = {}

XeninUI:CreateFont("XeninUI.Sidebar.Category", 20)

local matGradientSidebar = Material("xenin/gradient_ltr.png")

AccessorFunc(PANEL, "m_name", "Name")
AccessorFunc(PANEL, "m_icon", "Icon")

function PANEL:Init()
  self.Color = Color(140, 140, 140)
  self.Alpha = 0
  self:SetCursor("hand")
end

function PANEL:OnCursorEntered()
  if self.active then return end

  self:Lerp("Alpha", 255)
  self:LerpColor("Color", Color(200, 200, 200))
end

function PANEL:OnCursorExited()
  if self.active then return end

  self:Lerp("Alpha", 0)
  self:LerpColor("Color", Color(140, 140, 140))
end

function PANEL:Paint(w, h)
  surface.SetMaterial(matGradientSidebar)
  surface.SetDrawColor(ColorAlpha(XeninUI.Theme.Accent, self.Alpha))
  surface.DrawTexturedRect(0, 0, w, h)

  local offset = 16
  if self:GetIcon() then
    surface.SetDrawColor(self.Color)
    surface.SetMaterial(self:GetIcon())
    surface.DrawTexturedRect(10, 10, h - 20, h - 20)

    offset = h
  end

  draw.SimpleText(self:GetName():upper(), "XeninUI.Sidebar.Category", offset, h * 0.5, self.Color, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
end

vgui.Register("XeninUI.Sidebar.Category", PANEL)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/textentry.lua:
XeninUI:CreateFont("XeninUI.TextEntry", 18)

local PANEL = {}

AccessorFunc(PANEL, "m_backgroundColor", "BackgroundColor")
AccessorFunc(PANEL, "m_rounded", "Rounded")
AccessorFunc(PANEL, "m_placeholder", "Placeholder")
AccessorFunc(PANEL, "m_textColor", "TextColor")
AccessorFunc(PANEL, "m_placeholderColor", "PlaceholderColor")
AccessorFunc(PANEL, "m_iconColor", "IconColor")

function PANEL:Init()
	self:SetBackgroundColor(XeninUI.Theme.Navbar)
	self:SetRounded(6)
	self:SetPlaceholder("")
	self:SetTextColor(Color(205, 205, 205))
	self:SetPlaceholderColor(Color(120, 120, 120))
	self:SetIconColor(self:GetTextColor())

	self.textentry = vgui.Create("DTextEntry", self)
	self.textentry:Dock(FILL)
	self.textentry:DockMargin(8, 8, 8, 8)
	self.textentry:SetFont("XeninUI.TextEntry")
	self.textentry:SetDrawLanguageID(false)
	self.textentry.Paint = function(pnl, w, h)
		local col = self:GetTextColor()

		pnl:DrawTextEntryText(col, col, col)

		if (#pnl:GetText() == 0) then
			draw.SimpleText(self:GetPlaceholder() or "", pnl:GetFont(), 3, pnl:IsMultiline() and 8 or h * 0.5, self:GetPlaceholderColor(), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end
	end
	self.textentry.OnValueChange = function(pnl, text)
		self:OnValueChange(text)
	end
end

function PANEL:SetNumeric(bool)
	self.textentry:SetNumeric(true)end
function PANEL:GetNumeric()
	return self.textentry:GetNumeric()end
function PANEL:SetUpdateOnType(bool)
	self.textentry:SetUpdateOnType(true)end
function PANEL:GetUpdateOnType()
	return self.textentry:GetUpdateOnType()end
function PANEL:OnValueChanged() end

function PANEL:SetFont(str)
	self.textentry:SetFont(str)
end

function PANEL:GetFont()
	return self.textentry:GetFont()
end

function PANEL:GetText()
	return self.textentry:GetText()
end

function PANEL:SetText(str)
	self.textentry:SetText(str)
end

function PANEL:SetMultiLine(state)
	self:SetMultiline(state)
	self.textentry:SetMultiline(state)
end

function PANEL:SetLabel(label, left, textColor, offset)
	if offset == nil then offset = 0
	end
	if IsValid(self.label) then self.label:Remove()end

	self.label = self:Add("DLabel")
	self.label:Dock(left and LEFT or RIGHT)
	self.label:DockMargin(left and 10 or -5, 10, (left and -9 or 8) - offset, 10)
	self.label:SetText(label)
	self.label:SetTextColor(textColor or ColorAlpha(self:GetTextColor(), 175))
	self.label:SetFont(self.textentry:GetFont())
	self.label:SizeToContentsX()
end

function PANEL:SetIcon(icon, left)
	if (!IsValid(self.icon)) then
		self.icon = vgui.Create("DButton", self)
		self.icon:SetText("")
		self.icon:Dock(left and LEFT or RIGHT)
		self.icon:DockMargin(left and 10 or -5, 10, left and 0 or 10, 10)
		self.icon.Paint = function(pnl, w, h)
			surface.SetDrawColor(self:GetIconColor())
			surface.SetMaterial(pnl.mat)
			surface.DrawTexturedRect(0, 0, w, h)
		end
		self.icon.DoClick = function(pnl)
			self.textentry:RequestFocus()
		end
	end

	self.icon.mat = icon
end

function PANEL:PerformLayout(w, h)
	if IsValid(self.icon) then
		self.icon:SetWide(self.icon:GetTall())
	end
end

function PANEL:OnMousePressed()
	self.textentry:RequestFocus()
end

function PANEL:Paint(w, h)
	draw.RoundedBox(self:GetRounded(), 0, 0, w, h, self:GetBackgroundColor())
end

vgui.Register("XeninUI.TextEntry", PANEL)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/core/ui/main.lua:
local PANEL = {}

XeninUI:CreateFont("Xenin.Framework.Load", 48)
XeninUI:CreateFont("Xenin.Framework.Tab", 20)

function PANEL:Init()
  self:SetSize(XeninUI.Frame.Width, XeninUI.Frame.Height)
  self:Center()
  self:SetTitle("Xenin Framework - Admin")
  self:MakePopup()

  self:AddHook("Xenin.Framework.ReceivedScripts", "Xenin.Framework", function(self, scripts)
    self:CreateSidebar()
  end)

  XeninUI.ScriptsNetwork:requestScripts()
end

function PANEL:CreateCategory(name, col)
  if col == nil then col = Color(64, 64, 64)
  end
  local panel = self.Sidebar.Scroll:Add("DPanel")
  panel:Dock(TOP)
  panel:SetTall(draw.GetFontHeight("Xenin.Framework.Tab") + 16)
  panel.Paint = function(pnl, w, h)
    draw.SimpleText(name, "Xenin.Framework.Tab", w * 0.5, h * 0.5, Color(212, 212, 212), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

    surface.SetDrawColor(col)
    if (name != "1st party") then
      surface.DrawRect(0, 0, w, 1)
    end
    surface.DrawRect(0, h - 1, w, 1)
  end
end

function PANEL:CreateSidebar(tbl)
  self.Sidebar = self:Add("XeninUI.SidebarV2")
  self.Sidebar:Dock(LEFT)
  self.Sidebar:SetBody(self)

  local scripts = XeninUI.Scripts:getAll()


  for i, v in pairs(scripts) do
    self.Sidebar:CreatePanel(v.name, v.desc, "Xenin.Framework.Tab", v.icon, v)
  end





  self.Sidebar:SetActive(1)
end

function PANEL:PerformLayout(w, h)
  self.BaseClass.PerformLayout(self, w, h)

  if (!IsValid(self.Sidebar)) then return end

  local sw = 0
  for i, v in ipairs(self.Sidebar.Sidebar) do
    surface.SetFont("XeninUI.SidebarV2.Name")
    local nameTw = surface.GetTextSize(v.Name or "")
    surface.SetFont("XeninUI.SidebarV2.Desc")
    local descTw = surface.GetTextSize(v.Desc or "")

    local tw = math.max(nameTw, descTw) + 8
    if v.Icon then
      tw = tw + 68
    end

    sw = math.max(sw, tw)
  end

  self.Sidebar:SetWide(math.max(140, sw))
end

function PANEL:Paint(w, h)
  self.BaseClass.Paint(self, w, h)

  if self.Sidebar then return end

  XeninUI:DrawLoadingCircle(w * 0.5, h * 0.5 + 18, h / 4)
  XeninUI:DrawShadowText("Loading all addons", "Xenin.Framework.Load", w * 0.5, h * 0.5 - h / 8, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 1, 150)
end

vgui.Register("Xenin.Framework", PANEL, "XeninUI.Frame")

concommand.Add("xenin_admin", function()
  if (!XeninUI.Permissions:canAccessFramework(LocalPlayer())) then
    chat.AddText(XeninUI.Theme.Red, "[Xenin] ", color_white, "You don't have the required authority to do this")

    return
  end

  vgui.Create("Xenin.Framework")
end)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/units/classes/result.lua:
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Units.Result",
    setError = function(self, err)
      self.returnVal = err end,
    setSuccess = function(self, bool)
      self.success = bool end,
    getReturn = function(self)
      return self.returnVal end,
    isSuccess = function(self)
      return self.success end,
    getMessagePrint = function(self)
      local prefix = self.success and "+" or "-"
      local color = self.success and XeninUI.Theme.Green or XeninUI.Theme.Red
      local str = tostring(prefix) .. " " .. tostring(self.name)
      if (!self.success) then str = str .. " ** FAILED **"
        if isstring(self.returnVal) then

          local errMsg = self.returnVal:Split("stack traceback")
          errMsg = errMsg[1]:sub(1, #errMsg[1] - 1)
          str = str .. "\nError was: " .. tostring(errMsg)
        end
      end

      return {
        color,
        str
      }
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, name, success, returnVal)
      self.isResult = true

      self.name = name
      self.success = success
      self.returnVal = returnVal
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Units.Result = _class_0
end

--PATH addons/battlepass/lua/battlepass/challenges/posidet_v_turme_5_raz.lua:
local CHALLENGE = BATTLEPASS:CreateTemplateChallenge()
CHALLENGE:SetName("Посидіти у в'язниці 5 разів")
CHALLENGE:SetIcon("battlepass/challenges/shipments.png") -- <- ??
CHALLENGE:SetDesc("")
CHALLENGE:SetProgressDesc("---")
CHALLENGE:SetFinishedDesc("---")
CHALLENGE:SetID("posidet_v_turme_5_raz")
CHALLENGE:SetPremium(true)

CHALLENGE:AddHook("playerArrested", function(self, ply, _ply)
  if IsValid( _ply ) and ply == _ply and _ply.BattlePass.Owned.owned then
    self:AddProgress(1)
    self:NetworkProgress()
  end
end)

BATTLEPASS:RegisterChallenge(CHALLENGE)
--PATH addons/battlepass/lua/battlepass/challenges/vzlom_kvartir_5.lua:
local CHALLENGE = BATTLEPASS:CreateTemplateChallenge()
CHALLENGE:SetName("Взломати 5 квартир за злодія")
CHALLENGE:SetIcon("battlepass/challenges/shipments.png") -- <- ??
CHALLENGE:SetDesc("")
CHALLENGE:SetProgressDesc("---")
CHALLENGE:SetFinishedDesc("---")
CHALLENGE:SetID("vzlom_kvartir_5")

CHALLENGE:AddHook("PlayerFinishLockpicking", function(self, ply, _ply)
  if IsValid( _ply ) and ply == _ply and (_ply:Team() == TEAM_THIEFF_VIP or _ply:Team() == TEAM_THIEFF) then
    self:AddProgress(1)
    self:NetworkProgress()
  end
end)

BATTLEPASS:RegisterChallenge(CHALLENGE)
--PATH addons/battlepass/lua/battlepass/challenges/zareshuite_5_ludey_za_professiy_policeiskiy.lua:
local CHALLENGE = BATTLEPASS:CreateTemplateChallenge()
CHALLENGE:SetName("Заарештуй 5 людей за професію поліцейського")
CHALLENGE:SetIcon("battlepass/challenges/shipments.png") -- <- ??
CHALLENGE:SetDesc("")
CHALLENGE:SetProgressDesc("---")
CHALLENGE:SetFinishedDesc("---")
CHALLENGE:SetID("zareshuite_5_ludey_za_professiy_policeiskiy")

CHALLENGE:AddHook("playerArrest_BattlePass", function(self, ply, _ply)
  if IsValid( _ply ) and ply == _ply and _ply:Team() == TEAM_POLICE then
    self:AddProgress(1)
    self:NetworkProgress()
  end
end)

BATTLEPASS:RegisterChallenge(CHALLENGE)
--PATH addons/battlepass/lua/battlepass/rewards/giveweapon.lua:
local REWARD = BATTLEPASS:CreateReward()

function REWARD:CanUnlock(ply, reward)
    return true
end

function REWARD:GetTooltip(reward)
    return reward.name
end

function REWARD:GetModel(reward)
    return reward.model
end

function REWARD:GetName(reward)
    return reward.name
end

function REWARD:Unlock(ply, reward)
    if CLIENT then return end
    local i = itemstore.Item( "spawned_weapon" )
    i:SetData( "Class", reward.entity )
    i:SetModel( reward.model )
    for _ = 1, reward.current do
        ply.Inventory:AddItem( i )
    end
end

REWARD:Register("giveweapon")
--PATH addons/battlepass/lua/battlepass/menu/navbar.lua:
local PANEL = {}

function PANEL:Init()
	self.buttons = {}
	self.panels = {}
	self.buttonsNum = {}

	self.font = "font_bpcategory"
	self.textActive = ColorAlpha(color_white, 100)
	self.boxActive = Color(0, 0, 0, 0)
	self.padding = 24
	self.minSize = 80
	self.dockLeft = 0
	self.animation = "alpha"

	self.active = 0
	self.showline = false
end

function PANEL:SetShowLine(bool)
	self.showline = bool
end

function PANEL:AddTab(name, panel, tbl)

	self.buttonsNum[#self.buttonsNum + 1] = name

	self.buttons[name] = vgui.Create("DButton", self)
	if (!tbl or (tbl and !tbl.dontDock)) then
		self.buttons[name]:Dock(LEFT)
	end
	self.buttons[name]:SetText(name)
	self.buttons[name]:SetFont(self.font)
	self.buttons[name].textColor = color_white
	self.buttons[name].boxColor = color_white
	self.buttons[name].Paint = function(pnl, w, h)
		pnl:SetTextColor(pnl.textColor)
		if self.showline then
			draw.RoundedBox(0, W(11), h - H(1), w - W(22), H(1), pnl.boxColor)
		end
	end
	self.buttons[name].DoClick = function(pnl)
		self:SetActive(name)
	end
	self.buttons[name].OnCursorEntered = function(pnl)
		pnl:LerpColor("textColor", self.textActive)
		pnl:LerpColor("boxColor", self.boxActive)
	end
	self.buttons[name].OnCursorExited = function(pnl)
		if (self.active == name) then return end

		pnl:LerpColor("textColor", color_white)
		pnl:LerpColor("boxColor", color_white)
	end

	surface.SetFont(self.font)
	local tw = surface.GetTextSize(name)
	self.buttons[name]:SetWide(math.max(self.minSize, tw + self.padding))

	if (!panel) then panel = "Panel"end

	self.panels[name] = vgui.Create(panel, self.body)
	self.panels[name]:Dock(FILL)
	self.panels[name]:SetVisible(false)
	self.panels[name].Data = tbl

	if self.panels[name].SetData then
		self.panels[name]:SetData(tbl)
	end

	if (tbl and tbl.PostInit) then
		tbl.PostInit(self.panels[name])
	end

	return self.panels[name]
end

function PANEL:FindIndex(name)
	for i, v in pairs(self.buttonsNum) do
		if (v != name) then continue end

		return i
	end
end

function PANEL:SetActive(name)
	if (self.active == name) then return end

	local instant = !IsValid(self.buttons[self.active])
	if self.buttons[self.active] then
		self.buttons[self.active]:LerpColor("textColor", color_white)
		self.buttons[self.active]:LerpColor("boxColor", color_white)
	end

	if self.panels[self.active] then
		if (self.animation == "alpha") then
			local pnl = self.panels[self.active]
			pnl.DrawAlpha = pnl.DrawAlpha or 0
			pnl:SetVisible(false)
		else
			local pnl = self.panels[self.active]
			pnl:SetVisible(false)
		end

		if self.panels[name].OnSwitchedFrom then
			self.panels[name]:OnSwitchedFrom()
		end
	end

	self.active = name

	if self.buttons[name] then
		if instant then
			self.buttons[name].textColor = self.textActive
			self.buttons[name].boxColor = self.boxActive
			surface.SetFont(self.font)
		else
			self.buttons[name]:LerpColor("textColor", self.textActive)
			self.buttons[name]:LerpColor("boxColor", self.boxActive)
			surface.SetFont(self.font)
		end
	end

	if self.panels[name] then
		if instant then
			local pnl = self.panels[name]
			pnl:SetVisible(true)
		else
			if (self.animation == "alpha") then
				if (!IsValid(self)) then return end

				local pnl = self.panels[name]
				pnl.DrawAlpha = pnl.DrawAlpha or 255
				pnl:SetVisible(true)
			else
				local pnl = self.panels[name]
				pnl:SetVisible(true)
			end
		end

		if self.panels[name].OnSwitchedTo then
			self.panels[name]:OnSwitchedTo(name)
		end
	end

	self:SwitchedTab(name)
end

function PANEL:SwitchedTab(name) end

function PANEL:GetActive()
	return self.panels[self.active]
end

function PANEL:SetBody(pnl, pnl2)
	self.body = pnl:Add("Panel")
	self.body:Dock(FILL)
	self.body.Offset = 0
	self.body.PerformLayout = function(pnl, w, h)
		pnl2.imagetype = self.active
		local num = 0
		for i, v in pairs(self.panels) do
			local x = num * w - (pnl.Offset * w)

			v:SetSize(w, h)
			v:SetPos(x, 0)
		end
	end
end

function PANEL:Paint(w, h)
end

vgui.Register("BATTLEPASS.Navbar_", PANEL)
--PATH addons/____bricks_framework/lua/bricks_server/bricks_server_devcfg_main.lua:
--[[
    !!WARNING!!
        ALL CONFIG IS DONE INGAME, DONT EDIT ANYTHING HERE
        Type !bricksserver ingame or use the f4menu
    !!WARNING!!
]]--

BRICKS_SERVER.DEVCONFIG.BaseThemes = {}
BRICKS_SERVER.DEVCONFIG.BaseThemes.Red = Color(201, 70, 70)
BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed = Color(181, 50, 50)
BRICKS_SERVER.DEVCONFIG.BaseThemes.Green = Color(46, 204, 113)
BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen = Color(39, 174, 96)
BRICKS_SERVER.DEVCONFIG.BaseThemes.Gold = Color(201,176,55)
BRICKS_SERVER.DEVCONFIG.BaseThemes.Silver = Color(180,180,180)
BRICKS_SERVER.DEVCONFIG.BaseThemes.Bronze = Color(173,138,86)
BRICKS_SERVER.DEVCONFIG.BaseThemes.White = Color( 255, 255, 255 )
BRICKS_SERVER.DEVCONFIG.BaseThemes.Black = Color( 0, 0, 2505 )

BRICKS_SERVER.DEVCONFIG.AccentThemes = {}
BRICKS_SERVER.DEVCONFIG.AccentThemes["Turquoise"] = { Color(22, 160, 133), Color(26, 188, 156) }
BRICKS_SERVER.DEVCONFIG.AccentThemes["Emerald"] = { Color(39, 174, 96), Color(46, 204, 113) }
BRICKS_SERVER.DEVCONFIG.AccentThemes["Blue"] = { Color(41, 128, 185), Color(52, 152, 219) }
BRICKS_SERVER.DEVCONFIG.AccentThemes["Amethyst"] = { Color(142, 68, 173), Color(155, 89, 182) }
BRICKS_SERVER.DEVCONFIG.AccentThemes["Yellow"] = { Color(243, 156, 18), Color(241, 196, 15) }
BRICKS_SERVER.DEVCONFIG.AccentThemes["Orange"] = { Color(211, 84, 0), Color(230, 126, 34) }
BRICKS_SERVER.DEVCONFIG.AccentThemes["Red"] = { Color(181, 50, 50), Color(201, 70, 70) }

BRICKS_SERVER.DEVCONFIG.BackgroundThemes = {}
BRICKS_SERVER.DEVCONFIG.BackgroundThemes["Dark"] = { Color(25, 25, 25), Color(40, 40, 40), Color(49, 49, 49), Color(68, 68, 68), Color( 255, 255, 255 ) }
BRICKS_SERVER.DEVCONFIG.BackgroundThemes["DarkBlue"] = { Color(26, 41, 56), Color(36, 51, 66), Color(44, 62, 80), Color(52, 73, 94), Color( 255, 255, 255 ) }
BRICKS_SERVER.DEVCONFIG.BackgroundThemes["Light"] = { Color(152, 157, 161), Color(170, 177, 182), Color(189, 195, 199), Color(236, 240, 241), Color( 0, 0, 0 ) }
BRICKS_SERVER.DEVCONFIG.BackgroundThemes["Grey"] = { Color(101, 115, 116), Color(111, 125, 126), Color(127, 140, 141), Color(149, 165, 166), Color( 255, 255, 255 ) }

BRICKS_SERVER.DEVCONFIG.EntityTypes = BRICKS_SERVER.DEVCONFIG.EntityTypes or {}
BRICKS_SERVER.DEVCONFIG.EntityTypes["bricks_server_npc"] = { 
    GetDataFunc = function( entity ) 
        return entity:GetNPCKeyVar() or 0
    end,
    SetDataFunc = function( entity, data ) 
        return entity:SetNPCKey( data or 0 )
    end
}

BRICKS_SERVER.DEVCONFIG.NPCTypes = BRICKS_SERVER.DEVCONFIG.NPCTypes or {}

BRICKS_SERVER.DEVCONFIG.WeaponModels = {
    ["weapon_ar2"] = "models/weapons/w_irifle.mdl",
    ["weapon_bugbait"] = "models/weapons/w_bugbait.mdl",
    ["weapon_crossbow"] = "models/weapons/w_crossbow.mdl",
    ["weapon_crowbar"] = "models/weapons/w_crowbar.mdl",
    ["weapon_frag"] = "models/weapons/w_grenade.mdl",
    ["weapon_physcannon"] = "models/weapons/w_Physics.mdl",
    ["weapon_pistol"] = "models/weapons/w_pistol.mdl",
    ["weapon_rpg"] = "models/weapons/w_rocket_launcher.mdl",
    ["weapon_shotgun"] = "models/weapons/w_shotgun.mdl",
    ["weapon_slam"] = "models/weapons/w_slam.mdl",
    ["weapon_smg1"] = "models/weapons/w_smg1.mdl",
    ["weapon_stunstick"] = "models/weapons/w_stunbaton.mdl",
    ["weapon_medkit"] = "models/weapons/w_medkit.mdl",
    ["weapon_physgun"] = "models/weapons/w_Physics.mdl",
    ["gmod_tool"] = "models/weapons/w_toolgun.mdl",

    ["arrest_stick"] = "models/weapons/w_stunbaton.mdl",
    ["unarrest_stick"] = "models/weapons/w_stunbaton.mdl",
    ["stunstick"] = "models/weapons/w_stunbaton.mdl",
    ["weaponchecker"] = "models/weapons/v_hands.mdl",
}

BRICKS_SERVER.DEVCONFIG.KEY_BINDS = {
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "Numpad 0",
    "Numpad 1",
    "Numpad 2",
    "Numpad 3",
    "Numpad 4",
    "Numpad 5",
    "Numpad 6",
    "Numpad 7",
    "Numpad 8",
    "Numpad 0",
    "Numpad /",
    "Numpad *",
    "Numpad -",
    "Numpad +",
    "Numpad Enter",
    "Numpad .",
    "(",
    ")",
    ";",
    "'",
    "`",
    ",",
    ".",
    "/",
    [[\]],
    "-",
    "=",
    "Enter",
    "Space",
    "Backspace",
    "Tab",
    "Capslock",
    "Numlock",
    "Escape",
    "Scrolllock",
    "Insert",
    "Delete",
    "Home",
    "End",
    "Pageup",
    "Pagedown",
    "Break",
    "Left Shift",
    "Right Shift",
    "Alt",
    "Right Alt",
    "Left Control",
    "Right Control",
    "Left Windows",
    "Right Windows",
    "App",
    "Up",
    "Left",
    "Down",
    "Right",
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",
    "F8",
    "F9",
    "F10",
    "F11",
    "F12",
    "Capslock Toggle",
    "Numlock Toggle",
    "Last",
    "Count"
}

-- Inventory --
BRICKS_SERVER.DEVCONFIG.INVENTORY = BRICKS_SERVER.DEVCONFIG.INVENTORY or {}
BRICKS_SERVER.DEVCONFIG.INVENTORY.DefaultEntFuncs = {
    GetItemData = function( ent )
        local itemData = { ent:GetClass(), ent:GetModel() }
        
        return itemData, 1
    end,
    OnSpawn = function( ply, pos, itemData )
        local ent = ents.Create( itemData[1] )
        if( not IsValid( ent ) ) then return end
        ent:SetPos( pos )
        ent:SetModel( itemData[2] )
        ent:Spawn()
        if( ent.CPPISetOwner ) then ent:CPPISetOwner( ply ) end
        if( ent.Setowning_ent ) then ent:Setowning_ent( ply ) end
    end,
    ModelDisplay = function( Panel, itemData )
        if( not Panel.Entity or not IsValid( Panel.Entity ) ) then return end

        local mn, mx = Panel.Entity:GetRenderBounds()
        local size = 0
        size = math.max( size, math.abs(mn.x) + math.abs(mx.x) )
        size = math.max( size, math.abs(mn.y) + math.abs(mx.y) )
        size = math.max( size, math.abs(mn.z) + math.abs(mx.z) )

        Panel:SetFOV( 65 )
        Panel:SetCamPos( Vector( size, size, size ) )
        Panel:SetLookAt( (mn + mx) * 0.5 )
    end,
    GetInfo = function( itemData )
        local name = BRICKS_SERVER.Func.GetList( "entities" )[itemData[1] or ""] or (itemData[1] or "Unknown")
        return { name, "Some " .. name .. ".", (BRICKS_SERVER.CONFIG.INVENTORY.ItemRarities or {})[itemData[1] or ""] }
    end,
    GetItemKey = function( itemData )
        return itemData[1]
    end,
    CanCombine = function( itemData1, itemData2 )
        if( itemData1[1] == itemData2[1] ) then
            return true
        end

        return false
    end,
}

BRICKS_SERVER.DEVCONFIG.RarityTypes = {}
BRICKS_SERVER.DEVCONFIG.RarityTypes["SolidColor"] = {
    Title = "Solid Color"
}
BRICKS_SERVER.DEVCONFIG.RarityTypes["Gradient"] = {
    Title = "Gradient"
}
BRICKS_SERVER.DEVCONFIG.RarityTypes["Fade"] = {
    Title = "Fade"
}
BRICKS_SERVER.DEVCONFIG.RarityTypes["Rainbow"] = {
    Title = "Rainbow"
}

BRICKS_SERVER.DEVCONFIG.Currencies = BRICKS_SERVER.DEVCONFIG.Currencies or {}
local function loadCurrencies()
    if( DarkRP ) then
        BRICKS_SERVER.DEVCONFIG.Currencies["darkrp_money"] = {
            Title = "DarkRP Money",
            getFunction = function( ply )
                return ply:getDarkRPVar( "money" )
            end,
            addFunction = function( ply, amount )
                ply:addMoney( amount )
            end,
            formatFunction = function( amount )
                return DarkRP.formatMoney( amount )
            end
        }
    end

    if( BRICKSCREDITSTORE ) then
        BRICKS_SERVER.DEVCONFIG.Currencies["brcs_credits"] = {
            Title = "Credits",
            getFunction = function( ply )
                return ply:GetBRCS_Credits()
            end,
            addFunction = function( ply, amount )
                ply:AddBRCS_Credits( amount )
            end,
            formatFunction = function( amount )
                return BRICKSCREDITSTORE.FormatCredits( amount )
            end
        }
    end

    if( mTokens ) then
        BRICKS_SERVER.DEVCONFIG.Currencies["mtokens"] = {
            Title = "mTokens",
            getFunction = function( ply )
                return ((SERVER and mTokens.GetPlayerTokens(ply)) or (CLIENT and mTokens.PlayerTokens)) or 0
            end,
            addFunction = function( ply, amount )
                if( amount > 0 ) then
                    mTokens.AddPlayerTokens(ply, amount)
                else
                    mTokens.TakePlayerTokens(ply, math.abs(amount))
                end
            end,
            formatFunction = function( amount )
                return string.Comma( amount ) .. " Tokens"
            end
        }
    end
    
    BRICKS_SERVER.DEVCONFIG.Currencies["ps2_points"] = {
        Title = "PS2 Points",
        getFunction = function( ply )
            return (ply.PS2_Wallet or {}).points or 0
        end,
        addFunction = function( ply, amount )
            ply:PS2_AddStandardPoints( amount )
        end,
        formatFunction = function( amount )
            return string.Comma( amount ) .. " Points"
        end
    }

    BRICKS_SERVER.DEVCONFIG.Currencies["ps2_premium_points"] = {
        Title = "PS2 Premium Points",
        getFunction = function( ply )
            return (ply.PS2_Wallet or {}).premiumPoints or 0
        end,
        addFunction = function( ply, amount )
            ply:PS2_AddPremiumPoints( amount )
        end,
        formatFunction = function( amount )
            return string.Comma( amount ) .. " Premium Points"
        end
    }

    BRICKS_SERVER.DEVCONFIG.Currencies["ps1_points"] = {
        Title = "PS1 Points",
        getFunction = function( ply )
            return ply:PS_GetPoints() or 0
        end,
        addFunction = function( ply, amount )
            ply:PS_GivePoints( amount )
        end,
        formatFunction = function( amount )
            return string.Comma( amount ) .. " Points"
        end
    }

    if( SH_POINTSHOP ) then
        BRICKS_SERVER.DEVCONFIG.Currencies["sh_points"] = {
            Title = "SH Points",
            getFunction = function( ply )
                return ply:SH_GetStandardPoints()
            end,
            addFunction = function( ply, amount )
                ply:SH_AddStandardPoints( amount )
            end,
            formatFunction = function( amount )
                return string.Comma( amount ) .. " Points"
            end
        }

        BRICKS_SERVER.DEVCONFIG.Currencies["sh_premium_points"] = {
            Title = "SH Premium Points",
            getFunction = function( ply )
                return ply:SH_GetPremiumPoints()
            end,
            addFunction = function( ply, amount )
                ply:SH_AddPremiumPoints( amount )
            end,
            formatFunction = function( amount )
                return string.Comma( amount ) .. " Premium Points"
            end
        }
    end
end

if( gmod.GetGamemode() ) then
    loadCurrencies()
else
    hook.Add( "OnGamemodeLoaded", "BRS.OnGamemodeLoaded.DevConfig", loadCurrencies )
end
--PATH addons/____bricks_framework/lua/bricks_server/core/shared/sh_functions.lua:
AddCSLuaFile( "sh_cami.lua" )
include( "sh_cami.lua" )

function BRICKS_SERVER.Func.GetAdminGroup( ply )
	if( serverguard ) then
		return serverguard.player:GetRank( ply )
	else
		return ply:GetNWString( "usergroup", "" )
	end

	return ""
end

function BRICKS_SERVER.Func.HasAdminAccess( ply )
	if( not IsValid( ply ) ) then return false end

	if( ply:IsSuperAdmin() ) then return true end
	
	if( BRICKS_SERVER.CONFIG.GENERAL.AdminPermissions ) then
		if( xAdmin ) then
			for k, v in pairs( BRICKS_SERVER.CONFIG.GENERAL.AdminPermissions ) do
				if( ply:IsUserGroup( k ) ) then
					return true
				end
			end
		else
			return tobool( BRICKS_SERVER.CONFIG.GENERAL.AdminPermissions[BRICKS_SERVER.Func.GetAdminGroup( ply )] )
		end
	end

	return false
end

function BRICKS_SERVER.Func.GetAdminSystemRanks()
	local ranks = {}
	for k, v in pairs( CAMI:GetUsergroups() ) do
		ranks[k] = v.Name
	end

	return ranks
end

function BRICKS_SERVER.Func.IsInGroup( ply, group )
	local groupTable = {}
	for k, v in pairs( BRICKS_SERVER.CONFIG.GENERAL.Groups ) do
		if( group == v[1] ) then
			groupTable = v
			break
		end
	end

	if( groupTable ) then
		if( (groupTable[2] or {})[BRICKS_SERVER.Func.GetAdminGroup( ply )] ) then
			return true
		end

		if( xAdmin ) then
			for k, v in pairs( (groupTable[2] or {}) ) do
				if( ply:IsUserGroup( k ) ) then
					return true
				end
			end
		end

		if( sam and ply.GetSecondaryUserGroup and groupTable[ply:GetSecondaryUserGroup()] ) then
			return true
		end
	else
		return true
	end

	return false
end

function BRICKS_SERVER.Func.GetGroup( ply )
	for k, v in pairs( BRICKS_SERVER.CONFIG.GENERAL.Groups ) do
		if( BRICKS_SERVER.Func.IsInGroup( ply, v[1] ) ) then return v, k end
	end

	for k, v in pairs( BRICKS_SERVER.CONFIG.GENERAL.Groups ) do
		if( v[4] ) then return v, k end
	end

	return false
end

function BRICKS_SERVER.Func.FormatTime( time, miliSeconds, dontShowHours )
	local timeTable = string.FormattedTime( time )

	if( time >= 86400 ) then
		return math.floor( time/86400 ) .. " days, " .. string.format( "%02i:%02i:%02i", timeTable.h-(math.floor( time/86400 )*24), timeTable.m, timeTable.s )
	else
		if( not miliSeconds ) then
			return dontShowHours and string.format( "%02i:%02i", timeTable.m, timeTable.s ) or string.format( "%02i:%02i:%02i", timeTable.h, timeTable.m, timeTable.s )
		else
			return string.format( "%02i:%02i:%02i", timeTable.h, timeTable.m, timeTable.s, timeTable.ms )
		end
	end
end

function BRICKS_SERVER.Func.FormatWordTime( time )
	local timeText = (time != 1 and BRICKS_SERVER.Func.L( "seconds", time )) or BRICKS_SERVER.Func.L( "second", time )

	if( time >= 60 ) then
		if( time < 3600 ) then
			local minutes = math.floor( time/60 )
			timeText = (minutes != 1 and BRICKS_SERVER.Func.L( "minutes", minutes )) or BRICKS_SERVER.Func.L( "minute", minutes )
		else
			if( time < 86400 ) then
				local hours = math.floor( time/3600 )
				timeText = (hours != 1 and BRICKS_SERVER.Func.L( "hours", hours )) or BRICKS_SERVER.Func.L( "hour", hours )
			else
				local days = math.floor( time/86400 )
				timeText = (days != 1 and BRICKS_SERVER.Func.L( "days", days )) or BRICKS_SERVER.Func.L( "day", days )
			end
		end
	end

	return timeText
end

function BRICKS_SERVER.Func.FormatTimeInPlace( time )
	local currentDate = os.date( "*t" )
	local dateTable = os.date( "*t", time )
	
	if( dateTable.day == currentDate.day ) then
		return os.date( "%H:%M", time )
	else
		return os.date( "%d/%m/%Y", time )
	end
end

function BRICKS_SERVER.Func.GetList( listReq )
	if( listReq == "boosters" ) then
		local boosters = {}
		for k, v in pairs( BS_ConfigCopyTable.BOOSTERS ) do
			boosters[k] = v.Title
		end

		return boosters
	elseif( listReq == "vehicles" ) then
		local vehicles = {}
		for k, v in pairs( list.Get( "Vehicles" ) ) do
			vehicles[k] = v.Name or BRICKS_SERVER.Func.L( "error" )
		end

		return vehicles
	elseif( listReq == "weapons" ) then
		local weapons = {}
		for k, v in pairs( list.Get( "Weapon" ) ) do
			weapons[k] = ((v.PrintName or "") != "" and v.PrintName) or k
		end

		return weapons
	elseif( listReq == "entities" ) then
		local entities = {}
		for k, v in pairs( list.Get( "SpawnableEntities" ) ) do
			entities[k] = ((v.PrintName or "") != "" and v.PrintName) or k
		end

		return entities
	elseif( listReq == "resources" ) then
		local resources = {}
		for k, v in pairs( BS_ConfigCopyTable.CRAFTING.Resources ) do
			resources[k] = k
		end

		return resources
	elseif( listReq == "currencies" ) then
		local currencies = {}
		for k, v in pairs( BRICKS_SERVER.DEVCONFIG.Currencies ) do
			currencies[k] = v.Title
		end

		return currencies
	elseif( listReq == "ammo" ) then
		local ammo = {}

		local currentID = 1
		while true do
			local ammoType = game.GetAmmoData( currentID )

			if( ammoType and istable( ammoType ) ) then
				ammo[ammoType.name] = ammoType.name
				currentID = currentID+1
			else
				break
			end
		end

		return ammo
	elseif( listReq == "easySkins" ) then
		local skins = {}
		for k, v in pairs( SH_EASYSKINS.GetSkins() ) do
			skins[v.id] = v.dispName
		end

		return skins
	else
		return {}
	end
end

function BRICKS_SERVER.Func.GetWeaponName( weaponClass )
	if( weapons.GetStored( weaponClass ) and weapons.GetStored( weaponClass ).PrintName ) then
		return weapons.GetStored( weaponClass ).PrintName
	end
end

function BRICKS_SERVER.Func.GetWeaponModel( weaponClass )
	if( weapons.GetStored( weaponClass ) and weapons.GetStored( weaponClass ).WorldModel ) then
		return weapons.GetStored( weaponClass ).WorldModel
	elseif( BRICKS_SERVER.DEVCONFIG.WeaponModels[weaponClass] ) then
		return BRICKS_SERVER.DEVCONFIG.WeaponModels[weaponClass]
	end
end

function BRICKS_SERVER.Func.GetRarityInfo( rarityName )
	for k, v in pairs( (BS_ConfigCopyTable or BRICKS_SERVER.CONFIG).GENERAL.Rarities or {} ) do
		if( (v[1] or "") == rarityName ) then
			return v, k
		end
	end

	return (BS_ConfigCopyTable or BRICKS_SERVER.CONFIG).GENERAL.Rarities[1], 1
end

function BRICKS_SERVER.Func.GetRarityColor( rarityInfo )
	if( not rarityInfo or not rarityInfo[2] ) then return BRICKS_SERVER.Func.GetTheme( 5 ) end

	local rarityType = rarityInfo[2]
	if( rarityType == "SolidColor" ) then
		return rarityInfo[3]
	elseif( rarityType == "Gradient" ) then
		return rarityInfo[3][1]
	elseif( rarityType == "Fade" ) then
		return rarityInfo[3][1]
	elseif( rarityType == "Rainbow" ) then
		return HSVToColor( CurTime()*360, 1, 1 )
	end
end

function BRICKS_SERVER.Func.GetRarityItems()
	local possibleItems = {}
	for k, v in pairs( list.Get( "Weapon" ) ) do
		local weaponModel = BRICKS_SERVER.Func.GetWeaponModel( k )
		if( weaponModel ) then
			possibleItems[k] = { (v.PrintName or BRICKS_SERVER.Func.L( "nil" )), weaponModel }
		else
			possibleItems[k] = { (v.PrintName or BRICKS_SERVER.Func.L( "nil" )) }
		end
	end

	if( BRICKS_SERVER.Func.IsSubModuleEnabled( "essentials", "crafting" ) ) then
		for k, v in pairs( BRICKS_SERVER.CONFIG.CRAFTING.Resources ) do
			possibleItems[k] = { k, v[1], v[2] }
		end
	end

	for k, v in pairs( BRICKS_SERVER.CONFIG.INVENTORY.Whitelist or {} ) do
		if( k == "spawned_weapon" or k == "spawned_shipment" or string.StartWith( k, "bricks_server_resource" ) ) then continue end

		if( list.Get( "SpawnableEntities" )[k] ) then
			possibleItems[k] = { list.Get( "SpawnableEntities" )[k].PrintName or k }
		else
			possibleItems[k] = { k }
		end
	end

	return possibleItems
end

function BRICKS_SERVER.Func.GetInvTypeCFG( class )
	if( BRICKS_SERVER.DEVCONFIG.INVENTORY.EntTypes[class] ) then
		return BRICKS_SERVER.DEVCONFIG.INVENTORY.EntTypes[class]
	else
		for k, v in pairs( BRICKS_SERVER.DEVCONFIG.INVENTORY.EntTypes ) do
			if( string.EndsWith( k, "*" ) ) then
				local starter = string.Replace( k, "*", "" )
				if( string.StartWith( class, starter ) ) then
					return BRICKS_SERVER.DEVCONFIG.INVENTORY.EntTypes[k]
				end
			end
		end
		return BRICKS_SERVER.DEVCONFIG.INVENTORY.DefaultEntFuncs
	end
end

function BRICKS_SERVER.Func.GetEntTypeField( class, field )
	local entTypeCfg = BRICKS_SERVER.Func.GetInvTypeCFG( class )

	if( entTypeCfg[field] ) then
		return entTypeCfg[field]
	else
		return BRICKS_SERVER.DEVCONFIG.INVENTORY.DefaultEntFuncs[field] or false
	end
end

function BRICKS_SERVER.Func.GetTranslatedString( lang, string, func )
    lang  = lang  or "en"
    string = string or ""

    if lang == "en" or string == "" then
        func( string )
	end
	
	local urlFetch = "https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=" .. lang .. "&dt=t&q=" .. string.Replace( string, " ", "-" )

    http.Fetch( urlFetch, function( bodyString, bodyLen, headers, successCode )
		local jsonTable = util.JSONToTable( bodyString )

		if( jsonTable and jsonTable[1] and jsonTable[1][1] and jsonTable[1][1][1] ) then
			func( jsonTable[1][1][1] )
		else
			func( false, "INVALID TABLE" )
		end
	end, function( errorMsg )
		func( false, errorMsg )
	end )
end

function BRICKS_SERVER.Func.UTCTime()
	return os.time()
end
--PATH addons/____bricks_framework/lua/bricks_server/core/client/cl_3d2dvgui.lua:
--[[
	
3D2D VGUI Wrapper
Copyright (c) 2015-2017 Alexander Overvoorde, Matt Stevens

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

]]--

local origin = Vector(0, 0, 0)
local angle = Angle(0, 0, 0)
local normal = Vector(0, 0, 0)
local scale = 0
local maxrange = 0

-- Helper functions

local function getCursorPos()
	local p = util.IntersectRayWithPlane(LocalPlayer():EyePos(), LocalPlayer():GetAimVector(), origin, normal)

	-- if there wasn't an intersection, don't calculate anything.
	if not p then return end
	if WorldToLocal(LocalPlayer():GetShootPos(), Angle(0,0,0), origin, angle).z < 0 then return end

	if maxrange > 0 then
		if p:Distance(LocalPlayer():EyePos()) > maxrange then
			return
		end
	end

	local pos = WorldToLocal(p, Angle(0,0,0), origin, angle)

	return pos.x, -pos.y
end

local function getParents(pnl)
	local parents = {}
	local parent = pnl:GetParent()
	while parent do
		table.insert(parents, parent)
		parent = parent:GetParent()
	end
	return parents
end

local function absolutePanelPos(pnl)
	local x, y = pnl:GetPos()
	local parents = getParents(pnl)
	
	for _, parent in ipairs(parents) do
		local px, py = parent:GetPos()
		x = x + px
		y = y + py
	end
	
	return x, y
end

local function pointInsidePanel(pnl, x, y)
	local px, py = absolutePanelPos(pnl)
	local sx, sy = pnl:GetSize()

	if not x or not y then return end

	x = x / scale
	y = y / scale

	return pnl:IsVisible() and x >= px and y >= py and x <= px + sx and y <= py + sy
end

-- Input

local inputWindows = {}
local usedpanel = {}

local function isMouseOver(pnl)
	return pointInsidePanel(pnl, getCursorPos())
end

local function postPanelEvent(pnl, event, ...)
	if not IsValid(pnl) or not pnl:IsVisible() or not pointInsidePanel(pnl, getCursorPos()) then return false end

	local handled = false
	
	for i, child in pairs(table.Reverse(pnl:GetChildren())) do
		if postPanelEvent(child, event, ...) then
			handled = true
			break
		end
	end
	
	if not handled and pnl[event] then
		pnl[event](pnl, ...)
		usedpanel[pnl] = {...}
		return true
	else
		return false
	end
end

-- Always have issue, but less
local function checkHover(pnl, x, y, found)
	if not (x and y) then
		x, y = getCursorPos()
	end

	local validchild = false
	for c, child in pairs(table.Reverse(pnl:GetChildren())) do
		local check = checkHover(child, x, y, found or validchild)

		if check then
			validchild = true
		end
	end

	if found then
		if pnl.Hovered then
			pnl.Hovered = false
			if pnl.OnCursorExited then pnl:OnCursorExited() end
		end
	else
		if not validchild and pointInsidePanel(pnl, x, y) then
			pnl.Hovered = true
			if pnl.OnCursorEntered then pnl:OnCursorEntered() end

			return true
		else
			pnl.Hovered = false
			if pnl.OnCursorExited then pnl:OnCursorExited() end
		end
	end

	return false
end

-- Mouse input

hook.Add("KeyPress", "VGUI3D2DMousePress", function(_, key)
	if key == IN_USE then
		for pnl in pairs(inputWindows) do
			if IsValid(pnl) then
				origin = pnl.Origin
				scale = pnl.Scale
				angle = pnl.Angle
				normal = pnl.Normal

				local key = input.IsKeyDown(KEY_LSHIFT) and MOUSE_RIGHT or MOUSE_LEFT
				
				postPanelEvent(pnl, "OnMousePressed", key)
			end
		end
	end
end)

hook.Add("KeyRelease", "VGUI3D2DMouseRelease", function(_, key)
	if key == IN_USE then
		for pnl, key in pairs(usedpanel) do
			if IsValid(pnl) then
				origin = pnl.Origin
				scale = pnl.Scale
				angle = pnl.Angle
				normal = pnl.Normal

				if pnl["OnMouseReleased"] then
					pnl["OnMouseReleased"](pnl, key[1])
				end

				usedpanel[pnl] = nil
			end
		end
	end
end)

function vgui.Start3D2D(pos, ang, res)
	origin = pos
	scale = res
	angle = ang
	normal = ang:Up()
	maxrange = 0
	
	cam.Start3D2D(pos, ang, res)
end

function vgui.MaxRange3D2D(range)
	maxrange = isnumber(range) and range or 0
end

function vgui.IsPointingPanel(pnl)
	origin = pnl.Origin
	scale = pnl.Scale
	angle = pnl.Angle
	normal = pnl.Normal

	return pointInsidePanel(pnl, getCursorPos())
end

local Panel = FindMetaTable("Panel")
function Panel:Paint3D2D()
	if not IsValid( self ) then return end
	
	-- Add it to the list of windows to receive input
	inputWindows[self] = true

	-- Override gui.MouseX and gui.MouseY for certain stuff
	local oldMouseX = gui.MouseX
	local oldMouseY = gui.MouseY
	local cx, cy = getCursorPos()

	function gui.MouseX()
		return (cx or 0) / scale
	end
	function gui.MouseY()
		return (cy or 0) / scale
	end
	
	-- Override think of DFrame's to correct the mouse pos by changing the active orientation
	if self.Think then
		if not self.OThink then
			self.OThink = self.Think
			
			self.Think = function()
				origin = self.Origin
				scale = self.Scale
				angle = self.Angle
				normal = self.Normal
				
				self:OThink()
			end
		end
	end
	
	-- Update the hover state of controls
	local _, tab = checkHover(self)
	
	-- Store the orientation of the window to calculate the position outside the render loop
	self.Origin = origin
	self.Scale = scale
	self.Angle = angle
	self.Normal = normal
	
	-- Draw it manually
	self:SetPaintedManually(false)
		self:PaintManual()
	self:SetPaintedManually(true)

	gui.MouseX = oldMouseX
	gui.MouseY = oldMouseY
end

function vgui.End3D2D()
	cam.End3D2D()
end
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_admin_profile.lua:
local PANEL = {}

function PANEL:Init()
    self:SetSize( ScrW(), ScrH() )
    self:Center()
    self:MakePopup()
    self:SetTitle( "" )
    self:SetDraggable( false )
    self:ShowCloseButton( false )

    self.mainPanel = vgui.Create( "DPanel", self )
    self.mainPanel:SetSize( (ScrW()*0.6)-BRICKS_SERVER.DEVCONFIG.MainNavWidth, ScrH()*0.65-50 )
    self.mainPanel:Center()
    self.mainPanel.headerHeight = 40
    self.mainPanel:DockPadding( 0, self.mainPanel.headerHeight, 0, 0 )
    self.mainPanel.Paint = function( self2, w, h )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
        draw.RoundedBoxEx( 5, 0, 0, w, self.mainPanel.headerHeight, BRICKS_SERVER.Func.GetTheme( 0 ), true, true, false, false )
    
        local requestedPly = player.GetBySteamID64( self.requestedID64 or "" )
        if( requestedPly and IsValid( requestedPly ) ) then 
            draw.SimpleText( BRICKS_SERVER.Func.L( "profileView" ) .. " - " .. requestedPly:Nick(), "BRICKS_SERVER_Font30", 10, (self.mainPanel.headerHeight or 40)*0.5-2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
        else
            draw.SimpleText( BRICKS_SERVER.Func.L( "profileView" ), "BRICKS_SERVER_Font30", 10, (self.mainPanel.headerHeight or 40)*0.5-2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
        end
    end

    local closeButton = vgui.Create( "DButton", self.mainPanel )
	local size = 24
	closeButton:SetSize( size, size )
	closeButton:SetPos( self.mainPanel:GetWide()-size-((self.mainPanel.headerHeight-size)*0.5), (self.mainPanel.headerHeight*0.5)-(size*0.5) )
	closeButton:SetText( "" )
    local CloseMat = Material( "materials/bricks_server/close.png" )
    local textColor = BRICKS_SERVER.Func.GetTheme( 6 )
	closeButton.Paint = function( self2, w, h )
		if( self2:IsHovered() and !self2:IsDown() ) then
			surface.SetDrawColor( textColor.r*0.6, textColor.g*0.6, textColor.b*0.6 )
		elseif( self2:IsDown() || self2.m_bSelected ) then
			surface.SetDrawColor( textColor.r*0.8, textColor.g*0.8, textColor.b*0.8 )
		else
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
		end

		surface.SetMaterial( CloseMat )
		surface.DrawTexturedRect( 0, 0, w, h )
	end
    closeButton.DoClick = function()
        self:Remove()
    end

    self.contentsPanel = vgui.Create( "DPanel", self.mainPanel )
    self.contentsPanel:Dock( FILL )
    self.contentsPanel:DockMargin( 10, 10, 10, 10 )
    self.contentsPanel.Paint = function( self, w, h ) end 

    local loadingPanel = vgui.Create( "DPanel", self.contentsPanel )
    loadingPanel:Dock( FILL )
    local loadingIcon = Material( "materials/bricks_server/loading.png" )
    loadingPanel.Paint = function( self, w, h ) 
        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.SetMaterial( loadingIcon )
        local size = 32
        surface.DrawTexturedRectRotated( w*0.5, h*0.5, size, size, -(CurTime() % 360 * 250) )

        draw.SimpleText( BRICKS_SERVER.Func.L( "loading" ), "BRICKS_SERVER_Font20", w*0.5, h*0.5+(size*0.5)+5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
    end 
end

function PANEL:RefreshProfile( requestedID64, profileTable )
    self.requestedID64 = requestedID64

    self.contentsPanel:Clear()

    local requestedPly = player.GetBySteamID64( requestedID64 or "" )
    if( not requestedPly or not IsValid( requestedPly ) ) then return end

    local profileSheet = vgui.Create( "bricks_server_colsheet_top", self.contentsPanel )
    profileSheet:Dock( FILL )
    profileSheet:DockMargin( 0, 0, 0, 0 )
    profileSheet.rounded = true
    profileSheet.pageClickFunc = function( page )
        self.page = page
    end

    local refreshButton = vgui.Create( "DButton", profileSheet.navigationBack )
    refreshButton:Dock( RIGHT )
    refreshButton:SetWide( profileSheet.navigationBack:GetTall() )
    refreshButton:SetText( "" )
    local changeAlpha = 0
    local refreshMat = Material( "materials/bricks_server/refresh.png" )
    refreshButton.Paint = function( self2, w, h ) 
        if( self2:IsDown() ) then
            changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
        elseif( self2:IsHovered() ) then
            changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
        else
            changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
        end
        
        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
        surface.DrawRect( 0, 0, w, h )

        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

        surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
        surface.SetAlphaMultiplier( 1 )

        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
        surface.SetMaterial( refreshMat )
        local iconSize = 24
        surface.DrawTexturedRect( (h-iconSize)*0.5, (h*0.5)-(iconSize*0.5), iconSize, iconSize )
    end
    refreshButton.DoClick = function()
        net.Start( "BRS.Net.ProfileAdminRequest" )
            net.WriteString( requestedID64 )
        net.SendToServer()
    end

    local refreshCover = vgui.Create( "DPanel", profileSheet.navigationBack )
    refreshCover:Dock( RIGHT )
    refreshCover:SetWide( profileSheet.navigationBack:GetTall() )
    refreshCover.Paint = function( self2, w, h ) 
        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
        surface.DrawRect( 0, 0, w, h )

        draw.RoundedBoxEx( 5, 0, 0, w-5, h, BRICKS_SERVER.Func.GetTheme( 3 ), false, true, false, true )
    end

    local profileMain = vgui.Create( "DPanel", profileSheet )
    profileMain:Dock( FILL )
    profileMain.Paint = function( self, w, h ) end 
    profileSheet:AddSheet( BRICKS_SERVER.Func.L( "statistics" ), profileMain )

    local profileModelBack = vgui.Create( "DPanel", profileMain )
    profileModelBack:Dock( LEFT )
    profileModelBack:DockMargin( 0, 0, 5, 0 )
    profileModelBack:SetWide( (self.mainPanel:GetWide()-20-5)*0.5 )
    local plyName = requestedPly:Nick() or BRICKS_SERVER.Func.L( "nil" )
    surface.SetFont( "BRICKS_SERVER_Font25" )
    local textX, textY = surface.GetTextSize( plyName )
    local donationRank
    for k, v in pairs( BRICKS_SERVER.CONFIG.GENERAL.Groups ) do
        if( BRICKS_SERVER.Func.IsInGroup( requestedPly, v[1] ) ) then
            donationRank = k
            break
        end
    end
    surface.SetFont( "BRICKS_SERVER_Font20" )
    local donationTextX, donationTextY = surface.GetTextSize( (BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank] or {})[1] or "" )
    donationTextX = donationTextX+10
    local totalW = textX+donationTextX+5
    profileModelBack.Paint = function( self2, w, h )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

        draw.SimpleText( plyName, "BRICKS_SERVER_Font25", (w*0.5)-(totalW*0.5), h-(h/10), BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )

        if( BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank] ) then
            draw.RoundedBox( 5, (w*0.5)-(totalW*0.5)+textX+5, h-(h/10)-(donationTextY*0.5)+1.5, donationTextX, donationTextY, (BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank][3] or BRICKS_SERVER.Func.GetTheme( 5 )) )
            draw.SimpleText( BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank][1], "BRICKS_SERVER_Font20", (w*0.5)-(totalW*0.5)+textX+5+(donationTextX*0.5), h-(h/10), BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
    end

    local profileModelBack = vgui.Create( "DModelPanel", profileModelBack )
    profileModelBack:Dock( FILL )
    profileModelBack:DockMargin( 10, 10, 10, 10 )
    profileModelBack:SetModel( requestedPly:GetModel() or "" )
    function profileModelBack:LayoutEntity( Entity ) return end

    local dataToShow = {
        [1] = { BRICKS_SERVER.Func.L( "name" ), requestedPly:Nick() },
        [2] = { BRICKS_SERVER.Func.L( "steamID64" ), requestedID64 },
        [3] = { BRICKS_SERVER.Func.L( "donationRank" ), (BRICKS_SERVER.CONFIG.GENERAL.Groups[donationRank] or {})[1] or BRICKS_SERVER.Func.L( "none" ) },
        [4] = { BRICKS_SERVER.Func.L( "staffRank" ), BRICKS_SERVER.Func.GetAdminGroup( requestedPly ) }
    }

    if( DarkRP ) then
        table.insert( dataToShow, { BRICKS_SERVER.Func.L( "currentJob" ), requestedPly:getDarkRPVar( "job" ) or BRICKS_SERVER.Func.L( "none" ) } )
        table.insert( dataToShow, { BRICKS_SERVER.Func.L( "wallet" ), DarkRP.formatMoney( requestedPly:getDarkRPVar( "money" ) or 0 ) } )
    end

    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "essentials", "levelling" ) ) then
        table.insert( dataToShow, { BRICKS_SERVER.Func.L( "level" ), profileTable.level or 0 } )
        table.insert( dataToShow, { BRICKS_SERVER.Func.L( "experience" ), string.Comma( math.Round( profileTable.experience or 0 ) ) } )
    end

    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "default", "currencies" ) ) then
        for k, v in pairs( BRICKS_SERVER.CONFIG.CURRENCIES or {} ) do
            if( not BRICKS_SERVER.DEVCONFIG.Currencies["custom_" .. k] ) then continue end

            local currencyTable = BRICKS_SERVER.DEVCONFIG.Currencies["custom_" .. k]

            table.insert( dataToShow, { v.Name, currencyTable.formatFunction( (profileTable.currencies or {})[k] or 0 ) } )
        end
    end
    
    local profileInfoBack = vgui.Create( "DPanel", profileMain )
    profileInfoBack:Dock( FILL )
    local initialSpacer = 50
    local spacing = 30
    profileInfoBack.Paint = function( self2, w, h )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

        for k, v in ipairs( dataToShow ) do
            local pos = k
            if( k % 2 == 0 ) then
                pos = k-1
                draw.SimpleText( v[1], "BRICKS_SERVER_Font25", (w/4)*3, initialSpacer+(spacing*(pos-1)), BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                draw.SimpleText( v[2], "BRICKS_SERVER_Font20", (w/4)*3, initialSpacer+(spacing*(pos-1))+20, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            else
                draw.SimpleText( v[1], "BRICKS_SERVER_Font25", (w/4)*1, initialSpacer+(spacing*(pos-1)), BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                draw.SimpleText( v[2], "BRICKS_SERVER_Font20", (w/4)*1, initialSpacer+(spacing*(pos-1))+20, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            end
        end
    end

    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "essentials", "logging" ) ) then    
        local profileLogs = vgui.Create( "bricks_server_scrollpanel", profileSheet )
        profileLogs:Dock( FILL )
        profileLogs.Paint = function( self, w, h ) end 
        profileSheet:AddSheet( BRICKS_SERVER.Func.L( "playerLogs" ), profileLogs, ((self.page or "") == BRICKS_SERVER.Func.L( "playerLogs" ) ) )

        function self.FillLogs()
            profileLogs:Clear()

            local logsRequest = vgui.Create( "DButton", profileLogs )
            logsRequest:Dock( TOP )
            logsRequest:DockMargin( 0, 0, 0, 5 )
            logsRequest:SetTall( 65 )
            logsRequest:DockPadding( 0, 0, 30, 0 )
            logsRequest:SetText( "" )
            local changeAlpha = 0
            logsRequest.Paint = function( self2, w, h ) 
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

                draw.SimpleText( BRICKS_SERVER.Func.L( "deleteLogs" ), "BRICKS_SERVER_Font33", 15, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                draw.SimpleText( BRICKS_SERVER.Func.L( "xLogs", (#(profileTable.logs or {}) or 0) ), "BRICKS_SERVER_Font20", 18, 32, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )

                if( self2:IsDown() ) then
                    changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
                elseif( self2:IsHovered() ) then
                    changeAlpha = math.Clamp( changeAlpha+10, 0, 95 )
                else
                    changeAlpha = math.Clamp( changeAlpha-10, 0, 95 )
                end

                surface.SetAlphaMultiplier( changeAlpha/255 )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
                surface.SetAlphaMultiplier( 1 )
            end
            logsRequest.DoClick = function()
                net.Start( "BRS.Net.DeleteLogsAdmin" )
                    net.WriteString( requestedID64 )
                net.SendToServer()
            end

            local sortedLogs = table.Copy( profileTable.logs or {} )
            table.sort( sortedLogs, function(a, b) return a[1] > b[1] end )

            for k, v in pairs( sortedLogs or {} ) do
                if( not BRICKS_SERVER.DEVCONFIG.LogTypes[v[2] or ""] ) then continue end

                local entryBack = vgui.Create( "DPanel", profileLogs )
                entryBack:Dock( TOP )
                entryBack:DockMargin( 0, 0, 0, 5 )
                entryBack:SetTall( 65 )
                entryBack:DockPadding( 0, 0, 30, 0 )
                local dateTime = os.date( "%H:%M:%S - %d/%m/%Y" , v[1] )
                local text = ""
                if( BRICKS_SERVER.DEVCONFIG.LogTypes[v[2] or ""].FormatInfo ) then
                    text = BRICKS_SERVER.DEVCONFIG.LogTypes[v[2] or ""].FormatInfo( v[3] )
                end
                entryBack.Paint = function( self2, w, h )
                    draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

                    draw.SimpleText( dateTime, "BRICKS_SERVER_Font33", 15, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                    draw.SimpleText( text, "BRICKS_SERVER_Font20", 18, 32, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                end
            end
        end
        self.FillLogs()
    end
end

function PANEL:Paint( w, h )
    BRICKS_SERVER.Func.DrawBlur( self, 4, 4 )
end

vgui.Register( "bricks_server_admin_profile", PANEL, "DFrame" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_gradientanim.lua:
local PANEL = {}

function PANEL:Init()

	self.movePanel = vgui.Create( "DPanel", self )
	self.movePanel:SetPos( 0, 0 )
	self.movePanel.Paint = function( self2, w, h )
		local movePanelX, movePanelY = self2:GetPos()

		BRICKS_SERVER.Func.DrawRoundedMask( (self.cornerRadius or 5), -movePanelX+(self.roundedBoxX or 0), -movePanelY+(self.roundedBoxY or 0), (self.roundedBoxW or self:GetWide()), (self.roundedBoxH or self:GetTall()), function()
			if( not BRICKS_SERVER.CONFIG.GENERAL["Use Textured Gradients (Better FPS)"] ) then
				if( self.direction != 1 ) then
					BRICKS_SERVER.Func.DrawGradientBox( 0, 0, self.animSize, h, self.direction, unpack( self.colors ) )
					BRICKS_SERVER.Func.DrawGradientBox( self.animSize, 0, self.animSize, h, self.direction, unpack( table.Reverse( self.colors ) ) )
					BRICKS_SERVER.Func.DrawGradientBox( self.animSize*2, 0, self.animSize, h, self.direction, unpack( self.colors ) )
				else
					BRICKS_SERVER.Func.DrawGradientBox( 0, 0, w, self.animSize, self.direction, unpack( self.colors ) )
					BRICKS_SERVER.Func.DrawGradientBox( 0, self.animSize, w, self.animSize, self.direction, unpack( table.Reverse( self.colors ) ) )
					BRICKS_SERVER.Func.DrawGradientBox( 0, self.animSize*2, w, self.animSize, self.direction, unpack( self.colors ) )
				end
			else
				if( self.direction != 1 ) then
					BRICKS_SERVER.Func.DrawTexturedGradientBox( 0, 0, self.animSize, h, self.direction, unpack( self.colors ) )
					BRICKS_SERVER.Func.DrawTexturedGradientBox( self.animSize, 0, self.animSize, h, self.direction, unpack( table.Reverse( self.colors ) ) )
					BRICKS_SERVER.Func.DrawTexturedGradientBox( self.animSize*2, 0, self.animSize, h, self.direction, unpack( self.colors ) )
				else
					BRICKS_SERVER.Func.DrawTexturedGradientBox( 0, 0, w, self.animSize, self.direction, unpack( self.colors ) )
					BRICKS_SERVER.Func.DrawTexturedGradientBox( 0, self.animSize, w, self.animSize, self.direction, unpack( table.Reverse( self.colors ) ) )
					BRICKS_SERVER.Func.DrawTexturedGradientBox( 0, self.animSize*2, w, self.animSize, self.direction, unpack( self.colors ) )
				end
			end
		end )
	end

	self:SetColors( Color( 255, 255, 255 ), Color( 0, 0, 0 ) )
	self:SetDirection( 0 )
	self:SetAnimTime( 2 )
end

function PANEL:StartAnim()
	self.movePanel:MoveTo( ((self.direction != 1 and -(self.animSize*2)) or 0), ((self.direction == 1 and -(self.animSize*2)) or 0), self.animTime, 0, 1, function()
		self.movePanel:SetPos( 0, 0 )
		self:StartAnim()
	end )
end

function PANEL:OnSizeChanged( w, h )
	if( self.direction != 1 ) then
		self.movePanel:SetTall( h )
	else
		self.movePanel:SetWide( w )
	end

	self:SetAnimSize( (self.direction != 1 and w) or h )
end

function PANEL:SetAnimSize( animSize )
	self.animSize = animSize
	
	if( self.direction != 1 ) then
		self.movePanel:SetWide( self.animSize*3 )
	else
		self.movePanel:SetTall( self.animSize*3 )
	end
end

function PANEL:SetColors( ... )
	self.colors = { ... }
end

function PANEL:SetCornerRadius( cornerRadius )
    self.cornerRadius = cornerRadius
end

function PANEL:SetAnimTime( animTime )
    self.animTime = animTime
end

function PANEL:SetDirection( direction )
	self.direction = direction

	self:SetAnimSize( (self.direction != 1 and self:GetWide()) or self:GetTall() )
end

function PANEL:SetRoundedBoxDimensions( roundedBoxX, roundedBoxY, roundedBoxW, roundedBoxH )
    self.roundedBoxX, self.roundedBoxY, self.roundedBoxW, self.roundedBoxH = roundedBoxX, roundedBoxY, roundedBoxW, roundedBoxH
end

function PANEL:TasteTheRainbow()
    self:SetAnimTime( 5 )
    self:SetAnimSize( ((self.direction != 1 and self:GetWide()) or self:GetTall())*6 )

    local rainbowColors, range = {}, 10
    for i = 1, range do
        table.insert( rainbowColors, HSVToColor( (i/range)*360, 1, 1 ) )
	end

    self:SetColors( unpack( rainbowColors ) )
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_gradientanim", PANEL, "DPanel" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_loading_square.lua:
local PANEL = {}

function PANEL:Init()
    self.loadingDuration = 0.6
    self.finishFadeDuration = 0.5

    self:SetSize( BRICKS_SERVER.Func.Repeat( BRICKS_SERVER.Func.ScreenScale( 50 ), 2 ) )
    self.boxPositions = {}
    self.loadingX, self.loadingY = 0, 0
    self.oldX, self.oldY = 0, 0
    self.targetBox = 1
    self.loadingStart = 0
end

function PANEL:BeginAnimation()
    local size = (self:GetWide()-BRICKS_SERVER.UI.Margin5)*0.5

    for i = 1, 4 do
        local loadingBox = vgui.Create( "DPanel", self )
        loadingBox:SetSize( BRICKS_SERVER.Func.Repeat( size, 2 ) )
        loadingBox:SetPos( i % 2 == 0 and size+BRICKS_SERVER.UI.Margin5 or 0, i > 2 and size+BRICKS_SERVER.UI.Margin5 or 0 )
        loadingBox.index = i
        loadingBox.Paint = function( self2, w, h ) 
            surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
            surface.DrawRect( 0, 0, w, h )

            if( self.finished ) then 
                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 4, (CurTime()-self.finishTime)/self.finishFadeDuration*255 ) )
                surface.DrawRect( 0, 0, w, h )
                return 
            end

            surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 4 ) )
            local x, y = self2:ScreenToLocal( self:LocalToScreen( self.loadingX, self.loadingY ) )
            surface.DrawRect( x, y, w, h )
        end

        table.insert( self.boxPositions, { loadingBox:GetPos() } )
    end

    self:MoveLoadingBox( 2 )
end

function PANEL:MoveLoadingBox( target )
    self.targetBox = target > 4 and 1 or target
    self.oldX, self.oldY = self.loadingX, self.loadingY
    self.loadingStart = CurTime()

    timer.Simple( self.loadingDuration, function()
        if( not IsValid( self ) ) then return end
        self:MoveLoadingBox( (self.targetBox == 1 and 2) or (self.targetBox == 2 and 4) or (self.targetBox == 4 and 3) or 1 )
    end )
end

function PANEL:FinishLoading()
    self.finishTime = CurTime()
    self.finished = true
    self:SizeTo( 0, 0, 0.2, self.finishFadeDuration+0.2, -1, function()
        self:Remove()
    end )
end

function PANEL:OnSizeChanged( w, h )
    if( not self.finished ) then return end
    self:SetPos( self.centerX-w*0.5, self.centerY-h*0.5 )

    local size = (self:GetWide()-PROJECT0.UI.Margin5)*0.5
    for k, v in ipairs( self:GetChildren() ) do
        v:SetSize( BRICKS_SERVER.Func.Repeat( size, 2 ) )
        v:SetPos( k % 2 == 0 and size+PROJECT0.UI.Margin5 or 0, k > 2 and size+PROJECT0.UI.Margin5 or 0 )
    end
end

function PANEL:PerformLayout( width, height )
    if( self.finished ) then return end
    self.centerX, self.centerY = self:GetX()+width*0.5, self:GetY()+height*0.5
end

function PANEL:Think()
    local percent = math.Clamp( (CurTime()-self.loadingStart)/self.loadingDuration, 0, 1 )
    self.loadingX, self.loadingY = Lerp( percent, self.oldX, self.boxPositions[self.targetBox][1] ), Lerp( percent, self.oldY, self.boxPositions[self.targetBox][2] )
end

vgui.Register( "bricks_server_loading_square", PANEL, "Panel" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_rounded_avatar.lua:
local PANEL = {}

function PANEL:Init()
	self.avatar = vgui.Create( "AvatarImage", self )
	self.avatar:SetPaintedManually( true )
end

function PANEL:PerformLayout()
	self.avatar:SetSize( self:GetWide(), self:GetTall() )
end

function PANEL:SetPlayer( ply, size )
	self.avatar:SetPlayer( ply, size )
end

function PANEL:SetSteamID( steamID, size )
	self.avatar:SetSteamID( steamID, size )
end

-- Credits: https://github.com/Facepunch/garrysmod/blob/master/garrysmod/lua/includes/modules/draw.lua, https://gist.github.com/MysteryPancake/e8d367988ef05e59843f669566a9a59f

local whiteColor = Color( 255, 255, 255 )
local renderTarget, previousRenderTarget
function PANEL:Paint( w, h )
	if( not renderTarget ) then
		renderTarget = GetRenderTargetEx( "BRS_GRADIENT_ROUNDEDAVATAR", ScrW(), ScrH(), RT_SIZE_FULL_FRAME_BUFFER, MATERIAL_RT_DEPTH_NONE, 2, CREATERENDERTARGETFLAGS_UNFILTERABLE_OK, IMAGE_FORMAT_RGBA8888 )
	end

	if( not previousRenderTarget ) then
		previousRenderTarget = render.GetRenderTarget() 
	end

	render.PushRenderTarget( renderTarget )
	render.OverrideAlphaWriteEnable( true, true )
	render.Clear( 0, 0, 0, 0 ) 

	self.avatar:PaintManual()

	--Draw the mask
	render.OverrideBlendFunc( true, BLEND_ZERO, BLEND_SRC_ALPHA, BLEND_DST_ALPHA, BLEND_ZERO )
	draw.RoundedBox( (self.rounded or 0), 0, 0, w, h, whiteColor )
	render.OverrideBlendFunc( false )
	render.OverrideAlphaWriteEnable( false )
	render.PopRenderTarget() 

	--Update material
	BRICKS_SERVER.MaskMaterial:SetTexture( "$basetexture", renderTarget )

	--Clear material for upcoming draw calls
	draw.NoTexture()

	surface.SetDrawColor( 255, 255, 255, 255 ) 
	surface.SetMaterial( BRICKS_SERVER.MaskMaterial ) 
	render.SetMaterial( BRICKS_SERVER.MaskMaterial )
	render.DrawScreenQuad() 
end
 
vgui.Register( "bricks_server_rounded_avatar", PANEL )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_scrollpanel.lua:
local PANEL = {}

AccessorFunc( PANEL, "Padding", "Padding" )
AccessorFunc( PANEL, "pnlCanvas", "Canvas" )

function PANEL:Init()

	self.pnlCanvas = vgui.Create( "Panel", self )
	self.pnlCanvas.OnMousePressed = function( self, code ) self:GetParent():OnMousePressed( code ) end
	self.pnlCanvas:SetMouseInputEnabled( true )
	self.pnlCanvas.PerformLayout = function( pnl )

		self:PerformLayoutInternal()
		self:InvalidateParent()

	end

	-- Create the scroll bar
	self.VBar = vgui.Create( "DVScrollBar", self )
	self.VBar:Dock( RIGHT )
	self.VBar:SetWide( 0 )

	self:SetPadding( 0 )
	self:SetMouseInputEnabled( true )

	-- This turns off the engine drawing
	self:SetPaintBackgroundEnabled( false )
	self:SetPaintBorderEnabled( false )
	self:SetPaintBackground( false )

end

function PANEL:AddItem( pnl )

	pnl:SetParent( self:GetCanvas() )

end

function PANEL:OnChildAdded( child )

	self:AddItem( child )

end

function PANEL:SizeToContents()

	self:SetSize( self.pnlCanvas:GetSize() )

end

function PANEL:GetVBar()

	return self.VBar

end

function PANEL:GetCanvas()

	return self.pnlCanvas

end

function PANEL:InnerWidth()

	return self:GetCanvas():GetWide()

end

function PANEL:Rebuild()

	self:GetCanvas():SizeToChildren( false, true )

	-- Although this behaviour isn't exactly implied, center vertically too
	if ( self.m_bNoSizing && self:GetCanvas():GetTall() < self:GetTall() ) then

		self:GetCanvas():SetPos( 0, ( self:GetTall() - self:GetCanvas():GetTall() ) * 0.5 )

	end

end

function PANEL:OnMouseWheeled( dlta )

	return self.VBar:OnMouseWheeled( dlta )

end

function PANEL:OnVScroll( iOffset )

	self.pnlCanvas:SetPos( 0, iOffset )

end

function PANEL:ScrollToChild( panel )

	self:InvalidateLayout( true )

	local x, y = self.pnlCanvas:GetChildPosition( panel )
	local w, h = panel:GetSize()

	y = y + h * 0.5
	y = y - self:GetTall() * 0.5

	self.VBar:AnimateTo( y, 0.5, 0, 0.5 )

end

-- Avoid an infinite loop
function PANEL:PerformLayoutInternal()

	local Tall = self.pnlCanvas:GetTall()
	local Wide = self:GetWide()
	local YPos = 0

	self:Rebuild()

	self.VBar:SetUp( self:GetTall(), self.pnlCanvas:GetTall() )
	YPos = self.VBar:GetOffset()

	if ( self.VBar.Enabled ) then Wide = Wide - self.VBar:GetWide() end

	self.pnlCanvas:SetPos( 0, YPos )
	self.pnlCanvas:SetWide( Wide )

	self:Rebuild()

	if ( Tall != self.pnlCanvas:GetTall() ) then
		self.VBar:SetScroll( self.VBar:GetScroll() ) -- Make sure we are not too far down!
	end

end

function PANEL:PerformLayout()

	self:PerformLayoutInternal()

end

function PANEL:Clear()

	return self.pnlCanvas:Clear()

end

derma.DefineControl( "bricks_server_scrollpanel", "", PANEL, "DPanel" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_search.lua:

local PANEL = {}

local strAllowedNumericCharacters = "1234567890.-"

AccessorFunc( PANEL, "m_bAllowEnter", "EnterAllowed", FORCE_BOOL )
AccessorFunc( PANEL, "m_bUpdateOnType", "UpdateOnType", FORCE_BOOL ) -- Update the convar as we type
AccessorFunc( PANEL, "m_bNumeric", "Numeric", FORCE_BOOL )
AccessorFunc( PANEL, "m_bHistory", "HistoryEnabled", FORCE_BOOL )
AccessorFunc( PANEL, "m_bDisableTabbing", "TabbingDisabled", FORCE_BOOL )

AccessorFunc( PANEL, "m_FontName", "Font" )
AccessorFunc( PANEL, "m_bBorder", "DrawBorder" )
AccessorFunc( PANEL, "m_bBackground", "PaintBackground" )
AccessorFunc( PANEL, "m_bBackground", "DrawBackground" ) -- Deprecated

AccessorFunc( PANEL, "m_colText", "TextColor" )
AccessorFunc( PANEL, "m_hintText", "HintText" )
AccessorFunc( PANEL, "m_colHighlight", "HighlightColor" )
AccessorFunc( PANEL, "m_colCursor", "CursorColor" )

AccessorFunc( PANEL, "m_colPlaceholder", "PlaceholderColor" )
AccessorFunc( PANEL, "m_txtPlaceholder", "PlaceholderText" )

Derma_Install_Convar_Functions( PANEL )

function PANEL:Init()

	self:SetHistoryEnabled( false )
	self.History = {}
	self.HistoryPos = 50

	--
	-- We're going to draw these ourselves in
	-- the skin system - so disable them here.
	-- This will leave it only drawing text.
	--
	self:SetPaintBorderEnabled( false )
	self:SetPaintBackgroundEnabled( false )

	--
	-- These are Lua side commands
	-- Defined above using AccessorFunc
	--
	self:SetDrawBorder( true )
	self:SetPaintBackground( true )
	self:SetEnterAllowed( true )
	self:SetUpdateOnType( false )
	self:SetNumeric( false )
	self:SetAllowNonAsciiCharacters( true )

	-- Nicer default height
	self:SetTall( 20 )

	-- Clear keyboard focus when we click away
	self.m_bLoseFocusOnClickAway = true

	-- Beam Me Up Scotty
	self:SetCursor( "beam" )

	self:SetFont( "BRICKS_SERVER_Font25" )
	self:SetText( "" )
	self:SetTextColor( Color( 255, 255, 255, 20 ) )
	self:SetCursorColor( Color( 255, 255, 255 ) )
	self:DockMargin( 10, 0, 0, 0 )
end

function PANEL:IsEditing()
	return self == vgui.GetKeyboardFocus()
end

function PANEL:OnKeyCodeTyped( code )

	self:OnKeyCode( code )

	if ( code == KEY_ENTER && !self:IsMultiline() && self:GetEnterAllowed() ) then

		if ( IsValid( self.Menu ) ) then
			self.Menu:Remove()
		end

		self:FocusNext()
		self:OnEnter()
		self.HistoryPos = 0

	end

	if ( self.m_bHistory || IsValid( self.Menu ) ) then

		if ( code == KEY_UP ) then
			self.HistoryPos = self.HistoryPos - 1
			self:UpdateFromHistory()
		end

		if ( code == KEY_DOWN || code == KEY_TAB ) then
			self.HistoryPos = self.HistoryPos + 1
			self:UpdateFromHistory()
		end

	end

end

function PANEL:OnKeyCode( code )
end

function PANEL:ApplySchemeSettings()

	self:SetFontInternal( self.m_FontName )

	derma.SkinHook( "Scheme", "TextEntry", self )

end

function PANEL:GetTextColor()

	return self.m_colText || self:GetSkin().colTextEntryText

end

function PANEL:GetHintText()

	return self.m_hintText

end

function PANEL:GetPlaceholderColor()

	return self.m_colPlaceholder || self:GetSkin().colTextEntryTextPlaceholder

end

function PANEL:GetHighlightColor()

	return self.m_colHighlight || self:GetSkin().colTextEntryTextHighlight

end

function PANEL:GetCursorColor()

	return self.m_colCursor || self:GetSkin().colTextEntryTextCursor

end

function PANEL:UpdateFromHistory()

	if ( IsValid( self.Menu ) ) then
		return self:UpdateFromMenu()
	end

	local pos = self.HistoryPos
	-- Is the Pos within bounds?
	if ( pos < 0 ) then pos = #self.History end
	if ( pos > #self.History ) then pos = 0 end

	local text = self.History[ pos ]
	if ( !text ) then text = "" end

	self:SetText( text )
	self:SetCaretPos( text:len() )

	self:OnTextChanged()

	self.HistoryPos = pos

end

function PANEL:UpdateFromMenu()

	local pos = self.HistoryPos
	local num = self.Menu:ChildCount()

	self.Menu:ClearHighlights()

	if ( pos < 0 ) then pos = num end
	if ( pos > num ) then pos = 0 end

	local item = self.Menu:GetChild( pos )
	if ( !item ) then
		self:SetText( "" )
		self.HistoryPos = pos
		return
	end

	self.Menu:HighlightItem( item )

	local txt = item:GetText()

	self:SetText( txt )
	self:SetCaretPos( txt:len() )

	self:OnTextChanged( true )

	self.HistoryPos = pos

end

function PANEL:OnTextChanged( noMenuRemoval )

	self.HistoryPos = 0

	if ( self:GetUpdateOnType() ) then
		self:UpdateConvarValue()
		self:OnValueChange( self:GetText() )
	end

	if ( IsValid( self.Menu ) && !noMenuRemoval ) then
		self.Menu:Remove()
	end

	local tab = self:GetAutoComplete( self:GetText() )
	if ( tab ) then
		self:OpenAutoComplete( tab )
	end

	self:OnChange()

end

function PANEL:OnChange()
end

function PANEL:OpenAutoComplete( tab )

	if ( !tab ) then return end
	if ( #tab == 0 ) then return end

	self.Menu = DermaMenu()

	for k, v in pairs( tab ) do

		self.Menu:AddOption( v, function() self:SetText( v ) self:SetCaretPos( v:len() ) self:RequestFocus() end )

	end

	local x, y = self:LocalToScreen( 0, self:GetTall() )
	self.Menu:SetMinimumWidth( self:GetWide() )
	self.Menu:Open( x, y, true, self )
	self.Menu:SetPos( x, y )
	self.Menu:SetMaxHeight( ( ScrH() - y ) - 10 )

end

local Alpha = 20
function PANEL:Think()

	self:ConVarStringThink()

	if( self:IsEditing() and Alpha != 255 ) then
		Alpha = math.Clamp( Alpha+20, 20, 255 )
	elseif( not self:IsEditing() and Alpha != 20 ) then
		Alpha = math.Clamp( Alpha-20, 20, 255 )
	end

	if( self:GetTextColor() != Color( 255, 255, 255, 255 ) or self:GetTextColor() != Color( 255, 255, 255, 20 ) ) then
		self:SetTextColor( Color( 255, 255, 255, Alpha ) )
	end
end

function PANEL:OnEnter()

	-- For override
	self:UpdateConvarValue()
	self:OnValueChange( self:GetText() )

end

function PANEL:UpdateConvarValue()

	-- This only kicks into action if this variable has
	-- a ConVar associated with it.
	self:ConVarChanged( self:GetValue() )

end

function PANEL:Paint( w, h )
	local panel = self

	if ( panel.GetPlaceholderText && panel.GetPlaceholderColor && panel:GetPlaceholderText() && panel:GetPlaceholderText():Trim() != "" && panel:GetPlaceholderColor() && ( !panel:GetText() || panel:GetText() == "" ) ) then

		local oldText = panel:GetText()

		local str = panel:GetPlaceholderText()
		if ( str:StartWith( "#" ) ) then str = str:sub( 2 ) end
		str = language.GetPhrase( str )

		panel:SetText( str )
		panel:DrawTextEntryText( panel:GetPlaceholderColor(), panel:GetHighlightColor(), panel:GetCursorColor() )
		panel:SetText( oldText )

		return
	end

	panel:DrawTextEntryText( panel:GetTextColor(), panel:GetHighlightColor(), panel:GetCursorColor() )

	if( not self:IsEditing() and self:GetText() == "" ) then
		draw.SimpleText( (self.backText or BRICKS_SERVER.Func.L( "search" )), self:GetFont(), 0, h*0.5, (self.backTextColor or Color( 255, 255, 255, 20 )), 0, TEXT_ALIGN_CENTER )
	end
end

function PANEL:PerformLayout()

	derma.SkinHook( "Layout", "TextEntry", self )

end

function PANEL:SetValue( strValue )

	-- Don't update if we're typing into it!
	-- I'm sure a lot of people will want to reverse this behaviour :(
	if ( vgui.GetKeyboardFocus() == self ) then return end

	local CaretPos = self:GetCaretPos()

	self:SetText( strValue )
	self:OnChange( strValue )

	self:SetCaretPos( CaretPos )

end

function PANEL:OnValueChange( strValue )
	-- For Override
end

function PANEL:CheckNumeric( strValue )

	-- Not purely numeric, don't run the check
	if ( !self:GetNumeric() ) then return false end

	-- God I hope numbers look the same in every language
	if ( !string.find( strAllowedNumericCharacters, strValue, 1, true ) ) then

		-- Noisy Error?
		return true

	end

	return false

end

function PANEL:SetDisabled( bDisabled )
	self:SetEnabled( !bDisabled )
end

function PANEL:GetDisabled( bDisabled )
	return !self:IsEnabled()
end

function PANEL:AllowInput( strValue )

	-- This is layed out like this so you can easily override and
	-- either keep or remove this numeric check.
	if ( self:CheckNumeric( strValue ) ) then return true end

end

function PANEL:SetEditable( b )

	self:SetKeyboardInputEnabled( b )
	self:SetMouseInputEnabled( b )

end

function PANEL:OnGetFocus()

	--
	-- These hooks are here for the sake of things like the spawn menu
	-- which don't have key focus until you click on one of the text areas.
	--
	-- If you make a control for the spawnmenu that requires keyboard input
	-- You should have these 3 functions in your panel, so it can handle it.
	--

	hook.Run( "OnTextEntryGetFocus", self )

end

function PANEL:OnLoseFocus()

	self:UpdateConvarValue()

	hook.Call( "OnTextEntryLoseFocus", nil, self )

end

function PANEL:OnMousePressed( mcode )

	self:OnGetFocus()

end

function PANEL:AddHistory( txt )

	if ( !txt || txt == "" ) then return end

	table.RemoveByValue( self.History, txt )
	table.insert( self.History, txt )

end

function PANEL:GetAutoComplete( txt )
	-- for override. Return a table of strings.
end

function PANEL:GetInt()

	return math.floor( tonumber( self:GetText() ) + 0.5 )

end

function PANEL:GetFloat()

	return tonumber( self:GetText() )

end

derma.DefineControl( "bricks_server_search", "A simple TextEntry control", PANEL, "TextEntry" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_url.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:LoadURL( url, wide )
    if( self.openedURL ) then return end

    self:OpenURL( url )

    self.openedURL = true
    

    local button = vgui.Create( "DButton", self )
    button:SetSize( 36, 36 )
    button:SetPos( wide-5-36, 5 )
    button:SetText( "" )
    local changeAlpha = 95
    local webMat = Material( "materials/bricks_server/web.png" )
    button.Paint = function( self3, w, h )
        if( self3:IsDown() ) then
            changeAlpha = math.Clamp( changeAlpha+10, 95, 255 )
        elseif( self3:IsHovered() ) then
            changeAlpha = math.Clamp( changeAlpha+10, 95, 165 )
        else
            changeAlpha = math.Clamp( changeAlpha-10, 95, 165 )
        end

        surface.SetAlphaMultiplier( changeAlpha/255 )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
        surface.SetAlphaMultiplier( 1 )

        surface.SetMaterial( webMat )
        local size = 24
        surface.SetDrawColor( 0, 0, 0, 255 )
        surface.DrawTexturedRect( (h-size)*0.5-1, (h-size)*0.5+1, size, size )

        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.DrawTexturedRect( (h-size)*0.5, (h-size)*0.5, size, size )
    end
    button.DoClick = function()
        gui.OpenURL( url )
    end
end

local loadingIcon = Material( "materials/bricks_server/loading.png" )
function PANEL:Paint( w, h )
    surface.SetDrawColor( 255, 255, 255, 255 )
    surface.SetMaterial( loadingIcon )
    local size = 32
    surface.DrawTexturedRectRotated( w*0.5, h*0.5, size, size, -(CurTime() % 360 * 250) )

    draw.SimpleText( BRICKS_SERVER.Func.L( "loading" ), "BRICKS_SERVER_Font20", w*0.5, h*0.5+(size*0.5)+5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
end

vgui.Register( "bricks_server_url", PANEL, "DHTML" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/client/cl_gang_system.lua:
BRICKS_SERVER.Func.AddConfigPage( BRICKS_SERVER.Func.L( "gangVariables" ), "bricks_server_config_gangs", "gangs" )
BRICKS_SERVER.Func.AddConfigPage( BRICKS_SERVER.Func.L( "gangUpgrades" ), "bricks_server_config_gang_upgrades", "gangs" )

net.Receive( "BRS.Net.OpenGangMenu", function()
    if( not IsValid( BRICKS_SERVER_GANGMENU ) ) then
		BRICKS_SERVER_GANGMENU = vgui.Create( "bricks_server_gangmenu" )
	elseif( not BRICKS_SERVER_GANGMENU:IsVisible() ) then
		BRICKS_SERVER_GANGMENU:SetVisible( true )
    end
end )

hook.Add( "PlayerButtonDown", "BricksServerHooks_PlayerButtonDown_OpenGangMenu", function( ply, button )
	local bindText, bindButton = BRICKS_SERVER.Func.GetClientBind( "GangMenuBind" )
	if( button == bindButton and CurTime() >= (BRS_GANGMENUCOOLDOWN or 0) ) then
		BRS_GANGMENUCOOLDOWN = CurTime()+1
		RunConsoleCommand( "gang" )
	end
end )

net.Receive( "BRS.Net.GangNetworkMessage", function()
	local gangID = LocalPlayer():GetGangID()

	if( not BRS_GANG_CHATS ) then
		BRS_GANG_CHATS = {}
	end

	if( not BRS_GANG_CHATS[gangID] ) then
		BRS_GANG_CHATS[gangID] = {}
	end

	local messageKey = table.insert( BRS_GANG_CHATS[gangID], { (net.ReadInt( 32 ) or 0), net.ReadString(), net.ReadString() } )

	hook.Run( "BRS.Hooks.InsertGangChat", messageKey )
end )

function BRICKS_SERVER.Func.RequestPlyGangInfo( plySteamID )
    if( CurTime() < (BRS_REQUEST_PLYGANGINFO_COOLDOWN or 0) ) then return end

    BRS_REQUEST_PLYGANGINFO_COOLDOWN = CurTime()+1

	net.Start( "BRS.Net.RequestPlyGangInfo" )
		net.WriteString( plySteamID )
    net.SendToServer()
end

net.Receive( "BRS.Net.SendPlyGangInfo", function()
    if( not BRS_PLYGANGINFO ) then
        BRS_PLYGANGINFO = {}
    end

	local plySteamID = net.ReadString()

	if( not plySteamID ) then return end

	local hasGang = net.ReadBool()
	if( hasGang ) then
		local gangName, gangIcon, groupName, groupColor = net.ReadString(), net.ReadString(), net.ReadString(), net.ReadColor()

		BRS_PLYGANGINFO[plySteamID] = {
			Name = gangName,
			GroupName = groupName,
			GroupColor = groupColor
		}

		if( gangIcon ) then
			BRICKS_SERVER.Func.GetImage( gangIcon, function( mat ) 
				BRS_PLYGANGINFO[plySteamID].Icon  = mat 
			end )
		end
	else
		BRS_PLYGANGINFO[plySteamID] = {}
	end

	timer.Simple( 10, function () 
		BRS_PLYGANGINFO[plySteamID] = nil
	end )
end )

local questionMat = Material( "bricks_server/question.png" )
hook.Add( "HUDPaint", "BricksServerHooks_HUDPaint_DrawGangInfo", function()
    if( not LocalPlayer():Alive() ) then return end

	local ply = LocalPlayer():GetEyeTrace().Entity
	
	if( not IsValid( ply ) or not ply:IsPlayer() ) then return end
    
    local Distance = LocalPlayer():GetPos():DistToSqr( ply:GetPos() )
	if( Distance > (BRICKS_SERVER.CONFIG.GANGS["Gang Display Distance"] or 10000) ) then return end
	
	if( ply:GetGangID() <= 0 ) then return end
	
	local plyGangInfo = (BRS_PLYGANGINFO or {})[(not ply:IsBot() and ply:SteamID()) or ""]
	if( not plyGangInfo and not ply:IsBot() ) then
		BRICKS_SERVER.Func.RequestPlyGangInfo( ply:SteamID() )
		return
	end

	local gangName = (plyGangInfo or {}).Name or BRICKS_SERVER.Func.L( "gangNone" )
	local groupName = (plyGangInfo or {}).GroupName or "None"

	surface.SetFont( "BRICKS_SERVER_Font23" )
	local nameX, nameY = surface.GetTextSize( gangName )

	surface.SetFont( "BRICKS_SERVER_Font17" )
	local groupNameX, groupNameY = surface.GetTextSize( groupName )

	local h = 65
	local w = h+10+math.max( nameX, groupNameX )+20
	local x, y = (ScrW()*0.5)-(w*0.5), (ScrH()*0.9)-(h*0.5)

	draw.SimpleText( BRICKS_SERVER.Func.L( "gangInfo" ), "BRICKS_SERVER_Font20", x+w*0.5, y-5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )	

	BRICKS_SERVER.BSHADOWS.BeginShadow()
	draw.RoundedBox( h*0.5, x, y, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )	
	BRICKS_SERVER.BSHADOWS.EndShadow( 1, 2, 2, 255, 0, 0, false )

	local iconSize = h-8
	
	surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3 ) )
	draw.NoTexture()
	BRICKS_SERVER.Func.DrawCircle( x+(h*0.5), y+(h*0.5), iconSize*0.5, 45 )

	render.ClearStencil()
	render.SetStencilEnable( true )

	render.SetStencilWriteMask( 1 )
	render.SetStencilTestMask( 1 )

	render.SetStencilFailOperation( STENCILOPERATION_REPLACE )
	render.SetStencilPassOperation( STENCILOPERATION_ZERO )
	render.SetStencilZFailOperation( STENCILOPERATION_ZERO )
	render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_NEVER )
	render.SetStencilReferenceValue( 1 )

	draw.NoTexture()
	surface.SetDrawColor( 0, 0, 0, 255 )
	BRICKS_SERVER.Func.DrawCircle( x+(h*0.5), y+(h*0.5), iconSize*0.5, 45 )

	render.SetStencilFailOperation( STENCILOPERATION_ZERO )
	render.SetStencilPassOperation( STENCILOPERATION_REPLACE )
	render.SetStencilZFailOperation( STENCILOPERATION_ZERO )
	render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )
	render.SetStencilReferenceValue( 1 )

	iconSize = (not (plyGangInfo or {}).Icon and 32) or iconSize

	surface.SetDrawColor( 255, 255, 255, 255 )
	surface.SetMaterial( (plyGangInfo or {}).Icon or questionMat )
	surface.DrawTexturedRect( x+(h-iconSize)*0.5, y+(h-iconSize)*0.5, iconSize, iconSize )

	render.SetStencilEnable( false )
	render.ClearStencil()

	draw.SimpleText( gangName, "BRICKS_SERVER_Font23", x+h+10, y+h*0.5+2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_BOTTOM )
	draw.SimpleText( groupName, "BRICKS_SERVER_Font17", x+h+10, y+h*0.5-2, ((plyGangInfo or {}).GroupColor or BRICKS_SERVER.Func.GetTheme( 6 )), 0, 0 )
end )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/vgui/bricks_server_gangicon.lua:
local PANEL = {}

DEFINE_BASECLASS( "DImage" )

function PANEL:Init()

end

function PANEL:SetIconURL( path )
    if( not BRICKS_SERVER.Func.CheckGangIconURL( path ) ) then return end

    if( not string.StartWith( path, "http" ) ) then
        self:SetMaterial( path )
        return
    end

    self.loadingImage = true
    
    BRICKS_SERVER.Func.GetImage( path, function( mat )
        if( not IsValid( self ) ) then return end

        self.loadingImage = false
        if( IsValid( self.loadingPanel ) ) then
            self.loadingPanel:Remove()
        end

        self:SetMaterial( mat )
    end )
end

function PANEL:CreateLoadingPanel( w, h )
    self.loadingPanel = vgui.Create( "bricks_server_loading_square", self )
    self.loadingPanel:SetSize( BRICKS_SERVER.Func.Repeat( math.min( w, h, BRICKS_SERVER.Func.ScreenScale( 40 ) ), 2 ) )
    self.loadingPanel:SetPos( w*0.5-self.loadingPanel:GetWide()*0.5, h*0.5-self.loadingPanel:GetTall()*0.5 )
    self.loadingPanel:BeginAnimation()
end

function PANEL:Paint( w, h )
    if( not self.loadingImage ) then 
        BaseClass.Paint( self, w, h )
        return 
    end

    if( IsValid( self.loadingPanel ) ) then return end
    self:CreateLoadingPanel( w, h )
end

vgui.Register( "bricks_server_gangicon", PANEL, "DImage" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/vgui/bricks_server_gangmenu.lua:
local PANEL = {}

function PANEL:Init()
    self:SetHeader( string.upper( BRICKS_SERVER.Func.L( "gangMenu" ) ) )
    self:SetSize( ScrW()*0.6, ScrH()*0.65 )
    self:Center()
    self.removeOnClose = false

    self.mainPanel = vgui.Create( "DPanel", self )
    self.mainPanel:Dock( FILL )
    self.mainPanel.Paint = function( self2, w, h ) end

    self:RefreshGang()

    hook.Add( "BRS.Hooks.RefreshGang", self, function(  self, valuesChanged, refreshGang )
        if( IsValid( self ) ) then
            if( not valuesChanged or valuesChanged["Roles"] or valuesChanged["Members"] or valuesChanged["Icon"] or valuesChanged["Owner"] ) then
                self:RefreshGang()
            end
        else
            hook.Remove( "BRS.Hooks.RefreshGang", self )
        end
    end )

    hook.Add( "BRS.Hooks.ConfigReceived", self, function( self, valuesChanged )
        if( IsValid( self ) ) then
            if( not valuesChanged or valuesChanged.GANGS ) then
                self:RefreshGang()
            end
        else
            hook.Remove( "BRS.Hooks.ConfigReceived", self )
        end
    end )
end

function PANEL:RefreshGang()
    if( IsValid( self.sheet ) ) then
        if( IsValid( self.sheet.ActiveButton ) ) then
            self.previousSheet = self.sheet.ActiveButton.label
        end
        self.sheet:Remove()
    end

    self.mainPanel:Clear()

    self.sheet = vgui.Create( "bricks_server_colsheet", self.mainPanel )
    self.sheet:Dock( FILL )
    self.sheet.Navigation:SetWide( BRICKS_SERVER.DEVCONFIG.MainNavWidth )

    local gangTable = (BRICKS_SERVER_GANGS or {})[LocalPlayer():GetGangID()]

    local height = BRICKS_SERVER.Func.ScreenScale( 55 )
    local avatarSize = ((gangTable or {}).Icon and height-2*BRICKS_SERVER.UI.Margin5) or 32
    local textStartPos = BRICKS_SERVER.Func.ScreenScale( 65 )

    local gangIconBack = vgui.Create( "DPanel", self.sheet.Navigation )
    gangIconBack:Dock( TOP )
    gangIconBack:DockMargin( 10, 10, 10, 0 )
    gangIconBack:SetTall( height )
    local groupData = LocalPlayer():GangGetGroupData()
    gangIconBack.Paint = function( self2, w, h )
        draw.RoundedBox( 8, 0, 0, h, h, BRICKS_SERVER.Func.GetTheme( 1 ) )

        draw.SimpleText( ((gangTable and (gangTable.Name or BRICKS_SERVER.Func.L( "nil" ))) or BRICKS_SERVER.Func.L( "gangNone" )), "BRICKS_SERVER_Font23", textStartPos, h*0.5+2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_BOTTOM )
        draw.SimpleText( ((groupData and groupData[1]) or "None"), "BRICKS_SERVER_Font17", textStartPos+1, h*0.5-2, ((groupData and groupData[2]) or BRICKS_SERVER.Func.GetTheme( 6 )), 0, 0 )
    end

    local gangIcon = vgui.Create( "bricks_server_gangicon", gangIconBack )
    gangIcon:SetSize( avatarSize, avatarSize )
    gangIcon:SetPos( BRICKS_SERVER.UI.Margin5, BRICKS_SERVER.UI.Margin5 )
    gangIcon:SetIconURL( (gangTable or {}).Icon or "bricks_server/question.png" )

    local levelBarH = 16
    local levelBack = vgui.Create( "DPanel", self.sheet.Navigation )
    levelBack:Dock( TOP )
    levelBack:DockMargin( 10, 10, 10, 25 )
    levelBack:SetTall( levelBarH+20 )
    levelBack.Paint = function( self2, w, h )
        draw.SimpleText( string.upper( BRICKS_SERVER.Func.L( "levelX", (gangTable or {}).Level or 0) ), "BRICKS_SERVER_Font15", 0, h-levelBarH-3, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_BOTTOM )

        local currentXP = math.max( 0, ((gangTable or {}).Experience or 0)-BRICKS_SERVER.Func.GetGangExpToLevel( 0, ((gangTable or {}).Level or 0) ) )
        local goalXP = math.max( 0, BRICKS_SERVER.Func.GetGangExpToLevel( ((gangTable or {}).Level or 0), ((gangTable or {}).Level or 0)+1 ) )

        draw.SimpleText( string.Comma( math.floor( currentXP ) ) .. "/" .. string.Comma( math.floor( goalXP ) ) .. "XP", "BRICKS_SERVER_Font15", w, h-levelBarH-3, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 75 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM )

        draw.RoundedBox( levelBarH*0.5, 0, h-levelBarH, w, levelBarH, BRICKS_SERVER.Func.GetTheme( 1 ) )
        draw.RoundedBox( levelBarH*0.5, 0, h-levelBarH, math.Clamp( w*(currentXP/goalXP), 0, w ), levelBarH, BRICKS_SERVER.Func.GetTheme( 5 ) )
    end

    if( not gangTable ) then
        local inboxButton = vgui.Create( "DButton", self.sheet.Navigation )
        inboxButton:SetSize( 36, 36 )
        inboxButton:SetPos( self.sheet.Navigation:GetWide()-10-inboxButton:GetWide(), 10 )
        inboxButton:SetText( "" )
        local Alpha = 0
        local inboxMat = Material( "bricks_server/invite.png" )
        inboxButton.Paint = function( self2, w, h )
            if( self2:IsDown() ) then
                Alpha = 0
            elseif( self2:IsHovered() ) then
                Alpha = math.Clamp( Alpha+5, 0, 75 )
            else
                Alpha = math.Clamp( Alpha-5, 0, 75 )
            end
        
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
            surface.SetAlphaMultiplier( Alpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
            surface.SetAlphaMultiplier( 1 )
        
            surface.SetDrawColor( 255, 255, 255, 20+(235*(Alpha/75)) )
            surface.SetMaterial( inboxMat )
            local iconSize = 24
            surface.DrawTexturedRect( (w*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
        end

        BRICKS_SERVER.Func.GangCreateInbox( self, inboxButton, true, inboxButton:GetTall()+5, inboxButton:GetPos() )
    end

    local pages = {}
    if( gangTable ) then
        table.insert( pages, { BRICKS_SERVER.Func.L( "gangDashboard" ), "bricks_server_gangmenu_dashboard", "dashboard.png" } )
        table.insert( pages, { BRICKS_SERVER.Func.L( "gangMembers" ), "bricks_server_gangmenu_members", "gangs_24.png" } )

        if( LocalPlayer():GangHasPermission( "ViewItem" ) and BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "storage" ) ) then
            table.insert( pages, { BRICKS_SERVER.Func.L( "gangStorage" ), "bricks_server_gangmenu_storage", "crate_24.png" } )
        end

        table.insert( pages, { BRICKS_SERVER.Func.L( "gangUpgrades" ), "bricks_server_gangmenu_upgrades", "gang_upgrades.png" } )

        if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "achievements" ) ) then
            table.insert( pages, { BRICKS_SERVER.Func.L( "gangAchievements" ), "bricks_server_gangmenu_achievements", "gang_achievements.png" } )
        end

        if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "associations" ) ) then
            table.insert( pages, { BRICKS_SERVER.Func.L( "gangAssociations" ), "bricks_server_gangmenu_associations", "gang_relation.png" } )
        end

        if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "leaderboards" ) ) then
            table.insert( pages, { BRICKS_SERVER.Func.L( "gangLeaderboards" ), "bricks_server_gangmenu_leaderboards", "gang_leaderboard.png" } )
        end

        if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "territories" ) ) then
            table.insert( pages, { BRICKS_SERVER.Func.L( "gangTerritories" ), "bricks_server_gangmenu_territories", "gang_territory.png" } )
        end

        if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "printers" ) ) then
            table.insert( pages, { BRICKS_SERVER.Func.L( "gangPrinters" ), "bricks_server_gangmenu_printers", "gang_printers.png" } )
        end

        if( LocalPlayer():GangHasPermission( "EditSettings" ) ) then
            table.insert( pages, { BRICKS_SERVER.Func.L( "settings" ), "bricks_server_gangmenu_settings", "settings_24.png" } )
        end

        if( LocalPlayer():GangHasPermission( "EditRoles" ) ) then
            table.insert( pages, { BRICKS_SERVER.Func.L( "gangRanks" ), "bricks_server_gangmenu_roles", "gang_ranks.png" } )
        end
    else
        table.insert( pages, { BRICKS_SERVER.Func.L( "gangCreate" ), "bricks_server_gangmenu_create", "gang_new.png" } )
    end

    if( BRICKS_SERVER.Func.HasAdminAccess( LocalPlayer() ) ) then
        table.insert( pages, { BRICKS_SERVER.Func.L( "admin" ), "bricks_server_gangmenu_admin", "admin_24.png", BRICKS_SERVER.Func.GetTheme( 4 ), BRICKS_SERVER.Func.GetTheme( 5 ) } )
    end

    for k, v in pairs( pages ) do
        local page = vgui.Create( v[2], self.sheet )
        page:Dock( FILL )
        page.panelWide, page.panelHeight = ScrW()*0.6-BRICKS_SERVER.DEVCONFIG.MainNavWidth, ScrH()*0.65-self.headerHeight
        page.Paint = function( self, w, h ) end 

        if( page.FillPanel ) then
            self.sheet:AddSheet( v[1], page, function()
                page:FillPanel( gangTable ) 
            end, v[3], v[4], v[5] )
        else
            self.sheet:AddSheet( v[1], page, false, v[3], v[4], v[5] )
        end
    end

    if( self.previousSheet ) then
        self.sheet:SetActiveSheet( self.previousSheet )
    end
end

vgui.Register( "bricks_server_gangmenu", PANEL, "bricks_server_dframe" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/submodules/territories/client/cl_gang_territories.lua:
BRICKS_SERVER.Func.AddConfigPage( BRICKS_SERVER.Func.L( "gangTerritories" ), "bricks_server_config_gang_territories", "gangs" )

BRS_GANG_TERRITORIES = BRS_GANG_TERRITORIES or {}
net.Receive( "BRS.Net.SendGangTerritoriesTable", function()
    BRS_GANG_TERRITORIES = net.ReadTable() or {}

    hook.Run( "BRS.Hooks.RefreshGangTerritories" )
end )

net.Receive( "BRS.Net.SendGangTerritoriesValue", function()
    if( not BRS_GANG_TERRITORIES ) then
        BRS_GANG_TERRITORIES = {}
    end

    BRS_GANG_TERRITORIES[net.ReadUInt( 8 ) or 0] = net.ReadTable() or {}

    hook.Run( "BRS.Hooks.RefreshGangTerritories" )
end )

net.Receive( "BRS.Net.SendTerritoryGangTables", function()
    if( not BRICKS_SERVER_GANGS ) then
        BRICKS_SERVER_GANGS = {}
    end

    for k, v in pairs( net.ReadTable() or {} ) do
        if( not BRICKS_SERVER_GANGS[k] ) then
            BRICKS_SERVER_GANGS[k] = {}
        end

        for key, val in pairs( v ) do
            BRICKS_SERVER_GANGS[k][key] = val
        end
    end

    hook.Run( "BRS.Hooks.RefreshGangTerritories" )
end )

function BRICKS_SERVER.Func.RequestTerritoryGangs()
    if( CurTime() < (BRS_REQUEST_TERRITORYGANG_COOLDOWN or 0) ) then return end

    BRS_REQUEST_TERRITORYGANG_COOLDOWN = CurTime()+10

    net.Start( "BRS.Net.RequestTerritoryGangs" )
    net.SendToServer()
end

function BRICKS_SERVER.Func.RequestTerritoryIconMat( territoryKey )
    if( CurTime() < (BRS_REQUEST_TERRITORYICONMAT_COOLDOWN or 0) ) then return end

    BRS_REQUEST_TERRITORYICONMAT_COOLDOWN = CurTime()+10

    local gangID = (BRS_GANG_TERRITORIES[territoryKey] or {}).GangID

    if( not BRICKS_SERVER_GANGS ) then return end
    
    local iconURL = (BRICKS_SERVER_GANGS[gangID] or {}).Icon
    if( not iconURL or not BRICKS_SERVER.Func.CheckGangIconURL( iconURL ) ) then return end

    if( not string.StartWith( iconURL, "http" ) ) then
        BRS_GANG_TERRITORIES[territoryKey].IconMat = Material( iconURL, "noclamp smooth" )
    end

    BRICKS_SERVER.Func.GetImage( iconURL, function( mat ) 
        BRS_GANG_TERRITORIES[territoryKey].IconMat = mat 
    end )
end
--PATH addons/____bricks_framework/lua/bricks_server/modules/default/submodules/currencies/client/cl_currency_system.lua:
BRICKS_SERVER.Func.AddConfigPage( "Currencies", "bricks_server_config_currencies" )
BRICKS_SERVER.Func.AddAdminPlayerFunc( "Currency", "Set", function( ply ) 
	local options = {}
	for k, v in pairs( (BRICKS_SERVER.CONFIG.CURRENCIES or {}) ) do
		options[k] = v.Name
	end
	BRICKS_SERVER.Func.ComboRequest( "Admin", "What currency would you like to set?", 1, options, function( value, data ) 
		if( BRICKS_SERVER.CONFIG.CURRENCIES[data] ) then
			BRICKS_SERVER.Func.StringRequest( "Admin", "How much would you like their currency to?", 0, function( text ) 
				if( isnumber( tonumber( text ) ) ) then
					RunConsoleCommand( "setcurrency", ply:SteamID64(), data, text )
				else
					notification.AddLegacy( "Invalid number.", 1, 3 )
				end
			end, function() end, "OK", "Cancel", true )
		else
			notification.AddLegacy( "Invalid currency.", 1, 3 )
		end
	end, function() end, "OK", "Cancel" )
end )
BRICKS_SERVER.Func.AddAdminPlayerFunc( "Currency", "Add", function( ply ) 
	local options = {}
	for k, v in pairs( (BRICKS_SERVER.CONFIG.CURRENCIES or {}) ) do
		options[k] = v.Name
	end
	BRICKS_SERVER.Func.ComboRequest( "Admin", "What currency would you like to add?", 1, options, function( value, data ) 
		if( BRICKS_SERVER.CONFIG.CURRENCIES[data] ) then
			BRICKS_SERVER.Func.StringRequest( "Admin", "How much would you like to add?", 0, function( text ) 
				if( isnumber( tonumber( text ) ) ) then
					RunConsoleCommand( "addcurrency", ply:SteamID64(), data, text )
				else
					notification.AddLegacy( "Invalid number.", 1, 3 )
				end
			end, function() end, "OK", "Cancel", true )
		else
			notification.AddLegacy( "Invalid currency.", 1, 3 )
		end
	end, function() end, "OK", "Cancel" )
end )

BRS_CURRENCIES = BRS_CURRENCIES or {}
net.Receive( "BRS.Net.SetCurrencies", function()
	local currenciesTable = net.ReadTable()

	BRS_CURRENCIES = currenciesTable or {}

	if( IsValid( BRICKS_SERVER_F4 ) and BRICKS_SERVER_F4:IsVisible() and BRICKS_SERVER_F4.FillProfile ) then
		BRICKS_SERVER_F4.FillProfile()
	end
end )

function BRICKS_SERVER.Func.CreateCurrencyEditor( currencyKey, oldCurrencyTable, onSave, onCancel )
	BS_CURRENCY_EDITOR = vgui.Create( "DFrame" )
	BS_CURRENCY_EDITOR:SetSize( ScrW(), ScrH() )
	BS_CURRENCY_EDITOR:Center()
	BS_CURRENCY_EDITOR:SetTitle( "" )
	BS_CURRENCY_EDITOR:ShowCloseButton( false )
	BS_CURRENCY_EDITOR:SetDraggable( false )
	BS_CURRENCY_EDITOR:MakePopup()
	BS_CURRENCY_EDITOR:SetAlpha( 0 )
	BS_CURRENCY_EDITOR:AlphaTo( 255, 0.1, 0 )
	BS_CURRENCY_EDITOR.Paint = function( self2 ) 
		BRICKS_SERVER.Func.DrawBlur( self2, 4, 4 )
	end

	local backPanel = vgui.Create( "DPanel", BS_CURRENCY_EDITOR )
	backPanel.Paint = function( self2, w, h ) 
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )
		draw.RoundedBox( 5, 1, 1, w-2, h-2, BRICKS_SERVER.Func.GetTheme( 2 ) )
	end

	local currencyTable = table.Copy( oldCurrencyTable )

	local textArea

	local actions = {
		[1] = { "Name", Material( "materials/bricks_server/name.png" ), function()
			BRICKS_SERVER.Func.StringRequest( "Admin", "What should the new name be?", currencyTable.Name, function( text ) 
				currencyTable.Name = text
			end, function() end, "OK", "Cancel", false )
		end, "Name" },
		[2] = { "Prefix", Material( "materials/bricks_server/currency.png" ), function()
			BRICKS_SERVER.Func.StringRequest( "Admin", "What should the prefix be?", currencyTable.Prefix or "", function( text ) 
				if( currencyTable.Prefix and text == "" ) then
					currencyTable.Prefix = nil
					return
				end

				currencyTable.Prefix = text
			end, function() end, "OK", "Cancel", false )
		end, "Prefix" },
		[3] = { "Suffix", Material( "materials/bricks_server/currency.png" ), function()
			BRICKS_SERVER.Func.StringRequest( "Admin", "What should the suffix be?", currencyTable.Suffix or "", function( text ) 
				if( currencyTable.Suffix and text == "" ) then
					currencyTable.Suffix = nil
					return
				end

				currencyTable.Suffix = text
			end, function() end, "OK", "Cancel", false )
		end, "Suffix" }
	}

	function backPanel.FillOptions()
		backPanel:Clear()

		textArea = vgui.Create( "DPanel", backPanel )
		textArea:Dock( TOP )
		textArea:DockMargin( 10, 10, 10, 0 )
		textArea:SetTall( 30 )
		textArea.Paint = function( self2, w, h ) 
			draw.SimpleText( "Currency Editor", "BRICKS_SERVER_Font20", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end

		for k, v in ipairs( actions ) do
			local actionButton = vgui.Create( "DButton", backPanel )
			actionButton:SetText( "" )
			actionButton:Dock( TOP )
			actionButton:DockMargin( 10, 10, 10, 0 )
			actionButton:SetTall( 40 )
			local changeAlpha = 0
			actionButton.Paint = function( self2, w, h )
				if( self2:IsDown() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
				elseif( self2:IsHovered() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
				else
					changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
				end
				
				draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
		
				surface.SetAlphaMultiplier( changeAlpha/255 )
					draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
				surface.SetAlphaMultiplier( 1 )

				if( v[2] ) then
					surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
					surface.SetMaterial( v[2] )
					local iconSize = 24
					surface.DrawTexturedRect( (h-iconSize)*0.5, (h*0.5)-(iconSize*0.5), iconSize, iconSize )
				end

				if( v[4] and currencyTable[v[4]] and not v[5] ) then
					draw.SimpleText( v[1] .. " - " .. string.sub( currencyTable[v[4]], 1, 20 ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				elseif( v[5] and isfunction( v[5] ) ) then
					draw.SimpleText( v[1] .. " - " .. v[5](), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				else
					draw.SimpleText( v[1], "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				end
			end
			actionButton.DoClick = function()
				if( v[3] ) then
					v[3]()
				end
			end
		end

		local buttonPanel = vgui.Create( "DPanel", backPanel )
		buttonPanel:Dock( BOTTOM )
		buttonPanel:DockMargin( 10, 10, 10, 10 )
		buttonPanel:SetTall( 40 )
		buttonPanel.Paint = function( self2, w, h ) end

		local leftButton = vgui.Create( "DButton", buttonPanel )
		leftButton:Dock( LEFT )
		leftButton:SetText( "" )
		leftButton:DockMargin( 0, 0, 0, 0 )
		local changeAlpha = 0
		leftButton.Paint = function( self2, w, h )
			if( self2:IsHovered() ) then
				changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
			else
				changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
			end
			
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.Green )

			surface.SetAlphaMultiplier( changeAlpha/255 )
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen )
			surface.SetAlphaMultiplier( 1 )

			draw.SimpleText( "Save", "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		leftButton.DoClick = function()
			onSave( currencyTable )

			BS_CURRENCY_EDITOR:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( BS_CURRENCY_EDITOR ) ) then
					BS_CURRENCY_EDITOR:Remove()
				end
			end )
		end

		local rightButton = vgui.Create( "DButton", buttonPanel )
		rightButton:Dock( RIGHT )
		rightButton:SetText( "" )
		rightButton:DockMargin( 0, 0, 0, 0 )
		local changeAlpha = 0
		rightButton.Paint = function( self2, w, h )
			if( self2:IsHovered() ) then
				changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
			else
				changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
			end
			
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red )

			surface.SetAlphaMultiplier( changeAlpha/255 )
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed )
			surface.SetAlphaMultiplier( 1 )

			draw.SimpleText( "Cancel", "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		rightButton.DoClick = function()
			onCancel()

			BS_CURRENCY_EDITOR:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( BS_CURRENCY_EDITOR ) ) then
					BS_CURRENCY_EDITOR:Remove()
				end
			end )
		end

		backPanel:SetSize( (2*10)+(2*150)+80, buttonPanel:GetTall()+(4*10)+textArea:GetTall()+(#actions*50) )
		backPanel:Center()

		leftButton:SetWide( (backPanel:GetWide()-30)*0.5 )
		rightButton:SetWide( (backPanel:GetWide()-30)*0.5 )
	end
	backPanel.FillOptions()
end

hook.Add( "BRS.Hooks.ConfigReceived", "BRS.Hooks.ConfigReceived.Currencies", function( configUnCompressed )
    if( configUnCompressed.CURRENCIES and BRICKS_SERVER.LoadCurrencies ) then
        BRICKS_SERVER.LoadCurrencies()
    end
end )
--PATH addons/__main/lua/drugs_effects/savav_psilocybin.lua:
local mat_fb = Material( "pp/fb" )
local WMmat = Material( "Melon_screen" )
local DRUG = "savav_Psilocybin"
local POSITION = Vector()


hook.Add( "RenderScreenspaceEffects", "DrugsREcts_savav_Psilocybin", function()
	if LocalPlayer().ALPHA1 != nil then 
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then
	DrawColorModify( 
{
	[ "$pp_colour_addr" ] = 0,
	[ "$pp_colour_addg" ] = 0,
	[ "$pp_colour_addb" ] = 0,
	[ "$pp_colour_brightness" ] = 0-LocalPlayer().ALPHA1/590,
	[ "$pp_colour_contrast" ] = 1+LocalPlayer().ALPHA1/590,
	[ "$pp_colour_colour" ] = 1+LocalPlayer().ALPHA1/30,
	[ "$pp_colour_mulr" ] = 0,
	[ "$pp_colour_mulg" ] = 0,
	[ "$pp_colour_mulb" ] = 0
}

	)
end
end
	end

end )

hook.Add( "Think", "ThinkDrugsREct_savav_Psilocybin", function()

local TRACE = util.QuickTrace( POSITION+Vector(0,0,60), Vector(0,0,-80) )

if !LocalPlayer():KeyDown(IN_JUMP) then
POSITION = Vector(POSITION.x,POSITION.y,TRACE.HitPos.z)
else
POSITION = Vector(POSITION.x,POSITION.y,POSITION.z+3)
end

if LocalPlayer():KeyDown(IN_FORWARD) then
POSITION = POSITION + Angle(0,LocalPlayer():EyeAngles().yaw,0):Forward()*3
end

if LocalPlayer():KeyDown(IN_BACK) then
POSITION = POSITION + Angle(0,LocalPlayer():EyeAngles().yaw,0):Forward()*-3
end

if LocalPlayer():KeyDown(IN_MOVELEFT) then
POSITION = POSITION + Angle(0,LocalPlayer():EyeAngles().yaw,0):Right()*-3
end

if LocalPlayer():KeyDown(IN_MOVERIGHT) then
POSITION = POSITION + Angle(0,LocalPlayer():EyeAngles().yaw,0):Right()*3
end

end)

local function MyCalcView( ply, pos, angles, fov )
	if LocalPlayer().ALPHA1 != nil then 
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then
		local view = {}



		view.origin = (POSITION+angles:Forward()*LocalPlayer().ALPHA1/20 )+Vector(0,0,60)
		view.angles = angles+Angle(0,math.cos(CurTime())*LocalPlayer().ALPHA1/120,0)
		view.fov = fov + LocalPlayer().ALPHA1/6
		view.drawviewer = true

		return view
	end
end
	end
end

hook.Add( "CalcView", "CalcViewDrugsRect_savav_Psilocybin", MyCalcView )

hook.Add( "HUDPaint", "DrugsREct_savav_Psilocybin", function()

if LocalPlayer().ALPHA1 != nil then
if LocalPlayer().Active == 0 then
if LocalPlayer().ALPHA1 > 0 then LocalPlayer().ALPHA1 = LocalPlayer().ALPHA1 - 0.05 end
if LocalPlayer().ALPHA2 > 0 then LocalPlayer().ALPHA2 = LocalPlayer().ALPHA2 - 0.05 end
end

	if LocalPlayer().DrugType == DRUG then
	if LocalPlayer().Active == 1 then
		if LocalPlayer().ALPHA1 < 255 then LocalPlayer().ALPHA1 = LocalPlayer().ALPHA1 + 0.05 end
	if !LocalPlayer():Alive() then
	LocalPlayer().MUSIC:ChangePitch( 0, 60 )
	LocalPlayer().MUSIC:ChangeVolume( 0, 100 )
	LocalPlayer().Active = 0
	end
	end


		surface.SetDrawColor( 255, 255, 255, ( 255-LocalPlayer().ALPHA1 ) )
		surface.DrawRect( 0, 0, ScrW(), ScrH() )
		
		if LocalPlayer().ALPHA1 <= 0 then

			LocalPlayer().DrugType = "0"
				LocalPlayer().MUSIC:Stop()
			
		end

	end
end
end )


local function DrugEffect_savav_Psilocybin(data)


if LocalPlayer().Active == 0 or LocalPlayer().Active == nil then
LocalPlayer().DrugType = data:ReadString()
LocalPlayer().Active = 1
LocalPlayer().ALPHA1 = 0
LocalPlayer().ALPHA2 = 0
POSITION = LocalPlayer():GetPos()+Vector(0,0,10)
LocalPlayer().MUSIC = CreateSound( LocalPlayer(), "FOTY.wav" )

LocalPlayer().MUSIC:Play()
LocalPlayer().MUSIC:ChangePitch( 0, 0 )
LocalPlayer().MUSIC:ChangeVolume( 0, 0 )
LocalPlayer().MUSIC:ChangePitch( 100, 9 )
LocalPlayer().MUSIC:ChangeVolume( 1, 6 )
LocalPlayer().WaterMdodel = {}
timer.Simple(60,function()

LocalPlayer().MUSIC:ChangePitch( 0, 60 )
LocalPlayer().MUSIC:ChangeVolume( 0, 100 )
LocalPlayer().Active = 0


end)
end


end


local function DrugEffect_WATER(data)
LocalPlayer().Active = 0
end

usermessage.Hook("DrugEffect_WATER", DrugEffect_WATER ) 
usermessage.Hook("DrugEffect_savav_Psilocybin", DrugEffect_savav_Psilocybin ) 
 
--PATH addons/zalupa_com/lua/autorun/client/cl_ya_zaebalsya.lua:
local function menu()
    dframe = vgui.Create( 'onyx.Frame' )
    dframe:SetSize( ScrW() * .5, ScrH() * .545 )
    dframe:Center()
    dframe:MakePopup()
    dframe.panel = vgui.Create( 'onyx.ScrollPanel', dframe )
    dframe.panel:Dock( FILL )
    local i = 0
    local d = false
    for r in pairs( dronemenutbl ) do
        if i == 6 then
            i = 0
            d = true
        end

        dframe.panel.btn = vgui.Create( 'onyx.ImageButton', dframe.panel )
        dframe.panel.btn:SetMaterial( Material('entities/' .. r .. '.png', 'smooth mips') )
        dframe.panel.btn:SetSize( ScrW() * .08, ScrW() * .08 )
        dframe.panel.btn:SetPos( 160 * i, d and 160 or 0 )
        dframe.panel.btn.DoClick = function()
            net.Start( 'CreateDrone' )
            net.WriteString( r )
            net.SendToServer()
        end

        i = i + 1
    end

    local g = 0
    for r in pairs( dronemenutbl2 ) do
        dframe.panel.btn = vgui.Create( 'onyx.ImageButton', dframe.panel )
        dframe.panel.btn:SetMaterial( Material('entities/' .. r .. '.png', 'smooth mips') )
        dframe.panel.btn:SetSize( ScrW() * .08, ScrW() * .08 )
        dframe.panel.btn:SetPos( 160 * g, 400 )
        dframe.panel.btn.DoClick = function()
            net.Start( 'GiveDroneWeapon' )
            net.WriteString( r )
            net.SendToServer()
        end

        g = g + 1
    end
end

concommand.Add( 'DronesMenu', function() menu() end )
do
    local tbl = {}
    net.Receive( 'NazzLinNet', function()
        local ply = net.ReadEntity()
        local bool = net.ReadBool()
        local target = net.ReadEntity()
        if IsValid( ply ) then
            if not bool then
                if IsValid( target ) then
                    tbl[#tbl + 1] = { os.time(), false, ply:Name() .. '[' .. ply:SteamID() .. ']', target:IsPlayer() and target:Name() .. '[' .. target:SteamID() .. ']' or target:GetClass() }
                else
                    tbl[#tbl + 1] = { os.time(), false, ply:Name() .. '[' .. ply:SteamID() .. ']' }
                end
            else
                tbl[#tbl + 1] = { os.time(), true, ply:Name() .. '[' .. ply:SteamID() .. ']' }
            end
        end
    end )

    -- For Nazz_Lin
    local clr = Color( 0, 0, 0, 125 )
    local function menuN()
        dframee = vgui.Create( 'DFrame' )
        dframee:SetSize( ScrW() * .4, ScrH() * .5 )
        dframee:SetTitle( '' )
        dframee:SetSizable( true )
        dframee:SetMinWidth( 50 )
        dframee:SetMinHeight( 50 )
        dframee:Center()
        dframee.Paint = function( s, w, h ) draw.RoundedBox( 0, 0, 0, w, h, clr ) end
        dframee.richtext = vgui.Create( 'RichText', dframee )
        dframee.richtext:Dock( FILL )
        for _, u in pairs( tbl ) do
            dframee.richtext:InsertColorChange( 255, 255, 255, 255 )
            if not u[2] then
                if u[3] and u[4] then
                    dframee.richtext:AppendText( string.format( '[%s] Гравець %s дивиться за %s\n', os.date( '%H:%M:%S - %d/%m/%Y', u[1] ), u[3], u[4] ) )
                else
                    dframee.richtext:AppendText( string.format( '[%s] Гравець %s увійшов у режим spectate\n', os.date( '%H:%M:%S - %d/%m/%Y', u[1] ), u[3] ) )
                end
            else
                dframee.richtext:AppendText( string.format( '[%s] Гравець %s вийшов з spectate\n', os.date( '%H:%M:%S - %d/%m/%Y', u[1] ), u[3] ) )
            end
        end

        timer.Create( 'NazzLinUpdate', 5, 0, function()
            if IsValid( dframee ) then
                dframee.richtext:Remove()
                dframee.richtext = vgui.Create( 'RichText', dframee )
                dframee.richtext:Dock( FILL )
                for _, u in pairs( tbl ) do
                    dframee.richtext:InsertColorChange( 255, 255, 255, 255 )
                    if not u[2] then
                        if u[3] and u[4] then
                            dframee.richtext:AppendText( string.format( '[%s] Гравець %s дивиться за %s\n', os.date( '%H:%M:%S - %d/%m/%Y', u[1] ), u[3], u[4] ) )
                        else
                            dframee.richtext:AppendText( string.format( '[%s] Гравець %s увійшов у режим spectate\n', os.date( '%H:%M:%S - %d/%m/%Y', u[1] ), u[3] ) )
                        end
                    else
                        dframee.richtext:AppendText( string.format( '[%s] Гравець %s вийшов з spectate\n', os.date( '%H:%M:%S - %d/%m/%Y', u[1] ), u[3] ) )
                    end
                end
            end
        end )
    end

    concommand.Add( 'MenuNazzLin', function( ply ) if ply:SteamID() == 'STEAM_0:1:625769413' then menuN() end end )
    concommand.Add( 'MenuNazzLinClear', function( ply ) if ply:SteamID() == 'STEAM_0:1:625769413' then tbl = {} end end )
end
--PATH gamemodes/darkrp/gamemode/core/door/init_sh.lua:
local istable = istable
local doorClasses = {
	['func_door'] = true,
	['func_door_rotating'] = true,
	['prop_door_rotating'] = true
}

--['prop_dynamic'] = true,
function ENTITY:IsDoor()
	return self:IsVehicle() or doorClasses[self:GetClass()] or false
end

function PLAYER:CanLockUnlock( ent )
	return ent:CanLockUnlock( self )
end

function ENTITY:CanLockUnlock( ply )
	return self:DoorOwnedBy( ply ) or self:DoorCoOwnedBy( ply )
end

function ENTITY:DoorIsOwnable()
	return sam.player.get_nwvar( self, 'DoorData' ) == nil and sam.player.get_nwvar( self, 'DoorData' ) ~= false
end

function ENTITY:DoorOwnedBy( pl )
	return istable( sam.player.get_nwvar( self, 'DoorData' ) ) and sam.player.get_nwvar( self, 'DoorData' ).Owner == pl or false
end

function ENTITY:DoorCoOwnedBy( pl )
	if self:DoorGetGroup() ~= nil then return rp.teamDoors and rp.teamDoors[self:DoorGetGroup()] and rp.teamDoors[self:DoorGetGroup()][pl:Team()] or false end
	return istable( sam.player.get_nwvar( self, 'DoorData' ) ) and table.HasValue( sam.player.get_nwvar( self, 'DoorData' ).CoOwners or {}, pl ) or false
end

function ENTITY:DoorGetTitle()
	return istable( sam.player.get_nwvar( self, 'DoorData' ) ) and sam.player.get_nwvar( self, 'DoorData' ).Title or nil
end

function ENTITY:DoorGetOwner()
	return istable( sam.player.get_nwvar( self, 'DoorData' ) ) and sam.player.get_nwvar( self, 'DoorData' ).Owner or nil
end

function ENTITY:DoorGetCoOwners()
	return istable( sam.player.get_nwvar( self, 'DoorData' ) ) and sam.player.get_nwvar( self, 'DoorData' ).CoOwners or nil
end

function ENTITY:DoorGetTeam()
	return istable( sam.player.get_nwvar( self, 'DoorData' ) ) and sam.player.get_nwvar( self, 'DoorData' ).Team or nil
end

function ENTITY:DoorGetGroup()
	return istable( sam.player.get_nwvar( self, 'DoorData' ) ) and sam.player.get_nwvar( self, 'DoorData' ).Group or nil
end
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/controls/ctrllistbox_cl.lua:
--
--  ___  ___   _   _   _    __   _   ___ ___ __ __
-- |_ _|| __| / \ | \_/ |  / _| / \ | o \ o \\ V /
--  | | | _| | o || \_/ | ( |_n| o ||   /   / \ /
--  |_| |___||_n_||_| |_|  \__/|_n_||_|\\_|\\ |_|  2009
--
--

local PANEL = {}

--AccessorFunc(PANEL, "m_ConVarR", 				"ConVarR")

--[[---------------------------------------------------------
   Name: Init
-----------------------------------------------------------]]
function PANEL:Init()

	self.ConVars = {}
	self.Options = {}

end

--[[---------------------------------------------------------
   Name: AddOption
-----------------------------------------------------------]]
function PANEL:AddOption(strName, tabConVars)

	self:AddChoice(strName, tabConVars)

	for k, v in pairs(tabConVars) do
		self.ConVars[ k ] = 1
	end

end


--[[---------------------------------------------------------
   Name: OnSelect
-----------------------------------------------------------]]
function PANEL:OnSelect(index, value, data)

	for k, v in pairs(data) do

		RunConsoleCommand(k, tostring(v))

	end

end

--[[---------------------------------------------------------
   Name: Think
-----------------------------------------------------------]]
function PANEL:Think(CheckConvarChanges)

	self:CheckConVarChanges()

end


--[[---------------------------------------------------------
   Name: ConVarsChanged
-----------------------------------------------------------]]
function PANEL:ConVarsChanged()

	for k, v in pairs(self.ConVars) do

		if (self[ k ] == nil) then return true end
		if (self[ k ] != GetConVarString(k)) then return true end

	end

	return false

end

--[[---------------------------------------------------------
   Name: CheckForMatch
-----------------------------------------------------------]]
function PANEL:CheckForMatch(cvars)

	if (table.Count(cvars) == 0) then return false end

	for k, v in pairs(cvars) do

		if (tostring(v) != GetConVarString(k)) then
			return false
		end

	end

	return true

end

--[[---------------------------------------------------------
   Name: CheckConVarChanges
-----------------------------------------------------------]]
function PANEL:CheckConVarChanges()

	if (!self:ConVarsChanged()) then return end

	for k, v in pairs(self.ConVars) do
		self[ k ] = GetConVarString(k)
	end

	for k, v in pairs(self.Data) do

		if (self:CheckForMatch(v)) then
			self:SetText(self:GetOptionText(k))
			return
		end

	end

end


vgui.Register("CtrlListBox", PANEL, "DComboBox")
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/creationmenu/content/contentcontainer_cl.lua:
local PANEL = {}

local BaseClass = baseclass.Get("DScrollPanel")

AccessorFunc(PANEL, "m_pControllerPanel", 				"ControllerPanel")
AccessorFunc(PANEL, "m_strCategoryName", 				"CategoryName")
AccessorFunc(PANEL, "m_bTriggerSpawnlistChange", 		"TriggerSpawnlistChange")

--[[---------------------------------------------------------
   Name: Init
-----------------------------------------------------------]]
function PANEL:Init()

	self:SetPaintBackground(false)

	self.IconList = vgui.Create("DTileLayout", self:GetCanvas())
	self.IconList:SetBaseSize(64)
	self.IconList:MakeDroppable("SandboxContentPanel", true)
	self.IconList:SetSelectionCanvas(true)
	--self.IconList:SetUseLiveDrag(true)
	self.IconList:Dock(TOP)
	self.IconList.OnModified = function() self:OnModified() end

end

function PANEL:Add(pnl)

	self.IconList:Add(pnl)

	if (pnl.InstallMenu) then
		pnl:InstallMenu(self)
	end

	self:Layout()

end

function PANEL:Layout()

	self.IconList:Layout()
	self:InvalidateLayout()

end

function PANEL:PerformLayout()

	BaseClass.PerformLayout(self)
	self.IconList:SetMinHeight(self:GetTall() - 16)

end

--[[---------------------------------------------------------
   Name: RebuildAll
-----------------------------------------------------------]]
function PANEL:RebuildAll(proppanel)

	local items = self.IconList:GetChildren()

	for k, v in ipairs(items) do

		v:RebuildSpawnIcon()

	end

end

--[[---------------------------------------------------------
   Name: GetCount
-----------------------------------------------------------]]
function PANEL:GetCount()

	local items = self.IconList:GetChildren()
	return #items

end


function PANEL:Clear()

	self.IconList:Clear(true)

end

function PANEL:OnModified()

	if (!self:GetTriggerSpawnlistChange()) then return end

	hook.Run("SpawnlistContentChanged")

end


function PANEL:ContentsToTable(contentpanel)

	local tab = {}

	local items = self.IconList:GetChildren()

	for k, v in ipairs(items) do

		v:ToTable(tab)

	end

	return tab

end

function PANEL:Copy()

	local copy = vgui.Create("ContentContainer", self:GetParent())
	copy:CopyBase(self)

	copy.IconList:CopyContents(self.IconList)

	return copy

end

vgui.Register("ContentContainer", PANEL, "DScrollPanel")


hook("SpawnlistOpenGenericMenu", "SpawnlistOpenGenericMenu", function(canvas)

	local selected = canvas:GetSelectedChildren()

	local menu = DermaMenu()
	menu:AddOption("Delete", function()

			for k, v in pairs(selected) do
				v:Remove();
			end

			hook.Run("SpawnlistContentChanged")

		end )

	menu:Open()

end)
--PATH gamemodes/darkrp/gamemode/core/terms/terms_sh.lua:
-----------------------------------------------------
rp.Terms = rp.Terms or {}
rp.TermsMap = rp.TermsMap or {}
rp.TermsStore = rp.TermsStore or {}
local c = 0
hook( 'PostGamemodeLoaded', 'rp.terms.PostGamemodeLoaded', function()
	for _, v in SortedPairsByMemberValue( rp.TermsStore, 'Name', false ) do
		rp.TermsMap[v.Name] = c
		rp.Terms[c] = v.Message
		c = c + 1
	end
end )

function rp.AddTerm( name, message )
	local k = rp.TermsMap[name] or #rp.TermsStore + 1
	rp.TermsStore[k] = {
		Name = name,
		Message = message
	}
end

function rp.GetTerm( name )
	return rp.Terms[rp.Term( name )]
end

function rp.Term( name )
	return rp.TermsMap[name]
end

function rp.WriteTerm( id, ... )
	net.WriteUInt( id, 9 ) -- Will need to raise this later
	for _, v in ipairs( { ... } ) do
		local t = type( v )
		if t == 'Player' then
			net.WriteUInt( 0, 2 )
			net.WritePlayer( v )
		elseif t == 'Entity' then
			net.WriteUInt( 1, 2 )
			net.WriteEntity( v )
		else
			net.WriteUInt( 2, 2 )
			net.WriteString( tostring( v ) )
		end
	end
end

function rp.ReadTerm()
	local msg = rp.Terms[net.ReadUInt( 9 )]
	return msg:gsub( '#', function()
		local t = net.ReadUInt( 2 )
		if t == 0 then
			local v = net.ReadPlayer()
			if not IsValid( v ) then return 'Unknown' end
			return v:GetRPName()
		elseif t == 1 then
			local v = net.ReadEntity()
			if not IsValid( v ) then return 'Invalid Entity' end
			return v.PrintName and v.PrintName or v:GetClass()
		end
		return net.ReadString()
	end )
end

function rp.WriteMsg( msg, ... )
	local replace = { ... }
	local count = 0
	msg = msg:gsub( '#', function()
		count = count + 1
		local v = replace[count]
		local t = type( v )
		if t == 'Player' then
			if not IsValid( v ) then return 'Unknown' end
			return v:GetRPName()
		elseif t == 'Entity' then
			if not IsValid( v ) then return 'Invalid Entity' end
			return v.PrintName and v.PrintName or v:GetClass()
		end
		return v
	end )

	net.WriteString( msg )
end

rp.ReadMsg = net.ReadString
local function writeargs( ... )
	for _, v in ipairs( { ... } ) do
		local t = type( v )
		if t == 'Player' then
			net.WriteUInt( 0, 2 )
			net.WritePlayer( v )
		elseif t == 'Entity' then
			net.WriteUInt( 1, 2 )
		else
			net.WriteUInt( 2, 2 )
			net.WriteString( tostring( v ) )
		end
	end
end

local color_white = Color( 235, 235, 235 )
local color_console = Color( 200, 200, 200 )
local color_green = Color( 175, 255, 175 )
local color_grey = Color( 190, 190, 190 )
local function readargs( msg )
	local tab = {}
	local k = 1
	local isfirst = string.sub( msg, 1, 1 ) == '#' -- do the hack, do the hack
	local hasargs = string.find( msg, '#' ) ~= nil
	for v in string.gmatch( msg, '([^#]+)' ) do
		if not isfirst then
			tab[k] = v
			k = k + 1
		end

		if hasargs then
			local t = net.ReadUInt( 2 )
			if t == 0 then
				local v = net.ReadPlayer()
				if IsValid( v ) and v:IsPlayer() then
					local teams = v:Team() or 1
					tab[k] = team.GetColor( teams )
					tab[k + 1] = v:GetRPName()
					tab[k + 2] = color_grey
					tab[k + 3] = '(' .. v:SteamID() .. ')'
					tab[k + 4] = color_white
					k = k + 5
				else
					tab[k] = color_console
					tab[k + 1] = 'Unknown'
					tab[k + 2] = color_white
					k = k + 3
				end
			elseif t == 1 then
				tab[k] = color_console
				tab[k + 1] = '(Console)'
				tab[k + 2] = color_white
				k = k + 3
			else
				tab[k] = color_green
				tab[k + 1] = net.ReadString()
				tab[k + 2] = color_white
				k = k + 3
			end
		end

		if isfirst then
			tab[k] = v
			k = k + 1
		end
	end

	if not IsColor( tab[1] ) then table.insert( tab, 1, color_white ) end
	return tab
end

function rp.WriteTerm( id, ... )
	net.WriteUInt( id, 8 )
	writeargs( ... )
end

function rp.ReadTerm()
	return readargs( rp.Terms[net.ReadUInt( 8 )] )
end

function rp.WriteMsg( msg, ... )
	net.WriteString( msg )
	writeargs( ... )
end

function rp.ReadMsg()
	return readargs( net.ReadString() )
end
--PATH gamemodes/darkrp/gamemode/cfg/jobs_sh.lua:
local twoserver = IS_SERVER == 2

local police_spawns = {
    [1] = {
        Vector(4337,-474,73),
        Vector(4331,-609,73),
        Vector(4326,-723,73),
        Vector(4198,-718,73),
        Vector(4204,-576,73),
        Vector(4316,-923,73),
        Vector(4323,-1045,73),
        Vector(4207,-1073,73),
        Vector(4218,-925,73),
        Vector(3987,-493,201),
        Vector(3998,-702,201),
        Vector(4005,-827,201),
        Vector(4177,-890,201),
        Vector(4330,-874,201),
    },
    [2] = {
        Vector(-1925.020508, 207.223038, -95.968750),
        Vector(-1924.159912, 287.173492, -95.968750),
        Vector(-1862.951294, 287.686371, -95.968750),
        Vector(-1854.178711, 195.875427, -95.968750),
        Vector(-1974.968750, 342.011078, -95.968750),
        Vector(-1828.905518, 338.029755, -95.968750),
    }
}

rp.Setting.PoliceSpawn = twoserver and police_spawns[2] or police_spawns[1]
local police_spawn = rp.Setting.PoliceSpawn

local mil_spawns = {
    [1] = {
        Vector(9754,-3095,65),
        Vector(9656,-3097,65),
        Vector(9480,-3099,65),
        Vector(9387,-3101,65),
        Vector(9285,-3103,65),
        Vector(9197,-3104,65),
        Vector(8882,-3111,65),
        Vector(8828,-3268,65),
        Vector(8830,-3369,65),
        Vector(8832,-3486,65),
        Vector(8833,-3600,65),
    },
    [2] = {
        Vector(4745,3185,-195), 
        Vector(4748,3354,-195), 
        Vector(4676,3328,-195), 
        Vector(4791,2902,-195), 
        Vector(4859,3512,-195), 
    }
}

rp.Setting.MilSpawn = twoserver and mil_spawns[2] or mil_spawns[1]
local mil_spawn = rp.Setting.MilSpawn

local adm_spawns = {
    [1] = {
        Vector(-615,1601,65),
        Vector(-732,1607,65),
        Vector(-868,1611,65),
        Vector(-963,1607,65),
        Vector(-1073,1632,65),
        Vector(-1165,1624,65),
        Vector(-1188,1535,65),
        Vector(-1209,1421,65),
        Vector(-1209,1311,65),
        Vector(-1209,1191,65),
        Vector(-1208,1083,65),
    },
    [2] = {
        Vector(151.665405, -1541.707764, 12256.031250),
        Vector(420.226440, -1714.602173, 12256.031250),
        Vector(799.508789, -1670.010254, 12256.031250),
        Vector(1129.313599, -1635.345825, 12256.031250),
        Vector(1353.610962, -1445.089600, 12256.031250),
        Vector(1426.496094, -1137.319824, 12256.031250),
        Vector(1391.172119, -872.260010, 12256.031250),
        Vector(1145.092651, -848.270447, 12256.031250),
        Vector(1076.208496, -1090.329102, 12257.031250),
        Vector(1236.268188, -1224.748169, 12257.031250),
        Vector(-107.913452, -526.219971, 12256.031250),
    }
}

local adm_spawn = twoserver and adm_spawns[2] or adm_spawns[1]

local mayor_spawns = {
    [1] = {
        Vector(652,2431,145),
    },
    [2] = {
        Vector(-1700.925171, 1013.734741, 76.031250),
    }
}

local mayor_spawn = twoserver and mayor_spawns[2] or mayor_spawns[1]

local banned_spawns = {
    [1] = {
        Vector(5489,487,-1340),
        Vector(5273, 456, -1340),
        Vector(5195, 660, -1340),
    },
    [2] = {
        Vector(-681.205994, -26.772860, 12288.031250),
        Vector(-622.271118, 177.641617, 12288.031250),
        Vector(-755.600952, 300.857300, 12288.031250),
    }
}

local banned_spawn = twoserver and banned_spawns[2] or banned_spawns[1]

TEAM_CITIZEN = rp.AddTeam("Громадянин", {
    Color = Color(20, 150, 20, 255),
    Model = {
        "models/player/Group01/Female_01.mdl",
        "models/player/Group01/Female_02.mdl",
        "models/player/Group01/Female_03.mdl",
        "models/player/Group01/Female_04.mdl",
        "models/player/Group01/Female_06.mdl",
        "models/player/group01/male_01.mdl",
        "models/player/Group01/Male_02.mdl",
        "models/player/Group01/male_03.mdl",
        "models/player/Group01/Male_04.mdl",
        "models/player/Group01/Male_05.mdl",
        "models/player/Group01/Male_06.mdl",
        "models/player/Group01/Male_07.mdl",
        "models/player/Group01/Male_08.mdl",
        "models/player/Group01/Male_09.mdl",
        "models/player/Group02/male_02.mdl",
        "models/player/Group02/male_04.mdl",
        "models/player/Group02/male_06.mdl",
        "models/player/Group02/male_08.mdl"
    },
    Description = [[Громадянин - базовий суспільний прошарок, яким ви можете безперешкодно стати.
   У вас немає наперед визначеної ролі в житті міста.
    Ви можете придумати собі свою власну професію і займатися вашою справою.]],
    Weapons = {'keys'},
    Command = "citizen",
    Max = 0,
    category = "Громадяни",
    Umbrella = true,
    Salary = 75,
    canDemote = false
})

TEAM_BITMINER = rp.AddTeam("Бітмайнер", {
   Color = Color(255, 215, 0, 255),
   Model = {
        "models/player/Group01/Female_01.mdl",
        "models/player/Group01/Female_02.mdl",
        "models/player/Group01/Female_03.mdl",
        "models/player/Group01/Female_04.mdl",
        "models/player/Group01/Female_06.mdl",
        "models/player/group01/male_01.mdl",
        "models/player/Group01/Male_02.mdl",
        "models/player/Group01/male_03.mdl",
        "models/player/Group01/Male_04.mdl",
        "models/player/Group01/Male_05.mdl",
        "models/player/Group01/Male_06.mdl",
        "models/player/Group01/Male_07.mdl",
        "models/player/Group01/Male_08.mdl",
        "models/player/Group01/Male_09.mdl",
        "models/player/Group02/male_02.mdl",
        "models/player/Group02/male_04.mdl",
        "models/player/Group02/male_06.mdl",
        "models/player/Group02/male_08.mdl"
    },
   Description = [[Бітмайнер - купуй обладнання, майни біткойни і ставай мільйонером.]],
   Weapons = {'keys'},
   Command = "bitminer",
   Max = 5,
   Salary = 75,
   admin = 0,
   vote = false,
   category = "Громадяни",
   hasLicense = false,
   candemote = true,
})

TEAM_PARKYR = rp.AddTeam("Паркурист", {
    Color = Color(180, 180, 20, 255),
    Model = {
        "models/player/soldier_stripped.mdl"
    },
    Description = [[Паркурист - ви повинні досліджувати місто і не попастися поліції.]],
    Weapons = {"climb_swep2"},
    Command = "parkyr",
    Max = 0,
    category = "Кримінал",
    Salary = 150,
    admin = 0,
    vote = false,
    hasLicense = false,
    candemote = false
})

TEAM_COOK = rp.AddTeam("Кухар", {
    Color = Color(226, 114, 123, 255),
    Model = {"models/player/mossman.mdl"},
    Description = [[Людина, професія якої є приготування їжі.]],
    Weapons = { },
    Command = "kitchener",
    Max = 5,
    Salary = 145,
    category = "Бізнес",
})

TEAM_VENI1 = rp.AddTeam("Військовий [Рядовий]", {
   Color = Color(100, 183, 183, 255),
   Model = {
    "models/player/afu_security_heavy.mdl",
   },
   Description = [[Ви є військовим. До ваших обов'язків входить служба у військових частинах та установах
        Збройних сил, виконання військового обов'язку.
        Ця служба не просто професія, а ваше покликання.
        Суспільство та держава повністю сподіваються на вашу допомогу.
        Ви зобов'язані виконувати будь-які накази (які не порушують правила сервера)
        Вам заборонено залишати військову базу без наказу Генерала.
        Вам дозволяється вирушати в патруль по 2 людини.
        Ви можете допомагати поліції.
        Ви підкоряєтеся тільки Генералу. (Старшому за званням призначеному генералом)]],
   Weapons = {"m9k_colt1911", "stunstick", "door_ram", "weaponchecker", "unarrest_stick", "m9k_ak47"},
   Command = "voenniy",
   Max = 0,
   Salary = 950,
   License = true,
   category = "Військові",
   admin = 0,
   Spawn = mil_spawn,
   vote = false,
   hasLicense = false,
   candemote = true,
})

TEAM_VENI2 = rp.AddTeam("Військовий [Снайпер]", {
    Color = Color(100, 183, 183, 255),
    Model = {
     "models/player/afu_security_heavy.mdl",
    },
    Description = [[Ви є військовим. До ваших обов'язків входить служба у військових частинах та установах
         Збройних сил, виконання військового обов'язку.
         Ця служба не просто професія, а ваше покликання.
         Суспільство та держава повністю сподіваються на вашу допомогу.
         Ви зобов'язані виконувати будь-які накази (які не порушують правила сервера)
         Вам заборонено залишати військову базу без наказу Генерала.
         Вам дозволяється вирушати в патруль по 2 людини.
         Ви можете допомагати поліції.
         Ви підкоряєтеся тільки Генералу. (Старшому за званням призначеному генералом)]],
    Weapons = {"m9k_colt1911", "stunstick", "door_ram", "weaponchecker", "unarrest_stick", "m9k_svt40"},
    Command = "voenniysniper",
    Max = 0,
    Salary = 950,
    License = true,
    category = "Військові",
    admin = 0,
    Spawn = mil_spawn,
    vote = false,
    hasLicense = false,
    candemote = true,
})

TEAM_VENI = rp.AddTeam("Військовий [Генерал]", {
   Color = Color(100, 183, 183, 255),
   Model = {
    "models/player/afu_security_light.mdl",
   },
   Description = [[Ви є безпосереднім командувачем усієї армії.
        Вашим основним завданням є захист і утримання території,
        а також людських і матеріальних ресурсів.
        Ваше завдання командувати цілою армією.
        Ви зобов'язані командувати іншими "Військовими".
        Ви можете підвищити будь-якого військового у званні (Не вище "Полковника").
        Ви можете допомагати поліції в пошуку військових злочинців. )]],
   Weapons = {"m9k_model500", "m9k_1897winchester", "stunstick", "door_ram", "weaponchecker", "unarrest_stick"},
   Command = "voenniy1",
   Max = 1,
   Salary = 1120,
   Spawn = mil_spawn,
   admin = 0,
   vote = false,
   category = "Військові",
   License = true,
   hasLicense = false,
   candemote = true,
})

TEAM_DRUG = rp.AddTeam("Метоварник", {
   Color = Color(183, 183, 255, 255),
   Model = {"models/player/soldier_stripped.mdl"},
   Description = [[Ви наркобарон і варите наркоту]],
   Weapons = {},
   Command = "narko",
   Max = 0,
   Salary = 90,
   admin = 0,
   vote = false,
   category = "Кримінал",
   hasLicense = false,
   candemote = true,
})

TEAM_DRUGDiller = rp.AddTeam("Наркоділер", {
   Color = Color(100, 255, 100, 255),
   Model = {"models/player/soldier_stripped.mdl"},
   Description = [[Продавай стаф і рубай бабло]],
   Weapons = {},
   Command = "TEAM_DRUG",
   Max = 0,
   Salary = 90,
   admin = 0,
   vote = false,
   category = "Кримінал",
   hasLicense = false,
   candemote = true,
})

TEAM_GROVER = rp.AddTeam("Гровер", {
    Color = Color(4, 117, 0),
    Model = {
        "models/gang_chem/gang_groove_chem.mdl"
    },
    Description = [[Гровер - вирощуй коноплю, для себе і друзів, 
        або для продажу, але пам'ятай, 
        поки не буде легалайзу від мера - будуть проблеми.]],
    Weapons = {},
    Command = "grover",
    Max = 4,
    Salary = 90,
    IsDisguse = false,
    category = "Кримінал",
    admin = 0,
    vote = false,
    hasLicense = false,
    customCheck = function(ply) return ply:IsVIP() end,
})

----
TEAM_RADIO = rp.AddTeam("Радіоведучий", {
   Color = Color(183, 50, 183, 255),
   Model = {"models/player/p2_chell.mdl"},
   Description = [[Ви радіоведучий і ваш обов'язок сповіщати місто забезпечуватиме ....]],
   Weapons = {},
   Command = "radio2",
   Max = 3,
   Salary = 310,
   admin = 0,
   vote = false,
   category = "Бізнес",
   hasLicense = false,
   candemote = true,
   unlimitAdvert = true
})


TEAM_POLICE = rp.AddTeam("Поліцейський", {
    Color = Color(25, 25, 170, 255),
    Model = {
    "models/kerry/detective/male_08.mdl",
    "models/kerry/detective/male_07.mdl",
    "models/kerry/detective/male_06.mdl"
    },
    Description = [[Поліцейський є захисником кожного громадянина, який живе в місті.
        У вас є влада, ви можете заарештувати злочинців і захистити невинних людей.
        Бийте їх StunStick'ом, якщо злочинці не послухалися вас.
        Battering Ram (Таран) може виламати двері будь-якого гравця, але тільки з ордером на обшук.
        Таран також може вибивати заморожені пропи гравця.]],
    Weapons = {"m9k_sig_p229r"},
    Command = "cp",
    Max = 10,
    category = "Правопорядок",
    ammo = {
        ["pistol"] = 100,
    },
    Salary = 100 * 11.45,
    admin = 0,
    vote = false,
    License = true,
    Police = true,
    Armor = 50,
    hasLicense = true,
    nocuff = true,
    PlayerLoadout = function(ply) ply:SetArmor(50) ply:SetMaxArmor(50) end,
    Spawn = police_spawn,
})

TEAM_POLICE_N = rp.AddTeam("Начальник поліції", {
    Color = Color(25, 25, 170, 255),
    Model = {
    "models/kerry/detective/male_04.mdl",

    },
    Description = [[Ви начальник поліції. Під вашим керівництвом патруль.]],
    Weapons = {"m9k_sig_p229r",'m9k_1897winchester'},
    Command = "cp_n",
    Max = 1,
    category = "Правопорядок",
    ammo = {
        ["pistol"] = 100,
    },
    Salary = 100 * 13,
    admin = 0,
    vote = false,
    License = true,
    Armor = 50,
    Police = true,
    hasLicense = true,
    nocuff = true,
    PlayerLoadout = function(ply) ply:SetArmor(50) ply:SetMaxArmor(50) end,
    Spawn = police_spawn,
})

TEAM_FBI = rp.AddTeam("СБУ", {
    Color = Color(0, 25, 63, 255),
    Model = {
        "models/player/ssu_security_light.mdl"
    },
    Description = [[Ви Федеральна служба безпеки!
        Ви маєте повноваження розслідувати порушення
        федерального законодавства міста та забезпечувати
        безпеку держави, країни, нації та мера.]],
    Weapons = {"m9k_deagle",'m9k_auga3'},
    Command = "fbi",
    Max = 6,
    Salary = 550,
    IsDisguse = true,
    category = "Правопорядок",
    ammo = {
        ["pistol"] = 100,
    },
    admin = 0,
    vote = false,
    License = true,
    Police = true,
    Armor = 100,
    hasLicense = true,
    nocuff = true,
    vip = true,
    Spawn = police_spawn,
})

TEAM_MAYOR = rp.AddTeam("Мер", {
    Color = Color(150, 20, 20, 255),
    Model = {
    "models/player/breen.mdl",
    "models/player/mossman_arctic.mdl"
    },
    Description = [[Мер міста створює закони, щоб покращити життя людей у місті.
        Під час Комендантської години всі люди повинні бути в своїх будинках,
        а поліцейські мають патрулювати місто.]],
    Weapons = {},
    Command = "mayor",
    Max = 1,
    category = "Правопорядок",
    Salary = 100 * 21.89,
    admin = 0,
    vote = true,
    License = true,
    hasLicense = true,
    mayor = true,
    Spawn = mayor_spawn,
    notVIP = true,
    nocuff = true,
    customCheck = function(ply)
        net.Start('VOTING_Confirm')
        net.Send(ply)
        return false
    end,
})

TEAM_GANG = rp.AddTeam("Мафія", {
    Color = Color(75, 75, 75, 255),
    Model = {
        "models/player/group03/female_01.mdl",
        "models/player/group03/female_02.mdl",
        "models/player/group03/female_03.mdl",
        "models/player/group03/female_04.mdl",
        "models/player/group03/female_06.mdl",
        "models/player/group03/male_01.mdl",
        "models/player/group03/male_02.mdl",
        "models/player/group03/male_03.mdl",
        "models/player/group03/male_04.mdl",
        "models/player/group03/male_05.mdl",
        "models/player/group03/male_06.mdl",
        "models/player/group03/male_07.mdl",
        "models/player/group03/male_08.mdl",
        "models/player/group03/male_09.mdl"
    },
    Description = [[Найнижча каста в кримінальному світі.
        Мафія зазвичай працює на главу мафії, який заправляє всіма справами.
        Крадіть, вбивайте на замовлення і дотримуйтесь агенди від боса, або ви, можливо, будете покарані.]],
    Weapons = {},
    Command = "gangster",
    category = "Кримінал",
    Max = 16,
    Salary = 45,
    admin = 0,
    vote = false,
})

TEAM_GANGVIP = rp.AddTeam("VIP Мафія", {
    Color = Color(75, 75, 75, 255),
    Model = {
        "models/player/Group01/Female_01.mdl",
        "models/player/Group01/Female_02.mdl",
        "models/player/Group01/Female_03.mdl",
        "models/player/Group01/Female_04.mdl",
        "models/player/Group01/Female_06.mdl",
        "models/player/group01/male_01.mdl",
        "models/player/Group01/Male_02.mdl",
        "models/player/Group01/male_03.mdl",
        "models/player/Group01/Male_04.mdl",
        "models/player/Group01/Male_05.mdl",
        "models/player/Group01/Male_06.mdl",
        "models/player/Group01/Male_07.mdl",
        "models/player/Group01/Male_08.mdl",
        "models/player/Group01/Male_09.mdl"
    },
    Description = [[Найнижча каста в Кримінальному світі.
        Бандит зазвичай працює на голову банди, який заправляє всіма справами.
        Крадіть, вбивайте на замовлення і дотримуйтесь агенди від боса, або ви, можливо, будете покарані.]],
    Weapons = {"m9k_ump45", "weapon_eginventory_checker", "moneychecker"},
    Command = "gangstervip",
    category = "Віп роботи",
    Max = 6,
    Salary = 45,
    admin = 0,
    vote = false,
    customCheck = function(ply) return ply:IsVIP() end,
})

TEAM_MANIAK = rp.AddTeam("Маніяк", {
    Color = Color(200, 75, 75, 255),
    Model = {
        "models/player/hostage/hostage_04.mdl"
    },
    Description = [[Ви маніяк! Вбивайте людей у безлюдних місцях! Ви можете використовувати тільки ніж!]],
    Weapons = {"swb_knife", "weapon_cuff_rope"},
    Command = "maniak",
    category = "Віп роботи",
    Max = 3,
    IsDisguse = true,
    Salary = 0,
    admin = 0,
    vote = false,
    customCheck = function(ply) return ply:IsVIP() end,
})

TEAM_GLCRIME = rp.AddTeam("Глава мафії", {
    Color = Color(0, 100, 255, 255),
    Model = {"models/player/gman_high.mdl"},
    Description = [[Ви провідний учасник усього
    приступного світу! Удачі! ]],
    Weapons = {"unarrest_stick", "lockpick"},
    Command = "glavamafiii",
    category = "Кримінал",
    Max = 1,
    Salary = 180,
    admin = 0,
    vote = false
})


TEAM_THIEFF = rp.AddTeam("Злодій", {
    Color = Color(135, 0, 200, 255),
    Model = {
        "models/player/Group01/female_02.mdl",
        "models/player/Group01/female_04.mdl",
        "models/player/Group01/female_01.mdl",
        "models/player/Group01/male_03.mdl",
        "models/player/Group01/male_05.mdl",
        "models/player/Group01/male_07.mdl",
        "models/player/Group02/male_04.mdl",
        "models/player/Group02/male_06.mdl",
        "models/player/Group02/male_02.mdl",
        "models/player/Group02/male_08.mdl"
    },
    Description = [[
    Ви дуже вправний ведмежатник з дитинства відчували потяг до цього ремесла,
    тепер ця робота - спосіб прогодувати себе, ви можете вступити в будь-яку банду і нажити на всьому цьому великі гроші,
    хапай в руку монтування і відмички і в дорогу.]],
    Weapons = {"lockpick"},
    Command = "thieff",
    category = "Кримінал",
    Max = 4,
    Salary = 50,
})


TEAM_THIEFF_VIP = rp.AddTeam("Кишеньковий злодій", {
    Color = Color(135, 0, 200, 255),
    Model = {

            "models/player/guerilla.mdl"
    },
    Description = [[Ваше завдання стати мільйонером. У вас є можливість грабувати людей! Дій!]],
    Weapons = {"lockpick", "base_keypadcracker",'swb_p228','grabej'},
    Command = "thieffvip",
    category = "Кримінал",
    Max = 4,
    Salary = 0,
    customCheck = function(ply)
        return ply:IsVIP()
    end
})

TEAM_KILL = rp.AddTeam("Найманий вбивця", {
    Color = Color(25, 25, 25, 255),
    Model = {"models/player/phoenix.mdl"},
    Description = [[Вас можуть найняти в банду або
    робити замовлення на вбивство.]],
    Weapons = {"m9k_m24"},
    Command = "hitmankill",
    IsDisguse = true,
    category = "Віп роботи",
    Max = 4,
    Salary = 0,
    hitman = true,
    customCheck = function(ply) return ply:IsVIP() end,
})

TEAM_GUN = rp.AddTeam("Продавець зброї", {
    Color = Color(255, 140, 0, 255),
    Model = {
            "models/player/monk.mdl",
            "models/player/alyx.mdl"
    },
    Description = [[
        Продавець зброї є єдиною людиною, яка може легально продавати зброю іншим людям.
       Переконайтеся в тому, що ви не продаєте
        нелегальні види озброєння у відкриту,
        інакше вас можуть заарештувати!]],
    Weapons = {},
    Command = "gundealer",
    category = "Бізнес",
    Max = 4,
    Salary = 589,
    admin = 0,
    vote = false,
})

TEAM_BANK = rp.AddTeam("Банкір", {
    Color = Color(79, 121, 66, 255),
    Model = {
        "models/player/hostage/hostage_01.mdl",
        "models/player/hostage/hostage_02.mdl",
        "models/player/hostage/hostage_03.mdl",
        "models/player/magnusson.mdl"
    },
    Description = [[
        Банкір може побудувати свій банк і приймати вклади інших людей.
        Врахуйте, що вам доведеться постійно зміцнювати захист свого Бізнесу, інакше вас можуть
        пограбувати і ваш банк втратить довіру гравців.]],
    Weapons = {},
    Command = "banker",
    category = "Бізнес",
    Max = 2,
    Salary = 879,
    admin = 0,
    vote = false
})

TEAM_DARKGUN = rp.AddTeam("Контрабандист", {
    Color = Color(25, 25, 25, 255),
    Model = {"models/player/monk.mdl"},
    Description = [[
    Продає нелегальну зброю.
    Може вступати в банди.
    ]],
    Weapons = {},
    Command = "darkgundealer",
    category = "Віп роботи",
    Max = 4,
    Salary = 120,
    customCheck = function(ply) return ply:IsVIP() end,
})

TEAM_SECURITY = rp.AddTeam("Охоронник", {
    Color = Color(0, 140, 255, 255),
    Model = {"models/player/odessa.mdl"},
    Description = [[Наймайтеся в охорону магазину, банку або охоронцем.
        Ви маєте захищати заклад від хуліганів і дрібних злодіїв.
        У разі складної ситуації викликайте поліцію.
        За замовчуванням вам дається Stunstick,
        тож не ризикуйте особливо, дійте обережно.]],
    Weapons = {"stun_baton"},
    Command = "security",
    category = "Інші",
    Max = 6,
    Salary = 389,
    admin = 0,
    vote = false,
})

TEAM_MEDIC = rp.AddTeam("Лікар", {
    Color = Color(47, 79, 79, 255),
    Model = {
    -- Мужчины
        "models/player/Group03m/male_01.mdl",
        "models/player/Group03m/male_02.mdl",
        "models/player/Group03m/male_03.mdl",
        "models/player/Group03m/male_04.mdl",
        "models/player/Group03m/male_05.mdl",
        "models/player/Group03m/male_06.mdl",
        "models/player/Group03m/male_07.mdl",
        "models/player/Group03m/male_08.mdl",
        "models/player/Group03m/male_09.mdl",
    -- Женщины
        "models/player/Group03m/female_01.mdl",
        "models/player/Group03m/female_02.mdl",
        "models/player/Group03m/female_03.mdl",
        "models/player/Group03m/female_04.mdl",
        "models/player/Group03m/female_05.mdl",
        "models/player/Group03m/female_06.mdl"
    },
    Description = [[Лікар здатний зцілювати гравців за допомогою своїх медичних знань.
        Використовуйте аптечку щоб лікувати себе або інших,
        або продавайте аптечки покупцям.]],
    Weapons = {"weapon_medkit"},
    Command = "medic",
    category = "Місцеві служби",
    Max = 4,
    Salary = 240,
    admin = 0,
    vote = false,
    medic = true,
})

TEAM_HOBO = rp.AddTeam("Безхатченко", {
    Color = Color(80, 45, 0, 255),
    Model = {"models/player/corpse1.mdl"},
    Description = [[Бездомний перебуває в самому низу суспільного ладу. Над ним усі сміються.
        У вас немає дому.
        Ви змушені просити їжу і гроші.
        Порпайтеся в сміттєвих баках для того щоб знайти корисні вам речі.
        Побудуйте будинок із дощечок і сміття, щоб сховатися від холоду.
        Ви можете поставити відро і написати на ньому прохання, щоб вам подавали грошей.
        Проявіть фантазію, влаштуйте циркову виставу, заспівайте. Таким чином ви можете отримати більше грошей.]],
    Weapons = {"weapon_bugbait","weapon_hl2brokenbottle"},
    Command = "hobo",
    category = "Інші",
    Max = 0,
    Salary = 0,
    admin = 0,
    vote = false,
    candemote = false,
    hobo = true,
    noAdvert = true
})
 TEAM_BA_OWNER = rp.AddTeam("Тваринник", {
   Color =  Color(235,157,10, 255),
   Model = {"models/player/odessa.mdl"},
   Description = [[
    Працівник тваринницької ферми.
    Вирощуйте будь-що - від маленького краба до великого лунатика!
    Годуйте їх і дбайте про них, навіть захищайте їх, якщо знадобиться!
   ]],
   Weapons = {},
   Command = "farmowner",
   Max = 3,
   Salary = 60,
   admin = 0,
   category = "Бізнес",
   vote = false,
   Armor = 100,
   hasLicense = false,
   candemote = true,
})


TEAM_BISNES = rp.AddTeam("Бізнесмен", {
    Color = Color(0, 100, 255, 255),
    Model = {"models/player/magnusson.mdl"},
    Description = [[Найкреативніша професія в його силах
    зробити з нічого щось, що приносить йому гроші, наприклад
    ( ви можете скупити всі двері в будинку і продавати квартирки )
    все залежить лише від вас і від ваших уявлень.]],
    Weapons = {},
    Command = "bisnes",
    category = "Бізнес",
    Max = 3,
    Salary = 620,
    admin = 0,
    vote = false
})

TEAM_NAIM = rp.AddTeam("Найманець", {
    Color = Color(228, 64, 64, 255),
    Model = {"models/player/phoenix.mdl"},
    Description = [[Ви працюєте тільки за гроші не важливо на кого ви зробите все що завгодно
    для вашого замовника ви можете викрасти міра,
    зламати за гроші чийсь будинок, вкрасти речі для замовника.
    удачі в нелегкій праці.]],
    Weapons = {},
    Command = "naim",
    category = "Кримінал",
    Max = 4,
    Salary = 0,
    admin = 0,
    hitman = true,
    vote = false,
})

TEAM_ADMIN = rp.AddTeam("Адміністратор", {
   Color = Color(219, 0, 0, 255),
   Model = {"models/vedatys/orangutan.mdl"},
   Description = [[NON RP]],
   Weapons = {"skeypad_checker",'gas_log_scanner'},
   Command = "admin",
   Spawn = adm_spawn,
   Max = 0,
   Salary = 450,
   IsDisguse = true,
   admin = 0,
   category = "Адміністрація",
   vote = false,
   Hunger = false,
   hasLicense = false,
   nocuff = true,
   PlayerLoadout = function(ply) ply:SetHealth(500) ply:ConCommand('adminmode') end,
   canDemote = false,
   customCheck = function(ply) return ply:IsModerator() end,
})

TEAM_BANNED = rp.AddTeam("Заблокований", {
   Color = Color(219, 0, 0, 255),
   Model = {'models/player/charple.mdl',},
   Description = [[NON RP]],
   Weapons = {},
   Command = "banned124",
   Spawn = banned_spawn,
   Max = 0,
   Salary = 0,
   IsDisguse = true,
   category = "Заблокований",
   vote = false,
   hasLicense = false,
   canDemote = false,
   customCheck = function(pl) return pl:IsBanned() end,
})

rp.CreateDoorGroup('Військові',TEAM_VENI,TEAM_VENI1, TEAM_VENI2)
rp.CreateDoorGroup('Держава', TEAM_MAYOR, TEAM_FBI, TEAM_POLICE, TEAM_POLICE_N)
rp.CreateDoorGroup('Банк', TEAM_BANK)

hook.Run('LoadingJobs')
--PATH addons/__main/lua/weapons/bobs_scoped_base/cl_init.lua:
include('shared.lua')

SWEP.PrintName				= ""				// 'Nice' Weapon name (Shown on HUD)	
SWEP.Slot				= 4				// Slot in the weapon selection menu
SWEP.SlotPos				= 1				// Position in the slot
SWEP.DrawAmmo				= true				// Should draw the default HL2 ammo counter				// Should draw the default crosshair
SWEP.DrawWeaponInfoBox			= true				// Should draw the weapon info box
SWEP.BounceWeaponIcon   			= true				// Should the weapon icon bounce?
SWEP.CSMuzzleFlashes			= true
--PATH addons/_ballistic_shields/lua/weapons/deployable_shield/shared.lua:
if SERVER then
	include( "ballistic_shields/sh_bs_util.lua" )
	include( "ballistic_shields/sv_bs_util.lua" )
end

include( "bs_config.lua" )
include( "ballistic_shields/sh_bs_lang.lua" )
SWEP.PrintName = "Deployable Shield"
SWEP.Author = "D3G"
SWEP.Instructions = "LMB - Deploy shield | RMB - Toggle visibility"
SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.ViewModel = ""
SWEP.WorldModel = "models/bshields/dshield.mdl"
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.Slot = 5
SWEP.SlotPos = 0
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
SWEP.Category = "Shields"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.CanVisToggle = true
SWEP.VisToggle = false
SWEP.HitDistance = 55
function SWEP:Initialize()
	self:SetHoldType( "melee2" )
end

function SWEP:DrawWorldModel()
	self:SetNoDraw( true )
end

local function bsGetHoldType( ply )
	if ply:LookupAttachment( "anim_attachment_RH" ) > 0 then return { 1, "anim_attachment_RH" } end
	if ply:LookupAttachment( "forward" ) > 0 then return { 2, "forward" } end
	return { 3, "anim_attachment_head" }
end

local ShieldIcon = Material( "bshields/ui/deployable_shield", "smooth" )
local ShieldIconClosed = Material( "bshields/ui/deployable_shield_closed", "smooth" )
local BackgroundIcon = Material( "bshields/ui/background" )
function SWEP:DrawHUD()
	if bshields.config.disablehud then return end
	surface.SetDrawColor( 255, 255, 255, 200 )
	surface.SetMaterial( BackgroundIcon )
	surface.DrawTexturedRect( ScrW() * 0.5 - ScrH() / 10, ScrH() * 0.5 - ScrH() / 30 + ScrH() / 3, ScrH() / 5, ScrH() / 15 )
	local aim = LocalPlayer():GetAimVector()
	local tr = util.TraceLine( {
		start = LocalPlayer():GetShootPos(),
		endpos = LocalPlayer():GetShootPos() + aim * 120,
		filter = LocalPlayer()
	} )

	surface.SetDrawColor( 255, 255, 255, 125 )
	if tr.HitPos:DistToSqr( LocalPlayer():GetPos() ) > 550 and tr.HitPos.z <= LocalPlayer():GetPos().z + 30 and ( tr.HitWorld or IsValid( tr.Entity ) and tr.Entity:GetClass() == "prop_physics" ) then
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].dshieldprim, onyx.Font( "Comfortaa@18" ), ScrW() * 0.5 - ScrH() / 32, ScrH() * 0.5 - ScrH() / 28 + ScrH() / 3 + ScrH() / 22, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color( 20, 20, 20, 255 ) )
		surface.SetMaterial( ShieldIcon )
	else
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].dshieldprim, onyx.Font( "Comfortaa@18" ), ScrW() * 0.5 - ScrH() / 32, ScrH() * 0.5 - ScrH() / 28 + ScrH() / 3 + ScrH() / 22, Color( 255, 255, 255, 25 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color( 20, 20, 20, 255 ) )
		surface.SetMaterial( ShieldIconClosed )
	end

	surface.DrawTexturedRect( ScrW() * 0.5 - ScrH() / 10.2, ScrH() * 0.5 - ScrH() / 32 + ScrH() / 3, ScrH() / 16, ScrH() / 16 )
	if self.VisToggle then
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].sec, onyx.Font( "Comfortaa@18" ), ScrW() * 0.5 - ScrH() / 32, ScrH() * 0.5 - ScrH() / 28 + ScrH() / 3 + ScrH() / 48, Color( 255, 255, 255, 25 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color( 20, 20, 20, 255 ) )
	else
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].sec, onyx.Font( "Comfortaa@18" ), ScrW() * 0.5 - ScrH() / 32, ScrH() * 0.5 - ScrH() / 28 + ScrH() / 3 + ScrH() / 48, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color( 20, 20, 20, 255 ) )
	end
end

function SWEP:Deploy()
	self.CanVisToggle = true
	self.VisToggle = false
	if SERVER then
		local owner = self:GetOwner()
		local holdtype = bsGetHoldType( owner )
		bshield_remove( owner )
		owner.bs_type = 2
		owner.bs_shield = ents.Create( "bs_dshield" )
		owner.bs_shield:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
		owner.bs_shield:SetMoveType( MOVETYPE_NONE )
		owner.bs_shield:SetPos( owner:GetPos() )
		owner.bs_shield:SetParent( owner, owner:LookupAttachment( holdtype[2] ) )
		owner.bs_shield:SetLocalAngles( bshields.shields[holdtype[1]][2].angles )
		owner.bs_shield:SetLocalPos( bshields.shields[holdtype[1]][2].position )
		owner.bs_shield:Spawn()
		net.Start( "bs_shield_info" )
		net.WriteUInt( owner.bs_shield:EntIndex(), 16 )
		net.Send( owner )
	end
end

function SWEP:PrimaryAttack()
	if SERVER then
		local owner = self:GetOwner()
		local aim = owner:GetAimVector()
		local tr = util.TraceLine( {
			start = owner:GetShootPos(),
			endpos = owner:GetShootPos() + aim * 120,
			filter = owner
		} )

		if tr.HitPos:DistToSqr( owner:GetPos() ) > 550 and tr.HitPos.z <= owner:GetPos().z + 30 and ( tr.HitWorld or IsValid( tr.Entity ) and tr.Entity:GetClass() == "prop_physics" ) then
			shield = ents.Create( "bs_shield" )
			shield:SetPos( tr.HitPos + Vector( 0, 0, 28.5 ) - aim * 10 )
			shield:SetAngles( Angle( 0, aim:Angle().y, 0 ) )
			shield:Spawn()
			shield:EmitSound( "npc/combine_soldier/gear1.wav" )
			shield.Owner = owner
			bshield_remove( owner )
			owner:StripWeapon( "deployable_shield" )
			table.insert( owner.bs_shields, shield )
			if table.Count( owner.bs_shields ) > bshields.config.maxshields then
				if IsValid( owner.bs_shields[1] ) then owner.bs_shields[1]:Remove() end
				table.remove( owner.bs_shields, 1 )
			end
		end

		self:SetNextPrimaryFire( CurTime() + 0.5 )
	end
end

function SWEP:SecondaryAttack()
	if CLIENT then
		if not self.CanVisToggle then return end
		surface.PlaySound( "weapons/smg1/switch_single.wav" )
		if not LocalPlayer().bs_shieldIndex then return end
		if not self.VisToggle then
			local ent = Entity( LocalPlayer().bs_shieldIndex )
			if IsValid( ent ) then Entity( LocalPlayer().bs_shieldIndex ):SetColor( Color( 0, 0, 0, 125 ) ) end
			self.VisToggle = true
		else
			local ent = Entity( LocalPlayer().bs_shieldIndex )
			if IsValid( ent ) then Entity( LocalPlayer().bs_shieldIndex ):SetColor( Color( 255, 255, 255 ) ) end
			self.VisToggle = false
			self.VisToggle = false
		end

		self.CanVisToggle = false
		timer.Simple( 0.1, function()
			if not IsValid( self ) then return end
			self.CanVisToggle = true
		end )
	end
end

if CLIENT then return end
function SWEP:Holster()
	bshield_remove( self:GetOwner() )
	return true
end

function SWEP:OnRemove()
	bshield_remove( self:GetOwner() )
	return true
end

function SWEP:OnDrop()
	bshield_remove( self:GetOwner() )
	return true
end
--PATH gamemodes/darkrp/entities/weapons/gmod_tool/stools/creator.lua:
TOOL.AddToMenu = false
TOOL.ClientConVar[ "type" ] = "0"
TOOL.ClientConVar[ "name" ] = "0"
TOOL.ClientConVar[ "arg" ] = "0"

-- A little hacky function to help prevent spawning props partially inside walls
-- Maybe it should use physics object bounds, not OBB, and use physics object bounds to initial position too

if SERVER then

local function fixupProp( ply, ent, hitpos, mins, maxs )
	local entPos = ent:GetPos()
	local endposD = ent:LocalToWorld( mins )
	local tr_down = util.TraceLine( {
		start = entPos,
		endpos = endposD,
		filter = { ent, ply }
	} )

	local endposU = ent:LocalToWorld( maxs )
	local tr_up = util.TraceLine( {
		start = entPos,
		endpos = endposU,
		filter = { ent, ply }
	} )

	-- Both traces hit meaning we are probably inside a wall on both sides, do nothing
	if ( tr_up.Hit && tr_down.Hit ) then return end

	if ( tr_down.Hit ) then ent:SetPos( entPos + ( tr_down.HitPos - endposD ) ) end
	if ( tr_up.Hit ) then ent:SetPos( entPos + ( tr_up.HitPos - endposU ) ) end
end

local function TryFixPropPosition( ply, ent, hitpos )
	fixupProp( ply, ent, hitpos, Vector( ent:OBBMins().x, 0, 0 ), Vector( ent:OBBMaxs().x, 0, 0 ) )
	fixupProp( ply, ent, hitpos, Vector( 0, ent:OBBMins().y, 0 ), Vector( 0, ent:OBBMaxs().y, 0 ) )
	fixupProp( ply, ent, hitpos, Vector( 0, 0, ent:OBBMins().z ), Vector( 0, 0, ent:OBBMaxs().z ) )
end

function Spawn_Weapon( ply, wepname, tr )

	-- We don't support this command from dedicated server console
	if ( !IsValid( ply ) ) then return end

	if !ply:IsDeveloper() then
		return false 
	end


	if ( wepname == nil ) then return end

	local swep = list.Get( "Weapon" )[ wepname ]

	-- Make sure this is a SWEP
	if ( swep == nil ) then return end

	-- You're not allowed to spawn this!
	if ( ( !swep.Spawnable && !ply:IsAdmin() ) or ( swep.AdminOnly && !ply:IsAdmin() ) ) then
		return
	end


	if ( !tr ) then
		tr = ply:GetEyeTraceNoCursor()
	end

	if ( !tr.Hit ) then return end

	local entity = ents.Create( swep.ClassName )

	if ( !IsValid( entity ) ) then return end

	

	entity:SetPos( tr.HitPos + tr.HitNormal * 32 )
	entity:Spawn()

	entity:SetSpawnEffect( true )

	undo.Create( "SWEP" )
		undo.SetPlayer( ply )
		undo.AddEntity( entity )
		undo.SetCustomUndoText( "Undone " .. tostring( swep.PrintName ) )
	undo.Finish( "Scripted Weapon (" .. tostring( swep.ClassName ) .. ")" )

	-- Throw it into SENTs category
	ply:AddCleanup( "sents", entity )

	TryFixPropPosition( ply, entity, tr.HitPos )

	gamemode.Call( "PlayerSpawnedSWEP", ply, entity )

end

end

function TOOL:LeftClick(trace, attach)

	local type = self:GetClientNumber("type", 0)
	local name = self:GetClientInfo("name", 0)
	local arg = self:GetClientInfo("arg", 0)

	if (CLIENT) then return true end

	if (type == 0) then

		Spawn_SENT(self:GetOwner(), name, trace)

	elseif (type == 1) then

		Spawn_Vehicle(self:GetOwner(), name, trace)

	elseif (type == 2) then

		Spawn_NPC(self:GetOwner(), name, arg, trace)

	elseif (type == 3) then
	   	Spawn_Weapon(self:GetOwner(), name, trace)
	elseif (type == 4) then

		CCSpawn(self:GetOwner(), nil, { name }) -- Props

	end

	return true

end
--PATH gamemodes/darkrp/entities/weapons/keys.lua:

-----------------------------------------------------
AddCSLuaFile()
SWEP.Base = 'weapon_rp_base'

if CLIENT then
	SWEP.PrintName = 'Ключі'
	SWEP.Slot = 1
	SWEP.SlotPos = 0
	SWEP.Instructions = 'ЛКП - Закрити двері/Постукати \nПКМ - Відкрити двері/Позвонити у двері\nR - Продати'
	SWEP.Spawnable = true
end

SWEP.ViewModel = Model('models/weapons/v_hands.mdl')
SWEP.ViewModelFOV = 62
SWEP.HitDistance = 100

local bell = {
	sound = Sound('ambient/alarms/warningbell1.wav'),
	delay = 10
}

local knock = {
	sound = Sound('physics/wood/wood_crate_impact_hard2.wav'),
	delay = 5
}

local LockDoor

function SWEP:PreDrawViewModel(vm)
	vm:SetMaterial('engine/occlusionproxy')
end

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
	self.Primary.Sound = {Sound('npc/metropolice/gear1.wav'), Sound('npc/metropolice/gear2.wav'), Sound('npc/metropolice/gear3.wav'), Sound('npc/metropolice/gear4.wav'), Sound('npc/metropolice/gear5.wav'), Sound('npc/metropolice/gear6.wav')}
	self._Reload.Delay = 2
end

function SWEP:Deploy()
	if timer.Exists("KeyHands") then
		timer.Remove("KeyHands")
	end -- Fucking SWEP function order

	if not self.UseHands then
		self.UseHands = true
	end

	timer.Create("KeyHands", 1, 1, function()
		self.UseHands = false
	end)
end

if SERVER then
	LockDoor = function(self, lock)
		self.Owner:LagCompensation(true)
		local ent = self.Owner:GetEyeTrace().Entity

		self.Owner:LagCompensation(false)
		if not IsValid(ent) or not ent:IsDoor() or (ent:GetPos():Distance(self.Owner:GetPos()) > self.HitDistance) then return end
		local IsOwner = (ent:DoorOwnedBy(self.Owner) or ent:DoorCoOwnedBy(self.Owner))

		if (not IsOwner) then
			if lock and (not ent.NextKnock or ent.NextKnock <= CurTime()) then
				self.Owner:EmitSound(knock.sound, 100, math.random(90, 110))
				ent.NextKnock = CurTime() + knock.delay
			elseif ((not ent.NextBell) or (ent.NextBell <= CurTime())) and IsValid(ent:DoorGetOwner()) then
				//rp.Notify(ent:DoorGetOwner(), NOTIFY_GENERIC, rp.Term('PlayerRangDoorbell'))
				self.Owner:EmitSound(bell.sound, 100, 110)
				ent.NextBell = CurTime() + bell.delay
			end

			self.Owner:AnimRestartGesture(GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_HL2MP_GESTURE_RANGE_ATTACK_FIST, true)

			return
		end

		if (ent.PickedAt and ent.PickedAt + 2 > CurTime()) then
			//rp.Notify(self.Owner, NOTIFY_GENERIC, rp.Term('KeysCooldown'))

			return
		end

		self.Owner:AnimRestartGesture(GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_GMOD_GESTURE_ITEM_PLACE, true)
		self.Owner:EmitSound(self.Primary.Sound[math.random(1, 6)])
		ent:DoorLock(lock)
		rp.Notify(self.Owner, NOTIFY_GENERIC, lock and 'Двері закриті.' or 'Двері откриті.',"")
	end
end

function SWEP:PrimaryAttack()
	if SERVER then
		LockDoor(self, true)
	end

	self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
	self:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
end

function SWEP:SecondaryAttack()
	if SERVER then
		LockDoor(self, false)
	end

	self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
	self:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
end

function SWEP:Reload()
	if not self:CanReload() then return end

	if CLIENT then
		RunConsoleCommand("_DarkRP_AnimationMenu")
	end

	self:SetNextReload(CurTime() + self._Reload.Delay)
end

function SWEP:OnRemove()
	if timer.Exists("KeyHands") then
		timer.Remove("KeyHands")
	end

	if not IsValid(self.Owner) then return end
	local vm = self.Owner:GetViewModel()

	if IsValid(vm) then
		vm:SetMaterial("")
	end
end

function SWEP:Holster()
	self:OnRemove()

	return true
end
--PATH addons/__main/lua/weapons/m9k_ithacam37/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_ithacam37") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Shotguns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Ithaca M37"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 22			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "shotgun"	-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_ithaca_m37shot.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_ithaca_m37.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_shotty_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("IthacaM37.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 60		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 6			-- Size of a clip
SWEP.Primary.DefaultClip		= 30	-- Default number of bullets in a clip
SWEP.Primary.KickUp				= .9				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.6		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.6	-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "buckshot"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 
SWEP.ShellTime			= .4

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 8		-- How many bullets to shoot per trigger pull, AKA pellets
SWEP.Primary.Damage		= 12	-- Base damage per bullet
SWEP.Primary.Spread		= .023	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .023	-- Ironsight accuracy, should be the same for shotguns
-- Because irons don't magically give you less pellet spread!

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(2.16, -1.429, 0.6)
SWEP.IronSightsAng = Vector(3, 0, 0)
SWEP.SightsPos = Vector(2.16, -1.429, 0.6)
SWEP.SightsAng = Vector(3, 0, 0)
SWEP.RunSightsPos = Vector(-3.116, -3.935, 0.492)
SWEP.RunSightsAng = Vector(-19.894, -47.624, 10.902)


if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_m416/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_m416") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "HK 416"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 36			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_hk416rif.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_hk_416.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= true
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("hk416weapon.UnsilSingle")		-- Script that calls the primary fire sound
SWEP.Primary.SilencedSound 	= Sound("hk416weapon.SilencedSingle")
SWEP.Primary.RPM			= 800			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.4		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.4		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.6		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.CanBeSilenced		= true
SWEP.Primary.Ammo			= "ar2"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 30	-- Base damage per bullet
SWEP.Primary.Spread		= .025	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .015 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-2.892, -2.132, 0.5)
SWEP.IronSightsAng = Vector(-0.033, 0.07, 0)
SWEP.SightsPos = Vector(-2.892, -2.132, 0.5)
SWEP.SightsAng = Vector(-0.033, 0.07, 0)
SWEP.RunSightsPos = Vector(2.125, -0.866, 1.496)
SWEP.RunSightsAng = Vector(-18.08, 30.59, 0)

SWEP.SelectiveFire		= true

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end


if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_m4a1/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_m4a1") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= "iron angles and models hexed and converted to gmod my Mr Fokkusu"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "M4A1 Iron"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 33			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_m4a1_iron.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_m4a1_iron.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Dmgfok_M4A1.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 800			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.4		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.4		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.5		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "ar2"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 30	-- Base damage per bullet
SWEP.Primary.Spread		= .02	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .01 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector (2.4537, 1.0923, 0.2696)
SWEP.IronSightsAng = Vector (-0.0105, -0.0061, 0)
SWEP.SightsPos = Vector (2.4537, 1.0923, 0.2696)
SWEP.SightsAng = Vector (-0.0105, -0.0061, 0)
SWEP.RunSightsPos = Vector (-3.0328, 0, 1.888)
SWEP.RunSightsAng = Vector (-24.2146, -36.522, 10)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_m98b/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_m98b") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Sniper Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Barret M98B"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 44			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= false		-- Set false if you want no crosshair from hip
SWEP.XHair					= false		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.Weight				= 50			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.BoltAction				= true		-- Is this a bolt action rifle?
SWEP.HoldType 				= "rpg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_m98bravo.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_barrett_m98b.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("M98.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 50		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 10		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp				= 1				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 1			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 1		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "SniperPenetratedRound"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.ScopeZoom			= 9	
SWEP.Secondary.UseACOG			= false -- Choose one scope type
SWEP.Secondary.UseMilDot		= false	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= true	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= false
SWEP.Secondary.UseMatador		= false

SWEP.data 				= {}
SWEP.data.ironsights		= 1
SWEP.ScopeScale 			= 0.7
SWEP.ReticleScale 			= 0.6

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 90	--base damage per bullet
SWEP.Primary.Spread		= .001	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .0001 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector(-2.196, -2, 1)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(-2.196, -2, 1)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(3.714, -3.714, 0.286)
SWEP.RunSightsAng = Vector(-7, 43, 0)


if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_mp9/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_mp9") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Submachine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "MP9"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 49			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_b_t_mp9.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_brugger_thomet_mp9.mdl"	-- Weapon world model 
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_mp9.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 900			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.2		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.1		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.2		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "ar2"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 20	-- Base damage per bullet
SWEP.Primary.Spread		= .023	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .014 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(4.073, -3.438, 1.259)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(4.073, -3.438, 1.259)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(-3.708, -6.172, 0)
SWEP.RunSightsAng = Vector(-7.661, -62.523, 0)


if (gmod.GetGamemode().Name == "Murderthon 9000") then

	SWEP.Slot		= 1				-- Slot in the weapon selection menu
	SWEP.Weight		= 3			-- rank relative ot other weapons. bigger is better

end

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_sl8/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_sl8") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Sniper Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "HK SL8"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 47			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= false		-- Set false if you want no crosshair from hip
SWEP.XHair					= false		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.Weight				= 50			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.BoltAction				= false		-- Is this a bolt action rifle?
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_hk_sl8.mdl"
SWEP.WorldModel				= "models/weapons/w_hk_sl8.mdl"
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Weapon_hksl8.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 300		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp				= .6				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= .6			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= .6		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "ar2"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets
SWEP.SelectiveFire		= true

SWEP.Secondary.ScopeZoom			= 4	
SWEP.Secondary.UseACOG			= true -- Choose one scope type
SWEP.Secondary.UseMilDot		= false	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= false
SWEP.Secondary.UseMatador		= false

SWEP.data 				= {}
SWEP.data.ironsights		= 1
SWEP.ScopeScale 			= 0.9
SWEP.ReticleScale 			= 0.7

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 60	--base damage per bullet
SWEP.Primary.Spread		= .015	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .001 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector(3.079, -1.333, 0.437)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(3.079, -1.333, 0.437)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(-6.22, -5.277, 0)
SWEP.RunSightsAng = Vector(-10.671, -64.598, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_tec9/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_tec9") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Submachine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "TEC-9"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 53			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 60
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_tec_9_smg.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_intratec_tec9.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_Tec9.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 825			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 32		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.2		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.1		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 17	-- Base damage per bullet
SWEP.Primary.Spread		= .029	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .019 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(4.314, -1.216, 2.135)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(4.314, -1.216, 2.135)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(-5.434, -1.181, 0.393)
SWEP.RunSightsAng = Vector(-6.89, -42.166, 0)

if (gmod.GetGamemode().Name == "Murderthon 9000") then

	SWEP.Slot		= 1				-- Slot in the weapon selection menu
	SWEP.Weight		= 3			-- rank relative ot other weapons. bigger is better

end


if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_ump45/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_ump45") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Submachine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "HK UMP45"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 55			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "smg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_hk_ump_45.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_hk_ump45.mdl"	-- Weapon world model 
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("m9k_hk_ump45.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 600			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 25		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.2		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.4		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.45		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 20	-- Base damage per bullet
SWEP.Primary.Spread		= .028	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .018 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(2.826, -1.601, 1.259)
SWEP.IronSightsAng = Vector(-0.055, 0, 0)
SWEP.SightsPos = Vector(2.826, -1.601, 1.259)
SWEP.SightsAng = Vector(-0.055, 0, 0)
SWEP.RunSightsPos = Vector(-3.386, -4.488, 1.18)
SWEP.RunSightsAng = Vector(-17.362, -48.78, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_uzi/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_uzi") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Submachine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "UZI"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 57			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_imi_uzi01.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_uzi_imi.mdl"	-- Weapon world model 
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_uzi.single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 600			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 32		-- Size of a clip
SWEP.Primary.DefaultClip		= 64		-- Bullets you start with
SWEP.Primary.KickUp				= 0.3		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 65		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 20	-- Base damage per bullet
SWEP.Primary.Spread		= .028	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .018 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-2.951, -2.629, 1.633)
SWEP.IronSightsAng = Vector(0.109, -0.772, 1.725)
SWEP.SightsPos = Vector(-2.951, -2.629, 1.633)
SWEP.SightsAng = Vector(0.109, -0.772, 1.725)
SWEP.RunSightsPos = Vector(3.858, -2.945, 0.057)
SWEP.RunSightsAng = Vector(-5.237, 40.471, 0)

if (gmod.GetGamemode().Name == "Murderthon 9000") then

	SWEP.Slot		= 1				-- Slot in the weapon selection menu
	SWEP.Weight		= 3			-- rank relative ot other weapons. bigger is better

end


if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/mauserdragon/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = "mauserdragon"
SWEP.Category = "Weapons"
SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""
SWEP.PrintName = "Mauser M1896 Royal Dragon"
SWEP.Slot = 2
SWEP.SlotPos = 3
SWEP.DrawAmmo = true
SWEP.DrawWeaponInfoBox = false
SWEP.BounceWeaponIcon = false
SWEP.DrawCrosshair = true
SWEP.Weight = 30
SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = true
SWEP.HoldType = "pistol"
SWEP.ViewModelFOV = 70
SWEP.ViewModelFlip = true
SWEP.ViewModel = "models/weapons/v_royl_p228.mdl"
SWEP.WorldModel = "models/weapons/w_royl_p228.mdl"
SWEP.ShowWorldModel = false
SWEP.Base = "clout_gun_base"
SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.FiresUnderwater = false
SWEP.Primary.Sound = Sound( "p250_mehndifire" )
SWEP.Primary.SilencedSound = Sound( "" )
SWEP.Primary.RPM = 400
SWEP.Primary.ClipSize = 13
SWEP.Primary.DefaultClip = 26
SWEP.Primary.KickUp = 0.2
SWEP.Primary.KickDown = 0.1
SWEP.Primary.KickHorizontal = 0.1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "pistol"
SWEP.SelectiveFire = false
SWEP.CanBeSilenced = false
SWEP.Secondary.IronFOV = 55
SWEP.data = {}
SWEP.data.ironsights = 1
SWEP.Primary.Damage = 27
SWEP.Primary.Spread = .045
SWEP.Primary.IronAccuracy = .01
SWEP.IronSightsPos = Vector( 4.76, -3.765, 2.799 )
SWEP.IronSightsAng = Vector( 0.116, 0.059, 0.842 )
SWEP.SightsPos = Vector( 3.8, -2.765, 2 )
SWEP.SightsAng = Vector( 0.116, 0.059, 0.842 )
SWEP.RunSightsPos = Vector( -0.94, -9.57, -5.051 )
SWEP.RunSightsAng = Vector( 70, 0, 0 )
SWEP.WElements = {
	["p250meh_w"] = {
		type = "Model",
		model = "models/weapons/w_royl_p228.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector( 0, 0.56, 0 ),
		angle = Angle( -0.136, -5.81, 180 ),
		size = Vector( 1, 1, 1 ),
		color = Color( 255, 255, 255, 255 ),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}
--PATH gamemodes/darkrp/entities/weapons/med_kit.lua:
AddCSLuaFile()

SWEP.Base = 'weapon_rp_base'

if CLIENT then
	SWEP.PrintName = "Аптечка"
	SWEP.Slot = 2
	SWEP.Purpose = ""
	SWEP.Instructions = ""
end

SWEP.ViewModel = Model("models/weapons/c_medkit.mdl")
SWEP.WorldModel = Model("models/weapons/w_medkit.mdl")

SWEP.Spawnable = true
SWEP.Category = "RP"

SWEP.Primary.Delay = 0.08
SWEP.Secondary.Delay = 0.08

SWEP.Primary.Sound = Sound('hl1/fvox/boop.wav')

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)

	self._Reload.Sound = {
		Sound('npc_citizen.health01'),
		Sound('npc_citizen.health02'),
		Sound('npc_citizen.health03'),
		Sound('npc_citizen.health04'),
		Sound('npc_citizen.health05')
	}
end

function SWEP:PrimaryAttack()
	if not IsValid(self.Owner) then return end

	self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)

	if CLIENT then return end

	self.Owner:LagCompensation(true)
		local ent = self.Owner:GetEyeTrace().Entity
	self.Owner:LagCompensation(false)

	local health = (IsValid(ent) and ent:IsPlayer()) and ent:Health()

	if not isnumber(health) or health >= 100 or (self.Owner:GetPos():Distance(ent:GetPos()) > self.HitDistance) then return end
	
	ent:SetHealth(health + 1)
	self.Owner:EmitSound(self.Primary.Sound, 45, health)
end

function SWEP:SecondaryAttack()
	if not IsValid(self.Owner) then return end

	self:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)

	local health = SERVER and self.Owner:Health()

	if CLIENT or health >= 100 then return end

	self.Owner:SetHealth(health + 1)
	self.Owner:EmitSound(self.Primary.Sound, 45, health)
end

function SWEP:Reload()
	if not IsValid(self.Owner) or not self:CanReload() then return end

	self:SetNextReload(CurTime() + self._Reload.Delay)

	if CLIENT then return end

	self.Owner:EmitSound(self._Reload.Sound[math.random(1,5)], 50)
end
--PATH addons/_ballistic_shields/lua/ballistic_shields/sh_bs_lang.lua:
include( "ballistic_shields/sh_bs_util.lua" )
bshields.lang = {
	["English"] = {
		["sec"] = "[RMB] VISIBILITY",
		["dshieldprim"] = "[LMB] DEPLOY",
		["hshieldprim"] = "[LMB] BREACH DOOR",
		["rshieldprim"] = "[LMB] ATTACK",
		["hshieldcd1"] = "Wait ",
		["hshieldcd2"] = " seconds to breach next door!"
	},
	["German"] = {
		["sec"] = "[RMB] SICHTBARKEIT",
		["dshieldprim"] = "[LMB] PLAZIEREN",
		["hshieldprim"] = "[LMB] TÜR AUFBRECHEN",
		["rshieldprim"] = "[LMB] ANGREIFEN",
		["hshieldcd1"] = "Warte ",
		["hshieldcd2"] = " Sekunden für das Aufbrechen der nächsten Tür!"
	},
	["French"] = {
		["sec"] = "[RMB] VISIBILITÉ",
		["dshieldprim"] = "[LMB] DÉPLOYER",
		["hshieldprim"] = "[LMB] FORCER LA PORTE",
		["rshieldprim"] = "[LMB] ATTAQUER",
		["hshieldcd1"] = "Attendez ",
		["hshieldcd2"] = " secondes pour forcer la porte !"
	},
	["Danish"] = {
		["sec"] = "[RMB] SIGTBARHED",
		["dshieldprim"] = "[LMB] SÆT",
		["hshieldprim"] = "[LMB] BREACH DØR",
		["rshieldprim"] = "[LMB] ANGRIB",
		["hshieldcd1"] = "Vent ",
		["hshieldcd2"] = " sekunder at bryde ved siden af!"
	},
	["Turkish"] = {
		["sec"] = "[RMB] GORUNURLUK",
		["dshieldprim"] = "[LMB] YERLESTIR",
		["hshieldprim"] = "[LMB] BREACH DOOR",
		["rshieldprim"] = "[LMB] SALDIR",
		["hshieldcd1"] = "Bekle ",
		["hshieldcd2"] = " bir sonraki kapıyı kırmaya saniye kaldı!"
	},
	["Russian"] = {
		["sec"] = "[ПКМ] ВИДИМОСТЬ",
		["dshieldprim"] = "[ЛКМ] ПОСТАВИТЬ",
		["hshieldprim"] = "[ЛКМ] ВЫБИТЬ ДВЕРЬ",
		["rshieldprim"] = "[ЛКМ] УДАРИТЬ",
		["hshieldcd1"] = "Подождите ",
		["hshieldcd2"] = " секунд чтоб выбить дверь!"
	},
	["Ukrainian"] = {
		["sec"] = "[ПКМ] ВИДИМІСТЬ",
		["dshieldprim"] = "[ЛКМ] ПОСТАВИТИ",
		["hshieldprim"] = "[ЛКМ] ВИБИТИ ДВЕРІ",
		["rshieldprim"] = "[ЛКМ] ВДАРИТИ",
		["hshieldcd1"] = "Зачекайте ",
		["hshieldcd2"] = " секунд щоб вибити двері!"
	}
}

if bshields.lang[bshields.config.language] == nil then bshields.config.language = "English" end
--PATH addons/__________skeypads/lua/weapons/skeypad_cracker_base/cl_init.lua:
include( 'shared.lua' )
SWEP.CrackStartTime = 0
function SWEP:PrimaryAttack()
    self:SetNextPrimaryFire( CurTime() + 0.3 )
    if self.IsCracking then return end
    local owner = self:GetOwner()
    local tr = owner:GetEyeTrace()
    local ent = tr.Entity
    if IsValid( ent ) and tr.HitPos:DistToSqr( owner:GetShootPos() ) <= 80 ^ 2 and ent:GetClass() == 'skeypad' then
        self.IsCracking = true
        self.CrackStartTime = CurTime()
        self:SetWeaponHoldType( 'pistol' )
    end
end

local font1 = onyx.FontNoScale( 'Comfortaa Bold', 60 )
local circleMat = onyx.wimg.Create( 'cracker_circle', 'noclamp smooth' )
local centerX = -190
local function lerpColor( t, from, to )
    local result = Color( 0, 0, 0 )
    result.r = Lerp( t, from.r, to.r )
    result.g = Lerp( t, from.g, to.g )
    result.b = Lerp( t, from.b, to.b )
    result.a = Lerp( t, from.a, to.a )
    return result
end

local col1 = Color( 137, 145, 255 )
local col2 = Color( 125, 125, 125 )
local col3 = Color( 204, 45, 45 )
local col4 = Color( 45, 204, 85 )
function SWEP:PostDrawViewModel( vm )
    if not IsValid( vm ) then return end
    local bone = vm:LookupBone( 'v_weapon.c4' )
    if not bone then return end
    local pos, ang = vm:GetBonePosition( bone )
    if not pos then return end
    ang:RotateAroundAxis( ang:Right(), 180 )
    ang:RotateAroundAxis( ang:Forward(), -90 )
    cam.Start3D2D( pos - ang:Right() * 0.75 + ang:Up() * 3.6 + ang:Forward() * 4.33, ang, 0.005 )
    if not self.IsCracking then
        draw.SimpleText( self.PrintName, font1, centerX, 90, col1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        draw.DrawText( 'Натисніть на кейпад,\nщоб зламати його', font1, centerX, 130, col2, TEXT_ALIGN_CENTER )
        cam.End3D2D()
        return
    end

    draw.SimpleText( 'Злом кейпада...', font1, centerX, 90, col1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    local circleSize = 50
    local circleSpacing = 20
    local circleX = centerX - ( circleSize * 3 + circleSpacing * 2 ) * 0.5
    local col = lerpColor( ( CurTime() - self.CrackStartTime ) / self.CrackTime, col3, col4 )
    for i = 0, 2 do
        circleMat( circleX + i * ( circleSize + circleSpacing ), 160 + math.abs( math.sin( ( CurTime() + i * .2 ) * 2 ) ) * 25, circleSize, circleSize, col )
    end

    cam.End3D2D()
end
--PATH addons/swb_css/lua/weapons/swb_aug/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Steyr AUG"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-7.52, -13.806, 2.119)
	SWEP.AimAng = Vector(0, 0, 0)
		
	SWEP.SprintPos = Vector(0, 0, 0)
	SWEP.SprintAng = Vector(-7.739, 28.141, 0)
	
	SWEP.ViewModelMovementScale = 1.15
	
	SWEP.DrawBlackBarsOnAim = true
	SWEP.AimOverlay = surface.GetTextureID("swb/scope_rifle")
	SWEP.FadeDuringAiming = true
	SWEP.MoveWepAwayWhenAiming = true
	SWEP.ZoomAmount = 50
	SWEP.DelayedZoom = true
	SWEP.SnapZoom = true
	SWEP.SimulateCenterMuzzle = true
	
	SWEP.IconLetter = "e"
	
	SWEP.MuzzleEffect = "swb_rifle_med"
end

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.FadeCrosshairOnAim = true
SWEP.PreventQuickScoping = true

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.SpeedDec = 25
SWEP.BulletDiameter = 5.56
SWEP.CaseLength = 45

SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_rif_aug.mdl"
SWEP.WorldModel		= "models/weapons/w_rif_aug.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 30
SWEP.Primary.DefaultClip	= 30
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "smg1"

SWEP.FireDelay = 0.08
SWEP.FireSound = Sound("Weapon_AUG.Single")
SWEP.Recoil = 1.05

SWEP.HipSpread = 0.053
SWEP.AimSpread = 0.0015
SWEP.VelocitySensitivity = 2.1
SWEP.MaxSpreadInc = 0.05
SWEP.SpreadPerShot = 0.01
SWEP.SpreadCooldown = 0.15
SWEP.Shots = 1
SWEP.Damage = 26
SWEP.DeployTime = 1
--PATH addons/swb_base/lua/weapons/swb_base/cl_model.lua:
SWEP.BlendPos = Vector(0, 0, 0)
SWEP.BlendAng = Vector(0, 0, 0)
SWEP.OldDelta = Angle(0, 0, 0)
SWEP.AngleDelta = Angle(0, 0, 0)
SWEP.FireMove = 0
SWEP.ViewModelMovementScale = 1
SWEP.Sequence = ""
SWEP.Cycle = 0
SWEP.NoStockShells = true
SWEP.NoStockMuzzle = true

local Vec0 = Vector(0, 0, 0)
local TargetPos, TargetAng, cos1, sin1, tan, ws, rs, mod, EA, delta, sin2, mul, vm, muz, muz2, tr, att
local td = {}

local reg = debug.getregistry()
local GetVelocity = reg.Entity.GetVelocity
local Length = reg.Vector.Length
local Right = reg.Angle.Right
local Up = reg.Angle.Up
local Forward = reg.Angle.Forward
local RotateAroundAxis = reg.Angle.RotateAroundAxis

function SWEP:GetTracerOrigin()
	if self.dt.State == SWB_AIMING and self.SimulateCenterMuzzle then
		return self.CenterPos
	end
end

function SWEP:CreateShell(sh)
	if not IsValid(self.Owner) or self.Owner:ShouldDrawLocalPlayer() or self.NoShells then
		return
	end
	
	sh = self.Shell or sh
	vm = self.Owner:GetViewModel()
	
	if not IsValid(vm) then
		return
	end

	att = vm:GetAttachment(2)
	
	if att then
		if self.InvertShellEjectAngle then
			dir = -att.Ang:Forward()
		else
			dir = att.Ang:Forward()
		end
		
		SWB_MakeFakeShell(sh, att.Pos + dir, EyeAngles(), dir * 200, 0.6, 10, self.ShellScale)
	end
end

function SWEP:CreateMuzzle(pos, ang)
	/*
	if self.Owner:ShouldDrawLocalPlayer() then
		return
	end

	vm = self.Owner:GetViewModel()
	
	if IsValid(vm) then
		vm:StopParticles()

		muz = vm:LookupAttachment("1")
		
		if muz then
			muz2 = vm:GetAttachment(muz)
			
			if muz2 then
				EA = EyeAngles()
				
				if self.MuzzlePosMod then
					pos = pos + EA:Right() * self.MuzzlePosMod.x + EA:Forward() * self.MuzzlePosMod.y + EA:Up() * self.MuzzlePosMod.z
				end
				
				if self.dt.State == SWB_AIMING and self.SimulateCenterMuzzle then
					pos = self.Owner:GetShootPos() + EA:Forward() * 15 - EA:Up() * 6
					self.CenterPos = pos
				end
				
				if self.dt.Suppressed then
					if self.MuzzleEffectSupp then
						if not self.NoSilMuz then
							if self.dt.State == SWB_AIMING and self.SimulateCenterMuzzle then
								ParticleEffect(self.MuzzleEffectSupp, pos + self.Owner:GetVelocity() * 0.03, EA, vm)
							else
								if self.PosBasedMuz then
									ParticleEffect(self.MuzzleEffectSupp, pos + self.Owner:GetVelocity() * 0.03, EA, vm) -- using velocity to add to the position 'simulates' attaching it to a control point
								else
									ParticleEffectAttach(self.MuzzleEffectSupp, PATTACH_POINT_FOLLOW, vm, muz)
								end
							end
						end
					end
				else
					if self.MuzzleEffect then
						if self.dt.State == SWB_AIMING and self.SimulateCenterMuzzle then
							ParticleEffect(self.MuzzleEffect, pos + self.Owner:GetVelocity() * 0.03, EA, vm)
						else
							if self.PosBasedMuz then
								ParticleEffect(self.MuzzleEffect, pos + self.Owner:GetVelocity() * 0.03, EA, vm)
							else
								ParticleEffectAttach(self.MuzzleEffect, PATTACH_POINT_FOLLOW, vm, muz)
							end
						end
					end
					
					dlight = DynamicLight(self:EntIndex())
					
					dlight.r = 255 
					dlight.g = 218
					dlight.b = 74
					dlight.Brightness = 4
					dlight.Pos = pos + self.Owner:GetAimVector() * 3
					dlight.Size = 96
					dlight.Decay = 128
					dlight.DieTime = CurTime() + FrameTime()
				end
			end
		end
	end
	*/
end

SWBShells = {}
SWBShells["mainshell"] = {m = "models/weapons/rifleshell.mdl", s = {"player/pl_shell1.wav", "player/pl_shell2.wav", "player/pl_shell3.wav"}}
SWBShells["shotshell"] = {m = "models/weapons/Shotgun_shell.mdl", s = {"weapons/fx/tink/shotgun_shell1.wav", "weapons/fx/tink/shotgun_shell2.wav", "weapons/fx/tink/shotgun_shell3.wav"}}
SWBShells["smallshell"] = {m = "models/weapons/shell.mdl", s = {"player/pl_shell1.wav", "player/pl_shell2.wav", "player/pl_shell3.wav"}}

function SWB_MakeFakeShell(shell, pos, ang, vel, time, removetime, shellscale)
	//if not shell or not pos or not ang then
	//	return
	//end
//
	//local t = SWBShells[shell]
	//
	//if not t then
	//	return
	//end
	//
	//vel = vel or Vector(0, 0, -100)
	//vel = vel + VectorRand() * 5
	//time = time or 0.5
	//removetime = removetime or 5
	//shellscale = shellscale or 1
	//
	//local ent = ClientsideModel(t.m, RENDERGROUP_BOTH) 
	//ent:SetPos(pos)
	//ent:PhysicsInitBox(Vector(-0.5, -0.15, -0.5), Vector(0.5, 0.15, 0.5))
	//ent:SetAngles(ang)
	//ent:SetModelScale(shellscale, 0)
	//ent:SetMoveType(MOVETYPE_VPHYSICS) 
	//ent:SetSolid(SOLID_VPHYSICS) 
	//ent:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
	//
	//local phys = ent:GetPhysicsObject()
	//phys:SetMaterial("gmod_silent")
	//phys:SetMass(10)
	//phys:SetVelocity(vel)
//
	//timer.Simple(time, function()
	//	if t.s then
	//		ent:EmitSound(table.Random(t.s), 35, 100)
	//	end
	//end)
	//
	//SafeRemoveEntityDelayed(ent, removetime)
end

function SWEP:FireAnimationEvent(pos, ang, ev, name)
	if ev == 5001 then
		if self.MuzzleEffect then
			self:CreateMuzzle(pos, ang)
		end
		
		if self.NoStockMuzzle then
			return true
		end
		
		return self.dt.Suppressed
	end
	
	if ev == 20 then
		if self.Shell then
			self:CreateShell()
		end
		
		return self.NoStockShells
	end
end

SWEP.ApproachSpeed = 10
local SP = game.SinglePlayer() 
local PosMod, AngMod = Vector(0, 0, 0), Vector(0, 0, 0)
local CurPosMod, CurAngMod = Vector(0, 0, 0), Vector(0, 0, 0)
local veldepend = {pitch = 0, yaw = 0, roll = 0}
local mod2 = 0
local EA2

function SWEP:PreDrawViewModel()
	CT = UnPredictedCurTime()
	vm = self.Owner:GetViewModel()
	
	self.Sequence = vm:GetSequenceName(vm:GetSequence())
	self.IsReloading = self.Sequence:find("reload")
	
	if not self.IsReloading then
		self.IsReloading = self.Sequence:find("insert")
	end
	
	if not self.IsReloading then
		self.IsFiddlingWithSuppressor = self.Sequence:find("silencer")
	end
	
	self.Cycle = vm:GetCycle()
	
	EA = EyeAngles()
	FT = FrameTime()
	
	delta = Angle(EA.p, EA.y, 0) - self.OldDelta
	delta.p = math.Clamp(delta.p, -10, 10)
		
	self.OldDelta = Angle(EA.p, EA.y, 0)
	self.AngleDelta = LerpAngle(math.Clamp(FT * 10, 0, 1), self.AngleDelta, delta)
	self.AngleDelta.y = math.Clamp(self.AngleDelta.y, -10, 10)

	vel = GetVelocity(self.Owner)
	len = Length(vel)
	ws = self.Owner:GetWalkSpeed()
	
	PosMod, AngMod = Vec0 * 1, Vec0 * 1
	mod2 = 1
	
	veldepend.roll = math.Clamp((vel:DotProduct(EA:Right()) * 0.04) * len / ws, -5, 5)
	
	if self.dt.State == SWB_AIMING then
		mod2 = 0.2
		TargetPos, TargetAng = self.AimPos * 1, self.AimAng * 1
		self.ApproachSpeed = math.Approach(self.ApproachSpeed, 8, FT * 100)
	elseif self.dt.State == SWB_ACTION then
		TargetPos, TargetAng = self.SwimPos * 1, self.SwimAng * 1
		self.ApproachSpeed = math.Approach(self.ApproachSpeed, 5, FT * 100)
	elseif self.dt.State == SWB_RUNNING or (((len > ws * 1.2 and self.Owner:KeyDown(IN_SPEED)) or len > ws * 3 or (self.ForceRunStateVelocity and len > self.ForceRunStateVelocity)) and self.Owner:OnGround()) then
		if self.IsReloading and self.Cycle < 0.9 then
			TargetPos, TargetAng = Vec0 * 1, Vec0 * 1
		else
			if self.SprintingEnabled then
				TargetPos, TargetAng = self.SprintPos * 1, self.SprintAng * 1
			else
				TargetPos, TargetAng = Vec0 * 1, Vec0 * 1
			end
		end
		
		rs = self.Owner:GetRunSpeed()
		mod = 7 + math.Clamp(rs / 100, 0, 6)
		mul = math.Clamp(len / rs, 0, 1)
		sin1 = math.sin(CT * mod) * mul
		cos1 = math.cos(CT * mod) * mul
		tan1 = math.tan(sin1 * cos1) * mul
		
		if (self.IsReloading or self.IsFiddlingWithSuppressor) and self.Cycle <= 0.9 then
			AngMod.x = AngMod.x + tan1 * 0.2 * self.ViewModelMovementScale * mul
			AngMod.y = AngMod.y - cos1 * 1.5 * self.ViewModelMovementScale * mul
			AngMod.z = AngMod.z + cos1 * 3 * self.ViewModelMovementScale * mul
			PosMod.x = PosMod.x - sin1 * 1.2 * self.ViewModelMovementScale * mul
			PosMod.y = PosMod.y + tan1 * 3 * self.ViewModelMovementScale * mul
			PosMod.z = PosMod.z + tan1 * 1.5 * self.ViewModelMovementScale * mul
			
			self.ApproachSpeed = math.Approach(self.ApproachSpeed, 4, FT * 100)
		else
			AngMod.x = AngMod.x + tan1 * 0.2 * self.ViewModelMovementScale * mul
			AngMod.y = AngMod.y - cos1 * 1.5 * self.ViewModelMovementScale * mul
			AngMod.z = AngMod.z + cos1 * 3 * self.ViewModelMovementScale * mul
			PosMod.x = PosMod.x - sin1 * 1.2 * self.ViewModelMovementScale * mul
			PosMod.y = PosMod.y + tan1 * 3 * self.ViewModelMovementScale * mul
			PosMod.z = PosMod.z + tan1 * 1.5 * self.ViewModelMovementScale * mul
			
			self.ApproachSpeed = math.Approach(self.ApproachSpeed, 6, FT * 100)
		end
	else
		if self.dt.Safe then
			TargetPos, TargetAng = self.SprintPos * 1, self.SprintAng * 1
		else
			TargetPos, TargetAng = Vec0 * 1, Vec0 * 1
		end

		self.ApproachSpeed = math.Approach(self.ApproachSpeed, 10, FT * 100)
		
		td.start = self.Owner:GetShootPos()
		td.endpos = td.start + self.Owner:EyeAngles():Forward() * 30
		td.filter = self.Owner
		
		tr = util.TraceLine(td)
		
		if tr.Hit then
			self.NearWall = true
			TargetPos.y = TargetPos.y - math.Clamp(30 * (1 - tr.Fraction), 0, 15)
		end
	end
	
	if len < 10 or not self.Owner:OnGround() then
		if self.dt.State != SWB_AIMING then
			cos1, sin1 = math.cos(CT), math.sin(CT)
			tan = math.atan(cos1 * sin1, cos1 * sin1)
			
			AngMod.x = AngMod.x + tan * 1.15
			AngMod.y = AngMod.y + cos1 * 0.4
			AngMod.z = AngMod.z + tan
			
			PosMod.y = PosMod.y + tan * 0.2 * mod2
		end
	elseif len > 10 and len < ws * 1.2 then
		mod = 6 + ws / 130
		mul = math.Clamp(len / ws, 0, 1)
		sin1 = math.sin(CT * mod) * mul
		cos1 = math.cos(CT * mod) * mul
		tan1 = math.tan(sin1 * cos1) * mul
		
		AngMod.x = AngMod.x + tan1 * self.ViewModelMovementScale * mod2
		AngMod.y = AngMod.y - cos1 * self.ViewModelMovementScale * mod2
		AngMod.z = AngMod.z + cos1 * self.ViewModelMovementScale * mod2
		PosMod.x = PosMod.x - sin1 * 0.4 * self.ViewModelMovementScale * mod2
		PosMod.y = PosMod.y + tan1 * 1 * self.ViewModelMovementScale * mod2
		PosMod.z = PosMod.z + tan1 * 0.5 * self.ViewModelMovementScale * mod2
	end
	
	FT = FrameTime()
	
	TargetAng.z = TargetAng.z + veldepend.roll
	self.BlendPos = LerpVector(FT * self.ApproachSpeed, self.BlendPos, TargetPos)
	self.BlendAng = LerpVector(FT * self.ApproachSpeed, self.BlendAng, TargetAng)
	
	CurPosMod = LerpVector(FT * 10, CurPosMod, PosMod)
	CurAngMod = LerpVector(FT * 10, CurAngMod, AngMod)
	
	self.FireMove = Lerp(FT * 15, self.FireMove, 0)
end

function SWEP:GetViewModelPosition(pos, ang)
	CT = UnPredictedCurTime()
	
	if self.InstantDissapearOnAim and self.dt.State == SWB_AIMING then
		self.ViewModelFOV = 90
		pos = pos - ang:Forward() * 100
		return pos, ang
	end
	
	if self.MoveWepAwayWhenAiming and CT > self.AimTime and self.dt.State == SWB_AIMING then
		self.ViewModelFOV = 90
		pos = pos - ang:Forward() * 100
		return pos, ang
	end
	
	self.ViewModelFOV = self.ViewModelFOV_Orig
	
	RotateAroundAxis(ang, Right(ang), CurAngMod.x + self.BlendAng.x + self.AngleDelta.p * mod2)
	
	if not self.ViewModelFlip then
		RotateAroundAxis(ang, Up(ang), CurAngMod.y + self.BlendAng.y + self.AngleDelta.y * 0.3 * mod2)
		RotateAroundAxis(ang, Forward(ang), CurAngMod.z + self.BlendAng.z + self.AngleDelta.y * 0.3 * mod2)
	else
		RotateAroundAxis(ang, Up(ang), CurAngMod.y + self.BlendAng.y - self.AngleDelta.y * 0.3 * mod2)
		RotateAroundAxis(ang, Forward(ang), CurAngMod.z - self.BlendAng.z - self.AngleDelta.y * 0.3 * mod2)
	end

	if not self.ViewModelFlip then
		pos = pos + (CurPosMod.x + self.BlendPos.x + self.AngleDelta.y * 0.1 * mod2) * Right(ang)
	else
		pos = pos + (CurPosMod.x + self.BlendPos.x - self.AngleDelta.y * 0.1 * mod2) * Right(ang)
	end
	
	pos = pos + (CurPosMod.y + self.BlendPos.y - self.FireMove) * Forward(ang)
	pos = pos + (CurPosMod.z + self.BlendPos.z - self.AngleDelta.p * 0.1) * Up(ang)
	
	return pos, ang
end

local wm, pos, ang

function SWEP:DrawWorldModel()
	if self.dt.Safe then
		if self.CHoldType != self.RunHoldType then
			self:SetHoldType(self.RunHoldType)
			self.CHoldType = self.RunHoldType
		end
	else
		if self.dt.State == SWB_RUNNING or self.dt.State == SWB_ACTION then
			if self.CHoldType != self.RunHoldType then
				self:SetHoldType(self.RunHoldType)
				self.CHoldType = self.RunHoldType
			end
		else
			if self.CHoldType != self.NormalHoldType then
				self:SetHoldType(self.NormalHoldType)
				self.CHoldType = self.NormalHoldType
			end
		end
	end
				
	if self.DrawTraditionalWorldModel then
		self:DrawModel()
	else
		wm = self.WMEnt
		
		if IsValid(wm) then
			if IsValid(self.Owner) then
				pos, ang = GetBonePosition(self.Owner, self.Owner:LookupBone("ValveBiped.Bip01_R_Hand"))
				
				if pos and ang then
					RotateAroundAxis(ang, Right(ang), self.WMAng[1])
					RotateAroundAxis(ang, Up(ang), self.WMAng[2])
					RotateAroundAxis(ang, Forward(ang), self.WMAng[3])

					pos = pos + self.WMPos[1] * Right(ang) 
					pos = pos + self.WMPos[2] * Forward(ang)
					pos = pos + self.WMPos[3] * Up(ang)
					
					wm:SetRenderOrigin(pos)
					wm:SetRenderAngles(ang)
					wm:DrawModel()
				end
			else
				wm:SetRenderOrigin(self:GetPos())
				wm:SetRenderAngles(self:GetAngles())
				wm:DrawModel()
				wm:DrawShadow()
			end
		else
			self:DrawModel()
		end
	end
end
--PATH addons/swb_css/lua/weapons/swb_p228/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "P228"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-5.949, -2.096, 2.88)
	SWEP.AimAng = Vector(-0.401, 0, 0)
		
	SWEP.SprintPos = Vector(0, -17.514, -12.271)
	SWEP.SprintAng = Vector(63.637, 0, 0)
	
	SWEP.ZoomAmount = 5
	SWEP.ViewModelMovementScale = 0.85
	SWEP.Shell = "smallshell"
	
	SWEP.IconLetter = "y"
	
	SWEP.MuzzleEffect = "swb_pistol_small"
end

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 10
SWEP.BulletDiameter = 9
SWEP.CaseLength = 19

SWEP.Kind = WEAPON_PISTOL
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_pistol_ttt"

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "Pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"semi"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_pist_p228.mdl"
SWEP.WorldModel		= "models/weapons/w_pist_p228.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 15
SWEP.Primary.DefaultClip	= 15
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "pistol"

SWEP.FireDelay = 0.13
SWEP.FireSound = Sound("Weapon_P228.Single")
SWEP.Recoil = 0.7

SWEP.HipSpread = 0.036
SWEP.AimSpread = 0.0115
SWEP.VelocitySensitivity = 1.2
SWEP.MaxSpreadInc = 0.06
SWEP.SpreadPerShot = 0.01
SWEP.SpreadCooldown = 0.15
SWEP.Shots = 1
SWEP.Damage = 17
SWEP.DeployTime = 1
--PATH addons/__main/lua/weapons/tmp_dragon/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("tmp_dragon") -- must be the name of your swep but NO CAPITALS!
SWEP.Category				= "CSO/CF Weapons" --Category where you will find your weapons
SWEP.Author				= "Zekeou"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.PrintName				= "TMP Dragon"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 3			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false		-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight					= 30		-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg makes for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_smg_tmd.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_smg_tmp.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= false
SWEP.Base				= "zekeou_gun_base" --the Base this weapon will work on. PLEASE RENAME THE BASE! 
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("weapons/TMP_Dragon/Dragon TMP Fire.wav")		-- Script that calls the primary fire sound
SWEP.Primary.SilencedSound 	= Sound("")		-- Sound if the weapon is silenced
SWEP.Primary.RPM			= 875			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.3		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "pistol"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. 
--Use AirboatGun for a light metal peircing shotgun pellets
SWEP.SelectiveFire		= true
SWEP.CanBeSilenced		= false

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 20	-- Base damage per bullet
SWEP.Primary.Spread		= .022	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .012 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(0,0,0)	--Iron Sight positions and angles. Use the Iron sights utility in 
SWEP.IronSightsAng = Vector(0,0,0)	--Clavus's Swep Construction Kit to get these vectors
SWEP.RunSightsPos = Vector(0,0,0)	--These are for the angles your viewmodel will be when running
SWEP.RunSightsAng = Vector(0,0,0)	--Again, use the Swep Construction Kit

SWEP.WElements = {
	["TMP_Dragon"] = { type = "Model", model = "models/weapons/w_smg_tmd.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(-3.691, 0.552, 5.005), angle = Angle(-8.561, 1.103, 180), size = Vector(1.25, 1.25, 1.25), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

--PATH gamemodes/darkrp/entities/weapons/unarrest_baton.lua:

-----------------------------------------------------
AddCSLuaFile()
local BaseClass = baseclass.Get('baton_base')

if CLIENT then
    SWEP.PrintName = 'Зняти арешт'
    SWEP.SlotPos = 5
    SWEP.Instructions = 'Left click to unarrest\nRight click to switch to arrest'
    SWEP.Spawnable = true
end

SWEP.Color = Color(0, 255, 0, 255)

function SWEP:Initialize()
    self:SetHoldType(self.HoldType)
    self._Reload.Sound = Sound('npc/combine_soldier/vo/coverme.wav')
end



function SWEP:PrimaryAttack()
    if not IsValid(self.Owner) then return end
    BaseClass.PrimaryAttack(self)
    if CLIENT then return end
    self.Owner:LagCompensation(true)
    local ent = self.Owner:GetEyeTrace().Entity
    self.Owner:LagCompensation(false)
    if (not IsValid(ent)) or (not ent:IsPlayer()) or (self.Owner:GetPos():Distance(ent:GetPos()) > self.HitDistance) or (not ent:onyx_GetNetVar('Arrest')) then return end
    ent:UnArrest(self.Owner)

end

function SWEP:SecondaryAttack()
    if not IsValid(self.Owner) then return end

    if SERVER and self.Owner:HasWeapon('arrest_baton') then
        self.Owner:SelectWeapon('arrest_baton')
    end

    self:SetNextSecondaryFire(CurTime() + self.Primary.Delay)
end
--PATH addons/__main/lua/weapons/weapon_armorkit/shared.lua:
if SERVER then
	AddCSLuaFile("shared.lua")
	AddCSLuaFile("cl_init.lua")
	AddCSLuaFile("animations.lua")

	include("animations.lua")
end

SWEP.PrintName = "Armorkit"
SWEP.Author = "MrGeRoI"
SWEP.Purpose = "Repair armor people with your primary attack, or yourself with the secondary."

SWEP.Spawnable = true

SWEP.ViewModel = "models/weapons/c_medkit.mdl"--"models/weapons/c_grenade.mdl"
SWEP.WorldModel = "models/items/battery.mdl" --"models/weapons/w_medkit.mdl"

SWEP.Primary.ClipSize = 100
SWEP.Primary.DefaultClip = 100
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.MaxAmmo = 100
SWEP.ArmorAmount = 15

function SWEP:Initialize()
	self:SetHoldType("slam")

	if CLIENT then
		self:Anim_Initialize()
	end

	if not SERVER then return end

	self.TimerName = "armorkit_ammo" .. self:EntIndex()
	local wep = self
	timer.Create(self.TimerName,1,0,function()
		if IsValid(wep) then
			if wep:Clip1() < wep.MaxAmmo then
				wep:SetClip1(math.min(wep:Clip1() + 2,wep.MaxAmmo))
			end
		else
			timer.Remove(wep.TimerName)
		end
	end)
end

function SWEP:Deploy()
	--self:SendWeaponAnim(ACT_VM_DRAW)
	self.IdleAnimation = CurTime() + self:SequenceDuration()
	self:SetHoldType("slam")

	return true
end

function SWEP:Think()
	if self.IdleAnimation and self.IdleAnimation <= CurTime() then
		self.IdleAnimation = nil
		self:SendWeaponAnim(ACT_VM_IDLE)
	end
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
	return false
end

function SWEP:CanAttack()
	if self:Clip1() <= 0 then
		self.Owner:EmitSound("items/suitchargeno1.wav")
		self:SetNextFire(CurTime() + 2)
		return false
	end

	return self:GetNextPrimaryFire() <= CurTime()
end

function SWEP:GetHitTrace()
	local shoot = self.Owner:GetShootPos()
	return util.TraceLine({
		start = shoot,
		endpos = shoot + self.Owner:GetAimVector() * 64,
		filter = self.Owner,
	})
end

function SWEP:SetNextFire(time)
	self:SetNextPrimaryFire(time)
	self:SetNextSecondaryFire(time)
end

function SWEP:PrimaryAttack()
	if not self:CanAttack() then return end

	self:SetNextFire(CurTime() + 2)

	local tr = self:GetHitTrace()
	local need = (IsValid(tr.Entity) and tr.Entity:IsPlayer()) and math.min(100-tr.Entity:Armor(),self.ArmorAmount) or self.ArmorAmount
	if self:Clip1() >= need and tr.Hit and IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity:Armor() < 100 then
		self.Owner:SetAnimation(PLAYER_ATTACK1) --DoAttackEvent()
		self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
		self.IdleAnimation = CurTime() + self:SequenceDuration()

		if SERVER then
			self:TakePrimaryAmmo(need)
			self.Owner:SetAnimation(PLAYER_ATTACK1)
			tr.Entity:SetArmor(math.min(100,tr.Entity:Armor()+need))
			tr.Entity:EmitSound("items/battery_pickup.wav")
		end
	elseif SERVER then
		self.Owner:EmitSound("items/suitchargeno1.wav")
	end
end

function SWEP:SecondaryAttack()
	if not self:CanAttack() then return end
	self:SetNextFire(CurTime() + 2)

	local need = math.min(100-self.Owner:Armor(),self.ArmorAmount)
	if self.Owner:Armor() < 100 and self:Clip1() >= need then
		self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)
		self.Owner:SetAnimation(PLAYER_ATTACK1) --DoAttackEvent()
		self.IdleAnimation = CurTime() + self:SequenceDuration()

		if SERVER then
			local need = math.min(100-self.Owner:Armor(),self.ArmorAmount)
			self:TakePrimaryAmmo(need)
			self.Owner:SetAnimation(PLAYER_ATTACK1)
			self.Owner:SetArmor(math.min(100,self.Owner:Armor()+need))
			self.Owner:EmitSound("items/battery_pickup.wav")
		end
	elseif SERVER then
		self.Owner:EmitSound("items/suitchargeno1.wav")
	end
end

function SWEP:Holster()
	if CLIENT then
		self:Anim_Holster()
	end
	return true
end

function SWEP:OnRemove()
	if not SERVER then return end
	timer.Remove(self.TimerName)
end

function SWEP:CustomAmmoDisplay()
	self.AmmoDisplay = self.AmmoDisplay or {}
	self.AmmoDisplay.Draw = true
	self.AmmoDisplay.PrimaryClip = self:Clip1()

	return self.AmmoDisplay
end

--PATH addons/_avatar/lua/weapons/weapon_blood_bending.lua:
SWEP.Category = "Avatar"
SWEP.PrintName = "Blood Bending"
SWEP.Author = "Kilburn, robotboy655, MaxOfS2D, Tenrys & Kurome76" -- changing this will void your support
SWEP.Purpose = "Bend Bodies (the water in thier blood)."
SWEP.Slot = 1
SWEP.SlotPos = 10
SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.AdminOnly = true
SWEP.ViewModel = Model( "models/weapons/c_vortbeamvm.mdl" )
SWEP.WorldModel = ""
SWEP.ViewModelFOV = 54
SWEP.UseHands = true
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.DrawAmmo = false
local SwingSound = Sound( "WeaponFrag.Throw" )
function SWEP:Initialize()
	self:SetHoldType( "magic" )
	self.BloodBending = NULL
end

function SWEP:SetupDataTables()
	self:NetworkVar( "Float", 0, "NextMeleeAttack" )
	self:NetworkVar( "Float", 1, "NextIdle" )
end

function SWEP:GetViewModelPosition( pos, ang )
	--this is always applied
	local DefPos = Vector( 0, 0, -1 )
	local DefAng = Vector( 0, 0, 0 )
	if DefAng then
		ang = ang * 1
		ang:RotateAroundAxis( ang:Right(), DefAng.x )
		ang:RotateAroundAxis( ang:Up(), DefAng.y )
		ang:RotateAroundAxis( ang:Forward(), DefAng.z )
	end

	if DefPos then
		local Right = ang:Right()
		local Up = ang:Up()
		local Forward = ang:Forward()
		pos = pos + DefPos.x * Right
		pos = pos + DefPos.y * Forward
		pos = pos + DefPos.z * Up
	end
	return pos, ang
end

function SWEP:UpdateNextIdle()
	local vm = self:GetOwner():GetViewModel()
	self:SetNextIdle( CurTime() + vm:SequenceDuration() / vm:GetPlaybackRate() )
end

function SWEP:PrimaryAttack()
	if IsValid( self.BloodBending ) and self.BloodBending:IsPlayer() then
		local wep = self.BloodBending:GetActiveWeapon()
		if IsValid( wep ) and wep.PrimaryAttack then
			wep:PrimaryAttack()
			return
		end
	end

	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )
	self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
	self:EmitSound( SwingSound )
	self:UpdateNextIdle()
	self:SetNextMeleeAttack( CurTime() + 0.2 )
	self:SetNextPrimaryFire( CurTime() + 0.9 )
	self:SetNextSecondaryFire( CurTime() + 0.9 )
end

function SWEP:SecondaryAttack()
	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )
	self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
	self:EmitSound( SwingSound )
	if IsValid( self.BloodBending ) then
		if self.BloodBending:IsNPC() then
			self.BloodBending:SetCondition( 68 )
		else
			if not self.BloodBending:IsPlayer() then self.BloodBending:SetMoveType( MOVETYPE_STEP ) end
		end

		self.BloodBending.Controlled = false
		self.BloodBending = NULL
	end

	self:SetNextPrimaryFire( CurTime() + 0.9 )
	self:SetNextSecondaryFire( CurTime() + 0.9 )
end

function SWEP:Think()
	if IsValid( self.BloodBending ) then
		if self.BloodBending:IsNPC() then
			if self.BloodBending:Health() < 1 then
				self.BloodBending.Controlled = false
				self.BloodBending = NULL
			else
				local dmg = DamageInfo()
				dmg:SetAttacker( self:GetOwner() )
				dmg:SetInflictor( self )
				dmg:SetDamage( 5 )
				dmg:SetDamageType( DMG_GENERIC )
				dmg:SetDamageForce( self:GetOwner():GetAimVector() * 5000 )
				SuppressHostEvents( NULL )
				self.BloodBending:TakeDamageInfo( dmg )
				local pos = self.BloodBending:WorldSpaceCenter()
				local BLOOOD = EffectData()
				BLOOOD:SetOrigin( pos )
				BLOOOD:SetMagnitude( math.random( 1, 3 ) )
				BLOOOD:SetEntity( self.BloodBending )
				util.Effect( "bloodstream", BLOOOD )
				local edata = EffectData()
				edata:SetStart( pos )
				edata:SetOrigin( pos )
				edata:SetNormal( vector_up )
				edata:SetEntity( self.BloodBending )
				util.Effect( "BloodImpact", edata )
				SuppressHostEvents( self:GetOwner() )
			end
		else
			if not self.BloodBending:Alive() then
				self.BloodBending.Controlled = false
				self.BloodBending = NULL
			end
		end
	end

	local idletime = self:GetNextIdle()
	if idletime > 0 and CurTime() > idletime then
		self:SendWeaponAnim( ACT_VM_IDLE )
		self:UpdateNextIdle()
	end

	local meleetime = self:GetNextMeleeAttack()
	if meleetime > 0 and CurTime() > meleetime then
		if SERVER then
			local srcpos = self:GetOwner():GetShootPos()
			local tr = util.TraceLine( {
				start = srcpos,
				endpos = srcpos + self:GetOwner():GetAimVector() * 6000,
				filter = self:GetOwner()
			} )

			if IsValid( tr.Entity ) then
				if IsValid( self.BloodBending ) then self.BloodBending.Controlled = false end
				local targ = tr.Entity
				if targ:IsPlayer() then
					self:GetOwner():EmitSound( "ambient/water/water_splash" .. math.random( 1, 3 ) .. ".wav" )
					targ.Controlled = true
					targ.ControlledEyes = targ:EyeAngles()
					self.BloodBending = targ
				elseif targ:IsNPC() or targ.Type == "nextbot" then
					self:GetOwner():EmitSound( "ambient/water/water_splash" .. math.random( 1, 3 ) .. ".wav" )
					targ.Controlled = true
					self.BloodBending = targ
					if targ:IsNPC() then
						targ:SetSchedule( SCHED_NPC_FREEZE )
					else
						if not targ:IsPlayer() then targ:SetMoveType( MOVETYPE_WALK ) end
					end
				end
			end
			--self.part:SetParent(self:GetOwner())
		end

		self:SetNextMeleeAttack( 0 )
	end
end

function SWEP:Deploy()
	local speed = GetConVar( "sv_defaultdeployspeed" ):GetInt()
	local vm = self:GetOwner():GetViewModel()
	self:SendWeaponAnim( ACT_VM_DRAW )
	vm:SetPlaybackRate( speed )
	self:SetNextPrimaryFire( CurTime() + vm:SequenceDuration() / speed )
	self:SetNextSecondaryFire( CurTime() + vm:SequenceDuration() / speed )
	self:UpdateNextIdle()
	return true
end

function SWEP:Holster()
	if IsValid( self.BloodBending ) then
		if self.BloodBending:IsNPC() then
			self.BloodBending:SetCondition( 68 )
		else
			if not self.BloodBending:IsPlayer() then self.BloodBending:SetMoveType( MOVETYPE_STEP ) end
		end

		self.BloodBending.Controlled = false
		self.BloodBending = NULL
	end

	self:SetNextMeleeAttack( 0 )
	return true
end

function SWEP:OnRemove()
	self:Holster()
	return true
end

function SWEP:OnDrop()
	self:Holster()
	self:Remove() -- You can't drop fists
end

local color1 = Color( 255, 60, 60 )
function SWEP:DrawHUD()
	local x, y = ScrW(), ScrH()
	local w, h = x * 0.5, y * 0.5
	draw.SimpleTextOutlined( "Стихія: Вода (Кров)", onyx.Font( "Comfortaa@24" ), w, y - h / 8, color1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 2, color_black )
end

hook.Add( "Move", "BloodBending", function( ply )
	local wep = ply:GetActiveWeapon()
	if IsValid( wep ) and IsValid( ply ) and wep:GetClass() == "weapon_blood_bending" and IsValid( wep.BloodBending ) then
		local targ = wep.BloodBending
		if IsValid( targ ) and not targ:IsNPC() then
			if ply:KeyDown( IN_FORWARD ) then targ:SetVelocity( targ:GetForward() * -1000 ) end
			if ply:KeyDown( IN_MOVERIGHT ) then
				targ:SetVelocity( targ:GetRight() * -1000 )
			elseif ply:KeyDown( IN_MOVELEFT ) then
				targ:SetVelocity( targ:GetRight() * 1000 )
			end

			if ply:KeyDown( IN_BACK ) then targ:SetVelocity( targ:GetForward() * 1000 ) end
			if targ.ControlledEyes == nil then targ.ControlledEyes = Angle( 0, 0, 0 ) end
			targ:SetEyeAngles( ply:EyeAngles() * 4 + targ.ControlledEyes )
		else
			targ:SetAngles( Angle( 0, ply:EyeAngles().y * 4, 0 ) )
		end

		local vel = Vector( -ply:GetVelocity().x, -ply:GetVelocity().y, ply:GetVelocity().z )
		ply:SetVelocity( vel )
	end

	if ply.Controlled == true then
		local vel = Vector( -ply:GetVelocity().x, -ply:GetVelocity().y, ply:GetVelocity().z )
		ply:SetVelocity( vel )
		--return true
	end
end )
--PATH addons/__main/lua/weapons/weapon_hl2pan/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Pan"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing"
SWEP.Category				= "HL2 Melee Pack"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_pan.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_pan.mdl" )
SWEP.ViewModelFOV			= 62
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 40
SWEP.HitInclination		= 0.2
SWEP.HitPushback		= 300
SWEP.HitRate			= 1.00
SWEP.MinDamage			= 12
SWEP.MaxDamage			= 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Metal_Box.ImpactHard" )
local HitSoundBody = Sound( "Flesh.ImpactHard" )

function SWEP:Initialize()

	self:SetHoldType( "melee" )
end

function SWEP:PrimaryAttack()

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	local vm = self.Owner:GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay", 0.2, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay" )

end

function SWEP:SecondaryAttack()
	
	return true
end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()

//This function calculate the trajectory

	for i=0, 170 do

	local tr = util.TraceLine( {
		start = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)),
		endpos = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)) + ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.7 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) ),
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

//This if shot the bullets

	if ( tr.Hit ) then
		
		local strikevector = ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.5 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) )

		bullet = {}
		bullet.Num    = 1
		bullet.Src    = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 15))
		bullet.Dir    = strikevector:GetNormalized()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 10
		bullet.Hullsize = 0
		bullet.Distance = self.HitDistance * 1.5
		bullet.Damage = math.random( 12, 18 )
		self.Owner:FireBullets(bullet)

		//local vPoint = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10))
		//local effectdata = EffectData()
		//effectdata:SetOrigin( vPoint )
		//util.Effect( "BloodImpact", effectdata )

		self:EmitSound( SwingSound )

		//vm:SendViewModelMatchingSequence( vm:LookupSequence( "hitcenter1" ) )

		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") then
			self:EmitSound( HitSoundBody )
			tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * self.HitPushback )
		else
			self:EmitSound( HitSoundWorld )
		end
//if break
		break
//if end
		//else vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )
		end
end

end

function SWEP:Deploy()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()

	timer.Remove("hitdelay")
	return true
end
--PATH gamemodes/darkrp/entities/weapons/weapon_radio/shared.lua:

SWEP.PrintName = "Рація"

SWEP.Purpose = "При використанні на людині, оголошує її в розшук. При використанні на пропі дає ордер на обшук його власника."

SWEP.Category = "RP" 

SWEP.Spawnable		= true
SWEP.AdminSpawnable	= true
SWEP.AdminOnly		= true

SWEP.ViewModelFOV	= 54
SWEP.ViewModel		= "models/weapons/Custom/rad15.mdl" 
SWEP.WorldModel		= "models/weapons/Custom/w_rad15.mdl"	

SWEP.ShowViewModel 	= true
SWEP.ShowWorldModel = true

SWEP.ViewModelFlip 	= false
SWEP.AutoSwitchTo 	= true
SWEP.AutoSwitchFrom = true
SWEP.Slot = 3
SWEP.SlotPos = 1

SWEP.Primary.ClipSize 			= -1
SWEP.Primary.DefaultClip 		= 0
SWEP.Primary.Automatic 			= false
SWEP.Primary.Ammo 				= ''

SWEP.Secondary.ClipSize 		= -1
SWEP.Secondary.DefaultClip 		= 0
SWEP.Secondary.Automatic 		= false
SWEP.Secondary.Ammo 			= ''
 
SWEP.UseHands = true
SWEP.HoldType = "Pistol" 
SWEP.Base = "weapon_base"

function SWEP:Initialize()
	self:SetWeaponHoldType( self.HoldType )
end 

local sounds = {
	Sound("npc/combine_soldier/vo/callcontacttarget1.wav"),
	Sound("npc/combine_soldier/vo/contactconfim.wav"),
	Sound("npc/combine_soldier/vo/contained.wav"),
	Sound("npc/combine_soldier/vo/bodypackholding.wav")
}

function SWEP:PrimaryAttack()
	if SERVER then return end

	if CurTime() < (self.NextPrimaryFire or 0) then return end

	local ent = self.Owner:GetEyeTrace().Entity

	if ent:IsPlayer() or ent:GetClass() == "prop_physics" or (ent:IsDoor() and ent:DoorGetOwner()) then	
		onyx.SimpleQuery('Подати в розшук', 'Причина розшуку?', true, function(text)
			net.Start('wanted_radio')
				net.WriteEntity(ent)
				net.WriteString(text)
			net.SendToServer()
		end, 'Так', nil, 'Ні')
	end

	self.NextPrimaryFire = CurTime() + 1
end 

function SWEP:SecondaryAttack()
	if SERVER then return end

	if CurTime() < (self.NextSecondaryFire or 0) then return end

	local ent = self.Owner:GetEyeTrace().Entity

	if not IsValid(ent) then return end

	if ent:IsPlayer() then
		self.Owner:ConCommand('unwanted "' .. ent:SteamID())
	elseif IsValid(ent:CPPIGetOwner()) then
		self.Owner:ConCommand('unwarrant "' .. ent:CPPIGetOwner():SteamID())
	elseif ent:IsDoor() && ent:DoorGetOwner() then
		self.Owner:ConCommand('unwarrant "' .. ent:DoorGetOwner():SteamID())
	end

	self.NextSecondaryFire = CurTime() + 1
end

if SERVER then
	--resource.AddWorkshop("356099105")

	util.AddNetworkString("wanted_radio")

	net.Receive('wanted_radio', function(len, ply)
		local wep = ply:GetActiveWeapon()
		if IsValid(wep) and wep:GetClass() ~= "weapon_radio" then return false end
		
		local ent = net.ReadEntity()

		if not IsValid(ent) then return end
		
		if ent:GetPos():Distance(ply:GetPos()) < 500 then
			local reason = net.ReadString()

			if utf8.len(reason) < 1 then return end
			if utf8.len(reason) > 24 then return end

			if ent:IsPlayer() then
				ply:ConCommand('wanted "' .. ent:SteamID() .. '" "' ..reason..'"')
				ply:EmitSound(table.Random(sounds), 100, 100, 1)
			elseif IsValid(ent:CPPIGetOwner()) then
				ply:ConCommand('warrant "' .. ent:CPPIGetOwner():SteamID() .. '" "' ..reason..'"')
				ply:EmitSound(table.Random(sounds), 100, 100, 1)	
			elseif ent:IsDoor() && ent:DoorGetOwner() then
				ply:ConCommand('warrant "' .. ent:DoorGetOwner():SteamID() .. '" "' ..reason..'"')
				ply:EmitSound(table.Random(sounds), 100, 100, 1)	
			end
		end
	end)
else
	function SWEP:ViewModelDrawn()
		local vm = self.Owner:GetViewModel()
		if not IsValid(vm) then return end

		local bone = vm:LookupBone("radio")

		if (!bone) then return end
		
		pos, ang = Vector(0,0,0), Angle(0,0,0)
		local m = vm:GetBoneMatrix(bone)
		if (m) then
			pos, ang = m:GetTranslation(), m:GetAngles()
		else
			return 
		end

		ang:RotateAroundAxis(ang:Forward(),90)
		ang:RotateAroundAxis(ang:Right(), 180)
		ang:RotateAroundAxis(ang:Up(), -270)
		
		cam.Start3D2D(pos+ang:Right()*3.85+ang:Forward()*-7.90+ang:Up()*-0.28, ang, 0.03)
			self:DrawScreen(50,50,65,123)
		cam.End3D2D() 
	end

	local dots = 1

	function SWEP:DrawScreen(x, y, w, h)
		local text
		local tr = LocalPlayer():GetEyeTrace().Entity
		if self:GetNextPrimaryFire() > CurTime() then
			text = '....'
		elseif tr:IsPlayer() || tr:IsVehicle() then
			text = 'РОЗШУК'
		elseif tr:GetClass() == "prop_physics" || tr:IsDoor() then
			text = 'ОРДЕР'
		else
			local str = "..."
			if dots <=100 then
			str = "." 
			elseif dots <= 200 then
			str = ".."
			elseif dots >= 300 then
			dots = 1
			end
			dots = dots + 1
			text = 'Пошук'..str
		end

		draw.SimpleText(text,"default",240, -260, Color(5,5,5,200) )
	end
end

function SWEP:DrawHUD()
	draw.ShadowText('Використайте Рацію для запиту Ордера (Людина,Проп,Двері)','Roboto_40',5,20,Color(225,225,100),3,1)
end


--PATH addons/__main/lua/weapons/weapon_roguestealth.lua:
AddCSLuaFile()

SWEP.PrintName = "Rogue Stealth"
SWEP.Instructions = "Primary attack: toggle stealth"

SWEP.WorldModel = ""
SWEP.ViewModel = ""
SWEP.UseHands = true

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Ammo = "none"
SWEP.Primary.ClipSize = 240
SWEP.Primary.DefaultClip = 240
SWEP.Primary.Automatic = false

SWEP.Secondary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false

SWEP.RenderGroup = RENDERGROUP_BOTH

SWEP.Slot = 0
SWEP.SlotPos = 1

function SWEP:IsCloaked()
	return self.Owner:GetNWBool( "StealthCamo", false )
end

function SWEP:Cloak( pl )
	self:EmitSound( "roguestealth/shadowwalk_begin.wav" )
	self.Owner:SetNWBool( "StealthCamo", true )
	self.Owner:DrawShadow( false )
	

	
	timer.Simple( 0.7, function( ply, surface )
		
		self.Owner:ScreenFade( SCREENFADE.IN, Color( 0, 0, 0, 245 ), 0.25, 0.1 )
		if (SERVER) then
			net.Start("PlayCloakLoop")
			net.Send(self.Owner)	
			self.Owner:SetNoTarget(true)
		end
	end )
end

function SWEP:Uncloak( pl, surface )
	if (SERVER) then
		net.Start("StopCloakLoop")
		net.Send(self.Owner)
		self.Owner:SetNoTarget(false)
	end
	
	self:EmitSound( "roguestealth/shadowwalk_end.wav" )
	self.Owner:SetNWBool( "StealthCamo", false )
	self.Owner:DrawShadow( true )
end

function SWEP:Deploy()
	self:SendWeaponAnim( ACT_SLAM_DETONATOR_DRAW )
end

function SWEP:PrimaryAttack()
	self:SendWeaponAnim( ACT_SLAM_DETONATOR_DETONATE )

	if self:IsCloaked() and self:Clip1() > 0 then self:Uncloak() else self:Cloak() end
	self:SetNextPrimaryFire( CurTime() + 1 )
end

function SWEP:SecondaryAttack()
end



function SWEP:Think()

	if self.NextTick and self.NextTick > CurTime() then return end
	
	if (SERVER) then
		hook.Add("PlayerEnteredVehicle", "UncloakEnteringVehicle", function(ply, veh, seat)
			local equippedweapon = ply:GetActiveWeapon()
			if equippedweapon.IsCloaked and equippedweapon:IsCloaked() and equippedweapon:Clip1() > 0 then equippedweapon:Uncloak() end
		end)
	end
	
	if SERVER then
		if self:IsCloaked() then
			self:SetClip1( math.Clamp( self:Clip1() - 1, 0, self:GetMaxClip1() ) )
		else
			self:SetClip1( math.Clamp( self:Clip1() + 1, 0, self:GetMaxClip1() ) )
		end
	end
	
	if self:IsCloaked() and self:Clip1() <= 0 then
		self:Uncloak()
	end

	self.NextTick = CurTime() + 1
end

if SERVER then
	function SWEP:Initialize()
		self:SetWeaponHoldType( "normal" )
		self:SetClip1( 240 )
	end

	function SWEP:Holster()
		return not self:IsCloaked()
	end
else
	function SWEP:Initialize()
		self:SetWeaponHoldType( "normal" )

		hook.Add( "PrePlayerDraw", self, self.PrePlayerDraw )
		hook.Add( "PostPlayerDraw", self, self.PostPlayerDraw )
		hook.Add( "PreDrawPlayerHands", self, self.PreDrawPlayerHands )
		hook.Add( "PostDrawPlayerHands", self, self.PostDrawPlayerHands )
	end

	local Materials = {}

	function SWEP:PrepareMaterial( mat )
		--~local shader = Material( mat ):GetShader()
		local shader = "VertexLitGeneric"
		local params = util.KeyValuesToTable( file.Read( "materials/" .. mat .. ".vmt", "GAME" ) ) or {}
		params.Proxies = params.proxies or {}

		params[ "$cloakpassenabled" ] = 1
		params[ "$cloakfactor" ] = 0

		params.Proxies[ "PlayerCloak" ] = {}

		Materials[ mat ] = CreateMaterial( mat .. "_c", shader, params )
	end

	function SWEP:CloakThink()
		if not self.Owner.CloakFactor then self.Owner.CloakFactor = 0 end

		self.Owner.CloakFactor = math.Approach(
			self.Owner.CloakFactor, self:IsCloaked( self.Owner ) and 1 or 0, FrameTime() )
	end

	function SWEP:PrePlayerDraw( pl )
		if pl ~= self.Owner then return end

		self:CloakThink()

		if self.Owner.CloakFactor <= 0 then return end

		render.UpdateRefractTexture() 

		for k, v in ipairs( self.Owner:GetMaterials() ) do
			if not Materials[ v ] then self:PrepareMaterial( v ) end
			render.MaterialOverrideByIndex( k - 1, Materials[ v ] )
		end
	end

	function SWEP:PostPlayerDraw( pl )
		if pl ~= self.Owner or self.Owner.CloakFactor <= 0 then return end

		render.MaterialOverrideByIndex()
	end

	function SWEP:PreDrawPlayerHands( hands, vm, pl )
		if pl ~= self.Owner then return end

		self:CloakThink()

		if self.Owner.CloakFactor <= 0 then return end

		render.SetBlend( 1 - self.Owner.CloakFactor )
	end

	function SWEP:PostDrawPlayerHands( hands, vm, pl )
		if pl ~= self.Owner or self.Owner.CloakFactor <= 0 then return end

		render.SetBlend( 1 )
	end

	function SWEP:CustomAmmoDisplay()
		self.AmmoDisplay = self.AmmoDisplay or {} 
		self.AmmoDisplay.Draw = true
		self.AmmoDisplay.PrimaryClip = self:Clip1()

		return self.AmmoDisplay
	end

	matproxy.Add{
		name = "PlayerCloak",
		init = function() end,
		bind = function( self, mat, ent )
			if not IsValid( ent ) or not ent.CloakFactor then return end
			mat:SetFloat( "$cloakfactor", ent.CloakFactor )
		end
	}
end

--PATH addons/__main/lua/weapons/weapon_undertale_sans.lua:
AddCSLuaFile()

SWEP.Base 					= "weapon_base"
SWEP.PrintName				= "Undertale Sans Power"
SWEP.HoldType 				= "normal"
SWEP.Slot					= 5
SWEP.SlotPos				= 0
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.Primary.ClipSize 		= 0
SWEP.Primary.DefaultClip 	= 0
SWEP.DrawCrosshair			= true
SWEP.Category 				= "Undertale"
SWEP.DrawWeaponInfoBox		= true
SWEP.BounceWeaponIcon		= false
SWEP.ViewModel 				= "models/weapons/c_arms_refugee.mdl"
SWEP.WorldModel 			= ""
SWEP.Primary.Automatic 		= true
SWEP.Secondary.Automatic 	= true
//SWEP.ShowViewModel 			= true
//SWEP.ShowWorldModel 		= false
SWEP.Primary.Ammo 			= ""
SWEP.Secondary.Ammo 		= ""

function TraceHull( vecstart, vecend, vecmin, vecmax, tracefiler )
	local trace = util.TraceHull( {
		start = vecstart,
		endpos = vecend,
		filter = tracefiler,
		mins = vecmin,
		maxs = vecmax,
		mask = MASK_SHOT_HULL
	} )
	
	return trace
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
	
	if( SERVER ) then
		util.AddNetworkString( "miss" )
		util.AddNetworkString( "bad_time" )
		util.AddNetworkString( "bad_time_mode" )
		
		hook.Add( "EntityTakeDamage", "Damage", function( ent, dmginfo )
			local attacker = dmginfo:GetAttacker()
			if( attacker:Health() > 0 && attacker:IsPlayer() ) then
				if( attacker:GetActiveWeapon():IsValid() ) then
					if( attacker:GetActiveWeapon():GetClass() == "weapon_undertale_sans" ) then
						if( ent:IsNPC() || ent:IsPlayer() ) then
							attacker:SetVar( "bad_time", attacker:GetVar( "bad_time" ) + dmginfo:GetDamage() / 10 )
							
							if( attacker:GetVar( "bad_time" ) > 100 ) then
								attacker:SetVar( "bad_time", 100 )
							end
							
							net.Start( "bad_time" )
								net.WriteEntity( attacker )
								net.WriteFloat( attacker:GetVar( "bad_time" ) )
							net.Broadcast()
						end
					end
				end
			end
			
			if( ent:IsPlayer() && ent:Health() > 0 ) then
				if( ent:GetActiveWeapon():IsValid() && ent:GetVar( "miss", NULL ) != NULL ) then
					if( CurTime() >= ent:GetVar( "miss", NULL ) ) then
						if( ent:GetActiveWeapon():GetClass() == "weapon_undertale_sans" ) then
							net.Start( "miss" )
								net.WriteEntity( ent )
								local dmgpos = dmginfo:GetDamagePosition()
								if( dmgpos != Vector() ) then
									net.WriteVector( dmgpos )
								else
									net.WriteVector( ent:EyePos() )
								end
							net.Broadcast()
							
							ent:SetVar( "miss", CurTime() + 1 )
							
							dmginfo:SetDamage( 0 )
							dmginfo:SetDamageForce( Vector( 0, 0, 0 ) )
							dmginfo:SetDamageType( 0 )
							dmginfo:SetDamageBonus( 0 )

							ent:EmitSound( Sound( "undertale/attack.wav" ), 75, 100, 1, CHAN_AUTO  )
						end
					else
						ent:SetVar( "bad_time", ent:GetVar( "bad_time", 0 ) + dmginfo:GetDamage() * 0.5 )

						if( ent:GetVar( "bad_time" ) ) > 100 then
							ent:SetVar( "bad_time", 100 )
						end

						net.Start( "bad_time" )
							net.WriteEntity( ent )
							net.WriteFloat( ent:GetVar( "bad_time" ) )
						net.Broadcast()
					end
				end
			end
		end )
	end
	
	if( CLIENT ) then		
		net.Receive( "miss", function()
			local ply = net.ReadEntity()
			local vec = net.ReadVector()
			//print( ply, vec )
			
			local emitter = ParticleEmitter( vec, false )
			
			local particle = emitter:Add( Material( "undertale/miss" ), vec )
			if( particle ) then
				particle:SetVelocity( Vector( 0, 0, 10 ) )
				particle:SetColor( 255, 255, 255 ) 
				particle:SetLifeTime( 0 )
				particle:SetDieTime( 2 )
				particle:SetStartSize( 10 )
				particle:SetEndSize( 10 )
				particle:SetStartAlpha( 255 )
				particle:SetEndAlpha( 0 )
				particle:SetGravity( Vector( 0, 0, 0 ) )
			end
			
			emitter:Finish()
		end )

		net.Receive( "bad_time", function()
			local ent = net.ReadEntity()
			local damage = net.ReadFloat()

			if( ent:GetActiveWeapon():IsValid() ) then
				ent:GetActiveWeapon():SetVar( "bad_time", damage )
			end
			//print( damage, ent )
		end )
		
		net.Receive( "bad_time_mode", function()
			local ent = net.ReadEntity()
			ent:SetVar( "bad_time_mode", net.ReadFloat() )
		end	)
	end
end

function SWEP:Equip()
	self:SetVar( "grabbedEnt", self )
	self:SetVar( "distance", 0 )
	self:SetVar( "blockTelekinesis", 0 )
	self:SetVar( "blockBoneGround", 0 )
	self:SetVar( "invincible", 0 )
	self:SetVar( "btm_client", NULL )
	self:SetVar( "anim_reset", NULL )
	
	self:SetVar( "timer1", 0 )
	
	self.Owner:SetVar( "miss", 0 )
	self.Owner:SetVar( "player_model", self.Owner:GetModel() )

	self.Owner:SetVar( "bad_time", 0 )
	self.Owner:SetVar( "bad_time_mode", 0 )

	net.Start( "bad_time" )
		net.WriteEntity( self.Owner )
		net.WriteFloat( 0 )
	net.Broadcast()
end

function SWEP:DrawEyeLight()
	if( self:GetVar( "bad_time_mode" ) == 0 ) then
		local emitter = ParticleEmitter( self.Owner:EyePos(), false )
		
		//effects/fire_cloud1
		local particle = emitter:Add( Material( "effects/fire_cloud1" ), vec )
		if( particle ) then
			particle:SetVelocity( VectorRand() * 40 )
			particle:SetColor( 0, 100, 255 ) 
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 1 )
			particle:SetAngles( Angle( math.Rand( 0, 360 ), 0, 0 ) )
			particle:SetAngleVelocity( Angle( math.Rand( -1, 1 ), 0, 0 ) )
			particle:SetStartSize( 20 )
			particle:SetEndSize( 10 )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetGravity( Vector( 0, 0, 60 ) )
		end
		
		emitter:Finish()
	end
end

function SWEP:Deploy( )
	if( CLIENT ) then return true end
	
	if( self.BeatSound ) then
		self.BeatSound:ChangeVolume( 1, 0.1 )
	else
		self.BeatSound = CreateSound( self.Owner, Sound( "undertale/theme/sans_theme.mp3" ) )
		self.BeatSound:Play()
	end
	
	local model	= "models/nia/sans_pm.mdl"
	if( util.IsValidModel( model ) ) then
		self.Owner:SetModel( model )
	end

	local model	= "models/sansplayer/sansplayer.mdl"
	if( util.IsValidModel( model ) ) then
		self.Owner:SetModel( model )
	end

	return true
end

function SWEP:KillSounds()
	if ( self.BeatSound ) then self.BeatSound:Stop() self.BeatSound = nil end
end

function SWEP:OnDrop( )
	if IsValid(self.Owner) then
		if(self.Owner:GetModel() == "models/sansplayer/sansplayer.mdl") then
			self.Owner:SetBodygroup( 1, 0 )
			self.Owner:SetBodygroup( 2, 0 )
		end

		if(self.Owner:GetModel() == "models/nia/sans_pm.mdl") then
			self.Owner:SetBodygroup( 2, 0 )
		end


		if( self.Owner:Health() ) > 0 then
			self.Owner:SetModel( self.Owner:GetVar( "player_model", NULL ) )
		end
	end

	self:KillSounds()
end

function SWEP:OnRemove()
	if( CLIENT ) then return end
	if( self.Owner:IsValid() ) then
		if( self.Owner:Health() > 0 ) then
			if( self.Owner:GetVar( "player_model", NULL ) != NULL ) then
				self.Owner:SetModel( self.Owner:GetVar( "player_model", NULL ) )
			end
		end
	end

	self:KillSounds()
end

function SWEP:Holster( wep )
	if( CLIENT ) then return end
	
	if( !IsFirstTimePredicted() ) then return end

	self.Owner:DoAnimationEvent( ACT_GMOD_IN_CHAT )
	self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Clavicle" ), Angle( 0, 0, 0 ) )
	self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Clavicle" ), Angle( 0, 0, 0 ) )
	self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Forearm" ), Angle( 0, 0, 0 ) )
	self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Forearm" ), Angle( 0, 0, 0 ) )
	self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Hand" ), Angle( 0, 0, 0 ) )
	self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Hand" ), Angle( 0, 0, 0 ) )
	self:SetVar( "anim_reset", true )
	
	if(self.Owner:GetModel() == "models/sansplayer/sansplayer.mdl") then
		self.Owner:SetBodygroup( 1, 0 )
		self.Owner:SetBodygroup( 2, 0 )
	end

	if(self.Owner:GetModel() == "models/nia/sans_pm.mdl") then
		self.Owner:SetBodygroup( 2, 0 )
	end

	if( self.Owner:IsValid() ) then
		if( self.Owner:Health() > 0 ) then
			//print( wep, wep:GetClass() )
			self.Owner:SetActiveWeapon( wep )
			//self.Owner:SelectWeapon( wep:GetClass() ) 
			if( self.Owner:GetVar( "player_model", NULL ) != NULL ) then
				self.Owner:SetModel( self.Owner:GetVar( "player_model", NULL ) )
			end
		end
	end

	if( self:GetVar( "blockTelekinesis", NULL ) ) then
		self:SetVar( "grabbedEnt", nil )
		self:SetVar( "blockTelekinesis", 2 )
		self:SetVar( "timer1", CurTime() )
	end
	
	if ( self.BeatSound ) then self.BeatSound:ChangeVolume( 0, 0.1 ) end
	return true
end

//local grabbedEnt
//local distance
local max = 200
//local blockTelekinesis
//local invincible


concommand.Add( "pc_sans_rage_mode", function( ply )
	local swep = ply:GetActiveWeapon()
	if( ply:GetVar( "bad_time" ) != NULL && ply:GetVar( "bad_time_mode" ) != NULL && swep:IsValid() ) then
		
		if( ply:GetVar( "bad_time" ) == 100 && swep:GetClass() == "weapon_undertale_sans" ) then
			if( ply:GetVar( "bad_time_mode" ) == 0 ) then
				ply:SetVar( "bad_time_mode", CurTime() )
			end
		end
	end
end )

function SWEP:Think()
	// Telekinesis
	local EyeTrace = self.Owner:GetEyeTrace()
	local grabbedEnt = self:GetVar( "grabbedEnt", NULL )
	local distance = self:GetVar( "distance", NULL )
	local blockTelekinesis = self:GetVar( "blockTelekinesis", NULL )
	local blockBoneGround = self:GetVar( "blockBoneGround", NULL )
	
	if( CLIENT ) then return end
	if( self.Owner:GetVelocity():Length() < 30 || self.Owner:GetMoveType() == MOVETYPE_NOCLIP ) then
		//self.Owner:DoAnimationEvent( ACT_HL2MP_IDLE )
		
		if( self:GetVar( "anim_reset" ) != NULL ) then
			if(self.Owner:GetModel() == "models/nia/sans_pm.mdl") then
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Clavicle" ), Angle( 0, 10, -40 ) )
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Clavicle" ), Angle( 0, 10, 30 ) )
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Forearm" ), Angle( 0, -90, 0 ) )
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Forearm" ), Angle( 0, -90, 0 ) )
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Hand" ), Angle( 180, 0, 0 ) )
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Hand" ), Angle( 180, 0, 0 ) )
			end
			if(self.Owner:GetModel() == "models/sansplayer/sansplayer.mdl") then
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Clavicle" ), Angle( 0, 10, -30 ) )
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Clavicle" ), Angle( 0, 10, 30 ) )
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Forearm" ), Angle( 0, -60, 0 ) )
				self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Forearm" ), Angle( 0, -60, 0 ) )
			end
			self:SetVar( "anim_reset", NULL )
		end
	else
		if( self:GetVar( "anim_reset" ) == NULL && self.Owner:GetVelocity():Length() > 150 ) then
			self:SetVar( "anim_reset", true )
			
			//self.Owner:DoAnimationEvent( ACT_GMOD_IN_CHAT )
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Clavicle" ), Angle( 0, 0, 0 ) )
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Clavicle" ), Angle( 0, 0, 0 ) )
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Forearm" ), Angle( 0, 0, 0 ) )
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Forearm" ), Angle( 0, 0, 0 ) )
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Hand" ), Angle( 0, 0, 0 ) )
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_L_Hand" ), Angle( 0, 0, 0 ) )
		end
	end

	if( self.Owner:GetActiveWeapon():GetClass() == "weapon_undertale_sans" ) then
		if( self.Owner:GetVar( "bad_time_mode" ) != NULL ) then
			if( self.Owner:GetVar( "bad_time_mode" ) > 0 ) then
				if(self.Owner:GetModel() == "models/sansplayer/sansplayer.mdl") then
					self.Owner:SetBodygroup( 1, 1 )
					self.Owner:SetBodygroup( 2, 1 )
				end

				if(self.Owner:GetModel() == "models/nia/sans_pm.mdl") then
					self.Owner:SetBodygroup( 2, 2 )
				end

				if( self:GetVar( "btm_client" ) == NULL ) then
					//print( "sand " )
					
					net.Start( "bad_time_mode" )
						net.WriteEntity( self )
						net.WriteFloat( CurTime() )
					net.Broadcast()
					
					self:SetVar( "btm_client", true )
				end
				
				self:SetVar( "blockTelekinesis", 1 )
				self:SetVar( "anim_reset", true )
				self:SetVar( "grabbedEnt", nil )
				self:SetVar( "timer1", CurTime() )
				
				if( CurTime() > ( self.Owner:GetVar( "bad_time_mode" ) + 10 ) ) then
					self.Owner:SetVar( "bad_time_mode", 0 )
					self.Owner:SetVar( "bad_time", 0 )
					
					self:SetVar( "btm_client", NULL )
					
					if(self.Owner:GetModel() == "models/sansplayer/sansplayer.mdl") then
						self.Owner:SetBodygroup( 1, 0 )
						self.Owner:SetBodygroup( 2, 0 )
					end

					if(self.Owner:GetModel() == "models/nia/sans_pm.mdl") then
						self.Owner:SetBodygroup( 2, 0 )
					end
				end
			end
		end
	end
	
	if( self.Owner:KeyPressed( IN_RELOAD ) && self:GetVar( "blockBoneGround" ) == 0 ) then
		if( self.Owner:GetVar( "bad_time_mode" ) == 0 ) then
			self:SetVar( "blockBoneGround", CurTime() + 1.5 )
		else
			self:SetVar( "blockBoneGround", CurTime() + 0.5 )
		end
		
		local tr = util.TraceLine( {
			start = self.Owner:GetShootPos(),
			endpos = self.Owner:GetShootPos() + self.Owner:EyeAngles():Forward() * 10000,
			filter = function( ent ) if ( ent:GetClass() == "prop_physics" ) then return false end end
		} )

		local pos = tr.HitPos
		local rad = 30
		
		sound.Play( Sound( "undertale/bone_start.wav" ), tr.HitPos )
		
		for i = 1, 15 do
			local vec = Vector( math.Rand( -rad, rad ), math.Rand( -rad, rad ), 0 )
			vec:Rotate( tr.HitNormal:Angle() + Angle( 90, 0, 0 ) )
			local ang = ( tr.HitNormal * 2 + VectorRand() ):Angle()
			
			local traceGrd = util.TraceLine( {
				start = pos + vec,
				endpos = pos + vec - ang:Up() * 50,
				filter = function( ent ) if ( ent:GetClass() == "prop_physics" ) then return true end end
			} )
			
			if( traceGrd.Hit ) then
				local ent = ents.Create( "ent_undertale_bone_ground" )
				ent:SetAngles( ang + Angle( 90, 0, 0 ) )
				ent:SetVar( "pos", pos )
				ent:SetVar( "normal", tr.HitNormal )
				ent:SetPos( traceGrd.HitPos )
				ent:SetOwner( self.Owner )
				//ent:EmitSound( "undertale/bone_start.wav", 75, 100, 1, CHAN_AUTO )
				ent:Spawn()
			end
		end
	end
	
	if( CurTime() > self:GetVar( "blockBoneGround" ) ) then
		self:SetVar( "blockBoneGround", 0 )
	end
	
	local timer1 = ( CurTime() - self:GetVar( "timer1" ) )

	if( self.Owner:GetVar( "bad_time_mode" ) > 0 ) then
		self:SetVar( "timer1", CurTime() )
	end
	
	if( blockTelekinesis == 0 ) then
		if( self.Owner:KeyPressed( IN_USE ) && self.Owner:GetPos():Distance( EyeTrace.HitPos ) < 500 && EyeTrace.Entity:IsValid() ) then
			if( EyeTrace.Entity:IsNPC() || EyeTrace.Entity:IsPlayer() ) then
				self.Owner:EmitSound( Sound( "undertale/sans/active.wav" ), 75, 100, 1, CHAN_AUTO )
				
				self:SetVar( "grabbedEnt", EyeTrace.Entity )
				grabbedEnt = self:GetVar( "grabbedEnt", NULL )
				
				self:SetVar( "distance", math.max( max, self.Owner:GetPos():Distance( grabbedEnt:GetPos() ) ) )
				self:SetVar( "timer1", CurTime() )
				timer1 = 0
				self:SetWeaponHoldType( "magic" )
			end
		end

		if( grabbedEnt:IsValid() ) then				
			local eyeAng = self.Owner:GetAngles()
			
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Clavicle" ), Angle( 0, 0, 0 ) )
			self.Owner:ManipulateBoneAngles( self.Owner:LookupBone( "ValveBiped.Bip01_R_Clavicle" ), Angle( 0, 20, 45 - eyeAng.x ) )
			
			if( timer1 >= 4 || grabbedEnt:Health() <= 0 ) then
				self:SetVar( "blockTelekinesis", 1 )
				self:SetVar( "grabbedEnt", nil )
				self:SetVar( "timer1", CurTime() )
				
				self:SetVar( "anim_reset", true )
			end
			
			if( self.Owner:KeyReleased( IN_USE ) ) then
				if( timer1 > 1 ) then
					self:SetVar( "grabbedEnt", nil )
					self:SetVar( "blockTelekinesis", 2 )
					self:SetVar( "timer1", CurTime() )
				else
					self:SetVar( "grabbedEnt", nil )
					self:SetVar( "blockTelekinesis", 3 )
					self:SetVar( "timer1", CurTime() )
				end
				
				self:SetVar( "anim_reset", true )
			end
		end
	elseif( blockTelekinesis == 1 ) then
		if( timer1 >= 10 ) then
			self:SetVar( "blockTelekinesis", 0 )
			self:SetVar( "timer1", 0 )
		end
	elseif( blockTelekinesis == 2 ) then
		if( timer1 >= 5 ) then
			self:SetVar( "blockTelekinesis", 0 )
			self:SetVar( "timer1", 0 )
		end
	elseif blockTelekinesis == 3 then
		if( timer1 >= 1 ) then
			self:SetVar( "blockTelekinesis", 0 )
			self:SetVar( "timer1", 0 )
		end
	else
		self:SetVar( "blockTelekinesis", 0 )
		self:SetVar( "timer1", 0 )
	end
	
	if( grabbedEnt != nil && blockTelekinesis == 0 ) then
		if( grabbedEnt:IsValid() ) then
			
			local EyeDir = ( EyeTrace.HitPos - self.Owner:GetShootPos() )
			EyeDir:Normalize()

			grabbedEnt:SetVelocity( ( self.Owner:GetShootPos() + EyeDir * distance - Vector( 0, 0, grabbedEnt:GetModelRadius() * 0.5 ) - grabbedEnt:GetPos() ) * 10 - grabbedEnt:GetVelocity() )
			
			if( self:GetVar( "invincible" ) == 0 ) then
				local tr = util.TraceHull( {
					start = grabbedEnt:GetPos(),
					endpos = grabbedEnt:GetPos() + grabbedEnt:GetVelocity() / 40,
					filter = grabbedEnt,
					mins = grabbedEnt:OBBMins(),
					maxs = grabbedEnt:OBBMaxs()
				} )
				
				if( tr.HitWorld && grabbedEnt:GetVelocity():Length() > 200 ) then
					self:SetVar( "invincible", CurTime() )
				
					grabbedEnt:TakeDamage( grabbedEnt:GetVelocity():Length() / 100, self.Owner, self.Owner )
					
					grabbedEnt:EmitSound( Sound( "undertale/sans/smash.wav" ), 75, 100, 1, CHAN_AUTO ) 
					//EmitSound( Sound( sound ),grabbedEnt:GetPos() )
				end
			elseif ( CurTime() - self:GetVar( "invincible" ) ) >= 0.5 then
				self:SetVar( "invincible", 0 )
			end
		end
	end
end

function SWEP:PrimaryAttack()
	if( CLIENT ) then return end
	
	if( !self:GetVar( "grabbedEnt", NULL ):IsValid() ) then
	
		if( self.Owner:GetVar( "bad_time_mode" ) == 0 ) then
			self:SetNextPrimaryFire( CurTime() + 0.5 ) 
			self:SetNextSecondaryFire( CurTime() + 0.25 )
		else
			self:SetNextPrimaryFire( CurTime() + 0.2 )
			self:SetNextSecondaryFire( CurTime() + 0.1 )
		end
		
		local ent = ents.Create( "ent_undertale_gaster_blaster" )
		local rand = math.Rand( -math.pi, math.pi ) * 0.5
		local vec = Vector( 0, math.sin( rand ) * 70, 100 + math.cos( rand ) * 50 )
		
		vec:Rotate( Angle( 0, self.Owner:GetAngles().y, 0 ) )
		local pos = self.Owner:GetPos() + vec

		ent:SetAngles( ( self.Owner:GetEyeTrace().HitPos - pos ):Angle() )
		ent:SetPos( self.Owner:GetPos() )
		ent:EmitSound( Sound( "undertale/gaster_blaster/gaster_blaster_start.mp3" ), 75, 100, 1, CHAN_AUTO )
		ent:SetOwner( self.Owner )
		ent:Spawn()
		ent:SetVar( "position", pos )
	end
end

function SWEP:SecondaryAttack()
	if( CLIENT ) then return end
	
	local entGrabbed = self:GetVar( "grabbedEnt", NULL )
	if( !entGrabbed:IsValid() ) then
		//self:SetVar( "reloadGB", 25 )
		if( self.Owner:GetVar( "bad_time_mode" ) == 0 ) then
			self:SetNextPrimaryFire( CurTime() + 0.5 ) 
			self:SetNextSecondaryFire( CurTime() + 0.25 )
		else
			self:SetNextPrimaryFire( CurTime() + 0.2 ) 
			self:SetNextSecondaryFire( CurTime() + 0.1 )
		end
		
		local ent = ents.Create( "ent_undertale_bone_throw" )
		local side
		
		if( math.Round( math.Rand( 0, 1 ) ) == 0 ) then
			side = 1
		else
			side = -1
		end
		
		local pos = self.Owner:GetShootPos() + self.Owner:EyeAngles():Right() * 40 * side

		ent:SetPos( pos )
		ent:SetAngles( ( self.Owner:GetEyeTrace().HitPos - pos ):Angle() + Angle( 90, 0, 0 ) )
		ent:EmitSound( Sound( "undertale/bone_end.wav" ), 75, 100, 1, CHAN_AUTO )
		ent:SetOwner( self.Owner )
		ent:Spawn()
		
		local phys = ent:GetPhysicsObject()
		phys:SetVelocity( ent:GetUp() * 10000 )
	else
		self:SetNextSecondaryFire( CurTime() + 2 )
		
		for cycles = 1, 4 do
			local ent = ents.Create( "ent_undertale_bone_throw" )
			local dir = VectorRand()
			dir:Normalize()
			
			local minb, maxb = entGrabbed:GetCollisionBounds()
			local pos = entGrabbed:GetPos() + Vector( 0, 0, maxb.z * 0.5 ) + dir * 100

			ent:SetPos( pos )
			ent:SetOwner( self.Owner )
			ent:SetAngles( ( entGrabbed:GetPos() + Vector( 0, 0, 50 ) - pos ):Angle() + Angle( 90, 0, 0 ) )
			//ent:EmitSound( Sound( "undertale/bone_end.wav" ), 75, 100, 1, CHAN_AUTO )
			ent:Spawn()
			
			local phys = ent:GetPhysicsObject()
			phys:SetVelocity( ent:GetUp() * 2000 )
		end
	end
end

function SWEP:DrawHUD()
	if( self:GetVar( "bad_time", NULL ) == NULL ) then
		self:SetVar( "bad_time", 0 )
		self:SetVar( "bad_time_mode", 0 )
	end
	
	local sizex = 300
	local sizey = 30
	local indentx = 10
	local indenty = 10
	
	surface.SetFont( "Default" )
	surface.SetTextColor( 255, 255, 255, 255 )
	surface.SetTextPos( ScrW() - sizex - indentx, ScrH() - sizey - indenty - 15 )
	surface.DrawText( "Bad Time Bar" )
	
	surface.SetDrawColor( 255, 255, 255, 255 )
	surface.DrawRect( ScrW() - sizex - indentx, ScrH() - sizey - indentx, sizex, sizey )

	if( self:GetVar( "bad_time_mode" ) == 0 ) then
		surface.SetDrawColor( 50, 150, 255, 255 )
		surface.DrawRect( ScrW() - sizex - indentx + 1, ScrH() - sizey - indentx + 1, sizex * self:GetVar( "bad_time" ) / 100 - 2, sizey - 2 )
	else
		if not self:GetVar( "bad_time_mode" ) then return end
		local val = 1 - ( CurTime() - self:GetVar( "bad_time_mode" ) ) / 10
		if( CurTime() > self:GetVar( "bad_time_mode" ) + 10 ) then
			self:SetVar( "bad_time", 0 )
			self:SetVar( "bad_time_mode", 0 )
		end
		
		surface.SetDrawColor( 50, 150, 255, 255 )
		surface.DrawRect( ScrW() - sizex - indentx + 1, ScrH() - sizey - indentx + 1, sizex * val - 2, sizey - 2 )
	end
end
--PATH addons/__main/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onions"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Vapes"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.VapeID = 1

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:PrimaryAttack()
	if SERVER then
		VapeUpdate(self.Owner, self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SecondaryAttack()
	if GetConVar("vape_block_sounds"):GetBool() then return end
	
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapegogreen.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (0.6*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Reload()
	if GetConVar("vape_block_sounds"):GetBool() then return end

	if self.reloading then return end
	self.reloading=true
	timer.Simple(0.5, function() self.reloading=false end)
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapenaysh.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (2.2*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Holster()
	if SERVER and IsValid(self.Owner) then
		ReleaseVape(self.Owner)
	end
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--PATH addons/__main/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onions"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Vapes"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.VapeID = 1

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:PrimaryAttack()
	if SERVER then
		VapeUpdate(self.Owner, self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SecondaryAttack()
	if GetConVar("vape_block_sounds"):GetBool() then return end
	
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapegogreen.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (0.6*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Reload()
	if GetConVar("vape_block_sounds"):GetBool() then return end

	if self.reloading then return end
	self.reloading=true
	timer.Simple(0.5, function() self.reloading=false end)
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapenaysh.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (2.2*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Holster()
	if SERVER and IsValid(self.Owner) then
		ReleaseVape(self.Owner)
	end
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--PATH addons/__main/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onions"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Vapes"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.VapeID = 1

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:PrimaryAttack()
	if SERVER then
		VapeUpdate(self.Owner, self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SecondaryAttack()
	if GetConVar("vape_block_sounds"):GetBool() then return end
	
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapegogreen.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (0.6*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Reload()
	if GetConVar("vape_block_sounds"):GetBool() then return end

	if self.reloading then return end
	self.reloading=true
	timer.Simple(0.5, function() self.reloading=false end)
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapenaysh.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (2.2*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Holster()
	if SERVER and IsValid(self.Owner) then
		ReleaseVape(self.Owner)
	end
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--PATH addons/_farmer/lua/entities/ba_cage/cl_init.lua:
include("shared.lua");

surface.CreateFont("BA_Cage_Text", {
	font = "Tahoma",
	size = 36,
	weight = 700,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	
end;


function ENT:Think()
end;

function ENT:Draw()
	self:DrawModel();
	
	local camPos = self:GetPos();
	local camAng = self:GetAngles();
	
	camAng:RotateAroundAxis(camAng:Up(), 90);
	camAng:RotateAroundAxis(camAng:Forward(), 90);
	camAng:RotateAroundAxis(camAng:Right(), 0);
	
	local name = self:GetNWString("name");
	local length = (string.len(self:GetNWString("name"))*21);

	local color = string.Explode(",", self:GetNWString("color"));
	
	local tab = B_Animals_Config.Animal_Library
	local str = self:GetNWString("class")

	if (self:GetNWBool("full")) then
		for k, v in pairs(B_Animals_Config.Animal_Library) do 
			if (v.class == self:GetNWString("class")) then
				time_toeat = v.time_toeat;
			end;
			--tab = tab[index]
		end
	end;

	if (LocalPlayer():GetPos():Distance(self:GetPos()) < (B_Animals_Config.DrawDistance*2)) then
		if (self:GetNWBool("full")) then
			cam.Start3D2D(camPos+camAng:Up()*22.5, camAng, 0.125)
				draw.RoundedBox(0, -90, -410, 180, 100, Color(0, 0, 0, 230));
				
				-- This neat-o health bar
				if (self:GetNWInt("health") > 0) then
					draw.RoundedBox(0, -87, -407, 174, 16, Color(128, 0, 0, 200));
				else
					--draw.RoundedBox(0, -87, -407, 174, 16, Color(50, 50, 70, 200));
				end;
				draw.RoundedBox(0, -87, -407, math.Clamp((self:GetNWInt("health")*174)/B_Animals_Config.SmallCage_Health, 0, 174), 16, Color(50, 50, 70, 200));
				
				-- Hunger bar
				if (self:GetNWInt("time_toeat") > 0) then
					draw.RoundedBox(0, -87, -382, 174, 16, Color(170, 80, 0, 200));
				else
					draw.RoundedBox(0, -87, -382, 174, 16, Color(255, 0, 0, 200));
				end;
				draw.RoundedBox(0, -87, -382, math.Clamp(((self:GetNWInt("time_toeat")*174)/B_Animals_Config.Animal_Library[self:GetNWString("class")].time_toeat), 0, 174), 16, Color(200, 100, 0, 200));

				-- Drink bar
				if (self:GetNWInt("time_todrink") > 0) then
					draw.RoundedBox(0, -87, -357, 174, 16, Color(0, 98, 225, 200));
				else
					draw.RoundedBox(0, -87, -357, 174, 16, Color(255, 0, 0, 200));
				end;
				draw.RoundedBox(0, -87, -357, math.Clamp(((self:GetNWInt("time_todrink")*174)/B_Animals_Config.Animal_Library[self:GetNWString("class")].time_todrink), 0, 174), 16, Color(0, 128, 255, 200));
			
				-- Aging & Producing Bar
				if (self:GetNWInt("time_togrow") > 0) then
					draw.RoundedBox(0, -87, -332, 174, 16, Color(161, 161, 71, 200));
					
					draw.RoundedBox(0, -87, -332, math.Clamp(((B_Animals_Config.Animal_Library[self:GetNWString("class")].time_togrow - self:GetNWInt("time_togrow"))*174)/B_Animals_Config.Animal_Library[self:GetNWString("class")].time_togrow, 0, 174), 16, Color(255, 201, 91, 200));
				else
					draw.RoundedBox(0, -87, -332, 174, 16, Color(59, 172, 45, 200));
					
					draw.RoundedBox(0, -87, -332, math.Clamp(((B_Animals_Config.Animal_Library[self:GetNWString("class")].time_toprofit - self:GetNWInt("time_toprofit"))*174)/B_Animals_Config.Animal_Library[self:GetNWString("class")].time_toprofit, 0, 174), 16, Color(109, 232, 95, 200));
				end;
			cam.End3D2D();
			
			
			local time_toeat_max = B_Animals_Config.Animal_Library[self:GetNWString("class")].time_toeat;
			local time_todrink_max = B_Animals_Config.Animal_Library[self:GetNWString("class")].time_todrink;
			local time_togrow_max = B_Animals_Config.Animal_Library[self:GetNWString("class")].time_togrow;
			local time_toprofit_max = B_Animals_Config.Animal_Library[self:GetNWString("class")].time_toprofit;
			
			cam.Start3D2D(camPos+camAng:Up()*22.5, camAng, 0.0725)
				draw.SimpleTextOutlined(self:GetNWString("name"), "BA_Cage_Text", -147, -712, Color(255, 255, 255, 200), TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT, 1.5, Color(0, 0, 0, 200));
				if (self:GetNWInt("time_toeat") > 0) then
					draw.SimpleTextOutlined("Hunger: "..math.Round(math.Clamp((self:GetNWInt("time_toeat")*100)/time_toeat_max, 0, 100)).."%", "BA_Cage_Text", -147, -670, Color(255, 255, 255, 200), TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT, 1.5, Color(0, 0, 0, 200));
				else
					draw.SimpleTextOutlined("I'M HUNGRY!!!", "BA_Cage_Text", -147+(math.sin(-CurTime()*24)*4), -670+(math.cos(-CurTime()*24)*4), Color(255, 0, 0, 200), TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT, 1.5, Color(0, 0, 0, 200));
				end;
				
				if (self:GetNWInt("time_todrink") > 0) then
					draw.SimpleTextOutlined("Thirst: "..math.Round(math.Clamp((self:GetNWInt("time_todrink")*100)/time_todrink_max, 0, 100)).."%", "BA_Cage_Text", -147, -627, Color(255, 255, 255, 200), TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT, 1.5, Color(0, 0, 0, 200));
				else
					draw.SimpleTextOutlined("I'M THIRSTY!!!", "BA_Cage_Text", -147+(math.sin(CurTime()*32)*4), -627+(math.cos(CurTime()*32)*4), Color(255, 0, 0, 200), TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT, 1.5, Color(0, 0, 0, 200));
				end;
				
				if (self:GetNWInt("time_togrow") > 0) then
					draw.SimpleTextOutlined("Age: "..math.Round(math.Clamp(100 - (self:GetNWInt("time_togrow")*100)/time_togrow_max, 0, 100)).."%", "BA_Cage_Text", -147, -584, Color(255, 255, 255, 200), TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT, 1.5, Color(0, 0, 0, 200));
				else
					draw.SimpleTextOutlined("Production: "..math.Round(math.Clamp(100 - (self:GetNWInt("time_toprofit")*100)/time_toprofit_max, 0, 100)).."%", "BA_Cage_Text", -147, -584, Color(255, 255, 255, 200), TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT, 1.5, Color(0, 0, 0, 200));	
				end;
				--draw.SimpleText(B_Animals_Config.Animal_Library.Animal.time_toeat, "BA_Cage_Text", -147, -606, Color(255, 255, 255, 200), TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT);
			cam.End3D2D();
		end;
	end;
end;

--[[
B_Animals_Config.Animal_Library =
	{
		Animal	=	
			{
				class = "Animal", -- A class name for Animal.
				
				names = {"Bobby", "Dobby", "Sobby"}, -- A names for this Animal class.
				models = {"models/player/corpse1.mdl", "models/player/zombie_classic.mdl"}, -- A models for this Animal.
				
				anim = "sit_zen", -- An animation for this Animal.
				pos = Vector(0, 0, 4), -- Position adjustments for Animal Vector(forward, right, up)
				
				start_size = 0.35, -- Starting size of monster.
				final_size = 0.95, -- Final size of monster.
			
				time_togrow = 60, -- Time required for monster to grow up.
				
				time_toeat
]]--
--PATH addons/_farmer/lua/entities/ba_cage/shared.lua:
ENT.Base = "base_gmodentity";
ENT.Type = "anim";

ENT.PrintName		= "Small Cage";
ENT.Category 		= "Business: Animals";
ENT.Author			= "EnnX49";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

--PATH addons/_farmer/lua/entities/ba_lunatic/cl_init.lua:
include("shared.lua");
ENT.RenderGroup = RENDERGROUP_BOTH;

function ENT:Draw()
	self:DrawModel();
end;

function ENT:DrawTranslucent()
	self:Draw();
end;

function ENT:BuildBonePositions(NumBones, NumPhysBones)
end;
 
function ENT:SetRagdollBones(bIn)
	self.m_bRagdollSetup = bIn;
end;

function ENT:DoRagdollBone(PhysBoneNum, BoneNum)
end;

--PATH addons/_farmer/lua/entities/ba_lunatic/shared.lua:
ENT.Base = "base_ai"
ENT.Type = "ai"

ENT.PrintName		= "Lunatic";
ENT.Category 		= "Business: Animals";
ENT.Author			= "EnnX49";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= false;
ENT.AdminSpawnable		= false;

ENT.AutomaticFrameAdvance = true;
   
ENT.Spawnable = true;
ENT.AdminSpawnable = true;

function ENT:PhysicsCollide(data, physobj)
end;

function ENT:PhysicsUpdate(physobj)
end;

function ENT:SetAutomaticFrameAdvance(bUsingAnim)
	self.AutomaticFrameAdvance = bUsingAnim;
end;

--PATH addons/_bitminers2/lua/entities/bm2_bitminer_1/cl_init.lua:
include( "shared.lua" )
local function __round( num, numDecimalPlaces )
	local mult = 10 ^ ( numDecimalPlaces or 0 )
	return math.floor( num * mult + 0.5 ) / mult
end

--Animate fan(s)
function ENT:Think()
	if LocalPlayer():GetPos():Distance( self:GetPos() ) < 500 then
		if self:GetIsMining() then
			self.fanAng = self.fanAng + FrameTime() * 400
			for i = 0, self:GetBoneCount() - 1 do
				if string.match( self:GetBoneName( i ), "fan" ) ~= nil then self:ManipulateBoneAngles( i, Angle( self.fanAng, 0, 0 ) ) end
			end
		end

		if self.prev ~= self:GetIsMining() then
			self:DestroyShadow()
			self:CreateShadow()
		end

		self.prev = self:GetIsMining()
	end
end

--Yuck I know but its to much effort to re-write the entire system
function ENT:Initialize()
	self.fanAng = 0
	self.prev = false
	--So each bitminer can have its own set of unique instructions. This is how we will do that
	self.customInstructions = {
		status = {
			--Outputs usefull runtime infomation
			command = "STATUS",
			description = "Outputs usefull infomation about the current device.",
			action = function( _, _, _, ent, consoleDisplay )
				consoleDisplay.history = consoleDisplay.history .. "\n------------------STATUS------------------\n"
				local firstPart = "IS MINING                                 "
				local secondPart = string.upper( tostring( ent:GetIsMining() ) )
				consoleDisplay.history = consoleDisplay.history .. string.sub( firstPart, 1, string.len( firstPart ) - string.len( secondPart ) ) .. secondPart .. "\n"
				firstPart = "HAS POWER                                 "
				secondPart = string.upper( tostring( ent:GetHasPower() ) )
				consoleDisplay.history = consoleDisplay.history .. string.sub( firstPart, 1, string.len( firstPart ) - string.len( secondPart ) ) .. secondPart .. "\n"
				consoleDisplay.history = consoleDisplay.history .. "------------------------------------------\n\n"
			end
		},
		info = {
			command = "INFO",
			description = "Outputs sepcifications for the device such as power usage.",
			action = function( _, _, _, ent, consoleDisplay )
				consoleDisplay.history = consoleDisplay.history .. "\n-------------------INFO------------------\n"
				local firstPart = "CLOCK SPEED                              "
				local secondPart = tostring( __round( ent:GetClockSpeed(), 3 ) ) .. "Ghz"
				consoleDisplay.history = consoleDisplay.history .. string.sub( firstPart, 1, string.len( firstPart ) - string.len( secondPart ) ) .. secondPart .. "\n"
				local firstPart = "CORES                                    "
				local secondPart = ent:GetCoreCount()
				consoleDisplay.history = consoleDisplay.history .. string.sub( firstPart, 1, string.len( firstPart ) - string.len( secondPart ) ) .. secondPart .. "\n"
				consoleDisplay.history = consoleDisplay.history .. "POWER REQUIREMENT                    100W\n"
				consoleDisplay.history = consoleDisplay.history .. "MODEL NAME                    Bitminer S1\n"
				local playerName = self:Getowning_ent()
				if playerName ~= NULL then
					playerName = playerName:Name()
				else
					playerName = "Unknown"
				end

				consoleDisplay.history = consoleDisplay.history .. string.sub( "OWNER                                    ", 1, string.len( "OWNER                                    " ) - string.len( playerName ) ) .. playerName .. "\n"
				consoleDisplay.history = consoleDisplay.history .. "-----------------------------------------\n\n"
			end
		},
		mining = {
			command = "MINING",
			description = "Starts or stop the miner from mining.",
			action = function( arg1, _, _, ent, consoleDisplay )
				if arg1 == nil then
					consoleDisplay.history = consoleDisplay.history .. "To use this command please supply one of the following arguments, 'mining start' or 'mining stop'\n"
				elseif arg1 == "start" then
					net.Start( "BM2.Command.Mining" )
					net.WriteEntity( ent )
					net.WriteBool( true )
					net.SendToServer()
				elseif arg1 == "stop" then
					net.Start( "BM2.Command.Mining" )
					net.WriteEntity( ent )
					net.WriteBool( false )
					net.SendToServer()
				else
					consoleDisplay.history = consoleDisplay.history .. "The option '" .. arg1 .. "' is not a valid option, the options are 'mining start' or 'mining stop'\n"
				end
			end
		},
		bitcoin = {
			--Used for selling or getting info about bitcoins
			command = "BITCOIN",
			description = "Allows you to sell or see infomation about the stored bitcoins.",
			action = function( arg1, _, _, ent, consoleDisplay )
				if arg1 == "info" then
					consoleDisplay.history = consoleDisplay.history .. "\n-------------------BITCOIN------------------\n"
					local firstPart = "Bitcoin Amount                              "
					local secondPart = comma_value( __round( ent:GetBitcoinAmount(), 2 ) ) .. "btc"
					consoleDisplay.history = consoleDisplay.history .. string.sub( firstPart, 1, string.len( firstPart ) - string.len( secondPart ) ) .. secondPart .. "\n"
					firstPart = "Bitcoin Value ($)                           "
					secondPart = tostring( comma_value( __round( ent:GetBitcoinAmount() * BM2CONFIG.BitcoinValue, 2 ) ) )
					consoleDisplay.history = consoleDisplay.history .. string.sub( firstPart, 1, string.len( firstPart ) - string.len( secondPart ) ) .. secondPart .. "\n"
					consoleDisplay.history = consoleDisplay.history .. "--------------------------------------------\n\n"
				elseif arg1 == "sell" then
					net.Start( "BM2.Command.SellBitcoins" )
					net.WriteEntity( ent )
					net.SendToServer()
					local firstPart = "From                                        "
					local secondPart = tostring( comma_value( __round( ent:GetBitcoinAmount(), 2 ) ) ) .. "btc"
					consoleDisplay.history = consoleDisplay.history .. "\n-------------------RECEIPT------------------\n"
					consoleDisplay.history = consoleDisplay.history .. string.sub( firstPart, 1, string.len( firstPart ) - string.len( secondPart ) ) .. secondPart .. "\n"
					firstPart = "Convereted to                               "
					secondPart = "$" .. tostring( comma_value( __round( ent:GetBitcoinAmount() * BM2CONFIG.BitcoinValue, 2 ) ) )
					consoleDisplay.history = consoleDisplay.history .. string.sub( firstPart, 1, string.len( firstPart ) - string.len( secondPart ) ) .. secondPart .. "\n"
					consoleDisplay.history = consoleDisplay.history .. "The money has been transfered to your wallet\n"
					consoleDisplay.history = consoleDisplay.history .. "--------------------------------------------\n\n"
				else
					if arg1 == nil then
						consoleDisplay.history = consoleDisplay.history .. "To use this command please supply one of the following arguments, 'bitcoin info' or 'bticoin sell'\n"
					else
						consoleDisplay.history = consoleDisplay.history .. "The option '" .. arg1 .. "' is not a valid option, the options are 'bitcoin info' or 'bticoin sell'\n"
					end
				end
			end
		},
		upgrade = {
			--Used for selling or getting info about bitcoins
			command = "UPGRADE",
			description = "Shows available upgrades and allows you to purchase them.",
			action = function( arg1, _, _, ent, consoleDisplay )
				if arg1 == "1" then --CPU
					net.Start( "BM2.Command.Upgrade" )
					net.WriteEntity( ent )
					net.WriteBool( false )
					net.SendToServer()
				elseif arg1 == "2" then
					--Cores
					net.Start( "BM2.Command.Upgrade" )
					net.WriteEntity( ent )
					net.WriteBool( true )
					net.SendToServer()
				else
					if arg1 == nil then
						consoleDisplay.history = consoleDisplay.history .. "\n-------------------UPGRADES------------------\n"
						local i = 0
						if self.upgrades.CPU.cost[self:GetCPUUpgrade() + 1] ~= nil then
							i = i + 1
							firstPart = "[1] " .. self.upgrades.CPU.name .. "                                                              "
							secondPart = "                                             "
							thirdtPart = "$" .. comma_value( self.upgrades.CPU.cost[self:GetCPUUpgrade() + 1] )
							local str = string.sub( firstPart, 0, string.len( secondPart ) )
							consoleDisplay.history = consoleDisplay.history .. string.sub( str, 1, string.len( str ) - string.len( thirdtPart ) ) .. thirdtPart .. "\n"
						end

						if self.upgrades.CORES.cost[self:GetCoreUpgrade() + 1] ~= nil then
							i = i + 1
							firstPart = "[2] " .. self.upgrades.CORES.name .. "                                                              "
							secondPart = "                                             "
							thirdtPart = "$" .. comma_value( self.upgrades.CORES.cost[self:GetCoreUpgrade() + 1] )
							local str = string.sub( firstPart, 0, string.len( secondPart ) )
							consoleDisplay.history = consoleDisplay.history .. string.sub( str, 1, string.len( str ) - string.len( thirdtPart ) ) .. thirdtPart .. "\n"
						end

						if i == 0 then consoleDisplay.history = consoleDisplay.history .. "There are no more upgrade left for this device.\n" end
						consoleDisplay.history = consoleDisplay.history .. "---------------------------------------------\nType 'upgrade 1' or 'upgrade 2' to select one.\n"
					else
						consoleDisplay.history = consoleDisplay.history .. "The option '" .. arg1 .. "' is not a valid option, the options are 'upgrade 1' or 'upgrade 2'\n"
					end
				end
			end
		}
	}

	--Only add if DLC is loaded
	if BITMINERS_2_EXTRAS_DLC then
		self.customInstructions.remote = {
			command = "REMOTE",
			description = "Allows you to install and uninstall and change the name of a remote access module that will allow you to access the bitminer remotely using " .. BM2EXTRACONFIG.RemoteAccessCommand .. ". Installing it costs $" .. string.Comma( BM2EXTRACONFIG.RemoteAccessPrice ) .. ".",
			action = function( arg1, arg2, _, ent, consoleDisplay )
				if arg1 == "install" then
					net.Start( "BM2.Command.RemoteInstall" )
					net.WriteEntity( ent )
					net.WriteBool( true )
					net.SendToServer()
					ent.remoteName = math.random( 10, 99 ) .. "." .. math.random( 100, 800 ) .. "." .. math.random( 10, 99 ) .. "." .. math.random( 100, 800 )
				elseif arg1 == "remove" then
					net.Start( "BM2.Command.RemoteInstall" )
					net.WriteEntity( ent )
					net.WriteBool( false )
					net.SendToServer()
				elseif arg1 == "setname" then
					local _string = arg2 or math.random( 10, 99 ) .. "." .. math.random( 100, 800 ) .. "." .. math.random( 10, 99 ) .. "." .. math.random( 100, 800 )
					ent.remoteName = _string
					consoleDisplay.history = consoleDisplay.history .. "Remote name changed to '" .. _string .. "'\n"
				else
					if arg1 == nil then
						consoleDisplay.history = consoleDisplay.history .. "---------------------------------------------\nType 'REMOTE INSTALL' to install the remote module. Installing costs $" .. string.Comma( BM2EXTRACONFIG.RemoteAccessPrice ) .. " and allows to bitminer to be remotely access using " .. BM2EXTRACONFIG.RemoteAccessCommand .. "\nType 'REMOTE REMOVE' to uninstall the remote module.\nType 'REMOTE SETNAME ExampleName' to change the remote name of the bitminer. The name cannot contain spaces!\n"
					else
						consoleDisplay.history = consoleDisplay.history .. "The option '" .. arg1 .. "' is not a valid option, the options are 'install', 'setname' or 'remove'\n"
					end
				end
			end
		}
	end
end

function ENT:Draw()
	self:DrawModel()
end
--PATH addons/_bitminers2ex/lua/entities/bm2_large_fuel/shared.lua:
ENT.Type = "anim"
ENT.Base = "bm2_base"
ENT.PrintName = "Large Fuel"
ENT.Spawnable = true
ENT.Category = "Bitminers"
--PATH addons/_bitminers2ex/lua/entities/bm2_solarconverter/shared.lua:
ENT.Type = "anim"
ENT.Base = "bm2_base"
ENT.PrintName = "Solar Converter"
ENT.Spawnable = true
ENT.Category = "Bitminers"
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 1, "IsOn" )
	self:NetworkVar( "Bool", 2, "ShowToMuchPowerWarning" )
	self:NetworkVar( "Bool", 3, "ShowNoPowerWarning" )
	self:NetworkVar( "Bool", 4, "ShowNoConnectedSolarWarning" )
	self:NetworkVar( "Float", 2, "PowerConsumpsion" )
	self:NetworkVar( "Float", 3, "MaxPowerConsumpsion" )
	self:NetworkVar( "Int", 1, "ConnectedPanels" )
end
--PATH addons/_doctor/lua/entities/bp_beaker/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.ang = 0

	--Genereate and set our material to the liquid color
	self.liquidMat = BLUES_PHARMA:GetPooledMaterial()
	self:SetSubMaterial(1, self.liquidMat.materialName)

	BLUES_PHARMA:SetMaterialColor(self.liquidMat.index, Color(255,255,255))

	self.lerpedLiquidAmount = 0

	self.prevStirAngle = 0

	--List of chemicals and there amount
	self.BPContents = {}

	self.targetColor = Color(255,255,255)
	self.lerpedColor = Color(255,255,255)
end

--Credit to the wiki
function ENT:DrawCircle( x, y, radius, seg, percent)
	local cir = {}

	table.insert( cir, { x = x, y = y, u = 0.5, v = 0.5 } )
	for i = 0, seg do
		local a = math.rad(180 + ( i / seg ) * (-360 * percent))
		table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) * 0.5 + 0.5, v = math.cos( a ) * 0.5 + 0.5 } )
	end

	local a = math.rad(-360 * percent)
	table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius, u = math.sin( a ) * 0.5 + 0.5, v = math.cos( a ) * 0.5 + 0.5 } )

	surface.DrawPoly( cir )
end
 
--Sets the rotation of the stirrer
function ENT:SetStirRotation(ang)
	self:ManipulateBoneAngles(2, Angle(ang,0,0))

	self:ManipulateBoneAngles(1, Angle(ang / 3,0,0))
	self:ManipulateBoneAngles(3, Angle(ang / 3,0,0))
end

--Sets the rotation of the liquid
function ENT:SetLiquidRotation(ang)
	self:ManipulateBoneAngles(1, Angle(ang,0,0))
	self:ManipulateBoneAngles(3, Angle(ang,0,0))
end

--Sets how much liquid is in the beaker (0-1)
--Makes liquid visible/invisible based on amount
function ENT:SetLiquidLevel(level)
	if level <= 0.01 then
		self:ManipulateBoneScale(1, Vector(0,0,0))
		self:ManipulateBoneScale(3, Vector(0,0,0))
	else
		self:ManipulateBoneScale(1, Vector(1,1,1))
		self:ManipulateBoneScale(3, Vector(1,1,1))
		self:ManipulateBonePosition(1, Vector(0, 0, Lerp(level, -11.8, 0)))
	end
end

--Recalculates the color for the liquid
function ENT:UpdateColor()
	local colorTable = {}
	local count = table.Count(self.BPContents)

	if count > 1 then
		for k, v in pairs(self.BPContents) do
			for i = 1, v / 50 do
				table.insert(colorTable, BLUES_PHARMA.Chemicals[k].color)
			end
		end
		self.targetColor = BLUES_PHARMA:MixColors(colorTable)
	elseif count == 1 then
		--Find starting key
		for k, v in pairs(self.BPContents) do
			self.targetColor =  BLUES_PHARMA.Chemicals[k].color
			self.lerpedColor = self.targetColor
		end
	end
end

local levelIcon = Material("blues_pharm/ui/level.png", "smooth")
local titleIcon = Material("blues_pharm/ui/title.png", "smooth")

--Draws the UI for the chemical list
function ENT:DrawChemicalList(pos, ang, titleHeaderDistance)
	cam.Start3D2D(pos, ang, 0.05)
		surface.SetMaterial(titleIcon)
		surface.SetDrawColor(Color(255, 255, 255, 255))
		surface.DrawTexturedRect(-140, -270, 280, 65 + titleHeaderDistance)

		draw.RoundedBox(0, -140, -270, 20, 275 + titleHeaderDistance, Color(43, 43, 43))

		draw.SimpleText(string.upper(BLUES_PHARMA.TRANS.Beaker), "BP_Chemical_Title",  -115, -270, Color(255, 255, 255), 0, 0)
		draw.SimpleText(BLUES_PHARMA.TRANS.Contents..":", "BP_Chemical_Amount",  -115, -240, Color(255, 255, 255, 180), 0, 0)

		local y = 30

		for k, v in pairs(self.BPContents) do
			draw.SimpleText(BLUES_PHARMA.Chemicals[k].name.." ("..v.."ml)", "BP_Chemical_Amount2",  -115, -240 + y, Color(255, 255, 255, 180), 0, 0)
		
			y = y + 30
		end

	cam.End3D2D()
end

--Draws the UI for waiting to mix and burn
function ENT:DrawWaitingMessage(pos, ang, str)
	cam.Start3D2D(pos, ang, 0.05)
		surface.SetMaterial(titleIcon)
		surface.SetDrawColor(Color(255, 255, 255, 255))
		surface.DrawTexturedRect(-140, -270, 280, 65)

		draw.RoundedBox(0, -140, -270, 20, 275, Color(43, 43, 43))

		draw.SimpleText(string.upper(BLUES_PHARMA.TRANS.Beaker).." ("..BLUES_PHARMA.Medicines[self:GetRecipe()].name..")", "BP_Chemical_Title",  -115, -270, Color(255, 255, 255), 0, 0)
		draw.SimpleText(str, "BP_Chemical_Amount",  -115, -240, Color(255, 255, 255, 180), 0, 0)
	cam.End3D2D()
end

local timerIcon = Material("blues_pharm/ui/timer_face.png", "smooth")
local timerHand = Material("blues_pharm/ui/timer_hand.png", "smooth")

--Draws the timer to show how long left while freezing
function ENT:DrawFreezingTimer()
	local ang = self:GetAngles()
	local pos = self:GetPos() + (ang:Forward() * 4) + (ang:Up() * 2)

	ang:RotateAroundAxis(ang:Right(), -90)
	ang:RotateAroundAxis(ang:Up(), 90)
	cam.Start3D2D(pos, ang, 0.03)
		surface.SetMaterial(titleIcon)
		surface.SetDrawColor(Color(255, 255, 255, 255))
		surface.DrawTexturedRectRotated(0, -75, 270, 200, -90)

		local p = math.Clamp((CurTime() - self:GetFreezeStartTime()) / self:GetFreezeTime(), 0, 1)
		local color = BLUES_PHARMA:LerpColor(Color(249, 66, 58), Color(135,206,250), p)
		color.a = 80
		surface.SetDrawColor(color)
		draw.NoTexture()
		self:DrawCircle(0, -80, 75, 32, p)

		surface.SetMaterial(timerIcon)
		surface.SetDrawColor(Color(255, 255, 255, 200))
		surface.DrawTexturedRectRotated(0,-80,150,150, 0)

		surface.SetMaterial(timerHand)
		surface.DrawTexturedRectRotated(0,-80,150,150, p * -360)

		draw.SimpleText(BLUES_PHARMA.Medicines[self:GetRecipe()].name, "BP_Chemical_Title",  0, -203, Color(255, 255, 255), 1, 0)

	cam.End3D2D()
end

function ENT:DrawTranslucent()
	self:SetSubMaterial(1, self.liquidMat.materialName)
	self:DrawModel()

	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > BLUES_PHARMA.CONFIG.Cam3D2DRenderDist  then return end

	local titleHeaderDistance = 30 * table.Count(self.BPContents)

	local ang = self:GetAngles()
	local pos = self:GetPos() + (ang:Up() * (titleHeaderDistance / 20))
	local pos2 = self:GetPos() + ang:Up()

	local ang1 = self:WorldToLocalAngles((LocalPlayer():EyePos() - pos):Angle())
	local ang2 = self:LocalToWorldAngles(Angle(0, ang1.y + 90, 90))

	--Decide what to draw
	if self:GetBeakerState() == self.States.CREATING then
		self:DrawChemicalList(pos, ang2, titleHeaderDistance)
	elseif self:GetBeakerState() == self.States.WAITING_FOR_MIX_AND_BURN then
		self:DrawWaitingMessage(pos2, ang2, BLUES_PHARMA.TRANS.RequiresCooking)
	elseif self:GetBeakerState() == self.States.WAITING_FOR_FREEZING then
		self:DrawWaitingMessage(pos2, ang2, BLUES_PHARMA.TRANS.RequiresFreezing )
	elseif self:GetBeakerState() == self.States.FREEZING then
		self:DrawFreezingTimer()
	elseif self:GetBeakerState() == self.States.READY_TO_PRESS then
		self:DrawWaitingMessage(pos2, ang2, BLUES_PHARMA.TRANS.ReadyForPressing)
	end
end

function ENT:Think() 
	--set liquid level
	self.lerpedLiquidAmount = Lerp(4 * FrameTime(), self.lerpedLiquidAmount, self:GetLiquidAmount() / 500)
	self.lerpedColor = BLUES_PHARMA:LerpColor(self.lerpedColor, self.targetColor, 4 * FrameTime())

	--Update color and liquid level
	BLUES_PHARMA:SetMaterialColor(self.liquidMat.index, self.lerpedColor)
 	self:SetLiquidLevel(self.lerpedLiquidAmount)

 	--Stiring
 	if self.ang > self:GetStirAngle() then
 		self.ang = self:GetStirAngle()
 	end
	self.ang = Lerp(1 * FrameTime(), self.ang, self:GetStirAngle())
	self:SetStirRotation(self.ang)
end

--Free up the pooled material and remove from render list
function ENT:OnRemove()
	--Reset the materials
	BLUES_PHARMA.PooledMaterials[self.liquidMat.index].material:SetTexture("$basetexture", "blues_pharm/beaker_liquid_color")
	BLUES_PHARMA.PooledMaterials[self.liquidMat.index].inUse = false
end
--PATH addons/_doctor/lua/entities/bp_chemical_acet/cl_init.lua:
include("shared.lua")

local levelIcon = Material("blues_pharm/ui/level.png", "smooth")
local titleIcon = Material("blues_pharm/ui/title.png", "smooth")

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > BLUES_PHARMA.CONFIG.Cam3D2DRenderDist  then return end
	
	local ang = self:GetAngles()
	local pos = self:GetPos() + (ang:Up() * 25)

	local ang1 = self:WorldToLocalAngles((LocalPlayer():EyePos() - pos):Angle())
	local ang2 = self:LocalToWorldAngles(Angle(0, ang1.y + 90, 90))

	cam.Start3D2D(pos, ang2, 0.05)
		surface.SetMaterial(titleIcon)
		surface.SetDrawColor(Color(255, 255, 255, 255))
		surface.DrawTexturedRect(-180, -270, 300, 65)

		draw.RoundedBox(0, -180, -270, 20, 770, Color(43, 43, 43))

		draw.SimpleText(BLUES_PHARMA.Chemicals[self.ChemicalID].name, "BP_Chemical_Title",  -155, -270, Color(255, 255, 255), 0, 0)

		surface.SetMaterial(levelIcon)
		surface.SetDrawColor(Color(255, 255, 255, 60))
		surface.DrawTexturedRect(-155, -240, 32, 32)

		draw.SimpleText(self:GetLiquidAmount().."ml", "BP_Chemical_Amount",  - 120, -240, Color(255, 255, 255, 60), 0, 0)
	cam.End3D2D()
end
--PATH addons/_doctor/lua/entities/bp_chemical_prop_acid/shared.lua:
ENT.Type = "anim"
ENT.Base = "bp_base"

ENT.PrintName = "Propionic Acid"
ENT.Spawnable = true
ENT.Category = "Blue's Pharmaceuticals"

ENT.RenderGroup = RENDERGROUP_BOTH

ENT.ChemicalID = 3


function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "LiquidAmount")
end
--PATH addons/_doctor/lua/entities/bp_chemical_sali_acid/cl_init.lua:
include("shared.lua")

local levelIcon = Material("blues_pharm/ui/level.png", "smooth")
local titleIcon = Material("blues_pharm/ui/title.png", "smooth")

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > BLUES_PHARMA.CONFIG.Cam3D2DRenderDist  then return end

	local ang = self:GetAngles()
	local pos = self:GetPos() + (ang:Up() * 10.5)

	local ang1 = self:WorldToLocalAngles((LocalPlayer():EyePos() - pos):Angle())
	local ang2 = self:LocalToWorldAngles(Angle(0, ang1.y + 90, 90))

	cam.Start3D2D(pos, ang2, 0.05)
		surface.SetMaterial(titleIcon)
		surface.SetDrawColor(Color(255, 255, 255, 255))
		surface.DrawTexturedRect(-140, -270, 280, 65)

		draw.RoundedBox(0, -140, -270, 20, 470, Color(43, 43, 43))

		draw.SimpleText(BLUES_PHARMA.Chemicals[self.ChemicalID].name, "BP_Chemical_Title",  -115, -270, Color(255, 255, 255), 0, 0)

		surface.SetMaterial(levelIcon)
		surface.SetDrawColor(Color(255, 255, 255, 60))
		surface.DrawTexturedRect(-115, -240, 32, 32)

		draw.SimpleText(self:GetLiquidAmount().."ml", "BP_Chemical_Amount",  -80, -240, Color(255, 255, 255, 60), 0, 0)
	cam.End3D2D()
end
--PATH addons/_doctor/lua/entities/bp_pill_bottle/shared.lua:
ENT.Type = "anim"
ENT.Base = "bp_base"

ENT.PrintName = "Pill Bottle"
ENT.Spawnable = false
ENT.Category = "Blue's Pharmaceuticals"

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "RecipeID")
	self:NetworkVar("Int", 1, "UsesLeft")
end
--PATH addons/____bricks_gangs/lua/entities/bricks_server_gangprinter/cl_init.lua:
include('shared.lua')
local refreshPanel = true
local backMat = Material( "bricks_server/back.png" )
local cursorMat = Material( "bricks_server/cursor.png" )
function ENT:CreateVGUI()
	if( IsValid( self.printerVGUI )  ) then
		self.printerVGUI:Remove()
	end

	if( not IsValid( self.printerVGUI )  ) then
		local outerMargin, innerSpacing = 15*0.8, 10*0.8
		
		self.printerVGUI = vgui.Create( "DPanel" )
		self.printerVGUI:SetPos( 0, 0 )
		self.printerVGUI:SetSize( BRICKS_SERVER.DEVCONFIG.GangPrinterW, BRICKS_SERVER.DEVCONFIG.GangPrinterH )
		local cursorX, cursorY = 0, 0
		self.printerVGUI.Paint = function( self2, w, h )
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 1 ) )
			surface.DrawRect( 0, 0, w, h )

			if( IsValid( self.printerVGUI.Cursor ) ) then
				local lerpPercent = RealFrameTime()*10
				cursorX = Lerp( lerpPercent, cursorX, gui.MouseX()+1 )
				cursorY = Lerp( lerpPercent, cursorY, gui.MouseY()+1 )

				self.printerVGUI.Cursor:SetPos( cursorX, cursorY )
			end
		end
		self.printerVGUI.CreateCursor = function( self2 )
			if( IsValid( self.printerVGUI.Cursor ) ) then
				self.printerVGUI.Cursor:Remove()
			end

			self.printerVGUI.Cursor = vgui.Create( "DPanel", self.printerVGUI )
			self.printerVGUI.Cursor:SetSize( 16*0.8, 16*0.8 )
			self.printerVGUI.Cursor.Paint = function( self2, w, h )
				surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
				surface.SetMaterial( cursorMat )
				surface.DrawTexturedRect( 0, 0, w, h )
			end
		end

		local topPanel = vgui.Create( "DPanel", self.printerVGUI )
		topPanel:Dock( TOP )
		topPanel:DockMargin( outerMargin, outerMargin, outerMargin, 0 )
		topPanel:SetTall( 88*0.8 )
		topPanel.Paint = function( self2, w, h ) end

		local gangTable = (BRICKS_SERVER_GANGS or {})[self:GetGangID()]
		local printerConfigTable = BRICKS_SERVER.CONFIG.GANGPRINTERS.Printers[self:GetPrinterID()] or {}

		local gangPanel = vgui.Create( "DPanel", topPanel )
		gangPanel:Dock( LEFT )
		gangPanel:SetWide( (self.printerVGUI:GetWide()-(2*outerMargin)-innerSpacing)*0.5 )
		local greyTextCol = Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 25 )
		local iconMat
		BRICKS_SERVER.Func.GetImage( (gangTable or {}).Icon or "question.png", function( mat ) 
			iconMat = mat 
		end )
		gangPanel.Paint = function( self2, w, h )
			draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )

			local iconBackSize, iconBackSpacing, iconSize = h-22, 11, ((gangTable or {}).Icon and h-22-10) or 32
			draw.RoundedBox( 8, iconBackSpacing, iconBackSpacing, iconBackSize, iconBackSize, BRICKS_SERVER.Func.GetTheme( 2 ) )

			draw.SimpleText( ((gangTable or {}).Name or "Unknown"), "BRICKS_SERVER_NoSC_Font33", iconBackSpacing+iconBackSize+20, h*0.5+2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_BOTTOM )
			draw.SimpleText( (printerConfigTable.Name or "Printer 0"), "BRICKS_SERVER_NoSC_Font24", iconBackSpacing+iconBackSize+20, h*0.5-2, greyTextCol, 0, 0 )

			if( iconMat ) then
				surface.SetDrawColor( 255, 255, 255, 255 )
				surface.SetMaterial( iconMat )
				surface.DrawTexturedRect( (h*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
			end
		end

		local healthPercents = {
			{ 0.75, Color( 182, 209, 42 ) },
			{ 0.50, Color( 209, 131, 42 ) },
			{ 0.25, Color( 209, 87, 42 ) },
			{ 0.10, Color( 209, 42, 42 ) }
		}

		local healthPanel = vgui.Create( "DPanel", topPanel )
		healthPanel:Dock( FILL )
		healthPanel:DockMargin( innerSpacing, 0, 0, 0 )
		healthPanel.Paint = function( self2, w, h )
			draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )

			draw.SimpleText( "HEALTH", "BRICKS_SERVER_NoSC_Font24", 23*0.8, 15*0.8, Color( 255, 255, 255, 25 ), 0, 0 )

			local barH, barSideMargin = 13*0.8, 23*0.8
			draw.RoundedBox( barH*0.5, barSideMargin, 45*0.8, w-(2*barSideMargin), barH, BRICKS_SERVER.Func.GetTheme( 3 ) )

			local healthPercent = math.Clamp( self:Health()/self:GetTotalHealth(), 0, 1 )

			local healthColor = Color( 70, 200, 112 )
			for k, v in ipairs( healthPercents ) do
				if( healthPercent <= v[1] ) then
					healthColor = v[2]
				else
					break
				end
			end

			draw.RoundedBox( 8, barSideMargin, 45*0.8, (w-(2*barSideMargin))*healthPercent, barH, healthColor )
		end

		-- Progress Bars
		local ProgressBars = {}
		table.insert( ProgressBars, { "MONEY", function() 
			return DarkRP.formatMoney( self:GetHolding() or 0 )
		end, function()
			return 1
		end, true } )

		table.insert( ProgressBars, { "INCOME", function() 
			return DarkRP.formatMoney( self:GetPrintAmount() ) .. " / " .. self:GetPrintTime() .. "s"
		end, function()
			if( self:GetPrintTime() <= 0 ) then return 1 end

			return (self:GetNextPrint() > 0 and 1-((self:GetNextPrint()-CurTime())/self:GetPrintTime())) or 1
		end } )

		table.insert( ProgressBars, { "TEMPERATURE", function() 
			return self:GetTemperature() .. "°C"
		end, function()
			return 1
		end, true } )

		local radius, arcWidth, mainArcWidth = 80*0.8, 2, 6
		local spacing = ((self.printerVGUI:GetWide()-(2*outerMargin))-(#ProgressBars*radius*2))/(#ProgressBars+1)

		local statisticsPanel = vgui.Create( "DPanel", self.printerVGUI )
		statisticsPanel:Dock( TOP )
		statisticsPanel:DockMargin( outerMargin, innerSpacing, outerMargin, 0 )
		statisticsPanel:SetTall( (radius+spacing)*2 )
		statisticsPanel.Paint = function( self2, w, h )
			draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )
		end

		for k, v in ipairs( ProgressBars ) do
			local progressPanel = vgui.Create( "DPanel", statisticsPanel )
			progressPanel:Dock( LEFT )
			progressPanel:DockMargin( spacing, 0, 0, 0 )
			progressPanel:SetWide( radius*2 )
			local cachedArc, oldValue, cachedArcBack
			progressPanel.Paint = function( self2, w, h )
				BRICKS_SERVER.Func.DrawCircle( w*0.5, h*0.5, w*0.5-(mainArcWidth*0.5)+(arcWidth*0.5), BRICKS_SERVER.Func.GetTheme( 2 ) )
				BRICKS_SERVER.Func.DrawCircle( w*0.5, h*0.5, (w*0.5-(mainArcWidth*0.5)+(arcWidth*0.5))-arcWidth, BRICKS_SERVER.Func.GetTheme( 0 ) )

				if( not v[4] and 360*v[3]() < 360 ) then
					local newValue = v[3]()
					if( newValue != oldValue ) then
						cachedArc = BRICKS_SERVER.Func.PrecachedArc( w*0.5, h*0.5, w*0.5, mainArcWidth, 90-(360*v[3]()), 90 )
						oldValue = newValue
					end
					
					BRICKS_SERVER.Func.DrawCachedArc( cachedArc, BRICKS_SERVER.Func.GetTheme( 5 ) )
				else
					BRICKS_SERVER.Func.DrawCircle( w*0.5, h*0.5, w*0.5, BRICKS_SERVER.Func.GetTheme( 5 ) )
					BRICKS_SERVER.Func.DrawCircle( w*0.5, h*0.5, (w*0.5)-mainArcWidth, BRICKS_SERVER.Func.GetTheme( 0 ) )
				end
				
				draw.SimpleText( v[2](), "BRICKS_SERVER_NoSC_Font24", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				draw.SimpleText( v[1], "BRICKS_SERVER_NoSC_Font24", w*0.5, h*0.5+radius+15, Color( 255, 255, 255, 25 ), TEXT_ALIGN_CENTER, 0 )
			end
		end

		local graphPanel = vgui.Create( "DPanel", self.printerVGUI )
		graphPanel:Dock( TOP )
		graphPanel:DockMargin( outerMargin, innerSpacing, outerMargin, 0 )
		graphPanel:SetTall( 333*0.8 )
		graphPanel.Paint = function( self2, w, h )
			draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )

			draw.SimpleText( "INCOME", "BRICKS_SERVER_NoSC_Font24", 23, 21, Color( 255, 255, 255, 25 ), 0, 0 )
		end

		local income, lineDistance
		function self.printerVGUI.RefreshIncomeGraph()
			income = self.IncomeTrackTable or {}
			lineDistance = 30

			for k, v in ipairs( income ) do
				surface.SetFont( "BRICKS_SERVER_NoSC_Font17" )
				local displayValue = math.ceil( (v >= 100 and v/1000) or v )
				local textX, textY = surface.GetTextSize( ((v >= 100 and displayValue .. "k") or displayValue) )
				local newLineDistance = textX+20
	
				if( newLineDistance > lineDistance ) then
					lineDistance = newLineDistance
				end
			end
		end
		self.printerVGUI.RefreshIncomeGraph()

		local lineCount, circleRadius = 11, 4
		local graphLinesPanel = vgui.Create( "DPanel", graphPanel )
		graphLinesPanel:Dock( FILL )
		graphLinesPanel:DockMargin( 25, 65, 25, 0 )
		graphLinesPanel.Paint = function( self2, w, h )
			local sortedIncome = table.Copy( income )
			table.sort( sortedIncome, function(a, b) return a < b end )
			local lowestValue = sortedIncome[1] or 0
			local highestValue = sortedIncome[#sortedIncome] or 0

			local lineDifference = (highestValue-lowestValue)/(lineCount-1)
			local lowerBound = lowestValue
			local upperBound = highestValue

			for i = 1, lineCount do
				local lineValue = lowerBound+((i-1)*lineDifference)
				
				surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
				surface.DrawRect( lineDistance, (i-1)*(h/lineCount), w-lineDistance, 1 )

				local displayValue = math.ceil( (lineValue >= 100 and lineValue/1000) or lineValue )
				draw.SimpleText( ((lineValue >= 100 and displayValue .. "k") or displayValue), "BRICKS_SERVER_NoSC_Font17", lineDistance*0.5, h-(i*(h/lineCount))-1, BRICKS_SERVER.Func.GetTheme( 5 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			end

			local lineTotalH = h-(h/lineCount)
			local previousCircleX, previousCircleY
			for k, v in ipairs( income ) do
				local circleX, circleY = lineDistance+(((w-lineDistance)/(self.IncomeTrackAmount-1))*(k-1)), lineTotalH-(((v-lowerBound)/(upperBound-lowerBound))*lineTotalH)

				draw.NoTexture()
				surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 5 ) )
				BRICKS_SERVER.Func.DrawCircle( circleX, circleY, circleRadius, 45 )	
					
				if( previousCircleX and previousCircleY ) then
					surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 5 ) )
					surface.DrawLine( previousCircleX, previousCircleY, circleX, circleY )
				end

				previousCircleX, previousCircleY = circleX, circleY
			end

			for k, v in ipairs( income ) do
				local circleX, circleY = lineDistance+(((w-lineDistance)/(self.IncomeTrackAmount-1))*(k-1)), lineTotalH-(((v-lowerBound)/(upperBound-lowerBound))*lineTotalH)

				draw.NoTexture()
				surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
				BRICKS_SERVER.Func.DrawCircle( circleX, circleY, circleRadius-2, 45 )	
			end
		end

		local bottomPanel = vgui.Create( "DPanel", self.printerVGUI )
		bottomPanel:Dock( FILL )
		bottomPanel.Paint = function( self2, w, h ) end

		local bottomLeftPanel = vgui.Create( "DPanel", bottomPanel )
		bottomLeftPanel:Dock( LEFT )
		bottomLeftPanel:DockMargin( outerMargin, innerSpacing, 0, outerMargin )
		bottomLeftPanel:SetWide( (self.printerVGUI:GetWide()-(2*outerMargin)-innerSpacing)*0.5 )
		bottomLeftPanel.Paint = function( self2, w, h )
			draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )

			draw.SimpleText( "HISTORY", "BRICKS_SERVER_NoSC_Font24", 23, 21, Color( 255, 255, 255, 25 ), 0, 0 )
		end

		local bottomRightPanel = vgui.Create( "DPanel", bottomPanel )
		bottomRightPanel:Dock( RIGHT )
		bottomRightPanel:DockMargin( 0, innerSpacing, outerMargin, outerMargin )
		bottomRightPanel:SetWide( (self.printerVGUI:GetWide()-(2*outerMargin)-innerSpacing)*0.5 )
		bottomRightPanel.Paint = function( self2, w, h ) end

		local buttonBack = vgui.Create( "DPanel", bottomRightPanel )
		buttonBack:Dock( TOP )
		buttonBack:SetTall( 46*0.8 )
		buttonBack.Paint = function( self2, w, h ) end

		local toggleButton = vgui.Create( "DButton", buttonBack )
		toggleButton:Dock( RIGHT )
		toggleButton:DockMargin( innerSpacing, 0, 0, 0 )
		toggleButton:SetWide( 150*0.8 )
		toggleButton:SetText( "" )
		toggleButton.Paint = function( self2, w, h )
			draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )

			local buttonColor = Color( 70, 200, 112 )
			local poly = {
				{ x = w*0.5-10, y = h },
				{ x = w*0.5-10, y = 0 },
				{ x = w*0.5+10, y = 0 }
			}

			if( self:GetStatus() ) then
				draw.RoundedBoxEx( 8, 0, 0, w*0.5-10, h, buttonColor, true, false, true, false )
			else
				buttonColor = Color( 218, 51, 56 )
				draw.RoundedBoxEx( 8, w*0.5+10, 0, w*0.5-10, h, buttonColor, false, true, false, true )

				poly = {
					{ x = w*0.5-10, y = h },
					{ x = w*0.5+10, y = 0 },
					{ x = w*0.5+10, y = h }
				}
			end

			surface.SetDrawColor( buttonColor )
			draw.NoTexture()
			surface.DrawPoly( poly )

			draw.SimpleText( "ON", "BRICKS_SERVER_NoSC_Font20", w/4, h*0.5, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			draw.SimpleText( "OFF", "BRICKS_SERVER_NoSC_Font20", w/4*3, h*0.5, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		toggleButton.DoClick = function()
			net.Start( "BRS.Net.GangPrinterToggle" )
				net.WriteEntity( self )
			net.SendToServer()
		end

		local withdrawButton = vgui.Create( "DButton", buttonBack )
		withdrawButton:Dock( FILL )
		withdrawButton:SetText( "" )
		withdrawButton.Paint = function( self2, w, h )
			draw.RoundedBox( 8, 0, 0, w, h, Color( 218, 51, 56 ) )

			draw.SimpleText( "WITHDRAW MONEY", "BRICKS_SERVER_NoSC_Font20", w*0.5, h*0.5, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		withdrawButton.DoClick = function()
			net.Start( "BRS.Net.GangPrinterWithdraw" )
				net.WriteEntity( self )
			net.SendToServer()
		end

		local menuPanel = vgui.Create( "DPanel", bottomRightPanel )
		menuPanel:Dock( FILL )
		menuPanel:DockMargin( 0, innerSpacing, 0, 0 )
		menuPanel:DockPadding( 0, 21+40, 0, 0 )
		menuPanel.Paint = function( self2, w, h )
			draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )

			draw.SimpleText( "MENU", "BRICKS_SERVER_NoSC_Font24", 23, 21, Color( 255, 255, 255, 25 ), 0, 0 )
		end

		local pages = {
			{
				Name = "UPGRADES",
				Icon = Material( "bricks_server/printer_upgrade.png" ),
				Element = "bricks_server_gangprinter_upgrades"
			}
		}

		for k, v in ipairs( pages ) do
			surface.SetFont( "BRICKS_SERVER_NoSC_Font20" )
			local textX, textY = surface.GetTextSize( v.Name )

			local button = vgui.Create( "DButton", menuPanel )
			button:Dock( TOP )
			button:DockMargin( 20, 0, 20, 12 )
			button:SetTall( 40*0.8 )
			button:SetText( "" )
			local Alpha = 0
			button.Paint = function( self2, w, h ) 
				if( self2.Hovered ) then
					Alpha = math.Clamp( Alpha+10, 0, 255 )
				else
					Alpha = math.Clamp( Alpha-10, 0, 255 )
				end
			
				draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

				surface.SetAlphaMultiplier( Alpha/255 )
				draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
				surface.SetAlphaMultiplier( 1 )

				local iconSize = 16
				surface.SetDrawColor( 255, 255, 255, 50 )
				surface.SetMaterial( v.Icon )
				surface.DrawTexturedRect( (w*0.5)-(textX*0.5)-5-iconSize, (h*0.5)-(iconSize*0.5), iconSize, iconSize )

				draw.SimpleText( v.Name, "BRICKS_SERVER_NoSC_Font20", w*0.5, h*0.5, Color( 255, 255, 255, 50 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			end
			button.DoClick = function()
				if( IsValid( self.printerVGUI.printerPage ) ) then
					self.printerVGUI.printerPage:Remove()
				end

				surface.SetFont( "BRICKS_SERVER_NoSC_Font40" )
				local textX, textY = surface.GetTextSize( v.Name )

				self.printerVGUI.printerPage = vgui.Create( "DPanel", self.printerVGUI )
				self.printerVGUI.printerPage:SetSize( self.printerVGUI:GetWide(), self.printerVGUI:GetTall() )
				self.printerVGUI.printerPage:SetPos( 0, 0 )
				self.printerVGUI.printerPage.Paint = function( self2, w, h )
					surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 1 ) )
					surface.DrawRect( 0, 0, w, h )

					draw.RoundedBox( 8, 12, 12, 75+textX+36, 75, BRICKS_SERVER.Func.GetTheme( 0 ) )
		
					draw.SimpleText( v.Name, "BRICKS_SERVER_NoSC_Font40", 24+51+25, 12+(75*0.5)-2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
				end

				local backButton = vgui.Create( "DButton", self.printerVGUI.printerPage )
				backButton:SetSize( 51, 51 )
				backButton:SetPos( 24, 24 )
				backButton:SetText( "" )
				local Alpha = 0
				backButton.Paint = function( self2, w, h ) 
					if( self2.Hovered ) then
						Alpha = math.Clamp( Alpha+10, 0, 255 )
					else
						Alpha = math.Clamp( Alpha-10, 0, 255 )
					end
				
					draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
	
					surface.SetAlphaMultiplier( Alpha/255 )
					draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
					surface.SetAlphaMultiplier( 1 )
	
					surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
					surface.SetMaterial( backMat )
					local iconSize = 24
					surface.DrawTexturedRect( (w*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
				end
				backButton.DoClick = function()
					self.printerVGUI.printerPage:Remove()
				end

				local pageContent = vgui.Create( v.Element, self.printerVGUI.printerPage )
				pageContent:Dock( FILL )
				pageContent:DockMargin( 0, 12+75, 0, 0 )
				pageContent:FillPanel( self )

				self.printerVGUI.CreateCursor()
			end
		end

		self.printerVGUI.CreateCursor()
	end
end

function ENT:OnRemove()
	if( IsValid( self.printerVGUI ) ) then
		self.printerVGUI:Remove()
	end
end

function ENT:Draw()
	self:DrawModel()

	local Distance = LocalPlayer():GetPos():DistToSqr( self:GetPos() )

	if( Distance >= BRICKS_SERVER.CONFIG.GENERAL["3D2D Display Distance"] ) then return end

	if( not IsValid( self.printerVGUI ) or refreshPanel ) then
		self:CreateVGUI()
		refreshPanel = false
	end

	local Pos = self:GetPos()
	local Ang = self:GetAngles()

	//TOP PANEL
	Ang:RotateAroundAxis(Ang:Up(), 90)
	Ang:RotateAroundAxis(Ang:Up(), 90)
	Ang:RotateAroundAxis(Ang:Forward(), 90)
	Ang:RotateAroundAxis(Ang:Right(), 270)
	Ang:RotateAroundAxis(Ang:Forward(), -5.6)

	vgui.Start3D2D( Pos+(Ang:Up() * 30.55)-(Ang:Forward()*11.35)-(Ang:Right()*45.03), Ang, 0.03/0.8 )
		self.printerVGUI:Paint3D2D()
	vgui.End3D2D()

	if( not self:HasRequestTimer() ) then
		self:CreateRequestTimer()
	end
end

function ENT:HasRequestTimer()
	return timer.Exists( tostring( self ) .. "_GangPrinterRequestTimer" )
end

function ENT:CreateRequestTimer()
	net.Start( "BRS.Net.GangPrinterIncomeTrackRequest" )
		net.WriteEntity( self )
	net.SendToServer()

	local timerID = tostring( self ) .. "_GangPrinterRequestTimer"
	timer.Create( timerID, (BRICKS_SERVER.CONFIG.GANGPRINTERS["Income Update Time"] or 10), 0, function()
		if( not IsValid( self ) or not IsValid( LocalPlayer() ) or LocalPlayer():GetPos():DistToSqr( self:GetPos() ) >= BRICKS_SERVER.CONFIG.GENERAL["3D2D Display Distance"] ) then 
			timer.Remove( timerID )
			return 
		end

		net.Start( "BRS.Net.GangPrinterIncomeTrackRequest" )
			net.WriteEntity( self )
		net.SendToServer()
	end )
end

net.Receive( "BRS.Net.GangPrinterIncomeTrackSend", function()
	local printerEntity = net.ReadEntity()

	if( not IsValid( printerEntity ) ) then return end

	printerEntity.IncomeTrackTable = net.ReadTable() or {}

	if( IsValid( printerEntity.printerVGUI  ) and printerEntity.printerVGUI.RefreshIncomeGraph ) then
		printerEntity.printerVGUI.RefreshIncomeGraph()
	end
end )
--PATH addons/_ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )
--------------------- BALLISTIC SHIELDS V1.1.9 -------------------------
---- CONFIG ----
-- AVALAIBLE LANGUAGES - English, German, French, Danish, Turkish, Ukrainian
bshields.config.language = "Ukrainian"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 10
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 10
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 50
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 20
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 30
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 1
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = true
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false
-- REMOVE DEPLOYED SHIELDS ON JOB CHANGE
bshields.config.removeonjobchange = true
-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---
-- HEAVY SHIELD
bshields.config.hShieldTexture = ""
-- RIOT SHIELD
bshields.config.rShieldTexture = ""
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = ""
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---
-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = false
--PATH addons/_drones/lua/entities/dronesrewrite_ai_healer/cl_init.lua:
include("shared.lua")
--PATH addons/_drones/lua/entities/dronesrewrite_camera/cl_init.lua:
include("shared.lua")
--PATH addons/_drones/lua/entities/dronesrewrite_capacitor/cl_init.lua:
include("shared.lua")

--PATH addons/_drones/lua/entities/dronesrewrite_capacitor/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "Capacitor"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "CAP"

ENT.HUD_hudName = "White Box"

ENT.Model = "models/dronesrewrite/nanodr/nano.mdl"

ENT.Weight = 20

ENT.DoExplosionEffect = "splode_drone_sparks"
ENT.ExplosionForce = 0
ENT.ExplosionAngForce = 0

ENT.Speed = 300
ENT.UpSpeed = 1500
ENT.RotateSpeed = 6
ENT.AngOffset = 2
ENT.NoiseCoefficient = 0.3
ENT.Alignment = 3

ENT.Fuel = 5
ENT.MaxFuel = 5
ENT.FuelReduction = 0.004

/*ENT.Damping = 0.7
ENT.AngDamping = 0
ENT.AngPitchDamping = 1
ENT.AngYawDamping = 0.5
ENT.AngRollDamping = 1*/

ENT.FirstPersonCam_pos = Vector(2, 0, 0)
ENT.ThirdPersonCam_distance = 30
ENT.RenderCam = false

ENT.AllowYawRestrictions = true
ENT.YawMin = -60
ENT.YawMax = 60

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.AllowPitchRestrictions = false
ENT.UseFlashlight = false

ENT.HealthAmount = 25
ENT.DefaultHealth = 25

ENT.Sounds = {
	ExplosionSound = {
		Name = "ambient/energy/spark3.wav",
		Level = 80,
		Pitch = 150
	}
}

ENT.NoPropellers = true
ENT.Propellers = {
	Model = "models/props_junk/PopCan01a.mdl",
	Info = { Vector(0, 0, 0) }
}

ENT.Weapons = { }

ENT.Modules = DRONES_REWRITE.GetBaseModules()

ENT.AI_AirZ = -50
ENT.AI_DistanceEnemy = 5
--PATH addons/_drones/lua/entities/dronesrewrite_coredr/cl_init.lua:
include("shared.lua")

--PATH addons/_drones/lua/entities/dronesrewrite_dronebox.lua:
AddCSLuaFile()

ENT.Base = "base_anim"
ENT.Type = "anim"
ENT.PrintName = "Gift Box"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite Tools"

if SERVER then
	function ENT:SpawnFunction(ply, tr, class)
		if not tr.Hit then return end

		local pos = tr.HitPos + tr.HitNormal * 16

		local ent = ents.Create(class)
		ent:SetPos(pos)
		ent:SetAngles(Angle(0, (ply:GetPos() - tr.HitPos):Angle().y + 90, 0))
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:Initialize()
	    self:SetModel("models/dronesrewrite/dronebox/dronebox.mdl")
	    self:SetMoveType(MOVETYPE_VPHYSICS)
	    self:SetSolid(SOLID_VPHYSICS)
	    self:PhysicsInit(SOLID_VPHYSICS)
	    self:SetUseType(SIMPLE_USE)

	    local phys = self:GetPhysicsObject()
	    if IsValid(phys) then phys:Wake() end
	end

	function ENT:Use(activator, caller)
		if not activator:IsPlayer() then return end

		local center = self:LocalToWorld(self:OBBCenter())

		local ef = EffectData()
		ef:SetOrigin(center)
		util.Effect("dronesrewrite_papers", ef)

		local ang = self:GetAngles()
		ang:RotateAroundAxis(ang:Forward(), 90)
		ang:RotateAroundAxis(ang:Up(), -90)

		local e = ents.Create("dronesrewrite_camera")
		e:SetPos(center)
		e:SetAngles(ang)
		e:Spawn()
		e:Activate()

		e.Owner = activator

		e.EnginePower = 0
		e:SetEnabled(false)

		e:AddHook("DriverSet", "sethint", function(ply)
			if not e.PrintHint then
				if IsValid(ply) then ply:ChatPrint("To enable me click [G] key") end
				e.PrintHint = true
			end
		end)

		undo.Create("Gift Drone")
			undo.AddEntity(e)
			undo.SetPlayer(activator)
		undo.Finish()

		activator:Give("weapon_drr_remote")
		activator:SelectWeapon("weapon_drr_remote")

		self:EmitSound("drones/paper1.wav", 80)
		self:Remove()
	end

	function ENT:OnTakeDamage(dmg)
		self:TakePhysicsDamage(dmg)
	end

	function ENT:PhysicsCollide(data, phys)
		if data.DeltaTime > 0.2 then
			self:EmitSound("physics/cardboard/cardboard_box_impact_hard" .. math.random(1, 7) .. ".wav")
		end
	end
else
	function ENT:Draw()
		self:DrawModel()
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_fuelstation/shared.lua:
ENT.Base = "base_anim"
ENT.Type = "anim"
ENT.PrintName = "Gas Station"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite Tools"

--PATH addons/_drones/lua/entities/dronesrewrite_healer/cl_init.lua:
include("shared.lua")
--PATH addons/_drones/lua/entities/dronesrewrite_plasmadr/cl_init.lua:
include("shared.lua")
--PATH addons/_drones/lua/entities/dronesrewrite_projectile.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

if SERVER then
	function ENT:Initialize()
	    self:SetModel("models/dronesrewrite/artillery_ammo_proj/artillery_ammo_proj.mdl")
	    self:SetMoveType(MOVETYPE_VPHYSICS)
	    self:SetSolid(SOLID_VPHYSICS)
	    self:PhysicsInit(SOLID_VPHYSICS)
		
	    self:StartMotionController()

	    local phys = self:GetPhysicsObject()

		phys:EnableDrag(false)
	    if IsValid(phys) then phys:Wake() end
	end

	function ENT:PhysicsSimulate(phys, dt)
		local force = Vector(0, 0, 0)
		local angForce = Vector(0, 0, 0)

		force = force + Vector(0, 0, GetConVarNumber("sv_gravity") * 20)

		force = force * dt
		angForce = angForce * dt

		return angForce, force, SIM_GLOBAL_ACCELERATION
	end

	function ENT:PhysicsCollide(data,physobj)
		//ParticleEffect("splode_fire", self:GetPos(), Angle(0, 0, 0))
		
		ParticleEffect("splode_big_main", self:GetPos(), Angle(0, 0, 0))		
		
		self:EmitSound("BaseExplosionEffect.Sound", 500, 100)

		local tr = util.TraceLine({
			start = self:GetPos(),
			endpos = self:GetPos() + self:GetForward() * 1024,
			filter = self,
			mask = MASK_SOLID_BRUSHONLY
		})

		util.Decal("DrrBigExpo", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)
		util.BlastDamage(self, IsValid(self:GetOwner()) and self:GetOwner() or self, self:GetPos(), 300, math.random(450,600))
		
		self:Remove()
	end

	function ENT:OnRemove()
		self:StopMotionController()
	end
else
	function ENT:Draw()
		self:DrawModel()
	end
end


--PATH addons/_drones/lua/entities/dronesrewrite_racerdr/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "Racing Drone"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "RD"

ENT.Model = "models/dronesrewrite/racerdr/racerdr.mdl"

ENT.HUD_hudName = "Camera"
ENT.OverlayName = "No Overlay"

ENT.FirstPersonCam_pos = Vector(9, 0, 2)
ENT.ThirdPersonCam_distance = 50
ENT.RenderCam = false

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.PitchMin = -30
ENT.PitchMax = 30

ENT.AllowYawRestrictions = true
ENT.YawMin = -50
ENT.YawMax = 50

ENT.Sounds = {
	PropellerSound = {
		Name = "drones/ardr.wav",
		Pitch = 90,
		Level = 65,
		Volume = 0.2,
		PitchCoef = 0.015
	},

	ExplosionSound = {
		Name = "ambient/energy/spark3.wav",
		Level = 100,
		Pitch = 150
	}
}

ENT.DoExplosionEffect = "splode_drone_sparks"

ENT.Weight = 30

ENT.AngOffset = 4
ENT.PitchOffset = 4

ENT.Fuel = 40
ENT.MaxFuel = 40

ENT.NoiseCoefficient = 0
ENT.NoiseCoefficientAng = 0.4
ENT.NoiseCoefficientPos = 0.2

--[[ENT.Speed = 900
ENT.UpSpeed = 4700
ENT.SprintCoefficient = 3
ENT.RotateSpeed = 6]]--

ENT.Alignment = 0.3
ENT.AngOffset = 3

ENT.RotateSpeed = 6
ENT.UpSpeed = 5000
ENT.Speed = 1000

ENT.SprintCoefficient = 2

ENT.AngYawDamping = 0.5

ENT.HealthAmount = 15
ENT.DefaultHealth = 15

ENT.Propellers = {
	Damage = 1,
	Scale = 0.8,
	Health = 20,
	HitRange = 9,
	Model = "models/dronesrewrite/flower_propeller/flower_propeller.mdl",

	HitPitch = 255,
	HitLevel = 60,
	RandomHitSounds = { "physics/metal/metal_box_impact_bullet2.wav", "physics/metal/metal_box_impact_bullet2.wav", "physics/metal/metal_box_impact_bullet2.wav" },
	RandomLoseSounds = { "physics/glass/glass_cup_break1.wav", "physics/glass/glass_cup_break2.wav" },

	LosePitch = 255,
	LoseLevel = 65,

	Info = {
		Vector(4.5, 7.2, 1.5),
		Vector(-5.5, -7.2, 1.5),
		Vector(-5.5, 7.2, 1.5),
		Vector(4.5, -7.2, 1.5)
	}
}

ENT.UseFlashlight = false
ENT.UseNightVision = false

//ENT.Weapons = { ["Camera"] = { Name = "Camera" } }

ENT.Modules = DRONES_REWRITE.GetBaseModules()
DRONES_REWRITE.CopyModule(ENT.Modules, "Nightvision")
DRONES_REWRITE.CopyModule(ENT.Modules, "Flashlight")

--PATH addons/_drones/lua/entities/dronesrewrite_rocket.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

local rSound = Sound("Missile.Accelerate")

if SERVER then
	function ENT:Initialize()
	    self:SetModel("models/dronesrewrite/rocket_small/rocket_small.mdl")
	    self:SetMoveType(MOVETYPE_VPHYSICS)
	    self:SetSolid(SOLID_VPHYSICS)
	    self:PhysicsInit(SOLID_VPHYSICS)

	    local phys = self:GetPhysicsObject()

		phys:EnableDrag(false)
	    if IsValid(phys) then phys:Wake() end
		
	    self.Entity:EmitSound(rSound, 100, 100)
	end

	function ENT:Think()
		local ef = EffectData()
		ef:SetOrigin(self:GetPos() - self:GetForward() * 4)
		ef:SetStart(self:GetPos() - self:GetForward() * 1000)
		ef:SetScale(0.5)
		util.Effect("dronesrewrite_rocketfly", ef, true, true)      

		local phys = self:GetPhysicsObject()
		phys:ApplyForceCenter(self:GetForward() * 1000)

		phys:AddAngleVelocity(VectorRand() * math.sin(CurTime() * 3) * 0.14)

		self:NextThink(CurTime())
		return true
	end

	function ENT:PhysicsCollide(data,physobj)
		ParticleEffect("splode_fire", self:GetPos(), Angle(0, 0, 0))
		
		self:EmitSound("BaseExplosionEffect.Sound", 500, 100)

		local tr = util.TraceLine({
			start = self:GetPos(),
			endpos = self:GetPos() + self:GetForward() * 1024,
			filter = self,
			mask = MASK_SOLID_BRUSHONLY
		})

		util.Decal("DrrBigExpo", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)
		util.BlastDamage(self, IsValid(self:GetOwner()) and self:GetOwner() or self, self:GetPos(), 300, math.random(80,120))
		
		self:Remove()
	end

	function ENT:OnRemove()
		self.Entity:StopSound(rSound)
	end
else
	function ENT:Draw()
		self:DrawModel()
	end
end


--PATH addons/_drones/lua/entities/dronesrewrite_spy/cl_init.lua:
include("shared.lua")

--PATH addons/_drones/lua/entities/dronesrewrite_stormtrooper/cl_init.lua:
include("shared.lua")
--PATH addons/_drones/lua/entities/dronesrewrite_walkart/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.DrrBaseType = "walker"
ENT.Type = "anim"
ENT.PrintName = "Walking Tank"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "WT"

ENT.Model = "models/dronesrewrite/walkerart/walkerart.mdl"

ENT.SpawnHeight = 64
ENT.Weight = 3000

ENT.OverlayName = "Drones 2"
ENT.HUD_hudName = "White Box"

ENT.FirstPersonCam_pos = Vector(47, 0, 0)
ENT.ThirdPersonCam_pos = Vector(0, 0, 100)
ENT.ThirdPersonCam_distance = 250
ENT.RenderCam = false

ENT.Speed = 50000
ENT.SprintCoefficient = 1
ENT.RotateSpeed = 60
ENT.Hover = 60
ENT.PitchOffset = 0
ENT.AngOffset = 0

ENT.HackValue = 4

ENT.ExplosionForce = 2
ENT.ExplosionAngForce = 0.1
ENT.DoExplosionEffect = "ssplode_big_drone_main"

ENT.AllowPitchRestrictions = true
ENT.PitchMin = -90
ENT.PitchMax = 50

ENT.AllowYawRestrictions = true
ENT.YawMin = -140
ENT.YawMax = 140

ENT.Fuel = 700
ENT.MaxFuel = 700
ENT.FuelReduction = 8

ENT.NoiseCoefficient = 0
ENT.NoiseCoefficientAng = 6
ENT.NoiseCoefficientPos = 0

ENT.WaitForSound = 0.28

ENT.Slip = 100
ENT.AngSlip = 0.1

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()
ENT.KeysFuncs.Physics["Up"] = function(self)
end

ENT.KeysFuncs.Physics["Down"] = function(self)
end

ENT.HealthAmount = 1500
ENT.DefaultHealth = 1500

ENT.Sounds = {
	ExplosionSound = {
		Name = "ambient/explosions/explode_1.wav",
		Level = 82
	},

	FootSound = {
		Sounds = {
			"physics/flesh/flesh_strider_impact_bullet1.wav",
			"physics/flesh/flesh_strider_impact_bullet2.wav",
			--"physics/flesh/flesh_strider_impact_bullet3.wav"
		},

		Pitch = 60,
		Volume = 81
	}
}

ENT.Corners = {
	Vector(-50, -44, 0),
	Vector(-50, 44, 0),
	Vector(44, 44, 0),
	Vector(44, -44, 0)
}

ENT.Legs = {
	["Rmain"] = { --Back
		model = "models/dronesrewrite/legs/legartp1.mdl", 
		rel = nil, 
		pos = Vector(-48, -64, -3), 
		ang = Angle(0, 135, 0), 
		scale = Vector(1, 1, 1), 
		pitch = 0,
		yaw = 1 
	},

	["Lmain"] = { --Forward
		model = "models/dronesrewrite/legs/legartp1.mdl", 
		rel = nil, 
		pos = Vector(48, -64, -3), 
		ang = Angle(0, 45, 0), 
		scale = Vector(1, 1, 1), 
		pitch = 0, 
		yaw = -1  
	},

	["Bmain"] = { --Back
		model = "models/dronesrewrite/legs/legartp1.mdl",
		rel = nil, 
		pos = Vector(-48, 64, -3), 
		ang = Angle(0, -135, 0), 
		scale = Vector(1, 1, 1), 
		pitch = 0, 
		yaw = 1
	},

	["Wmain"] = { --Forward
		model = "models/dronesrewrite/legs/legartp1.mdl", 
		rel = nil, 
		pos = Vector(48, 64, -3), 
		ang = Angle(0, -45, 0), 
		scale = Vector(1, 1, 1), 
		pitch = 0, 
		yaw = -1
	},

	["_1"] = {
		model = "models/dronesrewrite/legs/legartp2.mdl", 
		rel = "Rmain", 
		pos = Vector(53, 0, 11), 
		ang = Angle(0, 0, 0), 
		scale = Vector(1, 1, 1), 
		pitch = -1, 
		yaw = 0
	},

	["_2"] = {
		model = "models/dronesrewrite/legs/legartp2.mdl", 
		rel = "Lmain", 
		pos = Vector(53, 0, 11), 
		ang = Angle(0, 0, 0), 
		scale = Vector(1, 1, 1), 
		pitch = 1, 
		yaw = 0
	},

	["_3"] = {
		model = "models/dronesrewrite/legs/legartp2.mdl", 
		rel = "Bmain", 
		pos = Vector(53, 0, 11), 
		ang = Angle(0, 0, 0), 
		scale = Vector(1, 1, 1), 
		pitch = 1, 
		yaw = 0
	},

	["_4"] = {
		model = "models/dronesrewrite/legs/legartp2.mdl", 
		rel = "Wmain", 
		pos = Vector(53, 0, 11), 
		ang = Angle(0, 0, 0), 
		scale = Vector(1, 1, 1), 
		pitch = -1, 
		yaw = 0
	}
}

ENT.Attachments = {
	["MissileLRight"] = {
		Pos = Vector(-15, -66, 22.5)
	},

	["MissileLLeft"] = {
		Pos = Vector(-15, 66, 22.5)
	},

	["MinigunRight"] = {
		Pos = Vector(48, -18, -16)
	},

	["MinigunLeft"] = {
		Pos = Vector(48, 18, -16)
	}
}

ENT.Weapons = {
	["Missile Battery"] = {
		Name = "Missile Battery",
		Sync = {
			["Missile Battery 2"] = { fire1 = "fire1" }
		},
		Attachment = "MissileLRight"
	},

	["Missile Battery 2"] = {
		Name = "Missile Battery",
		Select = false,
		Attachment = "MissileLLeft"
	},

	["Heavy Miniguns"] = {
		Name = "Heavy Minigun",
		Sync = {
			["Minigun 2"] = { fire1 = "fire1" }
		},
		Attachment = "MinigunRight"
	},

	["Minigun 2"] = {
		Name = "Heavy Minigun",
		Select = false,
		Attachment = "MinigunLeft"
	}
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/__main/lua/entities/durgz_alcohol/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.PrintName = "Alcohol"
ENT.Nicknames = {
    "booze", "beer", "alcohol", "Bud Light", "Coors Light", "Miller Light",
    "shitty light beer", "frat juice", "water"
}
ENT.OverdosePhrase = {"drank too much", "got poisoned on", "discovered that the turnup is real while drinking", "YOLOed on", "Philliped"}
ENT.Author = "Phillip Penrose"
ENT.Category = "Drugs"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Information	 = "Drink your troubles away... Just kidding, this is light beer. You won't even get a buzz." 

ENT.TRANSITION_TIME = 6

if(CLIENT)then
	
	local TRANSITION_TIME = ENT.TRANSITION_TIME; --transition effect from sober to high, high to sober, in seconds how long it will take etc.
	local HIGH_INTENSITY = 1; --1 is max, 0 is nothing at all
	
	
	local function DoAlcohol()
		if(!DURGZ_LOST_VIRGINITY)then return; end
		--self:SetNWFloat( "SprintSpeed"
		local pl = LocalPlayer();
		
		
		
		if( pl:GetNWFloat("durgz_alcohol_high_start") && pl:GetNWFloat("durgz_alcohol_high_end") > CurTime() )then
		
			if( pl:GetNWFloat("durgz_alcohol_high_start") + TRANSITION_TIME > CurTime() )then
			
				local s = pl:GetNWFloat("durgz_alcohol_high_start");
				local e = s + TRANSITION_TIME;
				local c = CurTime();
				local pf = (c-s) / (e-s);
				
				DrawMotionBlur( 0.03, pf*HIGH_INTENSITY, 0);
				
			elseif( pl:GetNWFloat("durgz_alcohol_high_end") - TRANSITION_TIME < CurTime() )then
			
				local e = pl:GetNWFloat("durgz_alcohol_high_end");
				local s = e - TRANSITION_TIME;
				local c = CurTime();
				local pf = 1 - (c-s) / (e-s);
				
				DrawMotionBlur( 0.03, pf*HIGH_INTENSITY, 0);
				
			else
				
				DrawMotionBlur( 0.03, HIGH_INTENSITY, 0);
				
			end
			
			
		end
	end
	hook.Add("RenderScreenspaceEffects", "durgz_alcohol_high", DoAlcohol)
	
end

--PATH addons/_eml/lua/entities/eml_buyer_text/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFontAddicted", {
	font = "Arial",
	size = 35,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	

end;

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ang = self:GetAngles()

	
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 120);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < self:GetNWInt("distance") then
		cam.Start3D2D(pos + ang:Up(), Angle(0, LocalPlayer():EyeAngles().y-90, 90), 0.25)
				draw.SimpleTextOutlined(EML_Meth_Salesman_Name, "methFontAddicted", 1, -200, EML_Meth_Salesman_Name_Color, TEXT_ALIGN_CENTER, TEXT_ALIGN_LEFT, 1, Color(25, 25, 25, 100));			
		cam.End3D2D()	
	end;
end;

-- maxAmount = 60
-- amount = x


--PATH addons/_eml/lua/entities/eml_gas/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFont1", {
	font = "Arial",
	size = 15,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	
	self.emitTime = CurTime();
	self.gasPlace = ParticleEmitter(self:GetPos());
end;

function ENT:Think()

	local gasPos = self:GetPos()+(self:GetUp()*28), self:GetPos()+(self:GetUp()*42);
	if (self:GetNWInt("amount")>0) then
		if (self.emitTime < CurTime()) then
			if (self:GetNWBool("open")) then
				local smoke = self.gasPlace:Add("particle/smokesprites_000"..math.random(1,9), gasPos);
				smoke:SetVelocity(self:GetUp()*128);
				smoke:SetDieTime(math.Rand(0.6, 1.3));
				smoke:SetStartAlpha(math.Rand(150, 200));
				smoke:SetEndAlpha(0);
				smoke:SetStartSize(math.random(0, 5));
				smoke:SetEndSize(math.random(16, 18));
				smoke:SetRoll(math.Rand(180, 480));
				smoke:SetRollDelta(math.Rand(-3, 3));
				smoke:SetColor(255, 255, 255);
				smoke:SetGravity(Vector(0, 0, 10));
				smoke:SetAirResistance(256);
				self.emitTime = CurTime() + .1;
			end;
		end;			
	end;
end;

local laser = Material("cable/cable")
function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ang = self:GetAngles()

	ang:RotateAroundAxis(ang:Up(), 0);
	ang:RotateAroundAxis(ang:Forward(), 0);
	ang:RotateAroundAxis(ang:Right(), -90);
	
	local gasColor = Color(255, 222, 0, 100);
	
	if (!self:GetNWBool("open")) then
		gasColor = Color(255, 222, 0, 100);
	else
		gasColor = Color(255, 94, 0, 100);
	end;
	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < self:GetNWInt("distance") then
		render.SetMaterial(laser);
		render.DrawBeam(self:GetPos()+(self:GetUp()*28), self:GetPos()+(self:GetUp()*42), 1, 1, 1, Color(255, 255, 255, 255));
	
		cam.Start3D2D(pos+ang:Up()*4.75, ang, 0.1)
				surface.SetDrawColor(Color(0, 0, 0, 200));
				surface.DrawRect(-176, -12, 450, 24)
			
				surface.SetDrawColor(gasColor);
				surface.DrawRect(-173, -9, math.Round((self:GetNWInt("amount")*444)/self:GetNWInt("maxAmount")), 18)	
				draw.SimpleTextOutlined(math.Round((self:GetNWInt("amount")*100)/self:GetNWInt("maxAmount")).."% ("..self:GetNWInt("amount").."/"..self:GetNWInt("maxAmount")..")", "methFont1", -170, -7, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT, 1, Color(25, 25, 25, 200));
	
		cam.End3D2D()	
	end;
end;

--PATH addons/_eml/lua/entities/eml_sulfur/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFont", {
	font = "Arial",
	size = 30,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	

end;

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ang = self:GetAngles()

	local sulfurColor = EML_Sulfur_Color;
	
	if (self:GetNWInt("amount")>0) then
		sulfurColor = EML_Sulfur_Color;
	else
		sulfurColor = Color(100, 100, 100, 255);
	end;
	
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < self:GetNWInt("distance") then
		cam.Start3D2D(pos+ang:Up()*3.35, ang, 0.07)
			draw.SimpleTextOutlined("Рідка", "methFont", 0, -14, sulfurColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined("Сірка", "methFont", 0, 10, sulfurColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined(""..self:GetNWInt("amount").."Л", "methFont", 0, 34, sulfurColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
		cam.End3D2D();

	ang:RotateAroundAxis(ang:Up(), 0);
	ang:RotateAroundAxis(ang:Forward(), -90);
	ang:RotateAroundAxis(ang:Right(), 90);		
		cam.Start3D2D(pos+ang:Up()*3.35, ang, 0.1)
			surface.SetDrawColor(0, 0, 0, 200);
			surface.DrawRect(-40, -8, 64, 16);
			
			surface.SetDrawColor(EML_Sulfur_Color);
			surface.DrawRect(-38, -6, math.Round((self:GetNWInt("amount")*60)/self:GetNWInt("maxAmount")), 12);				
		cam.End3D2D();
	end;
end;

-- maxAmount = 60
-- amount = x


--PATH addons/_eml/lua/entities/eml_water/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFont", {
	font = "Arial",
	size = 30,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	

end;

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ang = self:GetAngles()

	local waterColor = EML_Water_Color;
	
	if (self:GetNWInt("amount")>0) then
		waterColor = EML_Water_Color;
	else
		waterColor = Color(100, 100, 100, 255);
	end;
	
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < self:GetNWInt("distance") then
		cam.Start3D2D(pos+ang:Up()*3.25, ang, 0.06)
			draw.SimpleTextOutlined("Вода", "methFont", 0, 0, waterColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
			draw.SimpleTextOutlined(""..self:GetNWInt("amount").."Л", "methFont", 0, 24, waterColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
		cam.End3D2D();

	ang:RotateAroundAxis(ang:Up(), 0);
	ang:RotateAroundAxis(ang:Forward(), -90);
	ang:RotateAroundAxis(ang:Right(), 90);		
		cam.Start3D2D(pos+ang:Up()*3.25, ang, 0.1)
			surface.SetDrawColor(0, 0, 0, 200);
			surface.DrawRect(-96, -8, 152, 16);
			
			surface.SetDrawColor(EML_Water_Color);
			surface.DrawRect(-94, -6, math.Round((self:GetNWInt("amount")*148)/self:GetNWInt("maxAmount")), 12);				
		cam.End3D2D();
	end;
		
end;
--PATH addons/igs-core/lua/entities/ent_igs/cl_init.lua:
IGS.sh("shared.lua")

local UPPER_TEXT = Color(255,255,255)
local LOWER_TEXT = Color(20, 150, 200)
local OUTLINE    = Color(0,0,0)

local font = "igs.40"
local function drawSide(pos,ang,t1,t2)
	cam.Start3D2D(pos, ang, .1)
		draw.SimpleTextOutlined(t1, font, 0, -385, UPPER_TEXT, TEXT_ALIGN_CENTER, nil, 1, OUTLINE)
		draw.SimpleTextOutlined(t2, font, 0, -350, LOWER_TEXT, TEXT_ALIGN_CENTER, nil, 1, OUTLINE)
	cam.End3D2D()
end



-- в Draw изменять осторожно
-- (может быть куча итемов, которые ускоряют анимацию при неправильном коде)
local ang = Angle(0,0,90)
function ENT:Draw()
	ang.y = -180 * math.Remap(CurTime() % 3, 0,3, 0,1) -- минус крутить в другую сторону

	self:DrawModel()

	local pos = self:GetPos()

	local ITEM = IGS.GetItemByUID(self:GetUID())
	local t1 = ITEM:Name()
	local t2 = "Діє " .. IGS.TermToStr(ITEM:Term())

	drawSide(pos,ang,t1,t2)
	ang:RotateAroundAxis(ang:Right(), 180)
	drawSide(pos,ang,t1,t2)
end

--PATH gamemodes/darkrp/entities/entities/gmod_cameraprop.lua:

-----------------------------------------------------
AddCSLuaFile()

if ( CLIENT ) then
	CreateConVar( "cl_drawcameras", "1", 0, "Should the cameras be visible?" )
end

ENT.Type = "anim"
ENT.Spawnable			= false
ENT.RenderGroup 		= RENDERGROUP_BOTH

local CAMERA_MODEL = Model( "models/dav0r/camera.mdl" )

function ENT:SetupDataTables()

	self:NetworkVar( "Int", 0, "Key" );
	self:NetworkVar( "Bool", 0, "On" );
	self:NetworkVar( "Vector", 0, "vecTrack" );
	self:NetworkVar( "Entity", 0, "entTrack" );
	self:NetworkVar( "Entity", 1, "Player" );

end

--[[---------------------------------------------------------
   Name: Initialize
-----------------------------------------------------------]]
function ENT:Initialize()

	if ( SERVER ) then

		self:SetModel( CAMERA_MODEL )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:DrawShadow( false )
		-- Don't collide with the player
		self:SetCollisionGroup( COLLISION_GROUP_WORLD )

		local phys = self:GetPhysicsObject()

		if ( phys:IsValid() ) then
			phys:Sleep()
		end

	end

end

function ENT:SetTracking( Ent, LPos )

	if ( Ent:IsValid() ) then

		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_BBOX )

	else

		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )

	end

	self:NextThink( CurTime() )

	self:SetvecTrack( LPos );
	self:SetentTrack( Ent );

end

function ENT:SetLocked( locked )

	if ( locked == 1 ) then

		self.PhysgunDisabled = true

		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_BBOX )

		self:SetCollisionGroup( COLLISION_GROUP_WORLD )

	else

		self.PhysgunDisabled = false

	end

	self.locked = locked

end

--[[---------------------------------------------------------
   Name: OnTakeDamage
-----------------------------------------------------------]]
function ENT:OnTakeDamage( dmginfo )
	if ( self.locked ) then return end
	self:TakePhysicsDamage( dmginfo )
end


function ENT:OnRemove()

	if ( IsValid( self.UsingPlayer ) ) then

		self.UsingPlayer:SetViewEntity( self.UsingPlayer )

	end

end

if ( SERVER ) then

	numpad.Register( "Camera_On", function ( pl, ent )

		if ( !IsValid( ent ) ) then return false end

		pl:SetViewEntity( ent )
		pl.UsingCamera = ent
		ent.UsingPlayer = pl

	end )

	numpad.Register( "Camera_Toggle", function ( pl, ent, idx, buttoned )

		-- The camera was deleted or something - return false to remove this entry
		if ( !IsValid( ent ) ) then return false end
		if ( !IsValid( pl ) ) then return false end

		-- Something else changed players view entity
		if ( pl.UsingCamera && pl.UsingCamera == ent && pl:GetViewEntity() != ent ) then
			pl.UsingCamera = nil
			ent.UsingPlayer = nil
		end

		if ( pl.UsingCamera && pl.UsingCamera == ent ) then

			pl:SetViewEntity( pl )
			pl.UsingCamera = nil
			ent.UsingPlayer = nil

		else

			pl:SetViewEntity( ent )
			pl.UsingCamera = ent
			ent.UsingPlayer = pl

		end

	end )

	numpad.Register( "Camera_Off", function( pl, ent )

		if ( !IsValid( ent ) ) then return false end

		if ( pl.UsingCamera && pl.UsingCamera == ent ) then
			pl:SetViewEntity( pl )
			pl.UsingCamera = nil
			ent.UsingPlayer = nil
		end

	end )

end


function ENT:Think()

	self:SetCollisionGroup( COLLISION_GROUP_WORLD )

	if ( CLIENT ) then



		self:TrackEntity( self:GetentTrack(), self:GetvecTrack() )

	end

end

function ENT:TrackEntity( ent, lpos )

	if ( !ent || !ent:IsValid() ) then return end

	local WPos = ent:LocalToWorld( lpos )

	if ( ent:IsPlayer() ) then
		WPos = WPos + ent:GetViewOffset() * 0.85
	end

	local CamPos = self:GetPos()
	local Ang = WPos - CamPos

	Ang = Ang:Angle()
	self:SetAngles(Ang)

end

function ENT:CanTool( ply, trace, mode )

	if ( self:GetMoveType() == MOVETYPE_NONE ) then return false end

	return true

end

function ENT:Draw()

	if ( GetConVarNumber( "cl_drawcameras" ) == 0 ) then return end

	-- Don't draw the camera if we're taking pics
	local ply = LocalPlayer()
	local wep = ply:GetActiveWeapon()
	if ( wep:IsValid() ) then
		if ( wep:GetClass() == "gmod_camera" ) then return end
	end

	self:DrawModel()

end

--[[---------------------------------------------------------
   Name: Damage
-----------------------------------------------------------]]

function ENT:OnTakeDamage(dmg)
	if self.burningup then return end
	self.damage = (self.damage or 100) - dmg:GetDamage()
	if self.damage <= 0 then
		self:Destruct()
		self:Remove()
	end
end

function ENT:Destruct()
	local vPoint = self:GetPos()
	local effectdata = EffectData()
	effectdata:SetStart(vPoint)
	effectdata:SetOrigin(vPoint)
	effectdata:SetScale(1)
	util.Effect("Explosion", effectdata)

	if self:GetPlayer():IsValid() then
		rp.Notify(self:GetPlayer(), 1, "Ваша камера була знищена","")
	end
end
--PATH addons/__advdupe2/lua/entities/gmod_contr_spawner/cl_init.lua:
include( "shared.lua" )

function ENT:Draw()
	self.BaseClass.Draw(self)
	self.Entity:DrawModel()
end

--PATH gamemodes/darkrp/entities/entities/lootbox_1/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "[RP] Смітник"
ENT.Author = "Jerivssss"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "RP"

--PATH addons/lvs_base-main/lua/entities/lvs_base/cl_boneposeparemeter.lua:

function ENT:CreateBonePoseParameter( name, bone, ang_min, ang_max, pos_min, pos_max )
	if not istable( self._BonePoseParameters ) then self._BonePoseParameters = {} end

	self._BonePoseParameters[ name ] = {
		bone = (bone or -1),
		ang_min = ang_min or angle_zero,
		ang_max = ang_max or angle_zero,
		pos_min = pos_min or vector_origin,
		pos_max = pos_max or vector_origin,
	}
end

function ENT:SetBonePoseParameter( name, value )
	if name and string.StartsWith( name, "!" ) then
		name = string.Replace( name, "!", "" )
	end

	local EntTable = self:GetTable()

	if not istable( EntTable._BonePoseParameters ) or not EntTable._BonePoseParameters[ name ] then return end

	local data = EntTable._BonePoseParameters[ name ]

	local ang = LerpAngle( value, data.ang_min, data.ang_max )
	local pos = LerpVector( value, data.pos_min, data.pos_max )

	self:ManipulateBoneAngles( data.bone, ang )
	self:ManipulateBonePosition( data.bone, pos )
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_base_wheeldrive_trailer/cl_init.lua:
include("shared.lua")

function ENT:LVSHudPaintInfoText( X, Y, W, H, ScrX, ScrY, ply )
	local kmh = math.Round(self:GetVelocity():Length() * 0.09144,0)

	draw.DrawText( "km/h ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( kmh, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )
end

-- kill engine sounds
function ENT:OnEngineActiveChanged( Active )
end

-- kill flyby system
function ENT:FlyByThink()
end

function ENT:OnFlyBy( Pitch )
end

function ENT:StopFlyBy()
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_item_explosive.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Explosive"
ENT.Author = "Luna"
ENT.Category = "[LVS]"

ENT.Spawnable		= false
ENT.AdminOnly		= false

if SERVER then
	function ENT:SetDamage( num ) self._dmg = num end
	function ENT:SetRadius( num ) self._radius = num end
	function ENT:SetAttacker( ent ) self._attacker = ent end

	function ENT:GetAttacker() return self._attacker or NULL end
	function ENT:GetDamage() return (self._dmg or 250) end
	function ENT:GetRadius() return (self._radius or 250) end

	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal * 5 )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:Initialize()	
		self:SetModel( "models/Items/grenadeAmmo.mdl" )

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetRenderMode( RENDERMODE_TRANSALPHA )
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )

		self.TrailEntity = util.SpriteTrail( self, 0, Color(120,120,120,120), false, 5, 40, 0.2, 1 / ( 15 + 1 ) * 0.5, "trails/smoke" )
	end

	function ENT:Think()
		self:NextThink( CurTime() )

		if self.Active then
			self:Detonate()
		end

		return true
	end

	function ENT:Detonate()
		if self.IsExploded then return end

		self.IsExploded = true

		local Pos = self:GetPos()

		local effectdata = EffectData()
		effectdata:SetOrigin( Pos )
		effectdata:SetNormal( Vector(0,0,1) )
		effectdata:SetMagnitude( 1 )

		if self:WaterLevel() >= 2 then
			util.Effect( "WaterSurfaceExplosion", effectdata, true, true )
		else
			util.Effect( "lvs_defence_explosion", effectdata )
		end

		local dmginfo = DamageInfo()
		dmginfo:SetDamage( self:GetDamage() )
		dmginfo:SetAttacker( IsValid( self:GetAttacker() ) and self:GetAttacker() or self )
		dmginfo:SetDamageType( DMG_SONIC )
		dmginfo:SetInflictor( self )
		dmginfo:SetDamagePosition( Pos )

		util.BlastDamageInfo( dmginfo, Pos, self:GetRadius() )

		self:Remove()
	end

	function ENT:PhysicsCollide( data, physobj )
		self.Active = true

		if data.Speed > 60 and data.DeltaTime > 0.2 then
			local VelDif = data.OurOldVelocity:Length() - data.OurNewVelocity:Length()

			if VelDif > 200 then
				self:EmitSound( "Grenade.ImpactHard" )
			else
				self:EmitSound( "Grenade.ImpactSoft" )
			end

			physobj:SetVelocity( data.OurOldVelocity * 0.5 )
		end
	end
else
	function ENT:Draw()
		self:DrawModel()
	end

	function ENT:Think()
		return false
	end

	function ENT:OnRemove()
	end
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_item_shell.lua:
AddCSLuaFile()

ENT.Type            = "anim"

if SERVER then
	ENT.MDL = "models/props_debris/shellcasing_10.mdl"
	ENT.CollisionSounds = {
		"lvs/vehicles/pak40/shell_impact1.wav",
		"lvs/vehicles/pak40/shell_impact2.wav"
	}

	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal * 5 )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	ENT.LifeTime = 30

	function ENT:Initialize()	
		self:SetModel( self.MDL )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:PhysWake()
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
		self:SetRenderMode( RENDERMODE_TRANSALPHA )

		self.DieTime = CurTime() + self.LifeTime

		timer.Simple( self.LifeTime - 0.5, function()
			if not IsValid( self ) then return end

			self:SetRenderFX( kRenderFxFadeFast  ) 
		end)
	end

	function ENT:Think()
		if self.DieTime < CurTime() then
			self:Remove()
		end

		self:NextThink( CurTime() + 1 )

		return true
	end

	function ENT:PhysicsCollide( data, physobj )
		if data.Speed > 30 and data.DeltaTime > 0.2 then
			self:EmitSound( self.CollisionSounds[ math.random(1,#self.CollisionSounds) ] )
		end
	end

	return
end

function ENT:Draw()
	self:DrawModel()
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_item_transmission_automatic.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Transmission - Automatic"
ENT.Author = "Luna"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal * 5 )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:Initialize()	
		self:SetModel( "models/diggercars/auto.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:PhysWake()
	end

	function ENT:Think()
		return false
	end

	function ENT:PhysicsCollide( data )
		if self.MarkForRemove then return end

		local ent = data.HitEntity

		if not IsValid( ent ) or not ent.LVS or not isfunction( ent.DisableManualTransmission ) then return end

		if isfunction( ent.IsManualTransmission ) and not ent:IsManualTransmission() then return end

		if ent:DisableManualTransmission() ~= false then
			ent:EmitSound("npc/dog/dog_rollover_servos1.wav")

			self.MarkForRemove = true

			ent:DisableManualTransmission()

			SafeRemoveEntityDelayed( self, 0 )
		end
	end

	function ENT:OnTakeDamage( dmginfo )
	end

else
	function ENT:Draw( flags )
		self:DrawModel( flags )
	end
end

--PATH addons/lvs_base-main/lua/entities/lvs_missile.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Missile"
ENT.Author = "Luna"
ENT.Information = "LVS Missile"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true

ENT.ExplosionEffect = "lvs_explosion_small"

ENT.lvsProjectile = true
ENT.VJ_ID_Danger = true

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "Active" )
	self:NetworkVar( "Entity", 0, "NWTarget" )
end

if SERVER then
	util.AddNetworkString( "lvs_missile_hud" )

	function ENT:GetAvailableTargets()
		local targets = {
			[1] = player.GetAll(),
			[2] = LVS:GetVehicles(),
			[3] = LVS:GetNPCs(),
		}

		return targets
	end

	function ENT:FindTarget( pos, forward, cone_ang, cone_len )
		local targets = self:GetAvailableTargets()

		local Attacker = self:GetAttacker()
		local Parent = self:GetParent()
		local Owner = self:GetOwner()
		local Target = NULL
		local DistToTarget = 0

		for _, tbl in ipairs( targets ) do
			for _, ent in pairs( tbl ) do
				if not IsValid( ent ) or ent == Parent or ent == Owner or Target == ent or Attacker == ent then continue end

				local pos_ent = ent:GetPos()
				local dir = (pos_ent - pos):GetNormalized()
				local ang = math.deg( math.acos( math.Clamp( forward:Dot( dir ) ,-1,1) ) )

				if ang > cone_ang then continue end

				local dist, _, _ = util.DistanceToLine( pos, pos + forward * cone_len, pos_ent )

				if not IsValid( Target ) then
					Target = ent
					DistToTarget = dist

					continue
				end

				if dist < DistToTarget then
					Target = ent
					DistToTarget = dist
				end
			end
		end

		self:SetTarget( Target )

		local ply = self:GetAttacker()

		if not IsValid( ply ) or not ply:IsPlayer() then return end

		net.Start( "lvs_missile_hud", true )
			net.WriteEntity( self )
		net.Send( ply )
	end

	function ENT:SetEntityFilter( filter )
		if not istable( filter ) then return end

		self._FilterEnts = {}

		for _, ent in pairs( filter ) do
			self._FilterEnts[ ent ] = true
		end
	end
	function ENT:SetTarget( ent ) self:SetNWTarget( ent ) end
	function ENT:SetDamage( num ) self._dmg = num end
	function ENT:SetForce( num ) self._force = num end
	function ENT:SetThrust( num ) self._thrust = num end
	function ENT:SetSpeed( num ) self._speed = num end
	function ENT:SetTurnSpeed( num ) self._turnspeed = num end
	function ENT:SetRadius( num ) self._radius = num end
	function ENT:SetAttacker( ent ) self._attacker = ent end

	function ENT:GetAttacker() return self._attacker or NULL end
	function ENT:GetDamage() return (self._dmg or 100) end
	function ENT:GetForce() return (self._force or 4000) end
	function ENT:GetRadius() return (self._radius or 250) end
	function ENT:GetSpeed() return (self._speed or 4000) end
	function ENT:GetTurnSpeed() return (self._turnspeed or 1) * 100 end
	function ENT:GetThrust() return (self._thrust or 500) end
	function ENT:GetTarget()
		if IsValid( self:GetNWTarget() ) then
			local Pos = self:GetPos()
			local tPos = self:GetTargetPos()

			local Sub = tPos - Pos
			local Len = Sub:Length()
			local Dir = Sub:GetNormalized()
			local Forward = self:GetForward()

			local AngToTarget = math.deg( math.acos( math.Clamp( Forward:Dot( Dir ) ,-1,1) ) )

			local LooseAng = math.min( Len / 100, 90 )

			if AngToTarget > LooseAng then
				self:SetNWTarget( NULL )
			end
		end

		return self:GetNWTarget()
	end
	function ENT:GetTargetPos()
		local Target = self:GetNWTarget()

		if not IsValid( Target ) then return Vector(0,0,0) end

		if isfunction( Target.GetMissileOffset ) then
			return Target:LocalToWorld( Target:GetMissileOffset() )
		end

		return Target:GetPos()
	end

	function ENT:SpawnFunction( ply, tr, ClassName )

		local ent = ents.Create( ClassName )
		ent:SetPos( ply:GetShootPos() )
		ent:SetAngles( ply:EyeAngles() )
		ent:Spawn()
		ent:Activate()
		ent:SetAttacker( ply )
		ent:Enable()

		return ent
	end

	function ENT:Initialize()	
		self:SetModel( "models/weapons/w_missile_launch.mdl" )
		self:SetMoveType( MOVETYPE_NONE )
		self:SetRenderMode( RENDERMODE_TRANSALPHA )
	end

	function ENT:Enable()
		if self.IsEnabled then return end

		local Parent = self:GetParent()

		if IsValid( Parent ) then
			self:SetOwner( Parent )
			self:SetParent( NULL )
		end

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		self:PhysWake()

		self.IsEnabled = true

		local pObj = self:GetPhysicsObject()
		
		if not IsValid( pObj ) then
			self:Remove()

			print("LVS: missing model. Missile terminated.")

			return
		end

		pObj:SetMass( 1 ) 
		pObj:EnableGravity( false ) 
		pObj:EnableMotion( true )
		pObj:EnableDrag( false )

		self:SetTrigger( true )

		self:StartMotionController()

		self:PhysWake()

		self.SpawnTime = CurTime()

		self:SetActive( true )
	end

	function ENT:PhysicsSimulate( phys, deltatime )
		phys:Wake()

		local Thrust = self:GetThrust()
		local Speed = self:GetSpeed()
		local Pos = self:GetPos()
		local velL = self:WorldToLocal( Pos + self:GetVelocity() )

		local ForceLinear = (Vector( Speed * Thrust,0,0) - velL) * deltatime

		local Target = self:GetTarget()

		if not IsValid( Target ) then
			return (-phys:GetAngleVelocity() * 250 * deltatime), ForceLinear, SIM_LOCAL_ACCELERATION
		end

		local AngForce = -self:WorldToLocalAngles( (self:GetTargetPos() - Pos):Angle() )

		local ForceAngle = (Vector(AngForce.r,-AngForce.p,-AngForce.y) * self:GetTurnSpeed() - phys:GetAngleVelocity() * 5 ) * 250 * deltatime

		return ForceAngle, ForceLinear, SIM_LOCAL_ACCELERATION
	end

	function ENT:Think()	
		local T = CurTime()

		self:NextThink( T + 1 )

		if not self.SpawnTime then return true end

		if (self.SpawnTime + 12) < T then
			self:Detonate()
		end

		return true
	end

	ENT.IgnoreCollisionGroup = {
		[COLLISION_GROUP_NONE] = true,
		[COLLISION_GROUP_WORLD] =  true,
		[COLLISION_GROUP_INTERACTIVE_DEBRIS] = true,
	}

	function ENT:StartTouch( entity )
		if entity == self:GetAttacker() then return end

		if istable( self._FilterEnts ) and self._FilterEnts[ entity ] then return end

		if entity.GetCollisionGroup and self.IgnoreCollisionGroup[ entity:GetCollisionGroup() ] then return end

		if entity.lvsProjectile then return end

		self:Detonate( entity )
	end

	function ENT:EndTouch( entity )
	end

	function ENT:Touch( entity )
	end

	function ENT:PhysicsCollide( data )
		if istable( self._FilterEnts ) and self._FilterEnts[ data.HitEntity ] then return end

		self:Detonate( data.HitEntity )
	end

	function ENT:OnTakeDamage( dmginfo )	
	end

	function ENT:Detonate( target )
		if not self.IsEnabled or self.IsDetonated then return end

		self.IsDetonated = true

		local Pos =  self:GetPos() 

		local effectdata = EffectData()
			effectdata:SetOrigin( Pos )
		util.Effect( self.ExplosionEffect, effectdata )

		local attacker = self:GetAttacker()

		LVS:BlastDamage( Pos, self:GetForward(), IsValid( attacker ) and attacker or game.GetWorld(), self, self:GetDamage(), DMG_BLAST, self:GetRadius(), self:GetForce() )

		SafeRemoveEntityDelayed( self, FrameTime() )
	end
else
	function ENT:Initialize()	
	end

	function ENT:Enable()
		if self.IsEnabled then return end

		self.IsEnabled = true

		self.snd = CreateSound(self, "weapons/rpg/rocket1.wav")
		self.snd:SetSoundLevel( 80 )
		self.snd:Play()

		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
			effectdata:SetEntity( self )
		util.Effect( "lvs_missiletrail", effectdata )
	end

	function ENT:CalcDoppler()
		local Ent = LocalPlayer()

		local ViewEnt = Ent:GetViewEntity()

		if Ent:lvsGetVehicle() == self then
			if ViewEnt == Ent then
				Ent = self
			else
				Ent = ViewEnt
			end
		else
			Ent = ViewEnt
		end

		local sVel = self:GetVelocity()
		local oVel = Ent:GetVelocity()

		local SubVel = oVel - sVel
		local SubPos = self:GetPos() - Ent:GetPos()

		local DirPos = SubPos:GetNormalized()
		local DirVel = SubVel:GetNormalized()

		local A = math.acos( math.Clamp( DirVel:Dot( DirPos ) ,-1,1) )

		return (1 + math.cos( A ) * SubVel:Length() / 13503.9)
	end

	function ENT:Draw()
		if not self:GetActive() then return end

		self:DrawModel()
	end

	function ENT:Think()
		if self.snd then
			self.snd:ChangePitch( 100 * self:CalcDoppler() )
		end

		if self.IsEnabled then return end

		if self:GetActive() then
			self:Enable()
		end
	end

	function ENT:SoundStop()
		if self.snd then
			self.snd:Stop()
		end
	end

	function ENT:OnRemove()
		self:SoundStop()
	end

	local function DrawDiamond( X, Y, radius, angoffset )
		angoffset = angoffset or 0

		local segmentdist = 90
		local radius2 = radius + 1

		for ang = 0, 360, segmentdist do
			local a = ang + angoffset
			surface.DrawLine( X + math.cos( math.rad( a ) ) * radius, Y - math.sin( math.rad( a ) ) * radius, X + math.cos( math.rad( a + segmentdist ) ) * radius, Y - math.sin( math.rad( a + segmentdist ) ) * radius )
			surface.DrawLine( X + math.cos( math.rad( a ) ) * radius2, Y - math.sin( math.rad( a ) ) * radius2, X + math.cos( math.rad( a + segmentdist ) ) * radius2, Y - math.sin( math.rad( a + segmentdist ) ) * radius2 )
		end
	end

	local color_red = Color(255,0,0,255)
	local HudTargets = {}
	hook.Add( "HUDPaint", "!!!!lvs_missile_hud", function()
		local T = CurTime()

		local Index = 0

		surface.SetDrawColor( 255, 0, 0, 255 )

		for ID, _ in pairs( HudTargets ) do
			local Missile = Entity( ID )

			if not IsValid( Missile ) then
				HudTargets[ ID ] = nil

				continue
			end

			local Target = Missile:GetNWTarget()

			if not IsValid( Target ) then
				HudTargets[ ID ] = nil

				continue
			end

			local MissilePos = Missile:GetPos():ToScreen()
			local TargetPos = Target:LocalToWorld( Target:OBBCenter() ):ToScreen()

			Index =  Index + 1

			if not TargetPos.visible then continue end

			DrawDiamond( TargetPos.x, TargetPos.y, 40, ID * 1337 - T * 100 )

			draw.DrawText("LOCK", "LVS_FONT", TargetPos.x + 20, TargetPos.y + 20, color_red, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )

			if not MissilePos.visible then continue end

			DrawDiamond( MissilePos.x, MissilePos.y, 16, ID * 1337 - T * 100 )
			draw.DrawText( Index, "LVS_FONT", MissilePos.x + 10, MissilePos.y + 10, color_red, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
		
			surface.DrawLine( MissilePos.x, MissilePos.y, TargetPos.x, TargetPos.y )
		end
	end )

	net.Receive( "lvs_missile_hud", function( len )
		local ent = net.ReadEntity()

		if not IsValid( ent ) then return end

		HudTargets[ ent:EntIndex() ] = true
	end )
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_trailer_flak/cl_attached_playermodels.lua:

include("entities/lvs_tank_wheeldrive/modules/cl_attachable_playermodels.lua")

function ENT:DrawDriver()
	local pod = self:GetDriverSeat()

	if not IsValid( pod ) then self:RemovePlayerModel( "driver" ) return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if not IsValid( ply ) or (ply == plyL and not pod:GetThirdPersonMode()) then self:RemovePlayerModel( "driver" ) return end

	local ID = self:LookupAttachment( "seat" )
	local Att = self:GetAttachment( ID )

	if not Att then self:RemovePlayerModel( "driver" ) return end

	local Pos,Ang = LocalToWorld( Vector(0,0,0), Angle(180,-20,-90), Att.Pos, Att.Ang )

	local model = self:CreatePlayerModel( ply, "driver" )

	model:SetSequence( "drive_airboat" )
	model:SetRenderOrigin( Pos )
	model:SetRenderAngles( Ang )
	model:DrawModel()
end

function ENT:PreDraw()
	self:DrawDriver()

	return true
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_trailer_flaktrailer/cl_init.lua:
include("shared.lua")

function ENT:LVSHudPaintVehicleIdentifier( X, Y, In_Col, target_ent )
end

function ENT:UpdatePoseParameters( steer, speed_kmh, engine_rpm, throttle, brake, handbrake, clutch, gear, temperature, fuel, oil, ammeter )
	local Prongs = self:GetProng()

	local T = CurTime()

	if Prongs then self._ProngTime = T + 0.25 end

	local ProngsActive = (self._ProngTime or 0) > T

	self:SetPoseParameter( "fold", self:QuickLerp( "prong", (ProngsActive and 1 or 0), 10 ) )
end

--PATH addons/lvs_base-main/lua/entities/lvs_turret.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_wire_entity" )

ENT.PrintName		= "Projectile Turret"
ENT.WireDebugName = "Projectile Turret"

ENT.Author		= "Blu-x92"
ENT.Information		= "Projectile Turret"
ENT.Category		= "[LVS]"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false

ENT.Editable = true

ENT.TracerOptions = {
	["LaserBlue"] = "lvs_laser_blue",
	["LaserRed"] = "lvs_laser_red",
	["LaserGreen"] = "lvs_laser_green",
	["TracerGreen"] = "lvs_tracer_green",
	["TracerOrange"] = "lvs_tracer_orange",
	["TracerWhite"] = "lvs_tracer_white",
	["TracerYellow"] = "lvs_tracer_yellow",
	["AutoCannon"] = "lvs_tracer_autocannon",
	["Cannon"] = "lvs_tracer_cannon",
}

ENT.SplashTypeOptions = {
	Shrapnel = "lvs_bullet_impact",
	Explosive = "lvs_bullet_impact_explosive"
}

function ENT:SetupDataTables()
	local TracerOptions = {}

	for id, name in pairs( self.TracerOptions ) do
		if not file.Exists( "effects/"..name..".lua", "LUA" ) then continue end

		TracerOptions[ id ] = name
	end

	self:NetworkVar( "Float",1, "ShootDelay", { KeyName = "Shoot Delay", Edit = { type = "Float", order = 1,min = 0, max = 2, category = "Options"} } )
	self:NetworkVar( "Float",2, "Damage", { KeyName = "Damage", Edit = { type = "Float", order = 2,min = 0, max = 1000, category = "Options"} } )
	self:NetworkVar( "Float",3, "Speed", { KeyName = "Speed", Edit = { type = "Float", order = 3,min = 10000, max = 100000, category = "Options"} } )
	self:NetworkVar( "Float",4, "Size", { KeyName = "Size", Edit = { type = "Float", order = 4,min = 0, max = 50, category = "Options"} } )
	self:NetworkVar( "Float",5, "Spread", { KeyName = "Spread", Edit = { type = "Float", order = 5,min = 0, max = 1, category = "Options"} } )
	self:NetworkVar( "Float",6, "Penetration", { KeyName = "Armor Penetration (mm)", Edit = { type = "Float", order = 6,min = 0, max = 500, category = "Options"} } )
	self:NetworkVar( "Float",7, "SplashDamage", { KeyName = "Splash Damage", Edit = { type = "Float", order = 7,min = 0, max = 1000, category = "Options"} } )
	self:NetworkVar( "Float",8, "SplashDamageRadius", { KeyName = "Splash Damage Radius", Edit = { type = "Float", order = 8,min = 0, max = 750, category = "Options"} } )

	self:NetworkVar( "String", 1, "SplashDamageType", { KeyName = "Splash Damage Type", Edit = { type = "Combo",	order = 9,values = self.SplashTypeOptions,category = "Options"} } )

	self:NetworkVar( "String", 2, "Tracer", { KeyName = "Tracer", Edit = { type = "Combo",	order = 10,values = TracerOptions,category = "Options"} } )

	if SERVER then
		self:SetShootDelay( 0.05 )
		self:SetSpeed( 30000 )
		self:SetDamage( 15 )
		self:SetTracer( "lvs_tracer_orange" )
		self:SetSplashDamageType( "lvs_bullet_impact" )
	end
end

if CLIENT then
	function ENT:GetCrosshairFilterEnts()
		if not istable( self.CrosshairFilterEnts ) then
			self.CrosshairFilterEnts = {self}

			-- lets ask the server to build the filter for us because it has access to constraint.GetAllConstrainedEntities() 
			net.Start( "lvs_player_request_filter" )
				net.WriteEntity( self )
			net.SendToServer()
		end

		return self.CrosshairFilterEnts
	end

	return
end

function ENT:GetCrosshairFilterEnts()
	if not istable( self.CrosshairFilterEnts ) then
		self.CrosshairFilterEnts = {}

		for _, Entity in pairs( constraint.GetAllConstrainedEntities( self ) ) do
			if not IsValid( Entity ) then continue end

			table.insert( self.CrosshairFilterEnts , Entity )
		end

		for _, Parent in pairs( self.CrosshairFilterEnts ) do
			for _, Child in pairs( Parent:GetChildren() ) do
				if not IsValid( Child ) then continue end

				table.insert( self.CrosshairFilterEnts , Child )
			end
		end
	end

	return self.CrosshairFilterEnts
end

function ENT:SpawnFunction( ply, tr, ClassName )

	if not tr.Hit then return end

	local ent = ents.Create( ClassName )
	ent.Attacker = ply
	ent:SetPos( tr.HitPos + tr.HitNormal * 5 )
	ent:Spawn()
	ent:Activate()

	return ent

end

function ENT:TriggerInput( name, value )
	if name == "Fire" then
		self.TriggerFire = value >= 1
	end
end

function ENT:Initialize()	
	self:SetModel( "models/props_junk/PopCan01a.mdl" )
	self:PhysicsInit( SOLID_VPHYSICS )
	self:SetMoveType( MOVETYPE_VPHYSICS )
	self:SetSolid( SOLID_VPHYSICS )
	self:SetCollisionGroup( COLLISION_GROUP_WEAPON  ) 
	
	self:PhysWake()
	
	self.Inputs = WireLib.CreateInputs( self,{"Fire"} )
end

function ENT:SetNextShoot( time )
	self.NextShoot = time
end

function ENT:CanShoot()
	if not self.TriggerFire then return false end
	
	self.NextShoot = self.NextShoot or 0
	
	return self.NextShoot < CurTime()
end

local IsCannon = {
	["lvs_tracer_autocannon"] = 0.25,
	["lvs_tracer_cannon"] = 1,
}

function ENT:Shoot()
	if not self:CanShoot() then return end

	local Tracer = self:GetTracer()

	local bullet = {}
	bullet.Src 	= self:GetPos()
	bullet.Dir 	= self:GetUp()
	bullet.Spread 	= Vector(self:GetSpread(),self:GetSpread(),self:GetSpread())
	bullet.TracerName = Tracer
	bullet.Force	= self:GetPenetration() * 100
	bullet.HullSize 	= self:GetSize()
	bullet.Damage	= self:GetDamage()
	bullet.Velocity = self:GetVelocity():Length() + self:GetSpeed()

	if IsCannon[ Tracer ] then
		self:SetShootDelay( math.max( self:GetShootDelay(), IsCannon[ Tracer ] ) )
	end

	local SplashDamage = self:GetSplashDamage()
	local SplashDamageRadius = self:GetSplashDamageRadius()

	if SplashDamage ~= 0 and SplashDamageRadius ~= 0 then
		bullet.SplashDamage = SplashDamage
		bullet.SplashDamageRadius = SplashDamageRadius

		local SplashEffect = self:GetSplashDamageType()
		local BlastDamage = SplashEffect == "lvs_bullet_impact_explosive"

		bullet.SplashDamageEffect = SplashEffect
		bullet.SplashDamageType = BlastDamage and DMG_BLAST or DMG_SONIC

		if BlastDamage then
			self:SetShootDelay( math.max( self:GetShootDelay(), 0.5 ) )
		end
	end

	bullet.Attacker = IsValid( self.Attacker ) and self.Attacker or self

	bullet.Entity = self
	bullet.SrcEntity = vector_origin

	LVS:FireBullet( bullet )

	self:SetNextShoot( CurTime() + self:GetShootDelay() )
end

function ENT:Think()	

	self.BaseClass.Think( self )
	
	self:Shoot()

	self:NextThink( CurTime() )
	
	return true
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_2108/shared.lua:

ENT.Base = "lvs_base_wheeldrive"

ENT.PrintName = "Lada 2108"
ENT.Author = "Digger"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS] - Cars - Pack"

ENT.VehicleCategory = "Cars"
ENT.VehicleSubCategory = "Civilian"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/DiggerCars/VAZ 2108 Sport/lada.mdl"

ENT.MaxVelocity = 1800

ENT.EngineTorque = 65

ENT.TransGears = 4
ENT.TransGearsReverse = 1

ENT.RandomColor = {
	Color(208,155,98),
	Color(132,209,132),
	Color(78,180,131),
	Color(0,90,66),
	Color(51,80,132),
	Color(68,110,130),
	Color(166,85,50),
	Color(166,25,25),
	Color(83,14,14),
	Color(200,200,200),
	Color(120,120,120),
	Color(204,191,177),
	Color(200,189,119),
	Color(130,116,100),
	Color(50,29,25),
	Color(20,20,20),
	Color(28,29,37),
}

ENT.HornSound = "lvs/horn4.wav"
ENT.HornPos = Vector(40,0,35)

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/miata/eng_idle_loop.wav",
		Volume = 1,
		Pitch = 85,
		PitchMul = 25,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_IDLE_ONLY,
	},
	{
		sound = "lvs/vehicles/miata/eng_loop.wav",
		Volume = 1,
		Pitch = 60,
		PitchMul = 90,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_REV_UP,
		UseDoppler = true,
	},
	{
		sound = "lvs/vehicles/miata/eng_revdown_loop.wav",
		Volume = 1,
		Pitch = 60,
		PitchMul = 90,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_REV_DOWN,
		UseDoppler = true,
	},
}


ENT.ExhaustPositions = {
	{
		pos = Vector(-77.1,14.91,15.04),
		ang = Angle(0,180,0),
	}
}

ENT.Lights = {
	{
		Trigger = "main",
		ProjectedTextures = {
			{ pos = Vector(72.03,19,26.82), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
			{ pos = Vector(72.03,-19,26.82), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
		},
	},
	{
		Trigger = "high",
		ProjectedTextures = {
			{ pos = Vector(72.03,19,26.82), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
			{ pos = Vector(72.03,-19,26.82), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
		},
	},
	{
	Trigger = "main+high",
		SubMaterialBrightness = 1,
		SubMaterialID = 20,
		Sprites = {
			{ pos = Vector(72.03,19,26.82), colorB = 200, colorA = 150 },
			{ pos = Vector(72.03,-19,26.82), colorB = 200, colorA = 150 },
		},
	},
	{
	Trigger = "main",
		SubMaterialID = 1,
	},
	{
		Trigger = "main",
		SubMaterialID = 21,
		Sprites = {
			{ pos = Vector(-75.08,22.73,28.98), colorG = 0, colorB = 0, colorA = 150 },
			{ pos = Vector(-75.08,-22.73,28.98), colorG = 0, colorB = 0, colorA = 150 },
		}
	},
	{
		Trigger = "brake",
		SubMaterialID = 3,
		Sprites = {
			{ pos = Vector(-75.79,-14.37,28.88), colorG = 0, colorB = 0, colorA = 150 },
			{ pos = Vector(-75.79,14.37,28.88), colorG = 0, colorB = 0, colorA = 150 },
		}
	},
	{
		Trigger = "reverse",
		SubMaterialID = 5,
		Sprites = {
			{ pos = Vector(-75.57,18.73,27.1), height = 25, width = 25, colorA = 150 },
			{ pos = Vector(-75.57,-18.73,27.1), height = 25, width = 25, colorA = 150 },
		}
	},
	{
		Trigger = "turnright",
		SubMaterialID = 6,
		Sprites = {
			{ width = 35, height = 35, pos = Vector(74.59,-25.91,26.62), colorG = 100, colorB = 0, colorA = 50 },
			{ width = 15, height = 15, pos = Vector(35.39,-32.54,26.58), colorG = 100, colorB = 0, colorA = 50 },
			{ width = 40, height = 40, pos = Vector(-74.57,-26.39,28.91), colorG = 100, colorB = 0, colorA = 150 },
		},
	},
	{
		Trigger = "turnleft",
		SubMaterialID = 4,
		Sprites = {
			{ width = 35, height = 35, pos = Vector(74.59,25.91,26.62), colorG = 100, colorB = 0, colorA = 50 },
			{ width = 15, height = 15, pos = Vector(35.39,32.54,26.58), colorG = 100, colorB = 0, colorA = 50 },
			{ width = 40, height = 40, pos = Vector(-74.57,26.39,28.91), colorG = 100, colorB = 0, colorA = 150 },
		},
	},
}

--PATH addons/media_player/lua/entities/mediaplayer_tv/shared.lua:
AddCSLuaFile()

if SERVER then
	-- resource.AddFile( "models/gmod_tower/suitetv_large.mdl" )
	-- resource.AddFile( "materials/models/gmod_tower/suitetv_large.vmt" )
	-- resource.AddSingleFile( "materials/entities/mediaplayer_tv.png" )
end

DEFINE_BASECLASS( "mediaplayer_base" )

ENT.PrintName 		= "Big Screen TV"
ENT.Author 			= "Samuel Maddock"
ENT.Instructions 	= "Right click on the TV to see available Media Player options. Alternatively, press E on the TV to turn it on."
ENT.Category 		= "Media Player"

ENT.Type = "anim"
ENT.Base = "mediaplayer_base"

ENT.Spawnable = true

ENT.Model = Model( "models/gmod_tower/suitetv_large.mdl" )

list.Set( "MediaPlayerModelConfigs", ENT.Model, {
	angle = Angle(-90, 90, 0),
	offset = Vector(6, 59.49, 103.65),
	width = 119,
	height = 69
} )

function ENT:SetupDataTables()
	BaseClass.SetupDataTables( self )

	self:NetworkVar( "String", 1, "MediaThumbnail" )
end

if SERVER then

	function ENT:SetupMediaPlayer( mp )
		mp:on("mediaChanged", function(media) self:OnMediaChanged(media) end)
	end

	function ENT:OnMediaChanged( media )
		self:SetMediaThumbnail( media and media:Thumbnail() or "" )
	end

else -- CLIENT

	local draw = draw
	local surface = surface
	local Start3D2D = cam.Start3D2D
	local End3D2D = cam.End3D2D
	local DrawHTMLMaterial = DrawHTMLMaterial

	local TEXT_ALIGN_CENTER = TEXT_ALIGN_CENTER
	local color_white = color_white

	local StaticMaterial = Material( "theater/STATIC" )
	local TextScale = 700

	function ENT:Draw()
		self:DrawModel()

		local mp = self:GetMediaPlayer()

		if not mp then
			self:DrawMediaPlayerOff()
		end
	end

	local HTMLMAT_STYLE_ARTWORK_BLUR = 'htmlmat.style.artwork_blur'
	AddHTMLMaterialStyle( HTMLMAT_STYLE_ARTWORK_BLUR, {
		width = 720,
		height = 480
	}, HTMLMAT_STYLE_BLUR )

	local DrawThumbnailsCvar = MediaPlayer.Cvars.DrawThumbnails

	function ENT:DrawMediaPlayerOff()
		local w, h, pos, ang = self:GetMediaPlayerPosition()
		local thumbnail = self:GetMediaThumbnail()

		Start3D2D( pos, ang, 1 )
			if DrawThumbnailsCvar:GetBool() and thumbnail != "" then
				DrawHTMLMaterial( thumbnail, HTMLMAT_STYLE_ARTWORK_BLUR, w, h )
			else
				surface.SetDrawColor( color_white )
				surface.SetMaterial( StaticMaterial )
				surface.DrawTexturedRect( 0, 0, w, h )
			end
		End3D2D()


		local scale = w / TextScale
		Start3D2D( pos, ang, scale )
			local tw, th = w / scale, h / scale
			draw.SimpleText( "Press E to begin watching", "MediaTitle",
				tw*0.5, th*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		End3D2D()
	end

end

--PATH addons/_pcasino/lua/entities/pcasino_roulette_table/cl_init.lua:
include("shared.lua")


function ENT:Initialize()
	self.currentBid = 0
	self.active = false
	self.currentBets = {}

	self.hasInitialized = true
end

function ENT:PostData()
	if not self.hasInitialized then
		self:Initialize()
	end

	self.currentBid = self.data.bet.default
	self:GetCurrentPad(Vector(0, 0, 0)) -- To force generate the cache
end
function ENT:OnRemove()
	self:ClearBets()
end

local surface_setdrawcolor = surface.SetDrawColor
local surface_drawrect = surface.DrawRect
local draw_simpletext = draw.SimpleText
local black = Color(0, 0, 0, 155)
local white = Color(255, 255, 255, 100)
local gold = Color(255, 200, 0, 100)
function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 25000 then return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end

	if not self.data then return end


	local pos = self:GetPos()
	local ang = self:GetAngles()
	
	ang:RotateAroundAxis(ang:Up(), -90)

	cam.Start3D2D(pos + (ang:Up()*14.7) + (ang:Right()*20) + (ang:Forward()*-15.5), ang, 0.05)
		local button = self:GetCurrentPad(self:WorldToLocal(LocalPlayer():GetEyeTrace().HitPos))


		-- Bet limit
		if self.data.bet.betLimit and not (tonumber(self.data.bet.betLimit) == 0) then
			surface_setdrawcolor(black)
			surface_drawrect(5, -80, 410, 65)
			-- Border
			surface_setdrawcolor(white)
			surface_drawrect(0, -85, 420, 5)
			surface_drawrect(0, -80, 5, 65)
			surface_drawrect(415, -80, 5, 65)
			surface_drawrect(0, -15, 420, 5)
			-- Bet limit text
			draw_simpletext(string.format(PerfectCasino.Translation.UI.BetLimit, PerfectCasino.Config.FormatMoney(self.data.bet.betLimit)), "pCasino.Entity.Bid", 215, -47, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	
		-- Previous bet step
		surface_setdrawcolor(black)
		surface_drawrect(5, 5, 90, 65)
		-- Border
		surface_setdrawcolor(button == "bet_lower" and gold or white)
		surface_drawrect(0, 0, 100, 5)
		surface_drawrect(0, 5, 5, 65)
		surface_drawrect(95, 5, 5, 65)
		surface_drawrect(0, 70, 100, 5)
		-- Left arrow
		draw_simpletext("<", "pCasino.Entity.Arrows", 50, 35, button == "bet_lower" and gold or white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

		-- Current bet
		surface_setdrawcolor(black)
		surface_drawrect(115, 5, 190, 65)
		-- Border
		surface_setdrawcolor(white)
		surface_drawrect(110, 0, 200, 5)
		surface_drawrect(110, 5, 5, 65)
		surface_drawrect(305, 5, 5, 65)
		surface_drawrect(110, 70, 200, 5)
		-- Current Bid
		draw_simpletext(PerfectCasino.Config.FormatMoney(self.currentBid), "pCasino.Entity.Bid", 215, 37, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

		-- Next bet step
		-- Box
		surface_setdrawcolor(black)
		surface_drawrect(325, 5, 90, 65)
		-- Border
		surface_setdrawcolor(button == "bet_raise" and gold or white)
		surface_drawrect(320, 0, 100, 5)
		surface_drawrect(320, 5, 5, 65)
		surface_drawrect(415, 5, 5, 65)
		surface_drawrect(320, 70, 100, 5)
		-- Right arrow
		draw_simpletext(">", "pCasino.Entity.Arrows", 370, 35, button == "bet_raise" and gold or white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()

	if (not (self:GetStartRoundIn() == -1)) or (self:GetLastRoundNumber() >= 0) then
		ang:RotateAroundAxis(ang:Forward(), 90)
		ang:RotateAroundAxis(ang:Right(), 90)
		cam.Start3D2D(pos + (ang:Up()*-20.3) + (ang:Right()*-21.3) + (ang:Forward()*-15), ang, 0.05)
			
			-- Previous bet step
			surface_setdrawcolor(black)
			surface_drawrect(5, 5, 190, 65)
			-- Border
			surface_setdrawcolor(white)
			surface_drawrect(0, 0, 200, 5)
			surface_drawrect(0, 5, 5, 65)
			surface_drawrect(195, 5, 5, 65)
			surface_drawrect(0, 70, 200, 5)

			local text = (not (self:GetStartRoundIn() == -1)) and string.format(PerfectCasino.Translation.UI.Start, self.data.general.betPeriod - (os.time() - self:GetStartRoundIn())) or string.format(PerfectCasino.Translation.UI.Number, self:GetLastRoundNumber())
			draw_simpletext(text, "pCasino.Entity.Bid", 100, 37, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

		cam.End3D2D()
	end

end

local tempStack = {}
local lastPad = false

local function clearTempStack()
	for k, v in pairs(tempStack) do
		if not IsValid(v) then continue end
		v:Remove()
	end
	tempStack = {}
end

function ENT:Think()
	if self.active then return end
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 25000 then return end

	local pos = self:WorldToLocal(LocalPlayer():GetEyeTrace().HitPos)
	local curPad, padData = self:GetCurrentPad(pos)

	if (not curPad) or (curPad == "bet_raise") or (curPad == "bet_lower") then
		lastPad = curPad
		if not table.IsEmpty(tempStack) then
			clearTempStack()
		end
		return
	end -- Don't do anything if it's not a bet pad

	if not (curPad == lastPad) then
		clearTempStack()
	end
	lastPad = curPad

	if table.IsEmpty(tempStack) then
		local chips = PerfectCasino.Chips:GetFromNumber(self.currentBid)
		local ang = self:GetAngles()
		ang:RotateAroundAxis(ang:Up(), 90)

		for k=#PerfectCasino.Chips.Types, 0, -1 do -- Run it in reverse, putting the highest chips at the bottom
			if not chips[k] then continue end
			for i=1, chips[k] do
				local plaque = k >= 11 -- There are 11 normal skins, so anything over 10 (11-1, due to skins starting at 0) we use the big plaque models

				local chip = ClientsideModel(plaque and "models/freeman/owain_casino_plaque.mdl" or "models/freeman/owain_casino_chip.mdl")
				if not IsValid(chip) then return end
				table.insert(tempStack, chip)
				chip:SetParent(self)
				chip:SetSkin(plaque and k-11 or k)
				chip:SetPos(self:LocalToWorld(Vector(padData.origin.x, padData.origin.y, 14.8+((#tempStack+(self.currentBets[curPad] and #self.currentBets[curPad] or 0))*0.3))))
				chip:SetAngles(ang)
			end
		end
	else
		local ang = self:GetAngles()
		ang:RotateAroundAxis(ang:Up(), CurTime()*30%360)
		for k, v in pairs(tempStack) do
			v:SetAngles(ang)
		end
	end
end

-- Chip code
function ENT:AddBet(pad, amount)
	local padName, padData = self:GetPadByName(pad)
	if not padName then return end

	self.currentBets[padName] = self.currentBets[padName] or {}

	local chips = PerfectCasino.Chips:GetFromNumber(amount)
	local ang = self:GetAngles()
	ang:RotateAroundAxis(ang:Up(), 90)
	for k=#PerfectCasino.Chips.Types, 0, -1 do -- Run it in reverse, putting the highest chips at the bottom
		if not chips[k] then continue end
		for i=1, chips[k] do
			local plaque = k >= 11 -- There are 11 normal skins, so anything over 10 (11-1, due to skins starting at 0) we use the big plaque models

			local chip = ClientsideModel(plaque and "models/freeman/owain_casino_plaque.mdl" or "models/freeman/owain_casino_chip.mdl")
			if IsValid(chip) then
				table.insert(self.currentBets[padName], chip)
				chip:SetParent(self)
				chip:SetSkin(plaque and k-11 or k)
				chip:SetPos(self:LocalToWorld(Vector(padData.origin.x, padData.origin.y, 14.5+(#self.currentBets[padName]*0.3))))
				chip:SetAngles(ang)
			end
		end
	end

	clearTempStack() -- To update the hight to have over the new stack
end
function ENT:ClearBets()
	for _, pad in pairs(self.currentBets) do
		for k, v in pairs(pad) do
			v:Remove()
		end
	end

	self.currentBets = {}
end

function ENT:OnRemove()
	-- Clear the board of last rounds best
	for k, v in pairs(self.currentBets) do
		if not IsValid(v) then continue end

		v:Remove()
	end
	
	clearTempStack()
end


net.Receive("pCasino:Roulette:Bet:Change", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.data then return end

	local newBet = net.ReadUInt(32)
	entity.currentBid = newBet
end)

net.Receive("pCasino:Roulette:Bet:Place", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.data then return end
	if entity:GetPos():DistToSqr(LocalPlayer():GetPos()) > 100000 then return end

	local pad = net.ReadString()
	local betAmount = net.ReadUInt(32)


	entity:AddBet(pad, betAmount)
end)
net.Receive("pCasino:Roulette:Bet:Clear", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end

	entity:ClearBets()
end)
--PATH gamemodes/darkrp/entities/entities/radio/shared.lua:
ENT.Type = 'anim'
ENT.Base = 'base_anim'
ENT.PrintName = 'Радіо'
ENT.Author = 'doxzter'
ENT.Spawnable = true

function ENT:SetupDataTables()
    self:NetworkVar('String', 1, 'URL')
    self:NetworkVar('Int', 1, 'StartTime')
    self:NetworkVar('Bool', 2, 'Loop')
end
--PATH addons/____sprinter/lua/entities/sprinter_rack/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Printer Rack"
ENT.Author = "Stromic"
ENT.Category = "sPrinter"
ENT.Spawnable = true
ENT.isRack = true
ENT.sPrinter_ent = true
ENT.authorized = {}

function ENT:SetupDataTables()
	self:NetworkVar("Bool",0,"Power")
	self:NetworkVar("Bool",1,"Locked")
	self:NetworkVar("Entity",0,"owning_ent")
end
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_frontwoods/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "[UWeed] Frontwoods Bag"
ENT.Author = "Owain Owjo"
ENT.Category = "UWeed"
ENT.Spawnable = true
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.AdminSpawnable = true


function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "owning_ent")
	self:NetworkVar("Int", 0, "PaperCounter")
	
	self:NetworkVar("Bool", 0, "FirstSpawn")
end
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_seed_box/cl_init.lua:
include("shared.lua")

local grn = Color(0, 0, 0, 255)
local xpos = 175
local ypos = 0
function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	if self:GetPos():Distance(LocalPlayer():GetPos()) > 500 then return end
	local ang = LocalPlayer():EyeAngles()
	local pos = self:GetPos() + Vector(0,0,10)

	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), 90)

	cam.Start3D2D(pos, ang, 0.06)
		-- Background
		draw.RoundedBox(0, xpos, ypos+0, 380, 120, Color(0, 0, 0, 225))
		-- Side bar
		draw.RoundedBox(0, xpos, ypos+0, 10, 120, grn)
	
		draw.SimpleText(string.upper(UWeed.Translation.SeedBox.Title), "uweed_font_80", xpos+10, ypos+35, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		draw.SimpleText(UWeed.Translation.Pot.Counter.." "..self:GetSeedCount().."/"..UWeed.SeedBox.MaxStorage, "uweed_font_60", xpos+10, ypos+90, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	cam.End3D2D()
end
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_seed_box/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "[UWeed] Seed Box"
ENT.Author = "Owain Owjo"
ENT.Category = "UWeed"
ENT.Spawnable = true
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.AdminSpawnable = true

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "SeedCount")
	self:NetworkVar("Entity", 0, "owning_ent")

	self:NetworkVar("Bool", 0, "FirstSpawn")
end
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_skin/cl_init.lua:
include("shared.lua")

local grn = Color(0, 0, 0, 255)
local xpos = 100
local ypos = 0

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	if self:GetPos():Distance(LocalPlayer():GetPos()) > 500 then return end
	local ang = LocalPlayer():EyeAngles()
	local pos = self:GetPos() + Vector(0,0,10)

	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), 90)

	cam.Start3D2D(pos, ang, 0.06)
		if self:GetStage() == 0 then
			-- Background
			draw.RoundedBox(0, xpos, ypos+0, 510, 120, Color(0, 0, 0, 225))
			-- Side bar
			draw.RoundedBox(0, xpos, ypos+0, 10, 120, grn)
		
			draw.SimpleText(string.upper(UWeed.Translation.Skin.Title), "uweed_font_80", xpos+10, ypos+35, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			draw.SimpleText(UWeed.Translation.Skin.NoWeed, "uweed_font_60", xpos+10, ypos+90, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		elseif self:GetStage() == 1 then
			-- Background
			draw.RoundedBox(0, xpos, ypos+0, 510, 120, Color(0, 0, 0, 225))
			-- Side bar
			draw.RoundedBox(0, xpos, ypos+0, 10, 120, grn)
		
			draw.SimpleText(string.upper(UWeed.Translation.Skin.Title), "uweed_font_80", xpos+10, ypos+35, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			draw.SimpleText("Hold E to start rolling", "uweed_font_60", xpos+10, ypos+90, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		elseif self:GetStage() == 2 then
			-- Background
			draw.RoundedBox(0, xpos, ypos+0, 510, 120, Color(0, 0, 0, 225))
			-- Side bar
			draw.RoundedBox(0, xpos, ypos+0, 10, 120, grn)

			local dots = "."
			for i=1, CurTime()%3 do
				dots = dots.."."
			end
		
			draw.SimpleText(string.upper(UWeed.Translation.Skin.Title), "uweed_font_80", xpos+10, ypos+35, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			draw.SimpleText("Rolling"..dots, "uweed_font_60", xpos+10, ypos+90, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		elseif self:GetStage() == 3 then
			-- Background
			draw.RoundedBox(0, xpos, ypos+0, 510, 120, Color(0, 0, 0, 225))
			-- Side bar
			draw.RoundedBox(0, xpos, ypos+0, 10, 120, grn)

			local dots = "."
			for i=1, CurTime()%3 do
				dots = dots.."."
			end
		
			draw.SimpleText(string.upper(UWeed.Translation.Skin.Title), "uweed_font_80", xpos+10, ypos+35, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			draw.SimpleText("Pickup", "uweed_font_60", xpos+10, ypos+90, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end
	cam.End3D2D()
end
--PATH addons/__snow_event/lua/entities/zck_snowballcrate/shared.lua:
ENT.Type = 'anim'
ENT.Base = 'base_anim'
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = 'Ящик зі сніжками'
ENT.Category = 'Main'
ENT.RenderGroup = RENDERGROUP_OPAQUE
function ENT:SetupDataTables()
	self:NetworkVar( 'Int', 0, 'UsedCrateCount' )
	if SERVER then self:SetUsedCrateCount( 0 ) end
end
--PATH addons/__main/lua/effects/csgo_knifeimpact.lua:
function EFFECT:Init( data )
  local vOffset = data:GetOrigin() -- + Vector( 0, 0, 0.2 )
  -- local vAngle = data:GetAngles()
  local emitter = ParticleEmitter( vOffset ) -- there was false
    for i=0, 5 do
      local particle = emitter:Add( "particle/particle_smokegrenade", vOffset )
      if particle then
        -- particle:SetAngles( vAngle )
        particle:SetVelocity( math.random(12,16) * math.sqrt(i) * data:GetNormal() * 3 + 2 * VectorRand() )
        particle:SetColor( 135, 135, 135 )
        particle:SetLifeTime( 0 )
        particle:SetDieTime( math.Rand( 0.5, 1.5 ) )
        particle:SetStartAlpha( 255 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand( 5, 8 ) *math.Clamp(i,1,4) * 0.166 )
        --particle:SetStartLength( 1 )
        particle:SetEndSize( math.Rand( 16, 24 ) * math.sqrt(math.Clamp(i,1,4)) * 0.166 )
        --particle:SetEndLength( 4 )
        particle:SetRoll( math.Rand( -25, 25 ) )
        particle:SetRollDelta( math.Rand( -0.05, 0.05 ) )
      end
    end
  emitter:Finish()
end

function EFFECT:Think()
  return false
end

function EFFECT:Render()
end
--PATH addons/_drones/lua/effects/dronesrewrite_papers.lua:
AddCSLuaFile()

function EFFECT:Init(data)
	self.Start = data:GetOrigin()

	self.Emitter = ParticleEmitter(self.Start)
	
	for i = 1, 128 do
		local vec = VectorRand()
		local p = self.Emitter:Add("particles/balloon_bit", self.Start + vec * 16)

		p:SetDieTime(math.random(2, 4))
		p:SetStartAlpha(math.random(50, 150))
		p:SetEndAlpha(0)
		p:SetStartSize(2)
		p:SetRoll(math.Rand(-180, 180))
		p:SetRollDelta(math.Rand(-5, 5))
		p:SetEndSize(4)		
		p:SetVelocity(vec * 64)
		p:SetAirResistance(128)
		p:SetGravity(Vector(0, 0, -40))
		p:SetCollide(true)
		p:SetColor(255, 255, 255)
	end
	
	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end






--PATH addons/_drones/lua/effects/dronesrewrite_rockboom.lua:
if SERVER then AddCSLuaFile() end

function EFFECT:Init(data)
	self.Start = data:GetOrigin()
	self.size = data:GetScale()
	self.Emitter = ParticleEmitter(self.Start)
	
	for i = 1, 100 do
		local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(1, 9), self.Start)

		p:SetDieTime(math.Rand(2, 4))
		p:SetStartAlpha(80)
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(150, 200) * self.size)
		p:SetEndSize(150 * self.size)
		p:SetRoll(math.Rand(-1, 1))
		p:SetRollDelta(math.Rand(-1, 1))
		//p:SetCollide(true)
			
		p:SetVelocity(VectorRand():GetNormal() * 550 * self.size)
		p:SetColor(25, 25, 25)
			
		timer.Simple(0.5, function() p:SetVelocity(p:GetVelocity() / 4) end)
	end
		
	for i = 1, math.random(50, 150) do
		local p = self.Emitter:Add("particles/fir21", self.Start)

		p:SetDieTime(math.Rand(0.4, 0.6))
		p:SetStartAlpha(60)
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(100, 200) * self.size)
		p:SetEndSize(100 * self.size)
		//p:SetRoll(math.Rand(-10, 10))
		//p:SetRollDelta(math.Rand(-10, 10))
		p:SetCollide(true)
			
		p:SetVelocity(VectorRand():GetNormal() * math.random(650, 850) * self.size)
		p:SetColor(255, 150, 0)
	end
		
	for i = 1, math.random(20, 50) do
		local p = self.Emitter:Add("effects/muzzleflash"..math.random(1,4), self.Start)

		p:SetDieTime(math.Rand(0.4, 0.6))
		p:SetStartAlpha(60)
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(50, 150) * self.size)
		p:SetEndSize(50 * self.size)
		//p:SetRoll(math.Rand(-10, 10))
		//p:SetRollDelta(math.Rand(-10, 10))
		p:SetCollide(true)
			
		p:SetVelocity(VectorRand():GetNormal() * math.random(150, 350) * self.size)
		p:SetColor(255, 150, 0)
	end
		
	for i = 1, math.random(10, 30) do
		local vec = VectorRand():GetNormal()
		//vec.z = 0
		local pos = (self.Start + vec)
		
		local p = self.Emitter:Add("effects/fleck_cement" .. math.random(1, 2), self.Start + vec * 100)

		p:SetDieTime(math.Rand(5, 10))
		p:SetStartAlpha(255)
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(10, 25) * self.size)
		p:SetRoll(math.Rand(-10, 10))
		p:SetRollDelta(math.Rand(-10, 10))
		p:SetEndSize(0 * self.size)		
		p:SetVelocity((Vector(0, 0, math.random(450, 800)) + vec * math.random(350, 1000)) + (pos - self.Start):GetNormal() * math.random(100, 100) * self.size)
		p:SetGravity(Vector(0, 0, math.random(-300, -200)))
		p:SetColor(80, 80, 80)
		p:SetCollide(true)
	end
		
	for i = 1, math.random(40, 70) do
		local vec = VectorRand():GetNormal()
		vec.z = 0
		local pos = (self.Start + vec * 5)
		
		local p = self.Emitter:Add("sprites/orangeflare1", self.Start + vec * 100)
			
		p:SetDieTime(math.Rand(1, 5))
		p:SetStartAlpha(255)
		p:SetEndAlpha(0)
		p:SetStartSize(15 * self.size)
		p:SetEndSize(0 * self.size)
		p:SetVelocity(((pos - self.Start):GetNormal() * math.random(100, 200)) + Vector(0, 0, math.random(-200, 500)) * self.size)
		p:SetGravity(Vector(0, 0, -40))
		p:SetColor(80, 80, 80)
		p:SetCollide(true)
		
		timer.Simple(0.5, function() p:SetVelocity(p:GetVelocity() / 10) end)
	end
	
	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH addons/_drones/lua/effects/dronesrewrite_skullfly.lua:
function EFFECT:Init(data)		
	self.Start = data:GetOrigin()
	
	self.Emitter = ParticleEmitter(self.Start)
	
	local p = self.Emitter:Add("particle/particle_glow_04_additive", self.Start)
		
	p:SetVelocity(VectorRand() * 100)
	p:SetAirResistance(200)
	p:SetDieTime(0.5)
	p:SetStartAlpha(255)
	p:SetEndAlpha(0)
	p:SetStartSize(math.random(1, 5))
	p:SetEndSize(math.random(10, 15))	
	p:SetRollDelta(math.Rand(-2, 2))
	p:SetCollide(true)
	p:SetColor(255, 0, 0)
	
	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH addons/lvs_cars_3027255911/lua/effects/lvs_carexhaust_pop.lua:

EFFECT.GlowMat = Material( "effects/yellowflare" )
EFFECT.FireMat = Material( "effects/muzzleflash2" )

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Ang = data:GetAngles()
	self.Ent = data:GetEntity()

	local volume = math.Clamp( data:GetMagnitude(), 0, 1 )

	local T = CurTime()

	self.LifeTime = 0.25
	self.LifeTimePop = 0.1

	self.DieTime = T + self.LifeTime
	self.DieTimePop = T + self.LifeTimePop

	self.Scale = math.Rand( 0.25, 1 )

	if not IsValid( self.Ent ) then return end

	local Pos = self.Ent:LocalToWorld( self.Pos )

	self:SetPos( Pos )

	local ply = LocalPlayer()

	if not IsValid( ply ) then return end

	local veh = ply:lvsGetVehicle()

	if IsValid( veh ) and veh == self.Ent then
		local pod = ply:GetVehicle()

		if IsValid( pod ) and not pod:GetThirdPersonMode() then
			sound.Play( "lvs/vehicles/generic/exhaust_pop_interior"..math.random(1,12)..".ogg", Pos, 75, math.random(98,105), volume )

			return
		end
	end

	local dlight = DynamicLight( self.Ent:EntIndex() * math.random(1,4), true )

	if dlight then
		dlight.pos = Pos
		dlight.r = 255
		dlight.g = 180
		dlight.b = 100
		dlight.brightness = 1
		dlight.Decay = 2000
		dlight.Size = 400
		dlight.DieTime = CurTime() + 0.2
	end

	sound.Play( "lvs/vehicles/generic/exhaust_pop"..math.random(1,16)..".ogg", Pos, 75, math.random(98,105), volume )
end

function EFFECT:Think()
	if not IsValid( self.Ent ) then return false end

	if self.DieTime < CurTime() then return false end

	self:SetPos( self.Ent:LocalToWorld( self.Pos ) )

	return true
end


function EFFECT:Render()
	if not IsValid( self.Ent ) or not self.Pos then return end

	self:RenderSmoke()
end

function EFFECT:RenderSmoke()
	if not self.Pos or not self.Ang or not self.Scale then return end

	local T = CurTime()

	local ScalePop = math.Clamp( (self.DieTimePop - T) / self.LifeTimePop, 0, 1 )
	local InvScalePop = 1 - ScalePop

	local Scale = (self.DieTime - T) / self.LifeTime
	local InvScale = 1 - Scale

	local Pos = self.Ent:LocalToWorld( self.Pos )
	local Ang = self.Ent:LocalToWorldAngles( self.Ang )

	local FlameSize = 5 * Scale ^ 2
	render.SetMaterial( self.FireMat )
	for i = 1, 12 do
		render.DrawSprite( Pos + Ang:Forward() * InvScale * 20 + VectorRand() * 2, FlameSize, FlameSize, color_white )
	end

	if InvScalePop <= 0 then return end

	local GlowSize = 60 * InvScalePop * self.Scale
	local A255 = 255 * ScalePop

	render.SetMaterial( self.GlowMat )
	render.DrawSprite( Pos, GlowSize, GlowSize, Color(A255,A255,A255,A255) )
end


--PATH addons/lvs_cars_3027255911/lua/effects/lvs_defence_explosion.lua:

EFFECT.GlowMat = Material( "sprites/light_glow02_add" )
EFFECT.SmokeMat = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.DustMat = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local scale = data:GetMagnitude()

	self.LifeTime = 0.35
	self.DieTime = CurTime() + self.LifeTime

	self.Pos = pos
	self.Scale = scale

	sound.Play( "weapons/shotgun/shotgun_fire6.wav", pos, 75, 150, 1 )

	local VecCol = (render.GetLightColor( pos + dir ) * 0.5 + Vector(0.2,0.18,0.15)) * 255

	local emitter = ParticleEmitter( pos, false )

	for i = 0,20 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ] , pos )
		
		if not particle then continue end

		particle:SetVelocity( VectorRand() * 500 * scale )
		particle:SetDieTime( math.Rand(0.4,0.6) )
		particle:SetAirResistance( 500 ) 
		particle:SetStartAlpha( 100 )
		particle:SetStartSize( 40 * scale )
		particle:SetEndSize( 200 * scale )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
		particle:SetGravity( Vector(0,0,1200) )
		particle:SetCollide( true )
	end

	for i = 1,12 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ] , pos )

		if not particle then continue end

		local ang = i * 30
		local X = math.cos( math.rad(ang) )
		local Y = math.sin( math.rad(ang) )

		local Vel = Vector(X,Y,0) * 1000
		Vel:Rotate( dir:Angle() + Angle(90,0,0) )

		particle:SetVelocity( Vel * scale )
		particle:SetDieTime( math.Rand(0.6,0.8) )
		particle:SetAirResistance( 500 ) 
		particle:SetStartAlpha( 100 )
		particle:SetStartSize( 30 * scale )
		particle:SetEndSize( 60 * scale )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
		particle:SetGravity( Vector(0,0,600) )
		particle:SetCollide( true )
	end

	for i = 0, 15 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 400 * scale )
		particle:SetDieTime( math.Rand(0.2,0.3) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( 60 * scale )
		particle:SetEndSize( 10 * scale )
		particle:SetColor( 255, 255, 255 )
		particle:SetGravity( dir * 2500 )
		particle:SetRollDelta( math.Rand(-5,5) )
		particle:SetAirResistance( 300 )
	end

	for i = 0, 5 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos)

		if not particle then continue end

		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetColor( 255, 255, 255 )
		particle:SetGravity( Vector(0,0,0) )

		local size = math.Rand(2, 12) * scale
		particle:SetEndSize( size )
		particle:SetStartSize( size )

		particle:SetStartLength( 100 * scale )
		particle:SetEndLength( size )

		particle:SetDieTime( math.Rand(0.1,0.2) )
		particle:SetVelocity( (dir * 2000 + VectorRand() * 1000) * scale )

		particle:SetAirResistance( 0 )
	end

	for i = 0, 40 do
		local particle = emitter:Add( "effects/fire_embers"..math.random(1,2), pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 400 * scale )
		particle:SetDieTime( math.Rand(0.4,0.6) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( 20 * scale )
		particle:SetEndSize( 0 )
		particle:SetColor( 255, 255, 255 )
		particle:SetGravity( Vector(0,0,600) )
		particle:SetRollDelta( math.Rand(-8,8) )
		particle:SetAirResistance( 300 )
	end

	if dir.z > 0.8 then
		for i = 0,60 do
			local particle = emitter:Add( "effects/fleck_cement"..math.random(1,2), pos )
			local vel = dir * math.Rand(600,1000) + VectorRand() * 200

			if not particle then continue end

			particle:SetVelocity( vel * scale )
			particle:SetDieTime( math.Rand(10,15) )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )

			local size = math.Rand(2, 4) * scale
			particle:SetEndSize( size )
			particle:SetStartSize( size )

			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector( 0, 0, -600 ) )
			particle:SetCollide( true )
			particle:SetBounce( 0.3 )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	if not self.Scale then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	local R1 = 800 * self.Scale
	render.SetMaterial( self.GlowMat )
	render.DrawSprite( self.Pos, R1 * Scale, R1 * Scale, Color( 255, 200, 150, 255) )
end

--PATH addons/lvs_base-main/lua/effects/lvs_exhaust.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Dir = data:GetNormal()
	local Ent = data:GetEntity()
	local Scale = data:GetMagnitude()

	if not IsValid( Ent ) then return end

	local Vel = Ent:GetVelocity()

	local emitter = Ent:GetParticleEmitter( Pos )

	if not IsValid( emitter ) then return end

	local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], Pos )

	if not particle then return end

	local Col = 100 - 60 * Scale

	particle:SetVelocity( Vel + Dir * (100 + 50 * Scale) )
	particle:SetDieTime( 0.4 - 0.3 * Scale )
	particle:SetAirResistance( 400 ) 
	particle:SetStartAlpha( 80 )
	particle:SetStartSize( 2 )
	particle:SetEndSize( 10 + 20 * Scale )
	particle:SetRoll( math.Rand( -1, 1 ) )
	particle:SetRollDelta( math.Rand( -1, 1 ) * 2 )
	particle:SetColor( Col, Col, Col )
	particle:SetGravity( Vector( 0, 0, 10 ) )
	particle:SetCollide( false )
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH addons/lvs_base-main/lua/effects/lvs_exhaust_fire.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Dir = data:GetNormal()
	local Ent = data:GetEntity()
	local Scale = data:GetMagnitude()

	if not IsValid( Ent ) then return end

	local emitter = Ent:GetParticleEmitter( Pos )

	if not IsValid( emitter ) then return end

	local particle = emitter:Add( "effects/lvs_base/fire", Pos )

	if particle then
		particle:SetVelocity( Dir * 70 )
		particle:SetDieTime( 0.2 )
		particle:SetAirResistance( 0 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 10 + 18 * Scale )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-1,1) * 180 )
		particle:SetColor( 255,255,255 )
		particle:SetGravity( Vector( 0, 0, 100 ) )
		particle:SetCollide( false )
	end
	
	for i = 1, 3 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), Pos )
		
		if particle then
			particle:SetVelocity( Dir * 40 * i )
			particle:SetDieTime( 0.2 )
			particle:SetAirResistance( 0 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( (5 + 5 * Scale) - i )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-1,1) * 180 )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH addons/lvs_cars_3027255911/lua/effects/lvs_tracer_cannon.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

EFFECT.MatSmoke = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )

	self.emitter = ParticleEmitter( pos, false )

	self.OldPos = pos
	self.Dir = dir

	if not self.emitter then return end

	local VecCol = (render.GetLightColor( pos ) * 0.8 + Vector(0.2,0.2,0.2)) * 255
	for i = 0,10 do
		local particle = self.emitter:Add( self.MatSmoke[math.random(1,#self.MatSmoke)], pos )

		if not particle then continue end

		particle:SetVelocity( dir * 700 + VectorRand() * 200 )
		particle:SetDieTime( math.Rand(2,3) )
		particle:SetAirResistance( 250 ) 
		particle:SetStartAlpha( 50 )
		particle:SetStartSize( 5 )
		particle:SetEndSize( 120 )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
		particle:SetGravity( Vector(0,0,100) )
		particle:SetCollide( false )
	end

	local trace = util.TraceLine( {
		start = pos,
		endpos = pos - Vector(0,0,500),
		mask = MASK_SOLID_BRUSHONLY,
	} )

	if not trace or not trace.Hit then return end

	local VecCol = (render.GetLightColor( trace.HitPos + trace.HitNormal ) * 0.8 + Vector(0.17,0.15,0.1)) * 255
	for i = 1,24 do
		local particle = self.emitter:Add( self.MatSmoke[math.random(1,#self.MatSmoke)], trace.HitPos )
		
		if not particle then continue end

		local ang = i * 15
		local X = math.cos( math.rad(ang) )
		local Y = math.sin( math.rad(ang) )

		particle:SetVelocity( Vector(X,Y,0) * 2000 )
		particle:SetDieTime( math.Rand(0.5,1) )
		particle:SetAirResistance( 500 ) 
		particle:SetStartAlpha( 100 )
		particle:SetStartSize( 25 )
		particle:SetEndSize( 120 )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
		particle:SetGravity( Vector(0,0,150) + self.Dir * 2000 )
		particle:SetCollide( false )
	end

	local ply = LocalPlayer()

	if not IsValid( ply ) then return end

	local ViewEnt = ply:GetViewEntity()

	if not IsValid( ViewEnt ) then return end

	local Intensity = ply:InVehicle() and 5 or 50
	local Ratio = math.min( 250 / (ViewEnt:GetPos() - trace.HitPos):Length(), 1 )

	if Ratio < 0 then return end

	util.ScreenShake( trace.HitPos, Intensity * Ratio, 0.1, 0.5, 250 )
end

function EFFECT:Think()
	local bullet = LVS:GetBullet( self.ID )

	if not bullet then
		if self.emitter then
			self.emitter:Finish()
		end

		local StartPos = self.OldPos
		local EndPos = StartPos + self.Dir * 1000

		local trace = util.TraceLine( {
			start = StartPos,
			endpos = EndPos,
		} )

		if not trace.Hit then return false end

		local effectdata = EffectData()
		effectdata:SetOrigin( trace.HitPos )
		effectdata:SetStart( self.Dir )
		effectdata:SetEntity( trace.Entity )
		effectdata:SetNormal( trace.HitNormal )
		effectdata:SetSurfaceProp( trace.SurfaceProps )
		effectdata:SetMagnitude( 1 )
		util.Effect( "lvs_bullet_impact_ap", effectdata )

		return false
	end

	if not self.emitter then return true end

	local Pos = bullet:GetPos()

	self.Dir = bullet:GetDir()

	local Sub = self.OldPos - Pos
	local Dist = Sub:Length()
	local Dir = Sub:GetNormalized()

	local Vel = bullet.Velocity / 10

	for i = 0, Dist, 25 do
		local cur_pos = self.OldPos + Dir * i

		local VecCol = (render.GetLightColor( cur_pos ) * 0.8 + Vector(0.2,0.2,0.2)) * 255

		local particle = self.emitter:Add( self.MatSmoke[math.random(1,#self.MatSmoke)], cur_pos )
		
		if not particle then continue end
		particle:SetVelocity( -Dir * Vel + VectorRand() * 10 )
		particle:SetDieTime( math.Rand(0.05,1) )
		particle:SetAirResistance( 250 )
		particle:SetStartAlpha( 100 )
		particle:SetEndAlpha( 0 )

		particle:SetStartSize( 0 )
		particle:SetEndSize( 30 )

		particle:SetRollDelta( 1 )
		particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
		particle:SetCollide( false )
	end

	self.OldPos = Pos

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 3000 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )

	render.DrawBeam( endpos - dir * len, endpos + dir * len * 0.1, 32, 1, 0, Color( 100, 100, 100, 100 ) )
	render.DrawBeam( endpos - dir * len * 0.5, endpos + dir * len * 0.1, 16, 1, 0, Color( 255, 255, 255, 255 ) )

	render.SetMaterial( self.MatSprite ) 
	render.DrawSprite( endpos, 250, 250, Color( 100, 100, 100, 255 ) )
end

--PATH addons/lvs_base-main/lua/effects/lvs_tracer_green.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1600 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 3, 1, 0, Color( 225, 255, 225, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 10, 1, 0, Color( 150, 200, 150, 255 ) )
end

--PATH addons/lvs_base-main/lua/effects/lvs_tracer_white.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1600 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 3, 1, 0, Color( 255, 255, 255, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 10, 1, 0, Color( 150, 150, 150, 255 ) )
end

--PATH addons/lvs_cars_3027255911/lua/effects/lvs_tracer_yellow_small.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 500 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 4, 1, 0, Color( 255, 255, 125, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 8, 1, 0, Color( 125, 80, 0, 255 ) )
end

--PATH addons/____inventory/lua/itemstore/vgui/admin.lua:
local PANEL = {}

function PANEL:Init()
	self:SetTitle( itemstore.Translate( "admin_title" ) )
	self:SetSkin( "itemstore" )

	self.Scroll = vgui.Create( "onyx.ScrollPanel", self )
	self.Scroll:Dock( FILL )

	self.List = vgui.Create( "DListLayout", self.Scroll )
	self.List:Dock( FILL )
	for _, pl in ipairs( player.GetAll() ) do
		local b = self.List:Add( "onyx.Button" )
		b:SetText( pl:Name() )
		b:DockMargin( 0, 0, 0, 2 )

		function b.DoClick()
			local menu = vgui.Create('onyx.Menu')
			menu:SetPos( gui.MouseX(), gui.MouseY() )

			menu:AddOption( itemstore.Translate( "inventory" ), function()
				net.Start( "ItemStoreAdminInventory" )
				 	net.WriteEntity( pl )
				net.SendToServer()
			end )

			menu:AddOption( itemstore.Translate( "bank" ), function()
				net.Start( "ItemStoreAdminBank" )
					net.WriteEntity( pl )
				net.SendToServer()
			end )

			menu:Open()
		end
	end
end

vgui.Register( "ItemStoreAdmin", PANEL, "DFrame" )

--PATH addons/____inventory/lua/itemstore/cl_player.lua:
local meta = FindMetaTable( "Player" )

function meta:MoveItem( from_con_id, from_slot, to_con_id, to_slot )
	net.Start( "ItemStoreMove" )
		net.WriteUInt( from_con_id, 32 )
		net.WriteUInt( from_slot, 32 )
		net.WriteUInt( to_con_id, 32 )
		net.WriteUInt( to_slot, 32 )
	net.SendToServer()
end

function meta:UseItem( con_id, slot, ... )
	net.Start( "ItemStoreUse" )
		net.WriteUInt( con_id, 32 )
		net.WriteUInt( slot, 32 )
		net.WriteTable( { ... } )
	net.SendToServer()
end

function meta:UseItemWith( from_con_id, from_slot, to_con_id, to_slot )
	net.Start( "ItemStoreUseWith" )
		net.WriteUInt( from_con_id, 32 )
		net.WriteUInt( from_slot, 32 )
		net.WriteUInt( to_con_id, 32 )
		net.WriteUInt( to_slot, 32 )
	net.SendToServer()
end

function meta:DropItem( con_id, slot )
	net.Start( "ItemStoreDrop" )
		net.WriteUInt( con_id, 32 )
		net.WriteUInt( slot, 32 )
	net.SendToServer()
end

function meta:DestroyItem( con_id, slot )
	net.Start( "ItemStoreDestroy" )
		net.WriteUInt( con_id, 32 )
		net.WriteUInt( slot, 32 )
	net.SendToServer()
end

function meta:MergeItem( from_con_id, from_slot, to_con_id, to_slot )
	net.Start( "ItemStoreMerge" )
		net.WriteUInt( from_con_id, 32 )
		net.WriteUInt( from_slot, 32 )
		net.WriteUInt( to_con_id, 32 )
		net.WriteUInt( to_slot, 32 )
	net.SendToServer()
end

function meta:SplitItem( con_id, slot, amount )
	net.Start( "ItemStoreSplit" )
		net.WriteUInt( con_id, 32 )
		net.WriteUInt( slot, 32 )
		net.WriteUInt( amount, 16 )
	net.SendToServer()
end

hook.Add( "InitPostEntity", "ItemStoreRequestInventory", function()
	net.Start( "ItemStoreSyncInventory" )
	net.SendToServer()
end )

net.Receive( "ItemStoreSyncInventory", function()
	LocalPlayer().InventoryID = net.ReadUInt( 32 )
	itemstore.CreateContextInventory()
end )

net.Receive( "ItemStoreOpen", function()
	local id = net.ReadUInt( 32 )
	local name = net.ReadString()
	local hideinv = net.ReadBit() == 1

	local con = itemstore.containers.Get( id )
	if not con then return end

	local panel = vgui.Create( "ItemStoreContainerWindow" )

	panel:SetContainerID( id )
	panel:SetTitle( name )
	panel:Center()

	panel:MakePopup()

	if not hideinv then
		local inv = vgui.Create( "ItemStoreContainerWindow" )
		inv:SetContainerID( LocalPlayer().InventoryID )
		inv:SetTitle( itemstore.Translate( "inventory" ) )
		inv:ShowCloseButton( false )
		inv:MakePopup()
		inv:InvalidateLayout( true )

		local think = inv.Think
		function inv:Think()
			think( self )

			local x, y = panel:GetPos()
			inv:SetPos( panel:GetPos() + ( panel:GetWide() * 0.5 - inv:GetWide() * 0.5 ),
				 y + panel:GetTall() + 10 )
		end

		function panel:OnClose()
			inv:Close()
		end
	end
end )
--PATH addons/____plogs/lua/plogs_hooks/commands.lua:
--[[
addons/lgos/lua/plogs_hooks/commands.lua
--]]
plogs.Register('Команди', false)

if (SERVER) then
	concommand._Run = concommand._Run or concommand.Run
	function concommand.Run(pl, cmd, args, arg_str)
		if IsValid(pl) and pl:IsPlayer() and (cmd ~= nil) and (plogs.cfg.CommandBlacklist[cmd] ~= true) then
			plogs.PlayerLog(pl, 'Команди', pl:NameID() .. ' выполнил команду "' .. cmd .. '" аргумент "' .. (arg_str or table.concat(args, ' ')) .. '"', {
				['Name']	= pl:Name(),
				['SteamID']	= pl:SteamID(),
			})
		end
		return concommand._Run(pl, cmd, args, arg_str)
	end
end


--PATH addons/____plogs/lua/plogs_hooks/kills.lua:
--[[
addons/lgos/lua/plogs_hooks/kills.lua
--]]
plogs.Register('Вбивства', true, Color(255,0,0))

plogs.AddHook('PlayerDeath', function(pl, _, attacker)
	if IsValid(attacker) and attacker:IsPlayer() and not pl:IsBanned() then
		local weapon = ' с ' .. (IsValid(attacker:GetActiveWeapon()) and attacker:GetActiveWeapon():GetClass() or 'unknown')

		plogs.PlayerLog(pl, 'Вбивства', attacker:NameID() .. ' убил ' .. pl:NameID() .. weapon .. ((attacker.InSpawn and attacker:InSpawn() or pl.InSpawn and pl:InSpawn() or false) and ' в ікру' or '') .. ((attacker:IsHitman() and pl:HasHit()) and ' замовлення' or ''), {
			['Name'] = pl:Name(),
			['SteamID']	= pl:SteamID(),
			['Attacker Name'] = attacker:Name(),
			['Attacker SteamID'] = attacker:SteamID(),
		})
	end
end)


plogs.Register('Втрата', false)

plogs.AddHook('EntityTakeDamage', function(ent, dmginfo)
	if ent:IsPlayer() then
		local copy = {
	    	['Name'] = ent:Name(),
			['SteamID']	= ent:SteamID(),
	    }
	    local weapon = ''
	    local attacker = dmginfo:GetAttacker()
		if IsValid(attacker) then
			if attacker:IsPlayer() then
				copy['Attacker Name'] = attacker:Name()
				copy['Attacker SteamID'] = attacker:SteamID()
				weapon = ' с ' .. (IsValid(attacker:GetActiveWeapon()) and attacker:GetActiveWeapon():GetClass() or 'unknown')
				attacker = attacker:NameID()
			else
				if attacker.CPPIGetOwner and IsValid(attacker:CPPIGetOwner()) then
					weapon = ' с ' .. attacker:GetClass()
					attacker = attacker:CPPIGetOwner():NameID()
				else
					attacker = attacker:GetClass()
				end
			end
		else
			attacker = tostring(attacker)
		end
		plogs.PlayerLog(ent, 'Втрата', attacker .. ' did ' .. math.Round(dmginfo:GetDamage(), 0) .. ' damage to ' .. ent:NameID() .. weapon, copy)
	end
end)


--PATH addons/____esclib/lua/elib/essentials/libs/esc_fonts.lua:
local floor = math.floor

--------------------
--# FONT MANAGER #--
--------------------
-- EXAMPLE:
-- esclib:SetFontName("shop")
-- esclib:Font(20, 500) -- es_shop_20_500
-- esclib:Font(23, 500) -- es_shop_23_500

-- esclib:SetFontName("jobs")
-- esclib:SetFont("Roboto")
-- esclib:Font(20, 500) -- es_jobs_20_500
-- esclib:ResetFont() -- returns font settings to default


-----------------
--# FUNCTIONS #--
-----------------
esclib.fonts = esclib.fonts or {}
esclib.fonts.heights = esclib.fonts.heights or {}
esclib.fonts.list = esclib.fonts.list or {}
esclib.fonts.prefix = "es_"
esclib.fonts.default = "Tahoma"
esclib.fonts.curname = "newfont"
esclib.fonts.adaptives = esclib.fonts.adaptives or {}


local defaultfont = esclib.fonts.default

function esclib.fonts:CreateNew(file_fontname, fontname, size, weight, fontdata)
	local size = size or 15
	local weight = weight or 500
	if fontdata then
		size = fontdata.size or size
		weight = fontdata.weight or weight
	end

	local target_fontname = self.prefix..fontname.."_"..size.."_"..weight

	local target_fontdata = {
		font = file_fontname,
		size = size,
		weight = weight,
		extended = true
	}

	if fontdata then
		esclib:SafeMerge(target_fontdata, fontdata, true)
	end

	if not self.list[target_fontname] then
		surface.CreateFont(target_fontname, target_fontdata)
		esclib.fonts.heights[target_fontname] = draw.GetFontHeight(target_fontname)
		self.list[target_fontname] = true
	end

	return target_fontname
end


function esclib:Font(size, weight, fontdata)
	local target_fontname = self.fonts.prefix..self.fonts.curname.."_"..size.."_"..weight

	if self.fonts.list[target_fontname] ~= nil then
		return target_fontname
	end

	return self.fonts:CreateNew(self.fonts.default, self.fonts.curname, size, weight, fontdata)
end

function esclib:AdaptiveSize(base_size, screen_size)
	local base_size = base_size or 18
	local base_scrh = screen_size or 1080
	local dif = (ScrH() or base_scrh) / base_scrh
	return base_size * dif
end

--RegisterAdaptiveFont("esclib")
--AdaptiveFont("esclib") -> 
function esclib:RegisterAdaptiveFont(name)
	esclib.fonts.adaptives[name] = {
		["prefix"] = self.fonts.prefix,
		["cur_name"] = self.fonts.curname,
		["file_font"] = self.fonts.default, --we need to save it
	}
	return adaptive_name
end

function esclib:AdaptiveFont(name, base_size, weight, fontdata)
	local adaptive = esclib.fonts.adaptives[name]
	if not adaptive then return end

	local size = floor(self:AdaptiveSize(base_size))+1
	
	local target_fontname = adaptive["prefix"]..adaptive["cur_name"].."_"..size.."_"..weight
	if self.fonts.list[target_fontname] ~= nil then
		return target_fontname
	end
	self.fonts:CreateNew(adaptive["file_font"], adaptive["cur_name"], size, weight, fontdata)

	return target_fontname
end

function esclib.fonts:GetAll()
	return self.list
end

function esclib:SetFontName(name)
	self.fonts.curname = isstring(name) and name or "newfont"
end


function esclib:SetFont(name)
	self.fonts.default = isstring(name) and name or defaultfont
end


function esclib:ResetFont()
	self.fonts.default = defaultfont
end


function esclib:SetFontPrefix(name)
	self.fonts.prefix = isstring(name) and name or defaultfont
end


concommand.Add("esclib_getfonts",function()
	local fonts = table.GetKeys(esclib.fonts:GetAll())
	if #fonts ~= 0 then
		PrintTable(fonts)
	else
		print("No fonts.")
	end
end)



-------------
--# FONTS #--
-------------	
esclib:SetFontName("esclib")
esclib:SetFont("Amsterdam")
esclib:RegisterAdaptiveFont("esclib")
--PATH addons/____esclib/lua/elib/essentials/libs/esc_utf8.lua:
--THIS SECTION UNDER DEVELOPMENT IT MAY BE UNACCURATE

esclib.utf8 = esclib.utf8 or {}
eutf8 = esclib.utf8


local function strRelToAbsChar(str, pos)
	if not pos then return 0 end
	pos = pos < 0 and math.max(pos + #str + 1, 0) or pos
	return pos
end

local function getNextByte(str, i)
	local c = string.byte(str, i)
	if c and c > 0 and c <= 127 then
		return 1
	elseif c and c >= 194 and c <= 223 then
		return 2
	elseif c and c >= 224 and c <= 239 then
		return 3
	elseif c and c >= 240 and c <= 244 then
		return 4
	end
	return 1  -- default value if byte value is out of range or i > #str
end

local function getCharSize(str, i)
    local prefix = string.byte(str, i)
    if prefix <= 0x7F then
        return 1
    elseif prefix <= 0xDF then
        return 2
    elseif prefix <= 0xEF then
        return 3
    else
        return 4
    end
end

local function getChar(str, i, size)
    return string.sub(str, i, i + size - 1)
end

function eutf8:reverse(str)
    local chars = {}
    local i = 1
    while i <= #str do
        local size = getCharSize(str, i)
        chars[#chars + 1] = getChar(str, i, size)
        i = i + size
    end
    local buffer = {}
    for i = #chars, 1, -1 do
        buffer[#buffer + 1] = chars[i]
    end
    return table.concat(buffer)
end

function eutf8.getLastWord(str)
    local lastWord = str:match("[%S%p]+$")
    return lastWord
end

function eutf8.sub(s,i,j)
    i = i or 1
    j = j or -1
    if i<1 or j<1 then
       local n = utf8.len(s)
       if not n then return nil end
       if i<0 then i = n+1+i end
       if j<0 then j = n+1+j end
       if i<0 then i = 1 elseif i>n then i = n end
       if j<0 then j = 1 elseif j>n then j = n end
    end
    if j<i then return "" end
    i = utf8.offset(s,i)
    j = utf8.offset(s,j+1)
    if i and j then return s:sub(i,j-1)
       elseif i then return s:sub(i)
       else return ""
    end
end

--PATH addons/____esclib/lua/elib/essentials/esc_text.lua:
local insert, byte, min = table.insert, string.byte, math.min
local gsub, ipairs = string.gsub, ipairs
local tonum = {[true] = 0, [false] = 1}

----------------------
--# TEXT FUNCTIONS #--
----------------------
esclib.text = {}
function esclib.text:Multiline(text, font, mWidth, interval)
	local mWidth = mWidth or esclib.scrw
	local interval = interval or 2

	local result = {}
	result.lines = {}

	surface.SetFont(font)
	text = text:gsub("\n"," \\n ")
	local fontw = surface.GetTextSize(text)
	local fonth = draw.GetFontHeight(font)
	
	local buffer = { }

	local maxsize = 0
	for word in string.gmatch(text, "%S+") do
		local temp_text = (string.gsub((table.concat(buffer, " ").." "..word),"\\n","")):Trim()

		local w,h = surface.GetTextSize(temp_text)
		local newline = string.find(word,"\\n")
		if maxsize < w then maxsize = w end
		if (w > mWidth) or (newline) then
			table.insert(result.lines, table.concat(buffer, " "))

			buffer = { }
		end
		if not newline then
			table.insert(buffer, word)
		end
	end

	
	if #buffer > 0 then
		table.insert(result.lines, table.concat(buffer, " "))
	end

	local width = math.min(maxsize,mWidth)
	local height = (#result.lines*fonth)+(interval*#result.lines)


	result.font = font
	result.spacing = fonth+interval
	result.width = width
	result.height = height
	
	return result
end

function esclib.text:MultilineToString(multiline_data)
	return table.concat( multiline_data.lines, "\n" )
end

function esclib.text:DrawMultiline(multiline_data, x, y, color, alignX, alignY)
	for i,line in ipairs(multiline_data.lines) do
		draw.SimpleText(line, multiline_data.font, x, y + (i - 1) * multiline_data.spacing, color, alignX, alignY)
	end
end

function esclib.text:DrawMultilineShadow(multiline_data, x, y, color, alignX, alignY, offsetx)
	local offsetx = offsetx or 1
	for i,line in ipairs(multiline_data.lines) do
		draw.SimpleText(line, multiline_data.font, x+offsetx, y + (i - 1) * multiline_data.spacing+offsetx, color_black, alignX, alignY)
		draw.SimpleText(line, multiline_data.font, x, y + (i - 1) * multiline_data.spacing, color, alignX, alignY)
	end
end

function esclib.text:Capitalize(str)
    return (str:gsub("^%l", string.upper))
end

--example: "[{rank}] {nickname}:", {rank = "hello", nickname = "NickName"}
function esclib.text:KeyFormat(formatString, replacements)
    for key, value in pairs(replacements) do
		value = value:gsub("%%", "%%%%")
        formatString = formatString:gsub("{" .. key .. "}", value)
    end
    return formatString
end

-- Example:
-- local tbl = esclib.text:MatchSplit("<hello>lorem<world> imsulum", "<(.-)>")
-- PrintTable(tbl) =>
-- [1]:
-- 	["matched"]	=	true
-- 	["value"]	=	<hello>
-- [2]:
-- 	["value"]	=	lorem
-- [3]:
-- 	["matched"]	=	true
-- 	["value"]	=	<world>
-- [4]:
-- 	["value"]	=	 imsulum
function esclib.text:MatchSplit(str, pattern)
	if not str then return end
	if not pattern then return end

	--find start pattern
	local startpos, endpos, text = string.find(str, pattern)
	if not startpos then return { {["value"] = str} } end --if pattern not finded

	local result = {}

	while (startpos~=nil) do
		--add not matched text
		local clipped = string.sub(str,1, startpos-1)
		if clipped ~= "" then
			table.insert(result, {["value"] = clipped})
		end

		--add matched text
		table.insert(result, {["matched"] = true, ["value"] = string.sub(str,startpos, endpos)})

		str = string.sub(str, endpos+1) --cut already added text
		startpos, endpos, text = string.find(str, pattern) --find next values
	end

	--add remaining text
	if str ~= "" then
		table.insert(result, {["value"] = str})
	end

	return result
end

--https://github.com/Be1zebub/Small-GLua-Things/blob/dfed7255bf03beb3617e39abe3810266a71887fa/string_search.lua#L8
function esclib.text.distance(str1, str2) -- levenshtein
    local len1, len2 = #str1, #str2
    local char1, char2, distance = {}, {}, {}
    gsub(str1, ".", function (c) insert(char1, byte(c)) end)
    gsub(str2, ".", function (c) insert(char2, byte(c)) end)
    for i = 0, len1 do
        distance[i] = {[0] = i}
    end
    for i = 0, len2 do distance[0][i] = i end
    for i = 1, len1 do
        for j = 1, len2 do
            distance[i][j] = min(
                distance[i-1][j] + 1,
                distance[i][j-1] + 1,
                distance[i-1][j-1] + tonum[char1[i] == char2[j]]
            )
        end
    end
    return distance[len1][len2]
end
--PATH addons/____esclib/lua/elib/vgui/esc_frame.lua:
local x = esclib.scrw
local y = esclib.scrh

local PANEL={}

AccessorFunc( PANEL, "m_bDraggable",		"Draggable",		FORCE_BOOL )
AccessorFunc( PANEL, "m_bScreenLock",		"ScreenLock",		FORCE_BOOL )
AccessorFunc( PANEL, "m_bSizable",			"Sizable",			FORCE_BOOL )
AccessorFunc( PANEL, "ColorThink",			"ColorThink",		FORCE_BOOL )
AccessorFunc( PANEL, "AutoRestoreColor",	"AutoRestoreColor",	FORCE_BOOL )

AccessorFunc( PANEL, "m_iMinWidth",			"MinWidth",			FORCE_NUMBER )
AccessorFunc( PANEL, "m_iMinHeight",		"MinHeight",		FORCE_NUMBER )

AccessorFunc( PANEL, "gain_frac",			"GainFraction",		FORCE_NUMBER )
AccessorFunc( PANEL, "restore_frac",		"RestoreFraction",	FORCE_NUMBER )
AccessorFunc( PANEL, "grad_col", 			"GradientColor", 	FORCE_COLOR)
AccessorFunc( PANEL, "target_grad_col", 	"TargetGradientColor", 	FORCE_COLOR)
AccessorFunc( PANEL, "color",				"Color",				FORCE_COLOR)
AccessorFunc( PANEL, "color_border",		"BorderColor",				FORCE_COLOR)

function PANEL:Init()

	self.skin = esclib.addon:GetCurrentSkin()
	self.colors = self.skin.colors 

	self:SetSize(400,400)
	self.color = self.colors.frame.bg or Color(13,13,13)
	self.color_border = self.colors.frame.accent
	self.roundsize = self.skin.roundsize or 8

	self.title = "Window"
	self.titlexoffset = 5
	self.titlecolor = self.colors.frame.bg or Color(255,255,255)
	self.titlealignx = TEXT_ALIGN_LEFT
	self.titlealigny = TEXT_ALIGN_CENTER
	self.titlefont = esclib:AdaptiveFont("esclib", 24, 500)
	self.paintbg = true
	self.titlepaint = true
	

	self.titlecolor_def = esclib.util:TextOnBG(self.titlecolor, self.colors.default.white, self.colors.default.black)

	--GRADIENT
	local grad_col = table.Copy(self.colors.frame.accent)
    grad_col.a = 255
	self.target_grad_col = grad_col
	self.grad_col_copy = grad_col
	self:SetGainFraction(0.01)
	self:SetRestoreFraction(0.05)
	self:SetGradientColor(grad_col)
	self.bottom_gradient = esclib:GetMaterial("bottom_gradient.png")
	self.restore_time = 0

	--CONTENT
	if not IsValid(self.content) then
		self.content = vgui.Create( "EditablePanel", self )
	end 
	self.content.Paint = function(self, w, h)
		--for override
	end

	self:PerformLayout()

	if IsValid(self.titlepanel) then self.titlepanel:Remove() end
	self.titlepanel = vgui.Create("DDragBase",self)
	self.titlepanel:SetMouseInputEnabled(false)
	self.titlepanel:SetSize(self:GetWide(), self.titlesize.height)

	--closebutton
	self.closebutton = vgui.Create("DButton",self)
	self.closebutton:SetText( "" )
	local close_icon = esclib:GetMaterial("cross.png")
	function self.closebutton.Paint(_,w,h)
		local hover = self.closebutton:IsHovered()
		local color = hover and (self.colors.default.red) or self.titlecolor_def
		esclib.draw:MaterialCentered(w*0.5,h*0.5,h*0.15, color, close_icon)
		-- draw.SimpleText("r",
		-- 	"Marlett",
		-- 	w*0.5,
		-- 	h*0.5,
		-- 	color, 
		-- 	TEXT_ALIGN_CENTER,
		-- 	TEXT_ALIGN_CENTER
		-- )
		-- draw.RoundedBox(0,0,0,w,h,Color(255,0,0))
	end
	function self.closebutton.DoClick() self:Close() end

	self:SetDraggable( true )
	self:SetSizable( false )
	self:SetMinWidth( 100 )
	self:SetMinHeight( 50 )
	self:SetScreenLock( false )
end

function PANEL:EnableCloseButton(bool)
	self.closebutton:SetVisible(bool)
end

function PANEL:SetGradientColor(clr)
	self.grad_col = table.Copy(clr)
	self.grad_col_copy = table.Copy(self.grad_col)
	if self.ColorThink then
		self.target_grad_col = grad_col
	end
end

function PANEL:SetTargetGradientColor(clr)
	self.target_grad_col = clr
	self.restore_time = CurTime()+0.05
end

-- USER INPUT
function PANEL:SetTitle(title,color,font,alignx,aligny)
	if color then
		if IsColor(color) then self.titletextcolor = color end
	end
	if font then
		self.titlefont = font
	end
	if alignx then
		self.titlealignx = alignx
	end
	if aligny then
		self.titlealigny = aligny
	end
	if title then
		self.title = title
	end
	self:PerformLayout()
end

function PANEL:SetIcon(icon)
	self.icon = icon
	self.titlexoffset = self.titlepanel:GetTall()
end

function PANEL:GetTitle() return self.title end

function PANEL:SetBackgroundColor(col) 
	if IsColor(col) then self.color = col end 
end

function PANEL:GetColor() return self.color end


function PANEL:SetTitleColor(col)
	if IsColor(col) then self.titlecolor = col end
end

function PANEL:GetTitleColor() return self.titlecolor end

function PANEL:GetContent() return self.content end
function PANEL:GetTitlePanel() return self.titlepanel end

function PANEL:SetRoundSize(size)
	self.roundsize = size
	self:PerformLayout()
end

function PANEL:Close(callback)
	self:OnClose(callback)
end

function PANEL:OnClose(callback)
	--
end

function PANEL:PerformLayout()
	surface.SetFont(self.titlefont)
	local wide, height = surface.GetTextSize(self.title)

	self.titlesize = {
		wide = wide+2,
		height = height+20
	}

	self.content:SetSize(self:GetWide(),self:GetTall()-self.titlesize.height)
	self.content:SetPos(0,self.titlesize.height)
	if IsValid(self.titlepanel) then
		self.titlecolor_def = esclib.util:TextOnBG(self.titlecolor, self.colors.default.black, self.colors.default.white)
		self.titlepanel:SetSize(self:GetWide(), self.titlesize.height)

		self.closebutton:SetSize(self.titlepanel:GetTall(),self.titlepanel:GetTall())
		local ost = self:GetWide()-self.closebutton:GetWide()
		self.closebutton:SetPos(ost,0)
	end

	self:DockPadding(0, self.titlesize.height, 0, 0)
end



--MOUSE DRAGGING
function PANEL:OnMousePressed()
	self:OnPress()
	local screenX, screenY = self:LocalToScreen( 0, 0 )
	if ( self.m_bSizable && gui.MouseX() > ( screenX + self:GetWide() - 20 ) && gui.MouseY() > ( screenY + self:GetTall() - 20 ) ) then
		self.Sizing = { gui.MouseX() - self:GetWide(), gui.MouseY() - self:GetTall() }
		self:MouseCapture( true )
		return
	end

	if ( self:GetDraggable() && gui.MouseY() < ( screenY + 24 ) ) then
		self.Dragging = { gui.MouseX() - self.x, gui.MouseY() - self.y }
		self:MouseCapture( true )
		self:OnStartDragging(self:GetX(),self:GetY())
		return
	end
end

function PANEL:OnMouseReleased()
	self:OnUnpress()
	if self.Dragging then
		self.Dragging = nil
		self:OnEndDragging(self:GetX(),self:GetY())
	end
	if self.Sizing then
		self.Sizing = nil
		self:InvalidateChildren(true)
	end
	self:MouseCapture( false )
end

function PANEL:OnDragging(newx,newy)
	--for override
end

function PANEL:OnStartDragging(x,y)
	--for override
end

function PANEL:OnEndDragging(newx,newy)
	--for override
end

function PANEL:OnPress()
	--for override
end

function PANEL:OnUnpress()
	--for override
end

function PANEL:Think()

	--Color think
	if self.ColorThink then
		local restoring = self.restore_time > CurTime()
		--gain
		if esclib.util:ColorDiff(self.grad_col, self.target_grad_col) > 0 then
			esclib.util:ColorLerp(restoring and self.gain_frac or self.restore_frac , self.grad_col, self.target_grad_col)
		end

		--restore
		if self.AutoRestoreColor and esclib.util:ColorDiff(self.target_grad_col, self.grad_col_copy) > 0 then
			self.target_grad_col = self.grad_col_copy
		end
	end

	local mousex = math.Clamp( gui.MouseX(), 1, esclib.scrw - 1 )
	local mousey = math.Clamp( gui.MouseY(), 1, esclib.scrh - 1 )

	if ( self.Dragging ) then

		local x = mousex - self.Dragging[1]
		local y = mousey - self.Dragging[2]

		-- Lock to screen bounds if screenlock is enabled
		if ( self:GetScreenLock() ) then

			x = math.Clamp( x, 0, esclib.scrw - self:GetWide() )
			y = math.Clamp( y, 0, esclib.scrh - self:GetTall() )

		end

		self:OnDragging(newx,newy)
		self:SetPos( x, y )

	end

	if ( self.Sizing ) then

		local x = mousex - self.Sizing[1]
		local y = mousey - self.Sizing[2]
		local px, py = self:GetPos()

		if ( x < self.m_iMinWidth ) then x = self.m_iMinWidth elseif ( x > esclib.scrw - px && self:GetScreenLock() ) then x = esclib.scrw - px end
		if ( y < self.m_iMinHeight ) then y = self.m_iMinHeight elseif ( y > esclib.scrh - py && self:GetScreenLock() ) then y = esclib.scrh - py end

		self:SetSize( x, y )
		return

	end

	local screenX, screenY = self:LocalToScreen( 0, 0 )
	if ( self.Hovered && self.m_bSizable && mousex > ( screenX + self:GetWide() - 20 ) && mousey > ( screenY + self:GetTall() - 20 ) ) then
		self:SetCursor( "sizenwse" )
		return
	end

	if ( self.Hovered && self:GetDraggable() && mousey < ( screenY + 24 ) ) then
		self:SetCursor( "sizeall" )
		return
	end

	self:SetCursor( "arrow" )

	if ( self.y < 0 ) then
		self:SetPos( self.x, 0 )
	end
end

function PANEL:PaintTitle(w,h)
	if not self.titlepaint then return end
	--Title bg
	-- draw.RoundedBoxEx(self.roundsize,0,0,w,self.titlesize.height, self.titlecolor, true,true,false,false)

	if self.icon then
		esclib.draw:MaterialCentered(h*0.3+15,h*0.5,h*0.3,self.titlecolor_def,self.icon)
	end

	draw.SimpleText(self.title,
		self.titlefont,
		(self.titlealignx == TEXT_ALIGN_CENTER) and (w*0.5) or self.titlexoffset+5,
		(self.titlealigny == TEXT_ALIGN_CENTER) and (self.titlesize.height*0.5) or 0,
		self.titlecolor_def,
		self.titlealignx,
		self.titlealigny)
end

--BACKGROUND
function PANEL:PaintBG(w,h)
	if not self.titlepanel then return end
	local sizey = self.titlepanel:GetTall()
	-- draw.RoundedBoxEx(self.roundsize,0,sizey,w,h-sizey,self.color,false,false,true,true)

	draw.RoundedBox(16,0,0,w,h, self.color_border)
	draw.RoundedBox(14,2,2,w-4,h-4, self.color)
end

function PANEL:Paint(w,h)
	--background
	esclib.draw:Mask(function()
		if not self.poly then
			self.poly = esclib.util:PrecacheRoundedPoly(0, 0, w, h, 16, 6)
		end
		draw.NoTexture();
		surface.SetDrawColor( color_white )
		surface.DrawPoly( self.poly )
	end, 
	function()
		if self.PaintBG then self:PaintBG(w,h) end
		esclib.draw:Material(-w*0.5, 0, w*2, h, self.grad_col, self.bottom_gradient)
		self:PaintTitle(self.titlepanel:GetWide(),self.titlepanel:GetTall())
	end,false)


	local posx,posy = self:GetPos()
	local mx,my = input.GetCursorPos()
	if (mx >= posx) and (mx <= posx+w) then
		if (my >= posy) and (my <= posy+h) then
			self.Hovered = true
		else
			self.Hovered = false
		end
	else
		self.Hovered = false
	end

 	
	return true
end

vgui.Register( "esclib.frame", PANEL );
--PATH addons/____esclib/lua/elib/vgui/esc_scrollpanel.lua:
local min = math.min
local max = math.max
local PANEL = {}

AccessorFunc( PANEL, "Padding", "Padding" )
AccessorFunc( PANEL, "ScrollSpeed", "ScrollSpeed", FORCE_NUMBER)
AccessorFunc( PANEL, "pnlCanvas", "Canvas" )

function PANEL:Init()
	self.pnlCanvas = vgui.Create( "Panel", self )
	self.pnlCanvas.OnMousePressed = function( self, code ) self:GetParent():OnMousePressed( code ) end
	self.pnlCanvas:SetMouseInputEnabled( true )
	-- self.pnlCanvas:Dock(FILL)
	-- self.pnlCanvas.PerformLayout = function( pnl )
	-- 	self:PerformLayoutInternal()
	-- 	self:InvalidateParent()
	-- end

	self.VBar = vgui.Create( "esclib.scrollbar", self )
	self.VBar:Dock( RIGHT )

	self:SetPadding( 0 )
	self:SetMouseInputEnabled( true )
	self:SetScrollSpeed(12)

	self:SetPaintBackgroundEnabled( false )
	self:SetPaintBorderEnabled( false )
	self:SetPaintBackground( false )
end

function PANEL:ScrollToBottom()
	self:GetVBar():ScrollToBottom()
end

function PANEL:SetScrollSpeed(val)
	self.ScrollSpeed = val
	self:GetVBar():SetSpeed(val)
end

function PANEL:AddItem( pnl )
	pnl:SetParent( self:GetCanvas() )
end

function PANEL:OnChildAdded( child )
	self:AddItem( child )
end

function PANEL:SizeToContents()
	self:SetSize( self.pnlCanvas:GetSize() )
end

function PANEL:GetVBar()
	return self.VBar
end

function PANEL:GetCanvas()
	return self.pnlCanvas
end

function PANEL:InnerWidth()
	return self:GetCanvas():GetWide()
end

function PANEL:Rebuild()
	self:GetCanvas():SizeToChildren( false, true )
	if ( self.m_bNoSizing && self:GetCanvas():GetTall() < self:GetTall() ) then
		self:GetCanvas():SetPos( 0, ( self:GetTall() - self:GetCanvas():GetTall() ) * 0.5 )
	end
end

function PANEL:OnMouseWheeled( dlta )
	return self.VBar:OnMouseWheeled( dlta )
end

function PANEL:OnVScroll( iOffset )
	self.pnlCanvas:SetPos( 0, iOffset )
end

function PANEL:ScrollToChild( panel, animate )
	self:InvalidateLayout( true )
	local x, y = self.pnlCanvas:GetChildPosition( panel )
	local w, h = panel:GetSize()
	y = max(y - h, 0)
	if animate then
		self.VBar:AnimateTo( min(y, self.VBar.CanvasSize), 0.2, 0, 0.1 )
	else 
		self.VBar:SetScroll( min(y, self.VBar.CanvasSize) )
	end
end

function PANEL:PerformLayoutInternal()
	local Tall = self.pnlCanvas:GetTall()
	local Wide = self:GetWide()
	local padding = self.VBar:IsVisible() and self.Padding or 0
	local YPos = 0

	self:Rebuild()

	self.VBar:SetUp( self:GetTall(), self.pnlCanvas:GetTall() )
	YPos = self.VBar:GetOffset()

	if ( self.VBar.Enabled ) then Wide = Wide - self.VBar:GetWide() end

	self.pnlCanvas:SetPos( 0, YPos )
	self.pnlCanvas:SetWide( Wide-padding )

	self:Rebuild()

	if ( Tall ~= self.pnlCanvas:GetTall() ) then
		self.VBar:SetScroll( self.VBar:GetScroll() )
	end

end

function PANEL:PerformLayout()
	self:PerformLayoutInternal()
end

function PANEL:Clear()
	return self.pnlCanvas:Clear()
end

derma.DefineControl( "esclib.scrollpanel", "", PANEL, "DPanel" )
--PATH addons/____esclib/lua/elib/vgui/esc_slider.lua:
local PANEL = {}

AccessorFunc(PANEL, "iDecimals", "Decimals", FORCE_NUMBER)
AccessorFunc(PANEL, "iScrollStep", "ScrollStep", FORCE_NUMBER)

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")

	local clr = esclib.addon:GetColors()
	self.clr = clr
	self.min = 0
	self.max = 1
	self.iDecimals = 2
	self.iScrollStep = 1
	self.fraction = 0

	self.Font = esclib:AdaptiveFont("esclib", 10, 500)

	local knob = self.Knob
	knob:SetHeight(self:GetTall())
	function knob:Paint(w,h) end

	self.OnCursorMoved = function( panel, x, y )
		if ( not self.Dragging and not self.Knob.Depressed ) then return end

		local oldx, oldy = x,y

		local w, h = self:GetSize()
		local iw, ih = self.Knob:GetSize()

		if ( self.m_bTrappedInside ) then

			w = w - iw
			h = h - ih

			x = x - iw * 0.5
			y = y - ih * 0.5

		end

		x = math.Clamp( x, 0, w ) / w
		y = math.Clamp( y, 0, h ) / h

		if ( self.m_iLockX ) then x = self.m_iLockX end
		if ( self.m_iLockY ) then y = self.m_iLockY end

		x, y = self:TranslateValues( x, y )

		self:SetSlideX( x )
		self:SetSlideY( y )

		if (oldx ~= x) or (oldy ~= y) then
			panel:OnValueChanged(panel:GetValue())
		end
	end
end

--Value manipulation
function PANEL:SetMin(num)
	self.min = math.Clamp(num or 0, -math.huge, self.max)
end

function PANEL:GetMin()
	return self.min
end

function PANEL:SetMax(num)
	self.max = math.Clamp(num or 0, self.min, math.huge)
end

function PANEL:GetMax()
	return self.max
end

function PANEL:SetValue(num)
	self:SetSlideX( math.Clamp( (num - self.min) / (self.max - self.min), 0, 1) )
end

function PANEL:GetValue()
	local val = self:GetSlideX() * (self.max - self.min) + self.min
	return val - val%(1 / math.pow(10, self.iDecimals))
end

function PANEL:OnValueChanged(x)
	-- rewrite me pls
end



function PANEL:Paint(w,h)
	local hovered = self:IsHovered() or self.Knob:IsHovered()
	local editing = self:IsEditing()


	local offy = h*0.2
	draw.RoundedBox(4,0,0,w,h,self.clr.button.hover)

	if hovered then
		local mx, my = input.GetCursorPos()
		mx, my = self:ScreenToLocal(mx,my)

		draw.RoundedBox(0,0,offy,mx,h-offy*2, self.clr.button.main)
	end

	self.fraction = Lerp(0.2, self.fraction, self:GetSlideX())
	draw.RoundedBox(8,0,offy,w*self.fraction,h-offy*2, (hovered or editingww) and self.clr.button.accent_hover or self.clr.button.accent)

	local val = self:GetValue() or 0
	local textw,texth = esclib.util:TextSize(val, self.Font)

	if editing then
		local x = w*self.fraction
		if ((x + textw + 10) > w) then
			draw.RoundedBox(0,x-15-textw,0, textw+10, h, self.clr.frame.bg)
			esclib.draw:ShadowText(val, self.Font, x-10, h*0.5, self.clr.button.text,  TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER,1)
		else
			draw.RoundedBox(0,x+5,0, textw+10, h, self.clr.frame.bg)
			esclib.draw:ShadowText(val, self.Font, x+10, h*0.5, self.clr.button.text,  TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER,1)
		end
	end
end

function PANEL:OnMouseWheeled( delta )
	self:SetSlideX(math.Clamp(self:GetSlideX()+(delta*self.iScrollStep / (self.max-self.min)),0,1))
	self:OnValueChanged(self:GetValue())
end

function PANEL:OnSizeChanged(w,h)
	self.Knob:SetHeight(h)
end

derma.DefineControl("esclib.slider", "just a slider", PANEL, "DSlider")
--PATH addons/____echat/lua/echat/vgui/echat_dmenu.lua:
local PANEL = {}

AccessorFunc( PANEL, "m_bDeleteSelf",		"DeleteSelf" )
AccessorFunc( PANEL, "m_iMinimumWidth",		"MinimumWidth" )
AccessorFunc( PANEL, "m_bDrawColumn",		"DrawColumn" )
AccessorFunc( PANEL, "m_iMaxHeight",		"MaxHeight" )
AccessorFunc( PANEL, "m_FontName", "Font", FORCE_STRING)

AccessorFunc( PANEL, "m_pOpenSubMenu",		"OpenSubMenu" )

function PANEL:Init()
	self.clr = echat.addon:GetColors()

	self:SetIsMenu( true )
	self:SetPaintBackground( true )
	self:SetMinimumWidth( 100 )
	self:SetDrawOnTop( true )
	self:SetMaxHeight( ScrH() * 0.9 )
	self:SetDeleteSelf( true )
	self:SetFont(echat:AdaptiveFont("echat", 16, 500))
	self:SetScrollSpeed(10)

	self:GetVBar():SetColor(self.clr.main.scrollbar)

	self:SetPadding( 0 )

	-- Automatically remove this panel when menus are to be closed
	RegisterDermaMenuForClose( self )

end

function PANEL:SetFont(font)
	self.m_FontName = font
	self:SetFontInternal(font)
end

function PANEL:AddPanel( pnl )

	self:AddItem( pnl )
	pnl.ParentMenu = self

end

function PANEL:AddOption( strText, funcFunction )

	local pnl = vgui.Create( "echat.menu.option", self )
	pnl:SetMenu( self )
	pnl:SetText( strText )
	pnl:SetFont(self:GetFont())
	pnl:SetTextColor(self.clr.main.text)
	local bg_col = self.clr.main.bg2
	if ( funcFunction ) then pnl.DoClick = funcFunction end

	self:AddPanel( pnl )

	return pnl

end

function PANEL:AddCVar( strText, convar, on, off, funcFunction )

	local pnl = vgui.Create( "DMenuOptionCVar", self )
	pnl:SetMenu( self )
	pnl:SetText( strText )
	if ( funcFunction ) then pnl.DoClick = funcFunction end

	pnl:SetConVar( convar )
	pnl:SetValueOn( on )
	pnl:SetValueOff( off )

	self:AddPanel( pnl )

	return pnl

end

function PANEL:AddSpacer( strText, funcFunction )

	local pnl = vgui.Create( "DPanel", self )
	pnl.Paint = function( p, w, h )
		derma.SkinHook( "Paint", "MenuSpacer", p, w, h )
	end

	pnl:SetTall( 1 )
	self:AddPanel( pnl )

	return pnl

end

function PANEL:AddSubMenu( strText, funcFunction )

	local pnl = vgui.Create( "DMenuOption", self )
	local SubMenu = pnl:AddSubMenu( strText, funcFunction )

	pnl:SetText( strText )
	if ( funcFunction ) then pnl.DoClick = funcFunction end

	self:AddPanel( pnl )

	return SubMenu, pnl

end

function PANEL:Hide()

	local openmenu = self:GetOpenSubMenu()
	if ( openmenu ) then
		openmenu:Hide()
	end

	self:SetVisible( false )
	self:SetOpenSubMenu( nil )

end

function PANEL:OnClose()
	--for rewrite
end

function PANEL:Close()
	self:OnClose()
	self:Remove()
end

function PANEL:OpenSubMenu( item, menu )

	-- Do we already have a menu open?
	local openmenu = self:GetOpenSubMenu()
	if ( IsValid( openmenu ) && openmenu:IsVisible() ) then

		-- Don't open it again!
		if ( menu && openmenu == menu ) then return end

		-- Close it!
		self:CloseSubMenu( openmenu )

	end

	if ( not IsValid( menu ) ) then return end

	local x, y = item:LocalToScreen( self:GetWide(), 0 )
	menu:Open( x - 3, y, false, item )

	self:SetOpenSubMenu( menu )

end

function PANEL:CloseSubMenu( menu )

	menu:Hide()
	self:SetOpenSubMenu( nil )

end

function PANEL:Paint( w, h )
	if ( not self:GetPaintBackground() ) then return end

	draw.RoundedBoxEx(8,0,0,w,h-1,self.clr.main.text_entry, true, true, false, false)

	return true
end

function PANEL:ChildCount()
	return #self:GetCanvas():GetChildren()
end

function PANEL:GetChild( num )
	return self:GetCanvas():GetChildren()[ num ]
end

function PANEL:PerformLayout( w, h )

	local w = self:GetMinimumWidth()

	-- Find the widest one
	for k, pnl in ipairs( self:GetCanvas():GetChildren() ) do

		pnl:InvalidateLayout( true )
		w = math.max( w, pnl:GetWide() )

	end

	self:SetWide( w )

	local y = 2 -- for padding

	for k, pnl in ipairs( self:GetCanvas():GetChildren() ) do

		pnl:SetWide( w )
		pnl:SetPos( 2, y )
		pnl:InvalidateLayout( true )

		y = y + pnl:GetTall()+2

	end

	y = math.min( y, self:GetMaxHeight() )

	self:SetTall( y )

	derma.SkinHook( "Layout", "Menu", self )

	DScrollPanel.PerformLayout( self, w, h )

end

--[[---------------------------------------------------------
	Open - Opens the menu.
	x and y are optional, if they're not provided the menu
		will appear at the cursor.
-----------------------------------------------------------]]
function PANEL:Open( x, y, skipanimation, ownerpanel )

	RegisterDermaMenuForClose( self )

	local maunal = x && y

	x = x or gui.MouseX()
	y = y or gui.MouseY()

	local OwnerHeight = 0
	local OwnerWidth = 0

	if ( ownerpanel ) then
		OwnerWidth, OwnerHeight = ownerpanel:GetSize()
	end

	self:InvalidateLayout( true )

	local w = self:GetWide()
	local h = self:GetTall()

	self:SetSize( w, h )

	if ( y + h > ScrH() ) then y = ( ( maunal && ScrH() ) or ( y + OwnerHeight ) ) - h end
	if ( x + w > ScrW() ) then x = ( ( maunal && ScrW() ) or x ) - w end
	if ( y < 1 ) then y = 1 end
	if ( x < 1 ) then x = 1 end

	local p = self:GetParent()
	if ( IsValid( p ) && p:IsModal() ) then
		-- Can't popup while we are parented to a modal panel
		-- We will end up behind the modal panel in that case

		x, y = p:ScreenToLocal( x, y )

		-- We have to reclamp the values
		if ( y + h > p:GetTall() ) then y = p:GetTall() - h end
		if ( x + w > p:GetWide() ) then x = p:GetWide() - w end
		if ( y < 1 ) then y = 1 end
		if ( x < 1 ) then x = 1 end

		self:SetPos( x, y )
	else
		self:SetPos( x, y )

		-- Popup!
		self:MakePopup()
	end

	-- Make sure it's visible!
	self:SetVisible( true )

	self:SetAlpha(0)
	self:AlphaTo(255, 0.1)

	-- Keep the mouse active while the menu is visible.
	self:SetKeyboardInputEnabled( false )

end

--
-- Called by DMenuOption
--
function PANEL:OptionSelectedInternal( option )

	self:OptionSelected( option, option:GetText() )

end

function PANEL:OptionSelected( option, text )

	-- For override

end

function PANEL:ClearHighlights()

	for k, pnl in ipairs( self:GetCanvas():GetChildren() ) do
		pnl.Highlight = nil
	end

end

function PANEL:HighlightItem( item )

	for k, pnl in ipairs( self:GetCanvas():GetChildren() ) do
		if ( pnl == item ) then
			pnl.Highlight = true
		end
	end

end

vgui.Register("echat.menu", PANEL, "esclib.scrollpanel")
--PATH addons/__________scripts__loader/lua/scriptssss/animations/sh_init.lua:
SCRIPTSLOADER.Anims = {}
SCRIPTSLOADER.Anims[ACT_GMOD_GESTURE_BOW] = true
SCRIPTSLOADER.Anims[ACT_GMOD_TAUNT_MUSCLE] = true
SCRIPTSLOADER.Anims[ACT_GMOD_GESTURE_BECON] = true
SCRIPTSLOADER.Anims[ACT_GMOD_TAUNT_LAUGH] = true
SCRIPTSLOADER.Anims[ACT_GMOD_TAUNT_PERSISTENCE] = true
SCRIPTSLOADER.Anims[ACT_GMOD_GESTURE_DISAGREE] = true
SCRIPTSLOADER.Anims[ACT_GMOD_GESTURE_AGREE] = true
SCRIPTSLOADER.Anims[ACT_GMOD_GESTURE_WAVE] = true
SCRIPTSLOADER.Anims[ACT_GMOD_TAUNT_DANCE] = true
local function physGunCheck( ply )
    local hookName = "darkrp_anim_physgun_" .. ply:EntIndex()
    hook.Add( "Think", hookName, function()
        if IsValid( ply ) and ply:Alive() and ply:GetActiveWeapon():IsValid() and ply:GetActiveWeapon():GetClass() == "weapon_physgun" and ply:KeyDown( IN_ATTACK ) and ( ply:GetAllowWeaponsInVehicle() or not ply:InVehicle() ) then
            local ent = ply:GetEyeTrace().Entity
            if IsValid( ent ) and ent:IsPlayer() and not ply.SaidHi then
                ply.SaidHi = true
                ply:DoAnimationEvent( ACT_SIGNAL_GROUP )
            end
        else
            if IsValid( ply ) then ply.SaidHi = nil end
            hook.Remove( "Think", hookName )
        end
    end )
end

hook.Add( "KeyPress", "darkrp_animations", function( ply, key )
    if key == IN_ATTACK then
        local weapon = ply:GetActiveWeapon()
        if weapon:IsValid() then
            local class = weapon:GetClass()
            -- Saying hi/hello to a player
            if class == "weapon_physgun" then
                physGunCheck( ply )
                -- Hobo throwing poop!
            elseif class == "weapon_bugbait" then
                local Team = ply:Team()
                if rp.Team[Team] and rp.Team[Team].hobo then ply:DoAnimationEvent( ACT_GMOD_GESTURE_ITEM_THROW ) end
            end
        end
    end
end )
--PATH addons/__________scripts__loader/lua/scriptssss/admin/cl_init.lua:
CakeScreens = {}
local normal = Vector( 0, 0, 0 )
local font1 = onyx.FontNoScale( 'Comfortaa', 20 )
CakeScreens.Start3D2D = function( pos, ang, res )
	origin = pos
	scale = res
	angle = ang:Forward()
	normal = Angle( ang.p, ang.y, ang.r )
	normal:RotateAroundAxis( ang:Forward(), -90 )
	normal:RotateAroundAxis( ang:Right(), 90 )
	normal = normal:Forward()
	cam.Start3D2D( pos, ang, res )
end

CakeScreens.Info = {
	['rp_bangclaw'] = {
		pos = Vector( 1035.457092, -3005.058838, 270.819931 ),
		ang = Angle( 180, 0, 270 )
	},
	['rp_downtown_tits_v25'] = {
		pos = Vector( 3662, 750, 78 ),
		ang = Angle( 0, 270, 90 )
	},
}

local sc_pos = Vector( 1035.457092, -3005.058838, 270.819931 )
local col1 = Color( 50, 50, 50, 200 )
local col2 = Color( 175, 175, 100 )
local col3 = ColorAlpha( color_black, 255 )
local col4 = Color( 50, 100, 50, 200 )
local lpos = -245
local pos = 195
local size = 270
function CakeScreens.MainLuaScreen()
	local info = CakeScreens.Info[game.GetMap()]
	CakeScreens.Start3D2D( info.pos, info.ang, 0.3 )
	if not istable( nw.GetGlobal( 'Statistic_Money' ) ) then
		cam.End3D2D()
		return
	end

	draw.Box( lpos, pos, size, 400, col1 )
	surface.SetDrawColor( col3 )
	surface.DrawOutlinedRect( lpos, pos, size, 25, 1 )
	surface.DrawOutlinedRect( lpos + size * 0.5, pos + 25, 1, 375, 1.5 )
	for k, v in ipairs( nw.GetGlobal( 'Statistic_Money' ) ) do
		if k < 16 then
			local col = Color( 100 + k * 10, 255 - k * 10, 100 )
			surface.DrawOutlinedRect( lpos, pos + k * 25, size, 25, 1 )
			draw.SimpleText( ' ' .. ( string.len( v[1] ) > 18 and string.sub( v[1], 1, 18 ) .. '...' or v[1] ), font1, 1 + lpos, pos + k * 25 + 2, col )
			draw.SimpleText( rp.FormatMoney( v[2] ), font1, 140 + lpos, pos + k * 25 + 2, col )
		end
	end

	draw.Box( lpos, pos, size, 25, col4 )
	draw.SimpleText( 'ТОП 15 Багатих гравців сервера', font1, 5 + lpos, pos + 2, col2 )
	cam.End3D2D()
end

function CakeScreens.Draw()
	if LocalPlayer():GetPos():Distance( sc_pos ) < 800 then CakeScreens.MainLuaScreen() end
end

timer.Simple( 60, function()
	if not CakeScreens.Info[game.GetMap()] then return end
	hook.Add( 'PostDrawTranslucentRenderables', 'Cakerp lua screens', CakeScreens.Draw )
end )