--Stealed clientside server code by exechack.cc
--Hostname: Age of Clones | Clone Wars Roleplay | Eigener Spielmodus - Part 6/12 - 06/04/2025


--PATH addons/arccw_base_modified/lua/arccw/shared/sh_effects.lua:
game.AddParticles( "particles/muzzleflashes_test.pcf" )
game.AddParticles( "particles/muzzleflashes_test_b.pcf" )
PrecacheParticleSystem( "muzzleflash_smg" )
PrecacheParticleSystem( "muzzleflash_smg_bizon" )
PrecacheParticleSystem( "muzzleflash_shotgun" )
PrecacheParticleSystem( "muzzleflash_slug" )
PrecacheParticleSystem( "muzzleflash_slug_flame" )
PrecacheParticleSystem( "muzzleflash_pistol" )
PrecacheParticleSystem( "muzzleflash_pistol_cleric" )
PrecacheParticleSystem( "muzzleflash_pistol_deagle" )
PrecacheParticleSystem( "muzzleflash_suppressed" )
PrecacheParticleSystem( "muzzleflash_mp5" )
PrecacheParticleSystem( "muzzleflash_MINIMI" )
PrecacheParticleSystem( "muzzleflash_m79" )
PrecacheParticleSystem( "muzzleflash_m14" )
PrecacheParticleSystem( "muzzleflash_ak47" )
PrecacheParticleSystem( "muzzleflash_ak74" )
PrecacheParticleSystem( "muzzleflash_m82" )
PrecacheParticleSystem( "muzzleflash_m3" )
PrecacheParticleSystem( "muzzleflash_famas" )
PrecacheParticleSystem( "muzzleflash_g3" )
PrecacheParticleSystem( "muzzleflash_1" )
PrecacheParticleSystem( "muzzleflash_3" )
PrecacheParticleSystem( "muzzleflash_4" )
PrecacheParticleSystem( "muzzleflash_5" )
PrecacheParticleSystem( "muzzleflash_6" )
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_gl_thermal.lua:
att.PrintName = "Thermal Grenade Launcher"
att.Icon = Material("interfaz/armas/sw_firebomb.png")
att.Description = "Throwable grenade with thermal capacity."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.AutoStats = true
att.Slot = "ammo_rocket"

att.SortOrder = 1738
att.Override_ShootEntity = "tfa_battlefront_ent_nade_thermal"
att.Mult_SightTime = 1.25
att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_hailfire.lua:
att.PrintName = "Hail-Fire Module"
att.Icon = Material("interfaz/armas/sw_fullauto.png")
att.Description = "Higher fire-ratio at the cost of low damage."
att.Override_MuzzleEffect = "wpn_muzzleflash_dc17_green"
att.Override_Tracer = "tracer_green"
att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.NotForNPCs = true
att.AutoStats = true
att.Slot = "ammo"

att.Mult_ShootPitch = 1.2
att.Reload = 1
att.Mult_DamageMin = 0.75
att.Mult_Recoil = 1.2
att.Mult_SightTime = 1
att.Mult_RPM = 1.38
att.Mult_Damage = 0.74
att.Mult_MuzzleVelocity = 0.7
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_le_mod.lua:
att.PrintName = "LE Mod"
att.Icon = Material("entities/acwatt_go_ammo_blanks.png", "mips smooth")
att.Description = "Long range mod"
att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.AutoStats = true
att.Slot = "ammo"
att.MagReducer = true
att.Reload = 1
att.Mult_DamageMin = 1.35
att.Mult_Recoil = 1.1
att.Mult_SightTime = 1
att.Mult_RPM = 0.5

att.NotForNPCs = true
att.Mult_Damage = 1.8
att.Mult_MuzzleVelocity = 1.1
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_rocket_closerange.lua:
att.PrintName = "Close Range"
att.Description = "Uses the previous iteration of the quake launcher's missile before the update. It can't hurt combine gunships or helicopters, but makes up for it by not having a fuze timer, allowing for point blank explosions"
att.Icon = Material("interfaz/iconos/kraken/jedi comm combat medic/1545019367_770535378.png")

att.Desc_Pros = {
    "close range explosions"
}
att.Desc_Cons = {
    "doesn't damage vehicles",
    "slightly slower velocity",
}
att.AutoStats = true
att.Slot = "ammo_rocket"

att.Override_ShootEntity = "arccw_rocket"
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_rocket_electro.lua:
att.PrintName = "Electromagnetic Ball"
att.Description = "A giant plasma ball capable of causing great damage to enemy infantry."
att.Icon = Material("interfaz/iconos/kraken/sith power shield tech/309911060_2246076134.png")

att.AutoStats = true
att.Slot = "ammo_rocket"

att.Override_ShootEntity = "rocket_cis"
att.Override_AmmoPerShot = 1
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_rocket_emp.lua:
att.PrintName = "EMP Rocket"
att.Description = "Can disable vehicles and ships. Highly powered."
att.Icon = Material("interfaz/armas/sw_cyrobangrenade.png")

att.AutoStats = true
att.Slot = "ammo_rocket"
att.Override_ShootEntity = "emp_throwed"
--addons/arccw_weapons/lua/arccw/shared/attachments/muzzle_a280_mod.lua:
att.PrintName = "A280 Barrel Mod"
att.Description = "Bulky and heavy, but provides better ballistic performance.\n\n\"By the time you figured it out, it would be too late.\""

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/atts/a280_default_barrel.mdl"
att.ModelOffset = Vector(0, 0, 0)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = false
att.IsMuzzleDevice = false

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 1

att.Add_BarrelLength = 6
att.Mult_SightTime = 1.15
att.Mult_HipDispersion = 1.2
att.Mult_Sway = 1.15
att.Mult_Range = 1.1
--addons/arccw_weapons/lua/arccw/shared/attachments/muzzle_a280cfe_default_mod.lua:
att.PrintName = "A280-CFE Standard Barrel"
att.Description = "Bulky and heavy, but provides better ballistic performance.\n\n\"By the time you figured it out, it would be too late.\""

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/atts/a280cfe_defaultbarrel.mdl"
att.ModelOffset = Vector(0, 0, 0)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = false
att.IsMuzzleDevice = false

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 1


att.Mult_RecoilSide = 0.75

att.Mult_ShootSpeedMult = 1.05
att.Mult_Sway = 1

att.Add_BarrelLength = 6
att.Mult_SightTime = 1.1
att.Mult_HipDispersion = 1.1
att.Mult_Range = 1
--addons/arccw_weapons/lua/arccw/shared/attachments/optic_ee4_scope.lua:
att.PrintName = "EE-4 Magnifying Optic"
att.Icon = Material("entities/dlt19x_icon.png")
att.Description = "High-magnification sniper rifle scope for long range combat."

att.SortOrder = 9

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/atts/ee4_carbine_scope.mdl"
att.ModelOffset = Vector(0, 0, -0)
att.AdditionalSights = {
    {
        Pos = Vector(-0.005, 9, -1.11),
        Ang = Angle(0, 0, 0),
        Magnification = 1.5,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 10,
        ZoomSound = "weapons/arccw/fiveseven/fiveseven_slideback.wav",
        IgnoreExtra = true
    }
}

att.ScopeGlint = false

att.Holosight = true
att.HolosightReticle = Material("scope/star_ret.png", "smooth")
att.HolosightNoFlare = true
att.HolosightSize = 10
att.HolosightBone = "holosight"
att.HolosightPiece = "models/atts/ee4_carbine_scope_hsp.mdl"
att.Colorable = false

att.HolosightMagnification = 0
att.HolosightBlackbox = true

att.HolosightConstDist = 44

att.HolosightMagnificationMin = 2
att.HolosightMagnificationMax = 3
att.HoloSightColorable = false

att.Mult_SightTime = 1.35
att.Mult_SightedSpeedMult = 0.8
att.Mult_SpeedMult = 0.9
--addons/arccw_weapons/lua/arccw/shared/attachments/perk_conditionoverload.lua:
att.PrintName = "Condition Overload"

att.Icon = Material("interfaz/armas/sw_powercell2.png")
att.Description = "With a little grease and some compression charge, most magazines can be made to accept an extra round."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true
att.Add_ClipSize = 20

att.Hook_Compatible = function(wep)
    if wep.RejectMagSizeChange or wep:GetCapacity() == 1 then return false end
end

att.NotForNPCs = true
--addons/arccw_weapons/lua/arccw/shared/attachments/perk_loadingdrills.lua:
att.PrintName = "Loading Drills"

att.Icon = Material("interfaz/iconos/kraken/jedi comm assault specialist/4234321436_1053532338.png")
att.Description = "Every second counts in the heat of battle. Repeated training drills allow you to reload your weapon more quickly."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "perk"

att.AutoStats = true
att.Mult_ReloadTime = 0.6

att.NotForNPCs = true
--addons/arccw_weapons/lua/arccw/shared/attachments/perk_masita_berserker.lua:
att.PrintName = "Berserker"
att.Icon = Material("interfaz/iconos/kraken/jedi scoun sawbones/2553053340_4204086370.png")
att.Description = "You're a Berseker, you have an almost limitless amount of physical strength."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "perk"

att.Mult_SpeedMult = 2
att.Mult_SightedSpeedMult = 2

att.Mult_MeleeTime = 1.1
att.Mult_MeleeDamage = 6
att.Add_MeleeRange = 5
att.Mult_MeleeAttackTime = 2.5

att.NotForNPC = true
--addons/arccw_weapons/lua/arccw/shared/attachments/perk_masita_gunslinger.lua:
att.PrintName = "Gunslinger"
att.Icon = Material("interfaz/iconos/kraken/jedi guns dirty fighting/3726085931_3536543931.png")
att.Description = "You're a Gunslinger, an ace when it comes to Blaster Pistols. Your reload speed and accuracy will increase when using an pistol along other benefits."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "perk"

att.NotForNPC = true

att.Mult_AccuracyMOA = 0.25
att.Mult_HipDispersion = 0.5
att.Mult_RPM = 1.5
att.Mult_Penetration = 2
att.Mult_ReloadTime = 0.65

att.Hook_Compatible = function(wep)
    if (wep.Primary.Ammo ~= "ar2" and wep.Primary.Ammo ~= "357" and wep.Primary.Ammo ~= "pistol") then return false end
end
--addons/arccw_weapons/lua/arccw/shared/attachments/special_explosive.lua:
att.PrintName = "Explosive Rounds"
att.Icon = Material("interfaz/armas/sw_demolish.png")
att.Description = "Tibanna compression with explosive results"
att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.AutoStats = true
att.Slot = "special_ammo"

att.Mult_ShootPitch = 0.6
att.Mult_ShootVol = 1.7
att.Mult_Penetration = 1.1
att.Mult_Damage = 4
att.Mult_Range = 0.7

att.Override_DamageType = DMG_BURN

att.Override_Tracer = "tracer_yellow"

att.Hook_GetCapacity = function(wep, cap)
    return math.Clamp(math.Round(wep.RegularClipSize * 1), 1, 12)
end

att.Hook_BulletHit = function(wep, data)
    local ent = data.tr.Entity
    util.BlastDamage(wep, wep:GetOwner(), data.tr.HitPos, 96, wep:GetDamage(data.range))
    if ent:IsValid() and ent:GetClass() == "npc_helicopter" then
        data.dmgtype = DMG_AIRBOAT
    end
end
--addons/arccw_weapons/lua/arccw/shared/attachments/st_dc15.lua:
att.PrintName = "DC-15 Stock"
att.AbbrevName = "DC-15 Stock"
att.Icon = Material("interfaz/armas/swrp_att_dlt20_stock.png")
att.Description = ""
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = "stock"

att.Model = "models/sw_battlefront/weapons/mods/dc15s_mod_stock.mdl"
att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, 0, 0)
att.ModelOffset = Vector(0, 0, 0)
att.ModelScale = Vector(1, 1, 1)

att.AutoStats = true
att.HideIfBlocked = true

att.Mult_Damage = 1.10
att.Mult_SightTime = 0.97
att.Mult_Sway = 1.13
att.Mult_RPM = 0.98
att.Mult_SpeedMult = 0.95
att.Mult_DrawTime = 0.97
att.Mult_HolsterTime = 1.10
att.Mult_HipDispersion = 1.10

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--addons/arccw_weapons/lua/arccw/shared/attachments/sw_b2_rocket.lua:
att.PrintName = "B2 Rocket"
att.Description = "Test ammo for the B2 Rocket droid"

att.SortOrder = 2

att.Desc_Cons = {
}
att.AutoStats = false
att.Slot = "b2attachments"

att.HideModel = false
att.ModelScale = Vector(0, 0, 0)
att.ModelOffset = Vector(0, 0, 1.25)
att.OffsetAng = Angle(0, -90, 0)

att.Mult_SightTime = 1.08
att.Mult_SightedSpeedMult = 0.94
att.Mult_MuzzleVelocity = 50
att.Override_ChamberSize = -10
att.MagReducer = true
att.Add_ClipSize =  1
att.Override_ShootEntity = "arccw_rocket"

att.Hook_AddShootSound = function(wep, data)
	wep:MyEmitSound("everfall/weapons/rocket_launcher/explosive_rocketlauncher_corebass_close_var_03.mp3", 120, 100, 1, CHAN_WEAPON - 1)
end
--addons/arccw_weapons/lua/arccw/shared/attachments/sw_dc17m_sniper_ext_mag_v2.lua:
att.PrintName = "SW-Extended Magazine (v2)"
att.AbbrevName = "8-Round Mag"
att.SortOrder = 100
att.Icon = nil
att.Description = "Extended magazine, ideal for additional fire support. Slight Bulky construction and additional ammo capacity increases weight, making the weapon difficult to handle"
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Desc_Neutrals = {}
att.Slot = "dc17m_sniper_ext_v2"

att.DroppedModel = "models/Items/BoxSRounds.mdl"
att.OffsetAng = Angle(0, 0, 90)
att.AutoStats = true
att.ModelBodygroups = "0000000000"

att.Add_ClipSize = 3

att.Mult_SightTime = 1.05
att.Mult_Sway = 2.1

att.Mult_SpeedMult = 0.95
att.Mult_ShootSpeedMult = 0.95

att.Mult_DrawTime = 1.25
att.Mult_HolsterTime = 1.25

att.Mult_HipDispersion = 1.3

--[[]
att.Override_Jamming = true
att.Override_HeatCapacity = 200
att.Override_HeatDissipation = 4
att.Override_HeatDelayTime = 3
]]

--lua/arccw/shared/attachments/uc_ammo_jsp.lua:
att.PrintName = "\"JSP\" Jacketed Soft-point Rounds"
att.AbbrevName = "\"JSP\" Jacketed Soft-point"

att.SortOrder = 3
att.Icon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth")
att.Description = "Bullets with an exposed lead tip that expands on impact.\nIncreases wounding potential while maintaining an aerodynamic profile."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_ammo"

att.AutoStats = true

att.Mult_Penetration = 0.6
--att.Mult_Damage = 1.1
att.Mult_Range = 0.8
att.Mult_RangeMin = 1.8

att.Hook_Compatible = function(wep)
    if wep:GetIsShotgun() then
        return false
    end
end
--lua/arccw/shared/attachments/uc_charm_urbancharm_common.lua:
att.PrintName = "Urban Charm - Common"
att.Description = "The icon of a Garry's Mod addon."

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "charm"

att.Free = true

att.Model = "models/weapons/arccw/atts/charmbase.mdl"

att.DroppedModel = "models/Items/BoxSRounds.mdl"

att.Charm = true
att.CharmModel = "models/weapons/arccw/atts/uc_urbancharm.mdl"
att.CharmAtt = "Charm"
att.CharmScale = Vector(0.5, 0.5, 0.5)
att.CharmOffset = Vector(0, -1.1, -0.2)
att.CharmAngle = Angle(20, 0, 80)
att.CharmSkin = 0

--lua/arccw/shared/attachments/uc_fg_dualstage.lua:
att.PrintName = "Dual-Stage Trigger"

att.Icon = Material("entities/att/arccw_uc_dualstagetrigger.png", "mips smooth")
att.Description = "A heavy trigger with a semi-automatic middle stage and a fully-automatic end stage. Can shoot semi- and fully- automatically without the need for switching a fire selector."
att.Desc_Pros = {
    "uc.dualstage.pro"
}
att.Desc_Cons = {
    "uc.dualstage.con"
}
att.Desc_Neutrals = {
}
att.Slot = "uc_fg"
att.AutoStats = true

att.Hook_Compatible = function(wep)
    if wep:GetIsManualAction() then
        return false
    end
end
att.SortOrder = 2

att.Hook_Compatible = function(wep)
    if wep:GetIsManualAction() then
        return false
    end
    for i, v in pairs(wep.Firemodes) do
        if !v then continue end
        if v.Mode and v.Mode != 1 and v.Mode != 0 then
            return
        end
    end
    return false
end

--att.Override_ShotRecoilTable = {0.7}

att.Mult_RPM = 1.1
att.Mult_TriggerDelayTime = 0

function att.Hook_ModifyRPM(wep, delay)
    if wep:GetCurrentFiremode().Mode != 1 and (!wep:GetOwner():IsPlayer() or wep:GetOwner():KeyDown(IN_ATTACK))
            and wep:GetBurstCount() == 0 then -- wep:GetState() != ArcCW.STATE_CUSTOMIZE
        return delay + 0.1
    end
end

function att.Hook_Think(wep)
    if wep:GetOwner():IsPlayer() and wep:GetOwner():KeyReleased(IN_ATTACK) and wep:GetBurstCount() == 0 and IsFirstTimePredicted() then
        wep:SetNextPrimaryFire((wep.TriggerDownTime or CurTime()) + wep:GetFiringDelay())
    elseif wep:GetOwner():IsPlayer() and wep:GetOwner():KeyPressed(IN_ATTACK) and wep:GetBurstCount() == 0 and IsFirstTimePredicted() then
        wep.TriggerDownTime = CurTime()
    end
end

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"
--lua/arccw/shared/attachments/uc_fg_heavy.lua:
att.PrintName = "Heavy Bolt"

att.Icon = Material("entities/att/arccw_uc_heavybolt.png", "mips smooth")
att.Description = "Heavyweight bolt springs reduce the cyclic rate of the weapon, improving its controllability."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_fg"
att.AutoStats = true
att.SortOrder = 3

att.Mult_Recoil = 0.9
att.Mult_RPM = 0.8
att.Mult_CycleTime = 1.1

--[[]
att.Hook_Compatible = function(wep)
    if wep:GetIsManualAction() then
        return false
    end
end
]]

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"
--lua/arccw/shared/attachments/uc_grip_mafg2.lua:
att.PrintName = "MAGPUL AFG-2 Angled Fore Grip"
att.AbbrevName = "Magpul Angled Foregrip"
att.Icon = Material("entities/att/acwatt_uc_grip_magpul_afg2.png", "mips smooth")
att.Description = "An ergonomically angled grip surface reduces wrist strain, increasing maneuverability."

att.SortOrder = 1201

att.AutoStats = true
att.Slot = "foregrip"

att.LHIK = true

att.ModelOffset = Vector(0, 0, -0.75)

att.Model = "models/weapons/arccw/atts/uc_magpul_afg2.mdl"
att.ModelSkin = 1

att.Mult_SightTime = 0.8
att.Mult_Sway = 1.15
att.Mult_Recoil = 1.20
--lua/arccw/shared/attachments/uc_muzzle_brake2.lua:
att.PrintName = "Helix Muzzle Brake" -- fictional
att.AbbrevName = "Helix Brake"
att.Icon = Material("entities/att/acwatt_uc_muzzle_brake2.png", "mips smooth")
att.Description = "Redirects propellant gases to reduce weapon recoil.\nSlightly reduces recoil."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 100

att.Model = "models/weapons/arccw/atts/uc_muzzle3.mdl"
att.ModelOffset = Vector(2.3, 0, 0)
att.ModelScale = Vector(1.0, 1.0, 1.0)
att.OffsetAng = Angle(0, 0, 0)

att.IsMuzzleDevice = true

att.Mult_Recoil = 0.9
att.Mult_RecoilSide = 0.85

att.Mult_ShootSpeedMult = 0.9
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"

--lua/arccw/shared/attachments/uc_muzzle_fhider1.lua:
att.PrintName = "Flash Hider" -- fictional
att.AbbrevName = "Flash Hider"
att.Icon = Material("entities/att/acwatt_uc_muzzle_fhider1.png", "mips smooth")
att.Description = "Reduces muzzle flash to the point where it can't block the shooter's vision or compromise their position. The enhanced clarity marginally improves hip fire performance."
att.Desc_Pros = {
    "uc.flashhider"
}
att.Desc_Cons = {
}
att.AutoStats = true
att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 50

att.Model = "models/weapons/arccw/atts/uc_muzzle1.mdl"
att.ModelOffset = Vector(2.05, 0, 0)
att.ModelScale = Vector(.8, .8, .8)
att.OffsetAng = Angle(0, 0, 0)

-- att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.IsMuzzleDevice = true

att.Mult_HipDispersion = 0.9
att.Mult_MoveDispersion = 0.9

att.Mult_ShootSpeedMult = 0.9
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"
--lua/arccw/shared/attachments/uc_optic_eotech552.lua:
att.PrintName = "EOTech 552 (HOLO)"
att.Icon = Material("entities/att/acwatt_uc_optic_eotech552.png", "mips smooth")
att.Description = "Improves target acquisition with a highly precise circle-dot holographic reticle, while adding minimal extra weight."

att.SortOrder = 1

att.Desc_Pros = {
    "autostat.holosight",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "optic"

att.Model = "models/weapons/arccw/atts/uc_eotech552.mdl"
att.ModelOffset = Vector(-0.5, 0, 0)
att.ModelScale = Vector(0.67, 0.67, 0.67)

att.AdditionalSights = {
    {
        Pos = Vector(0, 9, -1.38),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ScrollFunc = ArcCW.SCROLL_NONE
    }
}

att.Holosight = true
att.HolosightReticle = Material("hud/reticles/ud_holo.png", "smooth")
att.HolosightSize = 1.1
att.HolosightBone = "holosight"
att.HolosightNoFlare = true

att.Colorable = true

att.Mult_SightedSpeedMult = 0.9
--addons/arccw_weapons/lua/arccw/shared/attachments_bulk/aocrp_charms.lua:
local AOCRP_Charms = {}

AOCRP_Charms["emotehappy"] = {

    PrintName = "Happy Emote",
    Icon = Material("entities/charm_fes_steamhappy.png", "mips"),
    Description = "Happy :)",
    Desc_Pros = {},
    Desc_Cons = {},
    Slot = "charm",
    Free = false,
    Model = "models/weapons/arccw/fml_charm/steamhappy.mdl",

}

AOCRP_Charms["emotebored"] = {

    PrintName = "Bored Emote",
    Icon = Material("entities/charm_fes_steambored.png", "mips"),
    Description = "Bored",
    Desc_Pros = {},
    Desc_Cons = {},
    Slot = "charm",
    Free = false,
    Model = "models/weapons/arccw/fml_charm/steambored.mdl",

}

AOCRP_Charms["emotefacepalm"] = {

    PrintName = "Facepalm Emote",
    Icon = Material("entities/charm_fes_steamfacepalm.png", "mips"),
    Description = "Omfg bist du dumm",
    Desc_Pros = {},
    Desc_Cons = {},
    Slot = "charm",
    Free = false,
    Model = "models/weapons/arccw/fml_charm/steamfacepalm.mdl",

}

AOCRP_Charms["emotemocking"] = {

    PrintName = "Mocking Emote",
    Icon = Material("entities/charm_fes_steammocking.png", "mips"),
    Description = "Hallo Welt",
    Desc_Pros = {},
    Desc_Cons = {},
    Slot = "charm",
    Free = false,
    Model = "models/weapons/arccw/fml_charm/steammocking.mdl",

}

AOCRP_Charms["emotesad"] = {

    PrintName = "Sad Emote",
    Icon = Material("entities/charm_fes_steamsad.png", "mips"),
    Description = "Hallo Welt",
    Desc_Pros = {},
    Desc_Cons = {},
    Slot = "charm",
    Free = false,
    Model = "models/weapons/arccw/fml_charm/steamsad.mdl",

}
AOCRP_Charms["emotesalty"] = {

    PrintName = "Salty Emote",
    Icon = Material("entities/charm_fes_steamsalty.png", "mips"),
    Description = "Hallo Welt",
    Desc_Pros = {},
    Desc_Cons = {},
    Slot = "charm",
    Free = false,
    Model = "models/weapons/arccw/fml_charm/steamsalty.mdl",

}


AOCRP_Charms["gigachad"] = {

    PrintName = "Gigachad",
    Icon = Material("entities/gigachad.png", "mips smooth"),
    Description = "Average AOC enjoyer",
    Desc_Pros = {},
    Desc_Cons = {},
    Slot = "charm",
    Free = false,
    Model = "models/weapons/arccw/gigacharm/gigachad.mdl",

}


AOCRP_Charms["logo"] = {

    PrintName = "AOC-Logo",
    Icon = Material("entities/gigachad.png", "mips smooth"),
    Description = "Average AOC enjoyer",
    Desc_Pros = {},
    Desc_Cons = {},
    Slot = "charm",
    Free = false,
    Model = "models/starwars/grady/props/aoc/charms/aoc-logo.mdl",

}

AOCRP_Charms["ph2helm"] = {

    PrintName = "Phase 2 Helm",
    Icon = Material("entities/gigachad.png", "mips smooth"),
    Description = "Average AOC enjoyer",
    Desc_Pros = {},
    Desc_Cons = {},
    Slot = "charm",
    Free = false,
    Model = "models/starwars/grady/props/aoc/charms/helmet_ph2.mdl",

}



--[[ AOCRP_Charms["emotereisphere"] = {

    PrintName = "Reisphere Emote",
    Icon = Material("entities/charm_fes_reisphere.png", "mips smooth"),
    Description = "Happy :)",
    Desc_Pros = {},
    Desc_Cons = {},
    Slot = "charm",
    Free = true,
    Model = "models/weapons/arccw/fml_charm/reisphere.mdl",

} ]]


for k, v in pairs(AOCRP_Charms) do
    ArcCW.LoadAttachmentType(v, k)
end
--addons/arccw_base_modified/lua/arccw/client/cl_autostats.lua:
local tbl     = table
local tbl_add = tbl.Add
local tbl_ins = tbl.insert
local tostr   = tostring
local translate = ArcCW.GetTranslation

-- ["buff"] = {"desc", string mode (mult, add, override, func), bool lowerbetter or function(val), number priority, bool flipsigns }

ArcCW.AutoStats = {
    -- Attachments
    ["MagExtender"]           = { "autostat.magextender", "override", false,       pr = 317 },
    ["MagReducer"]            = { "autostat.magreducer",  "override", true,        pr = 316 },
    ["Bipod"]                 = { "autostat.bipod",       false, false,            pr = 313 },
    ["ScopeGlint"]            = { "autostat.glint",       "override", true,        pr = 255 },
    ["Silencer"]              = { "autostat.silencer",    "override", false,       pr = 254 },
    ["Override_NoRandSpread"] = { "autostat.norandspr",   "override", false,       pr = 253 },
    ["Override_CanFireUnderwater"] = { "autostat.underwater",   "override", false, pr = 252 },
    ["Override_ShootWhileSprint"] = { "autostat.sprintshoot",   "override", false, pr = 251 },
    -- Multipliers
    ["Mult_BipodRecoil"]      = { "autostat.bipodrecoil", false, true,             pr = 312 },
    ["Mult_BipodDispersion"]  = { "autostat.bipoddisp",   false, true,             pr = 311 },
    ["Mult_Damage"]           = { "autostat.damage",      "mult", false,           pr = 215 },
    ["Mult_DamageMin"]        = { "autostat.damagemin",   "mult", false,           pr = 214 },
    ["Mult_Range"]            = { "autostat.range",       "mult", false,           pr = 185 },
    ["Mult_RangeMin"]         = { "autostat.rangemin",    "mult", false,           pr = 184 },
    ["Mult_Penetration"]      = { "autostat.penetration", "mult", false,           pr = 213 },
    ["Mult_MuzzleVelocity"]   = { "autostat.muzzlevel",   "mult", false,           pr = 212 },
    ["Mult_PhysBulletMuzzleVelocity"] = { "autostat.muzzlevel",   "mult", false,   pr = 211 },
    ["Mult_MeleeTime"]        = { "autostat.meleetime",   "mult", true,            pr = 145 },
    ["Mult_MeleeDamage"]      = { "autostat.meleedamage", "mult", false,           pr = 144 },
    ["Add_MeleeRange"]        = { "autostat.meleerange",  false,  false,           pr = 143 },
    ["Mult_Recoil"]           = { "autostat.recoil",      "mult", true,            pr = 195 },
    ["Mult_RecoilSide"]       = { "autostat.recoilside",  "mult", true,            pr = 194 },
    ["Mult_RPM"]              = { "autostat.firerate",    "mult", false,           pr = 216 },
    ["Mult_AccuracyMOA"]      = { "autostat.precision",   "mult", true,            pr = 186 },
    ["Mult_HipDispersion"]    = { "autostat.hipdisp",     "mult", true,            pr = 155 },
    ["Mult_SightsDispersion"] = { "autostat.sightdisp",   "mult", true,            pr = 154 },
    ["Mult_MoveDispersion"]   = { "autostat.movedisp",    "mult", true,            pr = 153 },
    ["Mult_JumpDispersion"]   = { "autostat.jumpdisp",    "mult", true,            pr = 152 },
    ["Mult_ShootVol"]         = { "autostat.shootvol",    "mult", true,            pr = 115 },
    ["Mult_SpeedMult"]        = { "autostat.speedmult",   "mult", false,           pr = 114 },
    ["Mult_MoveSpeed"]        = { "autostat.speedmult",   "mult", false,           pr = 105 },
    ["Mult_SightedSpeedMult"] = { "autostat.sightspeed",  "mult", false,           pr = 104 },
    ["Mult_SightedMoveSpeed"] = { "autostat.sightspeed",  "mult", false,           pr = 103 },
    ["Mult_ShootSpeedMult"]   = { "autostat.shootspeed",  "mult", false,           pr = 102 },
    ["Mult_ReloadTime"]       = { "autostat.reloadtime",  "mult", true,            pr = 125 },
    ["Add_BarrelLength"]      = { "autostat.barrellength","add",  true,            pr = 915 },
    ["Mult_DrawTime"]         = { "autostat.drawtime",    "mult", true,            pr = 14 },
    ["Mult_SightTime"]        = { "autostat.sighttime",   "mult", true,            pr = 335, flipsigns = true },
    ["Mult_CycleTime"]        = { "autostat.cycletime",   "mult", true,            pr = 334 },
    ["Mult_Sway"]             = { "autostat.sway",        "mult",  true,           pr = 353 },
    ["Mult_HeatCapacity"]     = { "autostat.heatcap",     "mult", false,           pr = 10 },
    ["Mult_HeatDissipation"]  = { "autostat.heatdrain",   "mult", false,           pr = 9 },
    ["Mult_FixTime"]          = { "autostat.heatfix",     "mult", true,            pr = 8 },
    ["Mult_HeatDelayTime"]    = { "autostat.heatdelay",   "mult", true,            pr = 7 },
    ["Mult_MalfunctionMean"]  = { "autostat.malfunctionmean", "mult", false,       pr = 6 },
    ["Add_ClipSize"]          = { "autostat.clipsize.mod",    "add", false,         pr = 315 },
    ["Mult_ClipSize"]         = { "autostat.clipsize.mod",    "mult", false,        pr = 314 },

    ["Mult_TriggerDelayTime"] = { "autostat.triggerdelay",    "mult", true,        pr = 200 },

    ["Override_Ammo"] = {"autostat.ammotype", "func", function(wep, val, att)
        -- have to use the weapons table here because Primary.Ammo *is* modified when attachments are used
        if !IsValid(wep) or !weapons.Get(wep:GetClass()) or weapons.Get(wep:GetClass()).Primary.Ammo == val then return end
        return string.format(translate("autostat.ammotype"), string.lower(ArcCW.TranslateAmmo(val))), "infos"
    end, pr = 316},
    ["Override_ClipSize"] = {"autostat.clipsize", "func", function(wep, val, att)
        if !IsValid(wep) then return end
        local ogclip = wep:GetBuff_Override("BaseClipSize") or (wep.RegularClipSize or (wep.Primary and wep.Primary.ClipSize) or 0)
        if ogclip < val then
            return string.format(translate("autostat.clipsize"), val), "pros"
        else
            return string.format(translate("autostat.clipsize"), val), "cons"
        end
    end, pr = 317},
    ["Bipod"] = {"autostat.bipod2", "func", function(wep, val, att)
        if val then
            local recoil = 100 - math.Round((att.Mult_BipodRecoil or (IsValid(wep) and wep.BipodRecoil) or 1) * 100)
            local disp = 100 - math.Round((att.Mult_BipodDispersion or (IsValid(wep) and wep.BipodDispersion) or 1) * 100)
            return string.format(translate("autostat.bipod2"), disp, recoil), "pros"
        else
            return translate("autostat.nobipod"), "cons"
        end
    end, pr = 314},
    ["UBGL"] = { "autostat.ubgl",  "override", false,        pr = 950 },
    ["UBGL_Ammo"] = {"autostat.ammotypeubgl", "func", function(wep, val, att)
        -- have to use the weapons table here because Primary.Ammo *is* modified when attachments are used
        if !IsValid(wep) then return end
        return string.format(translate("autostat.ammotypeubgl"), string.lower(ArcCW.TranslateAmmo(val))), "infos"
    end, pr = 949},

    ["Add_AccuracyMOA"] = { "autostat.precision",   "func",  function(wep, val, att)
        if val > 0 then
            return "+" .. math.Round(val, 2) .. " " .. translate("unit.moa") .. " " .. translate("autostat.precision"), "cons"
        else
            return "-" .. math.Round(val, 2) .. " " .. translate("unit.moa") .. " " .. translate("autostat.precision"), "pros"
        end
    end, pr = 187 },
}

local function getsimpleamt(stat)
    if stat > 1 then
        return stat >= 2 and "++++ " or stat >= 1.5 and "+++ " or stat >= 1.25 and "++ " or "+ "
    elseif stat < 1 then
        return stat <= 0.75 and "---- " or stat <= 0.5 and "--- " or stat <= 0.25 and "-- " or "- "
    end
end

local function stattext(wep, att, i, k, dmgboth, flipsigns)
    if !ArcCW.AutoStats[i] then return end
    if i == "Mult_DamageMin" and dmgboth then return end

    local stat = ArcCW.AutoStats[i]
    local simple = ArcCW.ConVars["attinv_simpleproscons"]:GetBool()

    local txt = ""
    local str, eval = ArcCW.GetTranslation(stat[1]) or stat[1], stat[3]

    if i == "Mult_Damage" and dmgboth then
        str = ArcCW.GetTranslation("autostat.damageboth") or stat[1]
    end

    local tcon, tpro = eval and "cons" or "pros", eval and "pros" or "cons"

    if stat[3] == "infos" then
        tcon = "infos"
    end

    if stat[2] == "mult" and k != 1 then
        local sign, percent = k > 1 and (flipsigns and "-" or "+") or (flipsigns and "+" or "-"), k > 1 and (k - 1) or (1 - k)
        txt = simple and getsimpleamt(k) or sign .. tostr(math.Round(percent * 100, 2)) .. "% "
        return txt .. str, k > 1 and tcon or tpro
    elseif stat[2] == "add" and k != 0 then
        local sign, state = k > 0 and (flipsigns and "-" or "+") or (flipsigns and "+" or "-"), k > 0 and k or -k
        txt = simple and "+ " or sign .. tostr(state) .. " "
        return txt .. str, k > 0 and tcon or tpro
    elseif stat[2] == "override" and k == true then
        return str, tcon
    elseif stat[2] == "func" then
        local a, b = stat[3](wep, k, att)
        if a and b then return a, b end
    end
end

function ArcCW:GetProsCons(wep, att, toggle)
    local pros = {}
    local cons = {}
    local infos = {}

    tbl_add(pros, att.Desc_Pros or {})
    tbl_add(cons, att.Desc_Cons or {})
    tbl_add(infos, att.Desc_Neutrals or {})

    local override = hook.Run("ArcCW_PreAutoStats", wep, att, pros, cons, infos, toggle)
    if override then return pros, cons, infos end

    -- Localize attachment-specific text
    local hasmaginfo = false
    for i, v in pairs(pros) do
        if v == "pro.magcap" then hasmaginfo = true end
        pros[i] = ArcCW.TryTranslation(v)
    end
    for i, v in pairs(cons) do
        if v == "con.magcap" then hasmaginfo = true end
        cons[i] = ArcCW.TryTranslation(v)
    end
    for i, v in pairs(infos) do infos[i] = ArcCW.TryTranslation(v) end

    if !att.AutoStats then return pros, cons, infos end

    -- Process togglable stats
    if att.ToggleStats then
        --local toggletbl = att.ToggleStats[toggle or 1]
        for ti, toggletbl in pairs(att.ToggleStats) do
            -- show the first stat block (unless NoAutoStats), and all blocks with AutoStats
            if toggletbl.AutoStats or (ti == (toggle or 1) and !toggletbl.NoAutoStats) then
                local dmgboth = toggletbl.Mult_DamageMin and toggletbl.Mult_Damage and toggletbl.Mult_DamageMin == toggletbl.Mult_Damage
                for i, stat in SortedPairsByMemberValue(ArcCW.AutoStats, "pr", true) do
                    if !toggletbl[i] or toggletbl[i .. "_SkipAS"] then continue end
                    local val = toggletbl[i]
                    --[[]
                    -- makes the stat show as a sum and not an additional modifier
                    -- feels more confusing though
                    if att[i] then
                        if stat[2] == "add" then
                            val = val + att[i]
                        elseif stat[2] == "mult" then
                            val = val * att[i]
                        end
                    end
                    ]]

                    local txt, typ = stattext(wep, toggletbl, i, val, dmgboth, ArcCW.AutoStats[i].flipsigns )
                    if !txt then continue end

                    local prefix = (stat[2] == "override" and k == true) and "" or ("[" .. (toggletbl.AutoStatName or toggletbl.PrintName or ti) .. "] ")

                    if typ == "pros" then
                        tbl_ins(pros, prefix .. txt)
                    elseif typ == "cons" then
                        tbl_ins(cons, prefix .. txt)
                    elseif typ == "infos" then
                        tbl_ins(infos, prefix .. txt)
                    end
                end
            end
        end
    end

    local dmgboth = att.Mult_DamageMin and att.Mult_Damage and att.Mult_DamageMin == att.Mult_Damage

    for i, stat in SortedPairsByMemberValue(ArcCW.AutoStats, "pr", true) do
        if !att[i] or att[i .. "_SkipAS"] then continue end

        -- Legacy support: If "Increased/Decreased magazine capacity" line exists, don't do our autostats version
        if hasmaginfo and i == "Override_ClipSize" then continue end

        if i == "UBGL" then
			tbl_ins(infos, translate("autostat.ubgl2"))
		end

        local txt, typ = stattext(wep, att, i, att[i], dmgboth, ArcCW.AutoStats[i].flipsigns )
        if !txt then continue end

        if typ == "pros" then
            tbl_ins(pros, txt)
        elseif typ == "cons" then
            tbl_ins(cons, txt)
        elseif typ == "infos" then
            tbl_ins(infos, txt)
        end

        --[[]
        if i == "Mult_DamageMin" and dmgboth then continue end

        local k, txt  = att[i], ""
        local str, st = ArcCW.GetTranslation(stat[1]) or stat[1], stat[3]

        if i == "Mult_Damage" and dmgboth then
            str = ArcCW.GetTranslation("autostat.damageboth") or stat[1]
        end

        local tcon, tpro = st and cons or pros, st and pros or cons

        if stat[2] == "mult" and k != 1 then
            local sign, percent = k > 1 and "+" or "-", k > 1 and (k - 1) or (1 - k)

            txt = simple and getsimpleamt(k) or sign .. tostr(math.Round(percent * 100, 2)) .. "% "

            tbl_ins(k > 1 and tcon or tpro, txt .. str)
        elseif stat[2] == "add" and k != 0 then
            local sign, state = k > 0 and "+" or "-", k > 0 and k or -k

            txt = simple and "+ " or sign .. tostr(state) .. " "

            tbl_ins(k > 1 and tpro or tcon, txt .. str)
        elseif stat[2] == "override" and k == true then
            tbl_ins(st and cons or pros, 1, str)
        end
        ]]
    end

    hook.Run("ArcCW_PostAutoStats", wep, att, pros, cons, infos, toggle)

    return pros, cons, infos
end
--addons/auralvsradar/lua/autorun/aura_lfs_fight_handler.lua:
-- Aura's LVS/LFS Fight Radar!
-- Finally with comments!

if SERVER then
	include( "aura_lvs_radar/aura_lvs_radar_server.lua" )
	AddCSLuaFile( "aura_lvs_radar/aura_lvs_radar_client.lua" )
	AddCSLuaFile( "aura_lvs_radar/aura_lvs_radar_util.lua" )
	AddCSLuaFile( "aura_lvs_radar/aura_lvs_radar_hooks.lua" )
end

if CLIENT then
	include( "aura_lvs_radar/aura_lvs_radar_util.lua" )
	include( "aura_lvs_radar/aura_lvs_radar_client.lua" )
	include( "aura_lvs_radar/aura_lvs_radar_hooks.lua" )
end
--addons/sh_lounge_chatbox/lua/autorun/autorun_lounge_chatbox.lua:
LOUNGE_CHAT = {}

include("chatbox_config.lua")
include("chatbox/sh_obj_player_extend.lua")
	
if (SERVER) then
	AddCSLuaFile("autorun_lounge_chatbox.lua")
	AddCSLuaFile("chatbox_config.lua")
	AddCSLuaFile("chatbox_emoticons.lua")
	AddCSLuaFile("chatbox_markups.lua")
	AddCSLuaFile("chatbox_tags.lua")
	AddCSLuaFile("chatbox/cl_util.lua")
	AddCSLuaFile("chatbox/cl_markups.lua")
	AddCSLuaFile("chatbox/cl_chatbox.lua")
	AddCSLuaFile("chatbox/cl_colors.lua")
	AddCSLuaFile("chatbox/cl_options.lua")
	AddCSLuaFile("chatbox/sh_obj_player_extend.lua")

	include("chatbox/sv_chatbox.lua")
else
	include("chatbox/cl_util.lua")
	include("chatbox/cl_markups.lua")
	include("chatbox/cl_chatbox.lua")
	include("chatbox/cl_colors.lua")
	include("chatbox/cl_options.lua")

	include("chatbox_emoticons.lua")
	include("chatbox_markups.lua")
	include("chatbox_tags.lua")
end
--addons/aoc_fire_system/lua/ch_fire_system/shared/firetrucks_config.lua:
CH_FireSystem.Trucks = CH_FireSystem.Trucks or {}

-- Default Firetrucks
CH_FireSystem.Trucks[ "FIRETRUCK_EOneLadder" ] = { 
	Name = "E-One Cyclone II Ladder",
	Description = "Realistic E-One Ladder firetruck for the fire fighter team.",
	Model = "models/perrynsvehicles/pierce_arrow_xt/pierce_arrow_xt.mdl",
	Script = "scripts/vehicles/perryn/pierce_arrow_xt.txt",
	Health = 200,
	VehicleSkin = 0,
	AllowedTeamNames = {
		"Fire Fighter",
	},
	AllowedTeams = {
		TEAM_FIREFIGHTERCHIEF,
	},
	ULXRanksAllowed = {
		"user",
		"admin",
		"superadmin",
	},
}

CH_FireSystem.Trucks[ "FIRETRUCK_HeavyRescue" ] = { 
	Name = "Heavy Rescue Firetruck",
	Description = "Heavy rescue firetruck specifically for large tasks and only for the chief.",
	Model = "models/perrynsvehicles/rescue_truck/rescue_truck.mdl",
	Script = "scripts/vehicles/perryn/rescue_truck.txt",
	Health = 200,
	VehicleSkin = 0,
	AllowedTeamNames = {
		"Fire Fighter Chief",
		"Fire Fighter",
		"Fire fighter pussy"
	},
	AllowedTeams = {
		TEAM_FIREFIGHTERCHIEF,
	},
	ULXRanksAllowed = {
		"user",
		"admin",
		"superadmin",
		"user",
		"admin",
		"superadmin",
	},
}

-- Looking for more fire trucks? I have pre-configured more fire trucks.
-- You can find the codes here: https://www.gmodstore.com/help/addon/302/adding-firetrucks
--addons/aoc_fire_system/lua/ch_fire_system/client/fire_fonts.lua:
surface.CreateFont("FIRE_UIFontTitle", {
    font = "Trebuchet MS", 
    size = ScreenScale( 10 ), 
    weight = 800,
	blursize = 0
})

surface.CreateFont("FIRE_UIFontText", {
    font = "Trebuchet MS", 
	size = ScreenScale( 7.5 ), 
	weight = ScreenScale( 300 )
})

surface.CreateFont("FIRE_UIFontTextButton", {
    font = "Trebuchet MS", 
	size = ScreenScale( 7 ), 
	weight = ScreenScale( 300 )
})

surface.CreateFont("FIRE_ExtCabinet", {
    font = "Trebuchet MS", 
    size = ScreenScale( 19 ), 
    weight = 800,
	blursize = 0
})
--addons/aoc_fire_system/lua/ch_fire_system/client/fire_menus.lua:
print( "CL - Crap-Head's Fire System Initialized" )
isdarkrpfiresystemactive = true

net.Receive( "FIRE_SendTruckModelCL", function( len, ply )
	LocalPlayer().CurVehModel = net.ReadString()
end )

local mat_col_spec = 1 -- 76561197989440650
local mat_col = Color( 255, 255, 255, 255 )
local ff_ui = Material( "craphead_scripts/fire_system/ff_ui.png" )

local col_white = Color( 255, 255, 255, 255 )
local col_invs = Color( 42, 100, 42, 0 )

local col_gray_text = Color( 100, 100, 100, 255 )
local col_gray_scroll = Color( 24, 24, 24, 100 )
local col_red_scroll = Color( 255, 29, 29, 155 )

local col_red_button = Color( 255, 29, 29, 255 )
local col_gray_button = Color( 30, 30, 30, 255 )

local col_bg_outer = Color( 22, 22, 24, 255 )
local col_bg_inner = Color( 19, 19, 21, 255 )

net.Receive( "FIRE_FiretruckMenu", function( len, ply )
	local VehMenu = vgui.Create( "DFrame" )
	VehMenu:SetTitle( "" )
	VehMenu:SetSize( ScrW() * 0.5, ScrH() * 0.5 )
	VehMenu:SetPos( ScrW() * 0.5, ScrH() * 0.5 )
	VehMenu:Center()
	VehMenu.Paint = function( self )
		surface.SetDrawColor( mat_col )
		surface.SetMaterial( ff_ui )
		surface.DrawTexturedRect( 0, 0, ScrW() * 0.48, ScrH() * 0.495 )
		
		-- Draw the top title.
		draw.SimpleText("Firetruck Station", "FIRE_UIFontTitle", ScrW() * 0.082, ScrH() * 0.052, col_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end
	VehMenu:MakePopup()
	VehMenu:ShowCloseButton( false )
	
	local VehMainExit = vgui.Create( "DButton", VehMenu )
	VehMainExit:SetSize( ScreenScale( 6.5 ), ScreenScale( 6.5 ) )
	VehMainExit:SetPos( ScrW() * 0.465, ScrH() * 0.04 )
	VehMainExit:SetText( "" )
	VehMainExit.Paint = function()
	end
	VehMainExit.DoClick = function()
		VehMenu:Remove()
	end
	
	local VehListPanel = vgui.Create( "DPanelList", VehMenu )
	VehListPanel:SetTall( ScreenScale( 147.5 ) )
	VehListPanel:SetWide( ScrW() * 0.466 )
	VehListPanel:SetPos( ScrW() * 0.009, ScrH() * 0.073 )
	VehListPanel:EnableVerticalScrollbar( true )
	VehListPanel:EnableHorizontal( true )
	VehListPanel.Paint = function()
		draw.RoundedBox( 2, 0, 2, VehListPanel:GetWide(), VehListPanel:GetTall(), col_invs )
	end
	if ( VehListPanel.VBar ) then
		VehListPanel.VBar.Paint = function(self, w, h)
			draw.RoundedBox( 0, 0, 0, w, h, col_gray_scroll ) -- BG
		end
		
		VehListPanel.VBar.btnUp.Paint = function(self, w, h)
			draw.RoundedBox( 4, 0, 2, w, h, col_invs )
		end
		
		VehListPanel.VBar.btnGrip.Paint = function(self, w, h)
			draw.RoundedBoxEx( 16, 0, 0, w, h, col_red_scroll, true, true, true, true )
		end
		
		VehListPanel.VBar.btnDown.Paint = function(self, w, h)
			draw.RoundedBox( 0, 0, 0, w, h, col_invs )
		end
	end
	
	for k, v in pairs( CH_FireSystem.Trucks ) do
		if v.Name then
			local VehPanel = vgui.Create("DPanelList")
			VehPanel:SetTall( ScreenScale( 55 ) )
			VehPanel:SetWide( ScrW() * 0.455 )
			VehPanel:SetPos( ScreenScale( 3.3 ), ScreenScale( 10 ) )
			VehPanel:SetSpacing( 10 )
			VehPanel.Paint = function()
				-- Outer
				draw.RoundedBox( 2, ScrW() * 0.007, ScrH() * 0.0125, VehPanel:GetWide(),VehPanel:GetTall(), col_bg_outer )
				
				-- Firetruck model frame
				draw.RoundedBox( 2, ScrW() * 0.01, ScrH() * 0.0175, ScrW() * 0.125, ScrH() * 0.13, col_bg_inner )
				
				-- Firetruck text frame
				draw.RoundedBox( 2, ScrW() * 0.138, ScrH() * 0.0175, ScrW() * 0.313, ScrH() * 0.13, col_bg_inner )
			end
			
			surface.SetFont( "FIRE_UIFontText" )
			local x, y = surface.GetTextSize( v.Name )
			
			local VehNameText = vgui.Create( "DLabel", VehPanel )
			VehNameText:SetPos( ( VehPanel:GetWide() / 6.25 ) - ( x / 2 ), ScrH() * 0.025 )
			VehNameText:SetFont( "FIRE_UIFontText" )
			VehNameText:SetColor( col_white )
			VehNameText:SetText( v.Name )
			VehNameText:SizeToContents()
			
			local VehIcon = vgui.Create( "DModelPanel", VehPanel )
			VehIcon:SetPos( -15, ScreenScale( 14 ) )
			VehIcon:SetSize( ScreenScale( 90 ), ScreenScale( 35 ) )
			VehIcon:SetModel( v.Model )
			VehIcon:GetEntity():SetAngles( Angle( -10, 0, 15 ) )
			local mn, mx = VehIcon.Entity:GetRenderBounds()
			local size = 0
			size = math.max( size, math.abs( mn.x ) + math.abs( mx.x ) )
			size = math.max( size, math.abs( mn.y ) + math.abs( mx.y ) )
			size = math.max( size, math.abs( mn.z ) + math.abs( mx.z ) )
			VehIcon:SetFOV( 45 )
			VehIcon:SetCamPos( Vector( size, size, size ) )
			VehIcon:SetLookAt( (mn + mx) * 0.5 )
			function VehIcon:LayoutEntity( Entity ) return end
			
			-- Vehicle Description
			local VehDescTitle = vgui.Create( "DLabel", VehPanel )
			VehDescTitle:SetPos( ScrW() * 0.145, ScrH() * 0.025 )
			VehDescTitle:SetFont( "FIRE_UIFontText" )
			VehDescTitle:SetColor( col_gray_text )
			VehDescTitle:SetText( "Description" )
			VehDescTitle:SizeToContents()
			
			local x, y = surface.GetTextSize( v.Description )

			local VehDescText = vgui.Create( "DLabel", VehPanel )
			if x <= 500 then
				VehDescText:SetPos( ScrW() * 0.145, ScrH() * 0.03 )
			elseif x <= 1000 then
				VehDescText:SetPos( ScrW() * 0.145, ScrH() * 0.04 )
			else
				VehDescText:SetPos( ScrW() * 0.145, ScrH() * 0.05 )
			end
			
			VehDescText:SetSize( ScrW() * 0.27, ScrH() * 0.055 )
			VehDescText:SetFont( "FIRE_UIFontText" )
			VehDescText:SetColor( col_white )
			VehDescText:SetWrap( true )
			VehDescText:SetText( v.Description )
			
			-- Vehicle required jobs
			local VehJobsTitle = vgui.Create( "DLabel", VehPanel )
			VehJobsTitle:SetPos( ScrW() * 0.145, ScrH() * 0.1 )
			VehJobsTitle:SetFont( "FIRE_UIFontText" )
			VehJobsTitle:SetColor( col_gray_text )
			VehJobsTitle:SetText( "Required Job" )
			VehJobsTitle:SizeToContents()
			
			local VehJobsText = vgui.Create( "DLabel", VehPanel )
			VehJobsText:SetPos( ScrW() * 0.145, ScrH() * 0.11 )
			VehJobsText:SetSize( ScrW() * 0.124, ScrH() * 0.04 )
			VehJobsText:SetFont( "FIRE_UIFontText" )
			VehJobsText:SetColor( col_white )
			VehJobsText:SetText( table.concat(v.AllowedTeamNames,", ") )
			
			-- Vehicle required ulx rank
			local VehRankTitle = vgui.Create( "DLabel", VehPanel )
			VehRankTitle:SetPos( ScrW() * 0.27, ScrH() * 0.1 )
			VehRankTitle:SetFont( "FIRE_UIFontText" )
			VehRankTitle:SetColor( col_gray_text )
			VehRankTitle:SetText( "Allowed Rank" )
			VehRankTitle:SizeToContents()
			
			local VehRankText = vgui.Create( "DLabel", VehPanel )
			VehRankText:SetPos( ScrW() * 0.27, ScrH() * 0.11 )
			VehRankText:SetSize( ScrW() * 0.1, ScrH() * 0.04 )
			VehRankText:SetFont( "FIRE_UIFontText" )
			VehRankText:SetColor( col_white )
			if CH_FireSystem.Config.UseRequiredULXRanks then
				VehRankText:SetText( table.concat(v.ULXRanksAllowed,", ") )
			else
				VehRankText:SetText( "All Ranks" )
			end
			
			-- Retrieve/Remove buttons
			-- Remove
			if LocalPlayer().CurVehModel == v.Model then
				local VehRemoveCurrent = vgui.Create("DButton", VehPanel)
				VehRemoveCurrent:SetPos( ScrW() * 0.372, ScrH() * 0.11 )
				VehRemoveCurrent:SetSize( ScrW() * 0.075, ScrH() * 0.031 )
				VehRemoveCurrent:SetText("")
				VehRemoveCurrent.Paint = function()
					draw.RoundedBox( 8, 0, 0, VehRemoveCurrent:GetWide(), VehRemoveCurrent:GetTall(), col_gray_button )
					
					local struc = {}
					struc.pos = {}
					struc.pos[1] = ScrW() * 0.0375
					struc.pos[2] = ScrH() * 0.0145
					struc.color = col_white
					struc.text = "Remove Firetruck" 
					struc.font = "FIRE_UIFontTextButton"
					struc.xalign = TEXT_ALIGN_CENTER
					struc.yalign = TEXT_ALIGN_CENTER
					draw.Text( struc )
				end
				VehRemoveCurrent.DoClick = function()
					VehMenu:Remove()
					
					net.Start( "FIRE_RemoveFireTruck" )
					net.SendToServer()
					LocalPlayer().CurVehModel = nil
				end
			-- Retrieve
			else
				local VehRetrieveTruck = vgui.Create("DButton", VehPanel)
				VehRetrieveTruck:SetPos( ScrW() * 0.372, ScrH() * 0.11 )
				VehRetrieveTruck:SetSize( ScrW() * 0.075, ScrH() * 0.031 )
				VehRetrieveTruck:SetText("")
				VehRetrieveTruck.Paint = function()
					draw.RoundedBox( 8, 0, 0, VehRetrieveTruck:GetWide(), VehRetrieveTruck:GetTall(), col_red_button )
					
					local struc = {}
					struc.pos = {}
					struc.pos[1] = ScrW() * 0.0375
					struc.pos[2] = ScrH() * 0.0145
					struc.color = col_white
					struc.text = "Retrieve Firetruck" 
					struc.font = "FIRE_UIFontTextButton"
					struc.xalign = TEXT_ALIGN_CENTER
					struc.yalign = TEXT_ALIGN_CENTER
					draw.Text( struc )
				end
				VehRetrieveTruck.DoClick = function()
					VehMenu:Remove()
					
					net.Start("FIRE_CreateFireTruck")
						net.WriteString( k )
					net.SendToServer()
				end
			end
			
			VehListPanel:AddItem( VehPanel )
		end
	end
end )
--addons/gm_express_binding/lua/gm_express_bindings/adv2/sh_init.lua:
AddCSLuaFile()

local Module = { default = true }

if SERVER then
    AddCSLuaFile( "cl_init.lua" )
    include( "sv_init.lua" )( Module )
else
    include( "cl_init.lua" )( Module )
end

function Module:IsValid()
    return AdvDupe2 ~= nil
end

ExpressBindings.RegisterModule( "adv2", Module )

--addons/gm_express_binding/lua/gm_express_bindings/pac3/sh_init.lua:
AddCSLuaFile()

local Module = { default = true }

if SERVER then
    AddCSLuaFile( "cl_init.lua" )
    include( "sv_init.lua" )( Module )
else
    include( "cl_init.lua" )( Module )
end

function Module:IsValid()
    return pac ~= nil
end

ExpressBindings.RegisterModule( "pac3", Module )

--addons/aocrp_map/lua/gmaps/cl_dmap.lua:

-- hook.Add("PostDrawSkybox","Render GMaps", self.RenderMap, self)

local blur = Material("pp/blurscreen");
local MapMaterial = CreateMaterial(
		"GMapsMat",
		"UnlitGeneric",
		{
			[ '$basetexture' ] = "debug/error",
		}
)

local PNL = {}
AccessorFunc(PNL,"CamPos","CamPos")
AccessorFunc(PNL,"Follow","Follow",FORCE_BOOL)
AccessorFunc(PNL,"RotFollow","RotFollow",FORCE_BOOL)
AccessorFunc(PNL,"ZOff","ZOff", FORCE_NUMBER)
AccessorFunc(PNL,"Yaw","Yaw", FORCE_NUMBER)
AccessorFunc(PNL,"Zoom","Zoom",FORCE_NUMBER)

gmaps.mapID = gmaps.mapID or 1
function PNL:Init()
	
	AOCDerma:RegisterFont("AOCRP.MAP.SQUADMARKER", "Aurebesh", 15, 1)
AOCDerma:RegisterFont("AOCRP.MAP.NAME", "Agency FB", 15, 1)
AOCDerma:RegisterFont("AOCRP.MAP.MARKER", "Aurebesh", 20, 1)
AOCDerma:RegisterFont("AOCRP.MAP.MARKERNAME", "Agency FB", 15, 1)


	gmaps.mapID = gmaps.mapID + 1
	self.ID = gmaps.mapID
	self:SetName("DMap"..gmaps.mapID)
	self:SetYaw(0)
	
	-- local w,h = 2,2
	-- while w < ScrW() do
		-- w = bit.lshift(w,1)
	-- end
	-- while h < ScrH() do
		-- h = bit.lshift(h,1)
	-- end
	local w,h = 2048,1024
	self.MapRT = GetRenderTarget("DMap",w,h,false)--RT_SIZE_FULL_FRAME_BUFFER,MATERIAL_RT_DEPTH_SHARED,16,0,IMAGE_FORMAT_DEFAULT)
	
	self.ZSlide = vgui.Create("ZSlider",self)
	self.ZSlide:SetPos(25,25+26)
	self.ZSlide:SetTall(180)
	function self.ZSlide.OnUpdate(this,y)
		self:SetFollow(false)
		self:SetZOff(y*(self:GetMapHeight()))
	end
	
	self.Home = vgui.Create("DImageButton",self)
	self.Home:SetSize(24,24)
	self.Home:SetPos(24,24)
	self.Home:SetText("")
	self.Home:SetImage("gmaps/home.png")
	self.Home:SetColor(Color(240,240,240))
	
	self.Comp = vgui.Create("DImageButton",self)
	self.Comp:SetSize(64,64)
	self.Comp:SetText("")
	self.Comp:SetColor(Color(255,255,255))
	local t = Material("materials/gmaps/compass.png","unlitgeneric smooth")
	function self.Comp.Paint(this,w,h) //Shitload of code and stencil wizardry for a barely noticable blur starts here:
		-- local x, y = this:LocalToScreen(0, 0);
		-- render.SetStencilEnable(true)
			-- render.ClearStencilBufferRectangle(x,y,w,h,0)
			-- render.SetStencilTestMask(255)
			-- render.SetStencilWriteMask(255)
			-- render.SetStencilReferenceValue(1)
			-- render.SetStencilCompareFunction(STENCIL_NEVER)
			-- render.SetStencilFailOperation(STENCIL_REPLACE)
			-- render.SetStencilZFailOperation(STENCIL_REPLACE)
			-- render.SetStencilPassOperation(STENCIL_KEEP)
			
			-- draw.NoTexture()
			-- gmaps.Circle(w/2,h/2,w/2-2,Color(255,255,255),2)
			
			-- render.SetStencilCompareFunction(STENCIL_EQUAL)
			-- render.SetStencilPassOperation(STENCIL_REPLACE)
			
			-- surface.SetDrawColor(color_white);
			-- surface.SetMaterial(blur);
			-- for i = 1, 5 do
				-- blur:SetFloat("$blur", (i / 5) * 10);
				-- blur:Recompute();
				-- render.UpdateScreenEffectTexture();
				-- render.SetStencilReferenceValue(i)
				
				-- surface.DrawTexturedRect(x * -1, y * -1, ScrW(), ScrH());
			-- end
		
		-- render.SetStencilEnable(false)
		
		surface.SetMaterial(t)
		surface.DrawTexturedRectRotated(w/2,h/2,w,h,-(self:GetYaw() or 0))
	end
	
	function self.Home.DoClick(this)
		self:ResetCamera(.7)
	end
	function self.Comp.DoClick(this)
		if self:GetRotFollow() then
			self:SetRotFollow(false)
			self:MoveCamera(.7,self:GetCamPos(),self:GetZOff(),0,self:GetZoom())
		else
			self:SetRotFollow(true)
			self:MoveCamera(.7,self:GetCamPos(),self:GetZOff(),LocalPlayer():GetAngles().y,self:GetZoom())
		end
	end
	
	-- self:SetRotFollow(true)
	self:ResetCamera(0)
	
	self.Dragging = false
	
end

function PNL:GetMapHeight()
	return self:GetMaxZ()-self:GetMinZ()
end
function PNL:GetMinZ()
	if not gmaps.Config.Maps[game.GetMap()].minz then
		local mins,maxs = game.GetWorld():GetRenderBounds()
		gmaps.Config.Maps[game.GetMap()].minz = gmaps.Config.Maps[game.GetMap()].minz or mins.z
		gmaps.Config.Maps[game.GetMap()].maxz = gmaps.Config.Maps[game.GetMap()].maxz or maxs.z
	end
	return gmaps.Config.Maps[game.GetMap()].minz
end
function PNL:GetMaxZ()
	if not gmaps.Config.Maps[game.GetMap()].maxz then
		local mins,maxs = game.GetWorld():GetRenderBounds()
		gmaps.Config.Maps[game.GetMap()].minz = gmaps.Config.Maps[game.GetMap()].minz or mins.z
		gmaps.Config.Maps[game.GetMap()].maxz = gmaps.Config.Maps[game.GetMap()].maxz or maxs.z
	end
	return gmaps.Config.Maps[game.GetMap()].maxz
end

function PNL:SetCamPos(p)
	p.z = self:GetMaxZ()+1
	self.CamPos = p
	self:InvalidateLayout(true)
end

function PNL:SetZOff(z)
	self.ZOff = math.Clamp(z, 0, self:GetMapHeight())
	self.ZSlide:SetSlideY(self.ZOff/self:GetMapHeight())
	
	-- if !self:GetFollow() then
		-- self:ClearPOIInfo()
	-- end
end

function PNL:MoveCamera(time,p,tzoff,tyaw,tzoom)
	
	local curpos = self:GetCamPos() or Vector(0,0,0)
	local zoff = self:GetZOff() or 0
	local zoom = self:GetZoom() or 0
	local yaw = self:GetYaw() or 0
	
	self.anim = Derma_Anim( "GMapsCamSet"..self.ID, self, function( pnl, anim, delta, data )
		if pnl:GetFollow() then
			p = LocalPlayer():GetShootPos()
			p.z = pnl:GetMaxZ()
			-- tyaw = LocalPlayer():GetAngles().y
		end
		pnl:SetZOff(Lerp(delta,zoff,tzoff))
		pnl:SetZoom(Lerp(delta, zoom, tzoom))
		pnl:SetCamPos(LerpVector(delta,curpos,p))
		pnl:SetYaw(Lerp(delta, yaw, tyaw))
	end )
	self.anim:Start( time )
	
end
function PNL:ResetCamera(time,rot)
	
	self:SetFollow(true)
	local p = LocalPlayer():GetShootPos()
	local pz = util.TraceLine({start=p,endpos=p+Vector(0,0,32000),filter=LocalPlayer()}).HitPos.z
	p.z = self:GetMaxZ()
	
	local yaw = self:GetYaw() or 0
	if rot then
		self:SetRotFollow(true)
		yaw = LocalPlayer():GetAngles().y
	end
	
	self:MoveCamera(time, p, self:GetMaxZ()-pz, yaw, gmaps.HomeZoom:GetInt())
end

function PNL:PerformLayout(w,h)
	
	local ch = math.Clamp(h/8,32,64)
	
	self.Comp:SetSize(ch,ch)
	self.Comp:AlignBottom(ch/4)
	self.Comp:AlignLeft(ch/4)
	
	self.Home:AlignTop(ch/4)
	self.Home:AlignLeft(ch/4)
	
	self.ZSlide:AlignTop(ch/4+25)
	self.ZSlide:AlignLeft(ch/4+1)
	self.ZSlide:SetTall(h/3.5)
end

function PNL:Paint(w,h)
	
	//Process animation
	if self.anim and self.anim:Active() then
		if self.Dragging then
			self.anim:Stop() 
		else
			self.anim:Run()
		end
	else
		if self:GetFollow() then
			local p = LocalPlayer():GetShootPos()
			local pz = util.TraceLine({start=p,endpos=p+Vector(0,0,32000),filter=LocalPlayer()}).HitPos.z
			p.z = self:GetMaxZ()
			self:SetCamPos(p)
			self:SetZOff(self:GetMaxZ()-pz)
		end
		if self:GetRotFollow() then
			self:SetYaw(LocalPlayer():GetAngles().y)
		end
	end
	
	//Process dragging
	if self.Dragging then
		local mx,my = self:GetMousePos()
		local dmx,dmy = self.Dragging[1]-mx, self.Dragging[2]-my
		if (dmx^2+dmy^2) > 6 then
			self:SetFollow(false)
			local v = self.DragStartCamPos
			local omx,omy = self:XYToWorld(v,dmx,dmy) //how much the mouse has moved, translated into world units
			
			local cam = Vector(omx,omy,v.z)
			
			self:SetCamPos(cam)
		end
	end
	
	//Draw debug background
	draw.RoundedBox(0,0,0,w,h,gmaps.Null)
	
	//Render map
	render.PushRenderTarget(self.MapRT,0,0,w,h)
		self:RenderMap(w,h)
	render.PopRenderTarget()
	
	MapMaterial:SetTexture("$basetexture",self.MapRT)
	surface.SetMaterial(MapMaterial)
	local tw,th = self.MapRT:GetMappingWidth(),self.MapRT:GetMappingHeight()
	local u,v = w/tw, h/th
	local x,y = 0,0
	surface.DrawTexturedRectUV(0,0,w,h,x,y,u,v)
	
	//Draw POI
	self:DrawPOI(w,h)
	
	//Draw path
	self:DrawPath()
	
	//Draw player
	self:DrawPlayer(w,h)
	
	for k, v in pairs(player.GetAll()) do
		if v == LocalPlayer() then continue end
		if !v:Alive() then continue end
		if !AOCRP.HUD:ShouldNotDrawTarget(v) then continue end
		if v:GetSquad() != LocalPlayer():GetSquad() then continue end
		self:DrawOtherPlayer(v, w, h)
	end

	if !table.IsEmpty(AOCRP.HUD.SquadMarkers) then
		for k, v in pairs(AOCRP.HUD.SquadMarkers) do
			self:DrawMarker(v, w, h)
		end
	end
	-- draw.RoundedBox(0,w/2-1,h/2-1,2,2,Color(255,255,0))
	-- if ROTATECAM then
		-- self:SetYaw(self:GetYaw() + ROTATECAM)
		
		-- local mx,my = self:GetMousePos()
		-- ABCX = -(w/2-mx)/10
		-- ABCY = -(h/2-my)/10
		-- print(ABCX,ABCY)
	-- end
	
	-- local nx,ny
	-- nx = ABCDEFGX*w/1024 + ABDCEFGOX	--+ math.sin(self:GetYaw()*math.pi/180)*ABCDEFGX
	-- ny = ABCDEFGY*h/1024 --+ math.cos(self:GetYaw()*math.pi/180)*ABCDEFGY
	-- draw.RoundedBox(0,w/2-1+nx,h/2-1+ny,2,2,Color(255,0,0))
	
	
end

function PNL:RenderMap(w,h)
	if not self:IsVisible() then return end
	
	//Paint background
	local c = gmaps.Null
	render.Clear(c.r,c.g,c.b,c.a,true,true)
	
	
	//Render world.
	local zoom = self:GetZoom()
	local x,y = 0,0
	-- local w,h = self.MapRT:Width(), self.MapRT:Height()
	local aw,ah = self:GetAspectOffset()
	
	for k,v in pairs(ents.GetAll()) do
		if not v:IsWorld() then
			v.GMapsNODraw = v:GetNoDraw()
			v:SetNoDraw(true)
		end
	end
		local campos = self:GetCamPos()
		-- campos.z = self:GetMaxZ()+1000
		
		RunConsoleCommand("r_lod",2)
		render.SuppressEngineLighting(true)
		render.SetShadowsDisabled(true)
		render.PushFlashlightMode(false)
		render.PushFilterMag( TEXFILTER.NONE )
		render.PushFilterMin( TEXFILTER.NONE )
			
			gmaps.Rendering = true
			render.RenderView({
				origin = campos, -- change to your liking
				angles = Angle( 90, self:GetYaw(), 0 ), -- change to your liking
				x = x,
				y = y,
				w = ScrW()+20,
				h = ScrH()+20,
				znear = self:GetZOff(),
				zfar = 32000,
				drawviewmodel = false,
				drawmonitors = false,
				drawhud = false,
				ortho=true,
				ortholeft=-zoom/2*aw,
				orthotop=-zoom/2*ah,
				orthoright=zoom/2*aw,
				orthobottom=zoom/2*ah,
			})
			gmaps.Rendering = false
		surface.SetDrawColor( 0,255,0,255 )
			
		render.PopFilterMin()
		render.PopFilterMag()
		render.PopFlashlightMode()
		render.SetShadowsDisabled(false)
		render.SuppressEngineLighting(false)
		RunConsoleCommand("r_lod",-1)
		
		
	for k,v in pairs(ents.GetAll()) do
		if not v:IsWorld() then
			v:SetNoDraw(v.GMapsNODraw)
			v.GMapsNODraw = nil
		end
	end
	
end

hook.Add("PostDrawHUD","Nutscript Fix",function()
	if gmaps.Rendering then return false end
end)

function PNL:DrawPOI(w,h)
	self.POI = {}
	for k,v in pairs(gmaps.POI)do
		
		local x,y = self:WorldToXY(v.pos)
		
		if v.pos.z-64 > self:GetMaxZ()-self:GetZOff() then continue end
		
		if !gmaps.CanSee(v,LocalPlayer()) then
			continue
		end
		
		local s = gmaps.Config.POISize
		surface.SetMaterial(Material(v.icon,"unlitgeneric smooth"))
		surface.SetDrawColor(color_black)
		surface.DrawTexturedRect(x-s/2+1,y-s+1,s,s)
		surface.SetDrawColor(v.color)
		surface.DrawTexturedRect(x-s/2,y-s,s,s)
		
		if gmaps.Config.AlwaysShowLabels then
			self.txt = self.txt or {font="gmaps_FrameTitle"}
			self.txt.text = v.name
			self.txt.pos = {x,y+20}
			self.txt.color = v.color
			self.txt.xalign = TEXT_ALIGN_CENTER
			draw.Text(self.txt)
			self.txt.color = color_black
			draw.TextShadow(self.txt,2,210)
		end
		
		table.insert(self.POI,{x=x-s/2,y=y-s,id=k})
		
	end
end

local flag = Material("materials/gmaps/flag.png","unlitgeneric smooth")
function PNL:DrawPath()
	//Draw the GPS path.
	if gmaps.Path[1] then
		local start = gmaps.Path[1]
		
		for k,v in ipairs(gmaps.Path or {})do
			if k==1 then continue end
			local endpos = v
			local x,y = self:WorldToXY(endpos)
			local x2,y2 = self:WorldToXY(start)
			local ang = -math.atan2(y-y2,x-x2)/(math.pi/180)
			local dist = math.Distance(x,y,x2,y2)
			
			draw.NoTexture()
			surface.SetDrawColor(gmaps.NavPath)
			surface.DrawTexturedRectRotated((x+x2)/2,(y+y2)/2,dist,4,ang)
			
			if k!=#gmaps.Path then
				draw.RoundedBox(4,x-4,y-4,8,8,gmaps.NavPath)
			end
			
			start = endpos
		end
		
		local flagsize = 24
		local last = gmaps.Path[#gmaps.Path]
		local x,y = self:WorldToXY(last)
		surface.SetMaterial(flag)
		surface.SetDrawColor(color_black)
		surface.DrawTexturedRect(x-flagsize/4,y-flagsize+1,flagsize,flagsize)
		surface.SetDrawColor(gmaps.NavFlag)
		surface.DrawTexturedRect(x-flagsize/4,y-flagsize,flagsize,flagsize)
	end
	
end

local pmat = Material("materials/gmaps/arrow.png","unlitgeneric smooth")
function PNL:DrawPlayer(w,h)
	local ang = LocalPlayer():GetAngles().y - self:GetYaw()
	local px,py = self:WorldToXY(LocalPlayer():GetShootPos())
	surface.SetMaterial(pmat)
	surface.SetDrawColor(color_black)
	surface.DrawTexturedRectRotated(px+1,py+1,32,32, ang)
	-- surface.DrawRect(w/2-2,h/2-2,4,4)
	surface.SetDrawColor(gmaps.Player)
	surface.DrawTexturedRectRotated(px,py,32,32, ang)
	-- surface.DrawRect(px-2,py-2,4,4)
end


function PNL:DrawOtherPlayer(ply, w,h)

	if !IsValid(ply) then return end
	local ang = ply:EyeAngles().y - self:GetYaw()
	local px,py = self:WorldToXY(ply:GetShootPos())

	local padding = 16
	px = math.Clamp(px, padding, w - padding)
	py = math.Clamp(py, padding, h - padding)


	surface.SetMaterial(pmat)
	surface.SetDrawColor(color_black)
	surface.DrawTexturedRectRotated(px+1,py+1,16,16, ang)



	local mapMarkerColor = Color(255,255,255,255)
	-- surface.DrawRect(w/2-2,h/2-2,4,4)
	if AOCRP.Config.SquadTeams[ply:GetNetVar("AOCRP.SquadTeam", 1)] then 
		mapMarkerColor = AOCRP.Config.SquadTeams[ply:GetNetVar("AOCRP.SquadTeam", 1)].color
	end

	if LocalPlayer():GetShootPos().z - ply:GetShootPos().z > 300 or LocalPlayer():GetShootPos().z - ply:GetShootPos().z < -300 then mapMarkerColor.a = 10 else mapMarkerColor.a = 255 end


	surface.SetDrawColor(mapMarkerColor)
	surface.DrawTexturedRectRotated(px,py,16,16, ang)
	-- surface.DrawRect(px-2,py-2,4,4)
	AOCDerma:DrawTextShadow(ply:GetCloneName(),AOCDerma:Font("AOCRP.MAP.NAME"),px,py+10,mapMarkerColor, TEXT_ALIGN_CENTER)

end



function PNL:DrawMarker(v,w,h)

	if !AOCRP.Config.SquadMarker[v.id] then return end

	if IsValid(v.target) then 
		v.pos = v.target:GetPos()
	end

	local px,py = self:WorldToXY(v.pos)
	
	local padding = 16
	px = math.Clamp(px, padding, w - padding)
	py = math.Clamp(py, padding, h - padding)


             
	draw.DrawText(AOCRP.Config.SquadMarker[v.id].symbol,AOCDerma:Font("AOCRP.MAP.MARKER"),px,py,AOCRP.Config.SquadMarker[v.id].cl, TEXT_ALIGN_CENTER)
                
	draw.DrawText(v.sender:GetCloneName(),AOCDerma:Font("AOCRP.MAP.MARKERNAME"),px,py+25,Color(255,255,255), TEXT_ALIGN_CENTER)


end

function PNL:GetAspectOffset()
	local aw = self:GetWide()/self:GetTall()
	local ah = 1/aw
	if aw>1 then ah = 1 else aw = 1 end
	return aw,ah
end

local samplesX = {	
	{x=1024,y=-4.8,},
	-- {x=900,y=-6.3,},
	{x=800,y=-9.1,},
	-- {x=700,y=-10.3,},
	{x=600,y=-11.4,},
	-- {x=500,y=-13.4,},
	{x=400,y=-15.1,},
	{x=300,y=-16.8,},
	{x=200,y=-18.6,},
}
local samplesY = {	
	{x=691,y=6.25,},
	-- {x=600,y=4.8,},
	{x=550,y=3.4,},
	-- {x=500,y=2.8,},
	{x=450,y=2.2,},
	-- {x=400,y=1.4,},
	{x=350,y=0.2,},
	{x=300,y=-0.1,},
	{x=250,y=-1.8,},
	{x=200,y=-2.4,},
}
function PNL:GetWackyOffset()
	local w,h = self:GetSize()
	local xoff = math.LagrangeInterpolation(samplesX,w)
	local yoff = math.LagrangeInterpolation(samplesY,h)
	return xoff,yoff
end
function PNL:WorldToXY(vec)
	-- local aw,ah = self:GetWide()/self:GetTall(), self:GetTall()/self:GetWide()
	local aw,ah = self:GetAspectOffset()
	aw = aw*.945
	ah = ah*.945
	local zoom = self:GetZoom()
	local pos = self:GetCamPos()
	
	local rot = pos-vec
	
	rot.x, rot.y = rot.y/(zoom*aw), rot.x/(zoom*ah)
	rot.x, rot.y = rot.x*self:GetWide(), rot.y*self:GetTall()
	
	rot.z = 0
	local rot1 = Vector(rot.x,rot.y,rot.z)
	rot:Rotate(Angle(0,self:GetYaw(),0))
	
	local nx,ny = rot.x+self:GetWide()/2, rot.y+self:GetTall()/2
	local ox,oy = self:GetWackyOffset()
	
	
	nx = nx + ox
	ny = ny + oy

	
	return nx,ny
end
function PNL:XYToWorld(pos,x,y)
	local aw,ah = self:GetAspectOffset()
	
	if !self.Dragging then
		local ox,oy = self:GetWackyOffset()
		x=x-ox
		y=y-oy
	end
	-- else
	aw = aw*.945 //not sure why.
	ah = ah*.945
	-- end
	
	local zoomedx, zoomedy = x*(self:GetZoom()*aw)/self:GetWide(), y*(self:GetZoom()*ah)/self:GetTall()
	
	local vec = Vector(zoomedy,zoomedx,0)
	vec:Rotate(Angle(0,self:GetYaw(),0))
	local nx,ny = vec.x,vec.y
	
	return pos.x-nx,pos.y-ny
end
function PNL:GetPosAt(x,y)
	local o = self:GetCamPos()
	local pos = Vector()
	pos.x,pos.y = self:XYToWorld(o,x-self:GetWide()/2, y-self:GetTall()/2)
	pos.z = self:GetMaxZ()-self:GetZOff()
	
	//Drop to floor.
	pos.z = util.TraceLine({start=pos,endpos=pos-Vector(0,0,32000),filter=LocalPlayer()}).HitPos.z
	
	return pos
end
function PNL:GetMouseVector()
	return self:GetPosAt(self:GetMousePos())
end
function PNL:GetMousePos()
	local x,y = self:ScreenToLocal(gui.MousePos())
	return x,y
end

function PNL:FindPOI(x,y)
	local key = -1
	local s = gmaps.Config.POISize
	for k,v in ipairs(self.POI)do
		if !gmaps.CanSee(v,LocalPlayer()) then continue end
		if v.x < x and x < v.x+s then
			if v.y < y and y < v.y+s then
				key = v.id
				break
			end
		end
	end
	return gmaps.POI[key] or false
end
function PNL:ClearPOIInfo()
	if IsValid(self.POIInfo) then
		self.POIInfo:Remove()
	end
end

function PNL:POIClicked(poi)
	local x,y = self:WorldToXY(poi.pos)
	
	self:ClearPOIInfo()
	
	local pnl = vgui.Create("DPOIInfo",self)
	pnl:SetPOI(poi)
	-- pnl:SetPos(math.Clamp(x-pnl:GetWide()/2,0,self:GetWide()-pnl:GetWide()),math.Clamp(y+2,0,self:GetTall()-pnl:GetTall()))
	
	self.POIInfo = pnl
	
end

function PNL:CenterOnPOI(poi,time)
	self:CenterOnPos(poi.pos,time)
	self:ClearPOIInfo()
	self:POIClicked(poi)
end

function PNL:CenterOnPos(p,time)
	self:SetFollow(false)
	local zo = util.TraceLine({start=p,endpos=p+Vector(0,0,32000),filter=LocalPlayer()}).HitPos.z
	self:MoveCamera(time or .7,p,self:GetMaxZ()-zo,self:GetYaw(),1000)
end	

function PNL:OpenMenu()
	if IsValid(self.Menu) then
		self.Menu:Remove()
	end
	local mx,my = self:GetMousePos()
	local pos = self:GetMouseVector()
	local menu = DermaMenu(self)
	local n
	
	if gmaps.CanNavigate() then
		n = menu:AddOption( "Hierhin navigieren", function() 
			local p = self:GetPosAt(mx,my)
			
			gmaps.NavigateTo(p) 
			self:ResetCamera(.7,true)
		end )
		-- n:SetImage("icon16/arrow_turn_right.png")
		n:SetImage("gmaps/flag16.png")
		n.m_Image:SetImageColor(gmaps.NavFlag)
		
		if gmaps.Path[1] then
			n = menu:AddOption( "Navigation beenden", function() 
				RunConsoleCommand("gmaps_nav_finish")
			end )
			-- n:SetImage("icon16/arrow_turn_right.png")
			n:SetImage("gmaps/error16.png")
			n.m_Image:SetImageColor(Color(200,0,0))
		end
		
		menu:AddSpacer()
	end


	local SubMenu = menu:AddSubMenu( "Squad-Marker" )

	for k, v in pairs(AOCRP.Config.SquadMarker) do
		SubMenu:AddOption( v.title, function() 
			local p = self:GetPosAt(mx,my)
			
			net.Start("AOCRP.Squad.MapCreateMarker")
				net.WriteInt(k, 7)
				net.WriteEntity(LocalPlayer())
				net.WriteVector(p)
				net.WriteEntity(nil)
			net.SendToServer()
		end  )
	end




--[[ 	net.Start("AOCRP.Squad.CreateMarker")
	net.WriteInt(marker, 7)
	net.WriteEntity(sender)
	net.WriteVector(trace.HitPos)
	net.WriteEntity(trace.Entity)
	 ]]
--[[  	n = menu:AddOption( "Create POI...", function()
		self:ClearPOIInfo()
		self:SetFollow(false)
		local p = self:GetPosAt(mx,my)
		
		-- timer.Simple(.7 + FrameTime(),function()
			-- if self:IsValid() then
				local edit = vgui.Create("DPOIEditor",self)
				edit:SetVector(p)
				self.POIInfo = edit
			-- end
		-- end)
		
		self:CenterOnPos(p,time)
	end )
	n:SetImage("gmaps/poiadd16.png")
	n.m_Image:SetImageColor(gmaps.POIRed)
	
	n = menu:AddOption( "View All POI's...", function()
		if IsValid(self.AllPOI) then self.AllPOI:Close() end
		self.AllPOI = vgui.Create("DAllPOI")
		self.AllPOI:SetPanel(self)
		self.AllPOI:SetPos(self:LocalToScreen(self:GetWide()/2-self.AllPOI:GetWide()/2,self:GetTall()/2-self.AllPOI:GetTall()/2))
	end )
	n:SetImage("gmaps/poiall16.png")  ]]
	
	-- menu:AddOption( "Cancel", function() print( "Close pressed" ) end )
	menu:AddSpacer()
	
	n = menu:AddOption("Einstellungen",function()
		if IsValid(self.Settings) then self.Settings:Close() end
		self.Settings = vgui.Create("DGMapsSettings")
		self.Settings:SetPanel(self)
		self.Settings:SetPos(self:LocalToScreen(self:GetWide()/2-self.Settings:GetWide()/2,self:GetTall()/2-self.Settings:GetTall()/2))
	
	end)
	n:SetImage("icon16/cog.png")
	
	self.Menu = menu
	
	menu:Open()
end

function PNL:OnMousePressed(mc)
	if mc == MOUSE_LEFT then
		-- self:SetFollow(false)
		self.Dragging = {self:GetMousePos()}
		self.DragStartCamPos = self:GetCamPos()
		self:MouseCapture(true)
	elseif mc == MOUSE_RIGHT then
		self:ClearPOIInfo()
	end
end
function PNL:OnMouseReleased(mc)
	if mc == MOUSE_LEFT then
		if self.Dragging then
			if (self.DragStartCamPos-self:GetCamPos()):Length2D() < 6*self:GetZoom()/1000 then
				local poi = self:FindPOI(self:GetMousePos())
				self:ClearPOIInfo()
				if poi then
					self:POIClicked(poi)
				end
			end
			self.DragStartCamPos = self:GetCamPos()
			self.Dragging = false
		end
		self:MouseCapture(false)
	elseif mc == MOUSE_RIGHT then
		local poi = self:FindPOI(self:GetMousePos())
		if poi then
			gmaps.POIDetails(poi)
			-- self:POIClicked(poi)
		else
			self:OpenMenu()
		end
	else
		
		-- self:SetCamPos(self:GetMouseVector())
	end
	
end
function PNL:OnMouseWheeled(delta)
	
	if input.IsKeyDown(KEY_LALT) or input.IsKeyDown(KEY_LCONTROL) then
		self.ZSlide:OnMouseWheeled(delta)
	elseif not self:IsChildHovered() then
		self:ScrollZoom(delta)
	end
end

function PNL:ScrollZoom(delta)

	-- self:ClearPOIInfo()
	if delta > 0 then
		
		local zoom = self:GetZoom()
		if zoom > gmaps.Config.MaxZoom then
			
			local dragOrigin = self:GetCamPos();
			local z = dragOrigin.z
			local mousePos = self:GetMouseVector()
			
			// Calculate how much we will have to move towards the zoomTowards position
			local multiplier = (1 / zoom * (delta*gmaps.ZoomSpeed:GetFloat()));
			 
			// Move camera
			dragOrigin = dragOrigin + (mousePos - dragOrigin) * multiplier; 
			dragOrigin.z = z
			
			
			self:SetCamPos(dragOrigin)
		end
	end
	
	self:SetZoom(self:GetZoom()-delta*gmaps.ZoomSpeed:GetFloat())
	
end

function PNL:SetZoom(z)
	self.Zoom = math.Clamp(z,gmaps.Config.MinZoom,gmaps.Config.MaxZoom)
end

vgui.Register("DMap",PNL,"DPanel")

--addons/billy_gas_logging/lua/gmodadminsuite/modules/logging/lang/spanish.lua:
return {
	Name = "Spanish",
	Flag = "flags16/es.png",
	Phrases = function() return {

		module_name = "Billy's Logs",

		--####################### UI PHRASES #######################--

		no_data                     = "Sin registros",
		add_to_evidence_box         = "Agregar a la Caja de Pruebas",
		livelogs_show_logs_for      = "Mostrar Logs Por",
		background_color            = "Color de Fondo",
		health_abbrieviated         = "%d HP",
		livelogs                    = "Logs en Vivo",
		exit_deep_storage           = "Salir del los Registros Profundos",
		log_formatting              = "Formato de log",
		strings                     = "Palabras Clave",
		when                        = "Cuando",
		copy_log                    = "Copiar log",
		evidence_box                = "Caja de Pruebas",
		livelogs_position_x         = "Posición X (pixeles)",
		width                       = "Anchura",
		color                       = "Color",
		help                        = "Ayuda",
		apply_filter                = "Aplicar Filtro",
		live_log_antispam           = "< live log descartado por antispam >",
		settings                    = "Ajustes",
		loading_ellipsis            = "Cargando...",
		livelogs_enabled            = "Habilitar Logs en Vivo",
		armor_abbrieviated          = "%d ARM",
		deep_storage                = "Registros Profundos",
		all_logs                    = "Todos los Logs",
		logs                        = "Logs",
		padding                     = "Relleno (pixeles)",
		livelogs_position_y         = "Posición Y (pixeles)",
		livelogs_rows_help          = "¿Cuál es la cantidad máxima de logs que se deben mostrar?",
		livelogs_rows               = "Filas (Cantidad de log)",
		livelogs_color_help         = "¿Deben mostrarse los registros en color?",
		export_to_clipboard         = "Exportar al portapapeles",
		players                     = "Jugadores",
		script_page                 = "Pagina del Script",
		wiki                        = "Wiki",
		module                      = "Módulo",
		modules                     = "Módulos",
		localization                = "Localización",
		view_deep_storage           = "Ver Registros Profundos",
		copied                      = "Copiado!",
		operator                    = "Operador",
		log                         = "Log",
		reset_to_defaults           = "Restablecer los valores predeterminados",
		livelogs_show_logs_for_help = "¿Por cuántos segundos se deben mostrar los registros?\nEstablecer en 0 para que sea para siempre.",
		advanced_search             = "Búsqueda Avanzada",
		quick_search                = "Búsqueda Rápida",
		quick_search_ellipsis       = "Búsqueda Rápida...",
		entities                    = "Entidades",
		tutorial                    = "Tutorial",
		clear_filters               = "Borrar Filtros",
		clear_filter                = "Borrar Filtro",
		manual_steamid_ellipsis     = "SteamID Manual...",
		no_results_found            = "No se han encontrado resultados",
		add_player                  = "+ Agregar Jugador",
		add_module                  = "+ Agregar Módulo",
		add_entity                  = "+ Agregar Entidad",
		add_string                  = "+ Agregar Palabra Clave",
		modules_search_tooltip      = "¿Qué módulo(s) quieres incluir? (dejar en blanco para cualquier módulo)",
		players_search_tooltip      = "¿Qué jugador(es) estás buscando? (dejar en blanco para cualquier jugador)",
		entities_search_tooltip     = "¿Qué entidad(es) estás buscando? (armas, entidades, vehículos, props, clases, etc...)",
		strings_search_tooltip      = "¿Hay algún texto específico que estás buscando?",
		class_name_ellipsis         = "Nombre de la clase...",
		add_string_popup_title      = "Agregar Palabra Clave",
		add_string_popup_text       = "Ingresa el texto que estás tratando de encontrar.",
		text_ellipsis               = "Texto...",
		click_to_focus              = "Haz click para enfocar",
		right_click_to_focus        = "Haz click derecho para enfocar",
		highlight_color             = "Color de resaltado",
		weapon_color                = "Color de arma",
		money_color                 = "Color de dinero",
		vehicle_color               = "Color vehiculo",
		entity_color                = "Color de entidad",
		health_color                = "Color de HP",
		armor_color                 = "Color de armadura",
		usergroup_color             = "Color de rango",
		unavailable_color           = "No disponible/Color Desconocido",
		learn_more                  = "Aprender más",
		player_combats              = "Combates de Jugadores",
		took_damage                 = "[recibió %d de daño]",
		open_pvp_event_report       = "Reporte de evento de PVP",
		remove                      = "Borrar",
		greedy                      = "Extenso",
		greedy_tip                  = "Si tu búsqueda es extensa, intentará hacer coincidir tantos registros como sea posible. Si no lo es, intentará hacer coincidir la menor cantidad posible de registros.",
		log_colouring               = "Colores de Logs",
		done_exclamation            = "Hecho!",
		module_settings             = "Ajustes de Módulo",
		storage_settings            = "Ajustes de Almacenamiento",
		third_party_addons          = "Addons de terceros",
		pvp_settings                = "Ajustes de registro PvP",
		live_logs_settings          = "Ajustes de Logs en Vivo",
		logging_settings            = "Ajustes de logs",
		settings                    = "Ajustes",
		enabled_modules             = "Habilitar Módulos",
		permissions                 = "Permisos",
		gamemode_modules            = "Módulos de Gamemodes",
		saved_exclamation           = "Guardado!",
		save_settings               = "Guardar Ajustes",
		weapon_class                = "Clase de Arma",
		enter_weapon_class          = "Introduce el nombre de la clase del arma.\nNo lo se? Abre tu menú de spawn, haz clic derecho en un arma y haz click \"Copiar al portapapeles\"",
		save                        = "Guardar",
		add_new                     = "+ Agregar nuevo",
		enabled                     = "Habilitado",
		website                     = "Sitio Web",
		name                        = "Nombre",
		usergroups                  = "Rangos",
		everyone                    = "Todos",
		all_modules                 = "Todos los módulos",
		all_teams                   = "Todos los Jobs",
		add_usergroup               = "Agregar Rango",
		cl_sv_tooltip               = [[cl representa el tiempo necesario para que tu ordenador solicite registros, los reciba, los procese y los muestre
		
		sv representa el tiempo necesario para que el servidor recupere los registros de la memoria/la base de datos, los procese y luego se los envíe.

		Los servidores que usan MySQL verán un valor sv más alto debido a la latencia entre el servidor MySQL y Garr's Mod]],
		deep_storage_help           = [[Registros Profundos es una función de bLogs que mejora el rendimiento al almacenar registros de sesiones anteriores del servidor por separado de las sesiones actuales.

		Después de hacer clic en "Ver Registros Profundos", solo verás los registros de las sesiones anteriores del servidor.
		Puede ver los registros de la sesión actual haciendo click nuevamente en el botón de abajo o volviendo a abrir el menú.

		NOTA:Los registros de daños no se incluyen en el almacenamiento profundo y se eliminan en cada reinicio para ahorrar espacio en el disco]],

		damage = "Daño",

		class_type_other = "Otro",
		class_type_player = "Jugador",
		class_type_team = "Team",
		class_type_weapon = "Arma",
		class_type_vehicle = "Vehiculo",
		class_type_damage = "Tipo de Daño",
		class_type_usergroup = "Rango",
		class_type_prop = "Prop",
		class_type_ragdoll = "Ragdoll",
		class_type_country = "País",
		class_type_ammo = "Munición",
		class_type_role = "Rol",
		class_type_entity = "Entidad",
		class_selector = "Selector de Clase",
		custom_class = "Clase Personalizada",
		class_type = "Tipo de Clase",
		value = "Valor",
		search = "Búscar",
		check_all = "Marcar Todo",
		uncheck_all = "Desmaecae Todo",
		general = "General",
		class_search_title = "Búsqueda de Clase",
		class_search_text = "Ingresa el nombre o parte de un nombre de la clase que estás buscando (no se distinguen mayúsculas y minúsculas)",
		view_logs = "Ver Logs",
		open_menu = "Open Menu",
		licensed_to = "Licenciado para %s",

		pvp_event_report = "Reporte de Evento PvP",
		victim = "Victima",
		instigator = "Instigador",
		victim_tag_tip = "Esta es la persona contra la que el instigador comenzó el combate.",
		instigator_tag_tip = "Esta es la persona que comenzó el combate.",
		victim_abbr = "V",
		instigator_abbr = "I",
		time = "Tiempo",
		linked_events = "Eventos Relacionados",

		deleted_team = "(TEAM BORRADO)",

		unknown = "Desconocido",
		cancel = "Cancelar",

		deep_storage_advanced_search_warning = "ADVERTENCIA: La búsqueda avanzada en realidad busca en el Registros Profundos internamente por razones de rendimiento, lo que significa que la Búsqueda avanzada no encontrará los registros creados recientemente durante un corto período de tiempo.",

		--####################### SETTINGS #######################--

		Player_RecordTeam = "Mostrar team del jugador en los logs",
		Player_RecordUsergroup = "Mostrar el rango del jugador en los logs",
		Player_RecordHealth = "Mostra vida del jugador en los logs",
		Player_RecordArmor = "Mostrar armadura del jugador en los logs",
		Player_RecordWeapon = "Mostrar arma del jugador en los logs",
		Player_RecordWeapon_DoNotRecord = "Filtro de arma del jugador",
		Player_RecordWeapon_DoNotRecord_help = "Si deseas mostrar las armas de los jugadores en los registros, usa esta opción para filtrar las armas que no quieres ver (como la physgun, la toolgun, etc.)",

		OverrideMoneyFormat = "Anular formato de dinero predeterminado",
		OverrideMoneyFormat_help = "Cuando esto está desactivado, se utilizará el formato de dinero del modo de juego.\nCuando esto está activado, puedes usar la opción a continuación para poner tu propio formato de dinero.",
		MoneyFormat = "Formato de Dinero",
		MoneyFormat_help = "Introduce cómo quieres que aparezca el dinero e inserta \"%s\" (sin las comillas)donde quieres que aparezca la cantidad de dinero.",

		DeepStorageEnabled = "Registros Profundos Habilitados",
		DeepStorageEnabled_help = "Deshabilitar el Registros Profundos puede mejorar significativamente el rendimiento en servidores que no usan MySQL.",

		DeepStorageCommitPeriod = "Registros Profundos período de compromiso",
		DeepStorageCommitPeriod_help = "¿Con qué frecuencia (en segundos) se deben confirmar los registros profundos en la base de datos?",

		DeepStorageTooOld = "Edad máxima de los registros profundos",
		DeepStorageTooOld_help = "¿Cuántos días puede estar un registro profundo antes de que se elimine? (ahorra espacio en el disco)\nEstablézcalo en 0 para no eliminar nunca los registros profundos.",

		LiveLogsEnabled = "Logs en Vivo Habilitado",
		LiveLogsEnabled_help = "Los registros en vivo pueden ser un impacto de rendimiento para servidores grandes; Puedes desactivar la función completamente aquí.",
		LiveLogsIn10Seconds = "Max registros en vivo en 10 segundos",
		LiveLogsIn10Seconds_help = "¿Cuántos registros en vivo se pueden enviar antes de que se bloqueen los registros adicionales para el antispam?",
		NotifyLiveLogsAntispam = "Notificar antispam",
		NotifyLiveLogsAntispam_help = "¿Se debe notificar a los usuarios que se ha descartado un registro activo por el antispam?",

		TimeBetweenPvPEvents = "Tiempo entre eventos PvP",
		TimeBetweenPvPEvents_help = "Cuando los jugadores comienzan el combate, se crea un \"Evento PVP\", cuando no se ha producido ningún combate adicional en una cierta cantidad de segundos, el evento PvP se trata como finalizado y comprometido con los registros. ¿Cuántos segundos deben esperar los bLogs antes de hacer esto?",
		NonPvPWeapons = "Filtro de armas PvP",
		NonPvPWeapons_help = "¿Qué armas no deben ser tratadas como armas PvP?",

		server_restart_required = "NOTA: Los cambios en estos ajustes se aplicarán después de reiniciar el servidor.",

		gamemode_modules_tip = [[bLogs soporta una gran cantidad de modos de juego.
        Sin embargo, a veces bLogs puede tener problemas para detectar si está ejecutando un determinado modo de juego.
        En esta pantalla, puedes forzar a bLogs a detectar que estás ejecutando un determinado modo de juego.

		Desmarcado = Comportamiento por defecto
		Marcado = Forzado
		Tachado = No Forzado

		Ten en cuenta que algunos modos de juego RETIVAN del Sandbox, esto significa que usan el menú de spawn del Sandbox, la toolgun, etc.
		Para los modos de juego como DarkRP que se derivan de Sandbox, se recomienda dejar Sandbox en su detección predeterminada.]],

		third_party_addons_tip = [[bLogs admite una gran cantidad de addons de terceros.
		Sin embargo, a veces, los bLogs pueden tener problemas para detectar si tienes un complemento de terceros instalado.
        En esta pantalla, puede forzar a bLogs a pensar que tiene ciertos addons de terceros instalados.

		Desmarcado = Comportamiento por defecto
		Marcado = Forzado
		Tachado = No Forzado]],

		edit_discord_webhooks = "Editar Discord Webhooks",
		webhook_name = "Nombre del webhook",
		webhook_name_tip = "Ingrese el nombre del webhook.\nEsto es solo un identificador para el webhook, ingresará la URL en la siguiente pantalla.",
		webhook = "Webhook",
		webhook_url = "Webhook URL",
		webhook_url_tip = "Copia la URL de tu webhook de Discord y pégala aquí.",
		copy_webhook = "Copiar Webhook",

		can_access_module = "Puede acceder al módulo",
		can_access_all_modules = "Puede acceder a TODOS los módulos",
		all_usergroups = "Todos los rangos",
		all_jobs_in_category = "Todos los jobs en categoría",
		all_teams_in_category = "Todos los teams en categoria",
		teams = "Teams",
		permissions_tip = "Desmarcado = Hereda de \"%s\"\nMarcado = Permitido usar módulo\nTachado = Prohibido usar módulo",
		all_modules_tip = "Los permisos se heredan de esta sección a menos que se invaliden.",

		wipes_and_resets = "Wipes & Reseteos", -- wipes as in data wipes
		disable_buttons = "Deshabilitar botones",
		enable_buttons = "Habilitar botones",
		wipe_deepstorage = "Borrar Registros Profundos",
		wipe_session = "Borrar Logs de la sesión",
		wipe_all_logs = "Borrar todos los Logs",
		reset_config = "Resetear Ajustes.",

		vehicle_driver = "Conductor:",
		data = "Data",
		weapons = "Armas",
		props = "Props",
		ragdolls = "Ragdolls",
		money = "Dinero",
		countries = "Países",
		ammo = "Munición",
		roles = "Roles",
		vehicles = "Vehiculos",

		flag_ongoing = "Evento en curso",
		flag_finished = "Evento Terminado",
		flag_superadmin = "Implica Superadmin",
		flag_admin = "Implica Staff",
		flag_friendly_fire = "Fuego amigo",
		flag_law_enforcement = "Implica cumplimiento de la ley",
		flag_instigator_death = "El instigador murió",
		flag_victim_death = "La víctima murió",
		flag_vehicle = "Implica vehículo(s)",
		flag_world = "Involucra el mapa",
		flag_props = "Involucra props",
		flag_team_switched = "Ocurrió cambio de team",
		flag_disconnect = "Jugador desconectado durante el combate",
		flag_linked = "Vinculado a otros eventos PvP",

		event_start = "Inicio de evento",
		event_end = "Final del evento",

		dead_tag = "[MUERTO]",

		DmgTooltip_Victim = "% del daño total del evento PVP fue la víctima responsable",
		DmgTooltip_Instigator = "% del daño total del evento PVP fue el instigador responsable",
		DmgTooltip_Other = "% del daño total del evento PVP fue por otra causa",

		--####################### LOG PHRASES #######################--
		Logs = {
			round_start     = "INICIO DE RONDA",
			round_preparing = "PREPARANDO RONDA",
			round_end       = "RONDA TERMINADA",

			connected                                      = "{1} conectado",
			connected_from_country                         = "{1} conectado desede {2}",
			finished_connecting                            = "{1} se terminó de conectar",
			respawned                                      = "{1} respawneo",
			disconnected                                   = "{1} desconectado ({2})",
			picked_up_weapon                               = "{1} cogió un arma {2}",
			picked_up_item                                 = "{1} cogió un item {2}",
			prop_killed_self                               = "{1} se suicidó con su prop {2}",
			prop_killed_other                              = "{1} fue asesinado por prop creado por {2} ({3})",
			prop_killed_world                              = "{1} fue asesinado por un prop del mundo {2}",
			prop_damaged_self                              = "{1} recibió un {2} de daño con su prop {3}",
			prop_damaged_other                             = "{1} fue dañado por prop creado por {2} quitandole {3} de daño ({4})",
			prop_damaged_world                             = "{1} fue dañado con un prop del mundo {2} recibió un {3} de daño",
			toolgun_used_their_ent                         = "{1} usó la tool {2} en su {3}",
			toolgun_used_other_ent                         = "{1} usó la tool {2} en {3} creado por {4}",
			toolgun_used_world_ent                         = "{1} usó la tool {2} en {3}",
			spawned_effect                                 = "{1} spawneó un efecto {2}",
			spawned_npc                                    = "{1} spawneó un NPC {2}",
			spawned_prop                                   = "{1} spawneó un prop {2}",
			spawned_ragdoll                                = "{1} spawneó un ragdoll {2}",
			spawned_sent                                   = "{1} spawneó una entidad {2}",
			spawned_swep                                   = "{1} spawneó un arma {2}",
			spawned_vehicle                                = "{1} spawneó vehiculo {2}",
			steam_name_changed                             = "{1} cambió su nombre de Steam de {2} a {3}",
			weapon_switched                                = "{1} cambió del arma {2} a {3}",
 
			murder_loot                                    = "{1} recogió loot",
 
			cinema_video_queued                            = "[{1}] {2} en cola [{3}] \"{4}\" {5}",
 
			ttt_win_traitor                                = "Ganan Traidores!",
			ttt_win_innocent                               = "Ganan Inocentes!",
			ttt_win_timelimit                              = "Ganan Inocentes - límite de tiempo alcanzado!",
			ttt_bought                                     = "{1} compró {2}",
			ttt_karma                                      = "{1} fue KICKEADO por bajo karma",
			ttt_foundbody                                  = "{1} encontró el cuerpo de {2}",
			ttt_founddna                                   = "{1} encontró el ADN de {2} en su {3}",
			ttt_founddna_corpse                            = "{1} encontró el ADN de {2} en su cadáver",
 
			darkrp_agenda_updated                          = "{1} actualizó la agenda de {2} a: {3}",
			darkrp_agenda_removed                          = "{1} borro {2}",
			darkrp_arrest                                  = "{1} arrestó {2}",
			darkrp_unarrest                                = "{1} salió {2}",
			darkrp_batteringram_owned_success              = "{1} abrió con el battering ram el {2} de {3}",
			darkrp_batteringram_owned_door_success         = "{1} abrió con el battering ram la puerta de {2}",
			darkrp_batteringram_success                    = "{1} abrió con el battering ram algo desconocido, {2}",
			darkrp_batteringram_door_success               = "{1} abrió con el battering ram una puerta desconocida",
			darkrp_batteringram_owned_failed               = "{1} falló con el battering ram en {2} de {3}",
			darkrp_batteringram_owned_door_failed          = "{1} falló con el battering ram en la puerta de {2}",
			darkrp_batteringram_failed                     = "{1} falló con el battering ram algo desconocido, {2}",
			darkrp_batteringram_door_failed                = "{1} falló con el battering ram una puerta desconocida",
			darkrp_cheque_dropped                          = "{1} solltó un cheque de {2} para {3}",
			darkrp_cheque_picked_up                        = "{1} cobró un cheque de {2} de {3}",
			darkrp_cheque_tore_up                          = "{1} rompió un cheque de {2} hecho para {3}",
			darkrp_demoted                                 = "{1} demoteado {2} por {3}",
			darkrp_demoted_afk                             = "{1} fue demoteado por estar AFK",
			darkrp_door_sold                               = "{1} vendió una puerta",
			darkrp_door_bought                             = "{1} compró una puerta",
			darkrp_money_dropped                           = "{1} soltó {2}",
			darkrp_money_picked_up                         = "{1} cogió {2}",
			darkrp_money_picked_up_owned                   = "{1} cogió {2} soltado por {3}",
			darkrp_hit_accepted                            = "{1} acepto un hit para {2} requerido por {3}",
			darkrp_hit_completed                           = "{1} completó un hit hacia {2} que fue requerido por {3}",
			darkrp_hit_failed                              = "{1} falló el hit para {2} porque {3}",
			darkrp_hit_requested                           = "{1} requirió un hit para {2} mediante {3} por {4}",
			darkrp_job_changed                             = "{1} se cambió de {2} a {3}",
			darkrp_law_added                               = "{1} ley añadida: {2}",
			darkrp_law_removed                             = "{1} ley borrada: {2}",
			darkrp_purchase                                = "{1} compró {2} por {3}",
			darkrp_purchase_ammo                           = "{1} compró munición de {2} por {3}",
			darkrp_purchase_shipment                       = "{1} compró un cargamento de x{2} {3} por {4}",
			darkrp_purchase_food                           = "{1} compró comida: {2} por {3}",
			darkrp_weapons_checked                         = "{1} chequeó las armas de {2}",
			darkrp_weapons_confiscated                     = "{1} confiscó las armas de {2}",
			darkrp_weapons_returned                        = "{1} devolvió las armas confiscadas de {2}",
			darkrp_filed_warant                            = "{1} presentó un warrant para {2} por: {3}",
			darkrp_warrant_cancelled                       = "{1} canceló el warrant de {2}",
			darkrp_set_wanted                              = "{1} pusó a {2} un wanted por {3}",
			darkrp_cancelled_wanted                        = "{1} canceló el wanted de {2}",
			darkrp_auto_cancelled_wanted                   = "{1} perdió el wanted que tenia",
			darkrp_starved                                 = "{1} murió de hambre",
			darkrp_pocket_added                            = "{1} guardó {2} en su pocket",
			darkrp_pocket_dropped                          = "{1} soltó {2} de su pocket",
			darkrp_rpname_change                           = "{1} se cambió el Nombre de RP de {2} a {3}",
			darkrp_started_lockpick_owned_entity           = "{1} empezó a usar la lockpick en {2} de {3}",
			darkrp_started_lockpick_unowned_entity         = "{1} empezó a usar la lockpick en un {2} desconocido",
			darkrp_started_lockpick_owned_door             = "{1} empezó a usar la lockpick en una puerta de {2}",
			darkrp_started_lockpick_unowned_door           = "{1} empezó a usar la lockpick en una puerta desconocida",
			darkrp_started_lockpick_own_entity             = "{1} empezó a usar la lockpick en su {2}",
			darkrp_started_lockpick_own_door               = "{1} empezó a usar la lockpick en una de sus puertas",
			darkrp_successfully_lockpicked_owned_entity    = "{1} lockpickeo con éxito un {2} de {3}",
			darkrp_successfully_lockpicked_unowned_entity  = "{1} lockpickeo con éxito un {2} desconocido",
			darkrp_successfully_lockpicked_owned_door      = "{1} lockpickeo con éxito una puerta de {2}",
			darkrp_successfully_lockpicked_unowned_door    = "{1} lockpickeo con éxito una puerta desconocida",
			darkrp_successfully_lockpicked_own_entity      = "{1} lockpickeo con éxito su {2}",
			darkrp_successfully_lockpicked_own_door        = "{1} lockpickeo con éxito una de sus puertas",
			darkrp_failed_lockpick_owned_entity            = "{1} no consiguió lockpickear el {2} de {3}",
			darkrp_failed_lockpick_unowned_entity          = "{1} no consiguió lockpickear el {2} desconocido",
			darkrp_failed_lockpick_owned_door              = "{1} no consiguió lockpickear la puerta de {2}",
			darkrp_failed_lockpick_unowned_door            = "{1} no consiguió lockpickear una puerta desconocida",
			darkrp_failed_lockpick_own_entity              = "{1} no consiguió lockpickear su {2}",
			darkrp_failed_lockpick_own_door                = "{1} no consiguió lockpickear una de sus pertas",
			darkrp_changed_job                             = "{1} se cambio de job de {2} a {3}",
			darkrp_added_law                               = "{1} añadió la ley: {2}",
			darkrp_removed_law                             = "{1} borró la ley: {2}",
			darkrp_hit_accepted                            = "{1} aceptó un hit para {2} requerido por {3}",
			darkrp_hit_completed                           = "{1} completoó un hit para {2} requerido por {3}",
			darkrp_hit_failed                              = "{1} falló en un hit para {2} requerido por {3}",
			darkrp_hit_requested                           = "{1} solicitó un hit para {2} mediante {3} por {4}",
			darkrp_sold_door                               = "{1} vendió una puerta",
			darkrp_bought_door                             = "{1} compró una puerta",
			darkrp_dropped_money                           = "{1} soltó {2}",
			darkrp_picked_up_money                         = "{1} cogió {2}",
			darkrp_picked_up_money_dropped_by              = "{1} cogió {2} que soltó {3}",
			darkrp_demoted                                 = "{1} fue demoteado de {2} por {3}",
			darkrp_afk_demoted                             = "{1} fue demoteado por estar AFK",
			darkrp_lottery_started                         = "{1} inició una loteria con el precio de: {2}",
			darkrp_lottery_ended                           = "{1} ganó {2} de la loteria!",
 
			pvp_instigator_killed_noweapon                 = "{1} {2} terminó el combate y ASESINÓ A {3} {4} después de {5}", -- after X seconds/minutes/hours
			pvp_instigator_killed_weapon                   = "{1} {2} terminó el combate usando {3} y ASESINÓ A {4} {5} después de {6}",
			pvp_instigator_killed_weapons                  = "{1} {2} terminó el combate usando multiples armas y ASESINÓ A {3} {4} después de {5}",
			pvp_victim_killed_noweapon                     = "{1} {2} terminó el combate y FUE ASESINADÓ POR {3} {4} después de {5}",
			pvp_victim_killed_weapon                       = "{1} {2} terminó el combate usando {3} y FUE ASESINADO POR {4} {5} después de {6}",
			pvp_victim_killed_weapons                      = "{1} {2} terminó el combate usando multiples armas y FUE ASESINADO POR {3} {4} después de {5}",
			pvp_combat_noweapon                            = "{1} {2} terminó el combate con {3} {4} después de {5}",
			pvp_combat_weapon                              = "{1} {2} terminó el combate usando {3} con {4} {5} después {6}",
			pvp_combat_weapons                             = "{1} {2} terminó el combate usando multiples armas con {3} {4} después {5}",
			pvp_log_noweapon                               = "{1} dañó a {2} quitandole {3} de daño",
			pvp_log_weapon                                 = "{1} dañó a {2} quitandole {3} de daño usando {4}",
			pvp_killed                                     = "{1} mató a {2}",
			pvp_vehicle_owned_killed                       = "{1} fue dañado & y asesinado por {2} sin conductor, propiedad de {3}",
			pvp_vehicle_owned_damaged                      = "{1} fue dañado quitandole {2} de daño por {3} sin conductor, propiedad de {4}",
			pvp_vehicle_killed                             = "{1} fue dañado & y asesinado por {2} sin conductor, propiedad de nadie",
			pvp_vehicle_damaged                            = "{1} fue dañado quitandole {2} de daño por {3} sin conductor, propiedad de nadie",
			pvp_killed_self                                = "{1} se suicidó",
			pvp_damaged_self                               = "{1} se dañó a si mismo quitandose {2} de daño",
 
			changed_team                                   = "{1} se cambió de team de {2} a {3}",
			command_used                                   = "{1}: {2}",
			warned_reason                                  = "{1} fue warneado por {2} por {3}",
			warned_noreason                                = "{1} fue warnedo por {2}",
			warned_kicked                                  = "{1} fue KICKEADO por alcanzar el límite de warns activos",
			warned_banned                                  = "{1} fue BANEADO por alcanzar el límite de warns activos",
			handcuffed                                     = "{1} esposó {2}",
			handcuffs_broken_by                            = "{1} rompió las esposas que le puso {2}",
			handcuffs_broken                               = "{1} rompió sus propias esposas",
			npc_health_bought                              = "{1} compro vida en un NPC por {2}",
			npc_armor_bought                               = "{1} compro armadura en un NPC por {2}",
			pac_outfit                                     = "{1} cambiado su traje de PAC {2}",
			party_chat                                     = "{1} ({2}): {3}",
			party_created                                  = "{1} creó una party {2}",
			party_join                                     = "{1} se unió a la parti {2}",
			party_join_request                             = "{1} requirió unirse a la party {2}",
			party_invite                                   = "{1} invitó a {2} a la party {3}",
			party_leave                                    = "{1} se salió de la party {2}",
			party_kick                                     = "{1} kickeo a {2} de la party {3}",
			party_disbanded                                = "{1} party borrada {2}",
			party_abandoned                                = "{1} se fue del server y se fue de la party {2}",
			spraymesh                                      = "{1} usó su spray {2}",
			starwarsvehicle_damage_owned_weapon            = "{1} dañó un vehiculo de Star Wars {2} de {3} quitandole {4} de daño con {5}",
			starwarsvehicle_damage_owned                   = "{1} dañó un vehiculo de Star Wars {2} de {3} quitandole {4} de daño",
			starwarsvehicle_damage_weapon                  = "{1} dañó un vehiculo de Star Wars {2} quitandole {3} de daño con {4}",
			starwarsvehicle_damage                         = "{1} dañó un vehiculo de Star Wars {2} quitandole {3} de daño",
			wac_damage_owned_weapon                        = "{1} dañó un vehiculo de WAC aircraft {2} de {3} quitandole {4} de daño con {5}",
			wac_damage_owned                               = "{1} dañó un vehiculo de WAC aircraft {2} de {3} quitandole {4} de daño",
			wac_damage_weapon                              = "{1} dañó un vehiculo de WAC aircraft {2} quitandole {3} de daño con {4}",
			wac_damage                                     = "{1} dañó un vehiculo de WAC aircraft {2} quitandole {3} de daño",
			wyozi_cinema_queued                            = "{1} requirió un video {2} ➞ {3} en el cine {4}",
			wyozi_dj_queued                                = "{1} en cola {2} ➞ {3} en el canal {4}",
			wyozi_dj_channel_rename                        = "{1} renombró el canal a {2}",
 
			bwhitelist_whitelist_enabled_by                = "{1} habilitó la whitelist para {2}",
			bwhitelist_whitelist_enabled                   = "La whitelist para {1} fue habilitada",
			bwhitelist_whitelist_disabled_by               = "{1} deshabilitó la whitelist de {2}",
			bwhitelist_whitelist_disabled                  = "La whitelist de {1} fue deshabilitada",
 
			bwhitelist_blacklist_enabled_by                = "{1} habilitó la blacklist para {2}",
			bwhitelist_blacklist_enabled                   = "La bakclist para {1} fue habilitada",
			bwhitelist_blacklist_disabled_by               = "{1} deshabilitó la blacklist para {2}",
			bwhitelist_blacklist_disabled                  = "La blacklist para {1} fue deshabilitada",
 
			bwhitelist_added_to_whitelist_by               = "{1} fue añadido a la whitelist de {2} por {3}",
			bwhitelist_added_to_whitelist                  = "{1} fue añadido a la whitelist de {2}",
			bwhitelist_removed_from_whitelist_by           = "{1} fue borrado de la whitelist de {2} por {3}",
			bwhitelist_removed_from_whitelist              = "{1} fue borrado de la whitelist de {2}",
			bwhitelist_added_to_blacklist_by               = "{1} fue añadido a la blacklist de {2} por {3}",
			bwhitelist_added_to_blacklist                  = "{1} fue añadido a la blacklist de {2}",
			bwhitelist_removed_from_blacklist_by           = "{1} fue borrado de la blacklist de {2} por {3}",
			bwhitelist_removed_from_blacklist              = "{1} fue borrado de la blacklist de {2}",
 
			bwhitelist_added_to_whitelist_by_usergroup     = "El rango {1} fue añadido a la whitelist de {2} por {3}",
			bwhitelist_added_to_whitelist_usergroup        = "El rango {1} fue añadido a la whitelist de {2}",
			bwhitelist_removed_from_whitelist_by_usergroup = "El rango {1} fue borrado a la whitelist de {2} por {3}",
			bwhitelist_removed_from_whitelist_usergroup    = "El rango {1} fue borrado a la whitelist de {2}",
			bwhitelist_added_to_blacklist_by_usergroup     = "El rango {1} fue añadido a la blacklist de {2} por {3}",
			bwhitelist_added_to_blacklist_usergroup        = "El rango {1} fue añadido a la blacklist de {2}",
			bwhitelist_removed_from_blacklist_by_usergroup = "El rango {1} fue borrado a la blacklist de {2} por {3}",
			bwhitelist_removed_from_blacklist_usergroup    = "El rango {1} fue borrado a la blacklist de {2}",
 
			bwhitelist_added_to_whitelist_by_luafunc       = "La función de lua {1} fue añadida a la whitelist de {2} por {3}",
			bwhitelist_added_to_whitelist_luafunc          = "La función de lua {1} fue añadida a la whitelist de {2}",
			bwhitelist_removed_from_whitelist_by_luafunc   = "La función de lua {1} fue borrada a la whitelist de {2} por {3}",
			bwhitelist_removed_from_whitelist_luafunc      = "La función de lua {1} fue borrada a la whitelist de {2}",
			bwhitelist_added_to_blacklist_by_luafunc       = "La función de lua {1} fue añadida a la blacklist de {2} por {3}",
			bwhitelist_added_to_blacklist_luafunc          = "La función de lua {1} fue añadida a la blacklist de {2}",
			bwhitelist_removed_from_blacklist_by_luafunc   = "La función de lua {1} fue borrada a la blacklist de {2} por {3}",
			bwhitelist_removed_from_blacklist_luafunc      = "La función de lua {1} fue borrada a la blacklist de {2}",

			pvp_combat_begin = "{1} combate instigado contra {2}",
			pvp_combat_end   = "El combate instigado por {1} en contra de {2} terminó",

			pvp_player_damage_weapon = "{1} dañó a {2} con {3}",
			pvp_player_damage = "{1} dañó a {2}",
			pvp_misc_dmg = "{1} fue dañado por {2}",
			pvp_fall_damage = "{1} recibió daño por caida",
			pvp_world_crush_damage = "{1} fue aplastado contra el mundo",
			pvp_world_damage = "{1} fue dañado por el mundo",
			pvp_prop_self_damage = "{1} se dañó a si mismo con el prop {2}",
			pvp_prop_damage = "{1} fue dañado con el prop {2} creado por {3}",
			pvp_world_prop_damage = "{1} fue dañado con el un prop del mundo, {2}",
			pvp_dmg_self = "{1} se daño a si mismo",
			pvp_vehicle_damage = "{1} fue dañado por el vehículo {2} conducido por {3}",
			pvp_driverless_vehicle_damage = "{1} fue dañado por el vehículo {2} sin conductor",

			pvp_player_silent_death = "{1} fue asesinado en silencio",
			pvp_death_propkill_self = "{1} se hizo propkill a si mismo con {2}",
			pvp_death_propkill_world = "{1} el mundo le hizo propkill con {2}",
			pvp_death_propkill = "{1} fue asesinado con un prop de {2} usando {3}",
			pvp_death_player = "{1} fue asesinado por {2}",
			pvp_death_player_weapon = "{1} fue asesinado por {2} con {3}",
			pvp_death_world = "{1} fue asesinado por el mundo",
			pvp_death = "{1} fue asesinado",
			
			pvp_misc_dmg_prop = "{1} recibió {2} por el prop de un mundo {3}",
			pvp_misc_dmg_attacker = "{1} recibió {2} de {3}",
			pvp_misc_dmg_other = "{1} recibió {2}",
		},

		pvp_dmgtype_generic = "%u de daño",
		pvp_dmgtype_burn = "%u de daño por fuego",
		pvp_dmgtype_crush = "%u de daño por aplastamiento",
		pvp_dmgtype_fall = "%u de daño por caida",
		pvp_dmgtype_bullet = "%u de daño por bala",
		pvp_dmgtype_slash = "%u de daño por corte",
		pvp_dmgtype_vehicle = "%u de daño por vehiculo",
		pvp_dmgtype_blast = "%u de daño por explosión",
		pvp_dmgtype_club = "%u de daño por club",
		pvp_dmgtype_shock = "%u de daño por electrocutamiento",
		pvp_dmgtype_sonic = "%u de daño por sonic",
		pvp_dmgtype_energybeam = "%u de daño por laser",
		pvp_dmgtype_drown = "%u de daño por ahogamiento",
		pvp_dmgtype_nervegas = "%u de daño por neurotoxina",
		pvp_dmgtype_poison = "%u de daño por  veneno",
		pvp_dmgtype_radiation = "%u de daño por radiación",
		pvp_dmgtype_acid = "%u de daño por químico",
		pvp_dmgtype_gravgun = "%u de daño por gravity gun",
		pvp_dmgtype_plasma = "%u de daño por plasma",
		pvp_dmgtype_airboat = "%u de daño por arma de airboat",
		pvp_dmgtype_buckshot = "%u de daño por bala de escopeta",
		pvp_dmgtype_sniper = "%u de daño por bala de Sniper",

} end }
--addons/billy_gas/lua/gmodadminsuite/modules/playerdatabase/lang/french.lua:
return {
	Name = "French",
	Flag = "flags16/fr.png",
	Phrases = function() return {

		module_name = "Player Database",

		right_click_to_focus    = "Clic Droit pour faire le focus",
		steamid                 = "SteamID",
		name                    = "Nom",
		usergroup               = "Groupe",
		ip_address              = "Adresse IP",
		last_seen               = "Dernière Connexion",
		copy_steamid            = "Copier SteamID",
		copy_steamid64          = "Copier SteamID64",
		copy_usergroup          = "Copier Groupe d'Utilisateurs",
		copy_ip_address         = "Copier IP Address",
		copy_name               = "Copier Nom",
		copy_steam_profile_link = "Copier Lien de Page de Profil Steam",
		search                  = "Chercher",
		country                 = "Pays",
		copy_country            = "Copier Country",
		search_usergroup        = "Chercher Groupe d'Utilisateurs",
		search_ip_address       = "Chercher Adresse IP",
		search_country          = "Chercher Pays",
		search_name             = "Chercher Nom",
		none                    = "< none >",
		cancel                  = "Annuler",
		steamid                 = "SteamID",

} end }
--addons/billy_gas/lua/gmodadminsuite/sh_teams.lua:
GAS.Teams = {}
GAS.Teams.Identifiers = {}
GAS.Teams.IdentifiersIndexed = {}

local ReadyCallbacks = {}
function GAS.Teams:Ready(callback)
	if (GAS.Teams.CachedIdentifiers) then
		callback()
	else
		table.insert(ReadyCallbacks, callback)
	end
end

if (SERVER) then

	local function utf8_cmp(str1, str2)
		return
			str1 == str2 or
			utf8.force(str1) == utf8.force(str2)
	end

	GAS:netInit("teams:GetIdentifiers")
	local function NetworkIdentifiers(ply)
		GAS:netStart("teams:GetIdentifiers")
			net.WriteUInt(table.Count(GAS.Teams.Identifiers), 16)
			for team_index, identifier in pairs(GAS.Teams.Identifiers) do
				net.WriteUInt(team_index, 16)
				net.WriteUInt(identifier, 16)
			end
		net.Send(ply)
	end

	local GetIdentifiersQueue = {}
	GAS:netReceive("teams:GetIdentifiers", function(ply)
		if (GAS.Teams.CachedIdentifiers) then
			NetworkIdentifiers(ply)
		else
			table.insert(GetIdentifiersQueue, ply)
		end
	end)

	GAS.Teams:Ready(function()
		for _,ply in ipairs(GetIdentifiersQueue) do
			NetworkIdentifiers(ply)
		end
		GetIdentifiersQueue = {}
	end)

	local function teams_init()
		GAS.Teams.Identifiers = {}
		GAS.Teams.IdentifiersIndexed = {}
		
		GAS:print("Populating team identification...", GAS_PRINT_TYPE_INFO)

		GAS.Database:Query("SELECT `id`, `name`, `command`, `OPENPERMISSIONS_IDENTIFIER` FROM `gas_teams` WHERE `server_id`=" .. GAS.ServerID, function(rows)
			GAS.Database:BeginTransaction()

			if (DarkRP and RPExtraTeams) then
				for _,job in ipairs(RPExtraTeams) do
					local OPENPERMISSIONS_IDENTIFIER = NULL
					if (job.OPENPERMISSIONS_IDENTIFIER ~= nil) then
						OPENPERMISSIONS_IDENTIFIER = utf8.force(job.OPENPERMISSIONS_IDENTIFIER)
					end
					local found = false
					for _,row in ipairs(rows) do
						if (
							(row.OPENPERMISSIONS_IDENTIFIER ~= nil and job.OPENPERMISSIONS_IDENTIFIER ~= nil and utf8_cmp(job.OPENPERMISSIONS_IDENTIFIER, row.OPENPERMISSIONS_IDENTIFIER)) or
							(row.command ~= nil and utf8_cmp(job.command, row.command))
						) then
							found = true
							GAS.Database:Prepare("UPDATE `gas_teams` SET `name`=?, `command`=?, `OPENPERMISSIONS_IDENTIFIER`=? WHERE `server_id`=? AND `id`=?", {utf8.force(job.name), utf8.force(job.command), OPENPERMISSIONS_IDENTIFIER, GAS.ServerID, tonumber(row.id)})
							break
						end
					end
					if (not found) then
						GAS.Database:Prepare("INSERT INTO `gas_teams` (`server_id`, `name`, `command`, `OPENPERMISSIONS_IDENTIFIER`) VALUES(?,?,?,?)", {GAS.ServerID, utf8.force(job.name), utf8.force(job.command), OPENPERMISSIONS_IDENTIFIER})
					end
				end
			else
				for i,t in ipairs(team.GetAllTeams()) do
					local found = false
					for _,row in ipairs(rows) do
						if (row.name ~= nil and utf8_cmp(t.Name, row.name)) then
							found = true
							GAS.Database:Prepare("UPDATE `gas_teams` SET `name`=?, `command`=?, `OPENPERMISSIONS_IDENTIFIER`=? WHERE `server_id`=? AND `id`=?", {utf8.force(t.Name), NULL, NULL, GAS.ServerID, tonumber(row.id)})
							break
						end
					end
					if (not found) then
						GAS.Database:Prepare("INSERT INTO `gas_teams` (`server_id`, `name`, `command`, `OPENPERMISSIONS_IDENTIFIER`) VALUES(?,?,?,?)", {GAS.ServerID, utf8.force(t.Name), NULL, NULL})
					end
				end
			end

			GAS.Database:CommitTransaction(function()

				GAS.Database:Query("SELECT `id`, `name`, `command`, `OPENPERMISSIONS_IDENTIFIER` FROM `gas_teams` WHERE `server_id`=" .. GAS.ServerID, function(rows)
					for _,row in ipairs(rows) do
						if (DarkRP and RPExtraTeams) then
							for _,job in ipairs(RPExtraTeams) do
								if (GAS.Teams.Identifiers[job.team] ~= nil) then continue end
								if (
									(row.OPENPERMISSIONS_IDENTIFIER ~= nil and job.OPENPERMISSIONS_IDENTIFIER == row.OPENPERMISSIONS_IDENTIFIER) or
									(row.command ~= nil and job.command == row.command) or
									(row.name ~= nil and job.name == row.name)
								) then
									GAS.Teams.Identifiers[job.team] = tonumber(row.id)
									GAS.Teams.IdentifiersIndexed[tonumber(row.id)] = job.team
									break
								end
							end
						else
							for i,t in ipairs(team.GetAllTeams()) do
								if (GAS.Teams.Identifiers[i] ~= nil) then continue end
								if (row.name ~= nil and t.Name == row.name) then
									GAS.Teams.Identifiers[i] = tonumber(row.id)
									GAS.Teams.IdentifiersIndexed[tonumber(row.id)] = i
									break
								end
							end
						end
					end

					GAS.Teams.CachedIdentifiers = true

					for _,callback in ipairs(ReadyCallbacks) do
						callback()
					end
					ReadyCallbacks = {}

					hook.Run("GAS:TeamIdentifiersReady")

					GAS:print("Initialized team identification", GAS_PRINT_COLOR_GOOD, GAS_PRINT_TYPE_INFO)
				end)

			end)
		end)
	end

	local function sql_init()
		GAS:GMInitialize(function()
			GAS:InitPostEntity(function()
				GAS.Database:ServerID(teams_init)
			end)
		end)
		hook.Add("DConfigOnUpdateJob", "DConfig:UpdateJobCache", teams_init)
	end

	if (GAS.Database.MySQLDatabase) then
		GAS.Database:Query([[

			CREATE TABLE IF NOT EXISTS `gas_teams` (
				`id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
				`server_id` smallint(5) unsigned NOT NULL,
				`OPENPERMISSIONS_IDENTIFIER` varchar(189) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,
				`command` varchar(189) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,
				`name` varchar(189) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,
				PRIMARY KEY (`id`),
				UNIQUE KEY `command` (`server_id`,`command`),
				UNIQUE KEY `OPENPERMISSIONS_IDENTIFIER` (`server_id`,`OPENPERMISSIONS_IDENTIFIER`)
			)

		]], function()
			GAS.Database:Query("SHOW INDEX FROM gas_teams WHERE KEY_NAME='name'", function(rows)
				if (rows and #rows > 0) then
					GAS.Database:Query("DROP INDEX name ON gas_teams", sql_init)
				else
					sql_init()
				end
			end)
		end)
	else
		GAS.Database:Query([[

			CREATE TABLE IF NOT EXISTS "gas_teams" (
				"id" INTEGER PRIMARY KEY,
				"server_id" INTEGER NOT NULL,
				"OPENPERMISSIONS_IDENTIFIER" TEXT DEFAULT NULL,
				"command" TEXT DEFAULT NULL,
				"name" TEXT NOT NULL,
				UNIQUE ("server_id","command"),
				UNIQUE ("server_id","OPENPERMISSIONS_IDENTIFIER")
			)

		]], sql_init)
	end

else

	GAS:netReceive("teams:GetIdentifiers", function(len)
		for i=1,net.ReadUInt(16) do
			local team_index, identifier = net.ReadUInt(16), net.ReadUInt(16)
			GAS.Teams.Identifiers[team_index] = identifier
			GAS.Teams.IdentifiersIndexed[identifier] = team_index
		end

		GAS.Teams.CachedIdentifiers = true

		for _,callback in ipairs(ReadyCallbacks) do
			callback()
		end
		ReadyCallbacks = {}

		hook.Run("GAS:TeamIdentifiersReady")
	end)

	GAS:InitPostEntity(function()
		GAS:netStart("teams:GetIdentifiers")
		net.SendToServer()
	end)

end

function GAS.Teams:GetIdentifier(team_index)
	return GAS.Teams.Identifiers[team_index]
end
function GAS.Teams:GetFromIdentifier(identifier)
	return GAS.Teams.IdentifiersIndexed[tonumber(identifier)]
end

GAS:hook("OpenPermissions:GetTeamIdentifier", "teams:OpenPermissions:GetTeamIdentifier", function(team_index)
	return GAS.Teams:GetIdentifier(team_index)
end)
GAS:hook("OpenPermissions:GetTeamFromIdentifier", "teams:OpenPermissions:GetTeamFromIdentifier", function(team_identifier)
	return GAS.Teams:GetFromIdentifier(team_identifier)
end)
--addons/billy_gas/lua/gmodadminsuite/modules/commands/sh_init.lua:
if (SERVER) then
	AddCSLuaFile("cl_commands.lua")
end

GAS.Commands = {}

GAS.Commands.ACTION_COMMANDS_MENU   = 0
GAS.Commands.ACTION_COMMAND         = 1
GAS.Commands.ACTION_CHAT            = 2
GAS.Commands.ACTION_WEBSITE         = 3
GAS.Commands.ACTION_TELEPORT        = 4
GAS.Commands.ACTION_LUA_FUNCTION_SV = 5
GAS.Commands.ACTION_LUA_FUNCTION_CL = 6
GAS.Commands.ACTION_GAS_MODULE      = 7

GAS:hook("gmodadminsuite:LoadModule:commands", "LoadModule:commands", function()
	if (SERVER) then
		include("gmodadminsuite/modules/commands/sv_commands.lua")
		include("gmodadminsuite/modules/commands/sv_permissions.lua")
	else
		include("gmodadminsuite/modules/commands/cl_commands.lua")
	end
end)
--addons/billy_gas/lua/gmodadminsuite/modules/playerdatabase/sh_init.lua:
if (SERVER) then
	AddCSLuaFile("gmodadminsuite/modules/playerdatabase/sh_playerdatabase.lua")
end

GAS:hook("gmodadminsuite:LoadModule:playerdatabase", "LoadModule:playerdatabase", function()
	include("gmodadminsuite/modules/playerdatabase/sh_playerdatabase.lua")
end)
--addons/billy_gas/lua/gmodadminsuite/modules/secondaryusergroups/sh_init.lua:
if (SERVER) then
	AddCSLuaFile("sh_core.lua")
	AddCSLuaFile("cl_menu.lua")
end

GAS:hook("gmodadminsuite:LoadModule:secondaryusergroups", "LoadModule:secondaryusergroups", function()
	include("gmodadminsuite/modules/secondaryusergroups/sh_core.lua")
	if (SERVER) then
		include("gmodadminsuite/modules/secondaryusergroups/sv_secondaryusergroups.lua")
		include("gmodadminsuite/modules/secondaryusergroups/sv_permissions.lua")
	else
		include("gmodadminsuite/modules/secondaryusergroups/cl_menu.lua")
	end
end)
--addons/billy_gas/lua/gmodadminsuite/cl_menu.lua:
local function L(phrase, ...)
	if (#({...}) == 0) then
		return GAS:Phrase(phrase)
	else
		return GAS:PhraseFormat(phrase, nil, ...)
	end
end

GAS.LocalConfig = GAS:GetLocalConfig("gas", {
	AllowVoiceChat = true,
	DefaultModule = false,
	ClosePlayerPopups = false
})

GAS:netReceive("menu_nopermission", function()
	GAS:PlaySound("error")
	GAS:chatPrint(L"menu_nopermission", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
end)
GAS:netReceive("menu_unknown_module", function()
	GAS:PlaySound("error")
	GAS:chatPrint(L"menu_unknown_module", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
end)
GAS:netReceive("menu_disabled_module", function()
	GAS:PlaySound("error")
	GAS:chatPrint(L"menu_disabled_module", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
end)
GAS:netReceive("menu_module_nopermission", function()
	GAS:PlaySound("error")
	GAS:chatPrint(L"menu_module_nopermission", GAS_PRINT_COLOR_BAD, GAS_PRINT_TYPE_FAIL)
end)

concommand.Add("gmodadminsuite", function(_, __, args)
	if (#args == 0) then
		GAS:netStart("menu_open")
			net.WriteString("")
		net.SendToServer()
	else
		if (args[1] == "reload") then
			GAS:Init()
		elseif (args[1] == "screenclicker") then
			gui.EnableScreenClicker(true)
		else
			GAS:netStart("menu_open")
				net.WriteString(args[1])
			net.SendToServer()
		end
	end
end, function(cmd, args)
	local arg = string.TrimLeft(args)
	local tbl = {}
	local is_operator = OpenPermissions:IsOperator(LocalPlayer())
	for module_name, module_data in pairs(GAS.Modules.Info) do
		if (module_data.OperatorOnly and not is_operator) then continue end
		if (arg and #string.Trim(arg) > 0) then
			if (not module_name:lower():find(string.Trim(arg):lower())) then
				continue
			end
		end
		table.insert(tbl, cmd .. " " .. module_name)
	end
	table.sort(tbl)
	table.insert(tbl, 1, cmd .. " reload")
	table.insert(tbl, 2, cmd .. " screenclicker")
	return tbl
end)

function GAS:OpenModuleFrame(module_name)
	if (IsValid(GAS.ModuleFrame)) then
		GAS.ModuleFrame:Close()
	end

	if (IsValid(GAS.Menu)) then
		if (GAS.Menu.Modules.IndexedItems[module_name]) then
			GAS.Menu.Modules.IndexedItems[module_name]:SetActive(true)
		end
	end

	GAS.ModuleFrame = vgui.Create("bVGUI.Frame")
	GAS.ModuleFrame.ModuleName = module_name
	local w, h = 1200, 700
	if (ScrW() < w or ScrH() < h) then
		w = ScrW()
		h = ScrH()
	end
	GAS.ModuleFrame:SetSize(w,h)
	GAS.ModuleFrame:MakePopup()
	GAS.ModuleFrame:SetTitle(GAS.Modules:GetFriendlyName(module_name))
	GAS.ModuleFrame:SetVisible(false)

	GAS.ModuleFrame.DragThink = GAS.ModuleFrame.Think
	function GAS.ModuleFrame:Think()
		self:DragThink()
		if (IsValid(GAS.Menu)) then
			self.bVGUI_FullscreenButton.OffsetX = 200

			local x_1, y_1, w_1, h_1 = self:GetBounds()
			GAS.Menu:SetPos(x_1 - 200 + 1, y_1)
			GAS.Menu:SetSize(200, h_1)
		else
			self.bVGUI_FullscreenButton.OffsetX = nil
		end
	end

	function GAS.ModuleFrame:OnClose()
		local x, y = self:GetPos()
		cookie.Set("gmodadminsuite_module_" .. self.ModuleName .. "_x_" .. ScrW(), x)
		cookie.Set("gmodadminsuite_module_" .. self.ModuleName .. "_y_" .. ScrH(), y)
	end

	function GAS.ModuleFrame:DermaMenuOptions(menu)
		if (not IsValid(GAS.Menu)) then
			menu:AddOption(L"open_gas", function()
				GAS:PlaySound("jump")
				GAS:OpenMenu()
			end):SetIcon("icon16/application_home.png")
		end

		menu:AddOption(L"close", function()
			if IsValid(self) then
				GAS.ModuleFrame:Remove()
			end
		end):SetIcon("icon16/cancel.png")

		menu:AddOption(L"module_shortcut", function()
			GAS:PlaySound("flash")
			bVGUI.RichMessage({
				title = L"module_shortcut",
				button = "OK",
				textCallback = function(richtext)
					local highlight_col = {0,255,255,255}
					local phrase = string.Explode("%s", GAS:Phrase("module_shortcut_info"))
					richtext:AppendText(phrase[1])

					richtext:InsertColorChange(unpack(highlight_col))
					richtext:AppendText("gmodadminsuite " .. module_name)

					richtext:InsertColorChange(255,255,255,255)
					richtext:AppendText(phrase[2])

					richtext:InsertColorChange(unpack(highlight_col))
					richtext:AppendText(GAS.Config.ChatCommand .. " " .. module_name)

					richtext:InsertColorChange(255,255,255,255)
					richtext:AppendText(phrase[3])

					richtext:InsertColorChange(unpack(highlight_col))
					richtext:AppendText("bind KEY \"gmodadminsuite " .. module_name .. "\"")

					richtext:InsertColorChange(255,255,255,255)
					richtext:AppendText(phrase[4])

					richtext:InsertColorChange(unpack(highlight_col))
					richtext:AppendText("https://developer.valvesoftware.com/wiki/Bind#Special_Keys")
				end
			})
		end):SetIcon("icon16/star.png")

		menu:AddOption(L"module_reset_data", function()
			GAS:PlaySound("flash")
			if IsValid(self) then
				self:SetSize(self.RealSize[1], self.RealSize[2])
				self:Center()
				local x, y = self:GetPos()
				cookie.Set("gmodadminsuite_module_" .. self.ModuleName .. "_x_" .. ScrW(), x)
				cookie.Set("gmodadminsuite_module_" .. self.ModuleName .. "_y_" .. ScrH(), y)
				cookie.Set("gmodadminsuite_module_" .. module_name .. "_w", self:GetWide())
				cookie.Set("gmodadminsuite_module_" .. module_name .. "_h", self:GetTall())
			end
		end):SetIcon("icon16/arrow_rotate_clockwise.png")

		if (GAS.Modules.Info[module_name].ScriptPage) then
			menu:AddOption(L"script_page", function()
				GAS:OpenURL(GAS.Modules.Info[module_name].ScriptPage)
			end):SetIcon("icon16/page_code.png")
		end

		if (GAS.Modules.Info[module_name].Wiki) then
			menu:AddOption(L"wiki", function()
				GAS:OpenURL(GAS.Modules.Info[module_name].Wiki)
			end):SetIcon("icon16/book.png")
		end

		if (GAS.ModuleFrame.Extra_DermaMenuOptions) then
			GAS.ModuleFrame:Extra_DermaMenuOptions(menu)
		end
	end

	-- would use file.IsDir, but: https://github.com/Facepunch/garrysmod-issues/issues/3592
	local _,d = file.Find("gmodadminsuite/modules/*", "LUA")
	if (table.HasValue(d, module_name) and not GAS.Modules:IsModuleLoaded(module_name)) then
		GAS.Modules:LoadModule(module_name)
	end

	local real_w, real_h = hook.Run("gmodadminsuite:ModuleSize:" .. module_name)

	w = math.min(cookie.GetNumber("gmodadminsuite_module_" .. module_name .. "_w", real_w), ScrW())
	h = math.min(cookie.GetNumber("gmodadminsuite_module_" .. module_name .. "_h", real_h), ScrH())

	GAS.ModuleFrame:SetSize(w,h)
	GAS.ModuleFrame:SetMinimumSize(real_w, real_h)
	GAS.ModuleFrame:Center()
	GAS.ModuleFrame:SetVisible(true)

	local new_x = cookie.GetNumber("gmodadminsuite_module_" .. module_name .. "_x_" .. ScrW(), false)
	local new_y = cookie.GetNumber("gmodadminsuite_module_" .. module_name .. "_y_" .. ScrH(), false)
	local cur_x, cur_y = GAS.ModuleFrame:GetPos()

	GAS.ModuleFrame:SetPos(new_x or cur_x, new_y or cur_y)

	GAS.ModuleFrame.OpenModule = module_name
	GAS.ModuleFrame.RealSize = {
		real_w,
		real_h
	}

	hook.Run("gmodadminsuite:ModuleFrame:" .. module_name, GAS.ModuleFrame)

	GAS.ModuleFrame:EnableUserResize()

	function GAS.ModuleFrame:OnResize(new_w, new_h)
		cookie.Set("gmodadminsuite_module_" .. module_name .. "_w", new_w)
		cookie.Set("gmodadminsuite_module_" .. module_name .. "_h", new_h)
	end

	return GAS.ModuleFrame
end

local logo_mat = Material("gmodadminsuite/gmodadminsuite.vtf")
local function OpenMenu()
	local is_operator = OpenPermissions:IsOperator(LocalPlayer())

	GAS.Menu = vgui.Create("bVGUI.Frame")
	GAS.Menu:ShowFullscreenButton(false)
	GAS.Menu:SetSize(800,500)
	GAS.Menu:SetTitle("GmodAdminSuite " .. GAS.Version)
	GAS.Menu:Center()
	GAS.Menu:MakePopup()

	if (IsValid(GAS.ModuleFrame) and GAS.ModuleFrame.Fullscreened) then
		GAS.ModuleFrame.bVGUI_FullscreenButton.OffsetX = 200
		GAS.ModuleFrame:Stop()
		GAS.ModuleFrame:SizeTo(ScrW() - 200, ScrH(), 0.5, 0, 0.5)
		GAS.ModuleFrame:MoveTo(200,0, 0.5, 0, 0.5)
	end
	function GAS.Menu:OnClose()
		if (IsValid(GAS.ModuleFrame) and GAS.ModuleFrame.Fullscreened) then
			GAS.ModuleFrame:Stop()
			GAS.ModuleFrame:SizeTo(ScrW(), ScrH(), 0.5, 0, 0.5)
			GAS.ModuleFrame:MoveTo(0, 0, 0.5, 0, 0.5)
		end
	end

	GAS.Menu.Modules = vgui.Create("bVGUI.Categories", GAS.Menu)
	GAS.Menu.Modules:Dock(LEFT)
	GAS.Menu.Modules:SetWide(200)
	GAS.Menu.Modules:SetDrawBackground(false)
	GAS.Menu.Modules.IndexedItems = {}

	GAS.Menu.Content = vgui.Create("bVGUI.BlankPanel", GAS.Menu)
	GAS.Menu.Content:Dock(FILL)
	function GAS.Menu.Content:PaintOver(w,h)
		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(bVGUI.MATERIAL_SHADOW)
		surface.DrawTexturedRect(0,0,10,h)
	end

	GAS.Menu.DragThink = GAS.Menu.Think
	function GAS.Menu:Think()
		self:DragThink()
		if (IsValid(GAS.ModuleFrame)) then
			self:SetTall(GAS.ModuleFrame:GetTall())
			if (self.Dragging) then
				local x,y = self:GetPos()
				GAS.ModuleFrame:SetPos(x + self:GetWide() - 1, y)
			end
		elseif (GAS.Menu:GetWide() ~= 800 or GAS.Menu:GetTall() ~= 500) then
			GAS.Menu:SetSize(800,500)
			GAS.Menu:Center()
			GAS.Menu.Modules:ClearActive()
		end
	end

	function GAS.Menu:DermaMenuOptions(menu)
		menu:AddOption(L"close", function()
			GAS.Menu:Close()
		end):SetIcon("icon16/cancel.png")
		menu:AddOption(L"website", function()
			GAS:OpenURL("https://gmodadminsuite.com")
		end):SetIcon("icon16/monitor.png")
		menu:AddOption(L"wiki", function()
			GAS:OpenURL("https://gmodsto.re/gmodadminsuite-wiki")
		end):SetIcon("icon16/book.png")
		-- menu:AddOption("Discord", function()
		-- 	GAS:OpenURL("https://gmodsto.re/gmodadminsuite-discord")
		-- end):SetIcon("materials/gmodadminsuite/discord.png")
	end

	local function SizeAndPosition(size_w, size_h, pos_x, pos_y)
		size_w = size_w + 200
		size_h = size_h + 24

		GAS.Menu:Stop()

		local anim = GAS.Menu:NewAnimation(0.5)
		anim.Size  = Vector(size_w, size_h, 0)
		anim.Think = function(anim, panel, fraction)
			if (not anim.StartSize) then
				local w, h = panel:GetSize()
				anim.StartSize = Vector(w, h, 0)
			end

			local size = LerpVector(fraction, anim.StartSize, anim.Size)
			panel:SetSize(size.x, size.y)
		end

		local anim = GAS.Menu:NewAnimation(0.5)
		anim.Pos   = Vector(pos_x or ((ScrW() / 2) - (size_w / 2)), pos_y or ((ScrH() / 2) - (size_h / 2)))
		anim.Think = function(anim, panel, fraction)
			if (not anim.StartPos) then
				local w, h = panel:GetPos()
				anim.StartPos = Vector(w, h, 0)
			end

			local size = LerpVector(fraction, anim.StartPos, anim.Pos)
			panel:SetPos(size.x, size.y)
		end
	end

	GAS.Menu.Tabs = vgui.Create("bVGUI.Tabs", GAS.Menu.Content)
	GAS.Menu.Tabs:Dock(TOP)
	GAS.Menu.Tabs:SetTall(40)

	local welcome_content = GAS.Menu.Tabs:AddTab(L"welcome", Color(76,216,76))

	GAS.Menu.Info = vgui.Create("bVGUI.BlankPanel", welcome_content)
	GAS.Menu.Info:Dock(FILL)

	GAS.Menu.Info.Logo = vgui.Create("DImage", GAS.Menu.Info)
	GAS.Menu.Info.Logo:SetMaterial(logo_mat)
	GAS.Menu.Info.Logo:SetSize(256,256)

	GAS.Menu.Info.ButtonContainer = vgui.Create("bVGUI.BlankPanel", GAS.Menu.Info)
	GAS.Menu.Info.ButtonContainer:SetSize(150,(30 * 3) + (10 * 2))

	local btn1 = vgui.Create("bVGUI.Button", GAS.Menu.Info.ButtonContainer)
	btn1:Dock(TOP)
	btn1:DockMargin(0,0,0,10)
	btn1:SetColor(bVGUI.BUTTON_COLOR_RED)
	btn1:SetText(L"website")
	function btn1:DoClick()
		GAS:OpenURL("https://gmodadminsuite.com")
	end

	local btn2 = vgui.Create("bVGUI.Button", GAS.Menu.Info.ButtonContainer)
	btn2:Dock(TOP)
	btn2:DockMargin(0,0,0,10)
	btn2:SetColor(bVGUI.BUTTON_COLOR_GREEN)
	btn2:SetText(L"wiki")
	function btn2:DoClick()
		GAS:OpenURL("https://gmodsto.re/gmodadminsuite-wiki")
	end

	local btn3 = vgui.Create("bVGUI.Button", GAS.Menu.Info.ButtonContainer)
	btn3:Dock(TOP)
	btn3:SetColor(Color(114, 137, 218))
	btn3:SetText("Discord")
	function btn3:DoClick()
		GAS:OpenURL("https://gmodsto.re/gmodadminsuite-discord")
	end

	GAS.Menu.Info.Copyright = vgui.Create("DLabel", GAS.Menu.Info)
	GAS.Menu.Info.Copyright:SetText("Copyright © " .. os.date("%Y") .. " Billy Venner")
	GAS.Menu.Info.Copyright:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	GAS.Menu.Info.Copyright:SizeToContents()
	GAS.Menu.Info.Copyright:SetMouseInputEnabled(true)
	GAS.Menu.Info.Copyright:SetCursor("hand")
	GAS.Menu.Info.Copyright:SetTextColor(Color(255,255,255,10))
	function GAS.Menu.Info.Copyright:DoClick()
		GAS:OpenURL("https://steamcommunity.com/profiles/76561198040894045")
	end

	function GAS.Menu.Info:PerformLayout()
		self.Logo:SetPos(self:GetWide() / 2 - self.Logo:GetWide() / 2, self:GetTall() / 2 - self.Logo:GetTall() / 2 - 150 / 2 - 5)
		self.ButtonContainer:SetPos(self:GetWide() / 2 - self.ButtonContainer:GetWide() / 2, self:GetTall() / 2 + 5)
		self.Copyright:CenterHorizontal()
		self.Copyright:AlignBottom(10)
	end

	local settings_content, settings_tab = GAS.Menu.Tabs:AddTab(L"settings", Color(76,76,216))
	settings_tab:SetFunction(function()
		if (settings_content.Content) then
			PrintTable(settings_content.Content)
			for _,v in ipairs(settings_content.Content) do
				v:Remove()
			end
			settings_content.Content = {}
		else
			settings_content.Content = {}
		end

		local tabs = vgui.Create("bVGUI.Tabs", settings_content)
		tabs:Dock(TOP)
		tabs:SetTall(40)
		table.insert(settings_content.Content, tabs)

		local general_settings = tabs:AddTab(L"general", Color(216,76,76))
		local language_settings = tabs:AddTab(L"localization", Color(76,216,76))

		local general_settings_form = vgui.Create("bVGUI.Form", general_settings)
		general_settings_form:Dock(FILL)
		general_settings_form:DockMargin(15,15,15,15)
		general_settings_form:SetPaddings(15,15)

		local _,combobox = general_settings_form:AddComboBox(L"setting_default_module", nil, L"setting_default_module_tip", function(index, val, data)
			GAS.LocalConfig.DefaultModule = data
			GAS:SaveLocalConfig("gas", GAS.LocalConfig)
		end)
		combobox:SetSortItems(false)
		combobox:AddChoice(L"none", false, not GAS.LocalConfig.DefaultModule, "icon16/cross.png")

		general_settings_form:AddSwitch(L"setting_menu_voicechat", GAS.LocalConfig.AllowVoiceChat, L"setting_menu_voicechat_tip", function(val)
			GAS.LocalConfig.AllowVoiceChat = val
			GAS:SaveLocalConfig("gas", GAS.LocalConfig)
		end)

		general_settings_form:AddSwitch(L"settings_player_popup_close", GAS.LocalConfig.ClosePlayerPopups, L"settings_player_popup_close_tip", function(val)
			GAS.LocalConfig.ClosePlayerPopups = val
			GAS:SaveLocalConfig("gas", GAS.LocalConfig)
		end)

		local language_settings_form = vgui.Create("bVGUI.Form", language_settings)
		language_settings_form:Dock(FILL)
		language_settings_form:DockMargin(15,15,15,15)
		language_settings_form:SetPaddings(15,15)

		language_settings_form:AddTextEntry(L"short_date_format", GAS.Languages.Config.ShortDateFormat or "", L"short_date_format_tip", function(val)
			if (#val == 0) then
				GAS.Languages.Config.ShortDateFormat = false
			else
				GAS.Languages.Config.ShortDateFormat = val
			end
		end, nil, L"default_format")

		language_settings_form:AddTextEntry(L"long_date_format", GAS.Languages.Config.LongDateFormat or "", L"long_date_format_tip", function(val)
			if (#val == 0) then
				GAS.Languages.Config.LongDateFormat = false
			else
				GAS.Languages.Config.LongDateFormat = val
			end
		end, nil, L"default_format")

		language_settings_form:AddSpacing(15)

		local function create_language_setting(module_name, info)
			local _,language_combobox = language_settings_form:AddComboBox(info.Name, nil, "", function(index, value, data)
				if (not data) then
					GAS.Languages.Config.SelectedLanguages[module_name] = nil
				else
					GAS.Languages.Config.SelectedLanguages[module_name] = data
				end
				GAS:SaveLocalConfig("languages", GAS.Languages.Config)
			end, info.Icon)
			language_combobox:SetSortItems(false)
			if (module_name ~= "GAS") then
				language_combobox:AddChoice(L"use_gas_language", false, GAS.Languages.Config.SelectedLanguages[module_name] == nil, "icon16/wand.png")
			end
			for language_name, language_info in pairs(GAS.Languages.LanguageData[module_name]) do
				local selected = false
				if (GAS.Languages.Config.SelectedLanguages[module_name] and GAS.Languages.Config.SelectedLanguages[module_name] == language_name) then
					selected = true
				end
				language_combobox:AddChoice(language_info.Name, language_name, selected, language_info.Flag)
			end
		end
		create_language_setting("GAS", {
			Name = "GmodAdminSuite",
			Icon = "icon16/shield.png",
		})
		for module_name, info in pairs(GAS.Modules.Info) do
			if (info.NoMenu or info.Hidden) then continue end
			combobox:AddChoice(info.Name, module_name, GAS.LocalConfig.DefaultModule == module_name, info.Icon)
			create_language_setting(module_name, info)
		end
	end)

	if (is_operator) then
		local operator_content = GAS.Menu.Tabs:AddTab(L"operator", Color(216,76,76))

		local operator_tabs = vgui.Create("bVGUI.Tabs", operator_content)
		operator_tabs:Dock(TOP)
		operator_tabs:SetTall(40)

		local modules_tab_content = operator_tabs:AddTab(L"modules", Color(76,216,76))
		function modules_tab_content:PaintOver(w,h)
			surface.SetDrawColor(255,255,255,255)
			surface.SetMaterial(bVGUI.MATERIAL_SHADOW)
			surface.DrawTexturedRect(175,0,10,h)
		end

		local modules_categories = vgui.Create("bVGUI.Categories", modules_tab_content)
		modules_categories:Dock(LEFT)
		modules_categories:SetWide(175)

		local modules_content

		modules_categories:AddItem(L"permissions", function()
			if (IsValid(modules_content)) then
				modules_content:Remove()
			end
			modules_content = vgui.Create("bVGUI.BlankPanel", modules_tab_content)
			modules_content:Dock(FILL)

			local permissions_btn_c = vgui.Create("bVGUI.ButtonContainer", modules_content)
			permissions_btn_c:DockMargin(10,10,10,10)
			permissions_btn_c:Dock(TOP)
			permissions_btn_c:SetTall(25)

			local permissions_btn = permissions_btn_c.Button
			permissions_btn:SetColor(bVGUI.BUTTON_COLOR_ORANGE)
			permissions_btn:SetText("OpenPermissions")
			permissions_btn:SetSize(150,25)
			function permissions_btn:DoClick()
				GAS:PlaySound("flash")
				RunConsoleCommand("openpermissions", "gmodadminsuite")
			end

			local text = vgui.Create("DLabel", modules_content)
			text:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
			text:Dock(FILL)
			text:SetContentAlignment(8)
			text:DockMargin(10,0,10,10)
			text:SetTextColor(bVGUI.COLOR_WHITE)
			text:SetText(L"permissions_help")
			text:SetWrap(true)
		end, Color(255,150,50))

		for category, modules in pairs(GAS.Modules.Organised) do
			local category_vgui
			local category_col
			if (category == GAS.MODULE_CATEGORY_ADMINISTRATION) then
				category_col = Color(255,35,35)
				category_vgui = modules_categories:AddCategory(L"administration", category_col)
			elseif (category == GAS.MODULE_CATEGORY_PLAYER_MANAGEMENT) then
				category_col = Color(0,130,255)
				category_vgui = modules_categories:AddCategory(L"player_management", category_col)
			elseif (category == GAS.MODULE_CATEGORY_UTILITIES) then
				category_col = Color(255,75,0)
				category_vgui = modules_categories:AddCategory(L"utilities", category_col)
			elseif (category == GAS.MODULE_CATEGORY_FUN) then
				category_col = Color(190,0,255)
				category_vgui = modules_categories:AddCategory(L"fun", category_col)
			end
			for module_name, info in pairs(modules) do
				local icon = "icon16/delete.png"
				if (GAS.Modules.Config.Enabled[module_name]) then
					icon = "icon16/accept.png"
				end
				local friendly_name = GAS.Modules:GetFriendlyName(module_name)
				local module_item
				module_item = category_vgui:AddItem(friendly_name, function()
					if (IsValid(modules_content)) then
						modules_content:Remove()
					end
					modules_content = vgui.Create("bVGUI.BlankPanel", modules_tab_content)
					modules_content:Dock(FILL)

					local header = vgui.Create("bVGUI.Header", modules_content)
					header:Dock(TOP)
					header:SetText(friendly_name)
					header:SetColor(category_col)
					header:DockMargin(0,0,0,10)

					if (info.Icon) then
						local icon1 = vgui.Create("DImage", header)
						icon1:SetSize(16,16)
						icon1:SetImage(info.Icon)

						local icon2 = vgui.Create("DImage", header)
						icon2:SetSize(16,16)
						icon2:SetImage(info.Icon)

						function header:PerformLayout()
							icon1:AlignLeft(5)
							icon1:CenterVertical()

							icon2:AlignRight(5)
							icon2:CenterVertical()
						end
					end

					local switch_container = vgui.Create("bVGUI.BlankPanel", modules_content)
					switch_container:Dock(TOP)
					switch_container:SetTall(40)
					switch_container:DockMargin(0,0,0,10)

					local switch = vgui.Create("bVGUI.Switch", switch_container)
					switch:SetChecked(GAS.Modules.Config.Enabled[module_name] or false)
					switch:SetText(L"enabled")
					function switch:OnChange()
						if (self:GetChecked()) then
							module_item:SetIcon("icon16/accept.png")
						else
							module_item:SetIcon("icon16/delete.png")
						end
						GAS.Modules.Config.Enabled[module_name] = self:GetChecked() or nil
						GAS:netStart("SetModuleEnabled")
							net.WriteString(module_name)
							net.WriteBool(self:GetChecked())
						net.SendToServer()
					end
					bVGUI.AttachTooltip(switch.ClickableArea, {Text = L"module_enable_switch_tip"})

					function switch_container:PerformLayout()
						switch:Center()
					end

					local script_buttons_container
					local script_buttons = {}
					if (info.GmodStore or info.CridentStore) then
						script_buttons_container = vgui.Create("bVGUI.BlankPanel", modules_content)
						script_buttons_container:Dock(TOP)
						script_buttons_container:SetTall(25)
						script_buttons_container:DockMargin(0,0,0,10)
						function script_buttons_container:PerformLayout(_w)
							local w = (_w - (#script_buttons * (125 + 10)) + 10) / 2
							for i,v in ipairs(script_buttons) do
								v:AlignLeft(w + ((i - 1) * (10 + 125)))
							end
						end
					end

					if (info.GmodStore) then
						local gms = vgui.Create("bVGUI.Button", script_buttons_container)
						table.insert(script_buttons, gms)
						gms:SetSize(125,25)
						gms:SetColor(Color(0,152,234))
						gms:SetText("GmodStore")
						function gms:DoClick()
							GAS:OpenURL("https://gmodstore.com/market/view/" .. info.GmodStore)
						end
					end

					if (info.CridentStore) then
						local crs = vgui.Create("bVGUI.Button", script_buttons_container)
						table.insert(script_buttons, crs)
						crs:SetSize(125,25)
						crs:SetColor(Color(255,40,0))
						crs:SetText("Crident Store")
						function crs:DoClick()
							GAS:OpenURL("https://crident.store/market/products/" .. info.CridentStore)
						end
					end

					if (info.Wiki) then
						local wiki_c = vgui.Create("bVGUI.ButtonContainer", modules_content)
						wiki_c:Dock(TOP)
						wiki_c:SetTall(25)
						wiki_c:DockMargin(0,0,0,10)

						wiki_c.Button:SetColor(bVGUI.BUTTON_COLOR_GREEN)
						wiki_c.Button:SetText(L"wiki")
						wiki_c.Button:SetSize(125,25)
						function wiki_c.Button:DoClick()
							GAS:OpenURL(info.Wiki)
						end
					end
				end, nil, icon)
			end
		end
	end

	local created_anything = false
	for category, modules in pairs(GAS.Modules.Organised) do
		local category_vgui
		for module_name, info in pairs(modules) do
			if (info.NoMenu or info.Hidden) then continue end
			if (info.DarkRP == true and DarkRP == nil) then continue end
			if (GAS.Modules:IsModuleEnabled(module_name) ~= GAS.Modules.MODULE_ENABLED) then continue end
			if (info.OperatorOnly and not is_operator) then continue end
			if (not is_operator and not OpenPermissions:HasPermission(LocalPlayer(), "gmodadminsuite/" .. module_name)) then continue end
			created_anything = true
			if (not category_vgui) then
				if (category == GAS.MODULE_CATEGORY_ADMINISTRATION) then
					category_vgui = GAS.Menu.Modules:AddCategory(L"administration", Color(255,35,35))
				elseif (category == GAS.MODULE_CATEGORY_PLAYER_MANAGEMENT) then
					category_vgui = GAS.Menu.Modules:AddCategory(L"player_management", Color(0,130,255))
				elseif (category == GAS.MODULE_CATEGORY_UTILITIES) then
					category_vgui = GAS.Menu.Modules:AddCategory(L"utilities", Color(255,75,0))
				elseif (category == GAS.MODULE_CATEGORY_FUN) then
					category_vgui = GAS.Menu.Modules:AddCategory(L"fun", Color(190,0,255))
				end
			end
			local item = category_vgui:AddItem(GAS.Modules:GetFriendlyName(module_name), function()
				GAS.Menu.ModuleOpen = module_name

				GAS:OpenModuleFrame(module_name)
				
				GAS.Menu.Fullscreened = false

				local _,h = GAS.ModuleFrame:GetSize()
				GAS.Menu:SetTall(h)
			end, nil, info.Icon)
			if (IsValid(GAS.ModuleFrame)) then
				if (GAS.ModuleFrame.ModuleName == module_name) then
					item:SetActive(true)
				end
			elseif (GAS.LocalConfig.DefaultModule == module_name) then
				item:OnMouseReleased(MOUSE_LEFT)
			end

			GAS.Menu.Modules.IndexedItems[module_name] = item
		end
	end
	if (not created_anything) then
		if (not is_operator) then
			GAS:PlaySound("error")
			bVGUI.RichMessage({
				title = L"no_modules_available",
				text = L"no_modules_available_info",
				button = "OK"
			})
			GAS.Menu:Close()
		else
			GAS.Menu.Modules:SetWide(0)
		end
	else
		GAS.Menu:SetVisible(true)
	end
end

function GAS:OpenMenu()
	if (not GAS_InitPostEntity) then GAS:InitPostEntity_Run() end
	if (IsValid(GAS.Menu)) then GAS.Menu:Close() end

	if (not GAS.Modules.Config) then
		GAS:GetConfig("modules", function(config)
			GAS.Modules.Config = config
			for module_name, enabled in pairs(GAS.Modules.Config.Enabled) do
				if (not enabled) then continue end
				GAS.Modules:LoadModule(module_name, true)
			end
			OpenMenu()
		end)
	else
		OpenMenu()
	end
end

GAS:netReceive("menu", function()
	local selected_module = net.ReadString()
	if (#selected_module == 0) then
		selected_module = false
	end
	if (not selected_module or not hook.Run("gmodadminsuite:ModuleMenu:" .. selected_module)) then
		if (selected_module) then
			GAS:OpenModuleFrame(selected_module)
		else
			GAS:OpenMenu()
		end
	end
end)
--lua/autorun/ig88.lua:
player_manager.AddValidModel( "IG-88", "models/player/ig88/ig88.mdl" );
list.Set( "PlayerOptionsModel", "IG-88", "models/player/ig88/ig88.mdl" );

--lua/autorun/lightsaberdroid.lua:
player_manager.AddValidModel( "Lightsaber Training Droid", "models/player/cheddar/droids/lightsaber_training_droid.mdl" );
list.Set( "PlayerOptionsModel", "Lightsaber Training Droid", "models/player/cheddar/droids/lightsaber_training_droid.mdl" );

--addons/weapon_jedi/lua/lscs/autorun/cl_forcepowers.lua:
local blur = Material("pp/blurscreen")

local SelectorWidth = 410
local SelectorItemHeight = 64
local SelectedItemHeight = 72
local SelectedItemHalfHeight = SelectedItemHeight * 0.5
local StartOffsetToSelectable = 5
local FrameThickness = 3
local SelectorHeight = SelectedItemHeight + 2 * FrameThickness

local X = ScrW() * 0.5 - SelectorWidth * 0.5
local Y = ScrH() * 0.75

local MouseWheelScroller = false
local Selected = 1
local smOffset = 0
local smAlpha = 0
local FadeTimer = 0

LSCS.ForceSelector = LSCS.ForceSelector or {
	KeyActivate = CreateClientConVar( "lscs_key_selector_activate", KEY_LALT, true, true ),
	KeyNext = CreateClientConVar( "lscs_key_selector_next", KEY_H, true, true ),
	KeyPrev = CreateClientConVar( "lscs_key_selector_prev", KEY_G, true, true ),
	KeyUse = CreateClientConVar( "lscs_key_selector_use", KEY_F, true, true ),
}

if IsValid( LSCS.ForceSelector.Selector ) then
	LSCS.ForceSelector.Selector:Remove()
	LSCS.ForceSelector.Selector = nil
end

local function CreateSelector()
	local ForceSelector = vgui.Create("DPanel")
	ForceSelector:SetPos(X, Y)
	ForceSelector:SetSize( SelectorWidth, SelectorHeight + 25 )
	ForceSelector.Paint = function( self, w, h )
		local Time = CurTime()

		local smRate = RealFrameTime()
		local tAlpha = (FadeTimer > Time) and 1 or 0

		smAlpha = smAlpha + math.Clamp(tAlpha - smAlpha,-smRate * 3,smRate * 50)

		if smAlpha == 0 then return end

		local fading_white = Color(255,255,255,smAlpha * 255)
		local fading_blue = Color(0, 127, 255, smAlpha * 255)

		local pX, pY = self:GetPos()
		surface.SetMaterial( blur )
		blur:SetFloat( "$blur", 5 )
		blur:Recompute()
		if render then render.UpdateScreenEffectTexture() end
		surface.SetDrawColor( 255, 255, 255, fading_white.a )
		surface.DrawTexturedRect( -pX, -pY, ScrW(), ScrH() )
		surface.SetDrawColor( 0, 0, 0, 200 * smAlpha )
		surface.DrawRect( 0, 0, w, h )

		local StartX = w * 0.5 + smOffset

		local xh = SelectorItemHeight
		local yh = SelectorHeight

		local ply = LocalPlayer()

		local Rate = RealFrameTime() * 450

		smOffset = math.Clamp(smOffset - math.Clamp(smOffset,-Rate,Rate),-xh * 0.6,xh * 0.6)
		local ForcePowers = ply:lscsGetForceAbilities()

		local Selection = ForcePowers[ Selected ]

		if not Selection then return end

		local SelectionPlus = {}
		local SelectionMinus = {}

		local StartIDp = Selected
		local StartIDm = StartIDp

		for ID = 1, 3 do
			StartIDp = StartIDp + 1
			StartIDm = StartIDm - 1

			if StartIDp > #ForcePowers then
				StartIDp = 1
			end
			if StartIDm < 1 then
				StartIDm = #ForcePowers
			end

			SelectionPlus[ ID ] = ForcePowers[ StartIDp ]
			SelectionMinus[ ID ] = ForcePowers[ StartIDm ]
		end

		surface.SetDrawColor( fading_white )

		surface.SetMaterial( Selection.icon )

		if smOffset ~= 0 then
			surface.DrawTexturedRect( StartX - xh * 0.5, (yh - xh) * 0.5, xh, xh )
		else
			surface.DrawTexturedRect( StartX - SelectedItemHalfHeight + 3, FrameThickness + 3, SelectedItemHeight - 6, SelectedItemHeight - 6 )
			draw.SimpleText( Selection.item.name, "LSCS_FONT", w * 0.5, h - 13, fading_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end

		local addX = SelectedItemHalfHeight + StartOffsetToSelectable
		for _, obj in pairs( SelectionPlus ) do
			surface.SetMaterial( obj.icon )
			surface.DrawTexturedRect( StartX + addX, yh - xh, xh, xh )
			addX = addX + xh
		end

		local subX = -xh - SelectedItemHalfHeight - StartOffsetToSelectable
		for _, obj in pairs( SelectionMinus ) do
			surface.SetMaterial( obj.icon )
			surface.DrawTexturedRect( StartX + subX, yh - xh, xh, xh )
			subX = subX - xh
		end

		surface.DrawRect( 0, 0, FrameThickness, h )
		surface.DrawRect( w - FrameThickness, 0, FrameThickness, h )

		surface.SetDrawColor( fading_blue )

		local Thickness = (smOffset ~= 0) and (3 + math.floor( math.abs( math.cos( CurTime() * 100 ) * 6 )) ) or FrameThickness -- looks cool

		local fXstat = w * 0.5 - SelectedItemHalfHeight
		surface.DrawRect( fXstat, 0, SelectedItemHeight, Thickness )
		surface.DrawRect( fXstat, yh - Thickness, SelectedItemHeight, Thickness )
		surface.DrawRect( fXstat, Thickness, Thickness, yh - 2 * Thickness )
		surface.DrawRect( fXstat + SelectedItemHeight - Thickness, Thickness, Thickness, yh - 2 * Thickness )
	end

	LSCS.ForceSelector.Selector = ForceSelector
end

local ID_IN_USE

local function Use( ID )
	ID_IN_USE = ID

	net.Start("lscs_force_use")
		net.WriteInt( ID, 8 ) -- 127 equipped force powers are enough?
		net.WriteBool( true )
	net.SendToServer()
end

local function StopUse( ID )
	ID_IN_USE = nil

	net.Start("lscs_force_use")
		net.WriteInt( ID, 8 )
		net.WriteBool( false )
	net.SendToServer()
end

net.Receive( "lscs_force_use", function( len )
	for i = 1, net.ReadInt( 9 ) do
		StopUse( net.ReadInt( 8 ) )
	end
end )

local NextNav = 0

local function Prev( dont_set_time )
	if not IsValid( LSCS.ForceSelector.Selector ) then CreateSelector() end

	local Time = CurTime()
	if NextNav > Time then return end
	NextNav = Time + 0.01

	local ply = LocalPlayer()
	local ForcePowers = ply:lscsGetForceAbilities()

	if #ForcePowers == 0 then return end

	Selected = Selected + 1

	surface.PlaySound( "lscs/force_next.mp3" )

	if Selected > #ForcePowers then
		Selected = 1
	end

	smOffset = smOffset + SelectorItemHeight

	if dont_set_time then return end

	FadeTimer = CurTime() + 2
end

local function Next( dont_set_time )
	if not IsValid( LSCS.ForceSelector.Selector ) then CreateSelector() end

	local Time = CurTime()
	if NextNav > Time then return end
	NextNav = Time + 0.01

	local ply = LocalPlayer()
	local ForcePowers = ply:lscsGetForceAbilities()

	if #ForcePowers == 0 then return end

	Selected = Selected - 1

	surface.PlaySound( "lscs/force_next.mp3" )

	if Selected < 1 then
		Selected = #ForcePowers
	end

	smOffset = smOffset - SelectorItemHeight

	if dont_set_time then return end

	FadeTimer = CurTime() + 2
end

local function PlayerButtonDown( ply, button )
	local selector = LSCS.ForceSelector

	local InVehicle = ply:InVehicle()

	local AllowForce = not InVehicle or (InVehicle and ply:GetAllowWeaponsInVehicle())

	if AllowForce then
	-- this needs to be reworked at some point to the same method used as direct inputs
		if button == selector.KeyActivate:GetInt() then
			if #ply:lscsGetForceAbilities() == 0 then return end

			MouseWheelScroller = true
			FadeTimer = CurTime() + 9999
		end
		if button == selector.KeyUse:GetInt() then
			Use( Selected )
		end
		if button == selector.KeyNext:GetInt() then
			Prev() -- inverted lmao
		end
		if button == selector.KeyPrev:GetInt() then
			Next()
		end
	end

	local Input = LSCS.KeyToForce[ button ]

	if not Input then return end

	local ForcePowers = ply:lscsGetForceAbilities()

	for _, name in pairs( Input ) do
		for ID, power in pairs( ForcePowers ) do
			if power.item.id == name then
				Use( ID )
			end
		end
	end
end

local function PlayerButtonUp( ply, button )
	local selector = LSCS.ForceSelector

	if button == selector.KeyActivate:GetInt() then
		MouseWheelScroller = false
		FadeTimer = 0
	end
	if ID_IN_USE and button == selector.KeyUse:GetInt() then
		StopUse( ID_IN_USE )
	end

	local Input = LSCS.KeyToForce[ button ]

	if not Input then return end

	local ForcePowers = ply:lscsGetForceAbilities()

	for _, name in pairs( Input ) do
		for ID, power in pairs( ForcePowers ) do
			if power.item.id == name then
				StopUse( ID )
			end
		end
	end
end

if game.SinglePlayer() then -- holy shit i hate gmod so much why dont these hooks run in SP holy fucking shit
	local IS_MOUSE_ENUM = {
		[MOUSE_LEFT] = true,
		[MOUSE_RIGHT] = true,
		[MOUSE_MIDDLE] = true,
		[MOUSE_4] = true,
		[MOUSE_5] = true,
		[MOUSE_WHEEL_UP] = true,
		[MOUSE_WHEEL_DOWN] = true,
	}

	local function InputPressed( key )
		if IS_MOUSE_ENUM[ key ] then
			return input.IsMouseDown( key ) 
		else
			return input.IsKeyDown( key ) 
		end
	end

	local OldPressed = {false, false,false,false}
	local OldPressedForce = {}

	hook.Add( "Think", "!!!lscs_gmods_prediction_system_is_cancer", function()
		local ply = LocalPlayer()

		local selector = LSCS.ForceSelector

		local SelectorButtons = {selector.KeyActivate:GetInt(),selector.KeyUse:GetInt(),selector.KeyNext:GetInt(),selector.KeyPrev:GetInt()}

		for id, key in pairs( SelectorButtons ) do
			local pressed = InputPressed( key )

			if OldPressed[ id ] ~= pressed then
				OldPressed[ id ] = pressed
				if pressed then
					PlayerButtonDown( ply, key )
				else
					PlayerButtonUp( ply, key )
				end
			end
		end

		for _, entry in pairs( LSCS.Force ) do
			local key = entry.cmd:GetInt()
			if not OldPressedForce[ key ] then OldPressedForce[ key ] = false end
	
			local pressed = InputPressed( key )

			if OldPressedForce[ key ] ~= pressed then
				OldPressedForce[ key ] = pressed
				if pressed then
					PlayerButtonDown( ply, key )
				else
					PlayerButtonUp( ply, key )
				end
			end
		end
	end )
else
	hook.Add( "PlayerButtonDown", "!!!!lscs_buttondownstuff", function( ply, button )
		if IsFirstTimePredicted() then
			PlayerButtonDown( ply, button )
		end
	end)

	hook.Add( "PlayerButtonUp", "!!!!lscs_buttonupstuff", function( ply, button )
		if IsFirstTimePredicted() then
			PlayerButtonUp( ply, button )
		end
	end)
end

local LAST_USED_LMB

hook.Add( "PlayerBindPress", "!!!!_lscs_playerbindpress", function( ply, bind, pressed )
	if not MouseWheelScroller then

		if not LAST_USED_LMB then return end

		if bind ~= "+attack" or pressed then return end

		StopUse( LAST_USED_LMB )

		return
	end

	if ply:InVehicle() and not ply:GetAllowWeaponsInVehicle() then return end

	local Time = CurTime()

	if bind == "invprev" then
		if pressed then
			Prev( true )
		end

		return true
	end

	if bind == "invnext" then
		if pressed then
			Next( true )
		end

		return true
	end
	if bind == "+attack" then
		if pressed then
			LAST_USED_LMB = Selected

			Use( Selected )
		else
			if LAST_USED_LMB then
				StopUse( LAST_USED_LMB )
			end

			LAST_USED_LMB = nil
		end

		return true
	end
end)

local lastSlotChangeTime = 0

hook.Add("StartCommand", "CustomMouseWheelScroll", function(ply, cmd)
	if not MouseWheelScroller then

		if not LAST_USED_LMB then return end

		if bind ~= "+attack" or pressed then return end

		StopUse( LAST_USED_LMB )

		return
	end

	if ply:InVehicle() and not ply:GetAllowWeaponsInVehicle() then return end

    local currentTime = CurTime()

    if cmd:GetMouseWheel() ~= 0 and currentTime - lastSlotChangeTime >= 0.1 then
        local direction = cmd:GetMouseWheel()
        if direction == 1 then
            Next(true)
        elseif direction == -1 then
            Prev(true)
        end
        lastSlotChangeTime = currentTime

        WeaponSelect_LastBindPressed = CurTime() - 1
        LastWeaponHUD = CurTime() - 1

        return true
    end
end)



--addons/weapon_jedi/lua/lscs/autorun/lscs_convar.lua:
-- 2022 and i still havent bothered creating a system that does this automatically

local cVar_SaberDamage = CreateConVar( "lscs_sv_saberdamage", "200", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"Amount of Damage per Saber Hit" )
LSCS.SaberDamage = cVar_SaberDamage and cVar_SaberDamage:GetInt() or 200
cvars.AddChangeCallback( "lscs_sv_saberdamage", function( convar, oldValue, newValue ) 
	LSCS.SaberDamage = tonumber( newValue )
end)


local cVar_BulletForceDrainMul = CreateConVar( "lscs_sv_forcedrain_per_bullet_mul", "0.1", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"BulletDamage is multiplied by this value and then removed from ForcePoints on deflect." )
LSCS.BulletForceDrainMul = cVar_BulletForceDrainMul and cVar_BulletForceDrainMul:GetFloat() or 0.1
cvars.AddChangeCallback( "lscs_sv_forcedrain_per_bullet_mul", function( convar, oldValue, newValue ) 
	LSCS.BulletForceDrainMul = math.max( tonumber( newValue ), 0 )
end)


local cVar_BulletForceDrainMin = CreateConVar( "lscs_sv_forcedrain_per_bullet_min", "1", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"Minimum amount of force a bullet will drain on deflect." )
LSCS.BulletForceDrainMin = cVar_BulletForceDrainMin and cVar_BulletForceDrainMin:GetFloat() or 1
cvars.AddChangeCallback( "lscs_sv_forcedrain_per_bullet_min", function( convar, oldValue, newValue ) 
	LSCS.BulletForceDrainMin = math.max( tonumber( newValue ), 0 )
end)


local cVar_BulletForceDrainMax = CreateConVar( "lscs_sv_forcedrain_per_bullet_max", "5", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"Maxmimum amount of force a bullet will drain on deflect." )
LSCS.BulletForceDrainMax = cVar_BulletForceDrainMax and cVar_BulletForceDrainMax:GetFloat() or 5
cvars.AddChangeCallback( "lscs_sv_forcedrain_per_bullet_max", function( convar, oldValue, newValue ) 
	LSCS.BulletForceDrainMax = math.max( tonumber( newValue ), LSCS.BulletForceDrainMin )
end)


local cVar_AttackInterruptable = CreateConVar( "lscs_sv_bullet_can_interrupt_attack", "1", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"Maxmimum amount of force a bullet will drain on deflect." )
LSCS.AttackInterruptable = cVar_AttackInterruptable and cVar_AttackInterruptable:GetBool() or true
cvars.AddChangeCallback( "lscs_sv_bullet_can_interrupt_attack", function( convar, oldValue, newValue ) 
	LSCS.AttackInterruptable = tonumber( newValue ) ~=0
end)

if SERVER then
	util.AddNetworkString( "lscs_admin_setconvar" )

	net.Receive( "lscs_admin_setconvar", function( length, ply )
		if not IsValid( ply ) or not ply:IsSuperAdmin() then return end

		local ConVar = net.ReadString()
		local Value = tonumber( net.ReadString() )

		RunConsoleCommand( ConVar, Value ) 
	end)
end
--addons/weapon_jedi/lua/lscs/autorun/lscs_player.lua:
local meta = FindMetaTable( "Player" )

function meta:lscsGetForce()
	return self:GetNetVar("lscs_force_mana", self:lscsGetMaxForce()) -- gay
end

function meta:lscsGetMaxForce()
	return self:GetNetVar( "lscs_force_mana_max", 100 ) -- gay
end

function meta:lscsGetShootPos()
	local attachment = self:GetAttachment( self:LookupAttachment( "eyes" ) )

	if attachment then
		return attachment.Pos
	else
		return self:GetShootPos()
	end
end

function meta:lscsGetViewOrigin()
	local angles = self:EyeAngles()
	local pos = self:lscsGetShootPos()

	local clamped_angles = Angle( math.max( angles.p, -60 ), angles.y, angles.r )

	local endpos = pos - clamped_angles:Forward() * 100 + clamped_angles:Up() * 12

	local trace = util.TraceHull({
		start = pos,
		endpos = endpos,
		mask = MASK_SOLID_BRUSHONLY,
		mins = Vector(-5,-5,-5),
		maxs = Vector(5,5,5),
		filter = { self },
	})

	return trace.HitPos
end

if SERVER then
	util.AddNetworkString( "lscs_sync_combo_data" )

	function meta:lscsIsValid()
		local HiltR, HiltL = self:lscsGetHilt()
		local BladeR, BladeL = self:lscsGetBlade()

		return (HiltR and BladeR and HiltR ~= "" and BladeR ~= "") or (HiltL and BladeL and HiltL ~= "" and BladeL ~= "")
	end

	function meta:lscsSetForceRegenAmount( num )
		if not num or not isnumber( num ) then

			self._lscsForceRegenAmount = nil

			return
		end

		self._lscsForceRegenAmount = num
	end

	function meta:lscsGetForceRegenAmount()
		return self._lscsForceRegenAmount or 1
	end

	function meta:lscsSetForce( num )
		self:SetNetVar("lscs_force_mana", num)
	end

	function meta:lscsSetMaxForce( num )
		self:SetNetVar("lscs_force_mana_max", num)
	end

	function meta:lscsTakeForce( Amount )
		if not Amount then Amount = 0 end

		self._lscsNextForceRegen = CurTime() + 2

		local Force = self:lscsGetForce() - Amount

		self:lscsSetForce( math.max( Force, 0 ) )
	end

	function meta:lscsSendComboDataTo( ply )
		if not IsValid( ply ) then return end

		local stances = self.m_lscs_combo or {}

		if table.IsEmpty( stances ) then return end

		net.Start( "lscs_sync_combo_data" )
			net.WriteEntity( self )
			net.WriteInt( #stances, 32 )
			for _, comboname in ipairs( stances ) do
				net.WriteString( comboname )
			end
		net.Send( ply )
	end

	hook.Add( "LSCS:OnPlayerFullySpawned", "sync_combo_data", function( ply )
		for id, other_ply in ipairs( player.GetAll() ) do
			timer.Simple( id * 0.25, function()
				if not IsValid( other_ply ) or not IsValid( ply ) then return end
				other_ply:lscsSendComboDataTo( ply )
			end )
		end
	end )

	hook.Add( "PlayerSpawn", "!!!!!lscs_auto_equip", function( ply )
		if not ply:lscsIsValid() then return end

		ply:lscsCraftSaber( true )

		local SWEP = ply:GetWeapon( "weapon_lscs" )

		if not IsValid( SWEP ) then return end

		SWEP:SetBlockPoints( 999999 )
	end )
else
	net.Receive( "lscs_sync_combo_data", function( len )
		local ply = net.ReadEntity()

		if not IsValid( ply ) then return end

		local num = net.ReadInt( 32 )

		local stances = {}
		for i = 1, num do
			table.insert( stances, net.ReadString() )
		end

		ply.m_lscs_combo = stances
	end )
end

function meta:lscsKeyDown( IN_KEY )
	if not self.lscs_cmd then self.lscs_cmd = {} end

	return self.lscs_cmd[ IN_KEY ]
end

function meta:lscsGetInventory()
	if not self.m_inventory_lscs then self.m_inventory_lscs = {} end
	return self.m_inventory_lscs
end

function meta:lscsGetInventoryItem( index )
	return LSCS:ClassToItem( self:lscsGetInventory()[ index ] )
end

function meta:lscsGetEquipped()
	if not self.m_equipped_lscs then self.m_equipped_lscs = {} end

	return self.m_equipped_lscs
end

function meta:lscsGetForceAbilities()
	if not self.m_equipped_force_lscs then self.m_equipped_force_lscs = {} end

	return self.m_equipped_force_lscs
end

function meta:lscsGetCombo( num )
	if not istable( self.m_lscs_combo ) or table.IsEmpty( self.m_lscs_combo ) then self.m_lscs_combo = { [1] = "default" } end

	if num then
		local combo = LSCS:GetStance( self.m_lscs_combo[ num ] )

		if combo then
			return combo
		else
			return LSCS:GetStance( "default" )
		end
	else
		return self.m_lscs_combo
	end
end

function meta:lscsGetHilt()
	return self.m_lscs_hilt_right, self.m_lscs_hilt_left
end

function meta:lscsGetBlade()
	return self.m_lscs_blade_right, self.m_lscs_blade_left
end

function meta:lscsBuildPlayerInfo()
	local inventory = self:lscsGetInventory()
	local equipped = self:lscsGetEquipped()
	local forcepowers = self:lscsGetForceAbilities()

	table.Empty( forcepowers ) -- all gone poof

	local stances = {}
	local hilt_right
	local hilt_left
	local blade_right
	local blade_left

	for index, item in pairs( inventory ) do
		local eq = equipped[ index ]

		if not isbool( eq ) then continue end

		local object = LSCS:ClassToItem( item )

		if not object then continue end

		local type = object.type
		local ID = object.id

		if type == "stance" then
			table.insert( stances, ID )
			continue
		end
		if type == "hilt" then
			if eq == true then
				if not hilt_right then
					hilt_right = ID
				end
			else
				if not hilt_left then
					hilt_left = ID
				end
			end
			continue
		end
		if type == "crystal" then
			if eq == true then
				if not blade_right then
					blade_right = ID
				end
			else
				if not blade_left then
					blade_left = ID
				end
			end
			continue
		end
		if type == "force" then
			local data = {}
			data.inventoryID = index
			data.item = object
			if CLIENT then data.icon = Material("entities/"..object.class..".png") end

			table.insert( forcepowers, data )
			continue
		end
	end

	table.SortByMember( forcepowers, "inventoryID", true )

	self.m_lscs_combo = stances

	LSCS:SetBlade( self, blade_right, blade_left )
	LSCS:SetHilt( self, hilt_right, hilt_left )

	if SERVER then
		if self._lscsNetworkingReady then
			self:SendLua( "LSCS:RefreshMenu() LocalPlayer():lscsBuildPlayerInfo()" )
		end

		for _, ply in pairs( player.GetAll() ) do
			if ply == self then continue end

			self:lscsSendComboDataTo( ply )
		end

		local wep = self:GetWeapon( "weapon_lscs" )

		if IsValid( wep ) then
			wep:SetActive( false )
		end
	else
		LSCS:RefreshMenu()
	end
end

-- clear all items of this type in this hand
function meta:lscsClearEquipped( type, hand )
	local inventory = self:lscsGetInventory()
	local equipped = self:lscsGetEquipped()

	for index, item in pairs( inventory ) do
		local eq = equipped[ index ]

		local object = LSCS:ClassToItem( item )

		if not object then continue end

		local _type = object.type

		if isbool( hand ) then
			if _type == type and hand == eq then
				self:lscsEquipItem( index, nil )
			end
		else
			if _type == type then
				self:lscsEquipItem( index, nil )
			end
		end
	end
end

hook.Add( "StartCommand", "!!!!lscs_syncedinputs", function( ply, cmd )
	if not ply.lscs_cmd then ply.lscs_cmd = {} end

	-- doing it like this works better than calling ply:KeyDown() directly in the SWEP. prediction lag compensation cancer

	ply.lscs_cmd[ IN_ATTACK ] = cmd:KeyDown( IN_ATTACK )
	ply.lscs_cmd[ IN_FORWARD ] = cmd:KeyDown( IN_FORWARD )
	ply.lscs_cmd[ IN_MOVELEFT ] = cmd:KeyDown( IN_MOVELEFT )
	ply.lscs_cmd[ IN_BACK ] = cmd:KeyDown( IN_BACK )
	ply.lscs_cmd[ IN_MOVERIGHT ] = cmd:KeyDown( IN_MOVERIGHT )
	ply.lscs_cmd[ IN_SPEED ] = cmd:KeyDown( IN_SPEED )
	ply.lscs_cmd[ IN_JUMP ] = cmd:KeyDown( IN_JUMP )
end )

hook.Add("PlayerSwitchWeapon", "PreventLSCSWeaponSwitch", function(ply, oldWeapon, newWeapon)
    if IsValid(oldWeapon) and oldWeapon.LSCS and oldWeapon:GetActive() then
        return true 
    end
end)

--addons/weapon_jedi/lua/lscs/combos/grievous.lua:
COMBO.id = "grievous"
COMBO.PrintName = "General Grievous"
COMBO.Author = "Deltaa"
COMBO.Description = "Nutzung von 2 Lichtschwertern"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = true

COMBO.HoldType = "lscs_jarkai"

COMBO.DamageMultiplier = 0.8
COMBO.MaxBlockPoints = 150

COMBO.Spawnable = false

COMBO.Attacks = {
	["FRONT_DASH"] = {
		AttackAnim = "pure_b_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound()
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.4,
	 },
	["BACKFLIP"] = {
		AttackAnim = "r_c6_t1",
		BeginAttack = function( weapon, ply )  
			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 25 )
			ply:lscsSuppressFalldamage(CurTime() + 5)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.8,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "phalanx_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 2, CurTime(), 0.3, Vector(100,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
    ["-45-"] = {
		AttackAnim = "r_c6_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.8,
	},
	["W_S_"] = {
		AttackAnim = "pure_r_s1_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["__S_"] = {
		AttackAnim = "r_left_t2",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "pure_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["___D"] = {
		AttackAnim = "pure_b_right_t2",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 1,
	},
	["_AS_"] = {
		AttackAnim = "pure_r_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove(1, CurTime(), 0.5, Vector(100, 0, 0))
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
    ["__SD"] = {
		AttackAnim = "pure_b_right_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 1,
	},
	["W___"] = {
		AttackAnim = "ryoku_r_c4_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.7,
	},
}

LSCS:Reload()
--addons/weapon_jedi/lua/lscs/combos/vapaad.lua:
COMBO.id = "vaapad"
COMBO.PrintName = "Form VII | Vaapad"
COMBO.Author = "Deltaa"
COMBO.Description = "Die tödlichste Form"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "lscs_vaapad"

COMBO.DamageMultiplier = 1.1
COMBO.MaxBlockPoints = 125

COMBO.Attacks = {
	["SLAM"] = {
		AttackAnim = "slashdown",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound(nil, 1)
			ply:Freeze( true )
			ply:SetVelocity( Vector(0,0,200) )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple( 0.5, function()
				if IsValid( weapon ) and IsValid( ply ) then
					ply:SetVelocity( Vector(0,0,-1500) )
				end
			end)
		end,
		FinishAttack = function( weapon, ply )
			ply:Freeze( false )
		end,
		Delay = 0.0,
		Duration = 1.5,
	},
	["FRONT_DASH"] = {
		AttackAnim = "pure_b_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(1, 1)
			timer.Simple(0.1, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 1, 2 )
			end)
			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 2 )
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 1, 1 )
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 1, 2 )
			end)

			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1600 )
			else
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 600 + Vector(0,0,40) )
			end
		end,

		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.9,
	 },
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "ryoku_b_s2_t1",
		BeginAttack = function( weapon, ply )  
			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 2 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "ryoku_b_s2_t2",
		BeginAttack = function( weapon, ply )  
			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 2 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.7,
	},
	["____"] = {
		AttackAnim = "pure_b_s2_t3",
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.5, Vector(4500,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.5, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 1 )
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 2 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
	["-45-"] = {
		AttackAnim = "vanguard_r_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound(nil, 1)
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.4,
	},
	["+45+"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound(nil, 1)
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["W_S_"] = {
		AttackAnim = "pure_h_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(1, 1)
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(400,0,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.4, 0.3, Vector(225,0,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.7, 0.6, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 2 )
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 1 )
			end)
			timer.Simple(0.6, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 2 )
			end)
			timer.Simple(0.8, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 2, 1 )
			end)
			timer.Simple(1, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(nil, 1)
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	},
	["__S_"] = {
		AttackAnim = "a_combo4",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound(nil, 1)
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(-10,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 0.3,
	},
	["_A__"] = {
		AttackAnim = "pure_b_right_t1",
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(0,-150,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.4, 0.2, Vector(0,-80,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.6, 0.4, Vector(0,0,0) )

			weapon:DoAttackSound(1, 1)
			timer.Simple(0.1, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 1, 2 )
			end)
			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.65,
	},
	["___D"] = {
		AttackAnim = "pure_b_s2_t3",
		AttackAnimStart = 0.3,
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(0,150,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.4, 0.2, Vector(0,80,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 0.6, 0.4, Vector(0,0,0) )

			weapon:DoAttackSound( math.random(1,2), 1 )

			timer.Simple(0.1, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 2 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(nil, 1)
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.7,
	},
	["W__D"] = {
		AttackAnim = "pure_b_s2_t3",
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(150,150,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.3, Vector(80,80,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 1, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 1 )
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 2 )
			end)
			timer.Simple(0.9, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1.25,
	},
	["WA__"] = {
		AttackAnim = "pure_b_right_t3",
		AttackAnimStart = 0.1,
		BeginAttack = function( weapon, ply )  
			ply:lscsSetTimedMove( 1, CurTime(), 0.7, Vector(150,-150,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.7, 0.3, Vector(80,-80,0) )
			ply:lscsSetTimedMove( 3, CurTime() + 1, 0.4, Vector(0,0,0) )

			timer.Simple(0.2, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
			timer.Simple(0.4, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 1 )
			end)
			timer.Simple(0.5, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( math.random(1,2), 2 )
			end)
			timer.Simple(0.9, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound( 3, 1 )
			end)
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1.25,
	},
	["__SD"] = {
		AttackAnim = "pure_b_s3_t2",
		AttackAnimStart = 0.2,
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(2, 1)
			timer.Simple(0.35, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(math.random(1,2), 1)
			end)

			ply:lscsSetTimedMove( 1, CurTime(), 0.5, Vector(150,80,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.5, 0.5, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
	["_AS_"] = {
		AttackAnim = "pure_b_s2_t2",
		AttackAnimStart = 0.05,
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(1, 1)
			timer.Simple(0.35, function()
				if not IsValid( weapon ) then return end
				weapon:DoAttackSound(math.random(1,2), 1)
			end)
			ply:lscsSetTimedMove( 1, CurTime(), 0.5, Vector(150,-80,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.5, 0.5, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 1,
	},
	["W___"] = {
		AttackAnim = "phalanx_b_s4_t1",
		AttackAnimStart = 0,
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound(nil,1)
			if ply:OnGround() then
				ply:SetVelocity( Angle(0,ply:EyeAngles().y,0):Forward() * 1000 )
			end
			ply:lscsSetTimedMove( 1, CurTime(), 0.9, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.7,
	},
}
--addons/lvs_base/lua/lvs_framework/autorun/cl_menu.lua:

local icon_load_version = Material("gui/html/refresh")

local bgMat = Material( "lvs/controlpanel_bg.png" )
local adminMat = Material( "icon16/shield.png" )
local gradient_mat = Material( "gui/gradient" )
local gradient_down = Material( "gui/gradient_down" )

local FrameSizeX = 600
local FrameSizeY = 400

local function ClientSettings( Canvas )
	local TopPanel = vgui.Create( "DPanel", Canvas )
	TopPanel:SetSize( FrameSizeX, FrameSizeY * 0.35 )
	TopPanel.Paint = function( self, w, h )
		surface.SetDrawColor( 80, 80, 80, 255 )
		surface.SetMaterial( gradient_mat )
		surface.DrawTexturedRect( 1, 0, w, 1 )

		draw.DrawText( "Mouse", "LVS_FONT", 4, 4, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
	end
	TopPanel:Dock( BOTTOM )

	local RightPanel = vgui.Create( "DPanel", Canvas )
	RightPanel:SetSize( FrameSizeX * 0.5, FrameSizeY )
	RightPanel.Paint = function( self, w, h )
		surface.SetDrawColor( 80, 80, 80, 255 )
		surface.SetMaterial( gradient_down )
		surface.DrawTexturedRect( 0, 0, 1, h )
		draw.DrawText( "Misc/Performance", "LVS_FONT", 4, 4, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
	end
	RightPanel:Dock( RIGHT )

	local RightPanelRight = vgui.Create( "DPanel", RightPanel )
	RightPanelRight:SetSize( FrameSizeX * 0.25, FrameSizeY )
	RightPanelRight.Paint = function() end
	RightPanelRight:Dock( RIGHT )

	local LeftPanel = vgui.Create( "DPanel", Canvas )
	LeftPanel:SetSize( FrameSizeX * 0.5, FrameSizeY )
	LeftPanel.Paint = function( self, w, h )
		draw.DrawText( "Preferences", "LVS_FONT", 4, 4, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
	end
	LeftPanel:Dock( LEFT )

	local CheckBoxPanel = vgui.Create( "DPanel", TopPanel )
	CheckBoxPanel:DockMargin( 0, 0, 0, 0 )
	CheckBoxPanel:SetSize( FrameSizeX, 55 )
	CheckBoxPanel.Paint = function() end
	CheckBoxPanel:Dock( TOP )

	if GetConVar( "lvs_mouseaim_type" ):GetInt() == 1 and not LVS:IsDirectInputForced() then
		local CheckBoxType = vgui.Create( "DCheckBoxLabel", CheckBoxPanel )
		CheckBoxType:SetSize( FrameSizeX * 0.5, 55 )
		CheckBoxType:DockMargin( 16, 36, 0, 0 )
		CheckBoxType:Dock( LEFT )
		CheckBoxType:SetText( "Mouse-Aim for:" )
		CheckBoxType:SetConVar("lvs_mouseaim_type") 
		CheckBoxType.OnChange = function( self, bVal )
			if not isbool( self.first ) then self.first = true return end
			timer.Simple(0.1, function() LVS:OpenMenu( true ) end )
		end

		local DScrollPanel = vgui.Create("DScrollPanel", CheckBoxPanel )
		DScrollPanel:SetSize( FrameSizeX * 0.25, 55 )
		DScrollPanel:DockMargin( 8, 0, 8, 0 )
		DScrollPanel:Dock( LEFT )

		for _, vehicletype in pairs( LVS:GetVehicleTypes() ) do
			local ScrollOption = vgui.Create( "DCheckBoxLabel", DScrollPanel )
			ScrollOption:SetText( vehicletype )
			ScrollOption:Dock( TOP )
			ScrollOption:DockMargin( 0, 0, 0, 5 )
			ScrollOption:SetConVar("lvs_mouseaim_type_"..vehicletype) 
		end
	else
		local CheckBox = vgui.Create( "DCheckBoxLabel", CheckBoxPanel )
		CheckBox:SetSize( FrameSizeX * 0.5, 55 )
		CheckBox:DockMargin( 16, 36, 0, 0 )
		CheckBox:Dock( LEFT )
		CheckBox:SetText( "Mouse-Aim Steering" )
		CheckBox:SetConVar("lvs_mouseaim") 
		CheckBox.OnChange = function( self, bVal )
			if not isbool( self.first ) then self.first = true return end
			timer.Simple(0.1, function() LVS:OpenMenu( true ) end )
		end
		if LVS:IsDirectInputForced() then
			CheckBox:SetText( "[DISABLED] Use Mouse-Aim Steering" )
			CheckBox:SetDisabled( true )
		end

		if not LVS:IsDirectInputForced() then
			local CheckBoxType = vgui.Create( "DCheckBoxLabel", CheckBoxPanel )
			CheckBoxType:SetSize( FrameSizeX * 0.5, 55 )
			CheckBoxType:DockMargin( 16, 36, 0, 0 )
			CheckBoxType:Dock( LEFT )
			CheckBoxType:SetText( "Edit Mouse-Aim per Type" )
			CheckBoxType:SetConVar("lvs_mouseaim_type") 
			CheckBoxType.OnChange = function( self, bVal )
				if not isbool( self.first ) then self.first = true return end
				timer.Simple(0.1, function() LVS:OpenMenu( true ) end )
			end
		end
	end

	if GetConVar( "lvs_mouseaim" ):GetInt() == 0 or LVS:IsDirectInputForced() then
		local L = vgui.Create( "DPanel", TopPanel )
		L:SetSize( FrameSizeX * 0.5, FrameSizeY )
		L.Paint = function() end
		L:Dock( LEFT )

		local R = vgui.Create( "DPanel", TopPanel )
		R:SetSize( FrameSizeX * 0.5, FrameSizeY )
		R.Paint = function() end
		R:Dock( RIGHT )

		local slider = vgui.Create( "DNumSlider", R )
		slider:DockMargin( 16, 4, 16, 4 )
		slider:Dock( TOP )
		slider:SetText( "Y Sensitivity" )
		slider:SetMin( -10 )
		slider:SetMax( 10 )
		slider:SetDecimals( 3 )
		slider:SetConVar( "lvs_sensitivity_y" )

		local slider = vgui.Create( "DNumSlider", L )
		slider:DockMargin( 16, 4, 16, 4 )
		slider:Dock( TOP )
		slider:SetText( "X Sensitivity" )
		slider:SetMin( 0 )
		slider:SetMax( 10 )
		slider:SetDecimals( 3 )
		slider:SetConVar( "lvs_sensitivity_x" )

		local slider = vgui.Create( "DNumSlider", L )
		slider:DockMargin( 16, 4, 16, 4 )
		slider:Dock( TOP )
		slider:SetText( "Return Delta" )
		slider:SetMin( 0 )
		slider:SetMax( 10 )
		slider:SetDecimals( 3 )
		slider:SetConVar( "lvs_return_delta" )
	else
		local slider = vgui.Create( "DNumSlider", TopPanel )
		slider:DockMargin( 16, 4, 16, 4 )
		slider:Dock( TOP )
		slider:SetText( "Camera Focus" )
		slider:SetMin( -1 )
		slider:SetMax( 1 )
		slider:SetDecimals( 2 )
		slider:SetConVar( "lvs_camerafocus" )
	end

	local slider = vgui.Create( "DNumSlider", LeftPanel )
	slider:DockMargin( 16, 36, 16, 4 )
	slider:Dock( TOP )
	slider:SetText( "Engine Volume" )
	slider:SetMin( 0 )
	slider:SetMax( 1 )
	slider:SetDecimals( 2 )
	slider:SetConVar( "lvs_volume" )

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanel )
	CheckBox:DockMargin( 16, 43, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Show Team Identifier" )
	CheckBox:SetConVar("lvs_show_identifier") 
	if LVS:IsIndicatorForced() then
		CheckBox:SetText( "[DISABLED] Team Identifier" )
		CheckBox:SetDisabled( true )
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanel )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Show Hit/Kill Marker" )
	CheckBox:SetConVar("lvs_hitmarker") 

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanel )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Enable HUD Editor" )
	CheckBox:SetConVar("lvs_edit_hud") 

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanelRight )
	CheckBox:DockMargin( 16, 43, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Trail Effects" )
	CheckBox:SetConVar("lvs_show_traileffects") 

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanelRight )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Wind/Dust FX/SFX" )
	CheckBox:SetConVar("lvs_show_effects") 

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanelRight )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Scrape/Impact FX" )
	CheckBox:SetConVar("lvs_show_physicseffects") 

	local CheckBox = vgui.Create( "DCheckBoxLabel", RightPanelRight )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Bullet near miss SFX" )
	CheckBox:SetConVar("lvs_bullet_nearmiss")
end

local function ClientControls( Canvas )
	local TextHint = vgui.Create("DPanel", Canvas)
	TextHint:DockMargin( 4, 20, 4, 2 )
	TextHint:SetText("")
	TextHint:Dock( TOP )
	TextHint.Paint = function(self, w, h ) 
		draw.DrawText( "You need to re-enter the vehicle in order for the changes to take effect!", "LVS_FONT_PANEL", w * 0.5, -1, Color( 255, 50, 50, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local DScrollPanel = vgui.Create("DScrollPanel", Canvas)
	DScrollPanel:DockMargin( 0, 0, 0, 24 )
	DScrollPanel:Dock( FILL )

	for category, _ in pairs( LVS.KEYS_CATEGORIES ) do
		local Header = vgui.Create("DPanel", DScrollPanel )
		Header:DockMargin( 0, 4, 4, 2 )
		Header:SetText("")
		Header:Dock( TOP )
		Header.Paint = function(self, w, h ) 
			surface.SetMaterial( gradient_mat )
			surface.SetDrawColor( 80, 80, 80, 255 )
			surface.DrawTexturedRect( 0, 0, w, 1 )
	
			draw.DrawText( category, "LVS_FONT", 4, 0, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		end

		for _, entry in pairs( LVS.KEYS_REGISTERED ) do
			if entry.category ~= category then continue end

			local DPanel = vgui.Create( "DPanel", DScrollPanel )
			DPanel.Paint = function(self, w, h ) end
			DPanel:DockMargin( 4, 2, 4, 2 )
			DPanel:SetSize( FrameSizeX, 25 )
			DPanel:Dock( TOP )

			local ConVar = GetConVar( entry.cmd )

			local DLabel = vgui.Create("DLabel", DPanel)
			DLabel:DockMargin( 16, 0, 0, 0 )
			DLabel:SetText( entry.printname )
			DLabel:SetSize( FrameSizeX * 0.5, 32 )
			DLabel:Dock( LEFT )

			local DBinder = vgui.Create("DBinder", DPanel)
			DBinder:DockMargin( 0, 0, 0, 0 )
			DBinder:SetValue( ConVar:GetInt() )
			DBinder:SetSize( FrameSizeX * 0.5, 32 )
			DBinder:Dock( RIGHT )
			DBinder.ConVar = ConVar
			DBinder.OnChange = function(self,iNum)
				self.ConVar:SetInt(iNum)

				LocalPlayer():lvsBuildControls()
			end
		end
	end

	local Header = vgui.Create("DPanel", DScrollPanel )
	Header:DockMargin( 0, 16, 0, 0 )
	Header:SetText("")
	Header:Dock( TOP )
	Header.Paint = function(self, w, h ) 
		surface.SetMaterial( gradient_mat )
		surface.SetDrawColor( 80, 80, 80, 255 )
		surface.DrawTexturedRect( 0, 0, w, 1 )
	end

	local DButton = vgui.Create("DButton",DScrollPanel)
	DButton:SetText("Reset")
	DButton:DockMargin( 4, 0, 4, 4 )
	DButton:SetSize( FrameSizeX, 32 )
	DButton:Dock( TOP )
	DButton.DoClick = function() 
		surface.PlaySound( "buttons/button14.wav" )

		for _, entry in pairs( LVS.KEYS_REGISTERED ) do
			GetConVar( entry.cmd ):SetInt( entry.default ) 
		end

		LocalPlayer():lvsBuildControls()

		LVS:OpenClientControls()
	end
end

local function ServerSettings( Canvas )
	local slider = vgui.Create( "DNumSlider", Canvas )
	slider:DockMargin( 16, 32, 16, 4 )
	slider:Dock( TOP )
	slider:SetText( "Player Default AI-Team" )
	slider:SetMin( 0 )
	slider:SetMax( 3 )
	slider:SetDecimals( 0 )
	slider:SetConVar( "lvs_default_teams" )
	function slider:OnValueChanged( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_default_teams")
			net.WriteString( tostring( math.Round(val,0) ) )
		net.SendToServer()
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", Canvas )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Freeze Player AI-Team" )
	CheckBox:SetValue( GetConVar( "lvs_freeze_teams" ):GetInt() )
	CheckBox:SizeToContents()
	function CheckBox:OnChange( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_freeze_teams")
			net.WriteString( tostring( val and 1 or 0 ) )
		net.SendToServer()
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", Canvas )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Only allow Players of matching AI-Team to enter Vehicles" )
	CheckBox:SetValue( GetConVar( "lvs_teampassenger" ):GetInt() )
	CheckBox:SizeToContents()
	function CheckBox:OnChange( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_teampassenger")
			net.WriteString( tostring( val and 1 or 0 ) )
		net.SendToServer()
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", Canvas )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "LVS-AI ignore NPC's" )
	CheckBox:SetValue( GetConVar( "lvs_ai_ignorenpcs" ):GetInt() )
	CheckBox:SizeToContents()
	function CheckBox:OnChange( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_ai_ignorenpcs")
			net.WriteString( tostring( val and 1 or 0 ) )
		net.SendToServer()
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", Canvas )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "LVS-AI ignore Players's" )
	CheckBox:SetValue( GetConVar( "lvs_ai_ignoreplayers" ):GetInt() )
	CheckBox:SizeToContents()
	function CheckBox:OnChange( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_ai_ignoreplayers")
			net.WriteString( tostring( val and 1 or 0 ) )
		net.SendToServer()
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", Canvas )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Disable Mouse Aim" )
	CheckBox:SetValue( GetConVar( "lvs_force_directinput" ):GetInt() )
	CheckBox:SizeToContents()
	function CheckBox:OnChange( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_force_directinput")
			net.WriteString( tostring( val and 1 or 0 ) )
		net.SendToServer()
	end

	local CheckBox = vgui.Create( "DCheckBoxLabel", Canvas )
	CheckBox:DockMargin( 16, 16, 4, 4 )
	CheckBox:SetSize( FrameSizeX, 30 )
	CheckBox:Dock( TOP )
	CheckBox:SetText( "Hide Team Identifier" )
	CheckBox:SetValue( GetConVar( "lvs_force_forceindicator" ):GetInt() )
	CheckBox:SizeToContents()
	function CheckBox:OnChange( val )
		net.Start("lvs_admin_setconvar")
			net.WriteString("lvs_force_forceindicator")
			net.WriteString( tostring( val and 1 or 0 ) )
		net.SendToServer()
	end
end

function LVS:OpenClientSettings()
	if not IsValid( LVS.Frame ) then return end

	local BasePanel = LVS.Frame:CreatePanel()

	local DPanel = vgui.Create( "DPanel", BasePanel )
	DPanel.Paint = function(self, w, h ) end
	DPanel:DockMargin( 0, 0, 0, 0 )
	DPanel:SetSize( FrameSizeX, 25 )
	DPanel:Dock( TOP )

	local TabPanel = vgui.Create( "DPanel", BasePanel )
	TabPanel.Paint = function(self, w, h ) end
	TabPanel:DockMargin( 0, 0, 0, 0 )
	TabPanel:SetSize( FrameSizeX, 25 )
	TabPanel:Dock( TOP )

	local SettingsPanel = vgui.Create( "DPanel", TabPanel )
	SettingsPanel:DockMargin( 0, 0, 0, 0 )
	SettingsPanel:SetSize( FrameSizeX * 0.5, 32 )
	SettingsPanel:Dock( LEFT )
	SettingsPanel.Paint = function(self, w, h ) 
		draw.DrawText( "SETTINGS", "LVS_FONT", w * 0.5, 0, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local DButton = vgui.Create( "DButton", TabPanel )
	DButton:DockMargin( 0, 0, 0, 0 )
	DButton:SetText( "" )
	DButton:SetSize( FrameSizeX * 0.5, 32 )
	DButton:Dock( RIGHT )
	DButton.DoClick = function()
		surface.PlaySound( "buttons/button14.wav" )
		LVS:OpenClientControls()
	end
	DButton.Paint = function(self, w, h ) 
		surface.SetDrawColor(0, 0, 0, 255)
		surface.DrawRect(0, 0, w, h)

		local Hovered = self:IsHovered()

		if Hovered then
			surface.SetDrawColor( 120, 120, 120, 255 )
		else
			surface.SetDrawColor( 80, 80, 80, 255 )
		end

		surface.DrawRect(1, 0, w-2, h-1)

		local Col = Hovered and Color( 255, 255, 255, 255 ) or Color( 150, 150, 150, 255 )
		draw.DrawText( "CONTROLS", "LVS_FONT", w * 0.5, 0, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local DButton = vgui.Create( "DButton", DPanel )
	DButton:DockMargin( 0, 0, 0, 0 )
	DButton:SetText( "" )
	DButton:SetSize( FrameSizeX * 0.5, 32 )
	DButton:Dock( RIGHT )
	DButton.DoClick = function()
		if LocalPlayer():IsSuperAdmin() then
			surface.PlaySound( "buttons/button14.wav" )
			LVS:OpenServerMenu()
		else
			surface.PlaySound( "buttons/button11.wav" )
		end
	end
	DButton.Paint = function(self, w, h ) 
		surface.SetDrawColor(0, 0, 0, 255)
		surface.DrawRect(0, 0, w, h)

		local Hovered = self:IsHovered()

		if Hovered then
			draw.RoundedBox( 4, 1, 1, w-2, h-2, Color( 120, 120, 120, 255 ) )
		else
			draw.RoundedBox( 4, 1, 1, w-2, h-2, Color( 80, 80, 80, 255 ) )
		end

		surface.SetDrawColor( 255, 255, 255, Hovered and 255 or 50 )
		surface.SetMaterial( adminMat )
		surface.DrawTexturedRect( 3, 2, 16, 16 )

		local Col = Hovered and Color( 255, 255, 255, 255 ) or Color( 150, 150, 150, 255 )
		draw.DrawText( "SERVER", "LVS_FONT", w * 0.5, 0, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local ClientPanel = vgui.Create( "DPanel", DPanel )
	ClientPanel.Paint = function(self, w, h ) end
	ClientPanel:DockMargin( 0, 0, 0, 0 )
	ClientPanel:SetSize( FrameSizeX * 0.5, 32 )
	ClientPanel:Dock( LEFT )
	ClientPanel.Paint = function(self, w, h ) 
		draw.DrawText( "CLIENT", "LVS_FONT", w * 0.5, 0, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local Canvas = vgui.Create( "DPanel", BasePanel )
	Canvas.Paint = function(self, w, h ) end
	Canvas:DockMargin( 0, 0, 0, 0 )
	Canvas:SetSize( FrameSizeX, 25 )
	Canvas:Dock( FILL )

	ClientSettings( Canvas )
end

function LVS:OpenClientControls()
	if not IsValid( LVS.Frame ) then return end

	local BasePanel = LVS.Frame:CreatePanel()

	local DPanel = vgui.Create( "DPanel", BasePanel )
	DPanel.Paint = function(self, w, h ) end
	DPanel:DockMargin( 0, 0, 0, 0 )
	DPanel:SetSize( FrameSizeX, 25 )
	DPanel:Dock( TOP )

	local TabPanel = vgui.Create( "DPanel", BasePanel )
	TabPanel.Paint = function(self, w, h ) end
	TabPanel:DockMargin( 0, 0, 0, 0 )
	TabPanel:SetSize( FrameSizeX, 25 )
	TabPanel:Dock( TOP )

	local SettingsPanel = vgui.Create( "DPanel", TabPanel )
	SettingsPanel:DockMargin( 0, 0, 0, 0 )
	SettingsPanel:SetSize( FrameSizeX * 0.5, 32 )
	SettingsPanel:Dock( RIGHT )
	SettingsPanel.Paint = function(self, w, h ) 
		draw.DrawText( "CONTROLS", "LVS_FONT", w * 0.5, 0, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local DButton = vgui.Create( "DButton", TabPanel )
	DButton:DockMargin( 0, 0, 0, 0 )
	DButton:SetText( "" )
	DButton:SetSize( FrameSizeX * 0.5, 32 )
	DButton:Dock( LEFT )
	DButton.DoClick = function()
		surface.PlaySound( "buttons/button14.wav" )
		LVS:OpenClientSettings()
	end
	DButton.Paint = function(self, w, h ) 
		surface.SetDrawColor(0, 0, 0, 255)
		surface.DrawRect(0, 0, w, h)

		local Hovered = self:IsHovered()

		if Hovered then
			surface.SetDrawColor( 120, 120, 120, 255 )
		else
			surface.SetDrawColor( 80, 80, 80, 255 )
		end

		surface.DrawRect(1, 1, w-2, h-2)

		local Col = Hovered and Color( 255, 255, 255, 255 ) or Color( 150, 150, 150, 255 )
		draw.DrawText( "SETTINGS", "LVS_FONT", w * 0.5, 0, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local DButton = vgui.Create( "DButton", DPanel )
	DButton:DockMargin( 0, 0, 0, 0 )
	DButton:SetText( "" )
	DButton:SetSize( FrameSizeX * 0.5, 32 )
	DButton:Dock( RIGHT )
	DButton.DoClick = function()
		if LocalPlayer():IsSuperAdmin() then
			surface.PlaySound( "buttons/button14.wav" )
			LVS:OpenServerMenu()
		else
			surface.PlaySound( "buttons/button11.wav" )
		end
	end
	DButton.Paint = function(self, w, h ) 
		surface.SetDrawColor(0, 0, 0, 255)
		surface.DrawRect(0, 0, w, h)

		local Hovered = self:IsHovered()

		if Hovered then
			draw.RoundedBox( 4, 1, 1, w-2, h-2, Color( 120, 120, 120, 255 ) )
		else
			draw.RoundedBox( 4, 1, 1, w-2, h-2, Color( 80, 80, 80, 255 ) )
		end

		surface.SetDrawColor( 255, 255, 255, Hovered and 255 or 50 )
		surface.SetMaterial( adminMat )
		surface.DrawTexturedRect( 3, 2, 16, 16 )

		local Col = Hovered and Color( 255, 255, 255, 255 ) or Color( 150, 150, 150, 255 )
		draw.DrawText( "SERVER", "LVS_FONT", w * 0.5, 0, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local ClientPanel = vgui.Create( "DPanel", DPanel )
	ClientPanel.Paint = function(self, w, h ) end
	ClientPanel:DockMargin( 0, 0, 0, 0 )
	ClientPanel:SetSize( FrameSizeX * 0.5, 32 )
	ClientPanel:Dock( LEFT )
	ClientPanel.Paint = function(self, w, h ) 
		draw.DrawText( "CLIENT", "LVS_FONT", w * 0.5, 0, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local Canvas = vgui.Create( "DPanel", BasePanel )
	Canvas.Paint = function(self, w, h ) end
	Canvas:DockMargin( 0, 0, 0, 0 )
	Canvas:SetSize( FrameSizeX, 25 )
	Canvas:Dock( FILL )

	ClientControls( Canvas )
end

function LVS:OpenServerMenu()
	if not IsValid( LVS.Frame ) then return end

	local BasePanel = LVS.Frame:CreatePanel()

	local DPanel = vgui.Create( "DPanel", BasePanel )
	DPanel.Paint = function(self, w, h ) end
	DPanel:DockMargin( 0, 0, 0, 0 )
	DPanel:SetSize( FrameSizeX, 25 )
	DPanel:Dock( TOP )

	local ServerPanel = vgui.Create( "DPanel", DPanel )
	ServerPanel.Paint = function(self, w, h ) end
	ServerPanel:DockMargin( 0, 0, 0, 0 )
	ServerPanel:SetSize( FrameSizeX * 0.5, 32 )
	ServerPanel:Dock( RIGHT )
	ServerPanel.Paint = function(self, w, h ) 
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.SetMaterial( adminMat )
		surface.DrawTexturedRect( 3, 2, 16, 16 )
		draw.DrawText( "SERVER", "LVS_FONT", w * 0.5, 0, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local DButton = vgui.Create( "DButton", DPanel )
	DButton:DockMargin( 0, 0, 0, 0 )
	DButton:SetText( "" )
	DButton:SetSize( FrameSizeX * 0.5, 32 )
	DButton:Dock( LEFT )
	DButton.DoClick = function()
		surface.PlaySound( "buttons/button14.wav" )
		LVS:OpenClientSettings()
	end
	DButton.Paint = function(self, w, h ) 
		surface.SetDrawColor(0, 0, 0, 255)
		surface.DrawRect(0, 0, w, h)

		local Hovered = self:IsHovered()

		if Hovered then
			draw.RoundedBox( 4, 1, 1, w-2, h-2, Color( 120, 120, 120, 255 ) )
		else
			draw.RoundedBox( 4, 1, 1, w-2, h-2, Color( 80, 80, 80, 255 ) )
		end

		local Col = Hovered and Color( 255, 255, 255, 255 ) or Color( 150, 150, 150, 255 )
		draw.DrawText( "CLIENT", "LVS_FONT", w * 0.5, 0, Col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local Canvas = vgui.Create( "DPanel", BasePanel )
	Canvas.Paint = function(self, w, h ) end
	Canvas:DockMargin( 0, 0, 0, 0 )
	Canvas:SetSize( FrameSizeX, 25 )
	Canvas:Dock( FILL )

	ServerSettings( Canvas )
end

function LVS:CloseMenu()
	if not IsValid( LVS.Frame ) then return end

	LVS.Frame:Close()
	LVS.Frame = nil
end

function LVS:OpenMenu( keep_position )
	local xPos
	local yPos

	if IsValid( LVS.Frame ) then
		if keep_position then
			xPos = LVS.Frame:GetX()
			yPos = LVS.Frame:GetY()
		end

		LVS:CloseMenu()
	end

	LVS.Frame = vgui.Create( "DFrame" )
	LVS.Frame:SetSize( FrameSizeX, FrameSizeY )
	LVS.Frame:SetTitle( "" )
	LVS.Frame:SetDraggable( true )
	LVS.Frame:SetScreenLock( true )
	LVS.Frame:MakePopup()
	LVS.Frame:Center()
	if keep_position and xPos and yPos then
		LVS.Frame:SetPos( xPos, yPos )
	end

	LVS.Frame.Paint = function(self, w, h )
		draw.RoundedBox( 8, 0, 0, w, h, Color( 0, 0, 0, 255 ) )
		draw.RoundedBoxEx( 8, 1, 26, w-2, h-27, Color( 120, 120, 120, 255 ), false, false, true, true )
		draw.RoundedBoxEx( 8, 0, 0, w, 25, LVS.ThemeColor, true, true )

		draw.SimpleText( "[LVS] - Control Panel ", "LVS_FONT", 5, 11, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

		surface.SetDrawColor( 255, 255, 255, 50 )
		surface.SetMaterial( bgMat )
		surface.DrawTexturedRect( 0, -50, w, w )
	end
	LVS.Frame.CreatePanel = function( self )

		if IsValid( self.OldPanel ) then
			self.OldPanel:Remove()
			self.OldPanel = nil
		end

		local DPanel = vgui.Create( "DPanel", LVS.Frame )
		DPanel:SetPos( 0, 25 )
		DPanel:SetSize( FrameSizeX, FrameSizeY - 25 )
		DPanel.Paint = function(self, w, h )
			local Col = Color( 255, 191, 0, 255 ) 

			if LVS.VERSION_GITHUB == 0 then
				surface.SetMaterial( icon_load_version )
				surface.SetDrawColor( Col )
				surface.DrawTexturedRectRotated( w - 14, h - 14, 16, 16, -CurTime() * 200 )

				draw.SimpleText( "v"..LVS:GetVersion()..LVS.VERSION_TYPE, "LVS_VERSION", w - 23, h - 14, Col, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )

				return
			end

			local Current = LVS:GetVersion()
			local Latest = LVS.VERSION_GITHUB

			local Pref = "v"

			if Current >= Latest and not LVS.VERSION_ADDONS_OUTDATED then
				Col = Color(0,255,0,255)
			else
				Col = Color(255,0,0,255)
				Pref = "OUTDATED v"
			end

			draw.SimpleText( Pref..LVS:GetVersion()..LVS.VERSION_TYPE, "LVS_VERSION", w - 7, h - 14, Col, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
		end

		self.OldPanel = DPanel

		return DPanel
	end

	LVS:OpenClientSettings()
end

list.Set( "DesktopWindows", "LVSMenu", {
	title = "[LVS] Settings",
	icon = "icon64/iconlvs.png",
	init = function( icon, window )
		LVS:OpenMenu()
	end
} )

concommand.Add( "lvs_openmenu", function( ply, cmd, args ) LVS:OpenMenu() end )
--addons/lvs_base/lua/lvs_framework/autorun/lvs_player.lua:
local meta = FindMetaTable( "Player" )

function meta:lvsGetAITeam()
	return self:GetNWInt( "lvsAITeam", LVS.PlayerDefaultTeam )
end

function meta:lvsGetVehicle()
	local Pod = self:GetVehicle()

	if not IsValid( Pod ) then return NULL end

	if Pod.LVSchecked then

		return Pod.LVSBaseEnt

	else
		local Parent = Pod:GetParent()
		
		if not IsValid( Parent ) then return NULL end

		if not Parent.LVS then
			Pod.LVSchecked = LVS.MapDoneLoading
			Pod.LVSBaseEnt = NULL

			return NULL
		end

		Pod.LVSchecked = LVS.MapDoneLoading
		Pod.LVSBaseEnt = Parent

		return Parent
	end
end

function meta:lvsGetWeaponHandler()
	local Pod = self:GetVehicle()

	if not IsValid( Pod ) then return NULL end

	local weapon = Pod:lvsGetWeapon()

	if IsValid( weapon ) then
		return weapon
	else
		local veh = self:lvsGetVehicle()

		if not IsValid( veh ) then return NULL end

		if veh:GetDriver() == self then
			return veh
		else
			return NULL
		end
	end
end

function meta:lvsGetControls()
	if not istable( self.LVS_BINDS ) then
		self:lvsBuildControls()
	end
	
	return self.LVS_BINDS
end

function meta:lvsMouseAim()
	if LVS:IsDirectInputForced() then
		return false
	end

	return self._lvsMouseAim
end

function meta:lvsMouseSensitivity()
	local X = self._lvsMouseX or 1
	local Y = self._lvsMouseY or 1
	local delta = self._lvsReturnDelta or 1

	return X, Y, delta
end

function meta:lvsBuildControls()
	if istable( self.LVS_BINDS ) then
		table.Empty( self.LVS_BINDS )
	end

	if SERVER then
		self._lvsMouseAim = self:GetInfoNum( "lvs_mouseaim", 0 ) == 1

		self.LVS_BINDS = table.Copy( LVS.KEYS_CATEGORIES )

		for _,v in pairs( LVS.KEYS_REGISTERED ) do
			if v.id == "~SKIP~" then continue end

			local ButtonID = self:GetInfoNum( v.cmd, 0 )

			if not self.LVS_BINDS[v.category][ ButtonID ] then
				self.LVS_BINDS[v.category][ ButtonID ] = {}
			end

			table.insert( self.LVS_BINDS[v.category][ ButtonID ], v.id )
		end

		net.Start( "lvs_buildcontrols" )
		net.Send( self )

		self._lvsMouseX = self:GetInfoNum( "lvs_sensitivity_x", 1 )
		self._lvsMouseY = self:GetInfoNum( "lvs_sensitivity_y", 1 )
		self._lvsReturnDelta = self:GetInfoNum( "lvs_return_delta", 1 )
	else
		self._lvsMouseAim = GetConVar( "lvs_mouseaim" ):GetInt() == 1
		self._lvsMouseX = GetConVar(  "lvs_sensitivity_x" ):GetFloat()
		self._lvsMouseY = GetConVar( "lvs_sensitivity_y" ):GetFloat()
		self._lvsReturnDelta = GetConVar( "lvs_return_delta" ):GetFloat()

		self.LVS_BINDS = {}

		local KeySpawnMenu = input.LookupBinding( "+menu" )
		if isstring( KeySpawnMenu ) then
			KeySpawnMenu = input.GetKeyCode( KeySpawnMenu )
		end

		local KeyContextMenu = input.LookupBinding( "+menu_context" )
		if isstring( KeyContextMenu ) then
			KeyContextMenu = input.GetKeyCode( KeyContextMenu )
		end

		self._lvsDisableSpawnMenu = nil
		self._lvsDisableContextMenu = nil

		for _,v in pairs( LVS.KEYS_REGISTERED ) do
			if v.id == "~SKIP~" then continue end

			local KeyCode = GetConVar( v.cmd ):GetInt()

			self.LVS_BINDS[ v.id ] = KeyCode

			if KeyCode == KeySpawnMenu then
				self._lvsDisableSpawnMenu = true
			end
			if KeyCode == KeyContextMenu then
				self._lvsDisableContextMenu = true
			end
		end
	end
end

local IS_MOUSE_ENUM = {
	[MOUSE_LEFT] = true,
	[MOUSE_RIGHT] = true,
	[MOUSE_MIDDLE] = true,
	[MOUSE_4] = true,
	[MOUSE_5] = true,
	[MOUSE_WHEEL_UP] = true,
	[MOUSE_WHEEL_DOWN] = true,
}

local function GetInput( ply, name )
	if SERVER then
		if not ply._lvsKeyDown then
			ply._lvsKeyDown = {}
		end

		return ply._lvsKeyDown[ name ] == true
	else
		local Key = ply:lvsGetControls()[ name ] or 0

		if IS_MOUSE_ENUM[ Key ] then
			return input.IsMouseDown( Key ) 
		else
			return input.IsKeyDown( Key ) 
		end
	end
end

function meta:lvsKeyDown( name )
	if not self:lvsGetInputEnabled() then return false end

	local Pressed = GetInput( self, name )
	local NewPressed = hook.Run( "LVS.PlayerKeyDown", self, name, Pressed )

	if isbool( NewPressed ) then
		return NewPressed
	else
		return Pressed
	end
end

function meta:lvsGetInputEnabled()
	return (self._lvsKeyDisabler or 0) < CurTime()
end

function meta:lvsSetInputDisabled( disable )
	if CLIENT then
		net.Start( "lvs_buildcontrols" )
			net.WriteBool( disable )
		net.SendToServer()
	end

	if disable then
		self._lvsKeyDisabler = CurTime() + 120
	else
		self._lvsKeyDisabler = CurTime() + 0.25
	end
end

if CLIENT then
	function meta:lvsSetView( view )
		self._lvsViewPos = view.origin or vector_origin
		self._lvsViewAngles = view.angles or angle_zero

		return view
	end

	function meta:lvsGetView()
		local pos = self._lvsViewPos or vector_origin
		local ang = self._lvsViewAngles or angle_zero

		return pos, ang
	end

	net.Receive( "lvs_buildcontrols", function( len )
		local ply = LocalPlayer()
		if not IsValid( ply ) then return end
		ply:lvsBuildControls()
	end )

	local OldVisible = false
	local function KeyBlocker()
		local Visible = gui.IsGameUIVisible() or vgui.CursorVisible()

		if Visible ~= OldVisible then
			OldVisible = Visible

			local ply = LocalPlayer()

			if not IsValid( ply ) then return end

			if Visible then
				ply:lvsSetInputDisabled( true )
			else
				ply:lvsSetInputDisabled( false )
			end
		end
	end

	hook.Add( "LVS.PlayerEnteredVehicle", "!!!!!lvs_keyblocker_enable", function( ply, veh )
		hook.Add("PostDrawHUD", "!!!lvs_keyblocker", KeyBlocker )
	end )

	hook.Add( "LVS.PlayerLeaveVehicle", "!!!!!lvs_keyblocker_disable", function( ply, veh )
		hook.Remove("PostDrawHUD", "!!!lvs_keyblocker" )
	end )

	local players_bonemanip = {}

	local function StartBoneManip( id )
		players_bonemanip[ id ] = true
	end

	local function StopBoneManip( id )
		if not players_bonemanip[ id ] then return end

		players_bonemanip[ id ] = nil

		local ply = Entity( id )

		if not IsValid( ply ) then return end

		local angle_zero = Angle(0,0,0)

		for i = 0, (ply:GetBoneCount() - 1) do
			ply:ManipulateBoneAngles( i, angle_zero )
		end
	end

	net.Receive( "lvs_bonemanip", function( len )
		local entindex = net.ReadInt( 9 )
		local enable = net.ReadBool()

		if enable then
			StartBoneManip( entindex )

			return
		end

		StopBoneManip( entindex )
	end )

	hook.Add( "PrePlayerDraw", "!!!!!lvs_player_bonemanip", function( ply, flags )
		if not players_bonemanip[ ply:EntIndex() ] then return end

		local Pod = ply:GetVehicle()
		local vehicle = ply:lvsGetVehicle()

		if not IsValid( Pod ) or not IsValid( vehicle ) then return end

		local BoneManipulate = vehicle:GetPlayerBoneManipulation( ply, Pod:lvsGetPodIndex() )

		for name, ang in pairs( BoneManipulate ) do
			local bone = ply:LookupBone( name )

			if not bone then continue end

			ply:ManipulateBoneAngles( bone, ang )
		end
	end )

	return
end

util.AddNetworkString( "lvs_buildcontrols" )
util.AddNetworkString( "lvs_bonemanip" )

function meta:lvsStartBoneManip()
	net.Start( "lvs_bonemanip" )
		net.WriteInt( self:EntIndex(), 9 )
		net.WriteBool( true )
	net.Broadcast()
end

function meta:lvsStopBoneManip()
	net.Start( "lvs_bonemanip" )
		net.WriteInt( self:EntIndex(), 9 )
		net.WriteBool( false )
	net.Broadcast()
end

net.Receive( "lvs_buildcontrols", function( len, ply )
	if not IsValid( ply ) then return end

	ply:lvsSetInputDisabled( net.ReadBool() )
end )

function meta:lvsSetInput( name, value )
	if not self._lvsKeyDown then
		self._lvsKeyDown = {}
	end

	self._lvsKeyDown[ name ] = value
end

LVS.TEAMS = {
	[0] = "FRIENDLY TO EVERYONE",
	[1] = "Team 1",
	[2] = "Team 2",
	[3] = "HOSTILE TO EVERYONE",
}

function meta:lvsSetAITeam( nTeam )
	nTeam = nTeam or LVS.PlayerDefaultTeam

	if self:lvsGetAITeam() ~= nTeam then
		self:PrintMessage( HUD_PRINTTALK, "[LVS] Your AI-Team has been updated to: "..(LVS.TEAMS[ nTeam ] or "") )
	end

	self:SetNWInt( "lvsAITeam", nTeam )
end

hook.Add( "PlayerButtonUp", "!!!lvsButtonUp", function( ply, button )
	for _, KeyBind in pairs( ply:lvsGetControls() ) do
		local KeyTBL = KeyBind[ button ]

		if not KeyTBL then continue end

		for _, KeyName in pairs( KeyTBL ) do
			ply:lvsSetInput( KeyName, false )
		end
	end
end )

hook.Add( "PlayerButtonDown", "!!!lvsButtonDown", function( ply, button )
	if not ply:lvsGetInputEnabled() then return end

	local vehicle = ply:lvsGetVehicle()
	local vehValid = IsValid( vehicle )

	for _, KeyBind in pairs( ply:lvsGetControls() ) do
		local KeyTBL = KeyBind[ button ]

		if not KeyTBL then continue end

		for _, KeyName in pairs( KeyTBL ) do
			ply:lvsSetInput( KeyName, true )

			if not vehValid then continue end

			if string.StartWith( KeyName, "~SELECT~" ) then
				local exp_string = string.Explode( "#", KeyName )
				local base = ply:lvsGetWeaponHandler()

				if exp_string[2] and IsValid( base ) then
					base:SelectWeapon( tonumber( exp_string[2] ) )
				end
			end

			if KeyName == "EXIT" then
				if vehicle:GetDriver() == ply and vehicle:GetlvsLockedStatus() then vehicle:UnLock() end

				if vehicle:GetlvsLockedStatus() then continue end

				ply:ExitVehicle()
			end
		end
	end
end )

hook.Add("CanExitVehicle","!!!lvsCanExitVehicle",function(vehicle,ply)
	if IsValid( ply:lvsGetVehicle() ) then return false end
end)

--lua/autorun/med_droid.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "2-1B Medical Droid",		"models/player/tiki/med_droid.mdl" )

--addons/billy_gas/lua/openpermissions/thirdparty/pon.lua:
--[[

DEVELOPMENTAL VERSION;

VERSION 1.2.2
Copyright thelastpenguin™

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author, thelastpenguin™, if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above still applies to the modified code.

	The author is not held responsible for any damages incured from the use of pon, you use it at your own risk.

DATA TYPES SUPPORTED:
 - tables  - 		k,v - pointers
 - strings - 		k,v - pointers
 - numbers -		k,v
 - booleans- 		k,v
 - Vectors - 		k,v
 - Angles  -		k,v
 - Entities- 		k,v
 - Players - 		k,v

CHANGE LOG
V 1.1.0
 - Added Vehicle, NPC, NextBot, Player, Weapon
V 1.2.0
 - Added custom handling for k,v tables without any array component.
V 1.2.1
 - fixed deserialization bug.

THANKS TO...
 - VERCAS for the inspiration.
]]


local pon = {};

local type, count = type, table.Count ;
local tonumber = tonumber ;
local format = string.format;
do
	local type, count = type, table.Count ;
	local tonumber = tonumber ;
	local format = string.format;

	local encode = {};

	local tryCache ;

	local cacheSize = 0;

	encode['table'] = function( self, tbl, output, cache )

		if( cache[ tbl ] )then
			output[ #output + 1 ] = format('(%x)',  cache[tbl] );
			return ;
		else
			cacheSize = cacheSize + 1;
			cache[ tbl ] = cacheSize;
		end


    local first = next(tbl, nil)
    local predictedNumeric = 1
    local lastKey = nil
    -- starts with a numeric dealio
    if first == 1 then
      output[#output + 1] = '{'

      for k,v in next, tbl do
        if k == predictedNumeric then
          predictedNumeric = predictedNumeric + 1

          local tv = type(v)
          if tv == 'string' then
            local pid = cache[v]
            if pid then
              output[#output + 1] = format('(%x)', pid)
            else
              cacheSize = cacheSize + 1
              cache[v] = cacheSize
              self.string(self, v, output, cache)
            end
          else
            self[tv](self, v, output, cache)
          end

        else
          break
        end
      end

			predictedNumeric = predictedNumeric - 1
    else
      predictedNumeric = nil
    end

    if predictedNumeric == nil then
      output[#output + 1] = '[' -- no array component
    else
      output[#output + 1] = '~' -- array component came first so shit needs to happen
    end

    for k, v in next, tbl, predictedNumeric do
      local tk, tv = type(k), type(v)

      -- WRITE KEY
      if tk == 'string' then
        local pid = cache[ k ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ k ] = cacheSize;

          self.string( self, k, output, cache );
        end
      else
        self[tk](self, k, output, cache)
      end

      -- WRITE VALUE
      if( tv == 'string' )then
        local pid = cache[ v ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ v ] = cacheSize;

          self.string( self, v, output, cache );
        end
      else
        self[ tv ]( self, v, output, cache );
      end
    end

    output[#output + 1] = '}'
	end
	--    ENCODE STRING
	local gsub = string.gsub ;
	encode['string'] = function( self, str, output )
		--if tryCache( str, output ) then return end
		local estr, count = gsub( str, ";", "\\;");
		if( count == 0 )then
			output[ #output + 1 ] = '\''..str..';';
		else
			output[ #output + 1 ] = '"'..estr..'";';
		end
	end
	--    ENCODE NUMBER
	encode['number'] = function( self, num, output )
		if num%1 == 0 then
			if num < 0 then
				output[ #output + 1 ] = format( 'x%x;', -num );
			else
				output[ #output + 1 ] = format('X%x;', num );
			end
		else
			output[ #output + 1 ] = tonumber( num )..';';
		end
	end
	--    ENCODE BOOLEAN
	encode['boolean'] = function( self, val, output )
		output[ #output + 1 ] = val and 't' or 'f'
	end
	--    ENCODE VECTOR
	encode['Vector'] = function( self, val, output )
		output[ #output + 1 ] = ('v'..val.x..','..val.y)..(','..val.z..';');
	end
	--    ENCODE ANGLE
	encode['Angle'] = function( self, val, output )
		output[ #output + 1 ] = ('a'..val.p..','..val.y)..(','..val.r..';');
	end
	encode['Entity'] = function( self, val, output )
		output[ #output + 1] = 'E'..(IsValid( val ) and (val:EntIndex( )..';') or '#');
	end
	encode['Player']  = encode['Entity'];
	encode['Vehicle'] = encode['Entity'];
	encode['Weapon']  = encode['Entity'];
	encode['NPC']     = encode['Entity'];
	encode['NextBot'] = encode['Entity'];
	encode['PhysObj'] = encode['Entity'];

	encode['nil'] = function()
		output[ #output + 1 ] = '?';
	end
	encode.__index = function( key )
		ErrorNoHalt('Type: '..key..' can not be encoded. Encoded as as pass-over value.');
		return encode['nil'];
	end

	do
		local empty, concat = table.Empty, table.concat ;
		function pon.encode( tbl )
			local output = {};
			cacheSize = 0;
			encode[ 'table' ]( encode, tbl, output, {} );
			local res = concat( output );

			return res;
		end
	end
end

do
	local tonumber = tonumber ;
	local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode ;
	local Vector, Angle, Entity = Vector, Angle, Entity ;

	local decode = {};
	decode['{'] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tv = sub( str, index, index );
			if( not tv or tv == '~' )then
				index = index + 1;
				break ;
			end
			if( tv == '}' )then
				return index + 1, cur;
			end

			-- READ THE VALUE
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );
			cur[ k ] = v;

			k = k + 1;
		end

		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY

			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end
	decode['['] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY
			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );
			if not k then continue end

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			if not self[tv] then
				print('did not find type: '..tv)
			end
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end

	-- STRING
	decode['"'] = function( self, index, str, cache )
		local finish = find( str, '";', index, true );
		local res = gsub( sub( str, index, finish - 1 ), '\\;', ';' );
		index = finish + 2;

		cache[ #cache + 1 ] = res;
		return index, res;
	end
	-- STRING NO ESCAPING NEEDED
	decode['\''] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local res = sub( str, index, finish - 1 )
		index = finish + 1;

		cache[ #cache + 1 ] = res;
		return index, res;
	end

	-- NUMBER
	decode['n'] = function( self, index, str, cache )
		index = index - 1;
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, num;
	end
	decode['0'] = decode['n'];
	decode['1'] = decode['n'];
	decode['2'] = decode['n'];
	decode['3'] = decode['n'];
	decode['4'] = decode['n'];
	decode['5'] = decode['n'];
	decode['6'] = decode['n'];
	decode['7'] = decode['n'];
	decode['8'] = decode['n'];
	decode['9'] = decode['n'];
	decode['-'] = decode['n'];
	-- positive hex
	decode['X'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end
	-- negative hex
	decode['x'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = -tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end

	-- POINTER
	decode['('] = function( self, index, str, cache )
		local finish = find( str, ')', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, cache[ num ];
	end

	-- BOOLEAN. ONE DATA TYPE FOR YES, ANOTHER FOR NO.
	decode[ 't' ] = function( self, index )
		return index, true;
	end
	decode[ 'f' ] = function( self, index )
		return index, false;
	end

	-- VECTOR
	decode[ 'v' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local vecStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', vecStr, false );
		return index, Vector( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ANGLE
	decode[ 'a' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local angStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', angStr, false );
		return index, Angle( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ENTITY
	decode[ 'E' ] = function( self, index, str, cache )
		if( str[index] == '#' )then
			index = index + 1;
			return index, NULL ;
		else
			local finish = find( str, ';', index, true );
			local num = tonumber( sub( str, index, finish - 1 ) );
			index = finish + 1;
			return index, Entity( num );
		end
	end
	-- PLAYER
	decode[ 'P' ] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, Entity( num ) or NULL;
	end
	-- NIL
	decode['?'] = function( self, index, str, cache )
		return index + 1, nil;
	end


	function pon.decode( data )
		local _, res = decode[sub(data,1,1)]( decode, 2, data, {});
		return res;
	end
end

return pon
--lua/autorun/p1clone_arms.lua:
list.Set( "PlayerOptionsModel", "Phase 1 Clone Trooper", "models/aussiwozzi/phase1clones/trooper.mdl" )
player_manager.AddValidModel( "Phase 1 Clone Trooper", "models/aussiwozzi/phase1clones/trooper.mdl" )
player_manager.AddValidHands( "Phase 1 Clone Trooper", "models/aussiwozzi/phase1clones/trooper_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 1 Clone Sergeant", "models/aussiwozzi/phase1clones/sergeant.mdl" )
player_manager.AddValidModel( "Phase 1 Clone Sergeant", "models/aussiwozzi/phase1clones/sergeant.mdl" )
player_manager.AddValidHands( "Phase 1 Clone Sergeant", "models/aussiwozzi/phase1clones/sergeant_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 1 Clone Lieutenant", "models/aussiwozzi/phase1clones/lieutenant.mdl" )
player_manager.AddValidModel( "Phase 1 Clone Lieutenant", "models/aussiwozzi/phase1clones/lieutenant.mdl" )
player_manager.AddValidHands( "Phase 1 Clone Lieutenant", "models/aussiwozzi/phase1clones/lieutenant_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 1 Clone Captain", "models/aussiwozzi/phase1clones/Captain.mdl" )
player_manager.AddValidModel( "Phase 1 Clone Captain", "models/aussiwozzi/phase1clones/Captain.mdl" )
player_manager.AddValidHands( "Phase 1 Clone Captain", "models/aussiwozzi/phase1clones/Captain_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 1 Clone Commander", "models/aussiwozzi/phase1clones/Commander.mdl" )
player_manager.AddValidModel( "Phase 1 Clone Commander", "models/aussiwozzi/phase1clones/Commander.mdl" )
player_manager.AddValidHands( "Phase 1 Clone Commander", "models/aussiwozzi/phase1clones/pilot_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 1 ARC Sergeant", "models/aussiwozzi/phase1clones/sergeant_arc.mdl" )
player_manager.AddValidModel( "Phase 1 ARC Sergeant", "models/aussiwozzi/phase1clones/sergeant_arc.mdl" )
player_manager.AddValidHands( "Phase 1 ARC Sergeant", "models/aussiwozzi/phase1clones/sergeant_arc_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 1 ARC Lieutenant", "models/aussiwozzi/phase1clones/lieutenant_arc.mdl" )
player_manager.AddValidModel( "Phase 1 ARC Lieutenant", "models/aussiwozzi/phase1clones/lieutenant_arc.mdl" )
player_manager.AddValidHands( "Phase 1 ARC Lieutenant", "models/aussiwozzi/phase1clones/lieutenant_arc_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 1 ARC Captain", "models/aussiwozzi/phase1clones/Captain_arc.mdl" )
player_manager.AddValidModel( "Phase 1 ARC Captain", "models/aussiwozzi/phase1clones/Captain_arc.mdl" )
player_manager.AddValidHands( "Phase 1 ARC Captain", "models/aussiwozzi/phase1clones/Captain_arc_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 1 ARC Commander", "models/aussiwozzi/phase1clones/Commander_arc.mdl" )
player_manager.AddValidModel( "Phase 1 ARC Commander", "models/aussiwozzi/phase1clones/Commander_arc.mdl" )
player_manager.AddValidHands( "Phase 1 ARC Commander", "models/aussiwozzi/phase1clones/Commander_arc_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 1 ARC Trooper", "models/aussiwozzi/phase1clones/trooper_arc.mdl" )
player_manager.AddValidModel( "Phase 1 ARC Trooper", "models/aussiwozzi/phase1clones/trooper_arc.mdl" )
player_manager.AddValidHands( "Phase 1 ARC Trooper", "models/aussiwozzi/phase1clones/trooper_arc_arms.mdl",0,"10000000" )

list.Set( "PlayerOptionsModel", "Phase 1 Pilot", "models/aussiwozzi/phase1clones/pilot.mdl" )
player_manager.AddValidModel( "Phase 1 Pilot", "models/aussiwozzi/phase1clones/pilot.mdl" )
player_manager.AddValidHands( "Phase 1 Pilot", "models/aussiwozzi/phase1clones/pilot_arms.mdl",0,"10000000" )
--addons/gm_prone/lua/autorun/prone_init.lua:
-- Copyright 2020, George "Stalker" Petrou. Enjoy!

--[[	DOCUMENTATION
prone.Version
	- Version of Prone Mod in YearMonthDay form.

COMMANDS:
	prone
		- Client
		- Enters or exits prone.
	prone_config
		- Client
		- Opens a little config menu for your prone keys.

HOOKS:
	prone.Initialized
		- Shared
		- Called after the Prone Mod has finished loading.
	prone.ShouldChangeCalcView
		- Client
		- Should the Prone Mod handle the transition of the player's view down/up from prone.
		- Arg One:	Local player.
		- Return:	Boolean. False to disable, anything else to enable.
	prone.ShouldChangeCalcViewModelView
		- Client
		- Same as prone.ShouldChangeCalcView but for their view model.

	Note:	These hooks are called on the server and client entering prone
			They are also predicted:
	
	prone.OnPlayerEntered
		- Called when a player is getting down to go prone.
		- Arg One:	Player entering prone.
		- Arg Two:	The length of their get down animation.
	prone.OnPlayerExitted
		- Called when a player just completely exitted prone.
		- Arg One:	The player that exitted prone.
	prone.CanEnter
		- Called to see if a player can enter prone.
		- Arg One:	The player that wants to go prone.
		- Return:	A boolean determining if they can enter prone or not.
	prone.CanExit
		- Called to see if a player can exit prone.
		- Arg One:	The player that wants to exit prone.
		- Return:	A boolean determining if they can exit prone or not.
		
FUNCTIONS:
	Note: None of these functions exist till after the initialize hook is called.
	
	PLAYER:IsProne()
		- Shared
		- Returns true if the player is prone.
	PLAYER:GetProneAnimationState()
		- Shared
		- Returns one of the PRONE_ enums mentionned below.
	prone.Handle(Player)
		- Shared
		- If the player is prone this will make them end, otherwise it will make them enter prone.
		- For prediction try to call this shared if you can.
	prone.Enter(Player)
		- Shared
		- Will make the player go prone, doesn't check to see if they should or if they are already in prone.
		- You should probably check with ply:IsProne() and prone.CanEnter(Player) before using this function.
		- For prediction try to call this shared if you can.
	prone.End(Player)
		- Shared
		- Will make the given player exit prone, doesn't check to see if they should or if they are already out of prone.
		- You should probably check with ply:IsProne() and prone.CanExit(Player) before using this function.
		- For prediction try to call this shared if you can.
	prone.Exit(Player)
		- Shared
		- Will make the player immediately exit prone, skipping the get up animation. Doesn't check to see if a player is already prone.
	prone.Request()
		- Client
		- Will ask the server to exit prone if they are prone or to enter prone if they aren't.
	RunConsoleCommand("prone_config")
		- Client
		- Will open up the in-game prone configuration menu.

	Note: These functions below MUST be called in or after the prone.Initialzed hook has been called.
	prone.AddNewHoldTypeAnimation(holdtype, movingSequenceName, idleSequenceName)
		- Shared
		- Registers a new hold type animation. Requires a sequence name for the moving animation and idle animation for that holdtype.
		- Can be used to override pre-existing holdtypes. Must be called shared.
	prone.GetIdleAnimation(holdtype)
		- Shared
		- Returns the name of the sequence corresponding the idle stance of the given holdtype.
	prone.GetMovingAnimation(holdtype)
		- Shared
		- Returns the name of the sequence corresponding the moving stance of the given holdtype.

ENUMERATIONS:
	PRONE_GETTINGDOWN	= 0
		-- Prone state. Set when the player is getting down into prone.
	PRONE_INPRONE		= 1
		-- Prone state. Set when the player is down in prone.
	PRONE_GETTINGUP		= 2
		-- Prone state. Set when the player is getting up.
	PRONE_NOTINPRONE	= 3
		-- Prone state. Set when a player is not prone.
	PRONE_IMPULSE		= 217
		-- Sent to server from client using CUserCmd:SetImpulse() to signify the user wanting to go prone.
	PRONE_CUSTOM_ANIM_EVENT_NUM		= 69420
		-- Passed as a data arg with Player:DoCustomAnimEvent() to be used in the GM:DoAnimationEvent hook.

CONVARS:
	prone_movespeed
		-- Server (replicated and archived)
		-- Number, speed of moving while prone.
	prone_bindkey_enabled
		-- Client (archived)
		-- Boolean (1 or 0), should a bind key be pressed to enter prone, or just the "prone" command.
	prone_bindkey_key
		-- Client (archived)
		-- Number, representing a KEY enum, for what the bind key should be.
	prone_bindkey_doubletap
		-- Client (archived)
		-- Boolean, should we have to double press the bind key to go prone.
	prone_jumptogetup
		-- Client (archived)
		-- Boolean, should the jump key toggle prone.
	prone_jumptogetup_doubletap
		-- Client (archived)
		-- Boolean, if prone_jumptogetup is enabled, should we have to double tap it.
	prone_disabletransitions
		-- Client (archived)
		-- Boolean, should we disable view transitions when entering and exitting prone.
]]

----------------------------------------------------------------
-- Initialization
----------------------------------------------------------------
prone = prone or {}
prone.Config = prone.Config or {}
prone.Animations = prone.Animations or {}

-- YearMonthDay
prone.Version = 20200711

-- States
PRONE_GETTINGDOWN	= 0
PRONE_INPRONE		= 1
PRONE_GETTINGUP		= 2
PRONE_NOTINPRONE	= 3

-- The impulse number to be used for toggling prone.
-- If anybody steals my number there will be hell to pay.
PRONE_IMPULSE = 127

-- This number is passed as the "data" arg to ply:DoCustomAnimEvent().
-- Again, steal this number and there will be hell to pay.
PRONE_CUSTOM_ANIM_EVENT_NUM = 69420

if SERVER then
	-- https://steamcommunity.com/sharedfiles/filedetails/?id=1100368137
	--resource.AddWorkshop("1100368137")
end

hook.Add("Initialize", "prone.Initialize", function()
	-- Send files
	if SERVER then
		AddCSLuaFile("prone/class_prone_statedata.lua")
		AddCSLuaFile("prone/config.lua")
		AddCSLuaFile("prone/sh_prone.lua")
		AddCSLuaFile("prone/sh_thirdparty_compat.lua")
		AddCSLuaFile("prone/cl_prone.lua")
	end

	-- Load files (in order)
	include("prone/class_prone_statedata.lua")
	include("prone/config.lua")
	include("prone/sh_prone.lua")
	include("prone/sh_thirdparty_compat.lua")
	if SERVER then
		include("prone/sv_prone.lua")
	else
		include("prone/cl_prone.lua")
	end

	print("Initialized The Prone Mod, by Stalker and Stiffy360")
	hook.Call("prone.Initialized")
end)


----------------------------------------------------------------
-- Pre-Library
---------------
-- Collection of small functions used throughout the addon.
----------------------------------------------------------------

---------------------
-- prone.WritePlayer
---------------------
-- Desc:		Writes a player entity via the net library.
-- Arg One:		Player, to write.
function prone.WritePlayer(ply)
	if IsValid(ply) then
		net.WriteUInt(ply:EntIndex(), 7)
	else
		net.WriteUInt(0, 7)
	end
end

--------------------
-- prone.ReadPlayer
--------------------
-- Desc:		Reads a player entity via the net library.
-- Arg One:		Player, to read.
function prone.ReadPlayer()
	local i = net.ReadUInt(7)
	if not i then
		return
	end
	return Entity(i)
end


--[[ 
if SERVER then
	resource.AddWorkshop("1100368137")
end ]]
--addons/admin_sam/lua/sam/libs/sh_mp.lua:
if SAM_LOADED then return end

local sam = sam
local mp = sam.load_file("sam/libs/message_pack/sh_messagepack.lua")
local EXT_VECTOR  = 1
local EXT_ANGLE   = 2
local EXT_ENTITY  = 3
local EXT_PLAYER  = 4
local EXT_COLOR   = 5
local EXT_CONSOLE = 6

mp.packers["Entity"] = function(buffer, ent)
	local buf = {}
	mp.packers["number"](buf, ent:EntIndex())
	mp.packers["ext"](buffer, EXT_ENTITY, buf[1])
end
mp.packers["Vehicle"] = mp.packers["Entity"]
mp.packers["Weapon"] = mp.packers["Entity"]
mp.packers["NPC"] = mp.packers["Entity"]
mp.packers["NextBot"] = mp.packers["Entity"]
mp.packers["PhysObj"] = mp.packers["Entity"]

mp.packers["Player"] = function(buffer, ply)
	local buf = {}
	mp.packers["number"](buf, ply:UserID())
	mp.packers["ext"](buffer, EXT_PLAYER, buf[1])
end

local VECTOR = {}
mp.packers["Vector"] = function(buffer, vec)
	VECTOR[1] = vec.x
	VECTOR[2] = vec.y
	VECTOR[3] = vec.z

	local buf = {}
	mp.packers["_table"](buf, VECTOR)
	mp.packers["ext"](buffer, EXT_VECTOR, table.concat(buf))
end

local ANGLE = {}
mp.packers["Angle"] = function(buffer, ang)
	ANGLE[1] = ang.p
	ANGLE[2] = ang.y
	ANGLE[3] = ang.r

	local buf = {}
	mp.packers["_table"](buf, ANGLE)
	mp.packers["ext"](buffer, EXT_ANGLE, table.concat(buf))
end

local COLOR = {}
mp.packers["Color"] = function(buffer, col)
	COLOR[1] = col.r
	COLOR[2] = col.g
	COLOR[3] = col.b
	COLOR[4] = col.a

	local buf = {}
	mp.packers["_table"](buf, COLOR)
	mp.packers["ext"](buffer, EXT_COLOR, table.concat(buf))
end

mp.packers["console"] = function(buffer)
	mp.packers["ext"](buffer, EXT_CONSOLE, "")
end

local Entity = Entity
local Player = Player
local Color = Color
local Vector = Vector
local Angle = Angle
local unpackers = {
	[EXT_ENTITY] = function(v)
		return Entity(v)
	end,
	[EXT_PLAYER] = function(v)
		return Player(v)
	end,
	[EXT_VECTOR] = function(v)
		return Vector(v[1], v[2], v[3])
	end,
	[EXT_ANGLE] = function(v)
		return Angle(v[1], v[2], v[3])
	end,
	[EXT_COLOR] = function(v)
		return Color(v[1], v[2], v[3], v[4])
	end,
	[EXT_CONSOLE] = function(v)
		return sam.console
	end
}

mp.build_ext = function(tag, data)
	local f = mp.unpacker(data)
	local _, v = f()
	return unpackers[tag](v)
end

sam.mp = mp

--addons/admin_sam/lua/sam/libs/sh_async_netstream.lua:
if SAM_LOADED then return end

local netstream = sam.netstream
netstream.async = {}

if SERVER then
	local IsValid = IsValid
	function netstream.async.Hook(name, fn, check)
		netstream.Hook(name, function(ply, i, ...)
			if not sam.isnumber(i) then return end
			local res = function(...)
				if IsValid(ply) then
					netstream.Start(ply, name, i, ...)
				end
			end
			fn(res, ply, ...)
		end, check)
	end
else
	local count = 0
	local receivers = {}

	local hook_fn = function(i, ...)
		local receiver = receivers[i]
		if receiver[2] then
			receiver[2]()
		end
		receiver[1]:resolve(...)
		receivers[i] = nil
	end

	function netstream.async.Start(name, func_to_call, ...)
		local promise = sam.Promise.new()
		count = count + 1
		receivers[count] = {promise, func_to_call}
		netstream.Hook(name, hook_fn)
		if func_to_call then
			func_to_call()
		end
		netstream.Start(name, count, ...)
		return promise
	end
end
--addons/admin_sam/lua/sam/command/sh_command.lua:
if SAM_LOADED then return end

local sam = sam
local istable, isstring = sam.istable, sam.isstring

local commands = {}
local arguments = {}

do
	local command = {}

	local current_category = "other"
	function command.set_category(category)
		if isstring(category) then
			current_category = category
		end
	end

	function command.get_commands()
		return commands
	end

	function command.get_command(name)
		for i = 1, #commands do
			local cmd = commands[i]
			if cmd.name == name then
				return cmd, i
			end

			local aliases = cmd.aliases
			for i2 = 1, #aliases do
				local alias = aliases[i2]
				if alias == name then
					return cmd, i
				end
			end
		end
		return false
	end

	function command.remove_command(name)
		local cmd, index = command.get_command(name)
		if index then
			table.remove(commands, index)
			hook.Call("SAM.CommandRemoved", nil, cmd.name, cmd, index)
			return index
		end
		return false
	end

	function command.get_arguments()
		return arguments
	end

	do
		local argument_methods = {
			OnExecute = function(self, func)
				if isfunction(func) and SERVER then
					self.on_execute = func
				end
				return self
			end,
			Menu = function(self, func)
				if isfunction(func) and CLIENT then
					self.menu = func
				end
				return self
			end,
			AutoComplete = function(self, func)
				if isfunction(func) and CLIENT then
					self.auto_complete = func
				end
				return self
			end,
			End = function(self)
				if SERVER then
					arguments[self.name] = self.on_execute
				else
					arguments[self.name] = self
				end
			end
		}

		local argument_meta = {__index = argument_methods}
		function command.new_argument(name)
			if isstring(name) then
				return setmetatable({name = name}, argument_meta)
			end
		end
	end

	if CLIENT then
		function command.run_commands(to_run)
			local time = 0
			for i = 1, #to_run do
				timer.Simple(time, function()
					RunConsoleCommand("sam", unpack(to_run[i]))
				end)
				time = time + 0.76
			end
		end
	end

	--
	-- Methods
	--
	local Command_Methods = {}
	local Command_meta = {__index = Command_Methods}

	function command.new(cmd)
		if not isstring(cmd) then return end

		local new_command = setmetatable({}, Command_meta)
		new_command.can_console_run = true
		new_command.args = {}
		new_command.name = cmd:lower()
		new_command.aliases = {}
		new_command.category = current_category

		return new_command
	end

	local AddMethod = function(name, func)
		Command_Methods[name] = func
	end

	AddMethod("Aliases", function(self, ...)
		for k, v in ipairs({...}) do
			table.insert(self.aliases, v)
		end
		return self
	end)

	AddMethod("AddArg", function(self, name, data)
		if not isstring(name) then return end
		if not istable(data) then
			data = {}
		end
		data.name = name
		table.insert(self.args, data)
		return self
	end)

	AddMethod("DisallowConsole", function(self, disallow)
		self.can_console_run = isbool(disallow) and disallow or false
		return self
	end)

	AddMethod("SetCategory", function(self, category)
		if isstring(category) then
			self.category = category
		end
		return self
	end)

	AddMethod("Help", function(self, help)
		if isstring(help) then
			self.help = sam.language.get(help) or help
		end
		return self
	end)

	AddMethod("OnExecute", function(self, func)
		if isfunction(func) and SERVER then
			self.on_execute = func
		end
		return self
	end)

	AddMethod("SetPermission", function(self, perm, default_rank)
		if isstring(perm) then
			self.permission = perm
			self.default_rank = default_rank
		end
		return self
	end)

	AddMethod("GetRestArgs", function(self, get)
		if not isbool(get) then
			get = true
		end
		self.get_rest_args = get
		return self
	end)

	AddMethod("MenuHide", function(self, should_hide)
		if isbool(should_hide) then
			self.menu_hide = should_hide
		else
			self.menu_hide = true
		end
		return self
	end)

	AddMethod("DisableNotify", function(self, disable)
		if isbool(disable) then
			self.disable_notify = disable
		else
			self.disable_notify = true
		end
		return self
	end)

	AddMethod("End", function(self)
		local name = self.name
		if SERVER and not self.on_execute then
			sam.print("need an OnExecute function for the command!")
			debug.Trace()
			return
		end

		if self.permission then
			sam.permissions.add(self.permission, "Commands - " .. self.category, self.default_rank)
		end

		local _, index = command.get_command(name)
		if index then
			commands[index] = self
			hook.Call("SAM.CommandModified", nil, name, self, index)
		else
			hook.Call("SAM.CommandAdded", nil, name, self, table.insert(commands, self))
		end
	end)

	AddMethod("GetRequiredArgs", function(self)
		local required_args = {}
		local args = self.args
		for i = 1, #args do
			local v = args[i]
			if not v.optional then
				table.insert(required_args, v)
			end
		end
		return required_args
	end)

	AddMethod("GetOptionalArgs", function(self)
		local optional_args = {}
		local args = self.args
		for i = 1, #args do
			local v = args[i]
			if v.optional then
				table.insert(optional_args, v)
			end
		end
		return optional_args
	end)

	AddMethod("ArgsToString", function(self, return_table)
		local str_table = {}
		local args = self.args
		for i = 1, #self.args do
			local v = args[i]
			if not v.optional then
				table.insert(str_table, "<" .. (v.hint or v.name) .. ">")
			else
				table.insert(str_table, "[" .. (v.hint or v.name) .. "]")
			end
		end
		return return_table and str_table or table.concat(str_table, " ")
	end)

	AddMethod("HasArg", function(self, arg)
		local args = self.args
		for i = 1, #self.args do
			if args[i].name == arg then
				return true
			end
		end
		return false
	end)

	command.add_method = AddMethod

	sam.command = command
end

sam.__commands = commands
sam.__arguments = arguments
--addons/admin_sam/lua/sam/command/arguments/steamid.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

local cached_ranks = {}
local targeting_offline = {}

local check_steamid = function(steamid)
	if not sam.is_steamid(steamid) then
		if sam.is_steamid64(steamid) then
			return util.SteamIDFrom64(steamid)
		else
			return nil
		end
	end

	return steamid
end

local can_target_steamid_callback = function(data, promise)
	local ply, steamid = promise.ply, promise.steamid

	if not data or sam.ranks.can_target(promise.rank, data.rank) then
		promise:resolve({steamid})
	elseif IsValid(ply) then
		ply:sam_send_message("cant_target_player", {
			S = steamid
		})
	end

	targeting_offline[ply] = nil
	cached_ranks[steamid] = data ~= nil and data or false
end

command.new_argument("steamid")
	:OnExecute(function(argument, input, ply, _, result, i)
		local steamid = check_steamid(input)
		if not steamid then
			ply:sam_send_message("invalid", {
				S = "steamid/steamid64", S_2 = input
			})
			return false
		end

		if argument.allow_higher_target then
			result[i] = steamid
			return
		end

		local promise = sam.Promise.new()
		promise.ply = ply
		promise.rank = ply:GetUserGroup()
		promise.steamid = steamid

		local target = player.GetBySteamID(steamid)
		if sam.isconsole(ply) then
			promise:resolve({steamid})
		elseif target then
			if ply:CanTarget(target) then
				promise:resolve({steamid, target})
			else
				ply:sam_send_message("cant_target_player", {
					S = steamid
				})
			end
		elseif cached_ranks[steamid] ~= nil then
			can_target_steamid_callback(cached_ranks[steamid], promise)
		else
			targeting_offline[ply] = true

			sam.SQL.FQuery([[
				SELECT
					`rank`
				FROM
					`sam_players`
				WHERE
					`steamid` = {1}
			]], {steamid}, can_target_steamid_callback, true, promise)
		end

		result[i] = promise
	end)
	:Menu(function(set_result, body, buttons, argument)
		local steamid_entry = buttons:Add("SAM.TextEntry")
		steamid_entry:SetTall(25)
		steamid_entry:SetUpdateOnType(true)
		steamid_entry:SetPlaceholder("steamid/steamid64")

		steamid_entry:SetCheck(function(steamid)
			steamid = check_steamid(steamid)
			set_result(steamid)
			return steamid or false
		end)

		return steamid_entry
	end)
:End()

timer.Create("SAM.ClearCachedRanks", 60 * 2.5, 0, function()
	table.Empty(cached_ranks)
end)

hook.Add("SAM.ChangedSteamIDRank", "RemoveIfCached", function(steamid)
	cached_ranks[steamid] = nil
end)

hook.Add("SAM.CanRunCommand", "StopIfTargetingOffline", function(ply)
	if targeting_offline[ply] then
		return false
	end
end)

--addons/admin_sam_sui/lua/sui/libs/gif_loader.lua:
local byte = string.byte
local sub = string.sub
local lshift = bit.lshift
local rshift = bit.rshift
local bor = bit.bor
local band = bit.band

local GIFDecoder = {}
local GIFDecoderMethods = {}
local GIFDecoder_meta = {__index = GIFDecoderMethods}

function GIFDecoder.new(buf)
	local buf_n = #buf
	local this = setmetatable({
		p = 1,
		buf = buf
	}, GIFDecoder_meta)

	local version = this:read(6)
	assert(version == "GIF89a" or version == "GIF87a", "wrong file format")

	this.width = this:word()
	this.height = this:word()

	local pf0 = this:byte()
	local global_palette_flag = rshift(pf0, 7)
	local num_global_colors_pow2 = band(pf0, 0x7)
	local num_global_colors = lshift(1, num_global_colors_pow2 + 1)
	this:skip(2)

	local global_palette_offset = nil
	local global_palette_size = nil

	if global_palette_flag > 0 then
		global_palette_offset = this.p
		this.global_palette_offset = global_palette_offset
		global_palette_size = num_global_colors
		this:skip(num_global_colors * 3)
	end

	local no_eof = true

	local frames = {}

	local delay = 0
	local transparent_index = nil
	local disposal = 1

	while no_eof and this.p <= buf_n do
		local b = this:byte()
		if b == 0x3b then
			no_eof = false
		elseif b == 0x2c then
			local x, y, w, h = this:word(), this:word(), this:word(), this:word()
			local pf2 = this:byte()
			local local_palette_flag = rshift(pf2, 7)
			local interlace_flag = band(rshift(pf2, 6), 1)
			local num_local_colors_pow2 = band(pf2, 0x7)
			local num_local_colors = lshift(1, num_local_colors_pow2 + 1)
			local palette_offset = global_palette_offset
			local palette_size = global_palette_size
			local has_local_palette = false
			if local_palette_flag ~= 0 then
				has_local_palette = true
				palette_offset = this.p
				palette_size = num_local_colors
				this:skip(num_local_colors * 3)
			end

			local data_offset = this.p

			this:skip(1)
			this:skip_eob()

			table.insert(frames, {
				x = x,
				y = y,
				width = w,
				height = h,
				has_local_palette = has_local_palette,
				palette_offset = palette_offset,
				palette_size = palette_size,
				data_offset = data_offset,
				data_length = this.p - data_offset,
				transparent_index = transparent_index,
				interlaced = interlace_flag > 0,
				delay = delay,
				disposal = disposal
			})
		elseif b == 0x21 then
			local b2 = this:byte()
			if b2 == 0xf9 then
				local len, flags = this:bytes(2)
				delay = this:word()
				local transparent, terminator = this:bytes(2)

				assert(len == 4 and terminator == 0, "Invalid graphics extension block.")

				if flags % 2 == 1 then
					transparent_index = transparent
				else
					transparent_index = nil
				end

				disposal = math.floor(flags / 4) % 8
			elseif b2 == 0xff then
				this:read(this:byte())
				this:skip_eob()
			else
				this:skip_eob()
			end
		end
	end

	this.frames = frames

	return this
end

function GIFDecoderMethods:skip(offset)
	self.p = self.p + offset
end

-- skip to end of block
function GIFDecoderMethods:skip_eob()
	repeat
		local size = self:byte()
		self:skip(size)
	until size == 0
end

function GIFDecoderMethods:byte()
	local b = byte(self.buf, self.p)
	self:skip(1)
	return b
end

function GIFDecoderMethods:bytes(len)
	local _p = self.p
	self:skip(len)
	return byte(self.buf, _p, len + _p - 1)
end

function GIFDecoderMethods:read(len)
	local _p = self.p
	self:skip(len)
	return sub(self.buf, _p, len + _p - 1)
end

function GIFDecoderMethods:word()
	return bor(self:byte(), lshift(self:byte(), 8))
end

local GifReaderLZWOutputIndexStream = function(this, output, output_length)
	local min_code_size = this:byte()
	local clear_code = lshift(1, min_code_size)
	local eoi_code = clear_code + 1
	local next_code = eoi_code + 1
	local cur_code_size = min_code_size + 1

	local code_mask = lshift(1, cur_code_size) - 1
	local cur_shift = 0
	local cur = 0
	local op = 0

	local subblock_size = this:byte()

	local code_table = {}

	local prev_code = nil

	while true do
		while cur_shift < 16 do
			if subblock_size == 0 then break end

			cur = bor(cur, lshift(this:byte(), cur_shift))
			cur_shift = cur_shift + 8

			if subblock_size == 1 then
				subblock_size = this:byte()
			else
				subblock_size = subblock_size - 1
			end
		end

		if cur_shift < cur_code_size then break end

		local code = band(cur, code_mask)
		cur = rshift(cur, cur_code_size)
		cur_shift = cur_shift - cur_code_size

		if code == clear_code then
			next_code = eoi_code + 1
			cur_code_size = min_code_size + 1
			code_mask = lshift(1, cur_code_size) - 1

			prev_code = null
			continue
		elseif code == eoi_code then
			break
		end

		local chase_code = code < next_code and code or prev_code
		local chase_length = 0
		local chase = chase_code
		while chase > clear_code do
			chase = rshift(code_table[chase], 8)
			chase_length = chase_length + 1
		end

		local k = chase
		local op_end = op + chase_length + (chase_code ~= code and 1 or 0)
		if op_end > output_length then
			Error("Warning, gif stream longer than expected.")
			return
		end

		output[op] = k; op = op + 1
		op = op + chase_length

		local b = op

		if chase_code ~= code then
			output[op] = k; op = op + 1
		end
		chase = chase_code

		while chase_length > 0 do
			chase_length = chase_length - 1
			chase = code_table[chase]
			b = b - 1
			output[b] = band(chase, 0xff)

			chase = rshift(chase, 8)
		end

		if prev_code ~= nil and next_code < 4096 then
			code_table[next_code] = bor(lshift(prev_code, 8), k)
			next_code = next_code + 1

			if next_code >= code_mask + 1 and cur_code_size < 12 then
				cur_code_size = cur_code_size + 1
				code_mask = bor(lshift(code_mask, 1), 1)
			end
		end

		prev_code = code
	end

	if op ~= output_length then
		Error("Warning, gif stream shorter than expected.")
	end

	return output
end

function GIFDecoderMethods:decode_and_blit_frame_RGBA(frame_num, pixels)
	local frame = self.frames[frame_num]
	local num_pixels = frame.width * frame.height
	local index_stream = {}

	self.p = frame.data_offset
	GifReaderLZWOutputIndexStream(self, index_stream, num_pixels)
	local palette_offset = frame.palette_offset

	local trans = frame.transparent_index
	if trans == nil then
		trans = 256
	end

	local width = self.width
	local framewidth = frame.width
	local framestride = width - framewidth
	local xleft = framewidth

	local opbeg = (frame.y * width + frame.x) * 4

	local opend = ((frame.y + frame.height) * width + frame.x) * 4
	local op = opbeg
	local scanstride = framestride * 4

	if frame.interlaced == true then
		scanstride = scanstride + (width * 4 * 7)
	end

	local interlaceskip = 8

	local i = 0
	local buf = self.buf
	while i < num_pixels do
		local index = index_stream[i]

		if xleft == 0 then
			op = op + scanstride
			xleft = framewidth

			if op >= opend then
				scanstride =
					framestride * 4 + width * 4 * (interlaceskip - 1)

				op =
					opbeg +
					(framewidth + framestride) * lshift(interlaceskip, 1)
				interlaceskip = rshift(interlaceskip, 1)
			end
		end

		if index ~= trans then
			index = palette_offset + index * 3
			pixels[op + 0] = byte(buf, index)
			pixels[op + 1] = byte(buf, index + 1)
			pixels[op + 2] = byte(buf, index + 2)
			pixels[op + 3] = 255
		end

		op = op + 4

		xleft = xleft - 1
		i = i + 1
	end
end

function GIFDecoderMethods:clear_frame(frame_num, pixels)
	local frame = self.frames[frame_num]

	self.p = frame.data_offset

	local width = self.width
	local framewidth = frame.width
	local framestride = width - framewidth
	local xleft = framewidth

	local opbeg = (frame.y * width + frame.x) * 4

	local opend = ((frame.y + frame.height) * width + frame.x) * 4
	local op = opbeg
	local scanstride = framestride * 4

	if frame.interlaced == true then
		scanstride = scanstride + (width * 4 * 7)
	end

	local interlaceskip = 8

	local i = 0
	local num_pixels = frame.width * frame.height
	while i < num_pixels do
		if xleft == 0 then
			op = op + scanstride
			xleft = framewidth

			if op >= opend then
				scanstride =
					framestride * 4 + width * 4 * (interlaceskip - 1)

				op =
					opbeg +
					(framewidth + framestride) * lshift(interlaceskip, 1)
				interlaceskip = rshift(interlaceskip, 1)
			end
		end

		pixels[op + 0] = 0
		pixels[op + 1] = 0
		pixels[op + 2] = 0
		pixels[op + 3] = 0
		op = op + 4

		xleft = xleft - 1
		i = i + 1
	end
end

function GIFDecoderMethods:get_frames()
	local num_pixels = self.width * self.height * 4 + 4
	local frames = {}
	local numFrames = #self.frames
	local last_frame
	local restore_from
	for i = 1, numFrames do
		local frame = self.frames[i]

		local data = {}

		if last_frame then
			local _data = last_frame.data
			for k = 0, num_pixels do
				data[k] = _data[k]
			end
		end

		if i > 1 then
			local last_disposal = last_frame.disposal
			if last_disposal == 3 then
				if restore_from then
					for k = 0, num_pixels do
						data[k] = restore_from[k]
					end
				else
					self:clear_frame(i - 1, data)
				end
			end

			if last_disposal == 2 then
				self:clear_frame(i - 1, data)
			end
		end

		self:decode_and_blit_frame_RGBA(i, data)

		local delay = frame.delay
		if delay < 2 then
			delay = 10
		end

		local disposal = frame.disposal
		last_frame = {
			data = data,
			delay = delay,
			disposal = disposal
		}
		frames[i] = last_frame

		if disposal ~= 3 then
			restore_from = data
		end
	end

	return frames
end

return GIFDecoder.new
--addons/admin_sam_sui/lua/sui/vgui/sui_text_entry.lua:
local sui = sui

local surface = surface
local utf8 = sui.utf8
local draw = draw
local math = math

local IsValid = IsValid
local tostring = tostring
local tonumber = tonumber

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor
local TEXT_ENTRY_FONT = SUI.CreateFont("TextEntry", "Roboto Regular", 16)

local Panel = {}

sui.scaling_functions(Panel)

AccessorFunc(Panel, "m_FontName", "Font", FORCE_STRING)
AccessorFunc(Panel, "m_Editable", "Editable", FORCE_BOOL)
AccessorFunc(Panel, "m_Placeholder", "Placeholder", FORCE_STRING)
AccessorFunc(Panel, "m_MaxChars", "MaxChars", FORCE_NUMBER)
AccessorFunc(Panel, "m_Numeric", "Numeric", FORCE_BOOL)
AccessorFunc(Panel, "m_NoBar", "NoBar", FORCE_BOOL)
AccessorFunc(Panel, "m_BarColor", "BarColor")
AccessorFunc(Panel, "m_Background", "Background")
AccessorFunc(Panel, "m_Radius", "Radius")
AccessorFunc(Panel, "m_NoEnter", "NoEnter")

Panel:SetRadius(3)

function Panel:Init()
	self:ScaleInit()

	self:SetupTransition("TextEntryReady", 0.9, function()
		return self:IsEditing() or self:GetBarColor() ~= nil
	end)

	self:SetUpdateOnType(true)
	self:SetCursor("beam")
	self:SetFont(TEXT_ENTRY_FONT)
	self:SetPlaceholder("Placeholder text")

	self:SetSize(200, 22)

	self.allowed_numeric_characters = "1234567890.-"

	self.history = {}
	self.history_pos = 1
	self.can_use_history = true

	self:OnScaleChange()
end

function Panel:SetCaretPos(pos)
	DTextEntry.SetCaretPos(self, math.Clamp(pos, 0, utf8.len(self:GetText())))
end

function Panel:SetValue(value)
	self:SetText(value)
	self:OnValueChange(value)
end

function Panel:AllowInput(ch)
	if self:CheckNumeric(ch) then return true end

	if sui.wspace_chs[ch] or sui.cntrl_chs[ch] then
		return true
	end

	local max_chars = self:GetMaxChars()
	if max_chars and #self:GetText() >= max_chars then
		surface.PlaySound("resource/warning.wav")
		return true
	end
end

function Panel:AddValue(v, i, j)
	local original_text = self:GetText()

	local start
	if i then
		start = original_text:sub(1, i)
	else
		start = utf8.sub(original_text, 1, self:GetCaretPos())
	end

	local text = start .. v
	local caret_pos = utf8.len(text)

	local _end
	if j then
		_end = original_text:sub(j)
	else
		_end = utf8.sub(original_text, utf8.len(start) + 1)
	end
	text = text .. _end

	local max_chars = self:GetMaxChars()
	if max_chars then
		text = text:sub(1, max_chars)
	end

	self:SetValue(text)
	self:SetCaretPos(caret_pos)
end

function Panel:OnKeyCodeTyped(code)
	if self.no_down then
		self.no_down = nil
		return
	end

	if code == KEY_UP or code == KEY_DOWN then
		if not self:UpdateFromHistory(code) then
			return true
		end

		local lines, caret_line = self:GetNumLines()

		if lines == 1 then
			return true
		end

		--
		-- this fixes a weird issue
		-- make the text entry has at least 2 lines, go up then go down, you won't be able to go up again
		--
		if code == KEY_DOWN and lines == caret_line + 1 then
			self.no_down = true
			gui.InternalKeyCodeTyped(KEY_DOWN)
		end
	end

	self:OnKeyCode(code)

	if code == KEY_ENTER then
		if IsValid(self.Menu) then
			self.Menu:Remove()
		end

		if not self:GetNoEnter() then
			self:FocusNext()
			self:OnEnter()
		end
	end
end

function Panel:DisallowFloats(disallow)
	if not isbool(disallow) then
		disallow = true
	end

	if disallow then
		self.allowed_numeric_characters = self.allowed_numeric_characters:gsub("%.", "", 1)
	elseif not self.allowed_numeric_characters:find(".", 1, true) then
		self.allowed_numeric_characters = self.allowed_numeric_characters .. "."
	end
end

function Panel:DisallowNegative(disallow)
	if not isbool(disallow) then
		disallow = true
	end

	if disallow then
		self.allowed_numeric_characters = self.allowed_numeric_characters:gsub("%-", "", 1)
	elseif not self.allowed_numeric_characters:find("-", 1, true) then
		self.allowed_numeric_characters = self.allowed_numeric_characters .. "-"
	end
end

function Panel:CheckNumeric(value)
	if not self:GetNumeric() then return false end

	if not self.allowed_numeric_characters:find(value, 1, true) then
		return true
	end

	local new_value = ""
	local current_value = tostring(self:GetText())

	local caret_pos = self:GetCaretPos()
	for i = 0, #current_value do
		new_value = new_value .. current_value:sub(i, i)
		if i == caret_pos then
			new_value = new_value .. value
		end
	end

	if #current_value ~= 0 and not tonumber(new_value) then
		return true
	end

	return false
end

function Panel:AddHistory(txt)
	if not txt or txt == "" then return end
	local history = self.history
	if history[#history] ~= txt then
		table.insert(history, txt)
	end
end

function Panel:UpdateFromHistory(code)
	if not self.can_use_history then return end

	local lines, caret_line = self:GetNumLines()

	if code == KEY_UP then
		if caret_line > 1 then return true end -- enable the caret to move up and down

		if self.history_pos <= 1 then return end

		self.history_pos = self.history_pos - 1
	elseif code == KEY_DOWN then
		if caret_line ~= lines then return true end

		if self.history_pos >= #self.history then
			self:SetValue("")
			self:SetCaretPos(0)
			self.history_pos = #self.history + 1
			return
		end

		self.history_pos = self.history_pos + 1
	end

	local text = self.history[self.history_pos]
	if not text then return end

	self:SetValue(text)
	self:SetCaretPos(utf8.len(text))
end

function Panel:OnTextChanged()
	self.history_pos = #self.history + 1

	local text = self:GetText()

	self.can_use_history = text == "" and true or false

	if self:GetUpdateOnType() then
		self:UpdateConvarValue()
		self:OnValueChange(text)
	end

	self:OnChange()
end

function Panel:OnScaleChange()
	self:InvalidateLayout()
	self:InvalidateLayout(true)
end

function Panel:Paint(w, h)
	self:RoundedBox("Background", self:GetRadius(), 0, 0, w, h, GetColor("text_entry_bg") or self:GetBackground())

	local text_entry_3 = GetColor("text_entry_3")

	if self:GetText() == "" then
		local old_text = self:GetText()
		self:SetText(self:GetPlaceholder())
		self:DrawTextEntryText(GetColor("text_entry_2"), text_entry_3, text_entry_3)
		self:SetText(old_text)
	else
		self:DrawTextEntryText(GetColor("text_entry"), text_entry_3, text_entry_3)
	end

	if not self:GetNoBar() then
		local bar_color = self:GetBarColor()

		self:RoundedBox("Bar1", 0, 0, h - 1, w, 1, GetColor("text_entry_bar_color"))

		local bar = math.Round(w * self.TextEntryReady)
		if bar > 0 then
			self:RoundedBox("Bar2", 0, (w / 2) - (bar / 2), h - 1, bar, 1, bar_color or text_entry_3)
		end
	end
end

-- https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/mp/src/vgui2/vgui_controls/TextEntry.cpp#L969
function Panel:GetNumLines(wide)
	local num_lines = 1

	wide = wide or self:GetWide() - 2

	local char_width
	local x = 3

	local word_start_index = 1
	local word_start_len
	local word_length = 0
	local has_word = false
	local just_started_new_line = true
	local word_started_on_new_line = true

	local start_char = 1

	surface.SetFont(self:GetFont())

	local i = start_char
	local text, n = utf8.force(self:GetText())
	local caret_line = 0
	local caret_pos = self:GetCaretPos()
	local caret_i = 1
	while i <= n do
		local ch_len = utf8.char_bytes(text:byte(i))
		local ch = text:sub(i, i + ch_len - 1)

		if ch ~= " " then
			if not has_word then
				word_start_index = i
				word_start_len = ch_len
				has_word = true
				word_started_on_new_line = just_started_new_line
				word_length = 0
			end
		else
			has_word = false
		end

		char_width = surface.GetTextSize(ch)
		just_started_new_line = false

		if (x + char_width) >= wide then
			x = 3

			just_started_new_line = true
			has_word = false

			if word_started_on_new_line then
				num_lines = num_lines + 1
			else
				num_lines = num_lines + 1
				i = (word_start_index + word_start_len) - ch_len
			end

			word_length = 0
		end

		x = x + char_width
		word_length = word_length + char_width

		if caret_i == caret_pos then
			caret_line = num_lines
		end

		i = i + ch_len
		caret_i = caret_i + 1
	end

	return num_lines, caret_line
end

function Panel:SetCheck(func, col)
	function self:OnValueChange(text)
		if func(text) == false then
			self.valid = false
			self:SetBarColor(GetColor("close_hover"))
			self:SetNoEnter(true)
		else
			self.valid = true
			self:SetBarColor(col)
			self:SetNoEnter(false)
		end
	end
	self:SetValue(self:GetText())
end

sui.register("TextEntry", Panel, "DTextEntry")

--addons/admin_sam_sui/lua/sui/vgui/sui_toggle_button.lua:
local Lerp = Lerp
local FrameTime = FrameTime

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

function Panel:Init()
	self:ScaleInit()

	local rounded_box = {}
	local switch_circle = {}
	function self:Paint(w, h)
		local is_checked = self:GetChecked()

		local _h = SUI.Scale(14)
		TDLib.RoundedBox(rounded_box, _h, 0, h / 2 - _h / 2, w, _h, is_checked and SUI.GetColor("toggle_button_active") or SUI.GetColor("toggle_button"))

		local size = h - 2
		do
			local pos = is_checked and (w - (size / 2)) or (h / 2 - 1)
			if self.pos then
				self.pos = Lerp(FrameTime() * 12, self.pos, pos)
			else
				self.pos = pos
			end
		end

		TDLib.DrawCircle(switch_circle, self.pos, h / 2, size / 2, is_checked and SUI.GetColor("toggle_button_switch_active") or SUI.GetColor("toggle_button_switch"))
	end

	self:SetSize(34, 20)
end

sui.register("ToggleButton", Panel, "DCheckBox")
--addons/admin_sam/lua/sam/menu/tabs/config/server.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config

config.add_tab("Server", function(parent)
	local server_body = parent:Add("SAM.ScrollPanel")
	server_body:Dock(FILL)
	server_body:LineMargin(0, 6, 0, 0)

	local i = 0
	server_body:GetCanvas():On("OnChildAdded", function(s, child)
		i = i + 1
		child:SetZPos(i)
	end)

	for k, v in ipairs(sam.config.get_menu_settings()) do
		local panel = v.func(server_body)
		if ispanel(panel) then
			local setting = server_body:Add("SAM.LabelPanel")
			setting:DockMargin(8, 6, 8, 0)
			setting:SetLabel(v.title)
			setting:SetPanel(panel)
		end

		server_body:Line()
	end

	return server_body
end, function()
	return LocalPlayer():HasPermission("manage_config")
end, 1)
--addons/admin_sam/lua/sam/modules/darkrp.lua:
if SAM_LOADED then return end

local add = not GAMEMODE and hook.Add or function(_, _, fn)
	fn()
end

add("PostGamemodeLoaded", "SAM.DarkRP", function()
	if not DarkRP then return end

	local sam, command, language = sam, sam.command, sam.language

	command.set_category("DarkRP")

	command.new("arrest")
		:SetPermission("arrest", "superadmin")

		:AddArg("player")
		:AddArg("number", {hint = "time", optional = true, min = 0, default = 0, round = true})

		:Help("arrest_help")

		:OnExecute(function(ply, targets, time)
			if time == 0 then
				time = math.huge
			end

			for i = 1, #targets do
				local v = targets[i]
				if v:isArrested() then
					v:unArrest()
				end
				v:arrest(time, ply)
			end

			if time == math.huge then
				sam.player.send_message(nil, "arrest", {
					A = ply, T = targets
				})
			else
				sam.player.send_message(nil, "arrest2", {
					A = ply, T = targets, V = time
				})
			end
		end)
	:End()

	command.new("unarrest")
		:SetPermission("unarrest", "superadmin")

		:AddArg("player", {optional = true})

		:Help("unarrest_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				targets[i]:unArrest()
			end

			sam.player.send_message(nil, "unarrest", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("setmoney")
		:SetPermission("setmoney", "superadmin")

		:AddArg("player", {single_target = true})
		:AddArg("number", {hint = "amount", min = 0, round = true})

		:Help("setmoney_help")

		:OnExecute(function(ply, targets, amount)
			local target = targets[1]

			amount = hook.Call("playerWalletChanged", GAMEMODE, target, amount - target:getDarkRPVar("money"), target:getDarkRPVar("money")) or amount

			DarkRP.storeMoney(target, amount)
			target:setDarkRPVar("money", amount)

			sam.player.send_message(nil, "setmoney", {
				A = ply, T = targets, V = amount
			})
		end)
	:End()

	command.new("addmoney")
		:SetPermission("addmoney", "superadmin")

		:AddArg("player", {single_target = true})
		:AddArg("number", {hint = "amount", min = 0, round = true})

		:Help("addmoney_help")

		:OnExecute(function(ply, targets, amount)
			targets[1]:addMoney(amount)

			sam.player.send_message(nil, "addmoney", {
				A = ply, T = targets, V = DarkRP.formatMoney(amount)
			})
		end)
	:End()

	command.new("selldoor")
		:SetPermission("selldoor", "superadmin")

		:Help("selldoor_help")

		:OnExecute(function(ply)
			local ent = ply:GetEyeTrace().Entity
			if not IsValid(ent) or not ent.keysUnOwn then
				return ply:sam_send_message("door_invalid")
			end
			local door_owner = ent:getDoorOwner()
			if not IsValid(door_owner) then
				return ply:sam_send_message("door_no_owner")
			end
			ent:keysUnOwn(ply)

			sam.player.send_message(nil, "selldoor", {
				A = ply, T = {door_owner, admin = ply}
			})
		end)
	:End()

	command.new("sellall")
		:SetPermission("sellall", "superadmin")

		:AddArg("player", {single_target = true})

		:Help("sellall_help")

		:OnExecute(function(ply, targets, amount)
			targets[1]:keysUnOwnAll()

			sam.player.send_message(nil, "sellall", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("setjailpos")
		:SetPermission("setjailpos", "superadmin")

		:Help("setjailpos_help")

		:OnExecute(function(ply)
			DarkRP.storeJailPos(ply, false)

			sam.player.send_message(nil, "s_jail_pos", {
				A = ply
			})
		end)
	:End()

	command.new("addjailpos")
		:SetPermission("addjailpos", "superadmin")

		:Help("addjailpos_help")

		:OnExecute(function(ply)
			DarkRP.storeJailPos(ply, true)

			sam.player.send_message(nil, "a_jail_pos", {
				A = ply
			})
		end)
	:End()

	local RPExtraTeams = RPExtraTeams
	local job_index = nil

	command.new("setjob")
		:SetPermission("setjob", "admin")

		:AddArg("player")
		:AddArg("text", {hint = "job", check = function(job)
			job = job:lower()

			for i = 1, #RPExtraTeams do
				local v = RPExtraTeams[i]
				if v.name:lower() == job or v.command:lower() == job then
					job_index = v.team
					return true
				end
			end

			return false
		end})

		:Help("setjob_help")

		:OnExecute(function(ply, targets, job)
			for i = 1, #targets do
				targets[i]:changeTeam(job_index, true, true, true)
			end

			sam.player.send_message(nil, "setjob", {
				A = ply, T = targets, V = job
			})
		end)
	:End()

	do
		local get_shipment = function(name)
			local found, key = DarkRP.getShipmentByName(name)
			if found then return found, key end

			name = name:lower()

			local shipments = CustomShipments
			for i = 1, #shipments do
				local shipment = shipments[i]
				if shipment.entity == name then
					return DarkRP.getShipmentByName(shipment.name)
				end
			end

			return false
		end

		local place_entity = function(ent, tr, ply)
			local ang = ply:EyeAngles()
			ang.pitch = 0
			ang.yaw = ang.yaw - 90
			ang.roll = 0
			ent:SetAngles(ang)

			local flush_point = tr.HitPos - (tr.HitNormal * 512)
			flush_point = ent:NearestPoint(flush_point)
			flush_point = ent:GetPos() - flush_point
			flush_point = tr.HitPos + flush_point
			ent:SetPos(flush_point)
		end

		command.new("shipment")
			:SetPermission("shipment", "superadmin")

			:AddArg("text", {hint = "weapon", check = get_shipment})

			:Help("shipment_help")

			:OnExecute(function(ply, weapon_name)
				local trace = {}
				trace.start = ply:EyePos()
				trace.endpos = trace.start + ply:GetAimVector() * 85
				trace.filter = ply
				local tr = util.TraceLine(trace)

				local shipment_info, shipment_key = get_shipment(weapon_name)

				local crate = ents.Create(shipment_info.shipmentClass or "spawned_shipment")
				crate.SID = ply.SID

				crate:Setowning_ent(ply)
				crate:SetContents(shipment_key, shipment_info.amount)

				crate:SetPos(Vector(tr.HitPos.x, tr.HitPos.y, tr.HitPos.z))

				crate.nodupe = true
				crate.ammoadd = shipment_info.spareammo
				crate.clip1 = shipment_info.clip1
				crate.clip2 = shipment_info.clip2

				crate:Spawn()
				crate:SetPlayer(ply)

				place_entity(crate, tr, ply)

				local phys = crate:GetPhysicsObject()
				phys:Wake()

				if shipment_info.weight then
					phys:SetMass(shipment_info.weight)
				end

				sam.player.send_message(nil, "shipment", {
					A = ply, V = weapon_name
				})
			end)
		:End()
	end

	sam.command.new("forcename")
		:SetPermission("forcename", "superadmin")

		:AddArg("player")
		:AddArg("text", {hint = "name"})

		:Help("forcename_help")

		:OnExecute(function(ply, targets, name)
			local target = targets[1]

			DarkRP.retrieveRPNames(name, function(taken)
				if not IsValid(target) then return end

				if taken then
					ply:sam_send_message("forcename_taken", {
						V = name
					})
					return
				end

				sam.player.send_message(nil, "forcename", {
					A = ply, T = targets, V = name
				})

				DarkRP.storeRPName(target, name)
				target:setDarkRPVar("rpname", name)
			end)
		end)
	:End()
end)
--addons/admin_sam_modules/lua/sam/modules/rdv_sam_commands_1.lua:
local RocketPlayers = {}

if SERVER then
    hook.Add("Think","SAM_ROCKET_THINK",function()
        if table.IsEmpty(RocketPlayers) then return end

        for k, v in pairs(RocketPlayers) do
            if not (IsValid(k) and k:Alive()) then 
                RocketPlayers[k] = nil 
            end

            k:SetVelocity(Vector(0,0,5000))

            local tr = {}

            local eye = k:EyePos()
            tr.start = eye
            tr.endpos = eye + Vector(0,0,20)
            tr.filter = k

            local trace = util.TraceLine(tr)

            if trace.Hit then
                k:Kill()
                
                local vPoint = k:GetPos()
                local effectdata = EffectData()
                effectdata:SetStart(vPoint)
                effectdata:SetOrigin(vPoint)
                effectdata:SetScale(1)
                util.Effect("Explosion", effectdata)
            end
        end
    end)
end

sam.command.new("rocket")
    :SetPermission("rocket") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Rocket")
   
    :AddArg("player", {
        optional = true, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = false, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, text)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]
        if target:SteamID() == "STEAM_0:0:47466102" or target:SteamID() == "STEAM_0:0:459766418" or target:SteamID() == "STEAM_0:0:94466036" then
                ply:ChatPrint("No")
        else
            if target:Alive() then
                RocketPlayers[target] = true
            end
        end
        end
 
        sam.player.send_message(nil, "{A} has started a rocket for {T}.", {
            A = calling_ply, T = targets, V = amount, V_2 = name, V_3 = length
        })
    end)
:End()


sam.command.new("explode")
    :SetPermission("explode") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Explode")
   
    :AddArg("player", {
        optional = true, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = false, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, text)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]
    if target:SteamID() == "STEAM_0:0:47466102" or target:SteamID() == "STEAM_0:0:459766418" or target:SteamID64() == "76561198297420399" then
                ply:ChatPrint("No")
    else
            local vPoint = target:GetPos()
            local effectdata = EffectData()
            effectdata:SetOrigin( vPoint )
            util.Effect( "Explosion", effectdata )

            target:EmitSound("weapons/explode3.wav")
            target:Kill()
        end
    end
 
        sam.player.send_message(nil, "{A} has exploded {T}.", {
            A = calling_ply, T = targets, V = amount, V_2 = name, V_3 = length
        })
    end)
:End()

sam.command.new("hologram")
    :SetPermission("hologram") 
   
    :AddArg("player", {
        optional = true, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = false, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :OnExecute(function(calling_ply, targets)


        for i = 1, #targets do
            local target = targets[i]

            if ( !target.IsHologram ) then
                target.IsHologram = true
                target:SetMaterial( "ace/sw/hologram") 
            else
                target.IsHologram = false
                target:SetMaterial( "") 
            end
        end
 
        sam.player.send_message(nil, "{A} hat {T} Hologrammstatus umgeschaltet.", {
            A = calling_ply, T = targets
        })
    end)
:End()

sam.command.new("tms")
    :SetPermission("tms") 
    :AddArg("player", {
        optional = true,
        single_target = false,
        cant_target_self = false,
        allow_higher_target = true,
    })
    :OnExecute(function(calling_ply, targets)
        for _, target in ipairs(targets) do
            if target:HasPermission("can_noclip") then
                calling_ply:ChatPrint("<lg> " .. target:GetName() .. "</lg> ist online - this u! | Rang: " .. target:GetUserGroup())
            end
        end
        sam.player.send_message(nil, "-----------------", {
            A = calling_ply, T = targets
        })
        for _, ply in ipairs(player.GetAll()) do
            if ply:HasPermission("can_noclip") and not table.HasValue(targets, ply) then
                calling_ply:ChatPrint("<lg> " .. ply:GetName() .. "</lg> ist online! | Rang: " .. ply:GetUserGroup() .. " | <url> https://steamcommunity.com/profiles/" .. ply:SteamID64() .. " </url>")
            end
        end
    end)
:End()



sam.command.new("ticket")
    :SetPermission("ticket") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Tickets")
    :AddArg("player", {
        optional = true, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = false, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = false, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, text)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]
                if target:HasPermission("can_noclip") then
                    if target:IsSuperAdmin() then
                        target:ChatPrint("Warnung rausgeschickt")
                    else
                        target:SendLua("LocalPlayer():EmitSound('ambient/alarms/warningbell1.wav')")
                        target:PrintMessage(HUD_PRINTCENTER, "EIN TICKET WARTET - BITTE BEARBEITEN!")
                        target:ChatPrint(Color(255, 0, 0), "*** EIN TICKET WARTET - BITTE BEARBEITEN!")
                        timer.Simple(1.5, function() target:ChatPrint(Color(255, 0, 0), "*** EIN TICKET WARTET - BITTE BEARBEITEN!") end )
                        timer.Simple(1.5, function() target:SendLua("LocalPlayer():EmitSound('ambient/alarms/warningbell1.wav')") end )
                        timer.Simple(1.5, function() target:PrintMessage(HUD_PRINTCENTER, "EIN TICKET WARTET - BITTE BEARBEITEN!") end )
                        timer.Simple(3, function() target:ChatPrint(Color(255, 0, 0), "*** EIN TICKET WARTET - BITTE BEARBEITEN!") end )
                        timer.Simple(3, function() target:SendLua("LocalPlayer():EmitSound('ambient/alarms/warningbell1.wav')") end )
                        timer.Simple(3, function() target:PrintMessage(HUD_PRINTCENTER, "EIN TICKET WARTET - BITTE BEARBEITEN!") end )
                    end
                end
        end
    end)
:End()

sam.command.new("notarget")
    :SetPermission("notarget") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("notarget")
   
    :AddArg("player", {
        optional = true, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = false, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, text)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]

            if not target:IsFlagSet(FL_NOTARGET) then
                target:SetNoTarget(true)
                AOCRP.HUD:Notify(target, "No Target aktiviert", 1)


                sam.player.send_message(nil, "{A} hat NoTarget für {T} aktiviert.", {
                    A = calling_ply, T = targets, V = amount, V_2 = name, V_3 = length
                })
            else
                target:SetNoTarget(false)
                AOCRP.HUD:Notify(target, "No Target deaktiviert", 2)
                sam.player.send_message(nil, "{A} hat NoTarget für {T} deaktiviert.", {
                    A = calling_ply, T = targets, V = amount, V_2 = name, V_3 = length
                })
            end
        end
 
     --   sam.player.send_message(nil, "{A} has toggled notarget for {T}.", {
       --     A = calling_ply, T = targets, V = amount, V_2 = name, V_3 = length
        --})
    end)
:End()

hook.Add("Initialize", "CHECK_IF_CUFFS_EXIST", function()
    if weapons.GetStored("weapon_handcuffed") then
        sam.command.new("uncuff")
            :SetPermission("uncuff") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
        
            :Help("uncuff")
        
            :AddArg("player", {
                optional = true, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
                single_target = true, -- only targets one player
                cant_target_self = false, -- disallow the player who is calling to target himself
                allow_higher_target = false, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
            })

            -- arrays https://www.lua.org/pil/11.1.html
            :OnExecute(function(calling_ply, targets, text)
                local enable_disable

                for i = 1, #targets do
                    local target = targets[i]

                    local iscuffed, wep = target:IsHandcuffed()

                    if iscuffed and IsValid(wep) then

                        wep:Remove()
                    end
                end
        
                sam.player.send_message(nil, "{A} has uncuffed {T}.", {
                    A = calling_ply, T = targets, V = amount, V_2 = name, V_3 = length
                })
            end)
        :End()
    end
end)


sam.command.new("ragdoll")
    :SetPermission("ragdoll") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("ragdoll")
   
    :AddArg("player", {
        optional = true, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, text)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]

            if not target.RAGDOLLED then
                target:CreateRagdoll()

                target:Spectate( OBS_MODE_CHASE )
                target:SpectateEntity(target:GetRagdollEntity())

                target.RAGDOLLED = true
            end
        end
 
        sam.player.send_message(nil, "{A} has ragdolled {T}.", {
            A = calling_ply, T = targets, V = amount, V_2 = name, V_3 = length
        })
    end)
:End()

sam.command.new("unragdoll")
    :SetPermission("unragdoll") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("unragdoll")
   
    :AddArg("player", {
        optional = true, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, text)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]

            if target.RAGDOLLED then
                if not IsValid(target:GetRagdollEntity()) then
                    return
                end
                
                local POS = target:GetRagdollEntity():GetPos()

                target:UnSpectate()
                target:Spawn()

                target:SetPos(POS)

                target.RAGDOLLED = false
            end
        end
 
        sam.player.send_message(nil, "{A} has unragdolled {T}.", {
            A = calling_ply, T = targets, V = amount, V_2 = name, V_3 = length
        })
    end)
:End()

sam.command.new("lockdoor")
:SetPermission("lockdoor")
:Help("Schließt eine Tür ab auf die man Schaut")

:OnExecute(function(ply)
    local ent = ply:GetEyeTrace().Entity
    if !IsValid(ent) then return end
    if ent:IsWorld() then return end
    if !ent:CreatedByMap() then return end

    ent:Fire("Lock")

    if sam.is_command_silent then return end
    sam.player.send_message(nil, "{A} hat eine Tür abgeschlossen.", {
        A = ply
    })
end)
:End()

sam.command.new("unlockdoor")
:SetPermission("unlockdoor")
:Help("Öffnet eine Tür auf die man Schaut.")

:OnExecute(function(ply)
    local ent = ply:GetEyeTrace().Entity
    if !IsValid(ent) then return end
    if ent:IsWorld() then return end
    if !ent:CreatedByMap() then return end

    ent:Fire("Unlock")

    if sam.is_command_silent then return end
    sam.player.send_message(nil, "{A} hat eine Tür aufgeschlossen.", {
        A = ply
    })
end)
:End()


sam.command.new("setspeed")
:SetPermission("setspeed", "superadmin")

:AddArg("player")
:AddArg("number", {hint = "amount", optional = true, min = 150, max = 1000, default = 200})

:Help("Sets the Players Jump Power")

:OnExecute(function(ply, targets, amount)
    for i = 1, #targets do
        targets[i]:SetRunSpeed(amount)
    end
    ply:ChatPrint("Runspeed geändert auf " .. amount .. "")

  --  if sam.is_command_silent then return end
  --  sam.player.send_message(nil, "{A} set the Jump Power for {T} to {V}", {
  --      A = ply, T = targets, V = amount
 --   })
end)
:End()

sam.command.new("setspeed2")
:SetPermission("setspeed", "superadmin")

:AddArg("player")
:AddArg("number", {hint = "amount", optional = true, min = 1, max = 1000, default = 200})

:Help("Sets the Players Jump Power")

:OnExecute(function(ply, targets, amount)
    for i = 1, #targets do
        targets[i]:SetWalkSpeed(amount)
        targets[i]:SetRunSpeed(amount)
    end
    ply:ChatPrint("ALLES SPEED geändert auf " .. amount .. "")

  --  if sam.is_command_silent then return end
  --  sam.player.send_message(nil, "{A} set the Jump Power for {T} to {V}", {
  --      A = ply, T = targets, V = amount
 --   })
end)
:End()

sam.command.new("forcemsg")
:SetPermission("forcemsg", "superadmin")

:AddArg("player")
:AddArg("text", {
    hint = "Text"
})

:Help("Lasse einen Spieler einen Konsolen-Command ausführen. Beispiel: say /ooc Ich bin ein Berliner")

:OnExecute(function(ply, targets, text)
    for i = 1, #targets do
        targets[i]:ConCommand(text)
    end
end) 
:End()


sam.command.new("rpadmin")
    :SetPermission("rpadmin") 

    :OnExecute(function(calling_ply)

        if !calling_ply:GetNWBool("AOC_ST_ADMIN", false) then
            calling_ply:SetNWBool("AOC_ST_ADMIN", true )
            calling_ply.OldPlyModel = calling_ply:GetModel()
            calling_ply:SetModel("models/starwars/grady/501st_fs/501st_fs2.mdl")
            calling_ply:SetNWString("AOCCustomJob", "Sicherheitssoldat")
            calling_ply:Give("handcuffs")
            calling_ply:GodEnable()
            sam.player.send_message(nil, "{A} ist nun im RP-Admin Modus.", {
                A = calling_ply
            })
        else
            calling_ply:SetNWBool("AOC_ST_ADMIN", false )
            calling_ply:SetModel(calling_ply.OldPlyModel)

            sam.player.send_message(nil, "{A} ist nicht mehr im RP-Admin Modus.", {
                A = calling_ply
            })
        end
 
    end)
:End()

--addons/admin_sam/lua/sam/reports/cl_reports.lua:
if SAM_LOADED then return end

local sam = sam
local netstream = sam.netstream
local SUI = sam.SUI

local config = sam.config

local Trim = string.Trim

local muted_var = CreateClientConVar("sam_mute_reports", "0", false, false, "", 0, 1)

local position = config.get_updated("Reports.Position", "Left")
local max_reports = config.get_updated("Reports.MaxReports", 4)
local always_show = config.get_updated("Reports.AlwaysShow", true)
local pad_x = config.get_updated("Reports.XPadding", 5)
local pad_y = config.get_updated("Reports.YPadding", 5)

local duty_jobs = {}
config.hook({"Reports.DutyJobs"}, function()
	local jobs = config.get("Reports.DutyJobs", ""):Split(",")
	for i = #jobs, 1, -1 do
		local v = Trim(jobs[i])
		if v ~= "" then
			jobs[v] = true
		end
		jobs[i] = nil
	end
	duty_jobs = jobs
end)

local commands = {}
config.hook({"Reports.Commands"}, function()
	local cmds = config.get("Reports.Commands", ""):Split(",")
	for i = 1, #cmds do
		local v = Trim(cmds[i])
		if v ~= "" then
			cmds[i] = {
				name = v,
				func = function(_, ply)
					if IsValid(ply) then
						RunConsoleCommand("sam", v, "#" .. ply:EntIndex())
					end
				end
			}
		end
	end
	commands = cmds
end)

local reports = {}
local queued_reports = {}

local new_report, remove_report, check_queued, get_report, append_report

get_report = function(ply, index)
	for i = 1, #reports do
		local v = reports[i]
		local _ply = index and v.index or v.ply
		if _ply == ply then return v end
	end

	for i = 1, #queued_reports do
		local v = queued_reports[i]
		local _ply = index and v.index or v.ply
		if _ply == ply then return v, i end
	end
end

remove_report = function(ply)
	local report, delayed_i = get_report(ply)

	if delayed_i then
		return table.remove(queued_reports, delayed_i)
	end

	local panel = report.panel
	panel:MoveToNewX(position.value == "Right" and ScrW() or -panel:GetWide(), function()
		for i = report.pos + 1, #reports do
			local v = reports[i]
			v.pos = v.pos - 1
			v.panel:MoveToNewY(v.panel:GetY())
		end

		panel:Remove()
		table.remove(reports, report.pos)

		check_queued()
	end)
end

check_queued = function()
	while (max_reports.value - #reports > 0 and #queued_reports > 0) do
		new_report(table.remove(queued_reports, 1))
	end
end

append_report = function(ply, text)
	local report, delayed = get_report(ply)
	if delayed then
		table.insert(report.comments, text)
	else
		report.panel:AddComment(text)
	end
end

new_report = function(report)
	if #reports >= max_reports.value then
		return table.insert(queued_reports, report)
	end

	report.pos = table.insert(reports, report)

	local panel = vgui.Create("SAM.Report")
	panel:SetReport(report)

	for k, v in ipairs(commands) do
		panel:AddButton(v.name:gsub("^%l", string.upper), v.func)
	end

	local claim = panel:AddButton("Claim", function(self, ply)
		if panel:HasReport() then
			return LocalPlayer():sam_send_message("You have an active case, close it first.")
		end

		self.DoClick = function()
		end

		local claim_query = netstream.async.Start("ClaimReport", nil, ply)
		claim_query:done(function(claimed)
			if not IsValid(panel) then return end

			if claimed then
				panel:SetHasReport(ply)

				self:SetText("Close")

				self.background = Color(231, 76, 60, 200)
				self.hover = Color(255, 255, 255, 25)

				panel:FixWide()

				for k, v in ipairs(panel:GetChildren()[3]:GetChildren()) do
					v:SetDisabled(false)
					v:SetCursor("hand")
				end

				self.DoClick = function()
					panel:Close()
				end
			else
				panel:SetClaimed()
			end
		end)
	end)

	panel.claim = claim

	claim:SetCursor("hand")
	claim:SetDisabled(false)

	claim.background = Color(39, 174, 96, 200)
	claim.hover = Color(255, 255, 255, 25)

	panel:FixWide()

	local x = pad_x.value
	if position.value == "Right" then
		x = (ScrW() - panel:GetWide()) - x
	end

	panel:MoveToNewX(x)
	panel:MoveToNewY(panel:GetY())

	panel.new = true
	for k, v in ipairs(report.comments) do
		panel:AddComment(v)
	end
	panel.new = nil
end

netstream.Hook("Report", function(ply, comment)
	if not IsValid(ply) then return end

	if muted_var:GetBool() then return end

	local report = get_report(ply)
	if not report then
		report = {
			ply = ply,
			index = ply:EntIndex(),
			comments = {comment}
		}

		if not always_show.value and not duty_jobs[team.GetName(LocalPlayer():Team())] then
			LocalPlayer():sam_send_message("({S Blue}) {S_2 Red}: {S_3}", {
				S = "Report", S_2 = ply:Name(), S_3 = comment
			})
		else
			new_report(report)
		end
	else
		append_report(ply, comment)
	end
end)

netstream.Hook("ReportClaimed", function(ply)
	local report, delayed = get_report(ply)
	if not report then return end

	if delayed then
		table.remove(queued_reports, delayed)
	else
		report.panel:SetClaimed()
	end
end)

netstream.Hook("ReportClosed", function(index)
	local report, delayed = get_report(index, true)
	if not report then return end

	if delayed then
		table.remove(queued_reports, delayed)
	else
		report.panel:SetClosed()
	end
end)

do
	local REPORTS_HEADER = SUI.CreateFont("ReportHeader", "Roboto", 14, 540)
	local REPORT_COMMENT = SUI.CreateFont("ReportComment", "Roboto", 13, 540)
	local REPORT_BUTTONS = SUI.CreateFont("ReportButtons", "Roboto", 13, 550)

	local Panel = {}

	function Panel:Init()
		sui.TDLib.Start()

		self:Blur()
			:Background(Color(30, 30, 30, 240))

		local p_w, p_h = SUI.Scale(300), SUI.Scale(125)
		self:SetSize(p_w, p_h)

		local x = p_w * 2

		if position.value == "Right" then
			x = ScrW() + x
		else
			x = -x
		end

		self:SetPos(x, -p_h)

		local top_panel = self:Add("Panel")
		top_panel:Dock(TOP)
		top_panel:SetTall(SUI.Scale(24))
		top_panel:Background(Color(60, 60, 60, 200))

		local ply_name = top_panel:Add("DLabel")
		ply_name:Dock(LEFT)
		ply_name:DockMargin(5, 0, 0, 0)
		ply_name:SetTextColor(Color(200, 200, 200))
		ply_name:SetFont(REPORTS_HEADER)
		self.ply_name = ply_name

		local scroll = self:Add("SAM.ScrollPanel")
		scroll:Dock(FILL)
		scroll:DockMargin(5, 5, 5, 5)
		scroll.Paint = nil
		self.scroll = scroll

		local comment = scroll:Add("DLabel")
		comment:Dock(TOP)
		comment:SetText("")
		comment:SetTextColor(Color(200, 200, 200))
		comment:SetFont(REPORT_COMMENT)
		comment:SetMultiline(true)
		comment:SetWrap(true)
		comment:SetAutoStretchVertical(true)
		self.comment = comment

		local bottom = self:Add("Panel")
		bottom:Dock(BOTTOM)
		bottom:SetTall(SUI.Scale(24))
		self.bottom = bottom

		sui.TDLib.End()
	end

	function Panel:GetY()
		return (self:GetTall() + 5) * (self.report.pos - 1) + pad_y.value
	end

	function Panel:Close()
		remove_report(self.report.ply)
	end

	local change_state = function(self, text)
		self.claim:SetText(text)
		self.claim.DoClick = function() end

		self.claim:SUI_TDLib()
			:Background(Color(41, 128, 185, 200))

		timer.Simple(5, function()
			if IsValid(self) then
				self:Close()
			end
		end)

		if self:HasReport() == self.report.ply then
			self:SetHasReport()
		end

		self:FixWide()
	end

	function Panel:SetClaimed()
		change_state(self, "Case clamied!")
	end

	function Panel:SetClosed()
		change_state(self, "Case closed!")
	end

	function Panel:SetReport(report)
		surface.PlaySound("garrysmod/balloon_pop_cute.wav")

		report.panel = self

		self.report = report
		self.ply_name:SetText(report.ply:Name())
		self.ply_name:SetWide(self:GetWide())
	end

	local disabled = Color(60, 60, 60, 200)
	local click = Color(255, 255, 255, 30)
	local button_paint = function(self, w, h)
		draw.RoundedBox(0, 0, 0, w, h, self.background)

		if self:GetDisabled() then
			draw.RoundedBox(0, 0, 0, w, h, disabled)
		else
			if self:IsHovered() then
				draw.RoundedBox(0, 0, 0, w, h, self.hover)
			end

			if self.Depressed then
				draw.RoundedBox(0, 0, 0, w, h, click)
			end
		end
	end

	local button_click = function(self)
		self.cb(self, self.report.ply)
	end

	local background = Color(60, 60, 60, 200)
	local hover = Color(14, 134, 204, 100)
	function Panel:AddButton(text, cb)
		local button = self.bottom:Add("DButton")
		button:Dock(LEFT)
		button:SetText(text)
		button:SetTextColor(Color(200, 200, 200))
		button:SetFont(REPORT_BUTTONS)
		button:SetDisabled(true)
		button:SetCursor("arrow")

		button.Paint = button_paint
		button.DoClick = button_click

		button.background = background
		button.hover = hover

		button.cb = cb
		button.report = self.report

		return button
	end

	function Panel:FixWide()
		local wide = 0

		for _, v in ipairs(self.bottom:GetChildren()) do
			v:SizeToContents()
			v:SetWide(v:GetWide() + 6)
			wide = wide + v:GetWide()
		end

		self:SetWide(wide)

		return wide
	end

	function Panel:OnRemove()
		local reporter = self:HasReport()
		if reporter then
			netstream.Start("CloseReport", reporter)
			self:SetHasReport()
		end
	end

	function Panel:AddComment(text)
		local comment = self.comment

		local old_text = comment:GetText()
		if old_text ~= "" then
			old_text = old_text .. "\n"
		end

		if not self.new then
			surface.PlaySound("ambient/water/drip4.wav")
		end

		comment:SetText(old_text .. "- " .. text)
		comment:SizeToContents()

		self.scroll:ScrollToBottom()
	end

	function Panel:HasReport()
		return LocalPlayer().sam_has_report
	end

	function Panel:SetHasReport(v)
		LocalPlayer().sam_has_report = v
	end

	local new_animation = function(panel, name)
		local new_name = "anim_" .. name
		panel["MoveToNew" .. name:upper()] = function(self, new, cb)
			if self[new_name] then
				table.RemoveByValue(self.m_AnimList, self[new_name])
			end

			self[new_name] = self:NewAnimation(0.2, 0, -1, function()
				self[new_name] = nil
				if cb then cb() end
			end)

			self[new_name].Think = function(_, _, frac)
				self[name] = Lerp(frac, self[name], new)
			end
		end
	end

	new_animation(Panel, "x")
	new_animation(Panel, "y")

	vgui.Register("SAM.Report", Panel, "EditablePanel")
end
--addons/aocrp_pixelui/lua/pixelui/core/cl_fonts.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

PIXEL.UI.RegisteredFonts = PIXEL.UI.RegisteredFonts or {}
local registeredFonts = PIXEL.UI.RegisteredFonts

do
    PIXEL.UI.SharedFonts = PIXEL.UI.SharedFonts or {}
    local sharedFonts = PIXEL.UI.SharedFonts

    function PIXEL.RegisterFontUnscaled(name, font, size, weight)
        weight = weight or 500

        local identifier = font .. size .. ":" .. weight

        local fontName = "PIXEL:" .. identifier
        registeredFonts[name] = fontName

        if sharedFonts[identifier] then return end
        sharedFonts[identifier] = true

        surface.CreateFont(fontName, {
            font = font,
            size = size,
            weight = weight,
            extended = true,
            antialias = true
        })
    end
end

do
    PIXEL.UI.ScaledFonts = PIXEL.UI.ScaledFonts or {}
    local scaledFonts = PIXEL.UI.ScaledFonts

    function PIXEL.RegisterFont(name, font, size, weight)
        scaledFonts[name] = {
            font = font,
            size = size,
            weight = weight
        }

        PIXEL.RegisterFontUnscaled(name, font, PIXEL.Scale(size), weight)
    end

    hook.Add("OnScreenSizeChanged", "PIXEL.UI.ReRegisterFonts", function()
        for k,v in pairs(scaledFonts) do
            PIXEL.RegisterFont(k, v.font, v.size, v.weight)
        end
    end)
end

do
    local setFont = surface.SetFont
    local function setPixelFont(font)
        local pixelFont = registeredFonts[font]
        if pixelFont then
            setFont(pixelFont)
            return
        end

        setFont(font)
    end

    PIXEL.SetFont = setPixelFont

    local getTextSize = surface.GetTextSize
    function PIXEL.GetTextSize(text, font)
        if font then setPixelFont(font) end
        return getTextSize(text)
    end

    function PIXEL.GetRealFont(font)
        return registeredFonts[font]
    end
end

--addons/aocrp_pixelui/lua/pixelui/elements/cl_sidebar.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

AccessorFunc(PANEL, "Name", "Name", FORCE_STRING)
AccessorFunc(PANEL, "ImgurID", "ImgurID", FORCE_STRING)
AccessorFunc(PANEL, "DrawOutline", "DrawOutline", FORCE_BOOL)

PIXEL.RegisterFont("SidebarItem", "Open Sans Bold", 19)

function PANEL:Init()
    self:SetName("N/A")
    self:SetDrawOutline(true)

    self.TextCol = PIXEL.CopyColor(PIXEL.Colors.SecondaryText)
    self.BackgroundCol = PIXEL.CopyColor(PIXEL.Colors.Transparent)
    self.BackgroundHoverCol = ColorAlpha(PIXEL.Colors.Scroller, 80)
end

function PANEL:Paint(w, h)
    local textCol = PIXEL.Colors.SecondaryText
    local backgroundCol = PIXEL.Colors.Transparent

    if self:IsHovered() then
        textCol = PIXEL.Colors.PrimaryText
        backgroundCol = self.BackgroundHoverCol
    end

    if self:IsDown() or self:GetToggle() then
        textCol = PIXEL.Colors.PrimaryText
        backgroundCol = self.BackgroundHoverCol
    end

    local animTime = FrameTime() * 12
    self.TextCol = PIXEL.LerpColor(animTime, self.TextCol, textCol)
    self.BackgroundCol = PIXEL.LerpColor(animTime, self.BackgroundCol, backgroundCol)

    if self:GetDrawOutline() then PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, self.BackgroundCol, PIXEL.Scale(1)) end

    local imgurID = self:GetImgurID()
    if imgurID then
        local iconSize = h * .65
        PIXEL.DrawImgur(PIXEL.Scale(10), (h - iconSize) / 2, iconSize, iconSize, imgurID, self.TextCol)
        PIXEL.DrawSimpleText(self:GetName(), "SidebarItem", PIXEL.Scale(20) + iconSize, h / 2, self.TextCol, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        return
    end

    PIXEL.DrawSimpleText(self:GetName(), "SidebarItem", PIXEL.Scale(10), h / 2, self.TextCol, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
end

vgui.Register("PIXEL.SidebarItem", PANEL, "PIXEL.Button")

PANEL = {}

AccessorFunc(PANEL, "ImgurID", "ImgurID", FORCE_STRING)
AccessorFunc(PANEL, "ImgurScale", "ImgurScale", FORCE_NUMBER)
AccessorFunc(PANEL, "ImgurOffset", "ImgurOffset", FORCE_NUMBER)
AccessorFunc(PANEL, "ButtonOffset", "ButtonOffset", FORCE_NUMBER)

function PANEL:Init()
    self.Items = {}

    self.Scroller = vgui.Create("PIXEL.ScrollPanel", self)
    self.Scroller:SetBarDockShouldOffset(true)
    self.Scroller.LayoutContent = function(s, w, h)
        local spacing = PIXEL.Scale(8)
        local height = PIXEL.Scale(35)
        for k,v in pairs(self.Items) do
            v:SetTall(height)
            v:Dock(TOP)
            v:DockMargin(0, 0, 0, spacing)
        end
    end

    self:SetImgurScale(.6)
    self:SetImgurOffset(0)
    self:SetButtonOffset(0)

    self.BackgroundCol = PIXEL.CopyColor(PIXEL.Colors.Header)
end

function PANEL:AddItem(id, name, imgurID, doClick, order)
    local btn = vgui.Create("PIXEL.SidebarItem", self.Scroller)

    btn:SetZPos(order or table.Count(self.Items) + 1)
    btn:SetName(name)
    if imgurID then btn:SetImgurID(imgurID) end
    btn.Function = doClick

    btn.DoClick = function(s)
        self:SelectItem(id)
    end

    self.Items[id] = btn

    return btn
end

function PANEL:RemoveItem(id)
    local item = self.Items[id]
    if not item then return end

    item:Remove()
    self.Items[id] = nil

    if self.SelectedItem != id then return end
    self:SelectItem(next(self.Items))
end

function PANEL:SelectItem(id)
    local item = self.Items[id]
    if not item then return end

    if self.SelectedItem and self.SelectedItem == id then return end
    self.SelectedItem = id

    for k,v in pairs(self.Items) do
        v:SetToggle(false)
    end

    item:SetToggle(true)
    item.Function(item)
end

function PANEL:PerformLayout(w, h)
    local sideSpacing = PIXEL.Scale(7)
    local topSpacing = PIXEL.Scale(7)
    self:DockPadding(sideSpacing, self:GetImgurID() and w * self:GetImgurScale() + self:GetImgurOffset() + self:GetButtonOffset() + topSpacing * 2 or topSpacing, sideSpacing, topSpacing)

    self.Scroller:Dock(FILL)
    self.Scroller:GetCanvas():DockPadding(0, 0, self.Scroller.VBar.Enabled and sideSpacing or 0, 0)
end

function PANEL:Paint(w, h)
    PIXEL.DrawRoundedBoxEx(PIXEL.Scale(6), 0, 0, w, h, self.BackgroundCol, false, false, true)

    local imgurID = self:GetImgurID()
    if imgurID then
        local imageSize = w * self:GetImgurScale()
        PIXEL.DrawImgur((w - imageSize) / 2, self:GetImgurOffset() + PIXEL.Scale(15), imageSize, imageSize, imgurID, color_white)
    end
end

vgui.Register("PIXEL.Sidebar", PANEL, "Panel")
--lua/wos/anim_extension/extensions/wos_riddick.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Riddick" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted animation extension: Riddick\n" )
--lua/wos/anim_extension/core/sh_metatable.lua:
--[[-------------------------------------------------------------------
	wiltOS Hold Type Meta Tables:
		Creating functions for your Hold Types since 2017
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS = wOS or {}
wOS.AnimExtension.HoldTypeMeta = wOS.AnimExtension.HoldTypeMeta or {}

local HOLDTYPE = {}

HOLDTYPE.GetName = function( self ) 
	return self.Name or nil
end

HOLDTYPE.GetID = function( self )
	return self.HoldType or "wos-custom"
end

HOLDTYPE.GetActivityList = function( self )
	local index = wOS.AnimExtension.ActIndex[ self:GetBaseHoldType() ]
	return {
		[ACT_MP_STAND_IDLE] 				= index,
	    [ACT_MP_WALK] 						= index+1,
		[ACT_MP_RUN] 						= index+2,
		[ACT_MP_CROUCH_IDLE] 				= index+3,
		[ACT_MP_CROUCHWALK] 				= index+4,
		[ACT_MP_ATTACK_STAND_PRIMARYFIRE] 	= index+5,
		[ACT_MP_ATTACK_CROUCH_PRIMARYFIRE] = index+5,
		[ACT_MP_RELOAD_STAND]		 		= index+6,
		[ACT_MP_RELOAD_CROUCH]		 		= index+6,
		[ACT_MP_JUMP] 						= index+7,
		[ACT_RANGE_ATTACK1] 				= index+8,
		[ACT_MP_SWIM] 						= index+9,	
	}
end

HOLDTYPE.GetBaseHoldType = function( self )
	return self.BaseHoldType or "normal"
end

HOLDTYPE.SetBaseHoldType = function( self, newtype )
	self.BaseHoldType = newtype
end

//This is a god damn mess mostly because of legacy support, I need to redo this part for sure.
//OR at least make the old hold-types switch over to the new one
HOLDTYPE.GetActData = function( self, act ) 

	local base = self.Translations[ act ]
	local tbl
	
	if base then
		tbl = {}
		if istable( base ) then
			if base.Sequence then
				tbl.Sequence = base.Sequence
				tbl.Weight = base.Weight or 1
			else
				local seed = ( game.SinglePlayer() and math.random( 1, #base ) ) or util.SharedRandom( "wOS.AnimExtension." .. self:GetName() .. "[" .. act .. "]", 1, #base )
				local key = math.Round( seed )
				local innerbase = base[key]
				if istable( innerbase ) then
					tbl = innerbase
				elseif isstring( innerbase ) then
					tbl.Sequence = innerbase
					tbl.Weight = 1
				end
			end
		elseif isstring( base ) then
			tbl.Sequence = base
		end
	end

	return tbl
	
end

HOLDTYPE.__index = HOLDTYPE

function wOS.AnimExtension.HoldTypeMeta:CreateMetaType( tbl )
	setmetatable( tbl, HOLDTYPE )
end
--addons/z_anticrash_v1.4.6/lua/z_anticrash/shared/sh_physperf.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

if SH_ANTICRASH.SETTINGS.PHYSPERFMODE == false then return end

if SERVER then

	local defaultPerf = {
		LookAheadTimeObjectsVsObject = 0.5,
		LookAheadTimeObjectsVsWorld	= 1,
		MaxAngularVelocity = 7272.7275390625,
		MaxCollisionChecksPerTimestep = 50000,
		MaxCollisionsPerObjectPerTimestep = 10,
		MaxFrictionMass	= 2500,
		MaxVelocity	= 4000,
		MinFrictionMass	= 10
	}

	local customPerf = {
		LookAheadTimeObjectsVsObject = 0.5,
		LookAheadTimeObjectsVsWorld	= 1,
		MaxAngularVelocity = 7000,
		MaxCollisionChecksPerTimestep = 15000,
		MaxCollisionsPerObjectPerTimestep = 1,
		MaxFrictionMass	= 2500,
		MaxVelocity	= 4000,
		MinFrictionMass	= 10
	}

	timer.Simple(0, function()
		physenv.SetPerformanceSettings(customPerf)
	end)
	
end

if CLIENT then

	local defaultPerf = {
		LookAheadTimeObjectsVsObject = 0.5,
		LookAheadTimeObjectsVsWorld	= 1,
		MaxAngularVelocity = 3636.3637695313,
		MaxCollisionChecksPerTimestep =	250,
		MaxCollisionsPerObjectPerTimestep = 6,
		MaxFrictionMass	= 2500,
		MaxVelocity	= 2000,
		MinFrictionMass	= 10
	}
	
	local customPerf = {
		LookAheadTimeObjectsVsObject = 0.5,
		LookAheadTimeObjectsVsWorld	= 1,
		MaxAngularVelocity = 3600,
		MaxCollisionChecksPerTimestep =	200,
		MaxCollisionsPerObjectPerTimestep = 1,
		MaxFrictionMass	= 2500,
		MaxVelocity	= 2000,
		MinFrictionMass	= 10
	}
	
	local function InitPostEntity()
		physenv.SetPerformanceSettings(customPerf)
	end
	hook.Add( "InitPostEntity", "z_anticrash_InitPostEntityPhys", InitPostEntity)

end
--addons/z_anticrash_v1.4.6/lua/z_anticrash/client/cl_fonts.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

/* 
	Gmod and custom fonts are bugged for some OS users, incase the font isn't loaded we use our own fallback
*/

local customFont = file.Read( "resource/fonts/yugothil.ttf", "GAME" )
local isCustomFontLoaded = customFont ~= nil
local font = isCustomFontLoaded and "Yu Gothic Light" or "Roboto Th"

surface.CreateFont( "z_anticrash_menu_title", {
	font = "Roboto Cn",
	size = 28,
	weight = 500,
	additive = true,
	antialias = true
} )

surface.CreateFont( "z_anticrash_graph_label", {
	font = "Roboto Cn",
	size = 20,
	weight = 1,
	additive = true,
	antialias = true
} )

surface.CreateFont( "z_anticrash_graph_btn", {
	font = "Roboto Cn",
	size = 22,
	weight = 500,
	additive = true,
	antialias = true
} )

surface.CreateFont( "z_anticrash_flag_count", {
	font = "Roboto Cn",
	size = 20,
	weight = 500,
	additive = true,
	antialias = true
} )

surface.CreateFont( "z_anticrash_global_btn", {
	font = "Roboto Cn",
	size = 18,
	weight = 500,
	additive = true,
	antialias = true
} )

surface.CreateFont( "z_anticrash_user_info_label", {
	font = "Roboto Cn",
	size = 16,
	weight = 500,
	additive = true,
	antialias = true
} )

surface.CreateFont( "z_anticrash_user_info_button", {
	font = "Roboto Cn",
	size = 16,
	weight = 500,
	additive = true,
	antialias = true
} )

surface.CreateFont( "z_anticrash_user_info_search", {
	font = "Roboto Cn",
	size = 16,
	weight = 500,
	additive = true,
	antialias = true
} )
--addons/z_anticrash_v1.4.6/lua/z_anticrash/client/cl_sound.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER]]

local sounds = {
	["catPress"] = "z_anticrash/cat_press.mp3",
	["plyPress"] = "z_anticrash/cat_press.mp3",
	["runAntiLag"] = "buttons/button14.wav",
	["gmodPress"] = "buttons/button15.wav",
	["togglePress"] = "garrysmod/content_downloaded.wav"
}

-- precache
for _, path in pairs( sounds ) do
	sound.Play( path, Vector(), 20, 100, 0 )
end

function CL_ANTICRASH.PlaySound( id )
	surface.PlaySound( sounds[id] )
end
--addons/z_anticrash_v1.4.6/lua/autorun/z_anticrash_version.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

/*
	This file is used to check if Anti-Crash is using the latest version
*/

local gmodstoreLink = "https://www.gmodstore.com/api/v3/products/%s/versions"
local apiKey = "bb7fc6fd-d28c-4bcb-b864-db6a409fa50f|l4OpPCggdfo0jd1xBBtEiLcl3SGoWLP4tNjXDwjZ"
local antiCrashID = "e751a065-bea3-4722-95b5-35fe2607415f"
local antiCrashVersion = "1.5.1"
local updateMsg = "[Anti-Crash] New version %s available! (curr: %s)"

local function VersionCheck()

	-- Retrieve versions from gmodstore
	http.Fetch( string.format(gmodstoreLink,antiCrashID),
		function( body, len, headers, code )
				
			local response = util.JSONToTable(body)

			-- Gmodstore api problem -> do nothing
			if response == nil then return end
			
			local data = response.data

			if data and istable(data) and #data > 0 then
			
				local latestVersion = data[1].name
				local latestVersionNum = tonumber(string.Replace( latestVersion, '.', '' ))
				local installedVersionNum = tonumber(string.Replace( antiCrashVersion, '.', '' ))
				
				if installedVersionNum < latestVersionNum then
					
					local updateMsg = string.format(updateMsg,latestVersion,antiCrashVersion)
					
					if SERVER then
						print(updateMsg)
					end
					
					SH_ANTICRASH.VARS.LATESTVERSION = false
					SH_ANTICRASH.VARS.LATESTVERSIONMSG = updateMsg
					
				end
				
			end

		end,
		function( error )
			-- Do nothing
		end,
		{
			["Authorization"] = "Bearer "..apiKey
		}
	)
	
end
timer.Simple(0, VersionCheck)
--addons/aoc_adblocktyler/lua/autorun/client/cl_trump_for_king.lua:
--[[
local white = Color(255,255,255)
local cyan = Color(0,255,255)
local yellow = Color(255,255,0)
local red = Color(255,0,0)
-- ARMIES OF ANGRY LOSERS INBOUND TO MY DMS.
-- complies with all the workshop ruls so dont bother bitching to me about it.
-- it's a single (rotary) advert that advertises one of twenty random messages launch.
-- the "link he adwertizzed!!!1" is actually the connection ip, i host my own server so I can do neet things like that, sugma.

-- PS: Donald Trump is a saint amongst men.
-- Vote Desantis!
 
local mesg ={
	"Join the intense world of police roleplay in Energized Networks today!",
	"Ready for high-octane action? Play Energized Networks now!",
	"Looking for a custom-coded police roleplay server? Energized Networks has you covered!",
	"Build your criminal empire or uphold the law on Energized Networks!",
	"Energized Networks: where gangs, drugs, and money printing are all fair game.",
	"Can you handle the heat? Play Energized Networks and find out.",
	"Join the ranks of the police force or become a notorious criminal on Energized Networks.",
	"Customize your gameplay experience like never before on Energized Networks.",
	"Take on the challenge of gang control and store robberies on Energized Networks.",
	"Energized Networks: the ultimate destination for adrenaline junkies.",
	"Looking for a thrilling and immersive gaming experience? Play Energized Networks now!",
	"Experience the intense gameplay of Energized Networks for yourself.",
	"Want to be a part of an exciting community? Join Energized Networks today.",
	"Energized Networks: where the action never stops.",
	"Choose your path and make your mark in the world of Energized Networks.",
	"Don't just play a game, live it on Energized Networks!",
	"Ready for the ultimate test of your skills? Play Energized Networks now!",
	"Join a community of like-minded gamers and take on the world of Energized Networks.",
	"Take on the role of a police officer or a criminal mastermind on Energized Networks.",
	"Energized Networks: the perfect place for those who love intense gameplay and endless possibilities.",
}

timer.Simple(math.random(60,90), function()
	chat.AddText(white, "[", cyan, "ENERGIZED", white, "] ", yellow, table.Random(mesg), red, " You can join the server here: 51.81.35.69 (gmod.energy)")
end)]]
--addons/wos-passiveevent-ageo/lua/wos/pes/addons/scene/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































local addon = {}

local recordingScenes = {}

local textData = {
	Color(255,150,150),
	"[Scene System] "
}

net.Receive("wOS.PES.Scene.StartRecording", function()

	local entIndex = net.ReadDouble()

	for index, dermaE in pairs(recordingScenes) do
		if !IsValid(dermaE) then continue end
		if table.HasValue( dermaE.data, entIndex ) then return end
		dermaE.data[#dermaE.data + 1] = entIndex
	end
end)

addon.StartRecording = function(dermaElement)
	for index, dermaE in pairs(recordingScenes) do
		if IsValid(dermaE) then continue end
		table.RemoveByValue(recordingScenes, dermaE)
	end

	local len = #recordingScenes

	recordingScenes[len + 1] = dermaElement

	if len == 0 then
		chat.AddText(textData[1], textData[2], color_white, "Please spawn props and position them how you want to. Once you are finished open the menu again and press the recording button, ", Color(150,150,150), "if you dont do this it won't save!!!")
	end

	chat.AddText( textData[1], textData[2], color_white, tostring(len + 1), " Active Recordings")

	local decomp = dermaElement.data or {}
	local comp = wOS.SFS_EXTERN:Compress( decomp )

	local checksum = SysTime()

    local NET_CAP = 55000
    if #comp < NET_CAP then
        net.Start( "wOS.PES.Scene.StartRecording" )
            net.WriteDouble( checksum )
            net.WriteUInt( 1, 32 )
            net.WriteUInt( 1, 32 )
            net.WriteUInt( #comp, 32 )
            net.WriteData( comp )
        net.SendToServer()
        return
    end

    local total_segments = math.ceil( #comp / NET_CAP )

    for i=1, total_segments do
        local lim
        if i != total_segments then
            lim = i*NET_CAP
        end
		local str = string.sub( comp, ( (i - 1)*NET_CAP ) + 1, lim )
		timer.Simple( (i-1)*0.5, function() 
			net.Start( "wOS.PES.Scene.StartRecording" )
				net.WriteDouble( checksum )
				net.WriteUInt( total_segments, 32 )
				net.WriteUInt( i, 32 )
				net.WriteUInt( #str, 32 )
				net.WriteData( str )       
			net.SendToServer()
		end )
    end

end

addon.StopRecording = function(dermaElement)
	table.RemoveByValue(recordingScenes, dermaElement)
	if #recordingScenes > 0 then return end
	net.Start("wOS.PES.Scene.StopRecording")
	net.SendToServer()
end

hook.Add("HUDPaint", "wOS.PES.SceneRecord", function()
	if #recordingScenes <= 0 then return end
	draw.SimpleText("You are currently recording a scene","DermaLarge", ScrW()/2, ScrH()- 100, color_white, 1)
end)

local function ClearRecording()
	net.Start( "wOS.PES.Scene.ClearRecording" )
	net.SendToServer()
	recordingScenes = {}
end

hook.Add( "wOS.PES.OnCreatorClose", "wOS.PES.Scene.DeleteStuff", function( creator_type )
	if #recordingScenes <= 0 then return end
	ClearRecording()
end )

hook.Add( "wOS.PES.OnNodeDelete", "wOS.PES.Scene.DeleteStuff", function( node )
	timer.Simple( 0, function()
		if #recordingScenes <= 0 then return end
		for k, dea in pairs( recordingScenes ) do
			if IsValid( dea ) then continue end
			recordingScenes[ k ] = nil
		end
		if #recordingScenes > 0 then return end
		ClearRecording()
	end )
end ) 

wOS.PES.Modules:RegisterAddon( "scene", addon )
--addons/wos-passiveevent-ageo/lua/wos/pes/addons/sound/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

local addon = {}



local function IsUrl(str)
    local pattern = "https?://%S+"
    return string.match(str, pattern) ~= nil
end

net.Receive("wOS.PES.Music", function()
    local path = net.ReadString()
    local vol = net.ReadFloat()
    local dur = net.ReadUInt(12)

    AOCRP:PlayMusic(path)
end)

net.Receive("wOS.PES.Sound", function()
    local path = net.ReadString()
    local vol = net.ReadFloat()
    local dur = net.ReadUInt(12)

    local soundStation = nil

    if IsUrl(path) then
        local soundObject = sound.PlayURL(path, "noblock", function(station) 
            if (IsValid(station)) then
                station:SetVolume(1)
                station:Play()

                if dur < 1 then
                    dur = station:GetLength()
                end

                soundStation = station
            end
        end)
    else
        local soundObj = sound.PlayFile("sound/" .. path, "3d", function(station)
            if (IsValid(station)) then
                station:Play()
                station:SetVolume(vol)
                station:SetPos(LocalPlayer():GetPos())
            end

            if dur > 0 then
                timer.Simple(dur, function()
                    if IsValid(station) then
                        station:Remove()
                    end
                end)
            end
        end)
    end
end)

wOS.PES.Modules:RegisterAddon("sound", addon)
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/dropdown.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Dropdown"
VAR.DirtyValidate = true
VAR.IsValid = function(varTable, value)
    if not isstring(value) then
        return false
    end

    if value == "" then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local frame = vgui.Create("DPanel")
    frame:SetTall( 50 )

    local comboBox = vgui.Create("DComboBox",frame)
    comboBox:SetTall( 20 )
    comboBox:Dock(TOP)
	comboBox:DockMargin(0,0,0,0)

    varTable.Values = varTable.Values or {}
    if isstring( varTable.Values ) and string.Left(varTable.Values, 6) == "FUNC::" then
        local func_name = string.Replace( varTable.Values, "FUNC::", "" )
        local layers = string.Split( func_name, "." )

        local func = _G
        for _, layer in ipairs( layers ) do
            func = func[ layer ] 
        end
        varTable.Values = func()
    end

    for _, choice in pairs(varTable.Values) do
        comboBox:AddChoice(choice)
    end

    if isstring(value) then
        comboBox:SetValue(value)
    else
        if isstring(varTable.Default) then
            comboBox:SetValue(varTable.Default )
        end
    end

    frame.GetValue = function( self )
        return comboBox:GetValue()
    end 

    return frame
end

VAR.GetValue = function(comboBox)
    return comboBox:GetValue()
end


return VAR
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/model.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--



local VAR = {}

VAR.Name = "Model"
VAR.UseTool = true

VAR.ToolTips = {
    { text = "Select the entity to save the model properties from", key = "gui/lmb.png", },
}

VAR.IsValid = function(varData, value)
    if not isstring(value) then
        return false
    end

    if value == "" then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local panel = vgui.Create("DPanel")
    panel.Value = value

    function panel:Paint(ww, hh)
        if isstring(self.Value) then
            draw.SimpleText("Model set to: " .. tostring(self.Value), nil, ww * 0.5, hh * 0.5, Color(125, 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        else
            draw.SimpleText("Model needs to be set!", nil, ww * 0.5, hh * 0.5, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end

    return panel
end

VAR.PrimaryAttack = function(wep, ply, dermaElement)
    dermaElement.Data = dermaElement.Data

    local ent = ply:GetEyeTrace().Entity
    if not IsValid( ent ) then return end
    dermaElement.Value = ent:GetModel()
end

VAR.GetValue = function(panel)
    return panel.Value
end

return VAR

--addons/wos-passiveevent-ageo/lua/wos/css/config/sh_config.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.CombatSim = wOS.CombatSim or {}

-- wOS.CombatSim.Difficulties = {}
-- 
-- wOS.CombatSim.Difficulties[ 1 ] = { 
-- 	Name = "Practice",
-- 	Icon = "wos/halo/css/normal.png",
-- }
-- 
-- wOS.CombatSim.Difficulties[ 2 ] = { 
-- 	Name = "Normal",
-- 	Icon = "wos/halo/css/normal.png",
-- }
-- 
-- wOS.CombatSim.Difficulties[ 3 ] = { 
-- 	Name = "Heroic",
-- 	Icon = "wos/halo/css/heroic.png",
-- }
-- 
-- wOS.CombatSim.Difficulties[ 4 ] = { 
-- 	Name = "Legendary",
-- 	Icon = "wos/halo/css/legend.png",
-- }
-- 

wOS.CombatSim.FrameColor = Color( 0, 0, 0, 155 )
wOS.CombatSim.BackgroundColor = Color( 0, 0, 0, 200 )
wOS.CombatSim.TextColor = Color( 155, 155, 155, 255 )
--addons/billy_gas/lua/vgui/bvgui/button.lua:
--/// Button Color Enumerations ///--

bVGUI.BUTTON_COLOR_BLUE   = bVGUI.COLOR_GMOD_BLUE
bVGUI.BUTTON_COLOR_GREEN  = Color(57, 202, 116)
bVGUI.BUTTON_COLOR_RED    = Color(229, 77, 66)
bVGUI.BUTTON_COLOR_ORANGE = Color(230, 126, 34)
bVGUI.BUTTON_COLOR_PURPLE = Color(154, 91, 180)
bVGUI.BUTTON_COLOR_YELLOW = Color(240, 195, 48)
bVGUI.BUTTON_COLOR_GREY   = Color(62, 62, 62)

--/// bVGUI.Button ///--

local PANEL = {}

function PANEL:Init()
	self:SetCursor("hand")
	self:SetTall(30)
	self:SetMouseInputEnabled(true)
	self:DockPadding(0,0,0,4)

	self.OriginalBarColor = bVGUI.INFOBAR_COLOR_GREY
	self.TargetBarColor = self.OriginalBarColor
	self.BorderColor = bVGUI.DarkenColor(self.OriginalBarColor, 0.4)

	self.Label = vgui.Create("DLabel", self)
	self.Label:Dock(FILL)
	self.Label:SetContentAlignment(5)
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
end

function PANEL:SetFont(font)
	self.Label:SetFont(font)
end

function PANEL:SetText(text)
	self.Text = text
	self.Label:SetText(text)
end
function PANEL:GetText()
	return self.Text
end

function PANEL:SetColor(col_enum)
	self.Label:SetTextColor(bVGUI.TextColorContrast(col_enum))
	self.OriginalBarColor = col_enum
	self.TargetBarColor = self.OriginalBarColor
	self.BorderColor = bVGUI.DarkenColor(self.OriginalBarColor, 0.4)
	if (self.ColorInterpolation) then
		self.ColorInterpolation = bVGUI.LerpColor(self.OriginalBarColor, self.OriginalBarColor, .25)
	end
end
function PANEL:GetColor()
	return self.OriginalBarColor
end

function PANEL:OnCursorEntered()
	if (self.Tooltip) then
		bVGUI.CreateTooltip(self.Tooltip)
	end
	if (self.Disabled) then return end

	self.TargetBarColor = bVGUI.LightenColor(self.OriginalBarColor, 0.2)
	self.ColorInterpolation = bVGUI.LerpColor(self.OriginalBarColor, self.TargetBarColor, .25)
end
function PANEL:OnCursorExited()
	if (self.Tooltip) then
		bVGUI.DestroyTooltip()
	end
	if (self.Disabled) then return end

	self.ColorInterpolation = bVGUI.LerpColor(self.TargetBarColor, self.OriginalBarColor, .25)
	self.TargetBarColor = self.OriginalBarColor

	if (self.DrawBorder ~= false) then
		self:DockPadding(0,0,0,4)
		self:InvalidateLayout(true)
	end
end
function PANEL:OnMousePressed()
	if (self.Disabled) then return end

	self.ColorInterpolation = nil
	self.TargetBarColor = self.BorderColor
	if (self.DrawBorder ~= false) then
		self:DockPadding(0,0,0,0)
		self:InvalidateLayout(true)
	end
end
function PANEL:OnMouseReleased()
	if (self.Disabled) then return end

	if (self:IsHovered()) then
		self.TargetBarColor = bVGUI.LightenColor(self.OriginalBarColor, 0.2)
	else
		self.TargetBarColor = self.OriginalBarColor
	end
	if (self.DrawBorder ~= false) then
		self:DockPadding(0,0,0,4)
		self:InvalidateLayout(true)
	end

	if (self.ButtonSound and GAS) then
		GAS:PlaySound(self.ButtonSound)
	end
	if (self.DoClick) then
		self:DoClick()
	end
end

function PANEL:Paint(w,h)
	if (self.ColorInterpolation) then
		self.ColorInterpolation:DoLerp()
		surface.SetDrawColor(self.ColorInterpolation:GetColor())
	else
		surface.SetDrawColor(self.TargetBarColor)
	end
	if (self.DrawBorder ~= false) then
		local col
		if (self.ColorInterpolation) then
			col = self.ColorInterpolation:GetColor()
		else
			col = self.TargetBarColor
		end
		draw.RoundedBox(4, 0, 0, w, h, self.BorderColor)
		draw.RoundedBoxEx(4, 0, 0, w, h - 4, col, true, true)
	else
		surface.DrawRect(0,0,w,h)
	end
end

function PANEL:SetDisabled(disabled)
	self.Disabled = disabled
	if (disabled) then
		self:SetCursor("no")
		if (self.ColorInterpolation) then
			self.ColorInterpolation = bVGUI.LerpColor(self.TargetBarColor, bVGUI.BUTTON_COLOR_GREY, .25)
		end
		self.TargetBarColor = bVGUI.BUTTON_COLOR_GREY
	else
		self:SetCursor("hand")
		if (self.ColorInterpolation) then
			self.ColorInterpolation = bVGUI.LerpColor(self.TargetBarColor, self.OriginalBarColor, .25)
		end
		self.TargetBarColor = self.OriginalBarColor
	end
	self.BorderColor = bVGUI.DarkenColor(self.TargetBarColor, 0.4)
end
function PANEL:GetDisabled()
	return self.Disabled
end

function PANEL:SetDrawBorder(draw_border)
	self.DrawBorder = draw_border
	if (draw_border == false) then
		self:DockPadding(0,0,0,0)
	else
		self:DockPadding(0,0,0,5)
	end
end
function PANEL:GetDrawBorder()
	return self.DrawBorder
end

function PANEL:SetTooltip(tooltip)
	self.Tooltip = tooltip
	self.Tooltip.VGUI_Element = self
end
function PANEL:RemoveTooltip()
	if (IsValid(self.Tooltip)) then
		bVGUI.DestroyTooltip()
	end
	self.Tooltip = nil
end

function PANEL:SetSound(sound_name)
	self.ButtonSound = sound_name
end

derma.DefineControl("bVGUI.Button", nil, PANEL, "DPanel")

local PANEL = {}

function PANEL:Init()
	self:SetTall(30)
	self.Button = vgui.Create("bVGUI.Button", self)
end

function PANEL:PerformLayout()
	self.Button:Center()
end

derma.DefineControl("bVGUI.ButtonContainer", nil, PANEL, "bVGUI.BlankPanel")
--addons/billy_gas/lua/vgui/bvgui/tabs.lua:
--/// bVGUI.Tabs ///--

local PANEL = {}

function PANEL:Init()
	self.Tabs = {}
	self.TabPages = {}

	self.EnabledTabs = {}
	self.EnabledTabPages = {}

	self.SelectedTab = 0

	self.BarX = bVGUI.Lerp(0,0,.5)
	self.BarColor = bVGUI.LerpColor(bVGUI.COLOR_BLACK,bVGUI.COLOR_BLACK,.5)
end

function PANEL:OnRemove()
	for _,v in pairs(self.TabPages) do
		v:Remove()
	end
end

function PANEL:CalculateEnabledTabs()
	self.EnabledTabs = {}
	self.EnabledTabPages = {}
	for i,v in pairs(self.Tabs) do
		if (v:GetEnabled()) then
			v.EnabledTabIndex = table.insert(self.EnabledTabs, v)
			self.TabPages[i].EnabledTabIndex = table.insert(self.EnabledTabPages, self.TabPages[i])
		end
	end
end

function PANEL:AddTab(tab_name, tab_color, enabled)
	local tab_index = #self.Tabs + 1
	local tab = vgui.Create("bVGUI.Tab", self)
	self.Tabs[tab_index] = tab
	tab.TabIndex = tab_index
	tab:SetColor(tab_color)
	tab:SetText(tab_name)

	local tab_page = vgui.Create("bVGUI.TabPage", self:GetParent())
	self.TabPages[tab_index] = tab_page
	tab_page:SetTab(tab)
	tab_page:SetTabs(self)

	tab:SetTabPage(tab_page)
	tab:SetEnabled(enabled ~= false)
	if (self.SelectedTab == 0 and enabled ~= false) then
		self.SelectedTab = tab_index
		self.BarColor:SetColor(tab:GetColor())
	end

	return tab_page, tab
end

function PANEL:Paint(w,h)
	surface.SetDrawColor(bVGUI.COLOR_SLATE)
	surface.DrawRect(0,0,w,h)
end

function PANEL:PaintOver(w,h)
	if (self.SelectedTab > 0) then
		self.BarX:DoLerp()
		self.BarColor:DoLerp()

		surface.SetDrawColor(bVGUI.COLOR_DARK_GREY)
		surface.DrawRect(0, h - 3, w, 3)

		surface.SetDrawColor(self.BarColor:GetColor())
		surface.DrawRect(self.BarX:GetValue(), h - 3, self:GetWide() / #self.EnabledTabs, 3)
	end
end

function PANEL:PerformLayout()
	self:CalculateEnabledTabs()

	local tab_width = self:GetWide() / #self.EnabledTabs
	for i,v in ipairs(self.EnabledTabs) do
		v:SetSize(tab_width, self:GetTall())
		local _,y = v:GetPos()
		v:SetPos((i - 1) * tab_width, y)
	end

	if (self.SelectedTab > 0) then
		for i,v in ipairs(self.EnabledTabPages) do
			local _,y = self:GetPos()
			v:SetSize(self:GetWide(), v:GetParent():GetTall() - self:GetTall() - y)
			if (not v.m_AnimList or #v.m_AnimList == 0) then
				v:SetPos((i - self.Tabs[self.SelectedTab].EnabledTabIndex) * self:GetWide() + (self:GetPos()), y + self:GetTall())
			end
		end

		local bar_x = (self.Tabs[self.SelectedTab]:GetPos())
		if (not self.EnabledTabs_Check or self.EnabledTabs_Check ~= #self.EnabledTabs) then
			self.EnabledTabs_Check = #self.EnabledTabs
			self.BarX:SetValue(bar_x)
		end
		if (self.BarX.to ~= bar_x) then
			self.BarX:SetValue(bar_x)
		end
	end
end

function PANEL:SelectTab(tab_index, suppress_click_func)
	if self.MovingTo == tab_index then return end
	self.MovingTo = tab_index
	local tab = self.Tabs[tab_index]

	local prev_tab = self.SelectedTab
	self.SelectedTab = tab.TabIndex

	self.BarX:SetTo((tab:GetPos()))
	self.BarColor:SetTo(tab:GetColor())

	for i,v in pairs(self.EnabledTabPages) do
		local _,y = v:GetPos()
		v:Stop()
		v:MoveTo((i - self.Tabs[self.SelectedTab].EnabledTabIndex) * v:GetWide() + (self:GetPos()), y, 0.5, 0, -1, function()
			self:InvalidateLayout(true)
			v:InvalidateChildren(true)
		end)
	end

	if (not suppress_click_func and tab.ClickFunction) then
		tab:GetTabPage().ExecClickFunction = tab.ClickFunction
		timer.Simple(0, function()
			if (self.OnTabSelected and prev_tab ~= nil) then
				self:OnTabSelected(self.Tabs[prev_tab], tab)
			end
		end)
	else
		if (self.OnTabSelected and prev_tab ~= nil) then
			self:OnTabSelected(self.Tabs[prev_tab], tab)
		end
	end
end

derma.DefineControl("bVGUI.Tabs", nil, PANEL, "DPanel")

--/// bVGUI.Tab ///--

local PANEL = {}

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")

	self.Label = vgui.Create("DLabel", self)
	self.Label:Dock(FILL)
	self.Label:SetContentAlignment(5)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 16))
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetText("Tab")
end

function PANEL:OnMouseReleased()
	self:GetParent():SelectTab(self.TabIndex)
end

function PANEL:SetEnabled(enabled)
	self:SetVisible(enabled)
	self:GetTabPage():SetVisible(enabled)
	if (enabled ~= self.Enabled) then
		self.Enabled = enabled
		self:GetParent():InvalidateLayout(true)
	else
		self.Enabled = enabled
	end
end
function PANEL:GetEnabled()
	return self.Enabled
end

function PANEL:SetColor(color)
	self.Color = color
end
function PANEL:GetColor()
	return self.Color
end

function PANEL:SetText(name)
	self.Name = name
	self.Label:SetText(self.Name)
end
function PANEL:GetText()
	return self.Name
end

function PANEL:SetTabPage(tabpage)
	self.TabPage = tabpage
end
function PANEL:GetTabPage()
	return self.TabPage
end

function PANEL:SetFunction(func)
	self.ClickFunction = func
end
function PANEL:GetFunction()
	return self.ClickFunction
end

function PANEL:Paint(w,h)
	if (self:GetParent().SelectedTab == self.TabIndex) then
		surface.SetMaterial(bVGUI.MATERIAL_GRADIENT_LIGHT)
		surface.DrawTexturedRect(0,0,w,h)
	end
end

derma.DefineControl("bVGUI.Tab", nil, PANEL, "DPanel")

--/// bVGUI.TabPage ///--

local PANEL = {}

function PANEL:SetTab(tab)
	self.MyTab = tab
end
function PANEL:GetTab()
	return self.MyTab
end

function PANEL:SetTabs(tabs)
	self.MyTabs = tabs
end
function PANEL:GetTabs()
	return self.MyTabs
end

function PANEL:Think()
	if (self.ExecClickFunction) then
		self.ExecClickFunction(self:GetTab())
		self.ExecClickFunction = nil
	end
end

derma.DefineControl("bVGUI.TabPage", nil, PANEL, "bVGUI.BlankPanel")
--addons/billy_gas/lua/vgui/openpermissions_addon.lua:
local function markup_Escape(str)
	return (tostring(str):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;"))
end

local PANEL = {}

function PANEL:Init()
	self:SetText("")
end

function PANEL:GenerateMarkup(text, maxwidth)
	self.Addon.Markup = markup.Parse("<color=255,255,255>" .. markup_Escape(text) .. "</color>", maxwidth)
end

function PANEL:Setup(id, options)
	self.Addon = {}

	self.Addon.Name = options.Name or id
	self.Addon.Color = options.Color or OpenPermissions.COLOR_BLACK

	if (options.Logo and options.Logo.Path and options.Logo.Width and options.Logo.Height) then
		self.Addon.Logo = {
			Material = Material(options.Logo.Path),
			Width = options.Logo.Width / 2,
			Height = options.Logo.Height / 2
		}
	end
end

function PANEL:Paint(w,h)
	derma.SkinHook("Paint", "Button", self, w, h)

	if (not self.Addon) then return end

	surface.SetDrawColor(self.Addon.Color)
	surface.DrawRect(5, 5, w - 10, h - 10)

	if (self.Addon.Logo) then
		local x,y = w / 2 - self.Addon.Logo.Width / 2, h / 2 - self.Addon.Logo.Height / 2
		surface.SetDrawColor(255,255,255)
		surface.SetMaterial(self.Addon.Logo.Material)
		surface.DrawTexturedRect(x, y, self.Addon.Logo.Width, self.Addon.Logo.Height)
	elseif (self.Addon.Markup) then
		self.Addon.Markup:Draw(w / 2, h / 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	else
		self:GenerateMarkup(self.Addon.Name, w - 20)
	end
end

derma.DefineControl("OpenPermissions.Addon", nil, PANEL, "DButton")
--addons/billy_gas/lua/vgui/openpermissions_tree.lua:
local PANEL = {}

AccessorFunc( PANEL, "m_bShowIcons", "ShowIcons" )
AccessorFunc( PANEL, "m_iIndentSize", "IndentSize" )
AccessorFunc( PANEL, "m_iLineHeight", "LineHeight" )
AccessorFunc( PANEL, "m_pSelectedItem", "SelectedItem" )
AccessorFunc( PANEL, "m_bClickOnDragHover", "ClickOnDragHover" )

function PANEL:Init()

	self:SetShowIcons( true )
	self:SetIndentSize( 14 )
	self:SetLineHeight( 17 )

	self.RootNode = self:GetCanvas():Add( "DTree_Node" )
	self.RootNode:SetRoot( self )
	self.RootNode:SetParentNode( self )
	self.RootNode:Dock( TOP )
	self.RootNode:SetText( "" )
	self.RootNode:SetExpanded( true, true )
	self.RootNode:DockMargin( 0, 4, 0, 0 )

	self:SetPaintBackground( true )

end

function PANEL:Root()
	return self.RootNode
end

function PANEL:AddNode( strName, strIcon )

	return self.RootNode:AddNode( strName, strIcon )

end

function PANEL:ChildExpanded( bExpand )

	self:InvalidateLayout()

end

function PANEL:ShowIcons()

	return self.m_bShowIcons

end

function PANEL:ExpandTo( bExpand )
end

function PANEL:SetExpanded( bExpand )
end

function PANEL:Clear()
	self:Root():Clear()
end

function PANEL:Paint( w, h )

	derma.SkinHook( "Paint", "Tree", self, w, h )
	return true

end

function PANEL:DoClick( node )
	return false
end

function PANEL:DoRightClick( node )
	return false
end

function PANEL:SetSelectedItem( node )

	if ( IsValid( self.m_pSelectedItem ) ) then
		self.m_pSelectedItem:SetSelected( false )
	end

	self.m_pSelectedItem = node

	if ( node ) then
		node:SetSelected( true )
		node:OnNodeSelected( node )
	end

end

function PANEL:OnNodeSelected( node )
end

function PANEL:MoveChildTo( child, pos )

	self:InsertAtTop( child )

end

function PANEL:LayoutTree()

	self:InvalidateChildren( true )

end

derma.DefineControl("OpenPermissions.Tree", nil, PANEL, "OpenPermissions.ScrollPanel")
--gamemodes/starwarsrp/gamemode/modules/terminals/sh_netdata.lua:
local Entity = FindMetaTable("Entity")

if SERVER then
	function Entity:NetDataUpdate()
		net.Start("netdata")
		net.WriteEntity(self)
		net.WriteUInt(self.NetDataHash and tonumber(util.CRC(self:NetDataHash())) or 0, 32)
		self:NetDataWrite()
		net.SendPVS(self:GetPos())
	end
	
	util.AddNetworkString("netdata")
	net.Receive("netdata", function(len, cl)
		local ent = net.ReadEntity()
		local prevHash = net.ReadUInt(32)
		
		if IsValid(ent) and ent.NetDataWrite then
			local curHash = ent.NetDataHash and tonumber(util.CRC(ent:NetDataHash())) or 0
			if curHash == 0 or prevHash == 0 or curHash ~= prevHash then
				net.Start("netdata")
				net.WriteEntity(ent)
				net.WriteUInt(curHash, 32)
				ent:NetDataWrite()
				net.Send(cl)
			end
		end
	end)
end
if CLIENT then
	hook.Add("NotifyShouldTransmit", "NetDataRequest", function(e, should)
		if e.NetDataRead and should then
			local prevHash = e._NetDataPrevHash or 0
			
			net.Start("netdata")
			net.WriteEntity(e)
			net.WriteUInt(prevHash, 32)
			net.SendToServer()
			
			if cvars.Number("developer") > 0 then
				print("[NetData] Asking for netdata due to PVS for " .. tostring(e) .. " using hash " .. prevHash)
			end
		end
	end)
	hook.Add("NetworkEntityCreated", "NetDataRequest", function(e)
		local sent = scripted_ents.GetStored(e:GetClass())
		if e.NetDataRead or (sent and sent.t and sent.t.NetDataRead) then
			net.Start("netdata")
			net.WriteEntity(e)
			net.WriteUInt(0, 32)
			net.SendToServer()
			
			if cvars.Number("developer") > 0 then
				print("[NetData] Asking for netdata due to NEC for " .. tostring(e))
			end
		end
	end)

	net.Receive("netdata", function(len, cl)
		local ent = net.ReadEntity()
		local hash = net.ReadUInt(32)
		if IsValid(ent) then
			if cvars.Number("developer") > 0 then
				print("[NetData] Received netdata for " .. tostring(ent) .. " with hash " .. hash)
			end
			ent:NetDataRead()
			ent._NetDataPrevHash = hash
		end
	end)
end

if SERVER then
	util.AddNetworkString("entaction")
	net.Receive("entaction", function(len, cl)
		local ent = net.ReadEntity()
		if IsValid(ent) and ent.ReceiveNetAction then
			ent:ReceiveNetAction(cl)
		end
	end)
end
if CLIENT then
	function Entity:StartNetAction(unreliable)
		net.Start("entaction", unreliable)
		net.WriteEntity(self)
	end
end
--gamemodes/starwarsrp/gamemode/modules/main/cl_aocapi.lua:
-- Kiwonta der Hurensohn hat mitgeholfen <3

AOCRP.API = AOCRP.API or {}



function AOCRP.API:Request(requestid, callback, vars, errorCallBack)


        local startTime = CurTime()
        vars = vars or ""

        vars = util.TableToJSON(vars)

        errorCallBack = errorCallBack or function() end
        local sharedSecret = self.SharedKey or ""

        local url = AOCRP.Config.APIUrl.."?t="..requestid.."&auth="..sharedSecret.."&data="..vars


        http.Fetch( url,
            
            -- onSuccess function
            function( body, length, headers, code )
            
                if body == "Verpiss dich!" then
                    AOCRP:Kick(LocalPlayer(),"Verbindungsfehler #VPD ("..requestid..") - Versuche neu zu verbinden, sollte das Problem fortbestehen, melde dich im Support.")
                    return
                end
                --tbl = util.JSONToTable(body)
                if body == "idiot" then
                    print("[AOC-API] Anfrage enthielt keine Angabe zur Funktion")
                    --errorCallBack("idiot")
                    AOCRP:Kick(LocalPlayer(),"Verbindungsfehler #ID ("..requestid..") - Versuche neu zu verbinden, sollte das Problem fortbestehen, melde dich im Support.")
                    return
                end

                if body == "staubsaugerficker" then
                    print("[AOC-API] Anfrage zur "..requestid.. " nicht möglich. Anfragetyp existiert nicht.")
                    --errorCallBack("staubsaugerficker")
                    AOCRP:Kick(LocalPlayer(),"Verbindungsfehler #SSF ("..requestid..") - Versuche neu zu verbinden, sollte das Problem fortbestehen, melde dich im Support.")
                    return
                end

                if body == "hurensohn" then
                    print("[AOC-API] Unauthorisierte Anfrage durch fehlenden Schlüssel zum Typ "..requestid)
                    --errorCallBack("hurensohn")
                    AOCRP:Kick(LocalPlayer(),"Verbindungsfehler #HS ("..requestid..") - Versuche neu zu verbinden, sollte das Problem fortbestehen, melde dich im Support.")
                    return
                end

                if body == "einbrecher" then
                    print("[AOC-API] Unauthorisierte Anfrage zum Typ "..requestid)
                    --errorCallBack("einbrecher")
                    AOCRP:Kick(LocalPlayer(),"Verbindungsfehler #EB ("..requestid..") - Versuche neu zu verbinden, sollte das Problem fortbestehen, melde dich im Support.")
                    return
                end

                if body == "arschloch" then
                    print("[AOC-API] Anfrage enthielt fehlerhaften Datensatz zum Typ "..requestid)
                    AOCRP:Kick(LocalPlayer(),"Verbindungsfehler #AL ("..requestid..") - Versuche neu zu verbinden, sollte das Problem fortbestehen, melde dich im Support.")
                end

           
                local tbl = util.JSONToTable(body)


                if !istable(tbl) then
                    print("[AOCRP] API-Datenfehler. (TBL) ("..requestid..")")
                    AOCRP:Kick(LocalPlayer(),"Verbindungsfehler #TBL ("..requestid..") - Versuche neu zu verbinden, sollte das Problem fortbestehen, melde dich im Support.")
                    return
                end

                callback(tbl)

            end,

            -- onFailure function
            function( message )
                print("[AOCRP] API-Verbindungsfehler. ("..message..")")
                
                errorCallBack(message)
                
            end,

            -- header example
            { 
            }
        ) 
end



--[[         FetchDataFromAOCAPI("getchars", function(data) 
        
            print(data)
            PrintTable(data)

        end, { ["steamid"] = ply:SteamID64() }, function(err) print(err) end)   ]]
--gamemodes/starwarsrp/gamemode/modules/gui/cl_hud.lua:
AOCRP.HUD = AOCRP.HUD or {}



AOCDerma:RegisterFont("AOCRP.ADMIN_HUD_TEXT", "Agency FB", 25, 1000)



function AOCRP.HUD:AusbilderWarnung()

    local cadetCount = 0
    local ausbilderCount = 0
    for k, v in ipairs(player.GetHumans()) do
        if v:GetGearID() == AOCRP.Config.DefaultGear then
            cadetCount = cadetCount + 1
        end
        if v:GetGearID() == 164 then
            ausbilderCount = ausbilderCount + 1
        end
    end

    if LocalPlayer():GetAusbilder() then
        if cadetCount > 0 and ausbilderCount < 1 then 
            AOCDerma:DrawTextShadow(""..cadetCount.." Kadett(en) benötigen Ausbildung",AOCDerma:xFont("!Agency FB@50#1000"),ScrW()/2,ScrH()*0.15,Color(199,0,0), TEXT_ALIGN_CENTER)
        end
    end

end



function AOCRP.HUD:TeamHud()

    local text = ""

    -- NPC-Count
    -- EVENTLEITER
    -- ROLEPLAY-TM
    -- !! OFFENES TICKET !!

    local npcCount = 0
    for k, v in ipairs(ents.GetAll()) do
        if v:IsNPC() or v:IsNextBot() then
            npcCount = npcCount + 1
        end
    end

    if npcCount > 0 then
        text = text .. " NPC: "..npcCount
    end


    if IsValid( GetGlobalNetVar( "AOCRP.EVENTLEITER", nil) ) then
        text = text .. " | EL: " .. GetGlobalNetVar( "AOCRP.EVENTLEITER", nil):Nick()
    end

    if IsValid( GetGlobalNetVar( "AOCRP.RPTEAMMITGLIED", nil) ) then
        text = text .. " | RP-TM: " .. GetGlobalNetVar( "AOCRP.RPTEAMMITGLIED", nil):Nick()
    end


    if text ~= "" then
        text = text .. " "

        draw.WordBox( 4, AOCW(250), AOCH(15), text, AOCDerma:Font("AOCRP.ADMIN_HUD_TEXT"), Color( 0, 0, 0, 140), Color( 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
    end
end




function AOCRP.HUD:GetEyePos(ply)

    local att = ply:LookupAttachment( "eyes" )

    if att == 0 or att == -1 then return ply:GetPos() end

    local attData = ply:GetAttachment( att )
    return attData.Pos
end

function AOCRP.HUD:ShouldNotDrawTarget(ply)
    return ply:GetMoveType() != MOVETYPE_NOCLIP
end

function AOCRP.HUD:CanSeePosition(pos)

    return true
end

PIXEL.RegisterFont("AOCRP.HUD.TraceEntityName", "Agency FB", 30, 1000)
PIXEL.RegisterFont("AOCRP.HUD.TraceEntityInteract", "Agency FB", 30, 10)

local interactbind = input.LookupBinding( "use" )
function AOCRP.HUD:TraceEntityHUD()

    local ent = LocalPlayer():GetEyeTrace().Entity
    if !IsValid(ent) then return false end
    if ent:IsWorld() then return false end
    if ent:GetPos():DistToSqr(LocalPlayer():GetPos()) > AOCRP.Config.HUDEntTraceDistance*AOCRP.Config.HUDEntTraceDistance then return end

    if ent.AOCRPInteract or ent:GetNetVar("AOCRPInteract", false) then
        AOCDerma:DrawTextShadow(ent.PrintName or "", PIXEL.UI.RegisteredFonts["AOCRP.HUD.TraceEntityName"], ScrW()/2,ScrH()/2-AOCH(30), Color(255,255,255), TEXT_ALIGN_CENTER)
        AOCDerma:DrawTextShadow("Drücke ["..string.upper(interactbind).."] zum interagieren.",PIXEL.UI.RegisteredFonts["AOCRP.HUD.TraceEntityInteract"], ScrW()/2,ScrH()/2, Color(255,255,255), TEXT_ALIGN_CENTER)
        return true
    end

    if IsValid(ent:GetNetVar("AOC_BodyOf", ply)) then
        AOCDerma:DrawTextShadow("Verletzte Person",PIXEL.UI.RegisteredFonts["AOCRP.HUD.TraceEntityName"], ScrW()/2,ScrH()/2-AOCH(30), Color(255,255,255), TEXT_ALIGN_CENTER)
        AOCDerma:DrawTextShadow(ent:GetNetVar("AOC_BodyOf", ply):Nick(),PIXEL.UI.RegisteredFonts["AOCRP.HUD.TraceEntityInteract"], ScrW()/2,ScrH()/2, Color(255,255,255), TEXT_ALIGN_CENTER)
        return true      
    end

    return false
end


local mainHelmet = Material( "aoc/helmoverlays/ct_default.png" )
--[[ local blueHelmet = Material( "aoc/helmoverlays/ct_blue.png" )
local redHelmet = Material( "aoc/helmoverlays/ct_red.png" )
 ]]

function AOCRP.HUD:DrawHelmetOverlay()
	--PIXEL.DrawImgur(0, 0, AOCW(1920), AOCH(1080), "rwvySVm", Color(255,255,255,255) )
	surface.SetMaterial( mainHelmet )
	surface.SetDrawColor( 255, 255, 255, 255 )
	surface.DrawTexturedRect( 0, 0, AOCW(1920), AOCH(1080) )

    draw.RoundedBox(10,ScrW()/2-5,ScrH()/2-5,10,10,Color(255,255,255))
end

function AOCRP.HUD:DrawAOCLogo()
   PIXEL.DrawImgur(0, -AOCH(50), AOCH(200), AOCH(200), AOCRP.Config.Logo, Color(255,255,255,150) )
end

-- Load the image file into a material.
AOCRP.HUD.CrosshairMaterials = {}

local CrosSize = 50

function AOCRP.HUD:DrawCrosshair()

    local currentCrosshair = GetConVar("aocrp_gtm_crosshair"):GetString()

    if currentCrosshair == "default" then return end

    if !AOCRP.Config.Crosshair[currentCrosshair] then return end



    local crossHair = AOCRP.Config.Crosshair[currentCrosshair]

    if !AOCRP.GTM:HasItem(LocalPlayer(), currentCrosshair) then return end

  surface.SetDrawColor(crossHair.cl)

  if !AOCRP.HUD.CrosshairMaterials[currentCrosshair] then
    AOCRP.HUD.CrosshairMaterials[currentCrosshair] = Material(crossHair.img)
  end

  -- Draw the image at (100, 100) with a size of 200x200 pixels.
  surface.SetMaterial(AOCRP.HUD.CrosshairMaterials[currentCrosshair])
  surface.DrawTexturedRect(ScrW()/2-CrosSize/2, ScrH()/2-CrosSize/2, CrosSize, CrosSize )

end

PIXEL.RegisterFont("AOCRP.VoiceDistance.Message", "Agency FB", 30, 10)

local msgBoxX, msgBoxY = ScrW()-AOCW(600), AOCH(20)
function AOCRP.HUD:DrawVoiceDistance()

    if !AOCRP_VoiceDistance then return end

    if input.IsKeyDown( input.GetKeyCode(input.LookupBinding( "+voicerecord" ))  ) or LocalPlayer():IsSpeaking() then
        draw.RoundedBox(0, ScrW()-AOCW(390), AOCH(10), AOCW(50), AOCH(2), AOCRP.Config.Distances[AOCRP_VoiceDistance].color)

        draw.RoundedBox(0, ScrW()-AOCW(390), msgBoxY, AOCW(50), AOCH(50), Color(0,0,0,200))
        surface.SetDrawColor( 255,255,255,125 )
        surface.DrawOutlinedRect( ScrW()-AOCW(390),msgBoxY,AOCW(50),AOCH(50), 1)
        draw.DrawText("REC",PIXEL.UI.RegisteredFonts["AOCRP.VoiceDistance.Message"], ScrW()-AOCW(390)+AOCW(50)/2,AOCH(30), Color(255, 255, 255), TEXT_ALIGN_CENTER)
  
        return 
    end

    if AOCRP_VoiceDistanceChangeMsg and AOCRP_VoiceDistanceChangeMsg != "" then

        draw.RoundedBox(0, msgBoxX, AOCH(10), AOCW(260), AOCH(2), AOCRP.Config.Distances[AOCRP_VoiceDistance].color)

        draw.RoundedBox(0, msgBoxX, msgBoxY, AOCW(260), AOCH(50), Color(0,0,0,200))
        surface.SetDrawColor( 255,255,255,125 )
        surface.DrawOutlinedRect( msgBoxX,msgBoxY,AOCW(260),AOCH(50), 1)
        draw.DrawText(AOCRP_VoiceDistanceChangeMsg,PIXEL.UI.RegisteredFonts["AOCRP.VoiceDistance.Message"], msgBoxX+AOCW(260)/2,AOCH(30), Color(255, 255, 255), TEXT_ALIGN_CENTER)
    else
        draw.RoundedBox(0, ScrW()-AOCW(390), AOCH(10), AOCW(50), AOCH(2), AOCRP.Config.Distances[AOCRP_VoiceDistance].color)
    end 
end




local function FToVar(f)
    if f == "f1" then
        return AOCRP_Comlink_F1
    end
    if f == "f2" then
        return AOCRP_Comlink_F2
    end
    if f == "f3" then
        return AOCRP_Comlink_F3
    end    
end

PIXEL.RegisterFont("AOCRP.Comlink.FHudText", "DermaDefault", 15, 10)
PIXEL.RegisterFont("AOCRP.Comlink.FHudTextShort", "Agency FB", 30, 1000)

local function DrawFHud(f,posX,posY)

    local chan = FToVar(f)
    local short = "-/-"

    if AOCRP.Comlink.Channels[chan] then
        short = AOCRP.Comlink.Channels[chan].short
    end
    draw.RoundedBox(0,posX,posY,AOCW(100),AOCH(50),Color(0,0,0,200))

    surface.SetDrawColor( 255, 255, 255, 128 )
    surface.DrawOutlinedRect( posX,posY,AOCW(100),AOCH(50), 1)


    draw.DrawText(string.upper(input.GetKeyName(AOCRP_Binds:FindBindByID("comlink"..f))),PIXEL.UI.RegisteredFonts["AOCRP.Comlink.FHudText"], posX+AOCW(50), posY+AOCH(5), Color(255, 255, 255),TEXT_ALIGN_CENTER)
    draw.DrawText(short,PIXEL.UI.RegisteredFonts["AOCRP.Comlink.FHudTextShort"], posX+AOCW(50), posY+AOCW(18), Color(255, 255, 255), TEXT_ALIGN_CENTER)

end


PIXEL.RegisterFont("AOCRP.Comlink.HudActive", "Agency FB", 30, 10)



function AOCRP.HUD:Eventcharbefehl()

    if GetGlobalNetVar( "AOCRP_EvchrOrder", "" ) != "" then return end 
    if !LocalPlayer():GetNetVar("AOCRP_DroidEvchr", false) then return end

    draw.DrawText("[EVENT-BEFEHL]\n"..GetGlobalNetVar( "AOCRP_EvchrOrder", "" ),AOCDerma:DF("l",35), ScrW()/2, AOCH(100), Color(255, 0, 0), TEXT_ALIGN_CENTER)

end

local function DrawNoComlink(posX,posY)


    local color = Color(255, 0, 0, 128)
    local text = "Comlink nicht verfügbar"

    draw.RoundedBox(0,posX,posY,AOCW(310),AOCH(50),Color(0,0,0,200))

    surface.SetDrawColor(color)
    surface.DrawOutlinedRect( posX,posY,AOCW(310),AOCH(50), 1)


    draw.DrawText(text,PIXEL.UI.RegisteredFonts["AOCRP.Comlink.HudActive"], posX+AOCW(155), posY+AOCH(10), Color(255, 255, 255), TEXT_ALIGN_CENTER)

end

local function DrawActiveHud(posX,posY)


    local color = Color(255, 0, 0, 128)
    local text = "Comlink inaktiv [" .. string.upper(input.GetKeyName(AOCRP_Binds:FindBindByID("comlink"))) .. "]"

    if LocalPlayer():ComlinkGetActiveChannel() != "" then
        color = Color(0, 255, 0, 128)
        text = AOCRP.Comlink.Channels[LocalPlayer():ComlinkGetActiveChannel()].name
    end

    draw.RoundedBox(0,posX,posY,AOCW(310),AOCH(50),Color(0,0,0,200))

    surface.SetDrawColor(color)
    surface.DrawOutlinedRect( posX,posY,AOCW(310),AOCH(50), 1)


    draw.DrawText(text,PIXEL.UI.RegisteredFonts["AOCRP.Comlink.HudActive"], posX+AOCW(155), posY+AOCH(10), Color(255, 255, 255), TEXT_ALIGN_CENTER)

end

local hudW, hudH = AOCW(330), AOCH(125)
function AOCRP.HUD:ComlinkHud()

    local height = AOCH(60)
    if LocalPlayer():ComlinkGetActiveChannel() != "" then
        height = hudH-AOCH(10)
    end

    --draw.RoundedBox(0,ScrW()-hudW, 0, hudW, hudH, Color(0,0,0,200))
    draw.RoundedBox(0,ScrW()-hudW, AOCH(10), hudW-AOCW(10), AOCH(2), Color(255,255,255,200))
    draw.RoundedBox(0,ScrW()-AOCW(12), AOCH(10), AOCW(2), height, Color(255,255,255,200))

    if AOCRP:GetComlinkUp() then 
        DrawFHud("f1",ScrW()-hudW,AOCH(20))
        DrawFHud("f2",ScrW()-hudW+AOCW(105),AOCH(20))
            DrawFHud("f3",ScrW()-hudW+AOCW(210),AOCH(20))

            if LocalPlayer():ComlinkGetActiveChannel() != "" then
            DrawActiveHud(ScrW()-hudW,AOCH(75))
            end
    else 
        DrawNoComlink(ScrW()-hudW,AOCH(20))
    end
end











local directions = {"O","S","W","N"}



local function drawPanel(x,y,w,h,bearing)


    local angle = LocalPlayer():EyeAngles().y
    if angle < 0 then
        angle = angle + 360
    end
    angle = math.Round(angle)

    draw.DrawText("⌤\n"..angle,AOCDerma:DF("l", 30), ScrW()/2, h+10, Color(255, 255, 255), TEXT_ALIGN_CENTER)

    return x, y
end

function AOCRP.HUD:BigCompass()
    if LastWeaponHUD and LastWeaponHUD >= CurTime() then return end
    
    local padding = {0,10,0,0}
    local bearing = LocalPlayer():EyeAngles().y
--[[ 
    if LocalPlayer():InVehicle() then
        local veh = LocalPlayer():GetVehicle() 
        bearing = veh:GetAngles().y
    end ]]
    drawPanel((ScrW()/2)-256,padding[2],512,32,bearing)
    surface.SetFont(AOCDerma:DF("l", 45))

    for k, v in ipairs(directions) do
        local sin = math.sin( math.rad( ((k/4)*360)+bearing ) )
        local cos = math.cos( math.rad( ((k/4)*360)+bearing ) )
        local alpha = cos
        surface.SetTextColor(255,255,255,255*alpha)
        surface.SetTextPos((sin*232)+ScrW()/2,padding[2])
        surface.DrawText( v )
        for i = 1, 5, 1 do
            local sin = math.sin( math.rad( ((i/6)*90)+bearing+2.5+(k*90) ) )   
            local cos = math.cos( math.rad( ((i/6)*90)+bearing+(k*90) ) )  
            local alpha = cos 
            local len = 8
            if i%3 == 0 then len = 16 end
            surface.SetDrawColor(255,255,255,255*alpha) 
            surface.DrawLine( (ScrW()/2)+(sin*232), padding[2], (ScrW()/2)+(sin*232), len+padding[2] )
    
        end


    end


end

local function ArmorGradient(v)
    local armorPercent = v:Armor() / v:GetMaxArmor()
    local r, g, b
    r = 0
    g = 0
    b = (armorPercent * 255)
    return Color(r, g, b)
end


local function HealthGradient(v)
    local healthPercent = v:Health() / v:GetMaxHealth()
    local r, g, b
    if healthPercent >= 0.5 then
        r = 255 * (1 - healthPercent) * 2
        g = 255
    else
        r = 255
        g = 255 * healthPercent * 2
    end
    b = 0
    return Color(r, g, b)
end

PIXEL.RegisterFont("AOCRP.HUD.Xray", "Agency FB", 25, 1000)
function AOCRP.HUD:DrawAdminXray()

    if LocalPlayer():GetMoveType() != MOVETYPE_NOCLIP then return end

    for k, v in ipairs(ents.GetAll()) do
        if v == LocalPlayer() then continue end

        local Position = ( v:GetPos() ):ToScreen()
        
        if Position.x > ScrW() or Position.x < 0 then continue end
        if Position.y > ScrH() or Position.y < 0 then continue end

        --draw.RoundedBox(0,Position.x-squadHPSize/2,Position.y-AOCH(3),squadHPSize,2,HealthGradient(v)) 
        if v:IsPlayer() then
            AOCDerma:DrawTextShadow("PLY",PIXEL.UI.RegisteredFonts["AOCRP.HUD.Xray"],Position.x,Position.y-AOCH(20),HealthGradient(v), TEXT_ALIGN_CENTER)
            AOCDerma:DrawTextShadow(v:GetCloneName(),PIXEL.UI.RegisteredFonts["AOCRP.HUD.Xray"],Position.x,Position.y,Color(255,255,255), TEXT_ALIGN_CENTER)
        end
        if v:IsNPC() or v:IsNextBot() then
            AOCDerma:DrawTextShadow("NPC",PIXEL.UI.RegisteredFonts["AOCRP.HUD.Xray"],Position.x,Position.y-AOCH(20),Color(255,0,0), TEXT_ALIGN_CENTER)
            AOCDerma:DrawTextShadow(v:Health(),PIXEL.UI.RegisteredFonts["AOCRP.HUD.Xray"],Position.x,Position.y,Color(255,255,255), TEXT_ALIGN_CENTER)
        end
    end

end




local squadHPSize = 50
local squadHPSize2 = 80
PIXEL.RegisterFont("AOCRP.HUD.SquadPos", "Aurebesh", 25, 10)

PIXEL.RegisterFont("AOCRP.HUD.SquadNumber", "Aurebesh", 25, 50)


local function LVSHealthGradient(v)
    local healthPercent = v:GetHP() / v.MaxHealth
    local r, g, b
    if healthPercent >= 0.5 then
        r = 255 * (1 - healthPercent) * 2
        g = 255
    else
        r = 255
        g = 255 * healthPercent * 2
    end
    b = 0
    return Color(r, g, b)
end


local function GetPassangers(lvs)
        local plys = {}
    
        for _, Pod in pairs( lvs:GetPassengerSeats() ) do
            if not IsValid( Pod ) then continue end
    
            local ply = Pod:GetDriver()
    
            if not IsValid( ply ) then continue end
    
            table.insert( plys, ply )
        end
    
        return plys

end

local function DrawRhombus(x, y, size, color)
    surface.SetDrawColor(color)
    
    local halfSize = size / 2
    
    -- Define the vertices of the rhombus
    local vertices = {
        { x = x - halfSize, y = y },                    -- Top
        { x = x, y = y - halfSize },                    -- Right
        { x = x + halfSize, y = y },                    -- Bottom
        { x = x, y = y + halfSize }                     -- Left
    }
    
    -- Draw lines connecting the vertices
    surface.DrawLine(vertices[1].x, vertices[1].y, vertices[2].x, vertices[2].y) -- Top-Right
    surface.DrawLine(vertices[2].x, vertices[2].y, vertices[3].x, vertices[3].y) -- Right-Bottom
    surface.DrawLine(vertices[3].x, vertices[3].y, vertices[4].x, vertices[4].y) -- Bottom-Left
    surface.DrawLine(vertices[4].x, vertices[4].y, vertices[1].x, vertices[1].y) -- Left-Top
end

AOCDerma:RegisterFont("AOCRP.SQUAD.INDEX", "Agency FB", 28, 1000)
AOCDerma:RegisterFont("AOCRP.SQUAD.INDEXBG", "Agency FB", 29, 1000)

AOCDerma:RegisterFont("AOCRP.SQUAD.SYMBOL", "Aurebesh", 35, 1)
AOCDerma:RegisterFont("AOCRP.SQUAD.TESTSYMBOL", "TargetID", 20, 1000)


function AOCRP.HUD:DrawSquadMembers()


    for k,v in ipairs(ents.GetAll()) do

        if v:IsPlayer() then

            if v:GetSquad() != LocalPlayer():GetSquad() then continue end
            if v == LocalPlayer() then continue end
            if !AOCRP.HUD:ShouldNotDrawTarget(v) then continue end
            if !v:Alive() then continue end
            Position = ( v:GetPos() + Vector(0,0,35)  ):ToScreen()


            local squadColor = Color(255,255,255,255)
    
            if AOCRP.Config.SquadTeams[v:GetNetVar("AOCRP.SquadTeam", 1)] then 
                squadColor = AOCRP.Config.SquadTeams[v:GetNetVar("AOCRP.SquadTeam", 1)].color
            end

            if v:GetNetVar("AOCRP.SquadTeam", 1) == 1 then
                squadColor = Color(255,255,255,255)
            end



--[[             local edgeX = math.Clamp(Position.x, 0, ScrW())
            local edgeY = math.Clamp(Position.y, 0, ScrH())

            local circleSize = AOCH(20)

            if Position.x > ScrW()-circleSize or Position.x < circleSize or Position.y > ScrH() -circleSize or Position.y < circleSize then 
                draw.RoundedBox(circleSize, edgeX - circleSize/2, edgeY - circleSize/2, circleSize, circleSize, squadColor)
            end
 ]]
     


            if Position.x > ScrW() or Position.x < 0 then continue end
            if Position.y > ScrH() or Position.y < 0 then continue end



            squadColor.a = 255

            
            if v:GetSquadPos() != "" then
                draw.DrawText(v:GetSquadPos(),AOCDerma:DF("aurebesh",45 ),Position.x,Position.y-AOCH(25),squadColor, TEXT_ALIGN_CENTER)
            end
            draw.DrawText(v:GetCloneName(),AOCDerma:DF("l", 30 ),Position.x,Position.y,squadColor, TEXT_ALIGN_CENTER)



            continue 
        end 

        if v:GetClass() == "prop_ragdoll" then
            if v:GetNetVar("AOC_BodyOf", nil) != nil then 

                
                local owner = v:GetNetVar("AOC_BodyOf", nil)

                if !IsValid(owner) then continue end

                if owner:GetSquad() != LocalPlayer():GetSquad() then continue end

                Position = ( v:GetPos() ):ToScreen()

                if Position.x > ScrW() or Position.x < 0 then continue end
                if Position.y > ScrH() or Position.y < 0 then continue end

                AOCDerma:DrawTextShadow("TOT",PIXEL.UI.RegisteredFonts["AOCRP.HUD.SquadPos"],Position.x,Position.y-AOCH(25),Color(255,0,0), TEXT_ALIGN_CENTER)
                AOCDerma:DrawTextShadow(owner:GetCloneName(),AOCDerma:Font("AOCRP.SQUAD.TESTSYMBOL"),Position.x,Position.y,Color(255,0,0), TEXT_ALIGN_CENTER)



                
                continue
            end 
            continue
        end

        if v:IsVehicle() then

            if !IsValid(v:GetParent()) then continue end 

            local lvs = v:GetParent()


            if !lvs.LVS then continue end

            local Position = ( lvs:GetPos() ):ToScreen()

            if Position.x > ScrW() or Position.x < 0 then continue end
            if Position.y > ScrH() or Position.y < 0 then continue end

            if lvs:GetNetVar("AOC_ATC_TARGET", false) then 

                if !IsValid(LocalPlayer():GetVehicle()) then continue end

                DrawRhombus(Position.x, Position.y, 80, Color(255,0,0))
               AOCDerma:DrawTextShadow(lvs:EntIndex(),AOCDerma:Font("AOCRP.SQUAD.INDEX"),Position.x,Position.y-AOCH(13),Color(255,0,0), TEXT_ALIGN_CENTER)
               AOCDerma:DrawTextShadow("T",AOCDerma:Font("AOCRP.SQUAD.SYMBOL"),Position.x,Position.y-AOCH(70),Color(255,0,0), TEXT_ALIGN_CENTER)
           
               continue

           end 


           if !IsValid(v:GetDriver()) then continue end 

            

            local driver = v:GetDriver() 

            if driver == LocalPlayer() then continue end







            if driver:GetSquad() == LocalPlayer():GetSquad() then

                        local Vel = lvs:GetVelocity():Length()
                        local kmh = math.Round(Vel * 0.09144,0)
                        
                        local pSeats = lvs:GetPassengerSeats()
                        local pCount = 0
                        for k, v in pairs(pSeats) do
                            if v:GetDriver() != NULL then
                                pCount = pCount + 1
                            end 
                        end


                --DrawRhombus(Position.x, Position.y, 80, LVSHealthGradient(lvs))
                AOCDerma:DrawTextShadow(lvs:EntIndex(),AOCDerma:Font("AOCRP.SQUAD.INDEX"),Position.x,Position.y-AOCH(13),Color(0,255,0), TEXT_ALIGN_CENTER)
                AOCDerma:DrawTextShadow(AOCRP.Unit:GetRankPrefix(driver:GetRankID(), driver:GetUnitID()) .. " " .. driver:GetCloneName(),AOCDerma:DF("l", 20, 10),Position.x,Position.y+AOCH(14),Color(255,255,255), TEXT_ALIGN_CENTER)
                AOCDerma:DrawTextShadow(kmh .. " | " .. pCount,AOCDerma:DF("l", 20, 10),Position.x,Position.y-AOCH(25),Color(255,255,255), TEXT_ALIGN_CENTER)
                
                continue
            end


--[[             AOCDerma:DrawTextShadow("F-"..v:EntIndex(),PIXEL.UI.RegisteredFonts["AOCRP.HUD.SquadNumber"],Position.x,Position.y,Color(255,255,255), TEXT_ALIGN_CENTER)
            draw.RoundedBox(0,Position.x-200/2,Position.y+40,200,2,LVSHealthGradient(v)) 

            AOCDerma:DrawTextShadow(v:GetDriver():EntIndex(),PIXEL.UI.RegisteredFonts["AOCRP.HUD.SquadNumber"],Position.x,Position.y+50,Color(255,255,255), TEXT_ALIGN_CENTER)

            AOCDerma:DrawTextShadow(#GetPassangers(v).."/"..#v:GetPassengerSeats()+1,PIXEL.UI.RegisteredFonts["AOCRP.HUD.SquadNumber"],Position.x,Position.y+80,Color(255,255,255), TEXT_ALIGN_CENTER)
 ]]

        end
    end

end

local SquadListLine = AOCW(200)
local SquadListX, SquadListY = AOCW(0), AOCH(100)
local SquadListPlayerSize = AOCH(30)
local SquadListPlayerAbstand = AOCH(4)
PIXEL.RegisterFont("AOCRP.HUD.SquadListTitle", "Agency FB", 35, 1000)
PIXEL.RegisterFont("AOCRP.HUD.SquadListOwnNumber", "Aurebesh", 40, 10)
PIXEL.RegisterFont("AOCRP.HUD.SquadListPlayerText", "TargetID", 15, 1000)
PIXEL.RegisterFont("AOCRP.HUD.SquadListPlayerPos", "Aurebesh", 15, 10)


function AOCRP.HUD:DrawSquadList()

    local plywithfarbi = {}
    for k, v in ipairs(player.GetHumans()) do
        if v:GetSquad() != LocalPlayer():GetSquad() then continue end
        v.squadfarbi = v:GetNetVar("AOCRP.SquadTeam", 1)
        table.insert(plywithfarbi, v)



    end


    local count = 0
    currentY = SquadListY + AOCH(10)
    for k, v in SortedPairsByMemberValue(plywithfarbi, "squadfarbi") do

        local color = AOCRP.Config.SquadTeams[v.squadfarbi].color
        color.a = 50

        local textcolor = Color(255,255,255)

        draw.RoundedBox(0,SquadListX,currentY,SquadListLine, SquadListPlayerSize, color)

        local healthPercent = v:Health() / v:GetMaxHealth()
        local width = math.max(0, SquadListLine * healthPercent)
        draw.RoundedBox(0,SquadListX,currentY+SquadListPlayerSize-2,width, 2, Color(0,255,0))


        local healthPercent = v:Armor() / v:GetMaxArmor()
        local width = math.max(0, SquadListLine * healthPercent)
        draw.RoundedBox(0,SquadListX,currentY+SquadListPlayerSize-2,width, 2, Color(0,0,255,196))


        if v:GetSquadPos() == "" then 
            local size = AOCH(30)
            PIXEL.DrawImgur(SquadListX+AOCW(5), currentY-2,size,size, AOCRP.Ranks[v:GetRankID()].icon, Color(255,255,255))
        else 
            AOCDerma:DrawTextShadow(v:GetSquadPos(), AOCDerma:DF("aurebesh", 30), SquadListX+AOCW(20), currentY+AOCH(4), textcolor, TEXT_ALIGN_CENTER)
        end

        AOCDerma:DrawTextShadow(v:GetCloneName(), AOCDerma:DF("l", 30), SquadListX+AOCW(38), currentY+AOCH(2), textcolor, TEXT_ALIGN_LEFT)

        currentY = currentY + SquadListPlayerSize + SquadListPlayerAbstand
    end
    

end


PIXEL.RegisterFont("AOCRP.HUD.SquadMarkers", "Aurebesh", 50, 10)
PIXEL.RegisterFont("AOCRP.HUD.SquadMarkersName", "Agency FB", 20, 10)


surface.CreateFont( "AOCRP_Squadmarker", {
	font = "Aurebesh", --  Use the font-name which is shown to you by your operating system Font Viewer, not the file name
	size = 40,
	weight = 100,
} )
surface.CreateFont( "AOCRP_Squadmarker_Meter", {
	font = "Agency FB", --  Use the font-name which is shown to you by your operating system Font Viewer, not the file name
	size = 30,
	weight = 10,
} )



local function HammerUnitsToMeters(distanceInHammerUnits)
    -- The conversion factor from Hammer units to meters is approximately 0.0254
    local conversionFactor = 0.0254
    return math.sqrt(distanceInHammerUnits) * conversionFactor
end


AOCRP.HUD.SquadMarkers = AOCRP.HUD.SquadMarkers or {}
function AOCRP.HUD:DrawSquadMarkers()
    if !table.IsEmpty(AOCRP.HUD.SquadMarkers) then
        for k, v in pairs(AOCRP.HUD.SquadMarkers) do
            if CurTime() > v.time then
                AOCRP.HUD.SquadMarkers[k] = nil 
            else

                if !AOCRP.Config.SquadMarker[v.id] then return end

             

                if IsValid(v.target) then 
                    v.pos = v.target:GetPos()
                end

                local Position = ( v.pos  ):ToScreen()

               
                draw.DrawText(AOCRP.Config.SquadMarker[v.id].symbol,"AOCRP_Squadmarker",Position.x,Position.y,AOCRP.Config.SquadMarker[v.id].cl, TEXT_ALIGN_CENTER)
                
                draw.DrawText(v.sender:GetCloneName() .. "\n".. math.Round( HammerUnitsToMeters(LocalPlayer():GetPos():DistToSqr(v.pos)) ) .. "m","AOCRP_Squadmarker_Meter",Position.x,Position.y+30,Color(255,255,255), TEXT_ALIGN_CENTER)
            end
        end
    end
end





function AOCRP.HUD:AddSquadMarker(pos, symbol, color, delay, sender, soundurl)

    
    if soundurl != "" then 
        AOCDerma:PlayURL(soundurl) 
    end

    local markerData = {}
    markerData.pos = pos
    markerData.symbol = symbol
    markerData.color = color
    markerData.time = CurTime() + delay
    markerData.sender = sender
    table.insert(AOCRP.HUD.SquadMarkers, markerData)
end


local AOCRP_PlayerVoicePanels = {}


local function voiceVolumeToColor(vol)

    if vol < 0.2  then
        return Color(0,255,0)
    end
    if vol < 0.4 then 
        return Color(255,255,0)
    end
    if vol < 0.7 then
        return Color(255,125,0)
    end
    if vol > 0.7 then
        return Color(255,0,0)
    end
end


function AOCRP.HUD:DrawVoiceIcons()
    for k, v in pairs(AOCRP_PlayerVoicePanels) do
        if IsValid(k) then 

            if !AOCRP.HUD:ShouldNotDrawTarget(k) then continue end

            local width = k:VoiceVolume() * 200
            local Position = ( AOCRP.HUD:GetEyePos(k) + Vector(0,0,10) ):ToScreen()
        
            draw.RoundedBox(0, Position.x - width/2, Position.y,  width, 3, voiceVolumeToColor(k:VoiceVolume()))
        

        end
    end
end

local function vitalBar(x,y)
    draw.RoundedBox(0, x, y,AOCW(8),AOCH(8), Color(0,255,0,100))
    draw.RoundedBox(0, x+AOCH(13), y,AOCW(100),AOCH(8), Color(0,255,0,100))
end

function AOCRP.HUD:DrawVitalsHelmet()
    local posX, posY = AOCW(490), AOCH(930)
    local seitlich = AOCW(2)
    local runter = AOCH(15)
    vitalBar(posX,posY)
    posX = posX + seitlich
    posY = posY + runter   
    vitalBar(posX,posY)
    posX = posX + seitlich
    posY = posY + runter   
        vitalBar(posX,posY)
    posX = posX + seitlich
    posY = posY + runter   
        vitalBar(posX,posY)
    posX = posX + seitlich
    posY = posY + runter   
        vitalBar(posX,posY)
    posX = posX + seitlich
    posY = posY + runter   
        vitalBar(posX,posY)
    posX = posX + seitlich
    posY = posY + runter   
        vitalBar(posX,posY)
    posX = posX + seitlich
    posY = posY + runter   
        vitalBar(posX,posY)
    posX = posX + seitlich
    posY = posY + runter   
        vitalBar(posX,posY)
    posX = posX + seitlich
    posY = posY + runter   
        vitalBar(posX,posY)
    posX = posX + seitlich
    posY = posY + runter   
end

local healthColor = Color(255,255,255,100)
local function vitalBarNoHelmet(x,y,cur)

    
    local healthHundert = LocalPlayer():Health() / LocalPlayer():GetMaxHealth() * 100
    if healthHundert >= cur then

        draw.RoundedBox(0, x, y,AOCW(5),AOCH(5), healthColor)
        draw.RoundedBox(0, x+AOCH(10), y,AOCW(100),AOCH(5), healthColor)
    end
end

function AOCRP.HUD:DrawVitalsNoHelmet()

    local posX, posY = AOCW(10), AOCH(980)

    local abstand = 9

    vitalBarNoHelmet(posX,posY,100)
        posY = posY + AOCH(abstand)
    vitalBarNoHelmet(posX,posY,88)
        posY = posY + AOCH(abstand)
            vitalBarNoHelmet(posX,posY,77)
        posY = posY + AOCH(abstand)
            vitalBarNoHelmet(posX,posY,66)
        posY = posY + AOCH(abstand)
            vitalBarNoHelmet(posX,posY,55)
        posY = posY + AOCH(abstand)
            vitalBarNoHelmet(posX,posY,44)
        posY = posY + AOCH(abstand)
            vitalBarNoHelmet(posX,posY,33)
        posY = posY + AOCH(abstand)
            vitalBarNoHelmet(posX,posY,22)
        posY = posY + AOCH(abstand)
            vitalBarNoHelmet(posX,posY,11)
        posY = posY + AOCH(abstand)
            vitalBarNoHelmet(posX,posY,1)
        posY = posY + AOCH(abstand)
           
        if LocalPlayer():Health() > 0 then
        draw.DrawText(LocalPlayer():Health(),PIXEL.UI.RegisteredFonts["AOCRP.VoiceListPlayerPanel"], posX+AOCW(115), posY-AOCH(30) , healthColor, TEXT_ALIGN_LEFT)
        end
    AOCRP.HUD:DrawVitalsNoHelmetArmor()
end

local armorColor = Color(125,214,255,100)
local function vitalBarNoHelmetArmor(x,y,cur)

    local healthHundert = LocalPlayer():Armor() / LocalPlayer():GetMaxArmor() * 100
    if healthHundert >= cur then

        draw.RoundedBox(0, x, y,AOCW(5),AOCH(5), armorColor)
        draw.RoundedBox(0, x+AOCH(10), y,AOCW(100),AOCH(5), armorColor)

    end
end

function AOCRP.HUD:DrawVitalsNoHelmetArmor()
    local posX, posY = AOCW(10), AOCH(935)

    

    local abstand = 9

    vitalBarNoHelmetArmor(posX,posY,100)
        posY = posY + AOCH(abstand)
    vitalBarNoHelmetArmor(posX,posY,75)
        posY = posY + AOCH(abstand)
            vitalBarNoHelmetArmor(posX,posY,50)
        posY = posY + AOCH(abstand)
            vitalBarNoHelmetArmor(posX,posY,25)
        posY = posY + AOCH(abstand)
            vitalBarNoHelmetArmor(posX,posY,1)
        posY = posY + AOCH(abstand)

            
        if LocalPlayer():Armor() > 0 then
        draw.DrawText(LocalPlayer():Armor(),PIXEL.UI.RegisteredFonts["AOCRP.VoiceListPlayerPanel"], posX+AOCW(115), posY-AOCH(30) , armorColor, TEXT_ALIGN_LEFT)
        end

end

AOCRP.HUD.Actions = {}


function AOCRP.HUD:DrawActions()
	for k, v in pairs( AOCRP.HUD.Actions ) do

        if v.time < CurTime() then
            table.remove(AOCRP.HUD.Actions, k)
        end



    	local Position = ( v.pos  ):ToScreen()
		local boxX, boxY = 250, 10
		draw.RoundedBox(0, Position.x-boxX/2, Position.y-boxY/2, boxX, boxY,Color( 0, 0, 0, 100 ))

        

        local boxX, boxY = 240, 2

		local timeBox = (v.time - CurTime()) / (v.time - v.startTime) * boxX
		local bar = -timeBox+boxX
		draw.RoundedBox(0, Position.x-bar/2, Position.y-boxY/2, bar, boxY,Color( 0, 255, 0, 200))

        draw.DrawText(v.name, "TargetID", Position.x+1, Position.y-24, Color( 0, 0, 0), 1 )
		draw.DrawText(v.name, "TargetID", Position.x, Position.y-25, Color( 255, 255, 255), 1 )

        draw.DrawText(v.text, "TargetID", Position.x+1, Position.y+6, Color( 0, 0, 0), 1 )
		draw.DrawText(v.text, "TargetID", Position.x, Position.y+5, Color( 255, 255, 255), 1 ) 

	end
end

AOCRP.HUD.ActionTimerCount = AOCRP.HUD.ActionTimerCount or 0


local function WrapText(text, maxLineLength)
    local words = {}
    for word in string.gmatch(text, "%S+") do
        table.insert(words, word)
    end

    local lines = {}
    local currentLineLength = 0
    local currentLineWords = {}

    for _, word in ipairs(words) do
        if currentLineLength + string.len(word) + 1 > maxLineLength then
            table.insert(lines, table.concat(currentLineWords, " "))
            currentLineWords = {}
            currentLineLength = 0
        end

        table.insert(currentLineWords, word)
        currentLineLength = currentLineLength + string.len(word) + 1
    end

    if #currentLineWords > 0 then
        table.insert(lines, table.concat(currentLineWords, " "))
    end

    return table.concat(lines, "\n")
end


PIXEL.RegisterFont("AOCRP.TargetHUDName", "Agency FB", 40, 1000)
PIXEL.RegisterFont("AOCRP.TargetHUDRank", "Agency FB", 40, 10)
PIXEL.RegisterFont("AOCRP.TargetHUDUnit", "Agency FB", 30, 10)

local lineWidth = AOCW(250)
local lineWidthHealthDefault = AOCW(250) -- Set the default line width
local posY = 100

local ribW, ribH = 200, 70
local multi = 0.5

ribW = ribW * multi
ribH = ribH * multi


local function isCommando(ply)
    
    
    local commando = {
        ["COMMANDINGOFFICER"] = "Commanding Officer",
        ["EXECUTIVEOFFICER"] = "Executive Officer",
        ["NO"] = "Naval Officer",
        ["TO"] = "Technical Officer",
        ["MO"] = "Medical Officer",
        ["SO"] = "Security Officer"
    }

    for k, v in pairs(commando) do
        if GetGlobalNetVar( "AOCRP."..k, nil) == ply then 
            return commando[k]
        end
    end
    return ""
end 

function AOCRP.HUD:TargetHUD()
    

    local ent = LocalPlayer():GetEyeTrace().Entity
    if not ent or ent:IsWorld() or not ent:IsPlayer() then return end
    if not AOCRP.HUD:ShouldNotDrawTarget(ent) then return end

    local pos = AOCRP.HUD:GetEyePos(ent) + Vector(0,0,15) or ent:GetPos() + Vector(0,0,80)
    local screenPos = pos:ToScreen()
    if LocalPlayer():GetPos():DistToSqr(ent:GetPos()) > 250*250 then return end

    local size = 70
    PIXEL.DrawImgur(screenPos.x-size/2, screenPos.y-70,size,size, AOCRP.Ranks[ent:GetRankID()].icon, Color(255,255,255))

    AOCDerma:DrawTextShadow(ent:Nick(), AOCDerma:DF("s",30), screenPos.x, screenPos.y, Color(255, 255, 255), TEXT_ALIGN_CENTER)
    
    if ent:GetNetVar("AOC_Fahndung", "") != "" then
        AOCDerma:DrawTextShadow("WIRD GESUCHT", AOCDerma:DF("s",30), screenPos.x, screenPos.y+25, Color(175, 0, 0), TEXT_ALIGN_CENTER)
        return 
    end

    if isCommando(ent) != "" then
        AOCDerma:DrawTextShadow(isCommando(ent), AOCDerma:DF("s",30), screenPos.x, screenPos.y+25, Color(175, 0, 0), TEXT_ALIGN_CENTER)
    else 
        if LocalPlayer():GetRankID() < 7 then
            AOCDerma:DrawTextShadow(AOCRP.Unit:GetRankName(ent:GetRankID(), ent:GetUnitID()), AOCDerma:DF("s",30), screenPos.x, screenPos.y+25, Color(97, 97, 97), TEXT_ALIGN_CENTER)
        end
    end

 
end


AOCDerma:RegisterFont("HealthHudMiddleAurebesh_HP", "Aurebesh", 40, 500)

AOCDerma:RegisterFont("HealthHudMiddleAurebesh_Ammo", "Aurebesh", 30, 200)
AOCDerma:RegisterFont("ArcCWFireModesFont", "Agency FB", 30, 200)
AOCDerma:RegisterFont("ArcCWFireModesFont_Bars", "Agency FB", 50, 200)

local start, oldhp, newhp = 0, -1, -1
local animationTime = 0.5 -- seconds

local function localPlayerSmoothHP()
    if ( !IsValid( LocalPlayer() ) ) then return end

	local hp = LocalPlayer():Health()
	

	-- The values are not initialized yet, do so right now
	if ( oldhp == -1 and newhp == -1 ) then
		oldhp = hp
		newhp = hp
	end

	-- You can use a different smoothing function here
	local smoothHP = Lerp( ( SysTime() - start ) / animationTime, oldhp, newhp )

	-- Health was changed, initialize the animation
	if newhp ~= hp then
		-- Old animation is still in progress, adjust
		if ( smoothHP ~= hp ) then
			-- Pretend our current "smooth" position was the target so the animation will
			-- not jump to the old target and start to the new target from there
			newhp = smoothHP
		end

		oldhp = newhp
		start = SysTime()
		newhp = hp
	end
    return smoothHP
end

local start, oldar, newar = 0, -1, -1
local animationTime = 0.5 -- seconds

local function localPlayerSmoothArmor()
    if ( !IsValid( LocalPlayer() ) ) then return end

	local ar = LocalPlayer():Armor()


	-- The values are not initialized yet, do so right now
	if ( oldar == -1 and newar == -1 ) then
		oldar = ar
		newar = ar
	end

	-- You can use a different smoothing function here
	local smoothArmor = Lerp( ( SysTime() - start ) / animationTime, oldar, newar )

	-- Health was changed, initialize the animation
	if newar ~= ar then
		-- Old animation is still in progress, adjust
		if ( smoothArmor ~= ar ) then
			-- Pretend our current "smooth" position was the target so the animation will
			-- not jump to the old target and start to the new target from there
			newar = smoothArmor
		end

		oldar = newar
		start = SysTime()
		newar = ar
	end
    return smoothArmor
end

local barW = AOCW(150)
local distance = AOCW(60)
local hudH = 1010

local showHUD = false
local lastHealth = 100
local lastArmor = 100
local lastChangeTime = 0

function AOCRP.HUD:HealthHudMiddleAurebesh()

    if ( !IsValid( LocalPlayer() ) ) then return end

        local currentHealth = LocalPlayer():Health()
        local currentArmor = LocalPlayer():Armor()

        if currentHealth ~= lastHealth or currentArmor ~= lastArmor then
            showHUD = true
            lastChangeTime = CurTime()
            lastHealth = currentHealth
            lastArmor = currentArmor
        end

        if CurTime() - lastChangeTime >= 10 then
            showHUD = false
        end

        alpha = 255
        if !showHUD then
            alpha = 50
        end
            local smoothHp = localPlayerSmoothHP()
            local smoothArmor = localPlayerSmoothArmor()

            if smoothHp > 999 then smoothHp = 999 end
            if smoothArmor > 999 then smoothArmor = 999 end

            local maxhp = LocalPlayer():GetMaxHealth()
            if maxhp > 999 then maxhp = 999 end
            local maxar = LocalPlayer():GetMaxArmor()
            if maxar > 999 then maxar = 999 end


            local smoothBarW = math.max( 0, smoothHp ) / maxhp * barW
            local smoothBarWarmor = math.max( 0, smoothArmor ) / maxar * barW

            AOCDerma:DrawTextShadow(math.Round(smoothHp), AOCDerma:Font("HealthHudMiddleAurebesh_HP"), ScrW()/2, AOCH(hudH-35), Color(15, 180, 0,alpha), TEXT_ALIGN_CENTER, Color(0,0,0,alpha))
    
            draw.RoundedBox(0,ScrW()/2 + distance+1, AOCH(hudH)+1, smoothBarW, 5, Color(0, 0, 0,alpha))
            draw.RoundedBox(0,ScrW()/2 + distance, AOCH(hudH), smoothBarW, 5, Color(15, 180, 0,alpha))

            --draw.RoundedBox(0,ScrW()/2 - distance - barW -1, AOCH(1025)+1, barW, 5, Color(0, 0, 0))
            draw.RoundedBox(0,ScrW()/2 - distance - smoothBarW - 1, AOCH(hudH) + 1, smoothBarW, 5, Color(0, 0, 0,alpha))
            draw.RoundedBox(0,ScrW()/2 - distance - smoothBarW, AOCH(hudH), smoothBarW, 5, Color(15, 180, 0,alpha))

            draw.RoundedBox(0,ScrW()/2 + distance+1, AOCH(hudH+15)+1, smoothBarWarmor, 5, Color(0, 0, 0,alpha))
            draw.RoundedBox(0,ScrW()/2 + distance, AOCH(hudH+15), smoothBarWarmor, 5, Color(37, 112, 199,alpha))

            draw.RoundedBox(0,ScrW()/2 - distance - smoothBarWarmor -1, AOCH(hudH+15)+1, smoothBarWarmor, 5, Color(0, 0, 0,alpha))      
            draw.RoundedBox(0,ScrW()/2 - distance - smoothBarWarmor, AOCH(hudH+15), smoothBarWarmor, 5, Color(37, 112, 199,alpha))      
    --[[         draw.RoundedBox( 4, 100, 200, barW, 100, color_black )
            draw.RoundedBox( 4, 100, 200, math.max( 0, smoothHp ) / maxhp * barW, 100, color_white ) ]]

            AOCDerma:DrawTextShadow(math.Round(smoothArmor), AOCDerma:Font("HealthHudMiddleAurebesh_HP"), ScrW()/2, AOCH(hudH+5), Color(37, 112, 199,alpha), TEXT_ALIGN_CENTER, Color(0,0,0,alpha))
        
            local wep = LocalPlayer():GetActiveWeapon()
            if !IsValid(wep) then return end
            local text = wep:GetPrintName()
            local ammo = LocalPlayer():GetAmmoCount( wep:GetPrimaryAmmoType() ) or 0
            local clip = wep:Clip1() or -1

            if clip != -1 then
            AOCDerma:DrawTextShadow(clip, AOCDerma:Font("HealthHudMiddleAurebesh_Ammo"), ScrW()/2-AOCW(136), AOCH(hudH+25), Color(255, 255, 255), TEXT_ALIGN_CENTER)
            end

            if ammo != 0 then
            AOCDerma:DrawTextShadow(ammo, AOCDerma:Font("HealthHudMiddleAurebesh_Ammo"), ScrW()/2+AOCW(136), AOCH(hudH+25), Color(255, 255, 255), TEXT_ALIGN_CENTER)
            end


            if wep.GetFiremodeName then
                AOCDerma:DrawTextShadow(wep:GetFiremodeName(), AOCDerma:Font("ArcCWFireModesFont"), ScrW()/2, AOCH(hudH-60), Color(255, 255, 255), TEXT_ALIGN_CENTER)
            end
     

        
end


function AOCRP.HUD:AddAction(name, location, text, time)

    local timerIdentifier = "AOCRP_ActionTimer_".. self.ActionTimerCount + 1

    actionData = {
        name = name,
        pos = location,
        text = WrapText(text, 35),
        startTime = CurTime(),
        time = CurTime() + tonumber(time),
    }
    
    local id = #AOCRP.HUD.Actions + 1

    AOCRP.HUD.Actions[id] = actionData
    



end



hook.Add( "HUDShouldDraw", "AOCRP_HIDEHUDELEMENTS", function( name )
	if ( AOCRP.Config.HideHUD[ name ] ) then
		return false
	end

	-- Don't return anything here, it may break other addons that rely on this hook.
end )



hook.Add( "HUDPaint", "AOCRP_MAINHUD", function()

    if ValidPanel(AOCEscape_BaseFrame) or ValidPanel(AOCRP.ScoreBoard.FRAME) or ValidPanel(AOCRP.Medic.DeathScreen) then return end


    --if IsValid(ArcCW) then
        if ValidPanel(ArcCW.InvHUD) then return end
    --end

    if LocalPlayer().DrawHelmetOverlay then
        if !LocalPlayer().ThirdPerson then
            AOCRP.HUD:DrawHelmetOverlay()
            --AOCRP.HUD:DrawVitalsHelmet()

        end
    end

    if LocalPlayer().AdminXray then
        AOCRP.HUD:DrawAdminXray()
    end



    if IsValid(AOCRP_DefaultFrameOpen) then 
        return 
    end
    

    AOCRP.HUD:DrawAOCLogo()
    
    if LocalPlayer().DontDrawAOCHUD then return end

    if !LocalPlayer():Alive() then return end


    if LocalPlayer():HasWeapon("gmod_tool") then
        AOCRP.HUD:TeamHud()
    end

    AOCRP.HUD:AusbilderWarnung()



    --AOCRP.HUD:HealthHudMiddleAurebesh()
    AOCRP.HUD:NewHUD()

    AOCRP.HUD:DrawSquadMarkers()

    if AOCRP.Squad:InValidSquad(LocalPlayer()) then
       


        AOCRP.HUD:DrawSquadMembers()

        if LocalPlayer().SquadList then
            AOCRP.HUD:DrawSquadList()
        end
    end

    AOCRP.HUD:BigCompass()
    AOCRP.HUD:DrawMusic()

    AOCRP.HUD:ComlinkHud()
    AOCRP.HUD:Eventcharbefehl()
    AOCRP.HUD:DrawVoiceDistance()

    AOCRP.HUD:TargetHUD()

    if !AOCRP.HUD:TraceEntityHUD() then
        if !LocalPlayer().ThirdPerson then
            AOCRP.HUD:DrawCrosshair()
        end
    end



    --- 3D2D WorldSpace

    AOCRP.HUD:DrawVoiceIcons()
    AOCRP.HUD:DrawActions()

    --AOCRP.HUD:TestHud()

end )



function AOCRP.HUD:DrawMusic()
    if IsValid(g_MusicStation) then 
        if g_MusicStation:IsValid() then
            
            if g_MusicStation:GetState() == GMOD_CHANNEL_PLAYING then

            
                local volume = math.Round(g_MusicStation:GetVolume() * 100)
                AOCDerma:DrawTextShadow("Es läuft Musik auf "..volume.."% Lautstärke", AOCDerma:DF("l", 40), AOCW(450), AOCH(15), Color(167,167,167), TEXT_ALIGN_CENTER)
                AOCDerma:DrawTextShadow("/sm zum Stoppen oder /mv 0-488 um Lautstärke anzupassen", AOCDerma:DF("m", 30), AOCW(450), AOCH(45), Color(116,116,116), TEXT_ALIGN_CENTER)
            end

        end
    end
end



PIXEL.RegisterFont("AOCRP.VoiceListPlayerPanel", "Agency FB", 30, 10)
PIXEL.RegisterFont("AOCRP.VoiceListPlayerPanelSmall", "Agency FB", 20, 10)
local function VoiceListCreatePlayerPanel(ply)

    local nick = ply:Nick()

    local pnl = vgui.Create("DPanel",AOCRP.HUD.VoiceList)
    pnl.ply = ply
	pnl:SetSize( AOCW(250), AOCH(40) )
	--pnl:DockPadding( 4, 4, 4, 4 )
	pnl:DockMargin( 2, 2, 2, 2 )
	pnl:Dock( TOP )


    function pnl:Paint(w,h)

        if !IsValid(self.ply) then return end

    	draw.RoundedBox( 0, 0, 0, w, h, Color( 0, 0, 0, 200 ) )
        draw.RoundedBox( 0, 0, h-2, self.ply:VoiceVolume()*w, 2, voiceVolumeToColor(self.ply:VoiceVolume()))
        draw.RoundedBox( 0, w-2, 0, 2, h, Color(255,255,255))
        
        draw.DrawText(nick,PIXEL.UI.RegisteredFonts["AOCRP.VoiceListPlayerPanel"], w/2,5 , Color(255, 255, 255), TEXT_ALIGN_CENTER)

    end

    return pnl
end


local function VoiceListCreatePlayerPanelComlink(ply)

    local nick = ply:Nick()

    local pnl = vgui.Create("DPanel",AOCRP.HUD.VoiceList)
    pnl.ply = ply
	pnl:SetSize( AOCW(250), AOCH(50) )
	--pnl:DockPadding( 4, 4, 4, 4 )
	pnl:DockMargin( 2, 2, 2, 2 )
	pnl:Dock( TOP )


    function pnl:Paint(w,h)
        if ply:ComlinkGetActiveChannel() == "" then self:Remove() return end

            draw.RoundedBox( 0, 0, 0, w, h, Color( 0, self.ply:VoiceVolume() * 255, 0, 200 ) )
            --draw.RoundedBox( 0, 0, h-2, w, 2, Color(255,255,255))
            draw.RoundedBox( 0, w-2, 0, 2, h, Color(255,255,255))
            
            draw.DrawText(nick,PIXEL.UI.RegisteredFonts["AOCRP.VoiceListPlayerPanel"], w/2,AOCH(17) , Color(255, 255, 255), TEXT_ALIGN_CENTER)
        
                draw.DrawText(AOCRP.Comlink.Channels[ply:ComlinkGetActiveChannel()].name ,PIXEL.UI.RegisteredFonts["AOCRP.VoiceListPlayerPanelSmall"], w/2,0 , Color(255, 255, 255), TEXT_ALIGN_CENTER)
       
    end

    return pnl
end


function AOCRP.HUD:VoiceListStart(ply)

    if IsValid(AOCRP_PlayerVoicePanels[ply]) then
        return
    end

    if ( !IsValid( ply ) ) then return end

    if ply == LocalPlayer() then return end

    if ply:ComlinkGetActiveChannel() != "" then
        local pnl = VoiceListCreatePlayerPanelComlink(ply)
        AOCRP_PlayerVoicePanels[ply] = pnl
    else
        local pnl = VoiceListCreatePlayerPanel(ply)
        AOCRP_PlayerVoicePanels[ply] = pnl
    end



    


end

function AOCRP.HUD:VoiceListEnd(ply)
	if ( IsValid( AOCRP_PlayerVoicePanels[ ply ] ) ) then
        AOCRP_PlayerVoicePanels[ ply ]:Remove()
    end
end


function AOCRP.HUD:DrawVoiceList()

    if ValidPanel(self.VoiceList) then self.VoiceList:Remove() end

	self.VoiceList = vgui.Create( "DPanel" )

    local width = AOCW(215)
	self.VoiceList:ParentToHUD()
	self.VoiceList:SetPos( ScrW() - width - AOCW(10), AOCH(135) )
	self.VoiceList:SetSize( width+AOCW(2), ScrH() - AOCH(200) )
	self.VoiceList:SetPaintBackground( false )
end


function AOCRP.HUD:DrawNotifyList()

    if ValidPanel(self.NotifyList) then self.NotifyList:Remove() end

	self.NotifyList = vgui.Create( "DPanel" )

    local width = AOCW(700)
	self.NotifyList:ParentToHUD()
	self.NotifyList:SetPos( ScrW() - width - AOCW(10), AOCH(190) )
	self.NotifyList:SetSize( width, ScrH() - AOCH(200) )
	self.NotifyList:SetPaintBackground( false )
end


function AOCRP.HUD:DrawNotificationList()
    if ValidPanel(self.NotificationList) then self.NotificationList:Remove() end

	self.NotificationList = vgui.Create( "DPanel" )

    local width = AOCW(500)
	self.NotificationList:ParentToHUD()
	self.NotificationList:SetPos( ScrW() / 2 - width/2, AOCH(100) )
	self.NotificationList:SetSize( width, ScrH() - AOCH(100) )
	self.NotificationList:SetPaintBackground( false )

end


function AOCRP.HUD:DrawRPInfoList()
    if ValidPanel(self.RPInfoList) then self.RPInfoList:Remove() end

	self.RPInfoList = vgui.Create( "DPanel" )

    local width = AOCW(500)
	self.RPInfoList:ParentToHUD()
	self.RPInfoList:SetPos( AOCW(200), AOCH(0) )
	self.RPInfoList:SetSize( width, AOCH(500))
	self.RPInfoList:SetPaintBackground( false )

end


PIXEL.RegisterFont("AOCRP.Hud.BigNotifyTitle", "Agency FB", 50, 1000)
PIXEL.RegisterFont("AOCRP.Hud.BigNotifyText", "Agency FB", 40, 10)

function AOCRP.HUD:BigNotify(text, color, title, soundurl, delay)
    delay = delay or 10

    if soundurl then 
        AOCDerma:PlayURL(soundurl) 
    end

    text = AOCDerma:WrapText(text, PIXEL.UI.RegisteredFonts["AOCRP.Hud.BigNotifyText"], AOCW(480))
    local newNotification = vgui.Create("DPanel", self.NotificationList)
    newNotification:Dock(TOP)
    newNotification:SetTall(AOCH(150))
    
    function newNotification:Paint(w,h)
       -- draw.RoundedBox(0,0,0,w,h,Color(0,0,0,100))
        draw.RoundedBox(0,0,h/3,w,2, Color(255,255,255, 200))
        draw.DrawText(title,PIXEL.UI.RegisteredFonts["AOCRP.Hud.BigNotifyTitle"], w/2+1, 2, Color(0,0,0), TEXT_ALIGN_CENTER)
        draw.DrawText(title,PIXEL.UI.RegisteredFonts["AOCRP.Hud.BigNotifyTitle"], w/2, 0, color, TEXT_ALIGN_CENTER)
        draw.DrawText(text,PIXEL.UI.RegisteredFonts["AOCRP.Hud.BigNotifyText"], w/2+1, h/3+AOCH(5)+2, Color(0,0,0), TEXT_ALIGN_CENTER)
        draw.DrawText(text,PIXEL.UI.RegisteredFonts["AOCRP.Hud.BigNotifyText"], w/2, h/3+AOCH(5), Color(255,255,255), TEXT_ALIGN_CENTER)

    end

    timer.Simple(delay, function() 
        if ValidPanel(newNotification) then 
            newNotification:Remove()
        end
    end)

end

PIXEL.RegisterFont("AOCRP.ScannerFont", "Agency FB", 25, 10)
    function AOCRP.HUD:AddScanNew(text,duration)

        LocalPlayer():EmitSound("ambient/machines/keyboard_fast2_1second.wav")
        
        local scanPanel = vgui.Create("DPanel", AOCRP.HUD.RPInfoList)
        scanPanel:SetTall(30)
        scanPanel:Dock(TOP)
        scanPanel:DockMargin(0,0,0,AOCH(5))


        local scanTimer = duration 
        local timerCoolDown = 0

        function scanPanel:Paint(w,h)

            local barW = scanTimer / duration * w

            draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
            draw.RoundedBox(0,-barW,h-AOCH(2),w,AOCH(2),Color(0,255,0))

            draw.DrawText(text,PIXEL.UI.RegisteredFonts["AOCRP.ScannerFont"],w/2,2,Color(255,255,255),TEXT_ALIGN_CENTER)
        end


        function scanPanel:Think()
            if CurTime() > timerCoolDown then
                timerCoolDown = CurTime() + 0.05

                if scanTimer > 0 then
                    scanTimer = scanTimer - 0.05
                else 
                    self:Remove()   
                end
            end
        end
    end


AOCDerma:RegisterFont("AOCRP_HUD_DEFCON_TEXT", "Agency FB", 30, 500)

function AOCRP.HUD:Defcon(level)

    if !ValidPanel(self.NotifyList) then return end 

    if AOCRP.Config.Defcon[level] then
        local delay = 20
        local startTime = CurTime()
        local delayTime = startTime + delay

        if AOCRP.Config.Defcon[level].soundurl then
            --print("Sound")
            --AOCDerma:PlayURL(AOCRP.Config.Defcon[level].soundurl)
        end

        text = AOCDerma:WrapText(AOCRP.Config.Defcon[level].text, PIXEL.UI.RegisteredFonts["AOCRP.Hud.BigNotifyText"], AOCW(480))

        title = "DEFCON "..level
        color = AOCRP.Config.Defcon[level].color
        local newNotification = vgui.Create("DPanel", self.NotifyList)
        newNotification:Dock(BOTTOM)
        newNotification:SetTall(AOCH(140))

        newNotification:AlphaTo( 0, 0.5, delay, function(animTbl, pnl) pnl:Remove() end)


        
        function newNotification:Paint(w,h)

            
            local newwidth = Lerp( (CurTime()-startTime) / delay, w, 0)

            draw.RoundedBox(0,0,0,w,h,Color(0,0,0,100))
            draw.RoundedBox(0,w/2-newwidth/2,h-AOCH(2),newwidth,AOCH(2),color)

            --draw.DrawText(title,PIXEL.UI.RegisteredFonts["AOCRP.Hud.BigNotifyTitle"], w/2+1, 2, Color(0,0,0), TEXT_ALIGN_CENTER)
            draw.DrawText(title,PIXEL.UI.RegisteredFonts["AOCRP.Hud.BigNotifyTitle"], w/2, AOCH(10), color, TEXT_ALIGN_CENTER)

            draw.DrawText(text,AOCDerma:Font("AOCRP_HUD_DEFCON_TEXT"), w/2, AOCH(60), Color(255,255,255), TEXT_ALIGN_CENTER)
    --[[         draw.RoundedBox(0,0,h/3,w,2, Color(255,255,255, 200))
            draw.DrawText(title,PIXEL.UI.RegisteredFonts["AOCRP.Hud.BigNotifyTitle"], w/2+1, 2, Color(0,0,0), TEXT_ALIGN_CENTER)
            draw.DrawText(title,PIXEL.UI.RegisteredFonts["AOCRP.Hud.BigNotifyTitle"], w/2, 0, color, TEXT_ALIGN_CENTER)
            draw.DrawText(text,PIXEL.UI.RegisteredFonts["AOCRP.Hud.BigNotifyText"], w/2+1, h/3+AOCH(5)+2, Color(0,0,0), TEXT_ALIGN_CENTER)
            draw.DrawText(text,PIXEL.UI.RegisteredFonts["AOCRP.Hud.BigNotifyText"], w/2, h/3+AOCH(5), Color(255,255,255), TEXT_ALIGN_CENTER)
 ]]
        end


    end

end


-- LUA REFRESH NICE TO HAVE
AOCRP.HUD:DrawRPInfoList()
AOCRP.HUD:DrawNotificationList()
AOCRP.HUD:DrawVoiceList()
AOCRP.HUD:DrawNotifyList()

hook.Add( "InitPostEntity", "CreateVoiceVGUI", function()  
    AOCRP.HUD:DrawRPInfoList()
    AOCRP.HUD:DrawNotificationList()
    AOCRP.HUD:DrawVoiceList()
    AOCRP.HUD:DrawNotifyList()
end)



function PostProcessHealthHUD()

    if ( !IsValid( LocalPlayer() ) ) then return end

	if (init==nil) or (init==false) then
		init=true	
		relation=0
		hp_init = LocalPlayer():Health()
		alpha_value = 0
	end
	
	
	if (alpha_value <= 100) and (alpha_value > 0) then
		alpha_value = alpha_value - 5
	end
	if hp_init != LocalPlayer():Health() and LocalPlayer():Health()<=hp_init then
		hp_init = LocalPlayer():Health()
		alpha_value=100
	elseif hp_init != LocalPlayer():Health() and LocalPlayer():Health()>=hp_init then
		hp_init = LocalPlayer():Health()
		alpha_value=0
	end
	if LocalPlayer():Health()>=100  then
		intensity = 100 - 100
		relation = 0
		
	else
		if LocalPlayer():Health()<40 then
			relation = math.Clamp((40 - LocalPlayer():Health()) / 40, 0, 1)	
		end
		intensity = 100 - LocalPlayer():Health()
	end
	

	local tab = {}
		tab[ "$pp_colour_addr" ] = ((intensity)*(0.00225))
		tab[ "$pp_colour_addg" ] = ((intensity)*(-0))
		tab[ "$pp_colour_addb" ] = ((intensity)*(-0))
		tab[ "$pp_colour_brightness" ] = ((intensity)*(-0.001))
		tab[ "$pp_colour_contrast" ] = 1-(relation/2)
		tab[ "$pp_colour_colour" ] = 1-relation
		tab[ "$pp_colour_mulr" ] = ((intensity)*(-0))
		tab[ "$pp_colour_mulg" ] = ((intensity)*(-0))
		tab[ "$pp_colour_mulb" ] = ((intensity)*(-0))
	DrawColorModify( tab )
	DrawMotionBlur( 0.25, alpha_value/100, 0)
	DrawMotionBlur( 0.25, relation, 0)
	DrawToyTown(intensity*0.15, intensity*4.5)

end
hook.Add( "RenderScreenspaceEffects", "PostProcessHealthHUD", PostProcessHealthHUD )










AOCDerma:RegisterFont("AOCRP.NEWHUD.HP", "Aurebesh", 35, 1)

AOCDerma:RegisterFont("AOCRP.NEWHUD.COOLDOWN", "Agency FB", 45, 10)
AOCDerma:RegisterFont("AOCRP.NEWHUD.ABILITYICON", "Aurebesh", 32, 1)
AOCDerma:RegisterFont("AOCRP.NEWHUD.ABILITYNAME", "Agency FB", 15, 1)


AOCDerma:RegisterFont("AOCRP.NEWHUD.FIREMODE", "Agency FB", 20, 1)
AOCDerma:RegisterFont("AOCRP.NEWHUD.AMMO1", "Aurebesh", 30, 1)

function AOCRP.HUD:DrawHexagon(centerX, centerY, radius, color, outlineColor, angle)
    -- Define the coordinates of the hexagon vertices
    local vertices = {}
    local startAngle = math.rad(angle) -- Adjust the start angle to rotate the hexagon
    for i = 1, 6 do
        local angle = startAngle + math.rad(60 * (i - 1))
        local x = centerX + radius * math.cos(angle)
        local y = centerY + radius * math.sin(angle)
        table.insert(vertices, {x = x, y = y})
    end

    -- Set the fill color
    surface.SetDrawColor(color)
    draw.NoTexture()
    -- Draw the hexagon fill
    surface.DrawPoly(vertices)

    -- If outline color is provided, draw the hexagon outline
    if outlineColor then
        surface.SetDrawColor(outlineColor)
        for i = 1, 6 do
            local nextIndex = i % 6 + 1
            surface.DrawLine(vertices[i].x, vertices[i].y, vertices[nextIndex].x, vertices[nextIndex].y)


        end
    end
    
    return vertices
end

local mode = "Fuel"
local lastSwitch = 0
local lastForceCheck = 0
local shouldDrawForce = 0
local heatMat = Material( "lvs/heat.png" )
function AOCRP.HUD:NewHUD()
    local Circles = {
        [1] = {r = -1, col = Color(0,0,0,200)},
        [2] = {r = 0, col = Color(255,255,255,200)},
        [3] = {r = 1, col = Color(255,255,255,255)},
        [4] = {r = 2, col = Color(255,255,255,200)},
        [5] = {r = 3, col = Color(0,0,0,200)},
    }
    local function DrawCircle( X, Y, target_radius, heatvalue )
        local endang = 360 * heatvalue
    
        if endang == 0 then return end
    
        for i = 1, #Circles do
            local data = Circles[ i ]
            local radius = target_radius + data.r
            local segmentdist = endang / ( math.pi * radius / 2 )
    
            for a = 0, endang, segmentdist do
                local r = data.col.r
                local g = data.col.g * (1 - math.min(a / 270,1))
                local b = data.col.b * (1 - math.min(a / 90,1))
    
                surface.SetDrawColor( r, g, b, data.col.a )
    
                surface.DrawLine( X - math.sin( math.rad( a ) ) * radius, Y + math.cos( math.rad( a ) ) * radius, X - math.sin( math.rad( a + segmentdist ) ) * radius, Y + math.cos( math.rad( a + segmentdist ) ) * radius )
            end
        end
    end
    
    local function GetFormattedTimeLeft(timeLeft)

        if timeLeft < 60 then
            return tostring(math.ceil(timeLeft)) .. "s"
        else
            return tostring(math.ceil(timeLeft / 60)) .. "m"
        end
    end

    local function GetVerticesMid(hexaVertices, verti1, verti2)
        local barMidX = (hexaVertices[verti1].x + hexaVertices[verti2].x) / 2
        local barMidY = (hexaVertices[verti1].y + hexaVertices[verti2].y) / 2

        return barMidX, barMidY
    end

    local function DrawHexaBar(hexaVertices, verti1, verti2, left, color, width, gap, high)
            -- Calculate the midpoint between vertices 1 and 6
            local barMidX = (hexaVertices[verti1].x + hexaVertices[verti2].x) / 2
            local barMidY = (hexaVertices[verti1].y + hexaVertices[verti2].y) / 2
        
            -- Calculate the angle of the line between vertices 1 and 6
            local angle = math.atan2(hexaVertices[verti2].y - hexaVertices[verti1].y, hexaVertices[verti2].x - hexaVertices[verti1].x)
        
            -- Define the height and width of the bar
            local barHeight = high
            local barWidth = 0
            
            local actualWidth = width
            if left then
                actualWidth = 0-actualWidth
            end

            local actualGap = gap
            if left then
                actualGap = 0-actualGap
            end
        
            -- Calculate the coordinates for the left side of the bar
            local barLeftX = barMidX - barHeight * math.cos(angle) - 0.5 * math.sin(angle)
            local barLeftY = barMidY - barHeight * math.sin(angle) + 0.5 * math.cos(angle)
        
            -- Calculate the coordinates for the right side of the bar
            local barRightX = barMidX + barHeight * math.cos(angle) - 0.5 * math.sin(angle)
            local barRightY = barMidY + barHeight * math.sin(angle) + 0.5 * math.cos(angle)
        
            -- Draw the bar
            surface.SetDrawColor(color) -- Red color
            draw.NoTexture()
            surface.DrawPoly({
                {x = barLeftX + actualGap, y = barLeftY},
                {x = barRightX + actualGap, y = barRightY},
                {x = barRightX + actualGap + actualWidth, y = barRightY},
                {x = barLeftX + actualGap + actualWidth, y = barLeftY}
            })

    end
  
    -- Draw the hexagon with black fill and white outline

    if !IsValid(LocalPlayer()) then return end 

    hexaVertices = AOCRP.HUD:DrawHexagon(ScrW() / 2, ScrH() - AOCH(65), AOCW(55), Color(0, 0, 0, 200), Color(255, 255, 255),0)

    local hp = LocalPlayer():Health()
    local maxhp = LocalPlayer():GetMaxHealth()

    local armor = LocalPlayer():Armor()
    local maxarmor = LocalPlayer():GetMaxArmor()


    local InLVS = false 
    local currentLVS = NULL
    if LocalPlayer():InVehicle() then 
        local veh = LocalPlayer():GetVehicle()

        if veh:GetClass() == "prop_vehicle_prisoner_pod" then 
            local actualVeh = veh:GetParent()

            if IsValid(actualVeh) then

                if actualVeh.LVS then 
       
                    hp = actualVeh:GetHP()
                    maxhp = actualVeh.MaxHealth

                    armor = actualVeh:GetShield()
                    maxarmor = actualVeh.MaxShield
                    currentLVS = actualVeh
                    InLVS = true
                end 
            
            end
        end
    end

    local targetArmorWidth = math.min(AOCW(250) * (armor / maxarmor), AOCW(250))
    DrawHexaBar(hexaVertices, 2, 1, false, Color(0,0,0,200), AOCW(250), AOCW(10), AOCH(20) )
    DrawHexaBar(hexaVertices, 2, 1, false, Color(0,112,204,255), targetArmorWidth, AOCW(10), AOCH(20) )

    local targetHealthWidth = math.min(AOCW(250) * (hp / maxhp), AOCW(250))
    DrawHexaBar(hexaVertices, 4, 3, true, Color(0,0,0,200), AOCW(250), AOCW(10), AOCH(20) )
    DrawHexaBar(hexaVertices, 4, 3, true, Color(0,114,0,255), targetHealthWidth, AOCW(10), AOCH(20) )


    local x, y = GetVerticesMid(hexaVertices, 4, 3)
    draw.DrawText(math.Round(hp), AOCDerma:Font("AOCRP.NEWHUD.HP"), x-42,y-AOCH(15.5), Color(255,255,255,200), TEXT_ALIGN_RIGHT)

    local x, y = GetVerticesMid(hexaVertices, 2, 1)
    draw.DrawText(math.Round(armor), AOCDerma:Font("AOCRP.NEWHUD.HP"), x+42,y-AOCH(15.5), Color(255,255,255,200), TEXT_ALIGN_LEFT)


    local textColor = Color(255,255,255,255)
    local cooldown = LocalPlayer():GetNetVar("AOCRP_AbilityDelay", CurTime())
    if cooldown > CurTime() then
	    textColor = Color( 255, 255, 255, 10)
    end

    local x, y = GetVerticesMid(hexaVertices, 4,3)

    local abilityIcon = "..."
    local abilityName = ""

    if LocalPlayer():GetCurrentAbility() != "" then 
        if AOCRP.Ability.Items[LocalPlayer():GetCurrentAbility()] then
            abilityIcon = AOCRP.Ability.Items[LocalPlayer():GetCurrentAbility()].icon
            abilityName = AOCRP.Ability.Items[LocalPlayer():GetCurrentAbility()].name
        end
    end

    if !InLVS then
        AOCDerma:DrawTextShadow(abilityIcon, AOCDerma:DF("aurebesh", 40), ScrW()/2, y-AOCH(40), textColor, TEXT_ALIGN_CENTER)
        AOCDerma:DrawTextShadow(string.upper(abilityName), AOCDerma:DF("s", 15), ScrW()/2, y-AOCH(15), textColor, TEXT_ALIGN_CENTER)
    else 
        local Base = LocalPlayer():lvsGetWeaponHandler()

        if not IsValid( Base ) then return end

        if not Base:HasWeapon( Base:GetSelectedWeapon() ) then return end

        local Heat = Base:GetNWHeat()
 
        DrawCircle( ScrW()/2, y-AOCH(23), 50, Heat )
    
        surface.SetMaterial( heatMat )
        surface.SetDrawColor( 255, 255, 255, 200)
        surface.DrawTexturedRect( ScrW()/2-80/2, y-AOCH(55), 80, 80 )

        local Vel = currentLVS:GetVelocity():Length()
        local kmh = math.Round(Vel * 0.09144,0)

        AOCDerma:DrawTextShadow("Geschwindigkeit (km/h)", AOCDerma:Font("AOCRP.NEWHUD.FIREMODE"), hexaVertices[4].x-AOCW(250/2), hexaVertices[4].y-AOCH(55), Color(204,204,204), TEXT_ALIGN_CENTER)
        AOCDerma:DrawTextShadow(kmh, AOCDerma:Font("AOCRP.NEWHUD.AMMO1"), hexaVertices[4].x-AOCW(250/2), hexaVertices[4].y-AOCH(35), Color(255,255,255), TEXT_ALIGN_CENTER)


        AOCDerma:DrawTextShadow( currentLVS:EntIndex(), AOCDerma:Font("AOCRP.NEWHUD.AMMO1"), ScrW()/2, hexaVertices[4].y-AOCH(90), Color(255,255,255), TEXT_ALIGN_CENTER)

  
    
        if Base:GetMaxAmmo() > 0 then
            AOCDerma:DrawTextShadow("Munnition", AOCDerma:Font("AOCRP.NEWHUD.FIREMODE"), hexaVertices[1].x+AOCW(250/2), hexaVertices[1].y-AOCH(55), Color(204,204,204), TEXT_ALIGN_CENTER)

            AOCDerma:DrawTextShadow(Base:GetNWAmmo(), AOCDerma:Font("AOCRP.NEWHUD.AMMO1"), hexaVertices[1].x+AOCW(250/2), hexaVertices[1].y-AOCH(35), Color(255,255,255), TEXT_ALIGN_CENTER)
        end 
        
    end 

--[[     if AOCRP.Squad:InValidSquad(LocalPlayer()) then 
        draw.DrawText(LocalPlayer():EntIndex(), AOCDerma:Font("AOCRP.NEWHUD.HP"), ScrW()/2,y-AOCH(110), Color(255,0,0,200), TEXT_ALIGN_CENTER)
    end ]]

    draw.RoundedBox(0,hexaVertices[4].x-AOCW(250+15), hexaVertices[4].y, AOCW(250+15), 1, Color(255,255,255))
    draw.RoundedBox(0,hexaVertices[1].x, hexaVertices[1].y, AOCW(250+15), 1, Color(255,255,255))

    if cooldown > CurTime() then
        AOCDerma:DrawTextShadow(GetFormattedTimeLeft(cooldown - CurTime()), AOCDerma:Font("AOCRP.NEWHUD.COOLDOWN"), ScrW()/2, y-AOCH(37), Color(255,255,255), TEXT_ALIGN_CENTER)
    end



    local wep = LocalPlayer():GetActiveWeapon()

    if IsValid(wep) then 
        local text = wep:GetPrintName()
        local ammo = LocalPlayer():GetAmmoCount( wep:GetPrimaryAmmoType() ) or 0
        local clip = wep:Clip1() or -1

        if ammo != 0 and clip != -1 then
            AOCDerma:DrawTextShadow(clip.." / "..ammo, AOCDerma:Font("AOCRP.NEWHUD.AMMO1"), hexaVertices[1].x+AOCW(250/2), hexaVertices[1].y-AOCH(35), Color(255,255,255), TEXT_ALIGN_CENTER)
        else
            if clip > 0  then 
                AOCDerma:DrawTextShadow(clip, AOCDerma:Font("AOCRP.NEWHUD.AMMO1"), hexaVertices[1].x+AOCW(250/2), hexaVertices[1].y-AOCH(35), Color(255,255,255), TEXT_ALIGN_CENTER)
            end
        end 



        if wep.GetFiremodeName then
         AOCDerma:DrawTextShadow(wep:GetFiremodeName(), AOCDerma:Font("AOCRP.NEWHUD.FIREMODE"), hexaVertices[1].x+AOCW(250/2), hexaVertices[1].y-AOCH(55), Color(204,204,204), TEXT_ALIGN_CENTER)
        end
    end

    if IsValid(LocalPlayer():GetNetVar("AOCRP_Emplacement", self)) then
        local ent = LocalPlayer():GetNetVar("AOCRP_Emplacement", self)

        AOCDerma:DrawTextShadow("Hitzelevel", AOCDerma:Font("AOCRP.NEWHUD.FIREMODE"), hexaVertices[4].x-AOCW(250/2), hexaVertices[4].y-AOCH(55), Color(204,204,204), TEXT_ALIGN_CENTER)
        AOCDerma:DrawTextShadow(math.Round(ent:GetHeat()).."%", AOCDerma:Font("AOCRP.NEWHUD.AMMO1"), hexaVertices[4].x-AOCW(250/2), hexaVertices[4].y-AOCH(35), Color(255,255,255), TEXT_ALIGN_CENTER)
        return 
    end

    local jet = LocalPlayer():GetNetVar('Jetted')

    local fullForce = LocalPlayer():lscsGetForce() >= LocalPlayer():lscsGetMaxForce()

    if lastForceCheck <= CurTime() then
        fullForce = LocalPlayer():lscsGetForce() >= LocalPlayer():lscsGetMaxForce()
        shouldDrawForce = not fullForce and CurTime() + 5 or 0
        lastForceCheck = CurTime() + 5
    end

    if LocalPlayer():lscsGetForce() < LocalPlayer():lscsGetMaxForce() then
        shouldDrawForce = CurTime() + 5 
        lastForceCheck = CurTime() + 5
    end

    if shouldDrawForce >= CurTime() and IsValid(jet) then
        if lastSwitch <= CurTime() then
            mode = (mode == "Force") and "Fuel" or "Force"
            lastSwitch = CurTime() + 5
        end

        if mode == "Force" then
            local ply = LocalPlayer()

            AOCDerma:DrawTextShadow("Deine Macht", AOCDerma:Font("AOCRP.NEWHUD.FIREMODE"), hexaVertices[4].x-AOCW(250/2), hexaVertices[4].y-AOCH(55), Color(204,204,204), TEXT_ALIGN_CENTER)
            AOCDerma:DrawTextShadow(math.Round(ply:lscsGetForce(), 0).."%", AOCDerma:Font("AOCRP.NEWHUD.AMMO1"), hexaVertices[4].x-AOCW(250/2), hexaVertices[4].y-AOCH(35), Color(255,255,255), TEXT_ALIGN_CENTER)
        else
            local cf, mf = jet:GetFuel(), jet:GetMaxFuel()
            local percent = math.floor(cf/mf*100)
    
            AOCDerma:DrawTextShadow("Kraftstoff", AOCDerma:Font("AOCRP.NEWHUD.FIREMODE"), hexaVertices[4].x-AOCW(250/2), hexaVertices[4].y-AOCH(55), Color(204,204,204), TEXT_ALIGN_CENTER)
            AOCDerma:DrawTextShadow(percent.."%", AOCDerma:Font("AOCRP.NEWHUD.AMMO1"), hexaVertices[4].x-AOCW(250/2), hexaVertices[4].y-AOCH(35), Color(255,255,255), TEXT_ALIGN_CENTER)
        end
    elseif shouldDrawForce >= CurTime() then 
        local ply = LocalPlayer()

        AOCDerma:DrawTextShadow("Deine Macht", AOCDerma:Font("AOCRP.NEWHUD.FIREMODE"), hexaVertices[4].x-AOCW(250/2), hexaVertices[4].y-AOCH(55), Color(204,204,204), TEXT_ALIGN_CENTER)
        AOCDerma:DrawTextShadow(math.Round(ply:lscsGetForce(), 0) .."%", AOCDerma:Font("AOCRP.NEWHUD.AMMO1"), hexaVertices[4].x-AOCW(250/2), hexaVertices[4].y-AOCH(35), Color(255,255,255), TEXT_ALIGN_CENTER)
    elseif IsValid(jet) then
        cf, mf = jet:GetFuel(), jet:GetMaxFuel()
        local percent = math.floor(cf/mf*100)

        AOCDerma:DrawTextShadow("Kraftstoff", AOCDerma:Font("AOCRP.NEWHUD.FIREMODE"), hexaVertices[4].x-AOCW(250/2), hexaVertices[4].y-AOCH(55), Color(204,204,204), TEXT_ALIGN_CENTER)
        AOCDerma:DrawTextShadow(percent.."%", AOCDerma:Font("AOCRP.NEWHUD.AMMO1"), hexaVertices[4].x-AOCW(250/2), hexaVertices[4].y-AOCH(35), Color(255,255,255), TEXT_ALIGN_CENTER)
    end
end
--gamemodes/starwarsrp/gamemode/modules/gear/sh_gear.lua:

AOCRP.Gear = AOCRP.Gear or {}

AOCRP.Perm:AddPermission("GearEdit", "Verwaltung")

function AOCRP.Gear:UnJSONGearData(geardata)

    geardata.models = util.JSONToTable(geardata.models)
    geardata.weapons = util.JSONToTable(geardata.weapons)
    geardata.weaponbox = util.JSONToTable(geardata.weaponbox)
    geardata.vehicles = util.JSONToTable(geardata.vehicles)
    geardata.attachments = util.JSONToTable(geardata.attachments)
    return geardata
end

function AOCRP.Gear:PlayerGetGearData(ply)
    return AOCRP.Gear:GetGearData(ply:GetGearID())
end

function AOCRP.Gear:GetGearData(gearid)
    return AOCRP.Gears[gearid]
end

function AOCRP.Gear:GetCurrentCount(gear)
    local count = 0
    for k, v in ipairs(player.GetAll()) do
        if v:GetGearID() == gear then
            count = count + 1
        end
    end
    return count
end


function AOCRP.Gear:HasWeaponInBox(ply, weapon)
    if SERVER then
        return table.HasValue(AOCRP.Gear.Data[ply:GetGearID()].weaponbox, weapon )
    else 
        return table.HasValue(AOCRP.Gears[ply:GetGearID()].weaponbox, weapon )
    end

end


if CLIENT then

    function AOCRP.Gear:ReloadGears()

        AOCRP.API:Request("getgears", function(data)

            AOCRP.Gears = {}
            if #data > 0 then
                for k, v in pairs(data) do
                    AOCRP.Gears[v.gearid] = AOCRP.Gear:UnJSONGearData(v)
                end
            end
        
            print("[AOCRP] Die Ausrüstungsdaten wurden neugeladen.")

        end, {})


    end

    net.Receive( "AOCRP.Gear.ReloadGears", function( len, ply )
        AOCRP.Gear:ReloadGears()   
    end)    

end
--gamemodes/starwarsrp/gamemode/modules/char/cl_char.lua:

AOCRP.CharSys = AOCRP.CharSys or {}



function AOCRP.CharSys:RequestOpen()
    
    if !IsValid(LocalPlayer()) then return end

    AOCRP.CharSys.Loading = AOCDerma:CreateLoadingScreen("Charakterinformationen werden abgerufen")


        AOCRP.API:Request("getchars", function(data) 
            if ValidPanel(AOCRP.CharSys.Loading) then AOCRP.CharSys.Loading:Remove() end
            AOCRP.CharSys:Open(data)
        end, { ["steamid"] = LocalPlayer():SteamID64() }, function(err) print(err) end)   


end




net.Receive( "AOCRP.CharSys.OpenCharMenu", function( len, ply )
    AOCRP.CharSys:RequestOpen()
end)

PIXEL.RegisterFont("AOCRP_CharMenuDeleteConfirm", "Agency FB", 25, 1000)
PIXEL.RegisterFont("AOCRP_CharMenuNew_CloneID", "Agency FB", 60, 1000)
PIXEL.RegisterFont("AOCRP_CharMenu_Name", "Agency FB", 45, 1000)
PIXEL.RegisterFont("AOCRP_CharMenu_Rank", "Agency FB", 35, 10)
PIXEL.RegisterFont("AOCRP_CharMenu_ID", "Aurebesh", 20, 10)
PIXEL.RegisterFont("AOCRP_CharMenu_BTN", "Agency FB", 40, 10)
PIXEL.RegisterFont("AOCRP_Loading_Aurebesh", "Aurebesh", 15, 10)
-- net.Recieve Data calls
local charbg = Material( "aoc/charbg.png", "noclamp smooth" )
local mombg = Material( "aoc/umom.png", "noclamp smooth" )
local newchar = Material( "aoc/newchar.png", "noclamp smooth" )
local deletechar = Material( "aoc/killfives2.png", "noclamp smooth" )
local aoclogo = Material( "aoc/aocmain.png", "noclamp smooth" )

local function insert_dash(str)
  -- Extract the first two digits and the rest of the string
  local first_two = string.sub(str, 1, 2)
  local rest = string.sub(str, 3)

  -- Insert the dash between the first two digits and the rest of the string
  return first_two .. "-" .. rest
end



function fade_in_dpanel(dpanel, duration)
  -- Set the DPanel's alpha to 0 (fully transparent)
  dpanel:SetAlpha(0)

  -- Save the start time of the fade
  local start_time = RealTime()

  -- Set up a hook to update the DPanel's alpha over time
  hook.Add("Think", "fade_in_dpanel_hook", function()
    -- Calculate the elapsed time and the progress of the fade
    local elapsed = RealTime() - start_time
    local fraction = math.min(1, elapsed / duration)

    -- Calculate the new alpha based on the progress of the fade
    local new_alpha = 255 * fraction

    -- Set the new alpha
    dpanel:SetAlpha(new_alpha)

    -- If the fade is complete, remove the hook
    if fraction >= 1 then
      hook.Remove("Think", "fade_in_dpanel_hook")
    end
  end)
end

function fade_out_dpanel(dpanel, duration)
  -- Set the DPanel's alpha to 255 (fully opaque)
  dpanel:SetAlpha(255)

  -- Save the start time of the fade
  local start_time = RealTime()

  -- Set up a hook to update the DPanel's alpha over time
  hook.Add("Think", "fade_out_dpanel_hook", function()
    -- Calculate the elapsed time and the progress of the fade
    local elapsed = RealTime() - start_time
    local fraction = math.min(1, elapsed / duration)

    -- Calculate the new alpha based on the progress of the fade
    local new_alpha = 255 * (1 - fraction)

    -- Set the new alpha
    dpanel:SetAlpha(new_alpha)

    -- If the fade is complete, remove the hook
    if fraction >= 1 then
      hook.Remove("Think", "fade_out_dpanel_hook")
      dpanel:SetVisible(false)
    end
  end)
end



net.Receive( "AOCRP.CharSys.OpenNewCharMenu", function( len, ply )
    local id = net.ReadString()
    AOCRP.CharSys:OpenNewChar(id)
end)
net.Receive( "AOCRP.CharSys.OpenNewCharMenuError", function( len, ply )
    local id = net.ReadString()
    AOCRP.CharSys:OpenNewChar(id,true)
end)

function AOCRP.CharSys:OpenNewChar(cloneid,err)
    if self.FRAME then self.FRAME:Remove() end
    self.FRAME = vgui.Create("DFrame") -- The name of the panel we don't have to parent it.
    self.FRAME:SetSize(ScrW(), ScrH()) -- Set the size to 300x by 200y.
    self.FRAME:Center()
    self.FRAME:SetTitle("") -- Set the title in the top left to "Derma Frame".
    self.FRAME:MakePopup() -- Makes your mouse be able to move around.
    self.FRAME:SetDraggable(false)
    self.FRAME:SetSizable(false)
    self.FRAME:ShowCloseButton(false)

            sound.PlayFile( "sound/aoc2/birthchamber.wav", "noplay", function( station, errCode, errStr )
                if ( IsValid( station ) ) then
                    station:Play()
                    station:SetVolume( 0.5 )
                    self.FRAME.SoundStation = station
                else
                    print( "Error playing sound!", errCode, errStr )
                end
            end )

    local errtext = "Dein Name darf keine Nummern enthalten, kein Leerzeichen enthalten, darf nicht länger als 10 Zeichen und nicht kürzer als 3 Zeichen sein und darf nur Buchstaben von A-Z enthalten. \n Verbotene Wörter und bekannte Klone sind ebenfalls untersagt."

    function self.FRAME:Paint(w,h)

        surface.SetMaterial( newchar )
        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.DrawTexturedRect( 0, 0, w, h )

        draw.DrawText( string.upper("Diese Kloneinheit entspricht den vorgebenen Anforderungen."), PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Name"], w/2 + 1, AOCH(30) + 1, Color(0, 0, 0), TEXT_ALIGN_CENTER  )
        draw.DrawText( string.upper("Diese Kloneinheit entspricht den vorgebenen Anforderungen."), PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Name"], w/2, AOCH(30), Color(211, 211, 0), TEXT_ALIGN_CENTER  )
        draw.DrawText( string.upper("Diese Einheit bekommt folgende Registierungsnummer:"), PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Name"], w/2 + 1, AOCH(70) + 1, Color(0, 0, 0), TEXT_ALIGN_CENTER  )
        draw.DrawText( string.upper("Diese Einheit bekommt folgende Registierungsnummer:"), PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Name"], w/2, AOCH(70), Color(211, 211, 0), TEXT_ALIGN_CENTER  )
        draw.DrawText( string.upper("CT "..insert_dash(cloneid)), PIXEL.UI.RegisteredFonts["AOCRP_CharMenuNew_CloneID"], w/2 + 1, AOCH(130) + 1, Color(0, 0, 0), TEXT_ALIGN_CENTER  )
        draw.DrawText( string.upper("CT "..insert_dash(cloneid)), PIXEL.UI.RegisteredFonts["AOCRP_CharMenuNew_CloneID"], w/2, AOCH(130), Color(211, 211, 0), TEXT_ALIGN_CENTER  )

        if err then 
        draw.DrawText( errtext, PIXEL.UI.RegisteredFonts["AOCRP_CharMenuDeleteConfirm"], w/2 + 1, AOCH(700) + 1, Color(0, 0, 0), TEXT_ALIGN_CENTER  )
        draw.DrawText( errtext, PIXEL.UI.RegisteredFonts["AOCRP_CharMenuDeleteConfirm"], w/2, AOCH(700), Color(180, 0, 0), TEXT_ALIGN_CENTER  )
        end

        draw.DrawText( "Wie sollen dich deine Brüder zukünftig nennen?", PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Name"], w/2 + 1, AOCH(800) + 1, Color(0, 0, 0), TEXT_ALIGN_CENTER  )
        draw.DrawText( "Wie sollen dich deine Brüder zukünftig nennen?", PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Name"], w/2, AOCH(800), Color(211, 211, 0), TEXT_ALIGN_CENTER  )
    end

    function self.FRAME:OnRemove()
        if IsValid(self.SoundStation) then
            self.SoundStation:Stop()
        end
    end

    local callname = AOCDerma:TextEntry(self.FRAME,"Rufname")
    local callw, callh = AOCW(600), AOCH(50)
    callname:SetSize(callw,callh)
    callname:SetPos(ScrW()/2-callw/2, AOCH(850))
    callname.Paint = function(self, w, h)
    draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 203))
    self:DrawTextEntryText(Color(255, 255, 255), Color(74, 168, 255, 176), Color(255, 255, 255))
    end
    callname:SetUpdateOnType(true)
    callname:SetTabbingDisabled( true )

        local btndelete = AOCDerma:Button(self.FRAME, "ABBRUCH", function() RunConsoleCommand("aocrp_charmenu") end, "bc")
        --btndelete:Dock( RIGHT )
        --btndelete:SetVisible(true)
        btndelete:SetPos(ScrW()/2-AOCW(200)/2,AOCH(980))
        btndelete:SetWide(AOCW(200))
        btndelete.akzent = Color(200,0,0,255)
        btndelete.akzenthover = Color(255,0,0,255)
        btndelete.textfont = PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_BTN"]
        btndelete.akzentsize = 3


        local btndelete = AOCDerma:Button(self.FRAME, "KLONTANK VERLASSEN", function()  
        
        local name = callname:GetValue()
        net.Start("AOCRP.CharSys.CreateNewCharRequest")
        net.WriteString(cloneid)
        net.WriteString(name)
        net.SendToServer()
        
        self.FRAME:Remove() 

        end, "bc")
        --btndelete:Dock( RIGHT )
        --btndelete:SetVisible(true)
        btndelete:SetPos(ScrW()/2-AOCW(350)/2,AOCH(920))
        btndelete:SetWide(AOCW(350))
        btndelete.akzent = Color(0,200,0,255)
        btndelete.akzenthover = Color(0,255,0,255)
        btndelete.textfont = PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_BTN"]
        btndelete.akzentsize = 3


        local btndelete = AOCDerma:Button(self.FRAME, "Namensgenerator", function()  
        
        AOCDerma:OpenWebPage("Namesgenerator","https://www.fantasynamegenerators.com/sw-clone-names.php")

        end, "bc")

        btndelete:SetPos(AOCW(10),AOCH(1020))
        btndelete.textfont = PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_BTN"]
        btndelete.akzentsize = 3

end


function AOCRP.CharSys:OpenDeleteChar(data)
    if self.FRAME then self.FRAME:Remove() end
    self.FRAME = vgui.Create("DFrame") -- The name of the panel we don't have to parent it.
    self.FRAME:SetSize(ScrW(), ScrH()) -- Set the size to 300x by 200y.
    self.FRAME:Center()
    self.FRAME:SetTitle("") -- Set the title in the top left to "Derma Frame".
    self.FRAME:MakePopup() -- Makes your mouse be able to move around.
    self.FRAME:SetDraggable(false)
    self.FRAME:SetSizable(false)
    self.FRAME:ShowCloseButton(false)




    function self.FRAME:Paint(w,h)

        surface.SetMaterial( deletechar )
        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.DrawTexturedRect( 0, 0, w, h )

        draw.DrawText( string.upper(insert_dash(data.cloneid)), PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_ID"], AOCW(455), AOCH(450), Color(31,31,31), TEXT_ALIGN_CENTER  )

       draw.DrawText( string.upper("Deserteure werden nicht gedulded!"), PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Name"], AOCW(1500) + 1, AOCH(100) + 1, Color(0, 0, 0), TEXT_ALIGN_CENTER  )
        draw.DrawText( string.upper("Deserteure werden nicht gedulded!"), PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Name"], AOCW(1500), AOCH(100), Color(133,0,0), TEXT_ALIGN_CENTER  )

        draw.DrawText( "Deinen Charakter wirklich löschen? Diese Aktion kann nicht rückgängig gemacht werden!", PIXEL.UI.RegisteredFonts["AOCRP_CharMenuDeleteConfirm"], AOCW(1500), AOCH(140), Color(0,0,0), TEXT_ALIGN_CENTER  )
    end

        local btndelete = AOCDerma:Button(self.FRAME, "EXEKUTIEREN", function() 
        
        net.Start("AOCRP.CharSys.DeleteCharRequest")
        net.WriteString(data.cloneid)
        net.SendToServer()

        self.FRAME:Remove()
        end, "tlrbc")
        --btndelete:Dock( RIGHT )
        --btndelete:SetVisible(true)
        btndelete:SetPos(AOCW(1302.5),AOCH(240))
        btndelete:SetWide(AOCW(400))
        btndelete.akzent = Color(200,0,0,255)
        btndelete.akzenthover = Color(255,0,0,255)
        btndelete.textfont = PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_BTN"]
        btndelete.akzentsize = 3


        local btndelete = AOCDerma:Button(self.FRAME, "DOCH NICHT", function() RunConsoleCommand("aocrp_charmenu") end, "bc")
        --btndelete:Dock( RIGHT )
        --btndelete:SetVisible(true)
        btndelete:SetPos(AOCW(1250),AOCH(180))

        btndelete:SetWide(AOCW(505))
        btndelete.akzent = Color(0,200,0,255)
        btndelete.akzenthover = Color(0,255,0,255)
        btndelete.textfont = PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_BTN"]
        btndelete.akzentsize = 3

end


function AOCRP.CharSys:Open(data)
    if self.WELCOMEFRAME then self.WELCOMEFRAME:Remove() end
    if self.FRAME then self.FRAME:Remove() end
    self.FRAME = vgui.Create("DFrame") -- The name of the panel we don't have to parent it.
    self.FRAME:SetSize(ScrW(), ScrH()) -- Set the size to 300x by 200y.
    self.FRAME:Center()
    self.FRAME:SetTitle("") -- Set the title in the top left to "Derma Frame".
    self.FRAME:MakePopup() -- Makes your mouse be able to move around.
    self.FRAME:SetDraggable(false)
    self.FRAME:SetSizable(false)
    self.FRAME:ShowCloseButton(false)


    function self.FRAME:Paint(w,h)
       surface.SetMaterial( charbg )
        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.DrawTexturedRect( 0, 0, w, h )

        if !data[1] then
            draw.RoundedBox(0,0,AOCH(799),w,AOCH(50),Color(0,0,0,240))
            draw.DrawText( "Drücke auf ein 'LEER'-Feld um deinen ersten Klon zu erstellen!", PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Name"], w/2 + 1, AOCH(800) + 1, Color(0, 0, 0), TEXT_ALIGN_CENTER  )
            draw.DrawText( "Drücke auf ein 'LEER'-Feld um deinen ersten Klon zu erstellen!", PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Name"], w/2, AOCH(800), Color(211, 211, 0), TEXT_ALIGN_CENTER  )

            surface.SetMaterial( aoclogo )
            surface.SetDrawColor( 255, 255, 255, 255 )
            surface.DrawTexturedRect( w/2-AOCW(500)/2, h/2-AOCH(500)/2, AOCW(500), AOCH(500) )
        end
    end


    local ModelDiv = vgui.Create("DPanel", self.FRAME)
    ModelDiv:Dock(FILL)
    ModelDiv:SetPaintBackground( false )
   


    local function CreateChar()
        local but = vgui.Create( "DPanel", ModelDiv )
        --but:SetText( "test" )
        --but:SetSize( AOCW(1850), AOCH(500) )
        local abstand = 500
        but:DockMargin(AOCW(abstand), AOCH(300), AOCW(abstand), 0)
        but:Dock(FILL)
         but:SetPaintBackground( false )

      --[[   local name = vgui.Create("DPanel", but)
        name:SetTall(AOCH(100))
        name:Dock(TOP) ]]


        self.FRAME.mdl = vgui.Create( "DModelPanel", but )
        local mdl = self.FRAME.mdl
        --but:SetSize(200,200)
        mdl:Dock(FILL)
        mdl:SetModel( "models/starwars/grady/stosstruppen/st_trooper_k9.mdl" ) -- you can only change colors on playermodels

        function mdl:LayoutEntity( Entity ) return end -- disables default rotation
        function mdl.Entity:GetPlayerColor() return Vector (1, 0, 0) end

        local lookat = mdl:GetLookAt()
        local campos = mdl:GetCamPos()
        mdl:SetLookAt(lookat+Vector(0,0,10))
        mdl:SetCamPos(campos+Vector(-15,-15,10))
        mdl.Entity:SetAngles(Angle(0, 50, 0))
        mdl:SetAnimated(true)
        ApplyCharAnimation(mdl.Entity, math.random(0,1))



        if false then

            mdl:SetDirectionalLight(BOX_FRONT, Color(0, 0, 0))
            mdl:SetDirectionalLight(BOX_TOP, Color(0, 0, 0))
            mdl:SetDirectionalLight(BOX_BOTTOM, Color(0, 0, 0))
            mdl:SetDirectionalLight(BOX_RIGHT, Color(0, 0, 0))

        else

            mdl:SetDirectionalLight(BOX_FRONT, Color(48, 48, 48))
            mdl:SetDirectionalLight(BOX_TOP, Color(0, 0, 0))
            mdl:SetDirectionalLight(BOX_BOTTOM, Color(0, 0, 0))
            mdl:SetDirectionalLight(BOX_RIGHT, Color(167, 167, 167))
        end 


    end

    CreateChar()
--[[ 
    local VIgnetteGif = vgui.Create("DPanel", self.FRAME)
    --VIgnetteGif:Dock(FILL)
    VIgnetteGif:SetSize(ScrW(), ScrH())
    --VIgnetteGif:SetPaintBackground( true )

    function VIgnetteGif:Paint(w,h) 
           surface.SetMaterial( mombg )
        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.DrawTexturedRect( 0, 0, w, h )

    end
 ]]

    function GetSlotCount()
        return AOCRP.CharSys:AllowedCharSlots(LocalPlayer())
    end

    function DrawCharSlot(x,y,data,hasaccess)
        local CharCount = 1

        local NamePanel = vgui.Create("DPanel", self.FRAME)
        local scaleX, scaleY = AOCW(350),AOCH(200)
        NamePanel:SetPos(x-scaleX/2, y-scaleY)
        NamePanel:SetSize(scaleX,scaleY-10)
        NamePanel.sel = false
        NamePanel.akzentLine = Color(255,255,255)
        local hover = false

        local text = ""
        local textcolor = Color(255,255,255,255)

        if data then
            text = data.name
            --NamePanel.sel = true
        else
            text = "LEER"
        end

        
        if !hasaccess then 
            text = "GESPERRT"
            textcolor = Color(200,200,200,255)
            NamePanel.akzentLine = Color(200,0,0)
        end


        local btnpanel = vgui.Create("DPanel", NamePanel)
        btnpanel:Dock(BOTTOM)
        btnpanel:SetPaintBackground( false )
        btnpanel:SetVisible(false)
        btnpanel:SetTall(AOCH(50))
        btnpanel:DockMargin(15,10,15,10)

        local btn = AOCDerma:Button(btnpanel, "Auswählen", function() 
        
            net.Start("AOCRP.CharSys.ChooseCharacter")
            net.WriteString(data.cloneid)
            net.SendToServer()
            self.FRAME:Remove()
        
        end, "bc")
        --btn:Dock( LEFT )
        --btn:SetVisible(false)
        btn:SetPos(AOCW(0),AOCH(0))
        local oldX, oldY = btn:GetSize()
        btn:SetSize(oldX+AOCW(60),oldY)
        btn.akzent = Color(0,200,0,255)
        btn.akzenthover = Color(0,255,0,255)
        btn.textfont = PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_BTN"]
        btn.akzentsize = 3
        local btndelete = AOCDerma:Button(btnpanel, "Löschen", function() AOCRP.CharSys:OpenDeleteChar(data) end, "bc")
        --btndelete:Dock( RIGHT )
        --btndelete:SetVisible(true)
        btndelete:SetPos(AOCW(210),AOCH(0))
        btndelete.akzent = Color(200,0,0,255)
        btndelete.akzenthover = Color(255,0,0,255)
        btndelete.textfont = PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_BTN"]
        btndelete.akzentsize = 3

        function NamePanel:Paint(w,h) 

            if self.sel then
                draw.RoundedBox(0,0,0,w,h,Color(0,0,0,100))
                draw.DrawText( string.upper(text), PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Name"], w/2+2, AOCH(32), color_black, TEXT_ALIGN_CENTER )
                draw.DrawText( string.upper(text), PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Name"], w/2, AOCH(30), textcolor, TEXT_ALIGN_CENTER  )
                btnpanel:SetVisible(true)
                if data then
                    if data.rankid then
                        --draw.DrawText( string.upper(AOCRP.Config.Ranks[data.rankid].name), PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Rank"], w/2+2, AOCH(52), color_black, TEXT_ALIGN_CENTER )
                        draw.DrawText( string.upper(AOCRP.Unit:GetRankName(data.rankid, data.unitid)), PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Rank"], w/2, AOCH(75), textcolor, TEXT_ALIGN_CENTER  ) 
                    end
                    if data.cloneid then
                        --draw.DrawText( string.upper(AOCRP.Config.Ranks[data.rankid].name), PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Rank"], w/2+2, AOCH(52), color_black, TEXT_ALIGN_CENTER )
                        draw.DrawText( string.upper(insert_dash(data.cloneid)), PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_ID"], w/2, AOCH(10), textcolor, TEXT_ALIGN_CENTER  ) 
                    end
                end
            else
                draw.RoundedBox(0,0,h/2+AOCH(30),w,h/2-AOCH(30),Color(0,0,0,100))
                draw.DrawText( string.upper(text), PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Name"], w/2+2, h/2+AOCH(40)+2, color_black, TEXT_ALIGN_CENTER )
                draw.DrawText( string.upper(text), PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Name"], w/2, h/2+AOCH(40), textcolor, TEXT_ALIGN_CENTER  )
                btnpanel:SetVisible(false)

                if self:IsHovered() then
                     draw.RoundedBox(0,0,h/2+AOCH(30),2,h/2-AOCH(30),self.akzentLine)
                    draw.RoundedBox(0,w-2,h/2+AOCH(30),2,h/2-AOCH(30),self.akzentLine)
                     draw.RoundedBox(0,0,h/2+AOCH(30),w,2,self.akzentLine)
                end
            end

            draw.RoundedBox(0,0,h-2,w,2,self.akzentLine)
        end
        NamePanel.OnMousePressed = function(self)
            if hasaccess then
                if data then
                    trigger_change_anim(self,data)
                else
                    RunConsoleCommand("newchar")
                end
            else
                AOCDerma:OpenWebPage("Age of Clones Shop", "https://portal.212th.de/shop/category/77d6e351-8b6b-44cd-bfbb-842a7e666624")
                --AOCDerma:OpenYoutubeVideo( "Pech yo", "y3hWYZ4rLXo")
            end
            --hide_other_dpanels(self)
        end

        return NamePanel
    end


    
    local slot1 = DrawCharSlot(AOCW(240),ScrH(), data[1], true)
    local slot2 = DrawCharSlot(AOCW(600),ScrH(), data[2], GetSlotCount()>1 )
    local slot3 = DrawCharSlot(ScrW()/2,ScrH(), data[3], GetSlotCount()>2)
    local slot4 = DrawCharSlot(AOCW(1320),ScrH(), data[4], GetSlotCount()>3)
    local slot5 = DrawCharSlot(AOCW(1680),ScrH(), data[5], GetSlotCount()>4)


    local slotpanels = {slot1,slot2,slot3,slot4,slot5}


    local blackscreenpanel = vgui.Create("DPanel", self.FRAME)
    --VIgnetteGif:Dock(FILL)
    blackscreenpanel:SetSize(ScrW(), ScrH())
    --VIgnetteGif:SetPaintBackground( true )

    function blackscreenpanel:Paint(w,h) 
        draw.RoundedBox(0,0,0,w,h,Color(0,0,0))
    end
    blackscreenpanel:SetVisible(false)


    function applyModelModifiers(mdl)
            ApplyCharAnimation(mdl.Entity, math.random(0,1))
            mdl.Entity:SetAngles(Angle(0, 50, 0))
    end

    function trigger_change_anim(panel,data)

        blackscreenpanel:SetVisible(true) 
        fade_in_dpanel(blackscreenpanel, 0.2)

        

        timer.Simple(0.3, function()
            sound.PlayFile( "sound/aoc2/blastdoor.wav", "noplay", function( station, errCode, errStr )
                if ( IsValid( station ) ) then
                    station:Play()
                else
                    print( "Error playing sound!", errCode, errStr )
                end
            end )
        end)
        timer.Simple(2, function() 
            
            hide_other_dpanels(panel)

            fade_out_dpanel(blackscreenpanel, 0.5)
            self.FRAME.mdl:SetModel( AOCRP.Gears[data.gearid].models[1] )
            applyModelModifiers(self.FRAME.mdl)
            self.FRAME.mdl:SetVisible(true)

        end)

    end



    function hide_other_dpanels(clicked) 
        for _, panel in pairs(slotpanels) do
            if panel ~= clicked then
                panel.sel = false
            else 
                panel.sel = true
            end
        end
    end


    self.FRAME.mdl:SetVisible(false)
--[[ 
    local DLabel = vgui.Create( "DLabel", self.FRAME )
    DLabel:SetPos( ScrW()/2, AOCH(1000) )
    DLabel:SetText( "99-9999 Grudge" )
    DLabel:SetFont(PIXEL.UI.RegisteredFonts["AOCRP_CharMenu_Name"])
    DLabel:SizeToContents()
    DLabel:SetContentAlignment( 5 ) ]]


    local closeBtn = AOCDerma:Button(self.FRAME, "Zurück", function() 
        self.FRAME:Remove()
    
    end, "tl")

    closeBtn:SetPos(0,0)

    if !LocalPlayer():IsInChar() then
        closeBtn:SetVisible(false)
    end

end

local CharAnims = {}

    CharAnims[0] = {
      ["ValveBiped.Bip01_R_Forearm"] = {
      ang = Angle(-44, -107, 16)
      },
      ["ValveBiped.Bip01_R_UpperArm"] = {
      ang = Angle(20, -57, -6)
      },
      ["ValveBiped.Bip01_L_UpperArm"] = {
      ang = Angle(-29, -59, 1)
      },
      ["ValveBiped.Bip01_R_Thigh"] = {
      ang = Angle(4.7, -6, -0.5)
      },
      ["ValveBiped.Bip01_L_Thigh"] = {
      ang = Angle(-7.7, -0.21, 0.4)
      },
      ["ValveBiped.Bip01_L_Forearm"] = {
      ang = Angle(51, -120, -19)
      },
      ["ValveBiped.Bip01_R_Hand"] = {
      ang = Angle(14.4, -33.4, -7.3)
      },
      ["ValveBiped.Bip01_L_Hand"] = {
      ang = Angle(26, 32, -15)
      }
    }

    CharAnims[1] = {
      ["ValveBiped.Bip01_R_UpperArm"] = {
      ang = Angle(3.8, 15.4, 2.7)
      },
      ["ValveBiped.Bip01_R_Forearm"] = {
      ang = Angle(-63.7, 1.8, -85)
      },
      ["ValveBiped.Bip01_L_UpperArm"] = {
      ang = Angle(3.8, 15, 2.7)
      },
      ["ValveBiped.Bip01_L_Forearm"] = {
      ang = Angle(53.7, -30, 31.5)
      },
      ["ValveBiped.Bip01_R_Thigh"] = {
      ang = Angle(4.8, 0, 0)
      },
      ["ValveBiped.Bip01_L_Thigh"] = {
      ang = Angle(-8.9, 0, 0)
      }
    }

function ApplyCharAnimation(ent, anim)

    for k, v in pairs(CharAnims[anim]) do
        if IsValid(ent) then 
            if ent:LookupBone( k ) != nil then
                ent:ManipulateBoneAngles( ent:LookupBone( k ), v.ang )
            end
        end
    end
end



--if AOCRP.CharSys.FRAME then AOCRP.CharSys.FRAME:Remove() end
--AOCRP.CharSys:Open()

--gamemodes/starwarsrp/gamemode/modules/admin/sh_teamstuff.lua:
AOCRP.Admin = AOCRP.Admin or {}


function AOCRP.Admin:GetTeamMembers()
    local tm = {}
    
    for k, v in pairs(player.GetHumans()) do
        if table.HasValue(AOCRP.Config.Team, v:GetUserGroup()) then
            table.insert(tm,v)
        end
    end
    return tm
end


function AOCRP.Admin:IsTeamMember(ply)
    if table.HasValue(AOCRP.Config.Team, ply:GetUserGroup()) then
        return true
    end
    return false
end
--addons/wos-passiveevent-ageo/lua/wos/pes/vgui/wos_viewnodes.lua:
local PANEL = {}

local bgMaterial = Material("wos/pes/bg.png", "noclamp smooth")

local borderBlack = Color(0, 0, 0, 150)
local bgBlack = Color(36,36,36) -- annoyingly 1 rgb off when actual rendering from the png WHY SOURCE WHYYYYY
local bgLighter = Color(255,255,255,100)

local bgWhite = Color(200,200,200)

function PANEL:AddNode( id, input_data )
	self.EventID = id
	local id = #self.Nodes + 1
	local x,y = self:GetCenter()
	
    local dbutton = vgui.Create("DButton", self._background)
    dbutton.main = self

	local wide = 280 * (ScrW()/1920)
    local tall = wide*0.8

    dbutton:SetPos(x-50, y-50)
	dbutton:SetSize( wide, tall )
    dbutton.ID = id
	dbutton:SetFont( "wOS.PES.NodeText" )


	-- dbutton.Links = input_data.Links
	-- dbutton.Active = input_data.Active
	-- dbutton.Type = input_data.Type

	-- dbutton:SetPos( input_data.Pos.x, input_data.Pos.y )
	-- dbutton:SetText( "" )
	-- dbutton.TextName = input_data.Name


	dbutton.DoClick = function()
		local isActive = dbutton.Active
		if not isActive then return end
		if IsValid(nodeWatchingMenu) then
			nodeWatchingMenu:Remove()
		end

        local dummy_frame = vgui.Create( "DFrame" )
        dummy_frame:SetSize( ScrW(), ScrH() )
        dummy_frame:SetTitle( "" )
        dummy_frame:ShowCloseButton( false )
        dummy_frame:SetDraggable( false )
        dummy_frame.Paint = function( pan, ww, hh )
            draw.RoundedBox(0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
        end
        dummy_frame:MakePopup()

		nodeWatchingMenu = vgui.Create("DFrame")
		nodeWatchingMenu:MakePopup()
		nodeWatchingMenu:SetSize(ScrW() * 0.25, ScrH() *0.25)
		nodeWatchingMenu:Center()

		nodeWatchingMenu.Think = function()
			nodeWatchingMenu:MoveToFront()
			if !IsValid(self) or not self:GetParent():IsVisible() then 
				nodeWatchingMenu:Remove()
			end
		end

        dummy_frame.Think = function( pan ) 
            if not IsValid( nodeWatchingMenu ) then
                pan:Remove()
            end
        end

		local scroll = vgui.Create("DScrollPanel", nodeWatchingMenu)
		local bw,bh = nodeWatchingMenu:GetSize()

		scroll:SetSize(bw, bh * 0.5)
		scroll:Dock(TOP)

		local button = vgui.Create("DButton", scroll)
		button:SetText("")
		button:Dock(TOP)
		button.Paint = function(self, w, h)
			local a, b = draw.SimpleText("ACTIVATE TRIGGERS", "wOS.PES.NodeText", 5, h/2, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			if a != w and b != h then
				button:SetSize(a, b)
			end
			surface.SetDrawColor(255,255,255)
			surface.DrawLine(5, h-1, w*0.75, h-1)
		end
		
		local bg = vgui.Create("DPanel", scroll)
		bg:Dock(TOP)

		button.DoClick = function()
			if bg:GetTall() == 0 then
				bg:SizeToChildren()
			else
				bg:SetTall(0)
			end
		end

		local noTriggers = true

		if dbutton.Type then
			local nodeData = wOS.PES.Nodes:Get(dbutton.Type)
			-- if chec
			local maxTriggers = #nodeData.Triggers
		
			for index, tdata in ipairs(nodeData.Triggers) do
				
				local trigger = tdata
				local trigger_name = trigger
				if istable( tdata ) then
					trigger = tdata.Type or trigger
					trigger_name = tdata.Name or trigger_name
				end

				local but = vgui.Create("DButton", bg)
				but:SetText( trigger_name )
				but:Dock(TOP)
				but.DoClick = function()
					wOS.PES.RequestTriggerStart(self.EventID, id, trigger)
					nodeWatchingMenu:Remove()
				end
				noTriggers = false
			end
		end

		if noTriggers then
			local but = vgui.Create("DButton", bg)
			but:SetText("Instant")
			but:Dock(TOP)
			but.DoClick = function()
				wOS.PES.RequestTriggerStart(self.EventID, id, "Instant")
			end
		end

		bg:SizeToChildren()
		bg:SetTall(100)
	end

	dbutton.Links = {}

	local VGUI_NodeMeta = vgui.GetControlTable( "WOS_PES_NODE" )
	dbutton.EventViewerNode = true
	dbutton.TriggerColorHierarchy = VGUI_NodeMeta.TriggerColorHierarchy
	dbutton.GetTriggerPos = VGUI_NodeMeta.GetTriggerPos
	dbutton.Paint = VGUI_NodeMeta.Paint
	dbutton.FormLinks = self.FormLinks
	dbutton.DrawTriangleRight = VGUI_NodeMeta.DrawTriangleRight

	-- function dbutton:GetTriggerPos(triggerName)
	-- 	if self.Type then
	-- 		local nodeData = wOS.PES.Nodes:Get(self.Type)
	-- 		-- if check
	-- 		local maxTriggers = #nodeData.Triggers
	-- 		for index, trigger in ipairs(nodeData.Triggers) do
	-- 			if trigger == triggerName then
	-- 				return 50 + 16 *(index - (maxTriggers +1)/2)
	-- 			end
	-- 		end

	-- 		return false
	-- 	end

    -- 	return self:GetTall() * 0.5
	-- end

	-- function dbutton:Paint(w, h)
	-- 	if dbutton.Active then
	-- 		draw.RoundedBox(6, 0, 0, w, h, Color(0, 255, 0, 255))	    
	-- 	else
	-- 		draw.RoundedBox(6, 0, 0, w, h, Color(0, 0, 0, 255))
	-- 	end
	--     draw.RoundedBox(5, 1, 1, w-2, h-2, Color(255, 255, 255, 127))
	-- end

    self.Nodes[id] = dbutton

	return dbutton
end

function PANEL:Init()
    self.CreationType = WOS_PES.CREATOR.EVENT
	self._x = 0
	self.Nodes = {}
	self._y = 0

    self._tx = 0
    self._ty = 0

    self.Links = {}
	
	self._background = vgui.Create("DButton", self)
    self._background:SetSize(1920*4, 1920*4)
    self._background:Center()
    self._background:SetText("")
    self._background.Paint = function(sef, w, h)

		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(bgMaterial)
		surface.DrawTexturedRectUV(0,0,w,h,0,0,w,h)

        for id, pnl in pairs(self.Nodes) do
		    if !IsValid(pnl) then
                return
			end

            for triggerName, panelTable in pairs(pnl.Links) do
                for index, oid in ipairs(panelTable) do
                    local oPnl = self.Nodes[oid]
                    if !IsValid(oPnl) then
                        continue
                    end

					if not oPnl.MakeOtherLink then
						self:MakeOtherLink(triggerName, oPnl)
						oPnl.MakeOtherLink = true
					end

                    local x,y = pnl:GetPos()
                    local w,h = oPnl:GetPos()
                    local posY, id, col = pnl:GetTriggerPos(triggerName)

                    if !posY then
                        self:RemoveLink(pnl, triggerName, oPnl)
                        continue
                    end

                    h = h + oPnl:GetTall()*0.5
                    y = y + posY

                    x = x + pnl:GetWide() + pnl:GetWide()*0.04
                    col = col or color_white

                    surface.SetDrawColor( col )
                    surface.DrawLine( x, y, w, h )
                end
            end
        end
    end

    self._background.OnDepressed = function( s )
        self:StartDragging()
    end

    self._background.OnReleased = function( s )
        self:StopDragging()
    end
end

function PANEL:StopDragging()
    self.Dragging = false
end

function PANEL:StartDragging()
    self.Dragging = true

    if IsValid(self.ViewingNode) then
        self.ViewingNode:NodeClose()
        self.ViewingNode = false
    end

    local x,y = gui.MousePos()

    self.mousepos = {x = x, y = y}
end

function PANEL:OnSizeChanged(nW, nH)
    self._background:Center()
end

function PANEL:GetCenter()
    local aX = self._background:GetWide()/2 - self._x
    local aY = self._background:GetTall()/2 - self._y

    return aX, aY
end

local speed = 100

function PANEL:Think()
    if not self.Dragging then return end
	
	local x,y = gui.MousePos()
	if !self.mousepos then
		self.mousepos = {x = x, y = y}
	end
	local dX = x - self.mousepos.x
	local dY = y - self.mousepos.y

	local oldMouseY = self.mousepos.y
	self.mousepos = {x = x, y = y}

	self._tx = dX + self._x
	self._ty = dY + self._y
	local posChanged = false

	if self.tx != self._x then
		posChanged = true
		self._x = math.Approach(self._x, self._tx, FrameTime() * speed*self:GetWide())
	end

	if self.ty != self._y then
		local x,y = self._background:GetPos()

		posChanged = true
		self._y = math.Approach(self._y, self._ty, FrameTime() * speed*self:GetTall())
	end

	if posChanged then
		local aX = self:GetWide()/2 -self._background:GetWide()/2
		local aY = self:GetTall()/2 -self._background:GetTall()/2
		local x,y = self._background:GetPos()

		self._background:SetPos( aX+self._x,  aY + self._y)
	end

end

function PANEL:MakeOtherLink(name, oNode)
	local link = vgui.Create("DPanel", oNode)
	link:SetSize( oNode:GetWide()*0.08, oNode:GetWide()*0.08 )
	link:SetPos( link:GetWide()*-0.5, oNode:GetTall()*0.5 - link:GetTall()*0.5 )
	link:SetText( "" )
	link.Name = name or "Output"
	link.TriggerColor = Color( 255, 255, 255 )
	
	link.Paint = function(s, w, h)
		local wasEnabled = DisableClipping( true )            
		local col = s.TriggerColor
		if s.Hovered then col = Color(150,150,150) end
		draw.RoundedBox( h*0.3, 0, 0, w, h, col )
		DisableClipping( wasEnabled )
	end
end

function PANEL:FormLinks()

    local function makeLink( name, trigger_label, trigger_description )
        local link = vgui.Create("DPanel", self)

        local t_pos, id, trigcol = self:GetTriggerPos( name )
        id = id or 1
        link.TriggerColor = trigcol or self.TriggerColorHierarchy[id]
        link:SetSize( self:GetWide()*0.08, self:GetWide()*0.08 )
        link:SetPos( self:GetWide() - link:GetWide()*0.5, t_pos - link:GetTall()*0.5 )
        link:SetText( "" )

        link.NLabel = trigger_label or name
        link.NDescription = desc or ""
        link.Name = name or "Output"

        link:SetToolTip(name)
        link.Paint = function(s, w, h)
            local col = s.TriggerColor
            local wasEnabled = DisableClipping( true )
            self:DrawTriangleRight( w*0.5, h*0.5, w, h, col )
            draw.SimpleText( s.NLabel, "DermaDefaultBold", w*-0.2, h/2, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

            DisableClipping( wasEnabled )
        end
    end

	-- for triggerName, panelTable in pairs(pnl.Links) do
	-- 	for index, oid in ipairs(panelTable) do
	-- 		local oPnl = self.Nodes[oid]
	-- 		if !IsValid(oPnl) then
	-- 			continue
	-- 		end

	-- 		local x,y = pnl:GetPos()
	-- 		local w,h = oPnl:GetPos()
	-- 		local posY, id, col = pnl:GetTriggerPos(triggerName)

	-- 		if !posY then
	-- 			self:RemoveLink(pnl, triggerName, oPnl)
	-- 			continue
	-- 		end

	-- 		h = h + oPnl:GetTall()*0.5
	-- 		y = y + posY

	-- 		x = x + pnl:GetWide() + pnl:GetWide()*0.04
	-- 		col = col or color_white

	-- 		surface.SetDrawColor( col )
	-- 		surface.DrawLine( x, y, w, h )
	-- 	end
	-- end

	-- 	if dbutton.Type then
	-- 		local nodeData = wOS.PES.Nodes:Get(dbutton.Type)
	-- 		-- if chec
	-- 		local maxTriggers = #nodeData.Triggers
		
	-- 		for index, tdata in ipairs(nodeData.Triggers) do
				
	-- 			local trigger = tdata
	-- 			local trigger_name = trigger
	-- 			if istable( tdata ) then
	-- 				trigger = tdata.Type or trigger
	-- 				trigger_name = tdata.Name or trigger_name
	-- 			end

	-- 			local but = vgui.Create("DButton", bg)
	-- 			but:SetText( trigger_name )
	-- 			but:Dock(TOP)
	-- 			but.DoClick = function()
	-- 				wOS.PES.RequestTriggerStart(self.EventID, id, trigger)
	-- 				nodeWatchingMenu:Remove()
	-- 			end
	-- 			noTriggers = false
	-- 		end
	-- 	end

    local nodeLinks = self.Links

    if self.Type then
        local nodeData = wOS.PES.Nodes:Get(self.Type)
        if nodeData and nodeData.Triggers then
            for index, tdata in ipairs(nodeData.Triggers) do
                
                local name = tdata
                local trigger_label = name
                local trigger_description = "This will fire when this condition is met"
                if istable( tdata ) then
                    name = tdata.Type or name
                    trigger_label = tdata.Name or trigger_label
                    trigger_description = tdata.Description or trigger_description
                end
                makeLink(name, trigger_label, trigger_description )
            end
            return
        end
    end

    makeLink("Instant")
end

vgui.Register( "WOS_PES_ViewNodeBG", PANEL, "Panel" )
--addons/wos-passiveevent-ageo/lua/wos/pes/vars/dropdown.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Dropdown"
VAR.DirtyValidate = true
VAR.IsValid = function(varTable, value)
    if not isstring(value) then
        return false
    end

    if value == "" then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local frame = vgui.Create("DPanel")
    frame:SetTall( 50 )

    local comboBox = vgui.Create("DComboBox",frame)
    comboBox:SetTall( 20 )
    comboBox:Dock(TOP)
	comboBox:DockMargin(0,0,0,0)

    varTable.Values = varTable.Values or {}
    if isstring( varTable.Values ) and string.Left(varTable.Values, 6) == "FUNC::" then
        local func_name = string.Replace( varTable.Values, "FUNC::", "" )
        local layers = string.Split( func_name, "." )

        local func = _G
        for _, layer in ipairs( layers ) do
            func = func[ layer ] 
        end
        varTable.Values = func()
    end

    for _, choice in pairs(varTable.Values) do
        comboBox:AddChoice(choice)
    end

    if isstring(value) then
        comboBox:SetValue(value)
    else
        if isstring(varTable.Default) then
            comboBox:SetValue(varTable.Default )
        end
    end

    frame.GetValue = function( self )
        return comboBox:GetValue()
    end 

    return frame
end

VAR.GetValue = function(comboBox)
    return comboBox:GetValue()
end


return VAR
--addons/arccw_weapons/lua/weapons/aocrp_chaingun.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "REP"
SWEP.Credits = "Kraken"
SWEP.PrintName = "Z-6 Chaingun"
SWEP.Trivia_Class = "Blaster Heavy Canon"
SWEP.Trivia_Desc = "Available only to the Clone Commander class of the Republic, or the Rail ARC Troopers of Kamino, the Chaingun is a large shoulder-worn weapon, which is particularly effective, and indeed intended for attacking infantry, especially droids."
SWEP.IconOverride = "entities/sopsmisc/z6chain.png"

-- Viewmodel & Entity Properties
SWEP.ViewModel = "models/weapons/c_rpg.mdl"
SWEP.WorldModel = "models/weapons/w_pistol.mdl"
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 20
SWEP.RangeMin = 300
SWEP.DamageMin = 10
SWEP.Range = 400
SWEP.Penetration = 2
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 250

SWEP.Recoil = 0.29
SWEP.RecoilSide = 0.205
SWEP.RecoilRise = 0.98
SWEP.Delay = 60 / 650

SWEP.Bipod_Integral = true 
SWEP.BipodDispersion = 0.8 
SWEP.BipodRecoil = 0.5 


SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 400
SWEP.MoveDispersion = 70

-- Special Properties
SWEP.TriggerDelay = true

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 125
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/z6_chain/fire.wav"
SWEP.ShootSound = "sops-v2/weapons/z6_chain/fire.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-8, -10, 3.5),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "rpg"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-4, -13, 2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5.226, -2, 0)
SWEP.SprintAng = Angle(-18, 36, -13.5)

SWEP.CustomizePos = Vector(8, -4.8, -3)
SWEP.CustomizeAng = Angle(11.199, 38, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.Jamming = false
SWEP.HeatGain = 0.95 
SWEP.HeatCapacity = 100
SWEP.HeatDissipation = 10
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5

-- Attachments
SWEP.DefaultElements = {"chain", "muzzle"}
SWEP.AttachmentElements = {
    ["chain"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/chaingun_base.mdl",
                Bone = "base",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-1, 4, 13.5),
                    ang = Angle(0, -180, 90),
                }
            }
        }
    },
    ["muzzle"] = {
         VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "base",
                Scale = Vector(0, 0, 0),                
                Offset = {
                    pos = Vector(-3, 0, 13),
                    ang = Angle(90, 0, 0)
                },
                IsMuzzleDevice = true
            }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/chaingun_base.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.9, 0.9, 0.9),
                Offset = {
                    pos = Vector(900, 0, -320),
                    ang = Angle(0, 90, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(2000, 0, -650),
                    ang = Angle(0, 0, 180)
                },
                IsMuzzleDevice = true
            },            
        },
    }
}

SWEP.Attachments = {    
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },  
    {
        PrintName = "Tactical", 
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        Bone = "base",
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(111, 111, 111),
        Offset = {
            vpos = Vector(2.2, 1, 19.76),
            vang = Angle(90, 0, 0),
            wpos = Vector(450, 360, -575),
            wang = Angle(0, 0, -90)
        },
    }, 
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "base",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(111, 111, 111),
        Offset = {   
            vpos = Vector(2.7, 1, 8),
            vang = Angle(90, 0, -90),
            wpos = Vector(450, 345, -575),
            wang = Angle(0, 0, 180)
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "base",
        WMScale = Vector(111, 111, 111),
        Offset = {
            vpos = Vector(2.9, 2, 4),
            vang = Angle(90, 0, -90),
            wpos = Vector(0, 395, -450),
            wang = Angle(0, 0, 180)
        },
    },    
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle1"
    },
    ["trigger"] = {
        Source = "fire",
        SoundTable = {
            {s = "sops-v2/weapons/z6x/active.wav", t = 0.01/30},
        },
    },
    ["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100, 
                v = 75,
                t = 0.1, 
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        Time = 3.4, 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "sops-v2/weapons/z6_chain/reload1.wav", t = 0.1/30},
            {s = "sops-v2/weapons/z6_chain/reload2.wav", t = 70/30},
        },
    },
}

SWEP.Hook_ModifyRPM = function(wep, delay)
    return delay / Lerp(wep:GetBurstCount() / 15, 1, 3)
end


--addons/arccw_weapons/lua/weapons/aocrp_dc15a.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Credits = { Author1 = "Meeks"}
SWEP.PrintName = "DC-15A"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "High tech DC-15A Blaster Rifle, preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/dc15a_rifle_meeks.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_dc15a_rifle.mdl"
SWEP.ViewModelFOV = 65
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(10, 0, -4),
    ang = Angle(165, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.IconOverride = "materials/entities/rw_sw_dc15a.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 15
SWEP.RangeMin = 190
SWEP.DamageMin = 12
SWEP.Range = 550
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.29
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.22

SWEP.Delay = 60 / 320
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2
    },
    {
        Mode = 1
    },
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 400 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100


SWEP.DistantShootSound = "dc15a/SW02_Weapons_Blasters_Shared_Corebass_Tight_Close_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "dc15a/SW02_Weapons_Blasters_DC15_Laser_Close_VAR_03 4 1 0.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash

SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-2.82, -12, 1.3),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1.5, -4, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"", ""}

-- SWEP.AttachmentElements = {
--     ["dc15a"] = {
--         VMElements = {
--             {
--                 Model = "models/arccw/sw_battlefront/weapons/new/DC15A_Rifle.mdl", -- using the model-edit i made in like 2 mins lol
--                 Bone = "v_dlt19_reference001",
--                 Scale = Vector(1.2, 1.2, 1.2),
--                 Offset = {
--                     pos = Vector(.7, -0.3, 0.5),
--                     ang = Angle(0,-90, 0)
--                 },
--             }
--         },
--     },
--     ["muzzle"] = {
--          VMElements = {
--             {
--                 Model = "models/hunter/plates/plate.mdl",
--                 Bone = "dlt19_sight",
--                 Scale = Vector(0, 0, 0),                
--                 Offset = {
--                     pos = Vector(-0.5, 4, 27 ),
--                     ang = Angle(-90, 180, 0)
--                 },
--                 IsMuzzleDevice = true
--             }
--         },
--         WMElements = {
--             {
--                 Model = "models/arccw/sw_battlefront/weapons/new/dc15a_rifle.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(1.1, 1.1, 1.1),
--                 Offset = {
--                     pos = Vector(3.75, 2.5, -1.5),
--                     ang = Angle(-15, 0, 180)
--                 }
--             },
--             {
--                 Model = "models/hunter/plates/plate.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(0, 0, 0),
--                 Offset = {
--                     pos = Vector(3500, 0, -1100),
--                     ang = Angle(-15, 0, 180)
--                 },
--                 IsMuzzleDevice = true
--             },
--         }, -- change the world model to something else. Please make sure it's compatible with the last one.
--     }
-- }
-- WMOverride = "models/arccw/sw_battlefront/weapons/new/dc15a_rifle.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        -- WMScale = Vector(111, 111, 111),
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, -0, -0.15),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 0.4, -4.8),
            wang = Angle(-15, 0, 180)
        },
    },
    {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"foregrip"},
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.2, 2.25, 15.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(20, 0.4, -5.9),
            wang = Angle(165, 180, 0),
        },
    },          
    {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol","tac"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0., 2, 22),
            vang = Angle(90, 0, -90),
            wpos = Vector(32, 0.4, -10),
            wang = Angle(-15, 0, -180)
        },
    },
    {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle","dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0, 0.9, 27.1),
            vang = Angle(90, 0, -90),
            wpos = Vector(33, 0.45, -11),
            wang = Angle(-15, 0, 180)
        },
    },    
    {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.75, 1, 7.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(12, 1.2, -5.5),
            wang = Angle(-10 , 0, 180)
        },
    },    
    {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.8, 1, 4),
            vang = Angle(90, 0, -90),
            wpos = Vector(675, 90, -400),
            wang = Angle(-15 , 0, 180)
        },
    },   
    {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },       
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3,
        LHIK = true,
        LHIKOut = 0.6,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "reloads/heavy.wav", t = 4 / 30}, --s sound file
        },
    },

}


-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 23
SWEP.DamageMin = 12
SWEP.RangeMin = 190
SWEP.Range = 550
SWEP.Delay = 60 / 320
SWEP.Primary.ClipSize = 35
SWEP.Category = 'REP'
--addons/arccw_weapons/lua/weapons/aocrp_dc15aarc.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = 'REP'
SWEP.Credits = { Author1 = "Meeks"}
SWEP.PrintName = "DC-15AC"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "High tech DC-15A Blaster Rifle, preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/dc15a_rifle_meeks.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_dc15a_rifle.mdl"
SWEP.ViewModelFOV = 65
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(10, 0, -4),
    ang = Angle(165, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.IconOverride = "materials/entities/rw_sw_dc15a.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 42
SWEP.RangeMin = 180
SWEP.DamageMin = 22
SWEP.Range = 590
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.29
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.22

SWEP.Delay = 60 / 380
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },            
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 400 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100


SWEP.DistantShootSound = "dc15a/SW02_Weapons_Blasters_Shared_Corebass_Tight_Close_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "westar/blasters_f-11aba_heavycannon_laser_close_var_01.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-2.82, -12, 1.3),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1.5, -4, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"", ""}

-- SWEP.AttachmentElements = {
--     ["dc15a"] = {
--         VMElements = {
--             {
--                 Model = "models/arccw/sw_battlefront/weapons/new/DC15A_Rifle.mdl", -- using the model-edit i made in like 2 mins lol
--                 Bone = "v_dlt19_reference001",
--                 Scale = Vector(1.2, 1.2, 1.2),
--                 Offset = {
--                     pos = Vector(.7, -0.3, 0.5),
--                     ang = Angle(0,-90, 0)
--                 },
--             }
--         },
--     },
--     ["muzzle"] = {
--          VMElements = {
--             {
--                 Model = "models/hunter/plates/plate.mdl",
--                 Bone = "dlt19_sight",
--                 Scale = Vector(0, 0, 0),                
--                 Offset = {
--                     pos = Vector(-0.5, 4, 27 ),
--                     ang = Angle(-90, 180, 0)
--                 },
--                 IsMuzzleDevice = true
--             }
--         },
--         WMElements = {
--             {
--                 Model = "models/arccw/sw_battlefront/weapons/new/dc15a_rifle.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(1.1, 1.1, 1.1),
--                 Offset = {
--                     pos = Vector(3.75, 2.5, -1.5),
--                     ang = Angle(-15, 0, 180)
--                 }
--             },
--             {
--                 Model = "models/hunter/plates/plate.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(0, 0, 0),
--                 Offset = {
--                     pos = Vector(3500, 0, -1100),
--                     ang = Angle(-15, 0, 180)
--                 },
--                 IsMuzzleDevice = true
--             },
--         }, -- change the world model to something else. Please make sure it's compatible with the last one.
--     }
-- }
-- WMOverride = "models/arccw/sw_battlefront/weapons/new/dc15a_rifle.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        -- WMScale = Vector(111, 111, 111),
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, -0, -0.15),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 0.4, -4.8),
            wang = Angle(-15, 0, 180)
        },
    },
    {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"foregrip"},
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.2, 2.25, 15.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(20, 0.4, -5.9),
            wang = Angle(165, 180, 0),
        },
    },          
    {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol","tac"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0., 2, 22),
            vang = Angle(90, 0, -90),
            wpos = Vector(32, 0.4, -10),
            wang = Angle(-15, 0, -180)
        },
    },
    {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle","dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0, 0.9, 27.1),
            vang = Angle(90, 0, -90),
            wpos = Vector(33, 0.45, -11),
            wang = Angle(-15, 0, 180)
        },
    },    
    {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.75, 1, 7.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(12, 1.2, -5.5),
            wang = Angle(-10 , 0, 180)
        },
    },    
    {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.8, 1, 4),
            vang = Angle(90, 0, -90),
            wpos = Vector(675, 90, -400),
            wang = Angle(-15 , 0, 180)
        },
    },   
    {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },       
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3,
        LHIK = true,
        LHIKOut = 0.6,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "reloads/heavy.wav", t = 4 / 30}, --s sound file
        },
    },

}

--addons/arccw_weapons/lua/weapons/arccw_b2_blaster.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Droidenwaffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "B2 Blaster"
SWEP.Trivia_Class = "CIS B2 Hand-Blaster"
SWEP.Trivia_Desc = "CIS B2 Combat Hand-Blaster"
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = false

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_b2rp_blaster.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 45
SWEP.RangeMin = 145
SWEP.DamageMin = 17
SWEP.Range = 325
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 35

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 0.8
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 260
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
}

SWEP.AccuracyMOA = 1 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 350 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(255, 0, 0)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/b2_blaster.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-3.8, -8, 1.7),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "pistol"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -6, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -9, 0)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(0, 0, 0)

SWEP.CustomizePos = Vector(0.824, -9, 0.897)
SWEP.CustomizeAng = Angle(0, 0, 0)


SWEP.DefaultElements = {"b2handblaster"}

SWEP.AttachmentElements = {
    ["b2handblaster"] = {
        VMElements = {
            {
                Model = "models/arccw/cs574/weapons/b2_hand.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(0, 0, 0),
                    ang = Angle(0, 180, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/cs574/weapons/b2_hand.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(40, 20, -15.3),
                    ang = Angle(-15, -90, 180)
                }
            },
        },
    }
}

WMOverride = "models/arccw/cs574/weapons/b2_hand.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "b2attachments",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}

-- AOCRP WAFFENSTATS arccw_b2_blaster - 02.06.2024
SWEP.Damage = 38
SWEP.DamageMin = 17
SWEP.RangeMin = 145
SWEP.Range = 325
SWEP.Delay = 60 / 260
SWEP.Primary.ClipSize = 35
SWEP.Category = 'KUS'
--addons/arccw_base_modified/lua/weapons/arccw_base/cl_presets.lua:
-- atts are comma separated
-- optic_mrs,,,perk_quickdraw,ammo_match



local function ScreenScaleMulti(input)
    return ScreenScale(input) * ArcCW.ConVars["hud_size"]:GetFloat()
end

function SWEP:GetPresetBase()
    return self.PresetBase or self:GetClass()
end

function SWEP:GetPresets()
    local path = ArcCW.PresetPath .. self:GetPresetBase() .. "/*.txt"

    local files = file.Find(path, "DATA")

    files = table.Add(files, file.Find(ArcCW.PresetPath .. self:GetPresetBase() .. "/*.json", "DATA"))

    return files
end

function SWEP:LoadPreset(presetname)
    presetname = presetname or "autosave"
    if presetname == "autosave" then
        if self:GetNWBool("ArcCW_DisableAutosave", false) then return end
        if !ArcCW.ConVars["autosave"]:GetBool() then return end
    end

    if presetname != "autosave" then
        surface.PlaySound("weapons/arccw/install.wav")
    end

    -- ???
    self.Attachments.BaseClass = nil

    local presetTbl


    -- New behavior
    local filename = ArcCW.PresetPath .. self:GetPresetBase() .. "/" .. presetname .. ".json"
    if file.Exists(filename, "DATA") then
        presetTbl = util.JSONToTable(file.Read(filename))
        if presetTbl and presetTbl != {} then
            for i = 1, table.Count(self.Attachments) do
                local ok = true

                if !presetTbl[i] or !ArcCW.AttachmentTable[presetTbl[i].Installed or ""] then
                    ok = false
                end

                if !ok then
                    presetTbl[i] = nil
                end
            end
        end
    end

    -- Legacy behavior
    filename = ArcCW.PresetPath .. self:GetPresetBase() .. "/" .. presetname .. ".txt"
    if presetTbl == nil and file.Exists(filename, "DATA") then
        local f = file.Open(filename, "r", "DATA")
        if !f then return end

        presetTbl = {}

        for i = 1, table.Count(self.Attachments) do
            local line = f:ReadLine()
            if !line then continue end
            local split = string.Split(string.Trim(line, "\n"), ",")
            if !ArcCW.AttachmentTable[split[1]] then continue end
            presetTbl[i] = {
                Installed = split[1],
                SlidePos = split[2] and tonumber(split[2]),
                SightMagnifications = split[3] and tonumber(split[3]),
                ToggleNum = nil, -- not implemented in legacy preset
            }
        end
        f:Close()
    end

    if !presetTbl then return end

    net.Start("arccw_applypreset")
    net.WriteEntity(self)
    for k, v in pairs(self.Attachments) do
        local att = (presetTbl[k] or {}).Installed

        if !att or !ArcCW.AttachmentTable[att] then
            net.WriteUInt(0, ArcCW.GetBitNecessity())
            continue
        end

        net.WriteUInt(ArcCW.AttachmentTable[att].ID, ArcCW.GetBitNecessity())

        net.WriteBool(presetTbl[k].SlidePos)
        if presetTbl[k].SlidePos then
            net.WriteFloat(presetTbl[k].SlidePos)
        end

        if ArcCW.AttachmentTable[att].ToggleStats != nil then
            net.WriteUInt(presetTbl[k].ToggleNum or 1, 8)
        end
        v.ToggleNum = presetTbl[k].ToggleNum or 1

        -- not networked
        self.SightMagnifications[k] = presetTbl[k].SightMagnifications
    end
    net.SendToServer()

    --[[]
    for i = 1, table.Count(self.Attachments) do
        local att = presetTbl[i]
        if !att then continue end

        if ArcCW:PlayerGetAtts(self:GetOwner(), att) == 0 then continue end
        if !self.Attachments[i] then continue end

        -- detect commas
        -- no commas = do nothing
        -- commas: If exactly two commas are detected
        -- try to parse them as slidepos, magnification

        local split = string.Split(att, ",")
        local sc = table.Count(split)

        local slidepos = 0.5
        local mag = -1

        if sc == 3 then
            att = split[1]
            slidepos = tonumber(split[2])
            mag = tonumber(split[3])
        end

        if att == self.Attachments[i].Installed then continue end

        self:Detach(i, true, true)

        if !ArcCW.AttachmentTable[att] then continue end

        self:Attach(i, att, true, true)

        if slidepos != 0.5 then
            self.Attachments[i].SlidePos = slidepos
        end

        if mag != -1 then
            self.SightMagnifications[i] = mag
        end
    end

    self:SendAllDetails()

    self:SavePreset()
    ]]
end

function SWEP:SavePreset(presetname)
    presetname = presetname or "autosave"
    if presetname == "autosave" and !ArcCW.ConVars["attinv_free"]:GetBool() then return end

    local presetTbl = {}
    for i, k in pairs(self.Attachments) do
        if k.Installed then
            presetTbl[i] = {
                Installed = k.Installed,
                SlidePos = k.SlidePos,
                SightMagnifications = self.SightMagnifications[i],
                ToggleNum = k.ToggleNum
            }
        end
    end

    filename = ArcCW.PresetPath .. self:GetPresetBase() .. "/" .. presetname .. ".json"
    file.CreateDir(ArcCW.PresetPath .. self:GetPresetBase())
    file.Write(filename, util.TableToJSON(presetTbl))

    local legacy_filename = ArcCW.PresetPath .. self:GetPresetBase() .. "/" .. presetname .. ".txt"
    if file.Exists(legacy_filename, "DATA") then
        file.Delete(legacy_filename)
    end

    -- Legacy presets
    --[[]
    local str = ""
    for i, k in pairs(self.Attachments) do
        if k.Installed then
            str = str .. k.Installed
            if k.SlidePos or self.SightMagnifications[i] then
                str = str .. "," .. tostring(k.SlidePos or 0.5) .. "," .. tostring(self.SightMagnifications[i] or -1)
            end
        end

        str = str .. "\n"
    end

    filename = ArcCW.PresetPath .. self:GetPresetBase() .. "/" .. filename .. ".txt"

    file.CreateDir(ArcCW.PresetPath .. self:GetPresetBase())
    file.Write(filename, str)
    ]]
end

function SWEP:CreatePresetSave()
    if !IsValid(ArcCW.InvHUD) then return end
    local bg = vgui.Create("DFrame", ArcCW.InvHUD)
    bg:SetPos(0, 0)
    bg:SetSize(ScrW(), ScrH())
    bg:SetText("")
    bg:SetTitle("")
    bg:SetDraggable(false)
    bg:ShowCloseButton(false)
    bg.Paint = function(span)
        surface.SetDrawColor(0, 0, 0, 200)
        surface.DrawRect(0, 0, ScrW(), ScrH())
    end
    bg:MakePopup()

    local text = vgui.Create("DTextEntry", bg)
    text:SetSize(ScreenScaleMulti(256), ScreenScaleMulti(26))
    text:Center()
    text:RequestFocus()
    text:SetFont("ArcCW_24")
    text:SetText(self.LastPresetName or "")

    local accept = vgui.Create("DButton", bg)
    accept:SetSize((ScreenScaleMulti(256) - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
    accept:SetText("")
    accept:SetPos((ScrW() - ScreenScaleMulti(256)) / 2, ((ScrH() - ScreenScaleMulti(14)) / 2) + ScreenScaleMulti(26) + ScreenScaleMulti(2))

    accept.OnMousePressed = function(spaa, kc)
        local txt = text:GetText()
        txt = string.sub(txt, 0, 36)
        self.LastPresetName = txt
        self:SavePreset(txt)
        bg:Close()
        bg:Remove()

        ArcCW.InvHUD_FormPresets()
    end

    accept.Paint = function(spaa, w, h)
        if !self:IsValid() then return end
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 100)

        if spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = "Save"

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(ScreenScaleMulti(2), ScreenScaleMulti(1))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    local cancel = vgui.Create("DButton", bg)
    cancel:SetSize((ScreenScaleMulti(256) - ScreenScaleMulti(2)) / 2, ScreenScaleMulti(14))
    cancel:SetText("")
    cancel:SetPos(((ScrW() - ScreenScaleMulti(256)) / 2) + ScreenScaleMulti(128 + 1), ((ScrH() - ScreenScaleMulti(14)) / 2) + ScreenScaleMulti(26) + ScreenScaleMulti(2))

    cancel.OnMousePressed = function(spaa, kc)
        bg:Close()
        bg:Remove()
    end

    cancel.Paint = function(spaa, w, h)
        if !self:IsValid() then return end
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 100)

        if spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = "Cancel"

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(ScreenScaleMulti(2), ScreenScaleMulti(1))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end
end

function SWEP:CreatePresetMenu()
    if !IsValid(ArcCW.InvHUD) then return end

    if !IsValid(ArcCW.InvHUD) then return end
    local bg = vgui.Create("DFrame", ArcCW.InvHUD)
    bg:SetPos(0, 0)
    bg:SetSize(ScrW(), ScrH())
    bg:SetText("")
    bg:SetTitle("")
    bg:SetDraggable(false)
    bg:ShowCloseButton(false)
    bg.Paint = function(span)
        surface.SetDrawColor(0, 0, 0, 200)
        surface.DrawRect(0, 0, ScrW(), ScrH())
    end

    local cancel = vgui.Create("DButton", bg)
    cancel:SetSize(ScreenScaleMulti(128), ScreenScaleMulti(14))
    cancel:SetText("")
    cancel:SetPos((ScrW() - ScreenScaleMulti(128)) / 2, ScrH() - ScreenScaleMulti(32))

    cancel.OnMousePressed = function(spaa, kc)
        bg:Close()
        bg:Remove()
    end

    cancel.Paint = function(spaa, w, h)
        if !self:IsValid() then return end
        local Bfg_col = Color(255, 255, 255, 255)
        local Bbg_col = Color(0, 0, 0, 100)

        if spaa:IsHovered() then
            Bbg_col = Color(255, 255, 255, 100)
            Bfg_col = Color(0, 0, 0, 255)
        end

        surface.SetDrawColor(Bbg_col)
        surface.DrawRect(0, 0, w, h)

        local txt = "Cancel"

        surface.SetTextColor(Bfg_col)
        surface.SetTextPos(ScreenScaleMulti(2), ScreenScaleMulti(1))
        surface.SetFont("ArcCW_12")
        surface.DrawText(txt)
    end

    local presetsmenu = vgui.Create("DScrollPanel", bg)
    presetsmenu:SetText("")
    presetsmenu:SetSize(ScreenScaleMulti(256), ScrH() - ScreenScaleMulti(64))
    presetsmenu:SetPos((ScrW() - ScreenScaleMulti(256)) / 2, ScreenScaleMulti(8))
    presetsmenu.Paint = function(span, w, h)
    end

    local sbar = presetsmenu:GetVBar()
    sbar.Paint = function() end

    sbar.btnUp.Paint = function(span, w, h)
    end

    sbar.btnDown.Paint = function(span, w, h)
    end

    sbar.btnGrip.Paint = function(span, w, h)
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawRect(0, 0, w, h)
    end

    local c = 0

    for i, k in pairs(self:GetPresets()) do
        if string.StripExtension(k) == "autosave" then continue end
        local preset = vgui.Create("DButton", presetsmenu)
        preset:SetSize(ScreenScaleMulti(254), ScreenScaleMulti(14))
        preset:SetText("")
        preset:Dock(TOP)
        preset:DockMargin( 0, 0, 0, ScreenScaleMulti(2) )

        preset.PresetName = string.StripExtension(k) --string.sub(k, 1, -5)
        preset.PresetFile = k

        preset.OnMousePressed = function(spaa, kc)
            self.LastPresetName = spaa.PresetName
            self:LoadPreset(spaa.PresetName)
            bg:Close()
            bg:Remove()
        end

        preset.Paint = function(spaa, w, h)
            if !self:IsValid() then return end
            local Bfg_col = Color(255, 255, 255, 255)
            local Bbg_col = Color(0, 0, 0, 100)

            if spaa:IsHovered() then
                Bbg_col = Color(255, 255, 255, 100)
                Bfg_col = Color(0, 0, 0, 255)
            end

            surface.SetDrawColor(Bbg_col)
            surface.DrawRect(0, 0, w, h)

            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(ScreenScaleMulti(2), ScreenScaleMulti(1))
            surface.SetFont("ArcCW_12")
            surface.DrawText(string.upper(spaa.PresetName))
        end

        local close = vgui.Create("DButton", preset)
        close:SetSize(ScreenScaleMulti(16), ScreenScaleMulti(16))
        close:SetText("")
        close:Dock(RIGHT)

        close.OnMousePressed = function(spaa, kc)
            local filename = spaa.PresetFile
            file.Delete(filename)
            preset:Remove()
        end

        close.Paint = function(spaa, w, h)
            if !self:IsValid() or preset:IsHovered() then return end
            local Bfg_col = Color(255, 255, 255, 255)
            local Bbg_col = Color(0, 0, 0, 100)

            if spaa:IsHovered() then
                Bbg_col = Color(255, 255, 255, 100)
                Bfg_col = Color(0, 0, 0, 255)
            end

            surface.SetDrawColor(Bbg_col)
            surface.DrawRect(0, 0, w, h)

            local w_x, h_x = surface.GetTextSize("×")
            surface.SetTextColor(Bfg_col)
            surface.SetTextPos((ScreenScaleMulti(16) - w_x) / 2, (ScreenScaleMulti(16) - h_x) / 2)
            surface.SetFont("ArcCW_12")
            surface.DrawText("×")
        end
        c = c + 1
    end

    if c == 0 then
        local label = vgui.Create("DLabel", presetsmenu)
        label:SetSize(ScreenScaleMulti(254), ScreenScaleMulti(14))
        label:SetText("")
        label:Dock(TOP)
        label:DockMargin( 0, 0, 0, ScreenScaleMulti(2) )

        label.Paint = function(spaa, w, h)
            local Bfg_col = Color(255, 255, 255, 255)

            local txt = "No presets found! Go make some!"

            surface.SetTextColor(Bfg_col)
            surface.SetTextPos(ScreenScaleMulti(2), ScreenScaleMulti(1))
            surface.SetFont("ArcCW_12")
            surface.DrawText(txt)
        end
    end
end

function SWEP:ClosePresetMenu()
end
--addons/arccw_base_modified/lua/weapons/arccw_base/cl_viewmodel.lua:
--[[
    Please, for the love of god, don't create objects in functions that are called multiple times per frame.
    The garbage collector will explode and so will players' comptuters.

    That means minimize usage of things that generate new objects, including:
        calls to Vector() or Angle(); use vector_origin and angle_zero if the value isn't modified
        arithmetic using +, -, * and / on Vectors and Angles; modifying individual parameters is fine
        functions like Angle:Right() and Vector:Angle(); however functions like Vector:Add() and Angle:Add() are fine

    Cache them if you use them more than one time!
]]

local mth = math
local m_appor = mth.Approach
local m_clamp = mth.Clamp
local f_lerp = Lerp
local srf = surface
SWEP.ActualVMData = false
local swayxmult, swayymult, swayzmult, swayspeed = 1, 1, 1, 1
local lookxmult, lookymult = 1, 1
SWEP.VMPos = Vector()
SWEP.VMAng = Angle()
SWEP.VMPosOffset = Vector()
SWEP.VMAngOffset = Angle()
SWEP.VMPosOffset_Lerp = Vector()
SWEP.VMAngOffset_Lerp = Angle()
SWEP.VMLookLerp = Angle()
SWEP.StepBob = 0
SWEP.StepBobLerp = 0
SWEP.StepRandomX = 1
SWEP.StepRandomY = 1
SWEP.LastEyeAng = Angle()
SWEP.SmoothEyeAng = Angle()
SWEP.LastVelocity = Vector()
SWEP.Velocity_Lerp = Vector()
SWEP.VelocityLastDiff = 0
SWEP.Breath_Intensity = 1
SWEP.Breath_Rate = 1

-- magic variables
local sprint_vec1 = Vector(-2, 5, 2)
local sprint_vec2 = Vector(0, 7, 3)
local sprint_ang1 = Angle(-15, -15, 0)
local spring_ang2 = Angle(-15, 15, -22)
local sight_vec1 = Vector(0, 15, -4)
local sight_vec2 = Vector(1, 5, -1)
local sight_ang1 = Angle(0, 0, -45)
local sight_ang2 = Angle(-5, 0, -10)
local sextra_vec = Vector(0.0002, 0.001, 0.005)

local procdraw_vec = Vector(0, 0, -5)
local procdraw_ang = Angle(-70, 30, 0)
local prochol_ang = Angle(-70, 30, 10)

local lst = SysTime()
local function scrunkly()
    local ret = (SysTime() - (lst or SysTime())) * GetConVar("host_timescale"):GetFloat()
    return ret
end

local function LerpC(t, a, b, powa)
    return a + (b - a) * math.pow(t, powa)
end

local function ApproachMod(usrobj, to, dlt)
    usrobj[1] = m_appor(usrobj[1], to[1], dlt)
    usrobj[2] = m_appor(usrobj[2], to[2], dlt)
    usrobj[3] = m_appor(usrobj[3], to[3], dlt)
end

local function LerpMod(usrobj, to, dlt, clamp_ang)
    usrobj[1] = f_lerp(dlt, usrobj[1], to[1])
    usrobj[2] = f_lerp(dlt, usrobj[2], to[2])
    usrobj[3] = f_lerp(dlt, usrobj[3], to[3])
    if clamp_ang then
        for i = 1, 3 do usrobj[i] = math.NormalizeAngle(usrobj[i]) end
    end
end

local function LerpMod2(from, usrobj, dlt, clamp_ang)
    usrobj[1] = f_lerp(dlt, from[1], usrobj[1])
    usrobj[2] = f_lerp(dlt, from[2], usrobj[2])
    usrobj[3] = f_lerp(dlt, from[3], usrobj[3])
    if clamp_ang then
        for i = 1, 3 do usrobj[i] = math.NormalizeAngle(usrobj[i]) end
    end
end

-- debug for testing garbage count
-- TODO: comment this out or something before actually going into main branch
local sw = false
local tries = {}
local totaltries = 1000
local sw_start = 0
local sw_orig = 0
concommand.Add("arccw_dev_stopwatch", function() tries = {} sw = true end)

local function stopwatch(name)
    if !sw then return end
    if name == true then
        local d = (collectgarbage("count") - sw_orig)
        if #tries == 0 then print("    total garbage: " .. d) end
        table.insert(tries, d)
        if #tries == totaltries then
            sw = false
            local average = 0
            for _, v in ipairs(tries) do average = average + v end
            average = average / totaltries
            print("----------------------------------")
            print("average over " .. totaltries .. " tries: " .. average)
        end
        return
    end
    local gb = collectgarbage("count")
    if name then
        if #tries == 0 then print(name .. ": " .. (gb - sw_start)) end
    else
        if #tries == 0 then print("----------------------------------") end
        sw_orig = gb
    end
    sw_start = gb
end

function SWEP:Move_Process(EyePos, EyeAng, velocity)
    local VMPos, VMAng = self.VMPos, self.VMAng
    local VMPosOffset, VMAngOffset = self.VMPosOffset, self.VMAngOffset
    local VMPosOffset_Lerp, VMAngOffset_Lerp = self.VMPosOffset_Lerp, self.VMAngOffset_Lerp
    local FT = scrunkly()
    local sightedmult = (self:GetState() == ArcCW.STATE_SIGHTS and 0.05) or 1
    local sg = self:GetSightDelta()
    VMPos:Set(EyePos)
    VMAng:Set(EyeAng)
    VMPosOffset.x = math.Clamp(velocity.z * 0.0025, -1, 1) * sightedmult
    VMPosOffset.x = VMPosOffset.x + (velocity.x * 0.001 * sg)
    VMPosOffset.y = math.Clamp(velocity.y * -0.002, -1, 1) * sightedmult
    VMPosOffset.z = math.Clamp(VMPosOffset.x * -2, -4, 4)
    VMPosOffset_Lerp.x = Lerp(8 * FT, VMPosOffset_Lerp.x, VMPosOffset.x)
    VMPosOffset_Lerp.y = Lerp(8 * FT, VMPosOffset_Lerp.y, VMPosOffset.y)
    VMPosOffset_Lerp.z = Lerp(8 * FT, VMPosOffset_Lerp.z, VMPosOffset.z)
    --VMAngOffset.x = math.Clamp(VMPosOffset.x * 8, -4, 4)
    VMAngOffset.y = VMPosOffset.y
    VMAngOffset.z = VMPosOffset.y * 0.5 + (VMPosOffset.x * -5) + (velocity.x * -0.005 * sg)
    VMAngOffset_Lerp.x = LerpC(10 * FT, VMAngOffset_Lerp.x, VMAngOffset.x, 0.75)
    VMAngOffset_Lerp.y = LerpC(5 * FT, VMAngOffset_Lerp.y, VMAngOffset.y, 0.6)
    VMAngOffset_Lerp.z = Lerp(25 * FT, VMAngOffset_Lerp.z, VMAngOffset.z)
    VMPos:Add(VMAng:Up() * VMPosOffset_Lerp.x)
    VMPos:Add(VMAng:Right() * VMPosOffset_Lerp.y)
    VMPos:Add(VMAng:Forward() * VMPosOffset_Lerp.z)
    VMAngOffset_Lerp:Normalize()
    VMAng:Add(VMAngOffset_Lerp)
end

local stepend = math.pi * 4

function SWEP:Step_Process(EyePos, EyeAng, velocity)

    local VMPos, VMAng = self.VMPos, self.VMAng
    local VMPosOffset, VMAngOffset = self.VMPosOffset, self.VMAngOffset
    local VMPosOffset_Lerp = self.VMPosOffset_Lerp
    local state = self:GetState()
    local sprd = self:GetSprintDelta()

    if state == ArcCW.STATE_SPRINT and self:SelectAnimation("idle_sprint") and !self:GetReloading() and !self:CanShootWhileSprint() then
        velocity = 0
    else
        velocity = math.min(velocity:Length(), 400) * Lerp(sprd, 1, 1.25)
    end

    local delta = math.abs(self.StepBob * 2 / stepend - 1)
    local FT = scrunkly() --FrameTime()
    local sightedmult = (state == ArcCW.STATE_SIGHTS and 0.25) or 1
    local sprintmult = (state == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint() and 2) or 1
    local pronemult = (self:IsProne() and 10) or 1
    local onground = self:GetOwner():OnGround()
    self.StepBob = self.StepBob + (velocity * 0.00015 + (math.pow(delta, 0.01) * 0.03)) * swayspeed * FT * 300

    if self.StepBob >= stepend then
        self.StepBob = 0
        self.StepRandomX = math.Rand(1, 1.5)
        self.StepRandomY = math.Rand(1, 1.5)
    end

    if velocity == 0 then
        self.StepBob = 0
    end

    if onground then
        -- oh no it says sex tra
        local sextra = vector_origin
        if (state == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint() and !self:SelectAnimation("idle_sprint")) or true then
            sextra = LerpVector(sprd, vector_origin, sextra_vec)
        end

        VMPosOffset.x = (math.sin(self.StepBob) * velocity * (0.000375 + sextra.x) * sightedmult * swayxmult) * self.StepRandomX
        VMPosOffset.y = (math.sin(self.StepBob * 0.5) * velocity * (0.0005 + sextra.y) * sightedmult * sprintmult * pronemult * swayymult) * self.StepRandomY
        VMPosOffset.z = math.sin(self.StepBob * 0.75) * velocity * (0.002 + sextra.z) * sightedmult * pronemult * swayzmult
    end

    VMPosOffset_Lerp.x = Lerp(32 * FT, VMPosOffset_Lerp.x, VMPosOffset.x)
    VMPosOffset_Lerp.y = Lerp(4 * FT, VMPosOffset_Lerp.y, VMPosOffset.y)
    VMPosOffset_Lerp.z = Lerp(2 * FT, VMPosOffset_Lerp.z, VMPosOffset.z)
    VMAngOffset.x = VMPosOffset_Lerp.x * 2
    VMAngOffset.y = VMPosOffset_Lerp.y * -7.5
    VMAngOffset.z = VMPosOffset_Lerp.y * 10
    VMPos:Add(VMAng:Up() * VMPosOffset_Lerp.x)
    VMPos:Add(VMAng:Right() * VMPosOffset_Lerp.y)
    VMPos:Add(VMAng:Forward() * VMPosOffset_Lerp.z)
    VMAng:Add(VMAngOffset)
end

function SWEP:Breath_Health()
    local owner = self:GetOwner()
    if !IsValid(owner) then return end
    local health = owner:Health()
    local maxhealth = owner:GetMaxHealth()
    self.Breath_Intensity = math.Clamp(maxhealth / health, 0, 2)
    self.Breath_Rate = math.Clamp((maxhealth * 0.5) / health, 1, 1.5)
end

function SWEP:Breath_StateMult()
    local owner = self:GetOwner()
    if !IsValid(owner) then return end
    local sightedmult = (self:GetState() == ArcCW.STATE_SIGHTS and 0.05) or 1
    self.Breath_Intensity = self.Breath_Intensity * sightedmult
end

function SWEP:Breath_Process(EyePos, EyeAng)
    local VMPos, VMAng = self.VMPos, self.VMAng
    local VMPosOffset, VMAngOffset = self.VMPosOffset, self.VMAngOffset
    -- self:Breath_Health() Snaps around when regenerating
    self:Breath_StateMult()
    VMPosOffset.x = (math.sin(CurTime() * 2 * self.Breath_Rate) * 0.1) * self.Breath_Intensity
    VMPosOffset.y = (math.sin(CurTime() * 2.5 * self.Breath_Rate) * 0.025) * self.Breath_Intensity
    VMAngOffset.x = VMPosOffset.x * 1.5
    VMAngOffset.y = VMPosOffset.y * 2
    VMAngOffset.z = VMPosOffset.y * VMPosOffset.x * -40
    VMPos:Add(VMAng:Up() * VMPosOffset.x)
    VMPos:Add(VMAng:Right() * VMPosOffset.y)
    VMAng:Add(VMAngOffset)
end

function SWEP:Look_Process(EyePos, EyeAng, velocity)
    local VMPos, VMAng = self.VMPos, self.VMAng
    local VMPosOffset, VMAngOffset = self.VMPosOffset, self.VMAngOffset
    local FT = scrunkly()
    local sightedmult = (self:GetState() == ArcCW.STATE_SIGHTS and 0.25) or 1
    self.SmoothEyeAng = LerpAngle(0.05, self.SmoothEyeAng, EyeAng - self.LastEyeAng)
    -- local xd, yd = (velocity.z / 10), (velocity.y / 200)
    VMPosOffset.x = -self.SmoothEyeAng.x * -0.5 * sightedmult * lookxmult
    VMPosOffset.y = self.SmoothEyeAng.y * 0.5 * sightedmult * lookymult
    VMAngOffset.x = VMPosOffset.x * 0.75
    VMAngOffset.y = VMPosOffset.y * 2.5
    VMAngOffset.z = VMPosOffset.x * 2 + VMPosOffset.y * -2
    self.VMLookLerp.y = Lerp(FT * 10, self.VMLookLerp.y, VMAngOffset.y * -1.5 + self.SmoothEyeAng.y)
    VMAng.y = VMAng.y - self.VMLookLerp.y
    VMPos:Add(VMAng:Up() * VMPosOffset.x)
    VMPos:Add(VMAng:Right() * VMPosOffset.y)
    VMAng:Add(VMAngOffset)
end

function SWEP:GetVMPosition(EyePos, EyeAng)
    local velocity = self:GetOwner():GetVelocity()
    velocity = WorldToLocal(velocity, angle_zero, vector_origin, EyeAng)
    self:Move_Process(EyePos, EyeAng, velocity)
    stopwatch("Move_Process")
    self:Step_Process(EyePos, EyeAng, velocity)
    stopwatch("Step_Process")
    self:Breath_Process(EyePos, EyeAng)
    stopwatch("Breath_Process")
    self:Look_Process(EyePos, EyeAng, velocity)
    stopwatch("Look_Process")
    self.LastEyeAng = EyeAng
    self.LastEyePos = EyePos
    self.LastVelocity = velocity

    return self.VMPos, self.VMAng
end

SWEP.TheJ = {posa = Vector(), anga = Angle()}
local rap_pos = Vector()
local rap_ang = Angle()

local actual
local target = {pos = Vector(), ang = Angle()}

local GunDriverFix = Angle( 0, 90, 90 )

function SWEP:GetViewModelPosition(pos, ang)
    if ArcCW.ConVars["dev_benchgun"]:GetBool() then
        if ArcCW.ConVars["dev_benchgun_custom"]:GetString() then
            local bgc = ArcCW.ConVars["dev_benchgun_custom"]:GetString()
            if string.Left(bgc, 6) != "setpos" then return vector_origin, angle_zero end

            bgc = string.TrimLeft(bgc, "setpos ")
            bgc = string.Replace(bgc, ";setang", "")
            bgc = string.Explode(" ", bgc)

            return Vector(bgc[1], bgc[2], bgc[3]), Angle(bgc[4], bgc[5], bgc[6])
        else
            return vector_origin, angle_zero
        end
    end

    stopwatch()

    local owner = self:GetOwner()
    if !IsValid(owner) or !owner:Alive() then return end
    local FT = scrunkly()
    local CT = CurTime()
    local TargetTick = (1 / FT) / 66.66
    local cdelta = math.Clamp(math.ease.InOutSine((owner:GetViewOffset().z - owner:GetCurrentViewOffset().z) / (owner:GetViewOffset().z - owner:GetViewOffsetDucked().z)),0,1)

    if TargetTick < 1 then
        FT = FT * TargetTick
    end

    local vm = LocalPlayer():GetViewModel()

    local asight = self:GetActiveSights()
    local state = self:GetState()
    local sgtd = self:GetSightDelta()
    local sprd = self:GetSprintDelta()

    local sprinted = self.Sprinted or state == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint()
    local sighted = self.Sighted or state == ArcCW.STATE_SIGHTS
    local holstered = self:GetCurrentFiremode().Mode == 0

    if game.SinglePlayer() then
        sprinted = state == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint()
        sighted = state == ArcCW.STATE_SIGHTS
    end

    local oldpos, oldang = Vector(), Angle()
    oldpos:Set(pos)
    oldang:Set(ang)
    ang:Sub(self:GetOurViewPunchAngles())

    actual = self.ActualVMData or {
        pos = Vector(),
        ang = Angle(),
        down = 1,
        sway = 1,
        bob = 1,
        evpos = Vector(),
        evang = Angle(),
    }

    local apos, aang = self:GetBuff_Override("Override_ActivePos", self.ActivePos), self:GetBuff_Override("Override_ActiveAng", self.ActiveAng)
    local cpos, cang = self:GetBuff("CrouchPos", true) or apos, self:GetBuff("CrouchAng", true) or aang
    target.down = 1
    target.sway = 2
    target.bob = 2

    stopwatch("set")

    if self:InBipod() and self:GetBipodAngle() then
        local bpos = self:GetBuff_Override("Override_InBipodPos", self.InBipodPos)
        target.pos:Set(asight and asight.Pos or apos)
        target.ang:Set(asight and asight.Ang or aang)

        local BEA = (self.BipodStartAngle or self:GetBipodAngle()) - owner:EyeAngles()
        target.pos:Add(BEA:Right() * bpos.x * self.InBipodMult.x)
        target.pos:Add(BEA:Forward() * bpos.y * self.InBipodMult.y)
        target.pos:Add(BEA:Up() * bpos.z * self.InBipodMult.z)
        target.sway = 0.2
    -- elseif (owner:Crouching() or owner:KeyDown(IN_DUCK)) and !self:GetReloading() then
        -- target.pos:Set(self:GetBuff("CrouchPos", true) or apos)
        -- target.ang:Set(self:GetBuff("CrouchAng", true) or aang)
    elseif self:GetReloading() then
        target.pos:Set(self:GetBuff("ReloadPos", true) or apos)
        target.ang:Set(self:GetBuff("ReloadAng", true) or aang)
    else
        target.pos:Set(apos)
        target.ang:Set(aang)
        LerpMod(target.pos, cpos, cdelta)
        LerpMod(target.ang, cang, cdelta, true)
    end
    if (owner:Crouching() or owner:KeyDown(IN_DUCK)) then target.down = 0 end

    stopwatch("reload, crouch, bipod")

    target.pos.x = target.pos.x + ArcCW.ConVars["vm_right"]:GetFloat()
    target.pos.y = target.pos.y + ArcCW.ConVars["vm_forward"]:GetFloat()
    target.pos.z = target.pos.z + ArcCW.ConVars["vm_up"]:GetFloat()

    target.ang.p = target.ang.p + ArcCW.ConVars["vm_pitch"]:GetFloat()
    target.ang.y = target.ang.y + ArcCW.ConVars["vm_yaw"]:GetFloat()
    target.ang.r = target.ang.r + ArcCW.ConVars["vm_roll"]:GetFloat()

    if state == ArcCW.STATE_CUSTOMIZE then
        target.down = 1
        target.sway = 3
        target.bob = 1
        local mx, my = input.GetCursorPos()
        mx = 2 * mx / ScrW()
        my = 2 * my / ScrH()
        target.pos:Set(self:GetBuff_Override("Override_CustomizePos", self.CustomizePos))
        target.ang:Set(self:GetBuff_Override("Override_CustomizeAng", self.CustomizeAng))
        target.pos.x = target.pos.x + mx
        target.pos.z = target.pos.z + my
        target.ang.y = target.ang.y + my * 2
        target.ang.r = target.ang.r + mx * 2
        if self.InAttMenu then
            target.ang.y = target.ang.y - 5
        end
    end

    stopwatch("cust")

    -- Sprinting
    local hpos, spos = self:GetBuff("HolsterPos", true), self:GetBuff("SprintPos", true)
    local hang, sang = self:GetBuff("HolsterAng", true), self:GetBuff("SprintAng", true)
    do
        local aaaapos = holstered and (hpos or spos) or (spos or hpos)
        local aaaaang = holstered and (hang or sang) or (sang or hang)

        local sd = (self:GetReloading() and 0) or (self:IsProne() and math.Clamp(owner:GetVelocity():Length() / prone.Config.MoveSpeed, 0, 1)) or (holstered and 1) or (!self:CanShootWhileSprint() and sprd) or 0
        sd = math.pow(math.sin(sd * math.pi * 0.5), 2)

        local d = math.pow(math.sin(sd * math.pi * 0.5), math.pi)
        local coolilove = d * math.cos(d * math.pi * 0.5)

        local joffset, jaffset
        if !sprinted then
            joffset = sprint_vec2
            jaffset = spring_ang2
        else
            joffset = sprint_vec1
            jaffset = sprint_ang1
        end

        LerpMod(target.pos, aaaapos, sd)
        LerpMod(target.ang, aaaaang, sd, true)
        for i = 1, 3 do
            target.pos[i] = target.pos[i] + joffset[i] * coolilove
            target.ang[i] = target.ang[i] + jaffset[i] * coolilove
        end

        local fu_sprint = (sprinted and self:SelectAnimation("idle_sprint"))

        target.sway = target.sway * f_lerp(sd, 1, fu_sprint and 0 or 2)
        target.bob = target.bob * f_lerp(sd, 1, fu_sprint and 0 or 2)
    end

    stopwatch("sprint")

    -- Sighting
    if asight then
        local delta = sgtd
        delta = math.pow(math.sin(delta * math.pi * 0.5), math.pi)
        local im = asight.Midpoint
        local coolilove = delta * math.cos(delta * math.pi * 0.5)

        local joffset, jaffset
        if !sighted then
            joffset = sight_vec2
            jaffset = sight_ang2
        else
            joffset = (im and im.Pos or sight_vec1)
            jaffset = (im and im.Ang or sight_ang1)
        end

        target.pos.z = target.pos.z - 1
        LerpMod2(asight.Pos, target.pos, delta)
        LerpMod2(asight.Ang, target.ang, delta)
        for i = 1, 3 do
            target.pos[i] = target.pos[i] + joffset[i] * coolilove
            target.ang[i] = target.ang[i] + jaffset[i] * coolilove
        end

        target.evpos = f_lerp(delta, asight.EVPos or vector_origin, vector_origin)
        target.evang = f_lerp(delta, asight.EVAng or angle_zero, angle_zero)

        target.down = 0
        target.sway = target.sway * f_lerp(delta, 0.1, 1)
        target.bob = target.bob * f_lerp(delta, 0.1, 1)
    end

    stopwatch("sight")

    local deg = self:GetBarrelNearWall()
    if deg > 0 and ArcCW.ConVars["vm_nearwall"]:GetBool() then
        LerpMod(target.pos, hpos, deg)
        LerpMod(target.ang, hang, deg)
        target.down = 2 * math.max(sgtd, 0.5)
    end

    if !isangle(target.ang) then
        target.ang = Angle(target.ang)
    end

    target.ang.y = target.ang.y + (self:GetFreeAimOffset().y * 0.5)
    target.ang.p = target.ang.p - (self:GetFreeAimOffset().p * 0.5)

    if self.InProcDraw then
        self.InProcHolster = false
        local delta = m_clamp((CT - self.ProcDrawTime) / (0.5 * self:GetBuff_Mult("Mult_DrawTime")), 0, 1)
        target.pos = LerpVector(delta, procdraw_vec, target.pos)
        target.ang = LerpAngle(delta, procdraw_ang, target.ang)
        target.down = target.down
        target.sway = target.sway
        target.bob = target.bob
    end

    if self.InProcHolster then
        self.InProcDraw = false
        local delta = 1 - m_clamp((CT - self.ProcHolsterTime) / (0.25 * self:GetBuff_Mult("Mult_DrawTime")), 0, 1)
        target.pos = LerpVector(delta, procdraw_vec, target.pos)
        target.ang = LerpAngle(delta, prochol_ang, target.ang)
        target.down = target.down
        target.sway = target.sway
        target.bob = target.bob
    end

    if self.InProcBash then
        self.InProcDraw = false
        local mult = self:GetBuff_Mult("Mult_MeleeTime")
        local mtime = self.MeleeTime * mult
        local delta = 1 - m_clamp((CT - self.ProcBashTime) / mtime, 0, 1)

        local bp, ba

        if delta > 0.3 then
            bp = self:GetBuff_Override("Override_BashPreparePos", self.BashPreparePos)
            ba = self:GetBuff_Override("Override_BashPrepareAng", self.BashPrepareAng)
            delta = (delta - 0.5) * 2
        else
            bp = self:GetBuff_Override("Override_BashPos", self.BashPos)
            ba = self:GetBuff_Override("Override_BashAng", self.BashAng)
            delta = delta * 2
        end

        LerpMod2(bp, target.pos, delta)
        LerpMod2(ba, target.ang, delta)

        target.speed = 10

        if delta == 0 then
            self.InProcBash = false
        end
    end

    stopwatch("proc")

    -- local gunbone, gbslot = self:GetBuff_Override("LHIK_GunDriver")
    -- if gunbone and IsValid(self.Attachments[gbslot].VElement.Model) and self.LHIKGunPos and self.LHIKGunAng then
    --     local magnitude = 1 --Lerp(sgtd, 0.1, 1)
    --     local lhik_model = self.Attachments[gbslot].VElement.Model
    --     local att = lhik_model:GetAttachment(lhik_model:LookupAttachment(gunbone))
    --     local attang = att.Ang
    --     local attpos = att.Pos
    --     attang = lhik_model:WorldToLocalAngles(attang)
    --     attpos = lhik_model:WorldToLocal(attpos)
    --     attang:Sub(self.LHIKGunAng)
    --     attpos:Sub(self.LHIKGunPos)
    --     attang:Mul(magnitude)
    --     attpos:Mul(magnitude)
    --     --target.ang:Add(attang)
    --     --target.pos:Add(attpos)
    --     --debugoverlay.Axis(lhik_model:GetPos() + attpos, att.Ang, 8, FrameTime() * 3, true)
    --     debugoverlay.Axis(lhik_model:GetPos(), att.Ang, 8, FrameTime() * 3, true)
    -- end

    -- stopwatch("gunbone")

    local vmhit = self.ViewModel_Hit
    if vmhit then
        if !vmhit:IsZero() then
            target.pos.x = target.pos.x + m_clamp(vmhit.y, -1, 1) * 0.25
            target.pos.y = target.pos.y + vmhit.y
            target.pos.z = target.pos.z + m_clamp(vmhit.x, -1, 1) * 1
            target.ang.x = target.ang.x + m_clamp(vmhit.x, -1, 1) * 5
            target.ang.y = target.ang.y + m_clamp(vmhit.y, -1, 1) * -2
            target.ang.z = target.ang.z + m_clamp(vmhit.z, -1, 1) * 12.5
        end

        local spd = vmhit:Length() * 5
        vmhit.x = m_appor(vmhit.x, 0, FT * spd)
        vmhit.y = m_appor(vmhit.y, 0, FT * spd)
        vmhit.z = m_appor(vmhit.z, 0, FT * spd)
    end

    if ArcCW.ConVars["shakevm"]:GetBool() and !engine.IsRecordingDemo() then
        target.pos:Add(VectorRand() * self.RecoilAmount * 0.2 * self.RecoilVMShake)
    end

    stopwatch("vmhit")

    local speed = 15 * FT * (game.SinglePlayer() and 1 or 2)

    LerpMod(actual.pos, target.pos, speed)
    LerpMod(actual.ang, target.ang, speed, true)
    LerpMod(actual.evpos, target.evpos or vector_origin, speed)
    LerpMod(actual.evang, target.evang or angle_zero, speed, true)
    actual.down = f_lerp(speed, actual.down, target.down)
    actual.sway = f_lerp(speed, actual.sway, target.sway)
    actual.bob = f_lerp(speed, actual.bob, target.bob)

    ApproachMod(actual.pos, target.pos, speed * 0.1)
    ApproachMod(actual.ang, target.ang, speed * 0.1)
    actual.down = m_appor(actual.down, target.down, speed * 0.1)

    stopwatch("actual -> target")

    local coolsway = ArcCW.ConVars["vm_coolsway"]:GetBool()
    self.SwayScale = (coolsway and 0) or actual.sway
    self.BobScale = (coolsway and 0) or actual.bob

    if coolsway then
        swayxmult = ArcCW.ConVars["vm_sway_zmult"]:GetFloat() or 1
        swayymult = ArcCW.ConVars["vm_sway_xmult"]:GetFloat() or 1
        swayzmult = ArcCW.ConVars["vm_sway_ymult"]:GetFloat() or 1
        swayspeed = ArcCW.ConVars["vm_sway_speedmult"]:GetFloat() or 1
        lookxmult = ArcCW.ConVars["vm_look_xmult"]:GetFloat() or 1
        lookymult = ArcCW.ConVars["vm_look_ymult"]:GetFloat() or 1

        local sd = self:GetSightDelta()
        lookxmult = Lerp(sd, 0, lookxmult)
        lookymult = Lerp(sd, 0, lookymult)
        swayxmult = Lerp(sd, 0, swayxmult)
        swayymult = Lerp(sd, 0, swayymult)
        swayzmult = Lerp(sd, 0, swayzmult)
        swayspeed = Lerp(sd, 0, swayspeed)

        stopwatch("before vmposition")
        local npos, nang = self:GetVMPosition(oldpos, oldang)
        pos:Set(npos)
        ang:Set(nang)
    end

    local old_r, old_f, old_u = oldang:Right(), oldang:Forward(), oldang:Up()
    pos:Add(math.min(self.RecoilPunchBack, Lerp(sgtd, self.RecoilPunchBackMaxSights or 1, self.RecoilPunchBackMax)) * -old_f)

    ang:RotateAroundAxis(old_r, actual.ang.x)
    ang:RotateAroundAxis(old_u, actual.ang.y)
    ang:RotateAroundAxis(old_f, actual.ang.z)
    ang:RotateAroundAxis(old_r, actual.evang.x)
    ang:RotateAroundAxis(old_u, actual.evang.y)
    ang:RotateAroundAxis(old_f, actual.evang.z)

    local new_r, new_f, new_u = ang:Right(), ang:Forward(), ang:Up()
    old_r:Mul(actual.evpos.x)
    old_f:Mul(actual.evpos.y)
    old_u:Mul(actual.evpos.z)
    pos:Add(old_r)
    pos:Add(old_f)
    pos:Add(old_u)
    new_r:Mul(actual.pos.x)
    new_f:Mul(actual.pos.y)
    new_u:Mul(actual.pos.z)
    pos:Add(new_r)
    pos:Add(new_f)
    pos:Add(new_u)

    pos.z = pos.z - actual.down

    ang:Add(self:GetOurViewPunchAngles() * Lerp(sgtd, 1, -1))

    local gunbone, gbslot = self:GetBuff_Override("LHIK_GunDriver")
    local lhik_model = gbslot and self.Attachments[gbslot].VElement and self.Attachments[gbslot].VElement.Model -- Visual M203 attachment
    local lhik_anim_model = gbslot and self.Attachments[gbslot].GodDriver and self.Attachments[gbslot].GodDriver.Model -- M203 anim and camera
    local lhik_refl_model = gbslot and self.Attachments[gbslot].ReflectDriver and self.Attachments[gbslot].ReflectDriver.Model -- Rifle
    if IsValid(lhik_model) and IsValid(lhik_anim_model) and IsValid(lhik_refl_model) and lhik_anim_model:GetAttachment(lhik_anim_model:LookupAttachment(gunbone)) then
        local att = lhik_anim_model:LookupAttachment(gunbone)
        local offset = lhik_anim_model:GetAttachment(att).Pos
        local affset = lhik_anim_model:GetAttachment(att).Ang

        affset:Sub( GunDriverFix )
        local r = affset.r
        affset.r = affset.p
        affset.p = -r
        affset.y = -affset.y

        local anchor = self.Attachments[gbslot].VMOffsetPos

        local looku = lhik_refl_model:LookupBone( self.Attachments[gbslot].Bone )
        local bonp, bona = lhik_refl_model:GetBonePosition( looku )
        if bonp == lhik_refl_model:GetPos() then
            bonp = lhik_refl_model:GetBoneMatrix( looku ):GetTranslation()
            bona = lhik_refl_model:GetBoneMatrix( looku ):GetAngles()
        end

        if anchor and bonp then -- Not ready / deploying
            anchor = ( bonp + ( (bona:Forward()*anchor.x) + (bona:Right()*anchor.y) + (bona:Up()*anchor.z) ) )

            debugoverlay.Axis(anchor, angle_zero, 4, FrameTime(), true)

            rap_pos, rap_ang = ArcCW.RotateAroundPoint2(pos, ang, anchor, offset, affset)
            rap_pos:Sub(pos)
            rap_ang:Sub(ang)

            pos:Add(rap_pos)
            ang:Add(rap_ang)
        end
    end

    self.ActualVMData = actual

    stopwatch("apply actual")

    stopwatch(true)

    lst = SysTime()
    return pos, ang
end

function SWEP:ShouldCheapWorldModel()
    local lp = LocalPlayer()
    if lp:GetObserverMode() == OBS_MODE_IN_EYE and lp:GetObserverTarget() == self:GetOwner() then return true end
    if !IsValid(self:GetOwner()) and !ArcCW.ConVars["att_showground"]:GetBool() then return true end

    return !ArcCW.ConVars["att_showothers"]:GetBool()
end

local bird = Material("arccw/hud/arccw_bird.png", "mips smooth")
local iw = 32

function SWEP:DrawWorldModel()
    local cvar2d3d = ArcCW.ConVars["2d3d"]:GetInt()
    if !IsValid(self:GetOwner()) and !TTT2
            and (cvar2d3d == 2 or (cvar2d3d == 1 and LocalPlayer():GetEyeTrace().Entity == self))
            and (EyePos() - self:WorldSpaceCenter()):LengthSqr() <= 262144 then -- 512^2
        local ang = LocalPlayer():EyeAngles()
        ang:RotateAroundAxis(ang:Forward(), 180)
        ang:RotateAroundAxis(ang:Right(), 90)
        ang:RotateAroundAxis(ang:Up(), 90)
        cam.Start3D2D(self:WorldSpaceCenter() + Vector(0, 0, 16), ang, 0.1)

        srf.SetFont("ArcCW_32_Unscaled")
        local w = srf.GetTextSize(self.PrintName)
        srf.SetTextPos(-w / 2 + 2, 2)
        srf.SetTextColor(0, 0, 0, 150)
        srf.DrawText(self.PrintName)
        srf.SetTextPos(-w / 2, 0)
        srf.SetTextColor(255, 255, 255, 255)
        srf.DrawText(self.PrintName)

        local icons = {}
        for i, slot in pairs(self.Attachments or {}) do
            if slot.Installed then
                local atttbl = ArcCW.AttachmentTable[slot.Installed]
                if !atttbl then continue end
                local icon = atttbl.Icon
                if !icon or icon:IsError() then icon = bird end
                table.insert(icons, icon)
            end
        end

        local ind = math.min(6, #icons)

        surface.SetDrawColor(255, 255, 255)
        for i = 1, ind do
            if i == 6 and #icons > 6 then
                local str = "+" .. (#icons - ind)
                local strw = srf.GetTextSize(str)
                srf.SetTextPos(-ind * iw / 2 + (i - 1) * iw + 2 + strw / 2, iw + 14)
                srf.SetTextColor(0, 0, 0, 150)
                srf.DrawText(str)
                srf.SetTextPos(-ind * iw / 2 + (i - 1) * iw + strw / 2, iw + 12)
                srf.SetTextColor(255, 255, 255, 255)
                srf.DrawText(str)
            else
                local icon = icons[i]
                surface.SetMaterial(icon)
                surface.DrawTexturedRect(-ind * iw / 2 + (i - 1) * iw, iw + 12, iw, iw)
            end
        end

        -- srf.SetFont("ArcCW_24_Unscaled")
        -- local count = self:CountAttachments()

        -- if count > 0 then
        --     local t = tostring(count) .. " Attachments"
        --     w = srf.GetTextSize(t)
        --     srf.SetTextPos(-w / 2, 32)
        --     srf.SetTextColor(255, 255, 255, 255)
        --     srf.DrawText(t)
        -- end

        cam.End3D2D()
    end

    self:DrawCustomModel(true)
    self:DoLaser(true)

    if self:ShouldGlint() then
        self:DoScopeGlint()
    end

    if !self.CertainAboutAtts and !self.AttReqSent and !IsValid(self:GetOwner()) then
        self.AttReqSent = true
        -- print(self, "network weapon from cl_viewmodel")
        -- debugoverlay.Cross(self:GetPos(), 8, 10, color_white, true)
        -- debugoverlay.EntityTextAtPosition(self:GetPos(), 1, tostring(self) .. " requesting networking data", 10, color_white)
        net.Start("arccw_rqwpnnet")
            net.WriteEntity(self)
        net.SendToServer()
    end
end

function SWEP:ShouldCheapScope()
    if !ArcCW.ConVars["cheapscopes"]:GetBool() then return end
end

local POSTVMDONE = nil
local POSTVMDONE_TIME = 0

local lst2 = SysTime()
function SWEP:PreDrawViewModel(vm)
    if ArcCW.VM_OverDraw then return end
    if !vm then return end

    if self:GetState() == ArcCW.STATE_CUSTOMIZE then
        self:BlurNotWeapon()
    end

    if ArcCW.ConVars["cheapscopesautoconfig"]:GetBool() then
        local fps = 1 / (SysTime() - lst2)
        lst2 = SysTime()
        local lowfps = fps <= 45
        ArcCW.ConVars["cheapscopes"]:SetBool(lowfps)
        ArcCW.ConVars["cheapscopesautoconfig"]:SetBool(false)
    end

    local asight = self:GetActiveSights()

    if asight and ((ArcCW.ConVars["cheapscopes"]:GetBool() and self:GetSightDelta() < 1 and asight.MagnifiedOptic)
            or (self:GetSightDelta() < 1 and asight.ScopeTexture)) then
        -- Necessary to call here since physbullets are not drawn until PreDrawEffects; cheap scope implementation will not allow them to be visible
        -- Introduces a bug when we try to call GetAttachment on the viewmodel in DrawPhysBullets here, so set a workaround variable to not call it
        ArcCW:DrawPhysBullets(true)
        self:FormCheapScope()
    end

    local coolFOV = self.CurrentViewModelFOV or self.ViewModelFOV

    if ArcCW.VMInRT then
        local mag = asight.ScopeMagnification
        coolFOV = self.ViewModelFOV - mag * 4 - (ArcCW.ConVars["vm_add_ads"]:GetFloat() * 3 or 0)
        ArcCW.VMInRT = false
    end

    cam.Start3D(EyePos(), EyeAngles(), self:QuickFOVix(coolFOV), nil, nil, nil, nil, 0.5, 1000)
    cam.IgnoreZ(true)
    self:DrawCustomModel(false)
    self:DoLHIK()

    if !ArcCW.Overdraw then
        self:DoLaser(false, true)
    end

    -- patrol
    if POSTVMDONE == false and POSTVMDONE_TIME <= CurTime() then
        POSTVMDONE_TIME = CurTime() + 1
        print( "[ArcCW] Warning: PostDrawViewModel failed response!! cam.End3D errors may be inbound!! You may have an addon conflict!!")
        print( "[ArcCW] Follow the troubleshooting guide at https://github.com/HaodongMo/ArcCW/wiki/Help-&-Troubleshooting#camend3d-errors")
    end
    POSTVMDONE = false
end

function SWEP:PostDrawViewModel()
    POSTVMDONE = true
    if ArcCW.VM_OverDraw then return end
    render.SetBlend(1)
    cam.End3D()
    cam.Start3D(EyePos(), EyeAngles(), self:QuickFOVix(self.CurrentViewModelFOV or self.ViewModelFOV), nil, nil, nil, nil, 0.5, 1000)
    cam.IgnoreZ(true)

    if ArcCW.Overdraw then
        ArcCW.Overdraw = false
    else
        --self:DoLaser()
        self:DoHolosight()
    end

    cam.End3D()
end

--addons/arccw_base_modified/lua/weapons/arccw_base/sh_bash.lua:
function SWEP:CanBackstab(melee2, ent)
    if !self:GetBuff_Override("Override_Backstab", self.Backstab) then return false end
    local reach = 32 + self:GetBuff_Add("Add_MeleeRange") + (melee2 and self.Melee2Range or self.MeleeRange)

    if (!IsValid(ent)) then
        local tr = util.TraceLine({
            start = self:GetOwner():GetShootPos(),
            endpos = self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * reach,
            filter = {self:GetOwner()},
            mask = MASK_SHOT_HULL
        })
        if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:IsNextBot() then
            ent = tr.Entity
        end
    end

    if (!IsValid(ent)) then
        local tr = util.TraceHull({
            start = self:GetOwner():GetShootPos(),
            endpos = self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * reach,
            filter = {self:GetOwner()},
            mins = Vector(-16, -16, -8),
            maxs = Vector(16, 16, 8),
            mask = MASK_SHOT_HULL
        })
        if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity:IsNextBot() then
            ent = tr.Entity
        end
    end

    if IsValid(ent) then
        local angle = math.NormalizeAngle(self:GetOwner():GetAngles().y - ent:GetAngles().y)
        return angle <= 90 and angle >= -90
    end

    return false
end

function SWEP:DoLunge(melee2)
    if ArcCW.ConVars["override_lunge_off"]:GetBool() then return end
    local var = self:GetBuff_Override("Override_Lunge", self.Lunge)
    if var == false or var == nil and self.PrimaryBash then return end
    if !self:GetOwner():IsPlayer() or self:GetOwner():Crouching() then return end

    local reach = 32 + self:GetBuff_Add("Add_MeleeRange") + (melee2 and self.Melee2Range or self.MeleeRange)
    local tr = self:GetOwner():GetEyeTrace()
    local tgt = tr.Entity

    if IsValid(tgt) and (tgt:IsPlayer() or tgt:IsNPC() or tgt:IsNextBot()) then

        local dist = (tr.HitPos - tr.StartPos):Length()

        if dist > reach and dist < reach + self:GetBuff("LungeLength") then
            local dir = tr.Normal
            dir.z = math.min(dir.z, 0)
            dir:Normalize()
            self:GetOwner():SetVelocity(dir * (self:GetOwner():IsOnGround() and 5 or 2.5) * dist)
        end
    end
end

function SWEP:Bash(melee2)
    melee2 = melee2 or false
    if self:GetState() == ArcCW.STATE_SIGHTS
            or (self:GetState() == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint())
            or self:GetState() == ArcCW.STATE_CUSTOMIZE then
        return
    end
    if self:GetNextPrimaryFire() > CurTime() or self:GetGrenadePrimed() or self:GetPriorityAnim() then return end

    if !self.CanBash and !self:GetBuff_Override("Override_CanBash") then return end

    self:GetBuff_Hook("Hook_PreBash")

    self.Primary.Automatic = true

    local mult = self:GetBuff_Mult("Mult_MeleeTime")
    local mt = self.MeleeTime * mult

    if melee2 then
        mt = self.Melee2Time * mult
    end

    mt = mt * self:GetBuff_Mult("Mult_MeleeWaitTime")

    local bashanim = "bash"
    local canbackstab = self:CanBackstab(melee2)

    if melee2 then
        bashanim = canbackstab and self:SelectAnimation("bash2_backstab") or self:SelectAnimation("bash2") or bashanim
    else
        bashanim = canbackstab and self:SelectAnimation("bash_backstab") or self:SelectAnimation("bash") or bashanim
    end

    bashanim = self:GetBuff_Hook("Hook_SelectBashAnim", bashanim) or bashanim

    if bashanim and self.Animations[bashanim] then
        if SERVER then self:PlayAnimation(bashanim, mult, true, 0, true) end
    else
        self:ProceduralBash()

        self:MyEmitSound(self.MeleeSwingSound, 75, 100, 1, CHAN_USER_BASE + 1)
    end

    if CLIENT then
        self:OurViewPunch(-self.BashPrepareAng * 0.05)
    end
    self:SetNextPrimaryFire(CurTime() + mt )

    if melee2 then
        if self.HoldtypeActive == "pistol" or self.HoldtypeActive == "revolver" then
            self:GetOwner():DoAnimationEvent(self.Melee2Gesture or ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE)
        else
            self:GetOwner():DoAnimationEvent(self.Melee2Gesture or ACT_GMOD_GESTURE_MELEE_SHOVE_2HAND)
        end
    else
        if self.HoldtypeActive == "pistol" or self.HoldtypeActive == "revolver" then
            self:GetOwner():DoAnimationEvent(self.MeleeGesture or ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE)
        else
            self:GetOwner():DoAnimationEvent(self.MeleeGesture or ACT_GMOD_GESTURE_MELEE_SHOVE_2HAND)
        end
    end

    local mat = self.MeleeAttackTime

    if melee2 then
        mat = self.Melee2AttackTime
    end

    mat = mat * self:GetBuff_Mult("Mult_MeleeAttackTime") * math.pow(mult, 1.5)

    self:SetTimer(mat or (0.125 * mt), function()
        if !IsValid(self) then return end
        if !IsValid(self:GetOwner()) then return end
        if self:GetOwner():GetActiveWeapon() != self then return end

        if CLIENT then
            self:OurViewPunch(-self.BashAng * 0.05)
        end

        self:MeleeAttack(melee2)
    end)

    self:DoLunge()
end

function SWEP:MeleeAttack(melee2)
    local reach = 32 + self:GetBuff_Add("Add_MeleeRange") + self.MeleeRange
    local dmg = self:GetBuff_Override("Override_MeleeDamage", self.MeleeDamage) or 20

    if melee2 then
        reach = 32 + self:GetBuff_Add("Add_MeleeRange") + self.Melee2Range
        dmg = self:GetBuff_Override("Override_MeleeDamage", self.Melee2Damage) or 20
    end

    dmg = dmg * self:GetBuff_Mult("Mult_MeleeDamage")

    self:GetOwner():LagCompensation(true)

    local filter = {self:GetOwner()}

    table.Add(filter, self.Shields)

    local tr = util.TraceLine({
        start = self:GetOwner():GetShootPos(),
        endpos = self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * reach,
        filter = filter,
        mask = MASK_SHOT_HULL
    })

    if (!IsValid(tr.Entity)) then
        tr = util.TraceHull({
            start = self:GetOwner():GetShootPos(),
            endpos = self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * reach,
            filter = filter,
            mins = Vector(-16, -16, -8),
            maxs = Vector(16, 16, 8),
            mask = MASK_SHOT_HULL
        })
    end

    -- Backstab damage if applicable
    local backstab = tr.Hit and self:CanBackstab(melee2, tr.Entity)
    if backstab then
        if melee2 then
            local bs_dmg = self:GetBuff_Override("Override_Melee2DamageBackstab", self.Melee2DamageBackstab)
            if bs_dmg then
                dmg = bs_dmg * self:GetBuff_Mult("Mult_MeleeDamage")
            else
                dmg = dmg * self:GetBuff("BackstabMultiplier") * self:GetBuff_Mult("Mult_MeleeDamage")
            end
        else
            local bs_dmg = self:GetBuff_Override("Override_MeleeDamageBackstab", self.MeleeDamageBackstab)
            if bs_dmg then
                dmg = bs_dmg * self:GetBuff_Mult("Mult_MeleeDamage")
            else
                dmg = dmg * self:GetBuff("BackstabMultiplier") * self:GetBuff_Mult("Mult_MeleeDamage")
            end
        end
    end

    -- We need the second part for single player because SWEP:Think is ran shared in SP
    if !(game.SinglePlayer() and CLIENT) then
        if tr.Hit then
            if tr.Entity:IsNPC() or tr.Entity:IsNextBot() or tr.Entity:IsPlayer() then
                self:MyEmitSound(self.MeleeHitNPCSound, 75, 100, 1, CHAN_USER_BASE + 2)
            else
                self:MyEmitSound(self.MeleeHitSound, 75, 100, 1, CHAN_USER_BASE + 2)
            end

            if tr.MatType == MAT_FLESH or tr.MatType == MAT_ALIENFLESH or tr.MatType == MAT_ANTLION or tr.MatType == MAT_BLOODYFLESH then
                local fx = EffectData()
                fx:SetOrigin(tr.HitPos)

                util.Effect("BloodImpact", fx)
            end
        else
            self:MyEmitSound(self.MeleeMissSound, 75, 100, 1, CHAN_USER_BASE + 3)
        end
    end

    if SERVER and IsValid(tr.Entity) and (tr.Entity:IsNPC() or tr.Entity:IsPlayer() or tr.Entity:Health() > 0) then
        local dmginfo = DamageInfo()

        local attacker = self:GetOwner()
        if !IsValid(attacker) then attacker = self end
        dmginfo:SetAttacker(attacker)

        local relspeed = (tr.Entity:GetVelocity() - self:GetOwner():GetAbsVelocity()):Length()

        relspeed = relspeed / 225

        relspeed = math.Clamp(relspeed, 1, 1.5)

        dmginfo:SetInflictor(self)
        dmginfo:SetDamage(dmg * relspeed)
        dmginfo:SetDamageType(self:GetBuff_Override("Override_MeleeDamageType") or self.MeleeDamageType or DMG_CLUB)

        dmginfo:SetDamageForce(self:GetOwner():GetRight() * -4912 + self:GetOwner():GetForward() * 9989)

        SuppressHostEvents(NULL)
        tr.Entity:TakeDamageInfo(dmginfo)
        SuppressHostEvents(self:GetOwner())

        if tr.Entity:GetClass() == "func_breakable_surf" then
            tr.Entity:Fire("Shatter", "0.5 0.5 256")
        end

    end

    if SERVER and IsValid(tr.Entity) then
        local phys = tr.Entity:GetPhysicsObject()
        if IsValid(phys) then
            phys:ApplyForceOffset(self:GetOwner():GetAimVector() * 80 * phys:GetMass(), tr.HitPos)
        end
    end

    self:GetBuff_Hook("Hook_PostBash", {tr = tr, dmg = dmg})

    self:GetOwner():LagCompensation(false)
end
--addons/arccw_base_modified/lua/weapons/arccw_base/sh_bipod.lua:
function SWEP:InBipod()
    local bip = self:GetInBipod()

    -- if !self:CanBipod() then
    --     self:ExitBipod()
    -- end

    if IsValid(self:GetOwner()) and self:GetBipodPos() != self:GetOwner():EyePos() then
        self:ExitBipod()
    end

    return bip
end

SWEP.CachedCanBipod = true
SWEP.CachedCanBipodTime = 0

local dist = 24
function SWEP:CanBipod()
    if !(self:GetBuff_Override("Bipod") or self.Bipod_Integral) then return false end

    if self:GetOwner():InVehicle() then return false end

    if self.CachedCanBipodTime >= CurTime() then return self.CachedCanBipod end

    local pos = self:GetOwner():EyePos()
    local angle = self:GetOwner():EyeAngles()
    if self:GetOwner():GetVelocity():Length() > 0 then
        return false
    end

    local rangemult = 2
    if self:IsProne() then
        rangemult = rangemult * 1.25
    end
    rangemult = rangemult * self:GetBuff_Mult("Mult_BipodRange")

    local tr = util.TraceLine({
        start = pos,
        endpos = pos + (angle:Forward() * dist * rangemult),
        filter = self:GetOwner(),
        mask = MASK_PLAYERSOLID
    })

    if tr.Hit then -- check for stuff in front of us
        return false
    end

    local maxs = Vector(8, 8, 16)
    local mins = Vector(-8, -8, 0)

    angle.p = angle.p + 45

    tr = util.TraceHull({
        start = pos,
        endpos = pos + (angle:Forward() * dist * rangemult),
        filter = self:GetOwner(),
        maxs = maxs,
        mins = mins,
        mask = MASK_PLAYERSOLID
    })

    self.CachedCanBipodTime = CurTime()

    if tr.Hit then
        local tr2 = util.TraceHull({
            start = tr.HitPos,
            endpos = tr.HitPos + Vector(0, 0, -24),
            filter = self:GetOwner(),
            maxs = maxs,
            mins = mins,
            mask = MASK_PLAYERSOLID
        })
        if tr2.Hit then
            self.CachedCanBipod = true
            return true, tr2
        end
    end

    self.CachedCanBipod = false
    return false
end

function SWEP:EnterBipod(sp)
    if !sp and self:GetInBipod() then return end
    local can, tr = self:CanBipod()
    if !sp and !can then return end

    if SERVER and game.SinglePlayer() then self:CallOnClient("EnterBipod", "true") end

    if self.Animations.enter_bipod then
        self:PlayAnimation("enter_bipod", nil, nil, 0, true)
    else
        -- Block actions for a tiny bit even if there is no animation
        self:SetNextPrimaryFire(CurTime() + 0.25)
    end

    if CLIENT and self:GetBuff_Override("LHIK") then
        self:DoLHIKAnimation("enter")
    end

    local bipodang = tr.HitNormal:Cross(self:GetOwner():EyeAngles():Right()):Angle()

    debugoverlay.Axis(tr.HitPos, tr.HitNormal:Angle(), 16, 5, true)
    debugoverlay.Line(tr.HitPos, tr.HitPos + bipodang:Forward() * 32, 5, color_white, true)
    debugoverlay.Line(tr.HitPos, tr.HitPos + self:GetOwner():EyeAngles():Forward() * 32, 5, Color(255, 255, 0), true)

    self:SetBipodPos(self:GetOwner():EyePos())
    self:SetBipodAngle(bipodang)
    self.BipodStartAngle = self:GetOwner():EyeAngles()

    if game.SinglePlayer() and CLIENT then return end

    self:MyEmitSound(self.EnterBipodSound)
    self:SetInBipod(true)
end

function SWEP:ExitBipod(sp)
    if !sp and !self:GetInBipod() then return end

    if SERVER and game.SinglePlayer() then self:CallOnClient("ExitBipod", "true") end

    if self.Animations.exit_bipod then
        self:PlayAnimation("exit_bipod", nil, nil, 0, true)
    else
        self:SetNextPrimaryFire(CurTime() + 0.25)
    end

    if CLIENT and self:GetBuff_Override("LHIK") then
        self:DoLHIKAnimation("exit")
    end

    if game.SinglePlayer() and CLIENT then return end

    self:MyEmitSound(self.ExitBipodSound)
    self:SetInBipod(false)
end

--addons/arccw_weapons/lua/weapons/arccw_cis_se14.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Droidenwaffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "SE-14"
SWEP.Trivia_Class = "CIS Blaster Pistol"
SWEP.Trivia_Desc = "CIS Blaster for CQB enviroments"
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_se14r.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 300
SWEP.DamageMin = 17
SWEP.Range = 600
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 32

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 1.4
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 560
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = -4,
        RunawayBurst = true,
        PostBurstDelay = 0.2,
    },
    {
        Mode = 0
    },   
}

SWEP.AccuracyMOA = 0.75 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 800 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(255, 0, 0)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/se14c.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-4, -8, 1.3),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "idle"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -4, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -10,-20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(12.824, -8, -3.897)
SWEP.CustomizeAng = Angle(10.149, 34.547, 0)


SWEP.DefaultElements = {"se14"}

SWEP.AttachmentElements = {
    ["se14"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/2019/se14_pistol.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(0, 0, -3.5),
                    ang = Angle(0, 90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/2019/se14_pistol.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(40, 20, 10),
                    ang = Angle(-0, 0, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/sw_battlefront/weapons/2019/se14_pistol.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = {"optic_lp", "optic"},
        WMScale = Vector(11, 11, 11),
        Bone = "scoutblaster_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, -0.8, 2.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(50, 20, -55),
            wang = Angle(0, 0, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(11, 11, 11),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, -6.5, -0.5),
            vang = Angle(0, 90, 0),
            wpos = Vector(90 , 20, -40),
            wang = Angle(0, 0, 180)
        },
    },    
    [3] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        WMScale = Vector(11, 11, 11),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, -0, 9),
            vang = Angle(90, 0, -90),
            wpos = Vector(130, 20, -48),
            wang = Angle(-0, 0, 180)
        },
    },        
    [4] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [5] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(11, 11, 11),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.5, 0.7, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(70, 25, -55),
            wang = Angle(-10, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}


-- AOCRP WAFFENSTATS arccw_cis_se14 - 02.06.2024
SWEP.Damage = 30
SWEP.DamageMin = 15
SWEP.RangeMin = 390
SWEP.Range = 1075
SWEP.Delay = 60 / 325
SWEP.Primary.ClipSize = 20
SWEP.Category = 'KUS'
--addons/arccw_weapons/lua/weapons/arccw_dc15a_original.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "DC-15A (Original)"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "High tech DC-15A Blaster Rifle, preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/dc15a_rifle_original_meeks.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_dc15a_rifle.mdl"
SWEP.ViewModelFOV = 65
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(10, 0, -4),
    ang = Angle(165, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.IconOverride = "materials/entities/rw_sw_dc15a.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 45
SWEP.RangeMin = 190
SWEP.DamageMin = 27
SWEP.Range = 550
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.29
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.22

SWEP.Delay = 60 / 320
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },            
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 400 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100


SWEP.DistantShootSound = "dc15a/SW02_Weapons_Blasters_Shared_Corebass_Tight_Close_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "dc15a/SW02_Weapons_Blasters_DC15_Laser_Close_VAR_03 4 1 0.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-2.755, -12, .4),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(2.5, -2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

-- SWEP.DefaultElements = {"", ""}

-- SWEP.AttachmentElements = {
--     ["dc15a"] = {
--         VMElements = {
--             {
--                 Model = "models/arccw/sw_battlefront/weapons/new/DC15A_Rifle.mdl", -- using the model-edit i made in like 2 mins lol
--                 Bone = "v_dlt19_reference001",
--                 Scale = Vector(1.2, 1.2, 1.2),
--                 Offset = {
--                     pos = Vector(.7, -0.3, 0.5),
--                     ang = Angle(0,-90, 0)
--                 },
--             }
--         },
--     },
--     ["muzzle"] = {
--          VMElements = {
--             {
--                 Model = "models/hunter/plates/plate.mdl",
--                 Bone = "dlt19_sight",
--                 Scale = Vector(0, 0, 0),                
--                 Offset = {
--                     pos = Vector(-0.5, 4, 27 ),
--                     ang = Angle(-90, 180, 0)
--                 },
--                 IsMuzzleDevice = true
--             }
--         },
--         WMElements = {
--             {
--                 Model = "models/arccw/sw_battlefront/weapons/new/dc15a_rifle.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(1.1, 1.1, 1.1),
--                 Offset = {
--                     pos = Vector(3.75, 2.5, -1.5),
--                     ang = Angle(-15, 0, 180)
--                 }
--             },
--             {
--                 Model = "models/hunter/plates/plate.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(0, 0, 0),
--                 Offset = {
--                     pos = Vector(3500, 0, -1100),
--                     ang = Angle(-15, 0, 180)
--                 },
--                 IsMuzzleDevice = true
--             },
--         }, -- change the world model to something else. Please make sure it's compatible with the last one.
--     }
-- }
-- WMOverride = "models/arccw/sw_battlefront/weapons/new/dc15a_rifle.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = {"dc15a_range_finder", "optic"},
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0, -0, -0.15),
            vang = Angle(90, 0, -90),
            wpos = Vector(5, 0.35, -4.5),
            wang = Angle(-15, 0, 180)
        },
        -- CorrectiveAng = Angle(0, .65, 0)
    },
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"foregrip"},
        Bone = "sights", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.2, 2.25, 15.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(20, 0.4, -5.9),
            wang = Angle(165, 180, 0),
        },
    },          
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol","tac"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0., 2, 22),
            vang = Angle(90, 0, -90),
            wpos = Vector(32, 0.4, -10),
            wang = Angle(-15, 0, -180)
        },
    },
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle","dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0, 0.9, 27.1),
            vang = Angle(90, 0, -90),
            wpos = Vector(33, 0.45, -11),
            wang = Angle(-15, 0, 180)
        },
    },    
    [5] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"dc15a_magazine_75", "dc15a_magazine_100"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0, 1.68, -0.8),
            vang = Angle(0, -1.75, -2.5),
            wpos = Vector(8, 2, -3.8),
            wang = Angle(-15, 90, -90)
        },
    },         
    [6] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.75, 1, 7.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(12, 1.2, -5.5),
            wang = Angle(-10 , 0, 180)
        },
    },    
    [9] = {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        Bone = "sights", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.8, 1, 4),
            vang = Angle(90, 0, -90),
            wpos = Vector(10, 1.2, -5.5),
            wang = Angle(-16.5 , 0, 180)
        },
    },   
    [10] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [11] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3,
        LHIK = true,
        LHIKOut = 0.6,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "reloads/heavy.wav", t = 4 / 30}, --s sound file
        },
    },

}
--addons/arccw_weapons/lua/weapons/arccw_dc15s_training_v2.lua:
AddCSLuaFile()
SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "DC-15s (Training)"
SWEP.Trivia_Class = "Modular Blaster"
SWEP.Trivia_Desc = "High tech verstile modular blaster base, suited for allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"

SWEP.ViewModel = "models/meeks/c_dc15s_meek.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_dc15s_v2.mdl"
SWEP.IconOverride = "materials/entities/rw_sw_trd_dc15s.png"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "111"
SWEP.DefaultWMBodygroups = "111"
SWEP.DefaultSkin = 0
SWEP.DefaultWMSkin = 0

SWEP.NoHideLeftHandInCustomization = false

SWEP.Damage = 27
SWEP.DamageMin = 14 -- damage done at maximum range
SWEP.DamageRand = 0 -- damage will vary randomly each shot by this fraction
SWEP.RangeMin = 100 -- how far bullets will retain their maximum damage for
SWEP.Range = 300 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false -- set to true to have the base not do anything with damage types
-- this includes: igniting if type has DMG_BURN; adding DMG_AIRBOAT when hitting helicopter; adding DMG_BULLET to DMG_BUCKSHOT

SWEP.MuzzleVelocity = 400 -- projectile muzzle velocity in m/s

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 3 -- color for phys tracer.

SWEP.TracerNum = 1 -- tracer every X
SWEP.TracerFinalMag = 0 -- the last X bullets in a magazine are all tracers
SWEP.Tracer = "tfa_tracer_orange" -- override tracer (hitscan) effect
SWEP.TracerCol = Color(255, 128, 0)
SWEP.HullSize = 2 -- HullSize used by FireBullets

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 20 -- DefaultClip is automatically set.

SWEP.AmmoPerShot = 1

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.15
SWEP.RecoilRise = 0.53
SWEP.VisualRecoilMult = 2
SWEP.RecoilPunch = 1.4
SWEP.RecoilPunchBackMax = 0.9

SWEP.RecoilDirection = Angle(1.1, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1.1, 0)

SWEP.Delay = 60 / 330 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 2 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
	{
		Mode = 2,
   	},
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace

SWEP.AccuracyMOA = 5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 410 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 65 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 130 -- dispersion that remains even in sights
SWEP.JumpDispersion = 200 -- dispersion penalty when in the air

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "ar2" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 50 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "dc15s/blasters_dc15_laser_close_var_02.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"


SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_orange"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(255, 166, 0)

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1

SWEP.IronSightStruct = {
    Pos = Vector(-2.85, -2, 2.25),
    Ang = Angle(0, 0, -0.5),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1,
    CrosshairInSights = false,
}


SWEP.SightTime = 0.13
SWEP.SprintTime = 0
-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "unjam" animation
-- if no "unjam", "fix", or "cycle" animations exist, the weapon will reload instead
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.
SWEP.MalfunctionTakeRound = true -- When malfunctioning, a bullet is consumed.
SWEP.MalfunctionWait = 0.5 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMean = nil -- The mean number of shots between malfunctions, will be autocalculated if nil
SWEP.MalfunctionVariance = 0.25 -- The fraction of mean for variance. e.g. 0.2 means 20% variance
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.CanBash = true
SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.SprintPos = Vector(6, -4, 0)
SWEP.SprintAng = Angle(-16.524, 60, -11.046)

SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.CustomizePos = Vector(10.824, -7, 4.897)
SWEP.CustomizeAng = Angle(12.149, 45.547, 45)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.BarrelLength = 24

SWEP.SightPlusOffset = true

SWEP.DefaultElements = {}

SWEP.AttachmentElements = {
    ["nil"] = {
        VMElements = {
            {
                Model = "models/arccw/props/e11r_scope/e11r_scope.mdl",
                Bone = "weapon",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0.05, -2.85, 0.8),
                    ang = Angle(-0.3, 0, -90)
                }
            }
        },
        WMElements = { -- Purely handles muzzle effect on the world model
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(20, 0.5, -8),
                    ang = Angle(0, 0, 0)
                },
                IsMuzzleDevice = true
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}


SWEP.Attachments = {
	[1] = {
		PrintName = "Optic", -- print name
		DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
		Slot = "optic",
        DefaultEles = {"ironsight"},
		Bone = "DC15", -- relevant bone any attachments will be mostly referring to
		Offset = {
            vpos = Vector(0.02, -1.5, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1.5, -5),
            wang = Angle(-10, 2, 180)
        },
        NoWM = false
	},
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC15", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(.9, -0.5, 6),
            vang = Angle(90, 0, -0),
            wpos = Vector(14, 2, -5.5),
            wang = Angle(-10, 5, -90)
        },
        NoWM = false
    },
    [3] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "DC15", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.9, 0, -3.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1.8, -4.5),
            wang = Angle(0, 0, 180)
        },
    },
    [4] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        Bone = "DC15", -- relevant bone any attachments wwill be mostly referring to /
        Offset = {
            vpos = Vector(-0, 0.2, 2.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(9, .5, 2),
            wang = Angle(0, 0, 180)            
        },
        SlideAmount = {
        vmin = Vector(-0, 0.2, 2),
        vmax = Vector(-0, 0.2, 6),
        wmin = Vector(14, 1, -4.5), 
        wmax = Vector(14, 1, -4.5) -- how far this attachment can slide in both directions.
        },          -- Set this to false if you want the foregrips to display on ViewModels.          
    },
    [5] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = {"ammo", "sw_ammo"},
    },
    [6] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [7] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"dc15a_magazine_75"},
        Bone = "Magazine", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(2, 0.7, -1.6),
            vang = Angle(180, 0, 0),
            wpos = Vector(9.5, 1.5, -3.8),
            wang = Angle(80, 90, 0) 
        },
    },
    [8] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle"},
        Bone = "DC15", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, -0.5, 11.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(20, 1, -6.5),
            wang = Angle(-12, 0.5, 180) 
        },
    },                              
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sights"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },
    ["enter_sight"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },
    ["exit_sight"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },  
	["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		SoundTable = {
	        {
				s = "dc15s/overheat_manualcooling_resetfoley_generic_var_03.mp3", -- sound; can be string or table
				p = 100, -- pitch
				v = 100, -- volume
				t = 0.1, -- time at which to play relative to Animations.Time
				c = CHAN_ITEM, -- channel to play the sound
			},
			{
				s = "dc15s/overheat_reset_var_02.mp3", -- "everfall/weapons/miscellaneous/charge/blasters_deathray_charge_start_var_04.mp3"sound; can be string or table
				p = 100, -- pitch
				v = 100, -- volume
				t = 1.1, -- time at which to play relative to Animations.Time
				c = CHAN_ITEM, -- channel to play the sound
			},
		}
    },
	["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
	["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}
--addons/arccw_weapons/lua/weapons/arccw_dc17ext_v2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "DC-17 Extended"
SWEP.Trivia_Class = "Heavy Blaster Pistol"
SWEP.Trivia_Desc = "Heavy blaster pistol for CQB enviroments"
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/v_dc17ext_meeks.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_dc17_ext_v2.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(10, 0, -4.4),
    ang = Angle(175, 180, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

SWEP.IconOverride = "materials/entities/rw_sw_dc17ext.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 90
SWEP.DamageMin = 23
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 240
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.DistantShootSound = "dc17/SW01_Weapons_Blasters_Shared_Corebass_Close_Tight_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "dc17/SW02_Weapons_Blasters_DC17_Laser_Close_VAR_07 0 0 0.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-5.4, -0, 0.4),
    Ang = Angle(0, 0, 0),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1,
    CrosshairInSights = false,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1, -3, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(2, -10,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {""}

-- SWEP.AttachmentElements = {
--     ["dc17"] = {
--         VMElements = {
--             {
--                 Model = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl",
--                 Bone = "v_scoutblaster_reference001",
--                 Scale = Vector(1.1, 1.1, 1.1),
--                 Offset = {
--                     pos = Vector(0, 0, 0),
--                     ang = Angle(0, 90, 0)
--                 }
--             }
--         },
--         WMElements = {
--             {
--                 Model = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(1, 1, 1),
--                 Offset = {
--                     pos = Vector(300, 100, -90),
--                     ang = Angle(-15, 0, 180)
--                 }
--             }
--         },
--     },
-- }
-- WMOverride = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic_lp",
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
		Offset = {
            vpos = Vector(-0.4, -3.1, -3),
            vang = Angle(90, 0, -90),
            -- wpos = Vector(70, 9, -53),
            -- wang = Angle(-10, 0, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-.3, 0, 0),
            vang = Angle(90, 0, -90),
            -- wpos = Vector(380, 3, -87),
            -- wang = Angle(-11, 0, 180)
        },
    },
    [3] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-.4, -1.4, 2),
            vang = Angle(90, 0, -90),
            -- wpos = Vector(900, 100, -500),
            -- wang = Angle(-15, 0, 180)
        },
    },        
    [4] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [5] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.24, -2, -2),
            vang = Angle(90, 0, -90),
            -- wpos = Vector(450, 150, -420),
            -- wang = Angle(-10, 0, 180)
        },
    },          
    [7] = {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 0.5, 0),
            vang = Angle(90, 0, -90),
            -- wpos = Vector(200, 165, -325),
            -- wang = Angle(-15, 0, 180)
        },
    },   
    [8] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [9] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}


SWEP.Animations = {
    ["idle"] = {
        Source = "Idle",
    },
    ["fire"] = {
        Source = "Fire",
    },
    ["fire_sights"] = {
        Source = "",
        Time = -1,
    },
    ["idle_sights"] = {
        Source = "",
        Time = -1,
    },
    ["enter_sight"] = {
        Source = "neutral",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        Time = 2.5,
        SoundTable = {
            {s = "reloads/pistols.wav", t = 1 / 30}, --s sound file
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_dc17s_v2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "DC-17s"
SWEP.Trivia_Class = "Heavy Blaster Pistol"
SWEP.Trivia_Desc = "Heavy blaster pistol for CQB enviroments"
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/v_dc17s_mk.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_dc17s_v2.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(10.3, 0, -4.9),
    ang = Angle(175, 180, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

SWEP.IconOverride = "materials/entities/rw_sw_dc17s.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 90
SWEP.DamageMin = 23
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 425
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.DistantShootSound = "dc17/SW01_Weapons_Blasters_Shared_Corebass_Close_Tight_VAR_02 0 0 0.mp3"
SWEP.ShootSound = "dc17/SW02_Weapons_Blasters_DC17_Laser_Close_VAR_07 0 0 0.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-5.4, -0, 0.4),
    Ang = Angle(0, 0, 0),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1,
    CrosshairInSights = false,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1, -3, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(2, -10,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {""}

-- SWEP.AttachmentElements = {
--     ["dc17"] = {
--         VMElements = {
--             {
--                 Model = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl",
--                 Bone = "v_scoutblaster_reference001",
--                 Scale = Vector(1.1, 1.1, 1.1),
--                 Offset = {
--                     pos = Vector(0, 0, 0),
--                     ang = Angle(0, 90, 0)
--                 }
--             }
--         },
--         WMElements = {
--             {
--                 Model = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl",
--                 Bone = "ValveBiped.Bip01_R_Hand",
--                 Scale = Vector(1, 1, 1),
--                 Offset = {
--                     pos = Vector(300, 100, -90),
--                     ang = Angle(-15, 0, 180)
--                 }
--             }
--         },
--     },
-- }
-- WMOverride = "models/arccw/SW_Battlefront/Weapons/dc17_blaster.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic_lp",
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
		Offset = {
            vpos = Vector(-0.4, -3.1, -3),
            vang = Angle(90, 0, -90),
            wpos = Vector(70, 9, -53),
            wang = Angle(-10, 0, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-.3, 0, 0),
            vang = Angle(90, 0, -90),
            -- wpos = Vector(380, 3, -87),
            -- wang = Angle(-11, 0, 180)
        },
    },
    [3] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-.4, -1.4, 2),
            vang = Angle(90, 0, -90),
            -- wpos = Vector(900, 100, -500),
            -- wang = Angle(-15, 0, 180)
        },
    },        
    [4] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [5] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.24, -2, -2),
            vang = Angle(90, 0, -90),
            -- wpos = Vector(450, 150, -420),
            -- wang = Angle(-10, 0, 180)
        },
    },          
    [7] = {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        Bone = "DC-15SA", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, 0.5, 0),
            vang = Angle(90, 0, -90),
            -- wpos = Vector(200, 165, -325),
            -- wang = Angle(-15, 0, 180)
        },
    },   
    [8] = {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },    
    [9] = {
        PrintName = "Internal Modifications", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "uc_fg",
    },   
}


SWEP.Animations = {
    ["idle"] = {
        Source = "Idle",
    },
    ["fire"] = {
        Source = "shoot",
    },
    ["fire_sights"] = {
        Source = "",
        Time = -1,
    },
    ["idle_sights"] = {
        Source = "",
        Time = -1,
    },
    ["enter_sight"] = {
        Source = "neutral",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        SoundTable = {
            {s = "reloads/pistols.wav", t = 1 / 30}, --s sound file
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_dual_dt12.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[P] Dual DT-12"
SWEP.Trivia_Class = "Galactic Dual Blaster Pistol"
SWEP.Trivia_Desc = "A Dual Blaster pistol for shooting enviroments"
SWEP.Trivia_Manufacturer = "Forged Armory"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel = "models/arccw/weapons/synbf3/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 90
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_dual_dt12.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 90
SWEP.DamageMin = 17
SWEP.Range = 300
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 0.6
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 460 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/dpst.wav"
SWEP.MuzzleFlashColor = Color(250, 0, 0, 50)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = ""
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)
SWEP.DrawCrosshair = true

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"dt12", "dt12+"}

SWEP.AttachmentElements = {
    ["dt12"] = {
        VMElements = {
            {
                Model = "models/arccw/hauptmann/star wars/weapons/ddt12.mdl",
                Bone = "LeftHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(6, -3.5, -0.7),
                    ang = Angle(-10, 0, 90)
                }
            }
        },
    },
    ["dt12+"] = {
         VMElements = {
            {
                Model = "models/arccw/hauptmann/star wars/weapons/ddt12.mdl",
                Bone = "RightHand_1stP",
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-5, 3, 1.2),
                    ang = Angle(170, 0, -90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/arccw/hauptmann/star wars/weapons/ddt12.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(60, 15, 40),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/arccw/hauptmann/star wars/weapons/ddt12.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-50, 230, -10),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/arccw/hauptmann/star wars/weapons/ddt12.mdl"

--SWEP.Attachments 
SWEP.Attachments = {
--    [1] = {
--        PrintName = "Tactical", -- print name
--        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
--        Slot = {"tactical","tac_pistol"},
--        VMScale = Vector(0.8, 0.8, 0.8),
--        Bone = "RightHand_1stP", -- relevant bone any attachments will be mostly referring to
--        Offset = {
--            vpos = Vector(-8, -3.7, 1.3),
 --           vang = Angle(170, 0, 0),
--        },
--    },    
    [2] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"shoot_lw", "shoot_rw"},
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        Time = 3.35,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_shock_grenade.lua:
SWEP.Base = "arccw_grenade_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "Shock Grenade"
SWEP.Trivia_Class = "Hand Grenade"
SWEP.Trivia_Desc = "Standard Shock ordnance with a timed fuse and a small-medium blast radius."

SWEP.Slot = 4

SWEP.CamAttachment = 3

SWEP.NotForNPCs = true

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/nade_frag.mdl"
SWEP.WorldModel = "models/weapons/w_nade_frag.mdl"
SWEP.HideViewmodel = true
SWEP.MirrorVMWM = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    scale = 0.09
}

SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "fcg.nade",
    },
}

SWEP.IconOverride = "materials/entities/stun_grenade_meeks.png"

SWEP.FuseTime = 2.1

SWEP.Primary.Ammo = "grenade"

SWEP.Primary.ClipSize = 1

SWEP.MuzzleVelocity = 1300
SWEP.MuzzleVelocityAlt = 500
SWEP.ShootEntity = "arccw_thr_ion"

SWEP.PullPinTime = 0.5

SWEP.ViewModelFOV = 70

SWEP.DefaultElements = {"shock_grenade"}

SWEP.AttachmentElements = {
    ["shock_grenade"] = {
        VMElements = {
            {
                Model = "models/arccw/shock_grenade.mdl",
                Bone = "def_c_base",
                Scale = Vector(0.8, 0.8, 0.8),
                Offset = {
                    pos = Vector(-.5, -0.1, -.1),
                    ang = Angle(-35, -190, 90)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/shock_grenade.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.8, 0.8, 0.8),
                Offset = {
                    pos = Vector(35, 25, 0),
                    ang = Angle(0, 0, 0)
                }
            }
        },
    },
}

WMOverride = "models/arccw/shock_grenade.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {Source = "sprint", Mult = 0.9},
    ["enter_sprint"] = {Source = "sprint_in", Mult = 0.1},
    ["exit_sprint"] = {Source = "sprint_out", Mult = 0.1},
    ["ready"] = {
        Source = "draw",
        SoundTable = {
           {s = "ArcCW_ThermalDet.firstdeploy1", t = 0 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = "misc/gunfoley_blaster_sheathe_var_03.mp3", t = 0 / 30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = "ArcCW_ThermalDet.holster1", t = 0 / 30}
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_primer.button", t = 0 / 30},
        },
        MinProgress = 0.5,
    },
    ["fire"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_primer.button", t = 0 / 30},
        },
    },
    ["throw"] = {
        Source = {"toss_overhead"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
    },
    ["throw_alt"] = {
        Source = {"underhand"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
    },
    ["enter_inspect"] = {
        Source = "inspect_in",
        LHIK = true,
    },
    ["exit_inspect"] = {
        Source = "inspect_out",
        LHIK = true,
    },
    ["idle_inspect"] = {
        Source = "inspect",
        LHIK = true,
    },

sound.Add({
    name =          "ArcCW_ThermalDet.holster1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/sw01_characters_gunfoley_draw_blaster_var21.mp3"
    }),

sound.Add({
    name =          "ArcCW_ThermalDet.armthrow",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/shock/SW02_Weapons_Grenades_Shock_Beep_01.wav"
    }),

sound.Add({
    name =          "ArcCW_ThermalDet.deploy1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/gunfoley_blaster_sheathe_var_03.mp3"
    }),
       
sound.Add({
    name =          "ArcCW_ThermalDet.firstdeploy1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/sw01_characters_gunfoley_draw_blaster_var19.mp3"
    }),
        
sound.Add({
    name =          "ArcCW_primer.button",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/buttonpress.mp3"
    }),

sound.Add({
    name =          "ArcCW_Underhand.explosion2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/underhand.mp3"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_smoke_grenade.lua:
SWEP.Base = "arccw_grenade_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "Smoke Grenade"
SWEP.Trivia_Class = "Hand Grenade"
SWEP.Trivia_Desc = "Standard explosive ordnance with a timed fuse and a large blast radius."

SWEP.Slot = 4

SWEP.CamAttachment = 3

SWEP.NotForNPCs = true

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/nade_frag.mdl"
SWEP.WorldModel = "models/weapons/w_nade_frag.mdl"
SWEP.HideViewmodel = true
SWEP.MirrorVMWM = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/smoke_grenade_meek.png"


SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "fcg.nade",
    },
}

SWEP.FuseTime = 1.35

SWEP.Primary.Ammo = "grenade"

SWEP.Primary.ClipSize = 1

SWEP.MuzzleVelocity = 1300
SWEP.MuzzleVelocityAlt = 500
SWEP.ShootEntity = "arccw_thr_smoke"

SWEP.PullPinTime = 0.5

SWEP.ViewModelFOV = 70

SWEP.DefaultElements = {"smoke_grenade"}

SWEP.AttachmentElements = {
    ["smoke_grenade"] = {
        VMElements = {
            {
                Model = "models/weapons/tfa_starwars/w_smoke.mdl",
                Bone = "def_c_base",
                Scale = Vector(.9, .9, .9),
                Offset = {
                    pos = Vector(-0.4, -.4, 0.2),
                    ang = Angle(-180, 0, -90)
                }
            }
        },
        WMElements = {
            {
                Model = "models/weapons/tfa_starwars/w_smoke.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.8, 0.8, 0.8),
                Offset = {
                    pos = Vector(35, 25, 0),
                    ang = Angle(0, 0, 0)
                }
            }
        },
    },
}

WMOverride = "models/weapons/tfa_starwars/w_smoke.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {Source = "sprint", Mult = 0.9},
    ["enter_sprint"] = {Source = "sprint_in", Mult = 0.1},
    ["exit_sprint"] = {Source = "sprint_out", Mult = 0.1},
    ["ready"] = {
        Source = "draw",
        SoundTable = {
           {s = "ArcCW_ThermalDet.firstdeploy1", t = 0 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = "misc/gunfoley_blaster_sheathe_var_03.mp3", t = 0 / 30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = "ArcCW_ThermalDet.holster1", t = 0 / 30}
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_primer.button", t = 0 / 30},
        },
        MinProgress = 0.5,
    },
    ["fire"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_primer.button", t = 0 / 30},
        },
    },
    ["throw"] = {
        Source = {"toss_overhead"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
    },
    ["throw_alt"] = {
        Source = {"underhand"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
    },
    ["enter_inspect"] = {
        Source = "inspect_in",
        LHIK = true,
    },
    ["exit_inspect"] = {
        Source = "inspect_out",
        LHIK = true,
    },
    ["idle_inspect"] = {
        Source = "inspect",
        LHIK = true,
    },

sound.Add({
    name =          "ArcCW_ThermalDet.holster1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/sw01_characters_gunfoley_draw_blaster_var21.mp3"
    }),
    
sound.Add({
    name =          "ArcCW_ThermalDet.deploy1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/gunfoley_blaster_sheathe_var_03.mp3"
    }),
       
sound.Add({
    name =          "ArcCW_ThermalDet.firstdeploy1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/sw01_characters_gunfoley_draw_blaster_var19.mp3"
    }),
        
sound.Add({
    name =          "ArcCW_ThermalDet.explosion1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/BEEPTimer_Anticipation Beeps_02.wav"
    }),

sound.Add({
    name =          "ArcCW_primer.button",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/buttonpress.mp3"
    }),

sound.Add({
    name =          "ArcCW_Underhand.explosion2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/underhand.mp3"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_sops_dlt23v.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4 

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "DLT-23v"
SWEP.Trivia_Class = "Blaster Heavy Repeater"
SWEP.Trivia_Desc = "In need of a heavy weapon capable of destroying Rebel scum, Blastech Industries designed and created a portable destruction machine. The DLT-23v was born with a single objective: that nothing and no one who is the target remains alive."
SWEP.IconOverride = "entities/sopsmisc/dlt23v.png"

-- Viewmodel & Entity Properties
SWEP.HideViewmodel = false
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops-v2/dlt23v2.mdl"
SWEP.WorldModel = "models/arccw/kraken/sops-v2/w_dlt23v_2.mdl"
SWEP.ViewModelFOV = 58
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-12, 3, -7),
    ang = Angle(-10, 0, 200)
}

-- Jamming
SWEP.Jamming = true
SWEP.HeatGain = 1
SWEP.HeatCapacity = 75 
SWEP.HeatDissipation = 2 
SWEP.HeatLockout = true 
SWEP.HeatDelayTime = 0.5

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 26
SWEP.RangeMin = 207
SWEP.DamageMin = 22
SWEP.Range = 402
SWEP.Penetration = 2
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 150

SWEP.Recoil = 0.65
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.78
SWEP.Delay = 60 / 402

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/dlt23v/dlt23v.wav"
SWEP.ShootSound = "sops-v2/weapons/dlt23v/dlt23v.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.573, -7.072, 0),
    Ang = Angle(0, 0, 25.809),
     Magnification = 2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, 2, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)


-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.573, -7.072, 0),
    Ang = Angle(0, 0, 25.809),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "smg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 3, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5.226, -0, -1)
SWEP.SprintAng = Angle(-19, 42, -22)

SWEP.HolsterPos = Vector(8, -4.8, -3)
SWEP.HolsterAng = Angle(11.199, 38, 0)

SWEP.Bipod_Integral = true 
SWEP.BipodDispersion = 1
SWEP.BipodRecoil = 1 

-- Attachments
SWEP.Attachments = {            
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "ammo_masita", "ammo_stun"},
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = {"perk", "mw3_pro"},
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },      
}


-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = false,
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "weapons/bf3/dlt23v_reload6.wav", t = 0.1/30},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_04.mp3", t = 2},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_heavyrepeater.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "Heavy Repeater"
SWEP.Trivia_Class = "Blaster Heavy Repeater"
SWEP.Trivia_Desc = "The  Heavy Repeater was a projectile weapon used by Imperial troops. It was an improvement over the earlier Imperial repeater rifle, which was developed by Moff Rebus."
SWEP.IconOverride = "entities/sopsmisc/heavyrepeater.png"

-- Viewmodel & Entity Properties
SWEP.ViewModel = "models/arccw/masita/viewmodels/base_rifle_animations.mdl"
SWEP.WorldModel = "models/weapons/synbf3/w_t21.mdl"
SWEP.ViewModelFOV = 60
SWEP.UseHands = true
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.3,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 67
SWEP.RangeMin = 187
SWEP.DamageMin = 34
SWEP.Range = 428
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_green"
SWEP.TracerCol = Color(0, 250, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 1.27
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.56
SWEP.Delay = 60 / 205

SWEP.Num = 3
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 30
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 70
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/hvyrpeater.wav"
SWEP.ShootSound = "sops-v2/weapons/hvyrpeater.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_green"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-4.45, 0, -1.7),
    Ang = Angle(1, -0.9, -3),
     Magnification = 2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 8, -2)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/imperial_repeater.mdl",
                Bone = "E11S_CONTR",
                ModelBodygroups = "00000",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0, -6, -7),
                    ang = Angle(0, 0, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-3, 15, -6),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/imperial_repeater.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                ModelBodygroups = "00000",
                Offset = {
                    pos = Vector(45, 20, 40),
                    ang = Angle(-15, -90, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(200, 15, -100),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/imperial_repeater.mdl"


SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.95, -2, 4.5),
            vang = Angle(0, -90, 0),
            wpos = Vector(74, 9, -100),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR", 
        Offset = {
            vpos = Vector(0.6, 9, 1.7),
            vang = Angle(25, -90, 90),
            wpos = Vector(170, 23, -100),
            wang = Angle(-15, 0, -70)
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.95, 3, -1.4),
            vang = Angle(0, -90, 0),
            wpos = Vector(140, 9, -52),
            wang = Angle(-15, 0, 180)
        },          
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},   
    },    
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(11, 11, 11),
        Offset = {
            vpos = Vector(1.4, -5.9, 0.8),
            vang = Angle(20, -90, 0),
            wpos = Vector(20, 34, -45),
            wang = Angle(-15, 0, 200)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        VMScale = Vector(1, 1, 1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(1.1, 1.5, 1 ),
            vang = Angle(20, -90, 0),
            wpos = Vector(110, 24, -90),
            wang = Angle(-15, 0, 200)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_hh12.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 5

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "Wrecker's HH-12"
SWEP.Trivia_Class = "Rocket Launcher"
SWEP.Trivia_Desc = "The HH-12 rocket launcher was a model of black-colored missile launcher used by the Special Forces of the Alliance to Restore the Republic during the Galactic Civil War against the Galactic Empire. In the year 0 BBY, the Rogue One special forces unit brought HH-12s with them on their mission to steal the plans for the Empire's Death Star superweapon from the Citadel Tower on the planet Scarif. The former Guardians of the Whills, Baze Malbus, appropriated one of the launchers to use on an All Terrain Armored Cargo Transport attacking Alliance forces, but the weapon was not strong enough to penetrate the walker's armor."
SWEP.IconOverride = "entities/sopsmisc/hh12.png"

-- Viewmodel & Entity Properties
SWEP.ViewModel = "models/weapons/c_rpg.mdl"
SWEP.WorldModel = "models/weapons/w_pistol.mdl"
SWEP.ViewModelFOV = 55
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

-- Grenade Launcher properties
SWEP.ShootEntity = "rocket_imp"
SWEP.MuzzleVelocity = 12000

-- Damage & Tracer
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 1
SWEP.ExtendedClipSize = 1
SWEP.ReducedClipSize = 1

SWEP.Recoil = 2.21
SWEP.RecoilSide = 0.175
SWEP.RecoilRise = 2.3

SWEP.Delay = 60 / 102
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
        PrintName = "ROCKET",
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 125 
SWEP.Primary.Ammo = "RPG_Round"

-- Speed Mult
SWEP.SpeedMult = 0.7
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.3

-- Ammo, Sounds & MuzzleEffect
SWEP.ShootVol = 130
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.2
SWEP.ShootSound = "sops-v2/weapons/hh12.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_green"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(85, 255, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-11, -12, 3.5),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 60,
}

-- Holdtype
SWEP.HoldtypeHolstered = "rpg"
SWEP.HoldtypeActive = "rpg"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_RPG

SWEP.ActivePos = Vector(-7, -12, 4)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5.226, -2, 0)
SWEP.SprintAng = Angle(-18, 36, -13.5)

SWEP.CustomizePos = Vector(8, -4.8, -3)
SWEP.CustomizeAng = Angle(11.199, 38, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"hh12", "muzzle"}
SWEP.AttachmentElements = {
    ["hh12"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/hh12.mdl",
                Bone = "base",
                Scale = Vector(0.9, 0.9, 0.9),
                Offset = {
                    pos = Vector(0.6, 2, 8),
                    ang = Angle(-90, -180, 90),
                }
            }
        }
    },
    ["muzzle"] = {
         VMElements = {
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "base",
                Scale = Vector(0, 0, 0),                
                Offset = {
                    pos = Vector(-3, 0, 13),
                    ang = Angle(90, 0, 0)
                },
                IsMuzzleDevice = true
            }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/hh12.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.9, 0.9, 0.9),
                Offset = {
                    pos = Vector(350, 200, -800),
                    ang = Angle(0, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(2000, 0, -650),
                    ang = Angle(0, 0, 180)
                },
                IsMuzzleDevice = true
            },            
        },
    }
}

SWEP.Attachments = {      
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(111, 111, 111),
        Bone = "base", 
        Offset = {
            vpos = Vector(3.5, 1.5, 16),
            vang = Angle(90, 0, 0),
            wpos = Vector(600, 550, -820),
            wang = Angle(0, 0, -90)
        },
    },   
    {
        PrintName = "Ammunition", 
        DefaultAttName = "None",
        Slot = {"ammo_rocket"},
    },         
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = {"perk", "mw3_pro"},
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "base",
        Offset = {
            vpos = Vector(3.6, 0, 2.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(200, 535, -820),
            wang = Angle(0, 0, 180)
        },
    }, 
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle1"
    },
    ["fire"] = {
        Source = "fire",
    },
    ["fire_iron"] = {
        Source = "fire",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        Time = 3.4, 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_manualcooling_var_02.mp3", t = 0.1/30},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_04.mp3", t = 70/30},
        },
    },
}
--lua/weapons/ghost_mace/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = "Ghost mace"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Ghost"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, Special +speed"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "melee"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-23.519, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(50, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-8.334, 3.888, 5.741), angle = Angle(10, 0, 0) },
	["v_weapon.Knife_Handle"] = { scale = Vector(0.37, 0.37, 0.37), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 160), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 160), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.4), color = Color(255, 255, 255, 160), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 160), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/roller.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(0, 90, 0), size = Vector(0.159, 0.159, 0.159), color = Color(255, 255, 255, 160), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 160), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 160), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.4), color = Color(255, 255, 255, 160), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(170, 50, 8), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 160), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/roller.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 22.337), angle = Angle(0, 90, 0), size = Vector(0.23, 0.23, 0.23), color = Color(255, 255, 255, 160), surpresslightning = false, material = "phoenix_storms/concrete0", skin = 0, bodygroup = {} }
}



SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 40
SWEP.Primary.DelayMiss	 = 1.2
SWEP.Primary.DelayHit 	 = 0.98
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "Impact.Glass"
SWEP.Primary.Range       = 12

SWEP.Secondary.Life        = false
SWEP.Secondary.Damage 	   = 70
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0
SWEP.SetRunSpeed=505

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
self.Owner:SetRunSpeed(self.SetRunSpeed)
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Owner:SetRunSpeed(self.SetRunSpeed+50)
		self.SetRunSpeed=self.SetRunSpeed +5
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/tools_advdupe/lua/weapons/gmod_tool/stools/advdupe2.lua:
--[[
	Title: Adv. Dupe 2 Tool

	Desc: Defines the AD2 tool and assorted functionalities.

	Author: TB

	Version: 1.0
]]


TOOL.Category = "Construction"
TOOL.Name = "#Tool.advdupe2.name"
cleanup.Register( "AdvDupe2" )
require( "controlpanel" )

if(SERVER) then
	CreateConVar("sbox_maxgmod_contr_spawners",5)

	local phys_constraint_system_types = {
		Weld          = true,
		Rope          = true,
		Elastic       = true,
		Slider        = true,
		Axis          = true,
		AdvBallsocket = true,
		Motor         = true,
		Pulley        = true,
		Ballsocket    = true,
		Winch         = true,
		Hydraulic     = true,
		WireMotor     = true,
		WireHydraulic = true
	}
	--Orders constraints so that the dupe uses as little constraint systems as possible
	local function GroupConstraintOrder( ply, constraints )
		--First separate the nocollides, sorted, and unsorted constraints
		local sorted, unsorted = {}, {}
		for k, v in pairs(constraints) do
			if phys_constraint_system_types[v.Type] then
				sorted[#sorted+1] = v
			else
				unsorted[#unsorted+1] = v
			end
		end

		local sortingSystems = {}
		local fullSystems = {}
		local function buildSystems(input)
			while next(input) ~= nil do
				for k, v in pairs(input) do
					for systemi, system in pairs(sortingSystems) do
						for _, target in pairs(system) do
							for x = 1, 4 do
								if v.Entity[x] then
									for y = 1, 4 do
										if target.Entity[y] and v.Entity[x].Index == target.Entity[y].Index then
											system[#system + 1] = v
											if #system == 100 then
												fullSystems[#fullSystems + 1] = system
												table.remove(sortingSystems, systemi)
											end
											input[k] = nil
											goto super_loopbreak
										end
									end
								end
							end
						end
					end
				end

				--Normally skipped by the goto unless no cluster is found. If so, make a new one.
				local k = next(input)
				sortingSystems[#sortingSystems + 1] = {input[k]}
				input[k] = nil

				::super_loopbreak::
			end
		end
		buildSystems(sorted)

		local ret = {}
		for _, system in pairs(fullSystems) do
			for _, v in pairs(system) do
				ret[#ret + 1] = v
			end
		end
		for _, system in pairs(sortingSystems) do
			for _, v in pairs(system) do
				ret[#ret + 1] = v
			end
		end
		for k, v in pairs(unsorted) do
			ret[#ret + 1] = v
		end

		if #fullSystems ~= 0 then
			ply:ChatPrint("DUPLICATOR: WARNING, Number of constraints exceeds 100: (".. #ret .."). Constraint sorting might not work as expected.")
		end

		return ret
	end

	local function CreationConstraintOrder( constraints )
		local ret = {}
		for k, v in pairs( constraints ) do
			ret[#ret + 1] = k
		end
		table.sort(ret)
		for i = 1, #ret do
			ret[i] = constraints[ret[i]]
		end
		return ret
	end

	local function GetSortedConstraints( ply, constraints )
		if ply:GetInfo("advdupe2_sort_constraints") ~= "0" then
			return GroupConstraintOrder( ply, constraints )
		else
			return CreationConstraintOrder( constraints )
		end
	end

	local areacopy_classblacklist = {
		gmod_anchor = true
	}

	local function PlayerCanDupeCPPI(ply, ent)
		if not AdvDupe2.duplicator.IsCopyable(ent) or areacopy_classblacklist[ent:GetClass()] then return false end
		return ent:CPPIGetOwner()==ply
	end

	-- Code from WireLib.CanTool
	local zero = Vector(0, 0, 0)
	local norm = Vector(1, 0, 0)

	local tr = { ---@type TraceResult
		Hit = true, HitNonWorld = true, HitNoDraw = false, HitSky = false, AllSolid = true,
		HitNormal = zero, Normal = norm,

		Fraction = 1, FractionLeftSolid = 0,
		HitBox = 0, HitGroup = 0, HitTexture = "**studio**",
		MatType = 0, PhysicsBone = 0, SurfaceProps = 0, DispFlags = 0, Contents = 0,

		Entity = NULL, HitPos = zero, StartPos = zero,
	}

	local function PlayerCanDupeTool(ply, ent)
		if not AdvDupe2.duplicator.IsCopyable(ent) or areacopy_classblacklist[ent:GetClass()] then return false end

		local pos = ent:GetPos()
		tr.Entity, tr.HitPos, tr.StartPos = ent, pos, pos

		return hook.Run( "CanTool", ply, tr, "advdupe2" ) ~= false
	end

	--Find all the entities in a box, given the adjacent corners and the player
	local function FindInBox(min, max, ply)
		local PPCheck = (tobool(ply:GetInfo("advdupe2_copy_only_mine")) and ply.CPPIGetOwner~=nil) and PlayerCanDupeCPPI or PlayerCanDupeTool
		local EntTable = {}
		for _, ent in ents.Iterator() do
			local pos = ent:GetPos()
			if (pos.X>=min.X) and (pos.X<=max.X) and
				 (pos.Y>=min.Y) and (pos.Y<=max.Y) and
				 (pos.Z>=min.Z) and (pos.Z<=max.Z) and PPCheck( ply, ent ) then
				EntTable[ent:EntIndex()] = ent
			end
		end

		return EntTable
	end

	--[[
		Name: GetDupeAngleOffset
		Desc: Retrieves duplication angle offsets from player
		Returns: <angle> Created angle
	]]
	local function GetDupeAngleOffset(ply)
		local p = math.Clamp(ply:GetInfoNum("advdupe2_offset_pitch", 0), -180, 180)
		local y = math.Clamp(ply:GetInfoNum("advdupe2_offset_yaw"  , 0), -180, 180)
		local r = math.Clamp(ply:GetInfoNum("advdupe2_offset_roll" , 0), -180, 180)
		return Angle(p, y, r)
	end

	--[[
		Name: GetDupeElevation
		Desc: Retrieves duplication Z elevation
		Returns: <number> Dupe elevation
	]]
	local function GetDupeElevation(ply)
		local con = ply:GetInfoNum("advdupe2_offset_z", 0)
		local enz = (tonumber(ply.AdvDupe2.HeadEnt.Z) or 0)
		return math.Clamp(con + enz, -32000, 32000)
	end

	--[[
		Name: LeftClick
		Desc: Defines the tool's behavior when the player left-clicks.
		Params: <trace> trace
		Returns: <boolean> success
	]]
	local messages = {
		["Pasting"] = "pasting.",
		["Downloading"] = "downloading.",
		["Uploading"] = "uploading."
	}
	function TOOL:LeftClick( trace )
		if(not trace) then return false end

		local ply = self:GetOwner()
		local dupe = ply.AdvDupe2

		if not (dupe and dupe.Entities) then return false end

		for key, msg in pairs(messages) do
			if dupe[key] then
				AdvDupe2.Notify(ply, "Advanced Duplicator 2 is busy " .. msg, NOTIFY_ERROR)
				return false
			end
		end

		dupe.Angle = GetDupeAngleOffset(ply)
		dupe.Position = Vector(trace.HitPos)
		dupe.Position.z = dupe.Position.z + GetDupeElevation(ply)

		if(tobool(ply:GetInfo("advdupe2_offset_world"))) then
			dupe.Angle = dupe.Angle - dupe.Entities[dupe.HeadEnt.Index].PhysicsObjects[0].Angle
		end

		dupe.Pasting = true
		AdvDupe2.Notify(ply,"Pasting...")
		local origin
		if(tobool(ply:GetInfo("advdupe2_original_origin"))) then
			origin = dupe.HeadEnt.Pos
		end

		AdvDupe2.InitPastingQueue(ply, dupe.Position, dupe.Angle, origin,
			tobool(ply:GetInfo("advdupe2_paste_constraints")),
			tobool(ply:GetInfo("advdupe2_paste_parents")),
			tobool(ply:GetInfo("advdupe2_paste_disparents")),
			tobool(ply:GetInfo("advdupe2_paste_protectoveride")))

		return true
	end

	--[[
		Name: RightClick
		Desc: Defines the tool's behavior when the player right-clicks.
		Params: <trace> trace
		Returns: <boolean> success
	]]
	function TOOL:RightClick( trace )
		local ply = self:GetOwner()
		local dupe = ply.AdvDupe2

		if not dupe then dupe = {}; ply.AdvDupe2 = dupe end

		if(dupe.Pasting or dupe.Downloading) then
			AdvDupe2.Notify(ply,"Advanced Duplicator 2 is busy.", NOTIFY_ERROR)
			return false
		end

		--Set Area Copy on or off
		if( ply:KeyDown(IN_SPEED) and not ply:KeyDown(IN_WALK) ) then
			if(self:GetStage()==0) then
				AdvDupe2.DrawSelectBox(ply)
				self:SetStage(1)
				return false
			elseif(self:GetStage()==1) then
				AdvDupe2.RemoveSelectBox(ply)
				self:SetStage(0)
				return false
			end
		end

		if(not trace or not trace.Hit) then return false end

		local Entities, Constraints, AddOne
		local HeadEnt = {}
		--If area copy is on
		if(self:GetStage()==1) then
			local area_size = math.Clamp(tonumber(ply:GetInfo("advdupe2_area_copy_size")) or 50, 0, 30720)
			local Pos = trace.HitNonWorld and trace.Entity:GetPos() or trace.HitPos
			local T = (Vector(area_size,area_size,area_size)+Pos)
			local B = (Vector(-area_size,-area_size,-area_size)+Pos)

			local Ents = FindInBox(B,T, ply)
			local _, Ent = next(Ents)
			if not Ent then
				self:SetStage(0)
				AdvDupe2.RemoveSelectBox(ply)
				return true
			end

			Ent = trace.HitNonWorld and trace.Entity or Ent
			HeadEnt.Index = Ent:EntIndex()
			HeadEnt.Pos = Ent:GetPos()

			Entities, Constraints = AdvDupe2.duplicator.AreaCopy(ply, Ents, HeadEnt.Pos, tobool(ply:GetInfo("advdupe2_copy_outside")))

			self:SetStage(0)
			AdvDupe2.RemoveSelectBox(ply)
		elseif trace.HitNonWorld then	--Area Copy is off
			-- Filter duplicator blocked entities out.
			if not AdvDupe2.duplicator.IsCopyable( trace.Entity ) then
				return false
			end

			--If Alt is being held, add a prop to the dupe
			if(ply:KeyDown(IN_WALK) and dupe.Entities~=nil and next(dupe.Entities)~=nil) then
				Entities = dupe.Entities
				Constraints = dupe.Constraints
				HeadEnt = dupe.HeadEnt

				AdvDupe2.duplicator.Copy( ply, trace.Entity, Entities, Constraints, HeadEnt.Pos)

				--Only add the one ghost
				AddOne = Entities[trace.Entity:EntIndex()]
			else
				Entities = {}
				Constraints = {}
				HeadEnt.Index = trace.Entity:EntIndex()
				HeadEnt.Pos = trace.HitPos

				AdvDupe2.duplicator.Copy( ply, trace.Entity, Entities, Constraints, trace.HitPos )
			end
		else --Non valid entity or clicked the world
			if dupe.Entities then
				--clear the dupe
				net.Start("AdvDupe2_RemoveGhosts")
				net.Send(ply)
				dupe.Entities = nil
				dupe.Constraints = nil
				net.Start("AdvDupe2_ResetDupeInfo")
				net.Send(ply)
				AdvDupe2.ResetOffsets(ply)
				return true
			else
				--select all owned props
				Entities = {}
				local PPCheck = (tobool(ply:GetInfo("advdupe2_copy_only_mine")) and CPPI~=nil) and PlayerCanDupeCPPI or PlayerCanDupeTool
				for _, ent in ents.Iterator() do
					if PPCheck( ply, ent ) then
						Entities[ent:EntIndex()] = ent
					end
				end

				local _, Ent = next(Entities)
				if not Ent then
				net.Start("AdvDupe2_RemoveGhosts")
				net.Send(ply)
					return true
				end

				HeadEnt.Index = Ent:EntIndex()
				HeadEnt.Pos = Ent:GetPos()

				Entities, Constraints = AdvDupe2.duplicator.AreaCopy(ply, Entities, HeadEnt.Pos, tobool(ply:GetInfo("advdupe2_copy_outside")))
			end
		end

		if not HeadEnt.Z then
			local WorldTrace = util.TraceLine({
				mask   = MASK_NPCWORLDSTATIC,
				start  = HeadEnt.Pos + Vector(0,0,1),
				endpos = HeadEnt.Pos-Vector(0,0,50000)
			})

			HeadEnt.Z = WorldTrace.Hit and math.abs(HeadEnt.Pos.Z - WorldTrace.HitPos.Z) or 0
		end

		dupe.HeadEnt = HeadEnt
		dupe.Entities = Entities
		dupe.Constraints = GetSortedConstraints(ply, Constraints)
		dupe.Revision = AdvDupe2.CodecRevision

		net.Start("AdvDupe2_SetDupeInfo")
			net.WriteString("")
			net.WriteString(ply:Nick())
			net.WriteString(os.date("%d %B %Y"))
			net.WriteString(os.date("%I:%M %p"))
			net.WriteString("")
			net.WriteString("")
			net.WriteString(table.Count(dupe.Entities))
			net.WriteString(#dupe.Constraints)
		net.Send(ply)

		if AddOne then
			AdvDupe2.SendGhost(ply, AddOne)
		else
			AdvDupe2.SendGhosts(ply)
		end

		AdvDupe2.ResetOffsets(ply)

		return true
	end

	--Checks table, re-draws loading bar, and recreates ghosts when tool is pulled out
	function TOOL:Deploy()
		local ply = self:GetOwner()
		local dupe = ply.AdvDupe2

		if not dupe then dupe = {}; ply.AdvDupe2 = dupe end

		if(not dupe.Entities) then return end

		net.Start("AdvDupe2_StartGhosting")
		net.Send(ply)

		if(dupe.Queued) then
			AdvDupe2.InitProgressBar(ply, "Queued: ")
			return
		end

		if(dupe.Pasting) then
			AdvDupe2.InitProgressBar(ply, "Pasting: ")
			return
		else
			if(dupe.Uploading) then
				AdvDupe2.InitProgressBar(ply, "Uploading: ")
				return
			elseif(dupe.Downloading) then
				AdvDupe2.InitProgressBar(ply, "Saving: ")
				return
			end
		end

	end

	--Removes progress bar
	function TOOL:Holster()
		AdvDupe2.RemoveProgressBar(self:GetOwner())
	end

	--[[
		Name: Reload
		Desc: Creates an Advance Contraption Spawner.
		Params: <trace> trace
		Returns: <boolean> success
	]]
	function TOOL:Reload( trace )
		if(not trace.Hit) then return false end

		local ply = self:GetOwner()
		local dupe = ply.AdvDupe2

		if not dupe then dupe = {}; ply.AdvDupe2 = dupe end

		if(self:GetStage()==1) then
			local areasize = math.Clamp(tonumber(ply:GetInfo("advdupe2_area_copy_size")) or 50, 0, 30720)
			net.Start("AdvDupe2_CanAutoSave")
				net.WriteVector(trace.HitPos)
				net.WriteFloat(areasize)
				if(trace.Entity) then
					net.WriteUInt(trace.Entity:EntIndex(), 16)
				else
					net.WriteUInt(0, 16)
				end
			net.Send(ply)
			self:SetStage(0)
			AdvDupe2.RemoveSelectBox(ply)
			dupe.TempAutoSavePos = trace.HitPos
			dupe.TempAutoSaveSize = areasize
			dupe.TempAutoSaveOutSide = tobool(ply:GetInfo("advdupe2_copy_outside"))
			return true
		end

		--If a contraption spawner was clicked then update it with the current settings
		if(trace.Entity:GetClass()=="gmod_contr_spawner") then
			local delay = tonumber(ply:GetInfo("advdupe2_contr_spawner_delay"))
			local undo_delay = tonumber(ply:GetInfo("advdupe2_contr_spawner_undo_delay"))
			local min
			local max
			if(not delay) then
				delay = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
			else
				if(not game.SinglePlayer()) then
					min = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
					if (delay < min) then
						delay = min
					end
				elseif(delay<0) then
					delay = 0
				end
			end

			if(not undo_delay) then
				undo_delay = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay"))
			else
				if(not game.SinglePlayer()) then
					min = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay")) or 0.1
					max = tonumber(GetConVarString("AdvDupe2_MaxContraptionUndoDelay")) or 60
					if(undo_delay < min) then
						undo_delay = min
					elseif(undo_delay > max) then
						undo_delay = max
					end
				elseif(undo_delay < 0) then
					undo_delay = 0
				end
			end

			trace.Entity:GetTable():SetOptions(
				ply, delay, undo_delay,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_key")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_undo_key")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_disgrav")) or 0,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_disdrag")) or 0,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_addvel")) or 1 )

			return true
		end

		--Create a contraption spawner
		if dupe and dupe.Entities then
			local headent = dupe.Entities[dupe.HeadEnt.Index]
			local Pos, Ang

			if(headent) then
				if(tobool(ply:GetInfo("advdupe2_original_origin"))) then
					Pos = dupe.HeadEnt.Pos + headent.PhysicsObjects[0].Pos
					Ang = headent.PhysicsObjects[0].Angle
				else
					local EntAngle = headent.PhysicsObjects[0].Angle
					if(tobool(ply:GetInfo("advdupe2_offset_world"))) then EntAngle = Angle(0,0,0) end
					trace.HitPos.Z = trace.HitPos.Z + GetDupeElevation(ply)
					Pos, Ang = LocalToWorld(headent.PhysicsObjects[0].Pos, EntAngle, trace.HitPos, GetDupeAngleOffset(ply))
				end
			else
				AdvDupe2.Notify(ply, "Invalid head entity to spawn contraption spawner.")
				return false
			end

			if(headent.Class=="gmod_contr_spawner") then
				AdvDupe2.Notify(ply, "Cannot make a contraption spawner from a contraption spawner.")
				return false
			end


			local spawner = MakeContraptionSpawner(
				ply, Pos, Ang, dupe.HeadEnt.Index,
				table.Copy(dupe.Entities),
				table.Copy(dupe.Constraints),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_delay")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_undo_delay")), headent.Model,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_key")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_undo_key")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_disgrav")) or 0,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_disdrag")) or 0,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_addvel")) or 1,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_hideprops")) or 0)

			ply:AddCleanup( "AdvDupe2", spawner )
			undo.Create("gmod_contr_spawner")
				undo.AddEntity( spawner )
				undo.SetPlayer( ply )
			undo.Finish()

			return true
		end
	end

	--Called to clean up the tool when pasting is finished or undo during pasting
	function AdvDupe2.FinishPasting(Player, Paste)
		Player.AdvDupe2.Pasting=false
		AdvDupe2.RemoveProgressBar(Player)
		if(Paste) then AdvDupe2.Notify(Player,"Finished Pasting!") end
	end

	--function for creating a contraption spawner
	function MakeContraptionSpawner( ply, Pos, Ang, HeadEnt, EntityTable, ConstraintTable, delay, undo_delay, model, key, undo_key, disgrav, disdrag, addvel, hideprops)

		if not ply:CheckLimit("gmod_contr_spawners") then return nil end

		if(not game.SinglePlayer()) then
			if(table.Count(EntityTable)>tonumber(GetConVarString("AdvDupe2_MaxContraptionEntities"))) then
				AdvDupe2.Notify(ply,"Contraption Spawner exceeds the maximum amount of "..GetConVarString("AdvDupe2_MaxContraptionEntities").." entities for a spawner!",NOTIFY_ERROR)
				return false
			end
			if(#ConstraintTable>tonumber(GetConVarString("AdvDupe2_MaxContraptionConstraints"))) then
				AdvDupe2.Notify(ply,"Contraption Spawner exceeds the maximum amount of "..GetConVarString("AdvDupe2_MaxContraptionConstraints").." constraints for a spawner!",NOTIFY_ERROR)
				return false
			end
		end

		local spawner = ents.Create("gmod_contr_spawner")
		if not IsValid(spawner) then return end

		spawner:SetPos(Pos)
		spawner:SetAngles(Ang)
		spawner:SetModel(model)
		spawner:SetRenderMode(RENDERMODE_TRANSALPHA)
		spawner:SetCreator(ply)
		spawner:Spawn()

		duplicator.ApplyEntityModifiers(ply, spawner)

		if IsValid(spawner:GetPhysicsObject()) then
			spawner:GetPhysicsObject():EnableMotion(false)
		end

		local min
		local max
		if(not delay) then
			delay = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
		else
			if(not game.SinglePlayer()) then
				min = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
				if (delay < min) then
					delay = min
				end
			elseif(delay<0) then
				delay = 0
			end
		end

		if(not undo_delay) then
			undo_delay = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay"))
		else
			if(not game.SinglePlayer()) then
				min = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay")) or 0.1
				max = tonumber(GetConVarString("AdvDupe2_MaxContraptionUndoDelay")) or 60
				if(undo_delay < min) then
					undo_delay = min
				elseif(undo_delay > max) then
					undo_delay = max
				end
			elseif(undo_delay < 0) then
				undo_delay = 0
			end
		end

		-- Set options
		spawner:SetPlayer(ply)
		spawner:GetTable():SetOptions(ply, delay, undo_delay, key, undo_key, disgrav, disdrag, addvel, hideprops)

		local tbl = {
			ply        = ply,
			delay      = delay,
			undo_delay = undo_delay,
			disgrav    = disgrav,
			disdrag    = disdrag,
			addvel     = addvel,
			hideprops  = hideprops
		}
		table.Merge(spawner:GetTable(), tbl)
		spawner:SetDupeInfo(HeadEnt, EntityTable, ConstraintTable)
		spawner:AddGhosts(ply)

		ply:AddCount("gmod_contr_spawners", spawner)
		ply:AddCleanup("gmod_contr_spawner", spawner)
		return spawner
	end

	duplicator.RegisterEntityClass("gmod_contr_spawner", MakeContraptionSpawner,
		"Pos", "Ang", "HeadEnt", "EntityTable", "ConstraintTable", "delay",
		"undo_delay", "model", "key", "undo_key", "disgrav", "disdrag", "addvel", "hideprops")

	function AdvDupe2.InitProgressBar(ply,label)
		net.Start("AdvDupe2_InitProgressBar")
			net.WriteString(label)
		net.Send(ply)
	end

	function AdvDupe2.DrawSelectBox(ply)
		net.Start("AdvDupe2_DrawSelectBox")
		net.Send(ply)
	end

	function AdvDupe2.RemoveSelectBox(ply)
		net.Start("AdvDupe2_RemoveSelectBox")
		net.Send(ply)
	end

	function AdvDupe2.UpdateProgressBar(ply,percent)
		net.Start("AdvDupe2_UpdateProgressBar")
			net.WriteFloat(percent)
		net.Send(ply)
	end

	function AdvDupe2.RemoveProgressBar(ply)
		net.Start("AdvDupe2_RemoveProgressBar")
		net.Send(ply)
	end

	--Reset the offsets of height, pitch, yaw, and roll back to default
	function AdvDupe2.ResetOffsets(ply, keep)

		if(not keep) then
			ply.AdvDupe2.Name = nil
		end
		net.Start("AdvDupe2_ResetOffsets")
		net.Send(ply)
	end

	net.Receive("AdvDupe2_CanAutoSave", function(len, ply, len2)

		local desc = net.ReadString()
		local ent = net.ReadInt(16)
		local dupe = ply.AdvDupe2

		if(ent~=0) then
			dupe.AutoSaveEnt = ent
			if(ply:GetInfo("advdupe2_auto_save_contraption")=="1") then
				dupe.AutoSaveEnt = ents.GetByIndex( dupe.AutoSaveEnt )
			end
		else
			if(ply:GetInfo("advdupe2_auto_save_contraption")=="1") then
				AdvDupe2.Notify(ply, "No entity selected to auto save contraption.", NOTIFY_ERROR)
				return
			end
			dupe.AutoSaveEnt = nil
		end

		dupe.AutoSavePos = dupe.TempAutoSavePos
		dupe.AutoSaveSize = dupe.TempAutoSaveSize
		dupe.AutoSaveOutSide = dupe.TempAutoSaveOutSide
		dupe.AutoSaveContr = ply:GetInfo("advdupe2_auto_save_contraption")=="1"
		dupe.AutoSaveDesc = desc

		local time = math.Clamp(tonumber(ply:GetInfo("advdupe2_auto_save_time")) or 2, 2, 30)
		if(game.SinglePlayer()) then
			dupe.AutoSavePath = net.ReadString()
		end

		AdvDupe2.Notify(ply, "Your area will be auto saved every "..(time*60).." seconds.")
		local name = "AdvDupe2_AutoSave_"..ply:UniqueID()
		if(timer.Exists(name)) then
			timer.Adjust(name, time*60, 0)
			return
		end
		timer.Create(name, time*60, 0, function()
			if(not IsValid(ply)) then
				timer.Remove(name)
				return
			end

			local dupe = ply.AdvDupe2
			if(dupe.Downloading) then
				AdvDupe2.Notify(ply, "Skipping auto save, tool is busy.", NOTIFY_ERROR)
				return
			end

			local Tab = {Entities={}, Constraints={}, HeadEnt={}}

			if(dupe.AutoSaveContr) then
				if(not IsValid(dupe.AutoSaveEnt)) then
					timer.Remove(name)
					AdvDupe2.Notify(ply, "Head entity for auto save no longer valid; stopping auto save.", NOTIFY_ERROR)
					return
				end

				Tab.HeadEnt.Index = dupe.AutoSaveEnt:EntIndex()
				Tab.HeadEnt.Pos = dupe.AutoSaveEnt:GetPos()

				local WorldTrace = util.TraceLine({
					mask   = MASK_NPCWORLDSTATIC,
					start  = Tab.HeadEnt.Pos + Vector(0,0,1),
					endpos = Tab.HeadEnt.Pos - Vector(0,0,50000)
				})

				Tab.HeadEnt.Z = WorldTrace.Hit and math.abs(Tab.HeadEnt.Pos.Z - WorldTrace.HitPos.Z) or 0
				AdvDupe2.duplicator.Copy( ply, dupe.AutoSaveEnt, Tab.Entities, Tab.Constraints, Tab.HeadEnt.Pos )
			else
				local i = dupe.AutoSaveSize
				local Pos = dupe.AutoSavePos
				local T = Vector( i, i, i); T:Add(Pos)
				local B = Vector(-i,-i,-i); B:Add(Pos)

				local Entities = FindInBox(B,T, ply)
				local _, HeadEnt = next(Entities)
				if not HeadEnt then
					AdvDupe2.Notify(ply, "Area Auto Save copied 0 entities; be sure to turn it off.", NOTIFY_ERROR)
					return
				end

				if(dupe.AutoSaveEnt and Entities[dupe.AutoSaveEnt]) then
					Tab.HeadEnt.Index = dupe.AutoSaveEnt
				else
					Tab.HeadEnt.Index = HeadEnt:EntIndex()
				end
				Tab.HeadEnt.Pos = HeadEnt:GetPos()

				local WorldTrace = util.TraceLine({
					mask   = MASK_NPCWORLDSTATIC,
					start  = Tab.HeadEnt.Pos + Vector(0,0,1),
					endpos = Tab.HeadEnt.Pos - Vector(0,0,50000)
				})

				Tab.HeadEnt.Z = WorldTrace.Hit and math.abs(Tab.HeadEnt.Pos.Z - WorldTrace.HitPos.Z) or 0
				Tab.Entities, Tab.Constraints = AdvDupe2.duplicator.AreaCopy(ply, Entities, Tab.HeadEnt.Pos, dupe.AutoSaveOutSide)
			end
			Tab.Constraints = GetSortedConstraints(ply, Tab.Constraints)
			Tab.Description = dupe.AutoSaveDesc

			AdvDupe2.Encode( Tab, AdvDupe2.GenerateDupeStamp(ply), function(data)
				AdvDupe2.SendToClient(ply, data, 1)
			end)
			dupe.FileMod = CurTime()+tonumber(GetConVarString("AdvDupe2_FileModificationDelay"))
		end)
		timer.Start(name)
	end)

	concommand.Add("AdvDupe2_SetStage", function(ply, cmd, args)
		ply:GetTool("advdupe2"):SetStage(1)
	end)

	concommand.Add("AdvDupe2_RemoveAutoSave", function(ply, cmd, args)
		timer.Remove("AdvDupe2_AutoSave_"..ply:UniqueID())
	end)

	concommand.Add("AdvDupe2_SaveMap", function(ply, cmd, args)
		if(not ply:IsAdmin()) then
			AdvDupe2.Notify(ply, "You do not have permission to this function.", NOTIFY_ERROR)
			return
		end

		local Entities = {}
		for _, v in ents.Iterator() do
			if not v:CreatedByMap() and AdvDupe2.duplicator.IsCopyable(v) then
				Entities[v:EntIndex()] = v
			end
		end

		local _, HeadEnt = next(Entities)
		if not HeadEnt then return end

		local Tab = {Entities={}, Constraints={}, HeadEnt={}, Description=""}
		Tab.HeadEnt.Index = HeadEnt:EntIndex()
		Tab.HeadEnt.Pos = HeadEnt:GetPos()

		local WorldTrace = util.TraceLine({
			mask   = MASK_NPCWORLDSTATIC,
			start  = Tab.HeadEnt.Pos + Vector(0,0,1),
			endpos = Tab.HeadEnt.Pos - Vector(0,0,50000)
		})

		Tab.HeadEnt.Z = WorldTrace.Hit and math.abs(Tab.HeadEnt.Pos.Z - WorldTrace.HitPos.Z) or 0
		Tab.Entities, Tab.Constraints = AdvDupe2.duplicator.AreaCopy(ply, Entities, Tab.HeadEnt.Pos, true)
		Tab.Constraints = GetSortedConstraints(ply, Tab.Constraints)

		Tab.Map = true
		AdvDupe2.Encode( Tab, AdvDupe2.GenerateDupeStamp(ply), function(data)
			if #data > AdvDupe2.MaxDupeSize then
				AdvDupe2.Notify(ply, "Copied duplicator filesize is too big!",NOTIFY_ERROR)
				return 
			end
			if(not file.IsDir("advdupe2_maps", "DATA")) then
				file.CreateDir("advdupe2_maps")
			end
			file.Write("advdupe2_maps/"..args[1]..".txt", data)
			AdvDupe2.Notify(ply, "Map save, saved successfully.")
		end)
	end)
end

if(CLIENT) then

	function TOOL:LeftClick(trace)
		if(trace and AdvDupe2.HeadGhost) then
			return true
		end
		return false
	end

	function TOOL:RightClick(trace)
		if( self:GetOwner():KeyDown(IN_SPEED) and not self:GetOwner():KeyDown(IN_WALK) ) then
			return false
		end
		return true
	end

	--Removes progress bar and removes ghosts when tool is put away
	function TOOL:ReleaseGhostEntity()
		AdvDupe2.RemoveGhosts()
		AdvDupe2.RemoveSelectBox()
		if(AdvDupe2.Rotation) then
			hook.Remove("PlayerBindPress", "AdvDupe2_BindPress")
			hook.Remove("CreateMove", "AdvDupe2_MouseControl")
		end
		return
	end

	function TOOL:Reload( trace )
		if(trace and (AdvDupe2.HeadGhost or self:GetStage() == 1)) then
			return true
		end
		return false
	end

	--Take control of the mouse wheel bind so the player can modify the height of the dupe
	local function MouseWheelScrolled(ply, bind, pressed)

		if(bind == "invprev") then
			if(ply:GetTool("advdupe2"):GetStage() == 1) then
				local size = math.min(tonumber(ply:GetInfo("advdupe2_area_copy_size")) + 25, 30720)
				RunConsoleCommand("advdupe2_area_copy_size",size)
			else
				local Z = tonumber(ply:GetInfo("advdupe2_offset_z")) + 5
				RunConsoleCommand("advdupe2_offset_z",Z)
			end
			return true
		elseif(bind == "invnext") then
			if(ply:GetTool("advdupe2"):GetStage() == 1) then
				local size = math.max(tonumber(ply:GetInfo("advdupe2_area_copy_size")) - 25, 25)
				RunConsoleCommand("advdupe2_area_copy_size",size)
			else
				local Z = tonumber(ply:GetInfo("advdupe2_offset_z")) - 5
				RunConsoleCommand("advdupe2_offset_z",Z)
			end
			return true
		end

		GAMEMODE:PlayerBindPress(ply, bind, pressed)
	end

	local YawTo = 0
	local BsAng = Angle()

	local function GetRotationSign(ply)
		local VY = tonumber(ply:GetInfo("advdupe2_offset_yaw")) or 0
		BsAng:Zero(); BsAng:RotateAroundAxis(BsAng:Up(), VY)
		local PR = ply:GetRight()
		local DP = BsAng:Right():Dot(PR)
		local DR = BsAng:Forward():Dot(PR)
		if(math.abs(DR) > math.abs(DP)) then -- Roll priority
			if(DR >= 0) then return -1, 1 else return  1, -1 end
		else -- Pitch axis takes priority. Normal X-Y map
			if(DP >= 0) then return  1, 1 else return -1, -1 end
		end
	end

	local function MouseControl( cmd )
		local ply = LocalPlayer()
		local X =  cmd:GetMouseX() / 20
		local Y = -cmd:GetMouseY() / 20
		local ru = ply:KeyDown(IN_SPEED)
		local mm = input.IsMouseDown(MOUSE_MIDDLE)

		if(mm) then
			if(ru) then
				YawTo = 0 -- Reset total integrated yaw
				RunConsoleCommand("advdupe2_offset_pitch", 0)
				RunConsoleCommand("advdupe2_offset_yaw"  , 0)
				RunConsoleCommand("advdupe2_offset_roll" , 0)
			else
				if(Y ~= 0) then
					local VR = tonumber(ply:GetInfo("advdupe2_offset_roll"))  or 0
					local VP = tonumber(ply:GetInfo("advdupe2_offset_pitch")) or 0
					local SP, SR, P, R = GetRotationSign(ply)
					if(SP ~= SR) then
						P = math.NormalizeAngle(VP + X * SR)
						R = math.NormalizeAngle(VR + Y * SP)
					else
						P = math.NormalizeAngle(VP + Y * SP)
						R = math.NormalizeAngle(VR + X * SR)
					end
					RunConsoleCommand("advdupe2_offset_pitch", P)
					RunConsoleCommand("advdupe2_offset_roll" , R)
				end
			end
		else
			if(X ~= 0) then
				VY = tonumber(ply:GetInfo("advdupe2_offset_yaw")) or 0
				if(ru) then
					YawTo = YawTo + X -- Integrate the mouse on the X value from the mouse
					RunConsoleCommand("advdupe2_offset_yaw", math.SnapTo(math.NormalizeAngle(YawTo), 45))
				else
					YawTo = VY + X -- Update the last yaw with the current value from the mouse
					RunConsoleCommand("advdupe2_offset_yaw", math.NormalizeAngle(YawTo))
				end
			end
		end
	end

	--Checks binds to modify dupes position and angles
	function TOOL:Think()

		if AdvDupe2.HeadGhost then
			AdvDupe2.UpdateGhosts()
		end

		if(LocalPlayer():KeyDown(IN_USE)) then
			if(not AdvDupe2.Rotation) then
				hook.Add("PlayerBindPress", "AdvDupe2_BindPress", MouseWheelScrolled)
				hook.Add("CreateMove", "AdvDupe2_MouseControl", MouseControl)
				AdvDupe2.Rotation = true
			end
		else
			if(AdvDupe2.Rotation) then
				AdvDupe2.Rotation = false
				hook.Remove("PlayerBindPress", "AdvDupe2_BindPress")
				hook.Remove("CreateMove", "AdvDupe2_MouseControl")
			end
		end
	end

	--Hinder the player from looking to modify offsets with the mouse
	function TOOL:FreezeMovement()
		return AdvDupe2.Rotation
	end

	TOOL.Information = {
		{ name = "left" },
		{ name = "right", stage = 0 },
		{ name = "right_world", stage = 0, icon2 = "gui/info" },
		{ name = "right_shift", stage = 0, icon2 = "gui/info" },
		{ name = "right_alt", stage = 1 },
		{ name = "reload_alt", stage = 1 },
		{ name = "right_shift_alt", stage = 1, icon2 = "gui/info" },
	}

	language.Add( "Tool.advdupe2.name",				"Advanced Duplicator 2" )
	language.Add( "Tool.advdupe2.desc",				"Duplicate things." )
	language.Add( "Tool.advdupe2.left",				"Paste" )
	language.Add( "Tool.advdupe2.right",			"Copy" )
	language.Add( "Tool.advdupe2.right_world",		"Hit the world to select/deselect all" )
	language.Add( "Tool.advdupe2.right_shift",		"Press Shift to area copy" )
	language.Add( "Tool.advdupe2.right_alt",		"Copy an area" )
	language.Add( "Tool.advdupe2.reload_alt",		"Autosave an area" )
	language.Add( "Tool.advdupe2.right_shift_alt",	"Press Shift to cancel" )
	language.Add( "Undone_AdvDupe2",				"Undone AdvDupe2 paste" )
	language.Add( "Cleanup_AdvDupe2",				"AdvDupe2 Duplications" )
	language.Add( "Cleaned_AdvDupe2",				"Cleaned up all AdvDupe2 Duplications" )
	language.Add( "SBoxLimit_AdvDupe2",				"You've reached the AdvDupe2 Duplicator limit!" )

	CreateClientConVar("advdupe2_offset_world", 0, false, true)
	CreateClientConVar("advdupe2_offset_z", 0, false, true)
	CreateClientConVar("advdupe2_offset_pitch", 0, false, true)
	CreateClientConVar("advdupe2_offset_yaw", 0, false, true)
	CreateClientConVar("advdupe2_offset_roll", 0, false, true)
	CreateClientConVar("advdupe2_original_origin", 0, false, true)
	CreateClientConVar("advdupe2_paste_constraints", 1, false, true)
	CreateClientConVar("advdupe2_sort_constraints", 1, true, true)
	CreateClientConVar("advdupe2_paste_parents", 1, false, true)
	CreateClientConVar("advdupe2_paste_unfreeze", 0, false, true)
	CreateClientConVar("advdupe2_preserve_freeze", 0, false, true)
	CreateClientConVar("advdupe2_copy_outside", 0, false, true)
	CreateClientConVar("advdupe2_copy_only_mine", 1, false, true)
	CreateClientConVar("advdupe2_limit_ghost", 100, false, true)
	CreateClientConVar("advdupe2_area_copy_size", 300, false, true)
	CreateClientConVar("advdupe2_auto_save_contraption", 0, false, true)
	CreateClientConVar("advdupe2_auto_save_overwrite", 1, false, true)
	CreateClientConVar("advdupe2_auto_save_time", 2, false, true)

	--Contraption Spawner
	CreateClientConVar("advdupe2_contr_spawner_key", -1, false, true)
	CreateClientConVar("advdupe2_contr_spawner_undo_key", -1, false, true)
	CreateClientConVar("advdupe2_contr_spawner_delay", 0, false, true)
	CreateClientConVar("advdupe2_contr_spawner_undo_delay", 10, false, true)
	CreateClientConVar("advdupe2_contr_spawner_disgrav", 0, false, true)
	CreateClientConVar("advdupe2_contr_spawner_disdrag", 0, false, true)
	CreateClientConVar("advdupe2_contr_spawner_addvel", 1, false, true)
	CreateClientConVar("advdupe2_contr_spawner_hideprops", 0, false, true)

	--Experimental
	CreateClientConVar("advdupe2_paste_disparents", 0, false, true)
	CreateClientConVar("advdupe2_paste_protectoveride", 1, false, true)
	CreateClientConVar("advdupe2_debug_openfile", 1, false, true)

	local function BuildCPanel(CPanel)
		CPanel:ClearControls()

		local FileBrowser = vgui.Create("advdupe2_browser")
		CPanel:AddItem(FileBrowser)
		FileBrowser:SetSize(CPanel:GetWide(), 405)
		AdvDupe2.FileBrowser = FileBrowser

		local Check = vgui.Create("DCheckBoxLabel")

		Check:SetText( "Paste at original position" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_original_origin" )
		Check:SetValue( 0 )
		Check:SetToolTip("Paste at the position originally copied")
		CPanel:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Paste with constraints" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_paste_constraints" )
		Check:SetValue( 1 )
		Check:SetToolTip("Paste with or without constraints")
		CPanel:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Paste with parenting" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_paste_parents" )
		Check:SetValue( 1 )
		Check:SetToolTip("Paste with or without parenting")
		CPanel:AddItem(Check)

		local Check_1 = vgui.Create("DCheckBoxLabel")
		local Check_2 = vgui.Create("DCheckBoxLabel")

		Check_1:SetText( "Unfreeze all after paste" )
		Check_1:SetDark(true)
		Check_1:SetConVar( "advdupe2_paste_unfreeze" )
		Check_1:SetValue( 0 )
		Check_1.OnChange = function()
			if(Check_1:GetChecked() and Check_2:GetChecked()) then
				Check_2:SetValue(0)
			end
		end
		Check_1:SetToolTip("Unfreeze all props after pasting")
		CPanel:AddItem(Check_1)

		Check_2:SetText( "Preserve frozen state after paste" )
		Check_2:SetDark(true)
		Check_2:SetConVar( "advdupe2_preserve_freeze" )
		Check_2:SetValue( 0 )
		Check_2.OnChange = function()
			if(Check_2:GetChecked() and Check_1:GetChecked()) then
				Check_1:SetValue(0)
			end
		end
		Check_2:SetToolTip("Makes props have the same frozen state as when they were copied")
		CPanel:AddItem(Check_2)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Area copy constrained props outside of box" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_copy_outside" )
		Check:SetValue( 0 )
		Check:SetToolTip("Copy entities outside of the area copy that are constrained to entities insde")
		CPanel:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "World/Area copy only your own props" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_copy_only_mine" )
		Check:SetValue( 1 )
		Check:SetToolTip("Copy entities outside of the area copy that are constrained to entities insde")
		CPanel:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Sort constraints by their connections" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_sort_constraints" )
		Check:SetValue( GetConVarNumber("advdupe2_sort_constraints") )
		Check:SetToolTip( "Orders constraints so that they build a rigid constraint system." )
		CPanel:AddItem(Check)

		local NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Ghost Percentage:" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( 0 )
		NumSlider:SetMax( 100 )
		NumSlider:SetDecimals( 0 )
		NumSlider:SetConVar( "advdupe2_limit_ghost" )
		NumSlider:SetToolTip("Change the percent of ghosts to spawn")
		--If these funcs are not here, problems occur for each
		local func = NumSlider.Slider.OnMouseReleased
		NumSlider.Slider.OnMouseReleased = function(self, mcode) func(self, mcode) AdvDupe2.StartGhosting() end
		local func2 = NumSlider.Slider.Knob.OnMouseReleased
		NumSlider.Slider.Knob.OnMouseReleased = function(self, mcode) func2(self, mcode) AdvDupe2.StartGhosting() end
		local func3 = NumSlider.Wang.Panel.OnLoseFocus
		NumSlider.Wang.Panel.OnLoseFocus = function(txtBox) func3(txtBox) AdvDupe2.StartGhosting() end
		CPanel:AddItem(NumSlider)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Area Copy Size:" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( 0 )
		NumSlider:SetMax( 30720 )
		NumSlider:SetDecimals( 0 )
		NumSlider:SetConVar( "advdupe2_area_copy_size" )
		NumSlider:SetToolTip("Change the size of the area copy")
		CPanel:AddItem(NumSlider)

		local Category1 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category1)
		Category1:SetLabel("Offsets")
		Category1:SetExpanded(0)

		local parent = FileBrowser:GetParent():GetParent():GetParent():GetParent()
		--[[Offsets]]--
		local CategoryContent1 = vgui.Create( "DPanelList" )
		CategoryContent1:SetAutoSize( true )
		CategoryContent1:SetDrawBackground( false )
		CategoryContent1:SetSpacing( 1 )
		CategoryContent1:SetPadding( 2 )
		CategoryContent1.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end		--Fix the damned mouse not scrolling when it's over the catagories

		Category1:SetContents( CategoryContent1 )

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Height Offset" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( -2500 )
		NumSlider:SetMax( 2500 )
		NumSlider:SetDefaultValue( 0 )
		NumSlider:SetDecimals( 3 )
		NumSlider:SetConVar("advdupe2_offset_z")
		NumSlider:SetToolTip("Changes the dupe Z offset")
		CategoryContent1:AddItem(NumSlider)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Use World Angles" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_offset_world" )
		Check:SetValue( 0 )
		Check:SetToolTip("Use world angles for the offset instead of the main entity")
		CategoryContent1:AddItem(Check)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Pitch Offset" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( -180 )
		NumSlider:SetMax( 180 )
		NumSlider:SetDefaultValue( 0 )
		NumSlider:SetDecimals( 3 )
		NumSlider:SetToolTip("Changes the dupe pitch offset")
		NumSlider:SetConVar("advdupe2_offset_pitch")
		CategoryContent1:AddItem(NumSlider)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Yaw Offset" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( -180 )
		NumSlider:SetMax( 180 )
		NumSlider:SetDefaultValue( 0 )
		NumSlider:SetDecimals( 3 )
		NumSlider:SetToolTip("Changes the dupe yaw offset")
		NumSlider:SetConVar("advdupe2_offset_yaw")
		CategoryContent1:AddItem(NumSlider)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Roll Offset" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( -180 )
		NumSlider:SetMax( 180 )
		NumSlider:SetDefaultValue( 0 )
		NumSlider:SetDecimals( 3 )
		NumSlider:SetToolTip("Changes the dupe roll offset")
		NumSlider:SetConVar("advdupe2_offset_roll")
		CategoryContent1:AddItem(NumSlider)

		local Btn = vgui.Create("DButton")
		Btn:SetText("Reset")
		Btn.DoClick = function()
			RunConsoleCommand("advdupe2_offset_z", 0)
			RunConsoleCommand("advdupe2_offset_pitch", 0)
			RunConsoleCommand("advdupe2_offset_yaw", 0)
			RunConsoleCommand("advdupe2_offset_roll", 0)
		end
		CategoryContent1:AddItem(Btn)


		--[[Dupe Information]]--
		local Category2 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category2)
		Category2:SetLabel("Dupe Information")
		Category2:SetExpanded(0)

		local CategoryContent2 = vgui.Create( "DPanelList" )
		CategoryContent2:SetAutoSize( true )
		CategoryContent2:SetDrawBackground( false )
		CategoryContent2:SetSpacing( 3 )
		CategoryContent2:SetPadding( 2 )
		Category2:SetContents( CategoryContent2 )
		CategoryContent2.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

		AdvDupe2.Info = {}

		local lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.File or "File: ")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.File = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Creator or "Creator:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Creator = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Date or "Date:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Date = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Time or "Time:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Time = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Size or "Size:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Size = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Desc or "Desc:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Desc = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Entities or "Entities:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Entities = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Constraints or "Constraints:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Constraints = lbl

	--[[Contraption Spawner]]--
		local Category3 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category3)
		Category3:SetLabel("Contraption Spawner")
		Category3:SetExpanded(0)

		local CategoryContent3 = vgui.Create( "DPanelList" )
		CategoryContent3:SetAutoSize( true )
		CategoryContent3:SetDrawBackground( false )
		CategoryContent3:SetSpacing( 3 )
		CategoryContent3:SetPadding( 2 )
		Category3:SetContents( CategoryContent3 )
		CategoryContent3.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

		local ctrl = vgui.Create( "CtrlNumPad" )
		ctrl:SetConVar1( "advdupe2_contr_spawner_key" )
		ctrl:SetConVar2( "advdupe2_contr_spawner_undo_key" )
		ctrl:SetLabel1( "Spawn Key")
		ctrl:SetLabel2( "Undo Key" )
		CategoryContent3:AddItem(ctrl)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Spawn Delay" )
		NumSlider.Label:SetDark(true)
		if(game.SinglePlayer()) then
			NumSlider:SetMin( 0 )
		else
			local min = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
			if(tonumber(LocalPlayer():GetInfo("advdupe2_contr_spawner_delay"))<min) then
				RunConsoleCommand("advdupe2_contr_spawner_delay", tostring(min))
			end
			NumSlider:SetMin( min )
		end
		NumSlider:SetMax(60)
		NumSlider:SetDecimals( 1 )
		NumSlider:SetConVar("advdupe2_contr_spawner_delay")
		CategoryContent3:AddItem(NumSlider)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Undo Delay" )
		NumSlider.Label:SetDark(true)
		if(game.SinglePlayer()) then
			NumSlider:SetMin( 0 )
			NumSlider:SetMax( 60 )
		else
			local min = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay")) or 10
			local max = tonumber(GetConVarString("AdvDupe2_MaxContraptionUndoDelay")) or 60
			if(tonumber(LocalPlayer():GetInfo("advdupe2_contr_spawner_undo_delay")) < min) then
				RunConsoleCommand("advdupe2_contr_spawner_undo_delay", tostring(min))
			elseif(tonumber(LocalPlayer():GetInfo("advdupe2_contr_spawner_undo_delay")) > max) then
				RunConsoleCommand("advdupe2_contr_spawner_undo_delay", tostring(max))
			end
			NumSlider:SetMin( min )
			NumSlider:SetMax( max )
		end
		NumSlider:SetDecimals( 1 )
		NumSlider:SetConVar("advdupe2_contr_spawner_undo_delay")
		CategoryContent3:AddItem(NumSlider)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable gravity for all spawned props" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_contr_spawner_disgrav" )
		Check:SetValue( 0 )
		CategoryContent3:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable drag for all spawned props" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_contr_spawner_disdrag" )
		Check:SetValue( 0 )
		CategoryContent3:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Add spawner's velocity to contraption" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_contr_spawner_addvel" )
		Check:SetValue( 1 )
		CategoryContent3:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable drawing spawner props" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_contr_spawner_hideprops" )
		Check:SetValue( 0 )
		CategoryContent3:AddItem(Check)

		--[[Area Auto Save]]--
		local Category4 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category4)
		Category4:SetLabel("Area Auto Save")
		Category4:SetExpanded(0)

		local CategoryContent4 = vgui.Create( "DPanelList" )
		CategoryContent4:SetAutoSize( true )
		CategoryContent4:SetDrawBackground( false )
		CategoryContent4:SetSpacing( 3 )
		CategoryContent4:SetPadding( 2 )
		Category4:SetContents( CategoryContent4 )
		CategoryContent4.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Only copy contraption" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_auto_save_contraption" )
		Check:SetValue( 0 )
		Check:SetToolTip("Only copy a contraption instead of an area")
		CategoryContent4:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Overwrite File" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_auto_save_overwrite" )
		Check:SetValue( 1 )
		Check:SetToolTip("Overwrite the file instead of creating a new one everytime")
		CategoryContent4:AddItem(Check)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Minutes to Save:" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( 2 )
		NumSlider:SetMax( 30 )
		NumSlider:SetDecimals( 0 )
		NumSlider:SetConVar( "advdupe2_auto_save_time" )
		NumSlider:SetToolTip("Interval time to save in minutes")
		CategoryContent4:AddItem(NumSlider)

		local pnl = vgui.Create("Panel")
		pnl:SetWide(CPanel:GetWide()-40)
		pnl:SetTall(75)
		pnl:SetPos(0, 50)
		CategoryContent4:AddItem(pnl)

		local label = vgui.Create("DLabel", pnl)
		label:SetText("Directory: ")
		label:SizeToContents()
		label:SetDark(true)
		label:SetPos(5,7)

		AdvDupe2.AutoSavePath = ""
		local txtbox = vgui.Create("DTextEntry", pnl)
		txtbox:SetWide(pnl:GetWide()-100)
		txtbox:SetPos(60, 5)
		txtbox:SetUpdateOnType(true)
		txtbox.OnTextChanged = function(self)
			self:SetValue(AdvDupe2.AutoSavePath)
		end

		local btn = vgui.Create("DImageButton", pnl)
		local x, y = txtbox:GetPos()
		btn:SetPos(x + txtbox:GetWide() + 5, 7)
		btn:SetMaterial("icon16/folder_explore.png")
		btn:SizeToContents()
		btn:SetToolTip("Browse")
		btn.DoClick = function()
			local ScrollBar = parent.VBar
			ScrollBar:AnimateTo(0, 1, 0, 0.2)

			FileBrowser.Submit:SetMaterial("icon16/disk.png")
			FileBrowser.Submit:SetTooltip("Directory for Area Auto Save")
			if(FileBrowser.FileName:GetValue()=="Folder_Name...") then
				FileBrowser.FileName:SetValue("File_Name...")
			end
			FileBrowser.Desc:SetVisible(true)
			FileBrowser.Info:SetVisible(false)
			FileBrowser.FileName:SetVisible(true)
			FileBrowser.FileName:SelectAllOnFocus(true)
			FileBrowser.FileName:OnMousePressed()
			FileBrowser.FileName:RequestFocus()
			FileBrowser.Expanding=true
			FileBrowser:Slide(true)
			FileBrowser.Submit.DoClick = function()
				local name = FileBrowser.FileName:GetValue()
				if(name=="" or name=="File_Name...") then
					AdvDupe2.Notify("Name field is blank.", NOTIFY_ERROR)
					FileBrowser.FileName:SelectAllOnFocus(true)
					FileBrowser.FileName:OnGetFocus()
					FileBrowser.FileName:RequestFocus()
					return
				end
				local desc = FileBrowser.Desc:GetValue()
				if(desc=="Description...") then desc="" end

				if(not IsValid(FileBrowser.Browser.pnlCanvas.m_pSelectedItem) or FileBrowser.Browser.pnlCanvas.m_pSelectedItem.Derma.ClassName~="advdupe2_browser_folder") then
					AdvDupe2.Notify("Folder to save Area Auto Save not selected.", NOTIFY_ERROR)
					return
				end

				FileBrowser.AutoSaveNode = FileBrowser.Browser.pnlCanvas.m_pSelectedItem
				txtbox:SetValue(FileBrowser:GetFullPath(FileBrowser.Browser.pnlCanvas.m_pSelectedItem)..name)
				AdvDupe2.AutoSavePath = txtbox:GetValue()
				txtbox:SetToolTip(txtbox:GetValue())
				AdvDupe2.AutoSaveDesc = desc

				FileBrowser:Slide(false)
				ScrollBar:AnimateTo(ScrollBar.CanvasSize, 1, 0, 0.2)

				RunConsoleCommand("AdvDupe2_SetStage")
				hook.Add("HUDPaint", "AdvDupe2_DrawSelectionBox", AdvDupe2.DrawSelectionBox)
			end
			FileBrowser.FileName.OnEnter = function()
				FileBrowser.FileName:KillFocus()
				FileBrowser.Desc:SelectAllOnFocus(true)
				FileBrowser.Desc.OnMousePressed()
				FileBrowser.Desc:RequestFocus()
			end
			FileBrowser.Desc.OnEnter = FileBrowser.Submit.DoClick
		end

		btn = vgui.Create("DButton", pnl)
		btn:SetSize(50, 35)
		btn:SetPos(pnl:GetWide()/4-10, 30)
		btn:SetText("Show")
		btn.DoClick = function()
			if(AdvDupe2.AutoSavePos) then
				RunConsoleCommand("advdupe2_area_copy_size", AdvDupe2.AutoSaveSize)
				LocalPlayer():SetEyeAngles( (AdvDupe2.AutoSavePos - LocalPlayer():GetShootPos()):Angle() )
				RunConsoleCommand("AdvDupe2_SetStage")
				hook.Add("HUDPaint", "AdvDupe2_DrawSelectionBox", AdvDupe2.DrawSelectionBox)
			end
		end

		btn = vgui.Create("DButton", pnl)
		btn:SetSize(50, 35)
		btn:SetPos((pnl:GetWide()/4)*3-40, 30)
		btn:SetText("Turn Off")
		btn:SetDisabled(true)
		btn.DoClick = function(self)
			RunConsoleCommand("AdvDupe2_RemoveAutoSave")
			self:SetDisabled(true)
			AdvDupe2.AutoSavePos = nil
		end
		AdvDupe2.OffButton = btn


		--[[Experimental Section]]--
		local Category5 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category5)
		Category5:SetLabel("Experimental Section")
		Category5:SetExpanded(0)

		local CategoryContent5 = vgui.Create( "DPanelList" )
		CategoryContent5:SetAutoSize( true )
		CategoryContent5:SetDrawBackground( false )
		CategoryContent5:SetSpacing( 3 )
		CategoryContent5:SetPadding( 2 )
		Category5:SetContents( CategoryContent5 )
		CategoryContent5.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable parented props physics interaction" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_paste_disparents" )
		Check:SetValue( 0 )
		CategoryContent5:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable Dupe Spawn Protection" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_paste_protectoveride" )
		Check:SetValue( 1 )
		Check:SetToolTip("Check this if you things don't look right after pasting.")
		CategoryContent5:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Open file after Saving" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_debug_openfile" )
		Check:SetValue( 1 )
		Check:SetToolTip("Check this if you want your files to be opened after saving them.")
		CategoryContent5:AddItem(Check)

		--[[Save Map]]--
		if(LocalPlayer():IsAdmin()) then
			local Category6 = vgui.Create("DCollapsibleCategory")
			CPanel:AddItem(Category6)
			Category6:SetLabel("Save Map")
			Category6:SetExpanded(0)

			local CategoryContent6 = vgui.Create( "DPanelList" )
			CategoryContent6:SetAutoSize( true )
			CategoryContent6:SetDrawBackground( false )
			CategoryContent6:SetSpacing( 3 )
			CategoryContent6:SetPadding( 2 )
			Category6:SetContents( CategoryContent6 )
			CategoryContent6.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

			pnl = vgui.Create("Panel")
			pnl:SetWide(CPanel:GetWide()-40)
			pnl:SetTall(75)
			pnl:SetPos(0, 50)
			CategoryContent6:AddItem(pnl)

			label = vgui.Create("DLabel", pnl)
			label:SetText("File Name: ")
			label:SizeToContents()
			label:SetDark(true)
			label:SetPos(5,7)

			AdvDupe2.AutoSavePath = ""

			local txtbox2 = vgui.Create("DTextEntry", pnl)
			txtbox2:SetWide(pnl:GetWide()-100)
			txtbox2:SetPos(60, 5)

			local btn2 = vgui.Create("DImageButton", pnl)
			x, y = txtbox2:GetPos()
			btn2:SetPos(x + txtbox2:GetWide() + 5, 7)
			btn2:SetMaterial("icon16/disk.png")
			btn2:SizeToContents()
			btn2:SetToolTip("Save Map")
			btn2.DoClick = 	function()
				if(txtbox2:GetValue()=="") then return end
				RunConsoleCommand("AdvDupe2_SaveMap", txtbox2:GetValue())
			end
			txtbox2.OnEnter = function()
				btn2:DoClick()
			end
		end
	end

	function TOOL.BuildCPanel(panel)
		panel:ClearControls()
		panel:AddControl("Header", {
			Text = "Advanced Duplicator 2",
			Description = "Duplicate stuff."
		})
		local function tryToBuild()
			local CPanel = controlpanel.Get("advdupe2")
			if CPanel and CPanel:GetWide()>16 then
				BuildCPanel(CPanel)
			else
				timer.Simple(0.1,tryToBuild)
			end
		end
		tryToBuild()
	end

	local StColor  = {r=130, g=25, b=40, a=255}
	local NoColor  = {r=25, g=100, b=40, a=255}
	local CurColor = {r=25, g=100, b=40, a=255}
	local CWhite   = Color(255,255,255,255)
	surface.CreateFont ("AD2Font", {font="Arial", size=40, weight=1000}) ---Remember to use gm_clearfonts
	surface.CreateFont ("AD2TitleFont", {font="Arial", size=24, weight=1000})

	function TOOL:DrawToolScreen()
		if(not AdvDupe2) then return true end

		local text = "Ready"
		local state, co = false
		local ply = LocalPlayer()

		if(AdvDupe2.Preview) then
			text = "Preview"
		end
		if(AdvDupe2.ProgressBar.Text) then
			state = true
			text = AdvDupe2.ProgressBar.Text
		end

		cam.Start2D()

			surface.SetDrawColor(32, 32, 32, 255)
			surface.DrawRect(0, 0, 256, 256)

			if(state) then
				co = StColor
			else
				co = NoColor
			end

			local rate = FrameTime() * 160
			CurColor.r = math.Approach( CurColor.r, co.r, rate )
			CurColor.g = math.Approach( CurColor.g, co.g, rate )

			surface.SetDrawColor(CurColor)
			surface.DrawRect(13, 13, 230, 230)

			surface.SetTextColor( 255, 255, 255, 255 )

			draw.SimpleText("Advanced Duplicator 2", "AD2TitleFont", 128, 50, CWhite, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
			draw.SimpleText(text, "AD2Font", 128, 128, CWhite, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			if(state) then
				draw.RoundedBox( 6, 32, 178, 192, 28, Color( 255, 255, 255, 150 ) )
				draw.RoundedBox( 6, 34, 180, 188*(AdvDupe2.ProgressBar.Percent / 100), 24, Color( 0, 255, 0, 255 ) )
			elseif(ply:KeyDown(IN_USE)) then
				local font, align = "AD2TitleFont", TEXT_ALIGN_BOTTOM
				draw.SimpleText("H: "..ply:GetInfo("advdupe2_offset_z")    , font, 20,  210, CWhite, TEXT_ALIGN_LEFT , align)
				draw.SimpleText("P: "..ply:GetInfo("advdupe2_offset_pitch"), font, 236, 210, CWhite, TEXT_ALIGN_RIGHT, align)
				draw.SimpleText("Y: "..ply:GetInfo("advdupe2_offset_yaw")  , font, 20 , 240, CWhite, TEXT_ALIGN_LEFT , align)
				draw.SimpleText("R: "..ply:GetInfo("advdupe2_offset_roll") , font, 236, 240, CWhite, TEXT_ALIGN_RIGHT, align)
			end

		cam.End2D()
	end


	local function FindInBox(min, max, ply)
		local EntTable = {}
		for _,ent in ents.Iterator() do
			local pos = ent:GetPos()
			if (pos.X>=min.X) and (pos.X<=max.X) and (pos.Y>=min.Y) and (pos.Y<=max.Y) and (pos.Z>=min.Z) and (pos.Z<=max.Z) then
				--if(ent:GetClass()~="C_BaseFlexclass") then
					EntTable[ent:EntIndex()] = ent
				--end
			end
		end

		return EntTable
	end


	local GreenSelected = Color(0, 255, 0, 255)
	function AdvDupe2.DrawSelectionBox()

		local TraceRes = util.TraceLine(util.GetPlayerTrace(LocalPlayer()))
		local i = math.Clamp(tonumber(LocalPlayer():GetInfo("advdupe2_area_copy_size")) or 50, 0, 30720)

		--Bottom Points
		local B1 = (Vector(-i,-i,-i) + TraceRes.HitPos)
		local B2 = (Vector(-i, i,-i) + TraceRes.HitPos)
		local B3 = (Vector( i, i,-i) + TraceRes.HitPos)
		local B4 = (Vector( i,-i,-i) + TraceRes.HitPos)

		--Top Points
		local T1 = (Vector(-i,-i, i) + TraceRes.HitPos):ToScreen()
		local T2 = (Vector(-i, i, i) + TraceRes.HitPos):ToScreen()
		local T3 = (Vector( i, i, i) + TraceRes.HitPos):ToScreen()
		local T4 = (Vector( i,-i, i) + TraceRes.HitPos):ToScreen()

		if(not AdvDupe2.LastUpdate or CurTime()>=AdvDupe2.LastUpdate) then

			if AdvDupe2.ColorEntities then
				for k,v in pairs(AdvDupe2.EntityColors)do
					local ent = AdvDupe2.ColorEntities[k]
					if(IsValid(ent)) then
						AdvDupe2.ColorEntities[k]:SetColor(v)
					end
				end
			end

			local Entities = FindInBox(B1, (Vector(i,i,i)+TraceRes.HitPos), LocalPlayer())
			AdvDupe2.ColorEntities = Entities
			AdvDupe2.EntityColors = {}
			for k,v in pairs(Entities)do
				AdvDupe2.EntityColors[k] = v:GetColor()
				v:SetColor(GreenSelected)
			end
			AdvDupe2.LastUpdate = CurTime()+0.25

		end

		local tracedata = {}
		tracedata.mask = MASK_NPCWORLDSTATIC
		local WorldTrace

		tracedata.start = B1+Vector(0,0,i*2)
		tracedata.endpos = B1
		WorldTrace = util.TraceLine( tracedata )
		B1 = WorldTrace.HitPos:ToScreen()
		tracedata.start = B2+Vector(0,0,i*2)
		tracedata.endpos = B2
		WorldTrace = util.TraceLine( tracedata )
		B2 = WorldTrace.HitPos:ToScreen()
		tracedata.start = B3+Vector(0,0,i*2)
		tracedata.endpos = B3
		WorldTrace = util.TraceLine( tracedata )
		B3 = WorldTrace.HitPos:ToScreen()
		tracedata.start = B4+Vector(0,0,i*2)
		tracedata.endpos = B4
		WorldTrace = util.TraceLine( tracedata )
		B4 = WorldTrace.HitPos:ToScreen()

		surface.SetDrawColor( 0, 255, 0, 255 )

		--Draw Sides
		surface.DrawLine(B1.x, B1.y, T1.x, T1.y)
		surface.DrawLine(B2.x, B2.y, T2.x, T2.y)
		surface.DrawLine(B3.x, B3.y, T3.x, T3.y)
		surface.DrawLine(B4.x, B4.y, T4.x, T4.y)

		--Draw Bottom
		surface.DrawLine(B1.x, B1.y, B2.x, B2.y)
		surface.DrawLine(B2.x, B2.y, B3.x, B3.y)
		surface.DrawLine(B3.x, B3.y, B4.x, B4.y)
		surface.DrawLine(B4.x, B4.y, B1.x, B1.y)

		--Draw Top
		surface.DrawLine(T1.x, T1.y, T2.x, T2.y)
		surface.DrawLine(T2.x, T2.y, T3.x, T3.y)
		surface.DrawLine(T3.x, T3.y, T4.x, T4.y)
		surface.DrawLine(T4.x, T4.y, T1.x, T1.y)

	end

	net.Receive("AdvDupe2_DrawSelectBox", function()
		hook.Add("HUDPaint", "AdvDupe2_DrawSelectionBox", AdvDupe2.DrawSelectionBox)
	end)

	function AdvDupe2.RemoveSelectBox()
		hook.Remove("HUDPaint", "AdvDupe2_DrawSelectionBox")
		if AdvDupe2.ColorEntities then
			for k,v in pairs(AdvDupe2.EntityColors)do
				if(not IsValid(AdvDupe2.ColorEntities[k])) then
					AdvDupe2.ColorEntities[k]=nil
				else
					AdvDupe2.ColorEntities[k]:SetColor(v)
				end
			end
			AdvDupe2.ColorEntities={}
			AdvDupe2.EntityColors={}
		end
	end
	net.Receive("AdvDupe2_RemoveSelectBox",function()
		AdvDupe2.RemoveSelectBox()
	end)

	function AdvDupe2.InitProgressBar(label)
		AdvDupe2.ProgressBar = {}
		AdvDupe2.ProgressBar.Text = label
		AdvDupe2.ProgressBar.Percent = 0
		AdvDupe2.BusyBar = true
	end
	net.Receive("AdvDupe2_InitProgressBar", function()
		AdvDupe2.InitProgressBar(net.ReadString())
	end)

	net.Receive("AdvDupe2_UpdateProgressBar", function()
		AdvDupe2.ProgressBar.Percent = net.ReadFloat()
	end)

	function AdvDupe2.RemoveProgressBar()
		AdvDupe2.ProgressBar = {}
		AdvDupe2.BusyBar = false
		if(AdvDupe2.Ghosting) then
			AdvDupe2.InitProgressBar("Ghosting: ")
			AdvDupe2.BusyBar = false
			AdvDupe2.ProgressBar.Percent = AdvDupe2.CurrentGhost/AdvDupe2.TotalGhosts*100
		end
	end
	net.Receive("AdvDupe2_RemoveProgressBar", function()
		AdvDupe2.RemoveProgressBar()
	end)

	net.Receive("AdvDupe2_ResetOffsets", function()
		RunConsoleCommand("advdupe2_original_origin", "0")
		RunConsoleCommand("advdupe2_paste_constraints","1")
		RunConsoleCommand("advdupe2_offset_z","0")
		RunConsoleCommand("advdupe2_offset_pitch","0")
		RunConsoleCommand("advdupe2_offset_yaw","0")
		RunConsoleCommand("advdupe2_offset_roll","0")
		RunConsoleCommand("advdupe2_paste_parents","1")
		RunConsoleCommand("advdupe2_paste_disparents","0")
	end)

	net.Receive("AdvDupe2_ReportModel", function()
		print("Advanced Duplicator 2: Invalid Model: "..net.ReadString())
	end)

	net.Receive("AdvDupe2_ReportClass", function()
		print("Advanced Duplicator 2: Invalid Class: "..net.ReadString())
	end)

	net.Receive("AdvDupe2_ResetDupeInfo", function()
		if not AdvDupe2.Info then return end
		AdvDupe2.Info.File:SetText("File:")
		AdvDupe2.Info.Creator:SetText("Creator:")
		AdvDupe2.Info.Date:SetText("Date:")
		AdvDupe2.Info.Time:SetText("Time:")
		AdvDupe2.Info.Size:SetText("Size:")
		AdvDupe2.Info.Desc:SetText("Desc:")
		AdvDupe2.Info.Entities:SetText("Entities:")
		AdvDupe2.Info.Constraints:SetText("Constraints:")
	end)

	net.Receive("AdvDupe2_CanAutoSave", function()
		if(AdvDupe2.AutoSavePath~="") then
			AdvDupe2.AutoSavePos = net.ReadVector()
			AdvDupe2.AutoSaveSize = net.ReadFloat()
			local ent = net.ReadUInt(16)
			AdvDupe2.OffButton:SetDisabled(false)
			net.Start("AdvDupe2_CanAutoSave")
				net.WriteString(AdvDupe2.AutoSaveDesc)
				net.WriteInt(ent, 16)
				if(game.SinglePlayer()) then
					net.WriteString(string.sub(AdvDupe2.AutoSavePath, 10, #AdvDupe2.AutoSavePath))
				end
			net.SendToServer()
		else
			AdvDupe2.Notify("Select a directory for the Area Auto Save.", NOTIFY_ERROR)
		end
	end)

	net.Receive("AdvDupe2_SetDupeInfo", function(len, ply, len2)
		if AdvDupe2.Info then
			AdvDupe2.Info.File:SetText("File: "..net.ReadString())
			AdvDupe2.Info.Creator:SetText("Creator: "..net.ReadString())
			AdvDupe2.Info.Date:SetText("Date: "..net.ReadString())
			AdvDupe2.Info.Time:SetText("Time: "..net.ReadString())
			AdvDupe2.Info.Size:SetText("Size: "..net.ReadString())
			AdvDupe2.Info.Desc:SetText("Desc: "..net.ReadString())
			AdvDupe2.Info.Entities:SetText("Entities: "..net.ReadString())
			AdvDupe2.Info.Constraints:SetText("Constraints: "..net.ReadString())
		else
			AdvDupe2.InfoText.File = "File: "..net.ReadString()
			AdvDupe2.InfoText.Creator = "Creator: "..net.ReadString()
			AdvDupe2.InfoText.Date = "Date: "..net.ReadString()
			AdvDupe2.InfoText.Time = "Time: "..net.ReadString()
			AdvDupe2.InfoText.Size = "Size: "..net.ReadString()
			AdvDupe2.InfoText.Desc = "Desc: "..net.ReadString()
			AdvDupe2.InfoText.Entities = "Entities: "..net.ReadString()
			AdvDupe2.InfoText.Constraints = "Constraints: "..net.ReadString()
		end
	end)
end

--addons/tools/lua/weapons/gmod_tool/stools/heart_turbolaser_tool.lua:
TOOL.Category = "Heart";
TOOL.Name = "Heart Turbolaser Tool";
TOOL.Command = nil;
TOOL.ConfigName	= "";
TOOL.AdminOnly = true;

if CLIENT then
	language.Add( "tool.heart_turbolaser_tool.name", "Heart Turbolaser Tool" );
	language.Add( "Tool.heart_turbolaser_tool.desc", "Shoot turbolasers." );
	language.Add( "Tool.heart_turbolaser_tool.left", "Shoot a turbolaser from the sky to where you are aiming.");
	language.Add( "Tool.heart_turbolaser_tool.right", "Shoot a turbolaser from the toolgun.");
	language.Add( "Tool.heart_turbolaser_tool.reload", "Creates a turbolaser spawner at your location.");
end

TOOL.Information = {
	{ name = "left" },
	{ name = "right" },
	{ name = "reload"}
}

// turbolaser options
TOOL.ClientConVar["speed"] = 1000;
TOOL.ClientConVar["damage"] = 1000;
TOOL.ClientConVar["radius"] = 150;
TOOL.ClientConVar["scale"] = 1.0;

TOOL.ClientConVar["r"] = 255;
TOOL.ClientConVar["g"] = 0;
TOOL.ClientConVar["b"] = 0;

// spawner options
TOOL.ClientConVar["shots"] = 3;
TOOL.ClientConVar["delay"] = 0.5;
TOOL.ClientConVar["spread"] = 0;

local defaultCV = TOOL:BuildConVarList();

function TOOL:VerifyValues()
	local speed = self:GetClientNumber("speed");
	local damage = self:GetClientNumber("damage");
	local radius = self:GetClientNumber("radius");
	local scale = self:GetClientNumber("scale");

	local shots = self:GetClientNumber("shots");
	local delay = self:GetClientNumber("delay");
	local spread = self:GetClientNumber("spread");

	local r = self:GetClientNumber("r");
	local g = self:GetClientNumber("g");
	local b = self:GetClientNumber("b");

	if speed <= 0 then return false end
	if damage < 0 then return false end
	if radius < 0 then return false end
	if scale < 0 then return false end

	if shots <= 0 then return false end
	if delay < 0 then return false end
	if spread < 0 then return false end

	if r < 0 || r > 255 then return false end
	if g < 0 || g > 255 then return false end
	if b < 0 || b > 255 then return false end

	return true;
end

// summon turbolaser function
function TOOL:Turbolaser()
	if CLIENT then return end

	if not self:VerifyValues() then return end

	local speed = self:GetClientNumber("speed");
	local damage = self:GetClientNumber("damage");
	local radius = self:GetClientNumber("radius");
	local scale = self:GetClientNumber("scale");

	local r = self:GetClientNumber("r");
	local g = self:GetClientNumber("g");
	local b = self:GetClientNumber("b");

	local laser = ents.Create("heart_turbolaser");
	laser:SetVar("speed", speed);
	laser:SetVar("damage", damage);
	laser:SetVar("radius", radius);

	laser:SetVar("scale", scale);
	laser:SetVar("r", r);
	laser:SetVar("g", g);
	laser:SetVar("b", b);

	return true, laser;
end

// shoot from sky
function TOOL:LeftClick(trace)
	if CLIENT then return end

	local spawned, laser = self:Turbolaser();

	if not spawned then return end

	local ply = self:GetOwner();

	laser:SetOwner(ply);
	laser:SetPos(trace.HitPos + Vector(0,0,5000));
	laser:SetAngles(Angle(90,0,0));

	laser:Spawn();
	laser:Activate();

	undo.Create("Turbolaser");
	undo.AddEntity(laser);
	undo.SetPlayer(ply);
	undo.SetCustomUndoText("Undone Turbolaser");
	undo.Finish();

	return false;
end

// shoot from face
function TOOL:RightClick()
	if CLIENT then return end

	local spawned, laser = self:Turbolaser();

	if not spawned then return end

	local ply = self:GetOwner();

	laser:SetOwner(ply);
	laser:SetPos(ply:GetShootPos());
	laser:SetAngles(ply:GetAngles());

	laser:Spawn();
	laser:Activate();

	undo.Create("Turbolaser");
	undo.AddEntity(laser);
	undo.SetPlayer(ply);
	undo.SetCustomUndoText("Undone Turbolaser");
	undo.Finish();

	return false;
end

// spawner from face
function TOOL:Reload()
	if CLIENT then return end;

	if not self:VerifyValues() then return end

	local ply = self:GetOwner();

	local speed = self:GetClientNumber("speed");
	local damage = self:GetClientNumber("damage");
	local radius = self:GetClientNumber("radius");
	local scale = self:GetClientNumber("scale");

	local shots = self:GetClientNumber("shots");
	local delay = self:GetClientNumber("delay");
	local spread = self:GetClientNumber("spread");

	local r = self:GetClientNumber("r");
	local g = self:GetClientNumber("g");
	local b = self:GetClientNumber("b");

	local spawner = ents.Create("heart_turbolaser_spawner");

	spawner:SetOwner(ply);
	spawner:SetPos(self:GetOwner():GetShootPos());
	spawner:SetAngles(self:GetOwner():GetAngles());

	spawner:SetVar("speed", speed);
	spawner:SetVar("damage", damage);
	spawner:SetVar("radius", radius);

	spawner:SetVar("shots", shots);
	spawner:SetVar("delay", delay);
	spawner:SetVar("spread", spread);

	spawner:SetVar("scale", scale);
	spawner:SetVar("r", r);
	spawner:SetVar("g", g);
	spawner:SetVar("b", b);

	spawner:Spawn();
	spawner:Activate();

	undo.Create("Spawner");
	undo.AddEntity(spawner);
	undo.SetPlayer(ply);
	undo.SetCustomUndoText("Undone Turbolaser Spawner");
	undo.Finish();

	print("undo ready")
end

function TOOL.BuildCPanel(panel)
	panel:SetName("Heart Turbolaser Tool")

	local header = vgui.Create("DImage");
	header:SetImage("materials/heart/turbolaser_header.png");
	header:SetSize(305, 140);
	panel:AddItem(header);

	panel:Help("Version 1.0")

	panel:AddControl( "ComboBox", { MenuButton = 1, Folder = "heart_turbolaser", Options = { [ "#preset.default" ] = defaultCV }, CVars = table.GetKeys( defaultCV ) } );

	panel:ControlHelp("");

	local divider1 = vgui.Create("DImage");
	divider1:SetImage("materials/heart/turbolaser_divider1.png");
	divider1:SetSize(305, 16);
	panel:AddItem(divider1);

	panel:NumSlider("Speed","heart_turbolaser_tool_speed","1","10000","0");
	panel:ControlHelp("Sets the speed of the turbolaser.");

	panel:NumSlider("Damage","heart_turbolaser_tool_damage","0","10000","0");
	panel:ControlHelp("Sets the damage of the turbolaser explosion.");

	panel:NumSlider("Explosion Radius","heart_turbolaser_tool_radius","10","1000","0");
	panel:ControlHelp("Sets the radius of the turbolasers explosion.");

	panel:NumSlider("Scale","heart_turbolaser_tool_scale","0.1","2","2");
	panel:ControlHelp("Sets the scale of the turbolaser model.");

	local colourLabel = vgui.Create("DLabel");
	colourLabel:SetText("Colour");
	colourLabel:SetColor(Color(0,0,0));
	panel:AddItem(colourLabel);

	panel:ColorPicker("", "heart_turbolaser_tool_r", "heart_turbolaser_tool_g", "heart_turbolaser_tool_b");

	panel:ControlHelp("");
	panel:ControlHelp("Sets the colour of the turbolaser.");

	panel:ControlHelp("");

	local divider2 = vgui.Create("DImage");
	divider2:SetImage("materials/heart/turbolaser_divider2.png");
	divider2:SetSize(305, 16);
	panel:AddItem(divider2);

	panel:NumSlider("Number of Shots","heart_turbolaser_tool_shots","1","10000","0");
	panel:ControlHelp("Sets the number of shots for the turbolaser spawner.");

	panel:NumSlider("Delay between Shots","heart_turbolaser_tool_delay","0.1","5","1");
	panel:ControlHelp("Sets the delay between shots for the turbolaser spawner. (In seconds)");

	panel:NumSlider("Spread","heart_turbolaser_tool_spread","0","10","1");
	panel:ControlHelp("Sets the spread of the turbolasers spawned from the turbolaser spawner.");

	panel:ControlHelp("");
end
--addons/lvs_base/gamemodes/sandbox/entities/weapons/gmod_tool/stools/lvshealthshieldeditor.lua:

TOOL.Category		= "LVS"
TOOL.Name			= "#tool.lvshealthshieldeditor.name"
TOOL.Command		= nil
TOOL.ConfigName		= ""

TOOL.ClientConVar[ "maxshield" ] = 0
TOOL.ClientConVar[ "maxhealth" ] = 5000

if CLIENT then
	language.Add( "tool.lvshealthshieldeditor.name", "Max Health & Shield Editor" )
	language.Add( "tool.lvshealthshieldeditor.desc", "A tool used to edit Max Health & Shield on LVS-Vehicles" )
	language.Add( "tool.lvshealthshieldeditor.0", "Left click on a LVS-Vehicle to set Max Health, Right click to set Max Shield, Reload to reset." )
	language.Add( "tool.lvshealthshieldeditor.1", "Left click on a LVS-Vehicle to set Max Health, Right click to set Max Shield, Reload to reset." )
	language.Add( "tool.lvshealthshieldeditor.maxshield", "Max Shield" )
	language.Add( "tool.lvshealthshieldeditor.maxhealth", "Max Health" )
end

function TOOL:LeftClick( trace )
	local ent = trace.Entity

	if not IsValid( ent ) then return false end

	if not ent.LVS and not ent.LFS then return end

	if not ent.OGMaxHealth then
		ent.OGMaxHealth = ent.MaxHealth
	end

	ent.MaxHealth = self:GetClientNumber( "maxhealth" )
	ent:SetHP( ent.MaxHealth )

	return true
end

function TOOL:RightClick( trace )
	local ent = trace.Entity

	if not IsValid( ent ) then return false end

	if not ent.LVS and not ent.LFS then return end

	if not ent.OGMaxShield then
		ent.OGMaxShield = ent.MaxShield
	end

	ent.MaxShield = self:GetClientNumber( "maxshield" )
	ent:SetShield( ent.MaxShield )

	return true
end

function TOOL:Reload( trace )
	local ent = trace.Entity

	if not IsValid( ent ) then return false end

	if not ent.LVS and not ent.LFS then return end

	if ent.OGMaxHealth then
		ent.MaxHealth = ent.OGMaxHealth
	end

	if ent.OGMaxShield then
		ent.MaxShield = ent.OGMaxShield
	end

	ent:SetHP( ent.MaxHealth )
	ent:SetShield( ent.MaxShield )

	return true
end

function TOOL:Think()
	if SERVER then return end

	local ply = LocalPlayer()
	local tr = ply:GetEyeTrace()

	local ent = tr.Entity
	if not IsValid( ent ) then return end

	if not ent.LVS and not ent.LFS then return end

	local Text = "Health: "..tostring( math.Round( ent:GetHP(), 0 ) ).."/"..tostring( ent.MaxHealth )
	if ent:GetShield() > 0 then
		Text = Text.."\nShield: "..tostring( math.Round( ent:GetShield(), 0 ) ).."/"..tostring( ent.MaxShield )
	end

	AddWorldTip( ent:EntIndex(), Text, SysTime() + 0.05, ent:GetPos(), ent )
end

function TOOL.BuildCPanel( panel )
	panel:AddControl( "Header", { Text = "#tool.lvshealthshieldeditor.name", Description = "#tool.lvshealthshieldeditor.desc" } )

	panel:AddControl( "Slider", 
	{
		Label 	= "#tool.lvshealthshieldeditor.maxhealth",
		Type 	= "Int",
		Min 	= "1",
		Max 	= "50000",
		Command = "lvshealthshieldeditor_maxhealth",
		Help = false
	})

	panel:AddControl( "Slider", 
	{
		Label 	= "#tool.lvshealthshieldeditor.maxshield",
		Type 	= "Int",
		Min 	= "0",
		Max 	= "50000",
		Command = "lvshealthshieldeditor_maxshield",
		Help = false
	})

	panel:AddControl( "Label",  { Text = "NOTE: Value in Edit-Properties menu will still be the same, because they can not be updated after the vehicle is spawned!" } )
end

--addons/tools/lua/improvedstacker/improvedstacker.lua:
--[[--------------------------------------------------------------------------
	Improved Stacker Module
	
	Author:
		Mista-Tea ([IJWTB] Thomas)
	
	License:
		The MIT License (MIT)

		Copyright (c) 2014-2020 Mista-Tea

		Permission is hereby granted, free of charge, to any person obtaining a copy
		of this software and associated documentation files (the "Software"), to deal
		in the Software without restriction, including without limitation the rights
		to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
		copies of the Software, and to permit persons to whom the Software is
		furnished to do so, subject to the following conditions:

		The above copyright notice and this permission notice shall be included in all
		copies or substantial portions of the Software.

		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
		SOFTWARE.
			
	Changelog:
----------------------------------------------------------------------------]]

local math = math
local hook = hook
local Angle = Angle
local Vector = Vector
local GetConVar = GetConVar
local duplicator = duplicator
local CreateConVar = CreateConVar

--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

module( "improvedstacker", package.seeall )

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

-- enums for determining stack relativity
MODE_WORLD = 1 -- stacking relative to the world
MODE_PROP  = 2 -- stacking relative to the prop

-- lookup table for validating relative values
Modes = {
	[MODE_WORLD] = true,
	[MODE_PROP]  = true,
}

-- enums for determining the direction to stack props
DIRECTION_FRONT = 1
DIRECTION_BACK  = 2
DIRECTION_RIGHT = 3
DIRECTION_LEFT  = 4
DIRECTION_UP    = 5
DIRECTION_DOWN  = 6

-- lookup table for validating direction values
Directions = {
	[DIRECTION_FRONT] = true,
	[DIRECTION_BACK]  = true,
	[DIRECTION_RIGHT] = true,
	[DIRECTION_LEFT]  = true,
	[DIRECTION_UP]    = true,
	[DIRECTION_DOWN]  = true,
}

-- constants used for when stacking relative to the World
ANGLE_ZERO   =  Angle( 0, 0, 0 )
VECTOR_FRONT  = ANGLE_ZERO:Forward()
VECTOR_RIGHT  = ANGLE_ZERO:Right()
VECTOR_UP     = ANGLE_ZERO:Up()
VECTOR_BACK   = -VECTOR_FRONT
VECTOR_LEFT   = -VECTOR_RIGHT
VECTOR_DOWN   = -VECTOR_UP

-- there has been a longstanding problem where stacked entities were an inch apart (figuratively), causing gaps everywhere.
-- as it turns out, fixing this issue is as easy as subtracting 0.5 from the forward component of the offset vector.
MAGIC_OFFSET = -0.5

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

if ( SERVER ) then
	
	-- the tables below are used internally and should only generally be interfaced with
	-- via the functions declared afterward.
	-- basically treat them as private, since they are only public for auto-refresh compatibility
	
	-- holds the current stacked entity count for every player
	m_EntCount  = m_EntCount  or {}
	-- holds the last stacker usage for every player
	m_StackTime = m_StackTime or {}
	-- holds every stacker entity created
	m_Ents      = m_Ents      or {}
		
	--[[--------------------------------------------------------------------------
	-- 	GetEntCount( player, number )
	--]]--
	function GetEntCount( ply, default )
		return m_EntCount[ ply:SteamID() ] or default
	end
	--[[--------------------------------------------------------------------------
	-- 	SetEntCount( player, number )
	--]]--
	function SetEntCount( ply, num )
		m_EntCount[ ply:SteamID() ] = num
	end
	--[[--------------------------------------------------------------------------
	-- 	IncrementEntCount( player, number )
	--]]--
	function IncrementEntCount( ply, num )
		m_EntCount[ ply:SteamID() ] = GetEntCount( ply, 0 ) + (num or 1)
	end
	--[[--------------------------------------------------------------------------
	-- 	DecrementEntCount( player, number )
	--]]--
	function DecrementEntCount( ply, num )
		m_EntCount[ ply:SteamID() ] = ( m_EntCount[ ply:SteamID() ] and m_EntCount[ ply:SteamID() ] - (num or 1) ) or 0
	end
	
	--[[--------------------------------------------------------------------------
	-- 	SetLastStackTime( player, number )
	--]]--
	function SetLastStackTime( ply, num )
		m_StackTime[ ply:SteamID() ] = num
	end
	--[[--------------------------------------------------------------------------
	-- 	GetLastStackTime( player, number )
	--]]--
	function GetLastStackTime( ply, default )
		return m_StackTime[ ply:SteamID() ] or default
	end
	
	--[[--------------------------------------------------------------------------
	--	Initialize( string )
	--
	--	This should be called immediately after including this file so that the follow
	--	variables/functions can use the stacker tool's mode (i.e., the name of the file itself
	--	and what is subsequently used in all of the cvars).
	--]]--
	function Initialize( mode )
		mode = mode or "stacker_improved"
		
		--[[--------------------------------------------------------------------------
		--  Hook :: PlayerInitialSpawn
		
		--	Sets the newly connected player's total stacker ents to 0.
		--	See TOOL:IsExceedingMax() for more details
		--]]--
		hook.Add( "PlayerInitialSpawn", mode.."_set_ent_count", function( ply )
			m_EntCount[ ply:SteamID() ] = 0
		end )
		--[[--------------------------------------------------------------------------
		--  Hook :: PlayerDisconnected
		--
		--	Removes the player from the table when they disconnect (for sanitation).
		--]]--
		hook.Add( "PlayerDisconnected", mode.."_remove_ent_count", function( ply )
			m_EntCount[ ply:SteamID() ] = nil
		end )
		
		--[[--------------------------------------------------------------------------
		-- 	MarkEntity( player, entity, table )
		--
		--	Marks the entity as a stacker entity. This allows the entity to be 
		--	collision-checked in GM.ShouldCollide.
		--]]--
		function MarkEntity( ply, ent, data )
			m_Ents[ ent ] = true
			duplicator.StoreEntityModifier( ent, mode, { StackerEnt = true } )
			ent:SetCustomCollisionCheck( true )
			
			-- when the entity is removed, sanitize our internal m_Ents array
			ent:CallOnRemove( mode, function( ent )
				ClearEntity( ent )
			end )
		end
		--duplicator.RegisterEntityModifier( mode, MarkEntity )
		--[[--------------------------------------------------------------------------
		-- 	ClearEntity( entity )
		--
		--	Removes the entity from the internal m_Ents array for sanitation purposes.
		--	This is called when an entity is just about to be removed.
		--]]--
		function ClearEntity( ent )
			if ( m_Ents[ ent ] ) then m_Ents[ ent ] = nil end
		end
		
		--[[--------------------------------------------------------------------------
		-- 	CanUnfreeze( player, entity, physObject )
		--]]--
		function CanUnfreeze( ply, ent, phys )
			if ( m_Ents[ ent ] ) then print("nope") return false end
		end
		--hook.Add( "CanPlayerUnfreeze", mode, CanUnfreeze )
		--hook.Add( "PhysgunPickup",     mode, CanUnfreeze )
		--hook.Remove( "CanPlayerUnfreeze", mode )
		--hook.Remove( "PhysgunPickup",     mode )
		
		local cvarNoCollideAll
		local cvarNoCollide
		--[[--------------------------------------------------------------------------
		-- 	ShouldCollide( entity, entity )
		--]]--
		function ShouldCollide( a, b )
			if ( not cvarNoCollideAll ) then cvarNoCollideAll = GetConVar( mode.."_force_nocollide_all" ) end
			if ( not cvarNoCollide )    then cvarNoCollide    = GetConVar( mode.."_force_nocollide" )     end
			
			if ( cvarNoCollideAll:GetBool() ) then
				if ( m_Ents[ a ] ) then
					if not ( b:IsPlayer() or b:IsWorld() or b:IsNPC() or b:IsVehicle() ) then return false end
				elseif ( m_Ents[ b ] ) then
					if not ( a:IsPlayer() or a:IsWorld() or b:IsNPC() or b:IsVehicle() ) then return false end
				end
			elseif ( cvarNoCollide:GetBool() ) then
				if ( m_Ents[ a ] and m_Ents[ b ] ) then return false end
			end
		end
		--hook.Add( "ShouldCollide", mode, ShouldCollide )
		--hook.Remove( "ShouldCollide", mode )
	end
	
elseif ( CLIENT ) then
	
	-- the table below is used internally and should only generally be interfaced with
	-- via the functions declared afterward.
	-- basically treat it as private, since it is only public for auto-refresh compatibility
	
	m_Ghosts    = m_Ghosts    or {}
	m_LookingAt = m_LookingAt or nil
	m_LookedAt  = m_LookedAt  or nil
	
	--[[--------------------------------------------------------------------------
	-- 	GetGhosts()
	--]]--
	function GetGhosts()
		return m_Ghosts
	end
	--[[--------------------------------------------------------------------------
	-- 	SetGhosts( table )
	--]]--
	function SetGhosts( tbl )
		m_Ghosts = tbl
	end
	
	--[[--------------------------------------------------------------------------
	-- 	GetLookingAt()
	--]]--
	function GetLookingAt()
		return m_LookingAt
	end
	--[[--------------------------------------------------------------------------
	-- 	SetLookingAt( entity )
	--]]--
	function SetLookingAt( ent )
		m_LookingAt = ent
	end
	
	--[[--------------------------------------------------------------------------
	-- 	GetLookedAt()
	--]]--
	function GetLookedAt()
		return m_LookedAt
	end
	--[[--------------------------------------------------------------------------
	-- 	SetLookedAt( entity )
	--]]--
	function SetLookedAt( ent )
		m_LookedAt = ent
	end
	
	--[[--------------------------------------------------------------------------
	-- 	ReleaseGhosts()
	--	
	--	Attempts to remove all ghosted props in the stack. 
	--	This occurs when the player stops looking at a prop with the stacker tool equipped.
	--]]--
	function ReleaseGhosts()
		if ( #m_Ghosts == 0 ) then return end
		
		for i = 1, #m_Ghosts do
			if ( not IsValid( m_Ghosts[ i ] ) ) then continue end
			SafeRemoveEntityDelayed( m_Ghosts[ i ], 0 )
			m_Ghosts[ i ] = nil
		end
	end
	
	--[[--------------------------------------------------------------------------
	--	Initialize( string )
	--
	--	This should be called immediately after including this file so that the follow
	--	variables/functions can use the stacker tool's mode (i.e., the name of the file itself
	--	and what is subsequently used in all of the cvars).
	--]]--
	function Initialize( mode )
		mode = mode or "stacker_improved"
		
		SETTINGS_DEFAULT = {
			[mode.."_set_max_per_player"]    = "-1",
			[mode.."_set_max_per_stack"]     = "15",
			[mode.."_set_delay"]             = "0.5",
			[mode.."_set_max_offsetx"]       = "200",
			[mode.."_set_max_offsety"]       = "200",
			[mode.."_set_max_offsetz"]       = "200",
			[mode.."_set_force_freeze"]      = "0",
			[mode.."_set_force_weld"]        = "0",
			[mode.."_set_force_nocollide"]   = "0",
			[mode.."_set_force_stayinworld"] = "1",
		}
		
		SETTINGS_SANDBOX = {
			[mode.."_set_max_per_player"]    = "-1",
			[mode.."_set_max_per_stack"]     = "30",
			[mode.."_set_delay"]             = "0.5",
			[mode.."_set_max_offsetx"]       = "1000",
			[mode.."_set_max_offsety"]       = "1000",
			[mode.."_set_max_offsetz"]       = "1000",
			[mode.."_set_force_freeze"]      = "0",
			[mode.."_set_force_weld"]        = "0",
			[mode.."_set_force_nocollide"]   = "0",
			[mode.."_set_force_stayinworld"] = "0",
		}
		
		SETTINGS_DARKRP = {
			[mode.."_set_max_per_player"]    = "50",
			[mode.."_set_max_per_stack"]     = "5",
			[mode.."_set_delay"]             = "1",
			[mode.."_set_max_offsetx"]       = "200",
			[mode.."_set_max_offsety"]       = "200",
			[mode.."_set_max_offsetz"]       = "200",
			[mode.."_set_force_freeze"]      = "1",
			[mode.."_set_force_weld"]        = "0",
			[mode.."_set_force_nocollide"]   = "1",
			[mode.."_set_force_stayinworld"] = "1",
		}
		
		SETTINGS_SINGLEPLAYER = {
			[mode.."_set_max_per_player"]    = "-1",
			[mode.."_set_max_per_stack"]     = "100",
			[mode.."_set_delay"]             = "0",
			[mode.."_set_max_offsetx"]       = "10000",
			[mode.."_set_max_offsety"]       = "10000",
			[mode.."_set_max_offsetz"]       = "10000",
			[mode.."_set_force_freeze"]      = "0",
			[mode.."_set_force_weld"]        = "0",
			[mode.."_set_force_nocollide"]   = "0",
			[mode.."_set_force_stayinworld"] = "0",
		}
	end
	
end

--
-- The functions below are used both serverside and clientside for properly orienting
-- and spacing props in a stack
--

-- Lookup table that holds functions related to determining the direction of a stack
DirectionFunctions = {
	[MODE_WORLD] = {
		[DIRECTION_FRONT] = function() return VECTOR_FRONT end,
		[DIRECTION_BACK]  = function() return VECTOR_BACK  end,
		[DIRECTION_RIGHT] = function() return VECTOR_RIGHT end,
		[DIRECTION_LEFT]  = function() return VECTOR_LEFT  end,
		[DIRECTION_UP]    = function() return VECTOR_UP    end,
		[DIRECTION_DOWN]  = function() return VECTOR_DOWN  end,
	},
	
	[MODE_PROP]  = {
		[DIRECTION_FRONT] = function( angle ) return  angle:Forward() end,
		[DIRECTION_BACK]  = function( angle ) return -angle:Forward() end,
		[DIRECTION_RIGHT] = function( angle ) return  angle:Right()   end,
		[DIRECTION_LEFT]  = function( angle ) return -angle:Right()   end,
		[DIRECTION_UP]    = function( angle ) return  angle:Up()      end,
		[DIRECTION_DOWN]  = function( angle ) return -angle:Up()      end,
	}
}

-- Lookup table that holds functions related to determining the distance to offset each prop in a stack
-- before applying the client's actual x/y/z offset values
DistanceFunctions = {
	[DIRECTION_FRONT] = function( min, max ) return math.abs(max.x - min.x) end,
	[DIRECTION_BACK]  = function( min, max ) return math.abs(max.x - min.x) end,
	[DIRECTION_RIGHT] = function( min, max ) return math.abs(max.y - min.y) end,
	[DIRECTION_LEFT]  = function( min, max ) return math.abs(max.y - min.y) end,
	[DIRECTION_UP]    = function( min, max ) return math.abs(max.z - min.z) end,
	[DIRECTION_DOWN]  = function( min, max ) return math.abs(max.z - min.z) end,
}

-- Lookup table that holds functions related to determining the distance to offset each prop in a stack
-- based on the client's x/y/z offset values
OffsetFunctions = {
	[DIRECTION_FRONT] = function( angle, offset ) return ( angle:Forward() * offset.x) + ( angle:Up()      * offset.z) + ( angle:Right()   * offset.y) end,
	[DIRECTION_BACK]  = function( angle, offset ) return (-angle:Forward() * offset.x) + ( angle:Up()      * offset.z) + (-angle:Right()   * offset.y) end,
	[DIRECTION_RIGHT] = function( angle, offset ) return ( angle:Right()   * offset.x) + ( angle:Up()      * offset.z) + (-angle:Forward() * offset.y) end,
	[DIRECTION_LEFT]  = function( angle, offset ) return (-angle:Right()   * offset.x) + ( angle:Up()      * offset.z) + ( angle:Forward() * offset.y) end,
	[DIRECTION_UP]    = function( angle, offset ) return ( angle:Up()      * offset.x) + (-angle:Forward() * offset.z) + ( angle:Right()   * offset.y) end,
	[DIRECTION_DOWN]  = function( angle, offset ) return (-angle:Up()      * offset.x) + ( angle:Forward() * offset.z) + ( angle:Right()   * offset.y) end,
}

RotationFunctions = {
	[DIRECTION_FRONT] = function( angle ) return  angle:Right(),   angle:Up(),       angle:Forward() end,
	[DIRECTION_BACK]  = function( angle ) return -angle:Right(),   angle:Up(),      -angle:Forward() end,
	[DIRECTION_RIGHT] = function( angle ) return -angle:Forward(), angle:Up(),       angle:Right()   end,
	[DIRECTION_LEFT]  = function( angle ) return  angle:Forward(), angle:Up(),      -angle:Right()   end,
	[DIRECTION_UP]    = function( angle ) return -angle:Right(),   angle:Forward(),  angle:Up()      end,
	[DIRECTION_DOWN]  = function( angle ) return  angle:Right(),   angle:Forward(), -angle:Up()      end,
}

--[[--------------------------------------------------------------------------
-- 	GetDirection( number, number, angle )
--
--	Calculates the direction to point the entity to by depending on whether the stack is
--	created relative to the world or the original prop, and the direction to stack in.
--]]--
function GetDirection( stackMode, stackDir, angle )
	return DirectionFunctions[ stackMode ][ stackDir ]( angle )
end

--[[--------------------------------------------------------------------------
-- 	GetDistance( number, number, entity )
--
--	Calculates the space occupied by the entity depending on the stack direction.
--	This represents the number of units to offset the stack entities so they appear
--	directly in front of the previous entity (depending on direction).
--]]--
function GetDistance( stackMode, stackDir, ent )
	if ( stackMode == MODE_WORLD ) then
		return DistanceFunctions[ stackDir ]( ent:WorldSpaceAABB() )
	elseif ( stackMode == MODE_PROP ) then
		return DistanceFunctions[ stackDir ]( ent:OBBMins(), ent:OBBMaxs() )
	end
end

--[[--------------------------------------------------------------------------
-- 	GetOffset( number, number, angle, vector )
--
--	Calculates a direction vector used for offsetting a stacked entity based on the facing angle of the previous entity.
--	This function uses a lookup table for added optimization as opposed to an if-else block.
--]]--
function GetOffset( stackMode, stackDir, angle, offset )
	-- if stacking relative to the world, apply the magic offset fix to the correct direction
	if ( stackMode == MODE_WORLD ) then
		local direction = DirectionFunctions[ stackMode ][ stackDir ]()
			  direction = direction * MAGIC_OFFSET
		return offset + direction
	-- if stacking relative to the prop, apply the magic offset only to the forward (x) component of the vector
	elseif ( stackMode == MODE_PROP ) then
		local trueOffset = Vector()
		      trueOffset:Set( offset )
			  trueOffset.x = trueOffset.x + MAGIC_OFFSET
		return OffsetFunctions[ stackDir ]( angle, trueOffset )
	end
end

--[[--------------------------------------------------------------------------
-- 	RotateAngle( angle, angle )
--
--	Rotates the first angle by the second angle. This ensures proper rotation
--	along all three axes and prevents various problems related to simply adding
--	two angles together. The first angle is modified directly by refence, so this does not
--	return anything.
--]]--
function RotateAngle( stackMode, stackDir, angle, rotation )
	local axisPitch, axisYaw, axisRoll = RotationFunctions[ stackDir ]( angle )

	angle:RotateAroundAxis( axisPitch,  rotation.p )
	angle:RotateAroundAxis( axisYaw,   -rotation.y )
	angle:RotateAroundAxis( axisRoll,   rotation.r )
end
--addons/arccw_weapons/lua/weapons/masita_cgshield.lua:
SWEP.Base = "arccw_base_melee"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.AdminOnly = false

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Coruscant Guard Shield"
SWEP.Trivia_Class = "Shield"
SWEP.Trivia_Desc = "Anti-blaster fire shield for the grand army of the Republic. Stops blaster fire, specially from those damm clankers."
SWEP.Trivia_Manufacturer = "Grand Army of the Republic"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/coruscantguard_shield.png"

SWEP.Slot = 0

SWEP.NotForNPCs = true

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw_cg/v_shield.mdl"
SWEP.WorldModel = "models/weapons/arccw_cg/v_shield.mdl"
SWEP.ViewModelFOV = 60

SWEP.WorldModelOffset = {
    pos = Vector(0, 15, -12),
    ang = Angle(0, 0, 180 - 15)
}

SWEP.ShieldProps = {
    {
        Model = "models/weapons/arccw_cg/v_shield.mdl",
        Pos = Vector(0, -15, -12),
        Ang = Angle(0, 0, 180 - 15),
        Resistance = 100
    }
}

SWEP.PrimaryBash = true

SWEP.SpeedMult = 0.85

SWEP.MeleeDamage = 50
SWEP.MeleeRange = 32
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 1
SWEP.MeleeGesture = ACT_HL2MP_GESTURE_RANGE_ATTACK_KNIFE
SWEP.MeleeAttackTime = 0

SWEP.MeleeSwingSound = {
    "arccw_go/shield/shield_push_01.wav",
}
SWEP.MeleeHitSound = {
    "physics/metal/metal_barrel_impact_hard7.wav",
}
SWEP.MeleeHitNPCSound = {
    "physics/body/body_medium_break3.wav",
}

SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "MELEE"
    },
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "melee2"

SWEP.Primary.ClipSize = -1

SWEP.Animations = {
    ["draw"] = {
        Source = "deploy",
    },
    -- ["idle"] = {
    --     Source = {"idle1", "idle2"}
    -- },
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "bash",
        Time = 2,
    },
}

SWEP.IronSightStruct = false

SWEP.ActivePos = Vector(0, 0, 3)

SWEP.BashPreparePos = Vector(0, 0, 0)
SWEP.BashPrepareAng = Angle(0, 5, 0)

SWEP.CustomizePos = Vector(15, 5, 0)
SWEP.CustomizeAng = Angle(0, 60, 0)

SWEP.BashPos = Vector(0, 0, 0)
SWEP.BashAng = Angle(10, -10, 0)

SWEP.HolsterPos = Vector(0, -1, 2)
SWEP.HolsterAng = Angle(-15, 0, 0)

sound.Add({
    name = "ARCCW_GO_SHIELD.ShieldEquipStart",
    channel = 16,
    volume = 1.0,
    sound = "arccw_go/shield/shield_equip_04.wav"
})

sound.Add({
    name = "ARCCW_GO_SHIELD.ShieldEquipEnd",
    channel = 16,
    volume = 1.0,
    sound = "arccw_go/shield/shield_equip_05.wav"
})
--addons/arccw_weapons/lua/weapons/masita_dc15a_stun.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Stun DC-15a"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "The DC-15A blaster rifle, known simply as the DC-15 blaster rifle, was a heavy blaster rifle manufactured by BlasTech Industries, as part of the DC-15 family. It was one of the standard-issue weapons of the Galactic Republic's clone troopers, an army of cloned soldiers in the Grand Army of the Republic, during the Clone Wars against the Confederacy of Independent Systems."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15a_stun.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.NoHideLeftHandInCustomization = true
SWEP.ViewModel = "models/servius/weapons/viewmodels/c_dc15a.mdl"
SWEP.WorldModel = "models/servius/weapons/worldmodels/w_dc-15a.mdl"
SWEP.ViewModelFOV = 56

SWEP.DefaultBodygroups = "010"
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 36
SWEP.RangeMin = 243
SWEP.DamageMin = 24
SWEP.Range = 510
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)

SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 55

SWEP.Recoil = 0.43
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.63
SWEP.Delay = 60 / 324
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
		Mode = -2
	},
    {
        Mode = 0
    },            
}

SWEP.AccuracyMOA = 0.50
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 50

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.66, -12.75, 2.529),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 2, 3)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(15, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true 
SWEP.BipodDispersion = 1
SWEP.BipodRecoil = 1 

-- Attachments
SWEP.DefaultElements = {"dc15"}
SWEP.AttachmentElements = {
    ["dc15"] = {
        WMElements = {
            {
                Model = "models/servius/weapons/worldmodels/w_dc-15a.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                WBodygroups = {{ind = 0, bg = 0}},
                Offset = {
                    pos = Vector(-550, 0, 470),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(4150, 0, -1100),
                    ang = Angle(-15, 0, 100)
                },
                IsMuzzleDevice = true
            },
        },
    },
}
WMOverride = "models/servius/weapons/worldmodels/w_dc-15a.mdl"

SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "Standard", 
        Slot = "optic", 
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(0.110, -3.771, 2.1),
            vang = Angle(0, -90, 0),
            wpos = Vector(420, 50, -450),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0),
    },          
    {
        PrintName = "Magazine Capacity",
        DefaultAttName = "Standard",
        Slot = {"dc15a_magazine_75"},
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(0, -3.7, 0.5),
            vang = Angle(0, 0, 90),
            wpos = Vector(550, 115, -250),
            wang = Angle(-15, -90, -90)
        },
    },      
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    {
        PrintName = "Ammo", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "sw_ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(1.3, -6.739, 0.504),
            vang = Angle(0, -90, 0),
            wpos = Vector(115, 180, -125),
            wang = Angle(-10 , 0, 180)
        },
    },    
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(111, 111, 111),
        Bone = "dc15a_DC15_mat",
        Offset = {
            vpos = Vector(1.1, -9, 0.7),
            vang = Angle(0, -90, 0),
            wpos = Vector(-100, 180, -75),
            wang = Angle(-15 , 0, 180)
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Neutral"
    },
    ["fire"] = {
        Time = 2.3,
        Source = {"shoot", "shoot2"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_lgequip.wav",
                p = 100, 
                v = 75,
                t = 0, 
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_medequip.wav",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "dc15a_reload1", t = 2 / 10},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 2 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 2 / 30},
        },
    },


sound.Add({
    name =          "dc15a_reload1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "armas/misc/dc17s_reload.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/masita_dc15sa.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-15sa"
SWEP.Trivia_Class = "Blaster Modular Pistol"
SWEP.Trivia_Desc = "The DC-15s side arm blaster was a blaster pistol created by BlasTech Industries for the Grand Army of the Republic. DC-15s pistols were used by clone commandos as a backup in addition to the heavier DC-17m Interchangeable Weapon System. The energy cell kept the blaster recharging at a slow but steady rate."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15sa.png"

SWEP.UseHands = true

SWEP.MirrorVMWM = false
SWEP.ViewModel = "models/jellyton/view_models/c_DC15SA.mdl"
SWEP.WorldModel = "models/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 36
SWEP.RangeMin = 90
SWEP.DamageMin = 23
SWEP.Range = 551
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 253
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.16
SWEP.HipDispersion = 410
SWEP.MoveDispersion = 37

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)

----AMMO / stuff----
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootSound = "armas/disparos/dc15sa.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"
SWEP.InfiniteAmmo = true
SWEP.BottomlessClip = true
SWEP.Jamming = true
SWEP.HeatGain = 1 
SWEP.HeatCapacity = 20
SWEP.HeatDissipation = 15 
SWEP.HeatLockout = true
SWEP.HeatDelayTime = 0.5

SWEP.IronSightStruct = {
    Pos = Vector(-5.173, -6.689, 0.411),
    Ang = Vector(0, 0, 0),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

SWEP.HoldtypeHolstered = "idle"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-4, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, -20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(10, -13, 0)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

-- Attachments
SWEP.DefaultElements = {"dc15sa"}
SWEP.AttachmentElements = {
    ["dc15sa"] = {
        VMElements = {
            {
                Model = "models/cs574/weapons/dc15sa.mdl",
                Bone = "DC-15SA",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-0.128, 4.4, -0.9),
                    ang = Angle(90, 0, -90),
                }
            }
        },
        WMElements = {
            {
                Model = "models/cs574/weapons/dc15sa.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(840, 100, 275),
                    ang = Angle(0, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(1250, 100, -400),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            }, 
        },
    },
}
WMOverride = "models/cs574/weapons/dc15sa.mdl"
SWEP.Attachments = {
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "DC-15SA",
        Offset = {
            vpos = Vector(-0.150, -1.9, -5.32),
            vang = Angle(90, 0, -90),
            wpos = Vector(400, 100, -475),
            wang = Angle(0, 0, 180)
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, -4, 0),
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None", 
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        WMScale = Vector(111, 111, 111),
        Bone = "DC-15SA", 
        Offset = {
            vpos = Vector(-0, -1.5, 4.2),
            vang = Angle(90, 0, 0),
            wpos = Vector(1450, 100, -400),
            wang = Angle(0, 0, 180)
        },
    },       
    {
        PrintName = "Tactical", 
        DefaultAttName = "None", 
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(100, 100, 100),
        Bone = "DC-15SA", 
        Offset = {
            vpos = Vector(-1.1, -0.6, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(1110, 100, -250),
            wang = Angle(0, 0, -180)
        },
    },      
    {
        PrintName = "Energization",
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None", 
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None", 
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "DC-15SA", 
        Offset = {
            vpos = Vector(0.503, -1.3, -5.336),
            vang = Angle(90, 0, -90),
            wpos = Vector(325, 180, -350),
            wang = Angle(-10, 0, 180)
        },
    },          
}

SWEP.Animations = {
    ["fire"] = {
        Source = "fire",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
        SoundTable = {
            {s = "dc15sa_1", t = 1 / 60}, --s sound file
        },
    },


sound.Add({
    name =          "dc15sa_1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_var_02.mp3"
    }),
}
--addons/arccw_weapons/lua/weapons/masita_dc15x.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number


-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-15x"
SWEP.Trivia_Class = "Blaster Sniper Rifle"
SWEP.Trivia_Desc = "The DC-15x sniper rifle was a sniper rifle manufactured for the clone snipers of the Galactic Republic through extensive modifications of the standard-issue DC-15A blaster rifle."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15x.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.NoHideLeftHandInCustomization = true

SWEP.ViewModel = "models/ser/starwars/c_dc15x.mdl"
SWEP.WorldModel = "models/ser/starwars/w_dc15x.mdl"

SWEP.ViewModelFOV = 50
SWEP.WorldModelOffset = {
    pos = Vector(8, 1., -3.5),
    ang = Angle(-5, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1.2
}

SWEP.DefaultBodygroups = "111"
SWEP.DefaultWMBodygroups = "111"

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 139
SWEP.RangeMin = 433
SWEP.DamageMin = 54
SWEP.Range = 1075
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 11

SWEP.Recoil = 1.78
SWEP.RecoilSide = 0.36
SWEP.RecoilRise = 0.76

SWEP.Delay = 60 / 70
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.47
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 76

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.35

-- Ammo, Sounds & MuzzleEffect
SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc15x.wav"
SWEP.ShootSoundSilenced = "armas/disparos/silenced_sniper.mp3"

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-2.941, -6.442, 1.307),
    Ang = Vector(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 50,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(1, 3, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true
SWEP.BipodDispersion = 1
SWEP.BipodRecoil = 1

-- Attachments 
SWEP.Attachments = {
	{
		PrintName = "Sight", 
		DefaultAttName = "Standard",
		Slot = "optic",
		Bone = "optic",
		Offset = {
            vpos = Vector(0.02, 0, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 0.8, -4.6),
            wang = Angle(-7, 0, 180),
        },
	},
    {
        PrintName = "Tactical", 
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        Bone = "optic",
        Offset = {
            vpos = Vector(0.8, 1, 15),
            vang = Angle(90, 0, -0),
            wpos = Vector(24, 1.4, -5),
            wang = Angle(-5, 0, -90),
        },
    },
    {
        PrintName = "Grip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "optic",
        Offset = {
            vpos = Vector(0, 2, 15),
            vang = Angle(90, 0, -90),    
            wang = Angle(-3, 0, 180)     
        },
        SlideAmount = {
        vmin = Vector(-0.2, 2.6, 6),
        vmax = Vector(-0.2, 2.6, 12),
        wmin = Vector(15, 0.6, -2.3), 
        wmax = Vector(15, 0.6, -2.3)
        },         
    }, 
    {
        PrintName = "Muzzle",
        DefaultAttName = "None", 
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "optic", 
        Offset = {
            vpos = Vector(0, 1, 20),
            vang = Angle(90, 0, -90),
            wpos = Vector(26, 0.75, -5.25),
            wang = Angle(-5, 0.5, 180)
        },
    },  
    {
        PrintName = "Energization",
        DefaultAttName = "Standard Energization",
        Slot = "ammo",
    },  
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    }, 
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "optic",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1, 1.6, -3.8),
            vang = Angle(90, 0, -90),
            wpos = Vector(2.3, 1.8, -2.3),
            wang = Angle(0, 0, 180)
        },
    },       
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "optic",
        Offset = {
            vpos = Vector(1, 1.350, -6),
            vang = Angle(90, 0, -90),
            wpos = Vector(-2, 1.8, -2.3),
            wang = Angle(-5, 0, 180)
        },
    },      
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/sw01_characters_gunfoley_draw_blaster_var14.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "dc15x-1", t = 0.1 }, --s sound file
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 0.1 },
            {s = "everfall/weapons/handling/reload_heavy/mag_load/023d-000000ae.mp3", t = 0.9 }, --s sound file
        },
    },

sound.Add({
    name =          "dc15x-1",
    channel =       CHAN_ITEM,
    volume =        1.1,
    sound =             "everfall/weapons/handling/reload_heavy/mag_eject/023d-00000628.mp3"
    }),
}
--addons/arccw_weapons/lua/weapons/masita_dc17m.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-17m"
SWEP.Trivia_Class = "Modular Blaster Rifle"
SWEP.Trivia_Desc = "The DC-17m Interchangeable Weapon System, also known as the DC-17m Repeating Blaster Rifle, was a type of repeating blaster rifle used by Republic clone commandos during the Clone Wars. It could change between a repeating blaster rifle and grenade launcher by switching the weapon's barrel module."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc17m_new.png"

SWEP.Slot = 3

SWEP.UseHands = true
SWEP.NoHideLeftHandInCustomization = true
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/c_dc17m.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dc17m.mdl"
SWEP.ViewModelFOV = 53
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(-5, 9, -6),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Tracer
SWEP.Damage = 39
SWEP.RangeMin = 276
SWEP.DamageMin = 23
SWEP.Range = 523
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 900

SWEP.BodyDamageMults =  {
     [HITGROUP_HEAD] = 2.3,
     [HITGROUP_CHEST] = 1.2,
     [HITGROUP_LEFTARM] = 1,
     [HITGROUP_RIGHTARM] = 1,
}

SWEP.TracerNum = 1
SWEP.TracerCol = Color(0, 0, 250)
SWEP.TracerWidth = 10
SWEP.Tracer = "tracer_blue"
SWEP.HullSize = 1

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 75
SWEP.ExtendedClipSize = 150
SWEP.ReducedClipSize = 25

SWEP.MaxRecoilBlowback = 1
SWEP.VisualRecoilMult = 1
SWEP.Recoil = 0.98
SWEP.RecoilSide = 0.13
SWEP.RecoilRise = 0.67
SWEP.RecoilPunch = 1

SWEP.Delay = 60 / 426
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 2,
        PrintName = "FULLAUTO-PLASMA",
    },
    {
		Mode = 1,
        PrintName = "SINGLE-PLASMA",
    },
	{
		Mode = 0,
   	}
}

SWEP.AccuracyMOA = 0.1
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 125 
SWEP.SightsDispersion = 0 
SWEP.JumpDispersion = 200

-- Speed Mult
SWEP.SpeedMult = 1.1
SWEP.SightedSpeedMult = 0.77
SWEP.ShootSpeedMult = 1

-- Ironsight & Properties
SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = false
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 150
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc17m/dc17m_fire0.wav"
SWEP.FirstShootSound = "armas/disparos/dc17m/dc17m_fire3.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc17m/dc17m_fire_silenced.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-8.389, 0, 0.689),
    Ang = Angle(1.332, -1.168, 0),
     Magnification = 1.2,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-3, 3, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(0, 3, -4)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "Standard",
        Slot = "optic",
        Bone = "weaponAttach_R",
        Offset = {
            vpos = Vector(3.5, -0.1, 4.8),
            vang = Angle(0, 0, 0),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        Bone = "weaponAttach_R",
        Offset = {
            vpos = Vector(9, -1.5, 2.7),
            vang = Angle(0, 0, 90),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "weaponAttach_R",
        Offset = {
            vpos = Vector(14.5, 0, 3.5),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "weaponAttach_R",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0, -1.4, 2.4),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "weaponAttach_R",
        VMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(-2, -1.3, 3.4),
            vang = Angle(0, 0, 20),
        },
    },
}

SWEP.Animations = {
    ["enter_inspect"]= {
        Source = "pose",
        SoundTable = {
            {
                s = "armas/disparos/dc17m/dc17m_pose.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 100, -- volume
                t = 1, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "melee", 
        SoundTable = {
            {s = "armas/disparos/dc17m/melee0.wav", t = 0.1 },
        },
    },
    ["fire"] = {
        Source = "fire"
    },
    ["idle_iron"] = {
        Source = false
    },
    ["idle_sight"] = {
        Source = false
    },
    ["fire_iron"] = {
        Source = false
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armas/disparos/dc17m/dc17m_unholster.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 100, -- volume
                t = 0.1, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armas/disparos/dc17m/dc17m_sniper_unholster.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0.1, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        SoundTable = {
            {s = "armas/disparos/dc17m/dc17m_reload.wav", t = 0.1 }, --s sound file
        },
    },
}
--addons/arccw_weapons/lua/weapons/masita_dual_dc17s_red.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "Dual DC-17s [Red]"
SWEP.Trivia_Class = "Heavy Dual Blaster Pistol"
SWEP.Trivia_Desc = "The DC-17s hand blaster, also known as DC-17s blaster pistol, was a heavy blaster pistol wielded by the clone troopers of the Grand Army of the Galactic Republic during the Clone Wars. An advanced firearm, it was fielded to elite soldiers in the army, most notably Advanced Recon Commandos, clone trooper commanders, and clone jet troopers. This one version is a powerful one."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dual_dc17s_red.png"

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/c_reaper_nope.mdl"
SWEP.WorldModel = "models/rising/base/c_akimbo.mdl"
SWEP.ViewModelFOV = 80
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.DefaultBodygroups = "000000000000"
SWEP.NoHideLeftHandInCustomization = true
SWEP.Damage = 30
SWEP.RangeMin = 100
SWEP.DamageMin = 17
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 40

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 0.6
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 348
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 2
    },
    {
        Mode = 0
    },        
}

SWEP.AccuracyMOA = 0.56 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 460 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50


SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootSound = "armas/disparos/dc17s.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"
SWEP.MuzzleFlashColor = Color(0, 0, 255)

SWEP.IronSightStruct = {
    Pos = Vector(0, -4, 1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 90,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "duel"
SWEP.HoldtypeSights = ""


SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -5, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, -14,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-25, 0, 0)

SWEP.ReloadPos = Vector(0, -10, -5)

SWEP.CustomizePos = Vector(-0.5, -8, -4.897)
SWEP.CustomizeAng = Angle(30, 0, 0)

SWEP.BarrelLength = 60
SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(3, 0, -3)
SWEP.DefaultElements = {"dc17", "dc17+"}

SWEP.AttachmentElements = {
    ["dc17"] = {
        VMElements = {
            {
                Model = "models/weapon/ven/ggn/dc17s_single.mdl",
                Bone = "ReaperShot1",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-16.912, -2, 3.986),
                    ang = Angle(0, -20, 90)
                }
            }
        },
    },
    ["dc17+"] = {
         VMElements = {
            {
                Model = "models/weapon/ven/ggn/dc17s_single.mdl",
                Bone = "ReaperShot2",
                Scale = Vector(1.1, 1.1, 1.1),                
                Offset = {
                    pos = Vector(-16.912, -0.872, 3.986),
                    ang = Angle(0, -20, 90)
                }
            }
        }, 
        WMElements = {
            {
                Model = "models/weapon/ven/ggn/dc17s_single_world.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(30, 15, -10),
                    ang = Angle(180, -180, 2)
                }
            },
            {
                Model = "models/weapon/ven/ggn/dc17s_single_world.mdl",
                Bone = "ValveBiped.Bip01_L_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(-50, 230, -55),
                    ang = Angle(180, -180, 2)
                }
            },
        },            -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}
WMOverride = "models/weapon/ven/ggn/dc17s_single_world.mdl"

--SWEP.Attachments 
SWEP.Attachments = {   
    [1] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    }
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["bash"] = {
        Source = "bash"
    },
    ["fire"] = {
        Source = {"shoot", "shoot2"},
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_10.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 0.5}, 
            {s = "weapons/reapershotsound/draw.wav", t = 2}
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "weapons/reapershotsound/throw.wav"
    }),
}
--addons/joes_stuff/lua/weapons/shield_deployer_2/shared.lua:
AddCSLuaFile()

SWEP.Base = "shield_deployer_base"
SWEP.PrintName = "Shield Level 2 Deployer"
SWEP.Category = "AOCRP - Schilde"

SWEP.Author = "Joe"
SWEP.Purpose = "Deploy Shields"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true


SWEP.ENT_CLASS = "shield_2"
--addons/joes_stuff/lua/weapons/shield_deployer_3/shared.lua:
AddCSLuaFile()

SWEP.Base = "shield_deployer_base"
SWEP.PrintName = "Shield Level 3 Deployer"
SWEP.Category = "AOCRP - Schilde"

SWEP.Author = "Joe"
SWEP.Purpose = "Deploy Shields"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true


SWEP.ENT_CLASS = "shield_3"
--addons/weapon_jedi/lua/weapons/vibrosword.lua:
-- this script will add a pre-assembled lightsaber to your q-menu

AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS("weapon_lscs")

SWEP.Category = "[LSCS]"
SWEP.PrintName = "BX Vibroklinge"
SWEP.Author = "Rino"

SWEP.Slot = 3
SWEP.SlotPos = 0

SWEP.Spawnable = true
SWEP.AdminOnly = false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables(self)

	if SERVER then
		self:SetHiltR("bx1")
		self:SetBladeR("bx1blade")
		self:SetStance("bx")
	end
end
--addons/weapon_jedi/lua/weapons/weapon_lightsaber_ahsoka.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS("weapon_lscs")

SWEP.Category = "[LSCS]"
SWEP.PrintName = "Ahsoka Tano"
SWEP.Author = "Deltaa"

SWEP.Slot = 0
SWEP.SlotPos = 3

SWEP.Spawnable = true
SWEP.AdminOnly = false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables(self)

	if SERVER then
		self:SetHiltR("ahsokaright")
		self:SetBladeR("ahsokarighti")

        self:SetHiltL("ahsokaleft")
        self:SetBladeL("ahsokalefti")

        self:SetStance("jarkai")
	end
end

if CLIENT then return end 

function SWEP:ForcePowersGive(ply)
	ply:lscsWipeInventory()

	ply:lscsAddInventory("item_force_leap", true)
    ply:lscsAddInventory("item_force_push", true)
	ply:lscsAddInventory("item_force_pull", true)
    ply:lscsAddInventory("item_force_sprint", true)
    ply:lscsAddInventory("item_force_breach", true)
    ply:lscsAddInventory("item_force_mindtrick", true)
    ply:lscsAddInventory("item_force_unarm", true)
    ply:lscsAddInventory("item_force_whirlwind", true)
end

function SWEP:Deploy() 
	BaseClass.Deploy(self)
	if not IsValid(self:GetOwner()) then return end

    self:GetOwner():lscsWipeInventory()

	self:ForcePowersGive(self:GetOwner())
end
--addons/weapon_jedi/lua/weapons/weapon_lightsaber_kenobi.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS("weapon_lscs")

SWEP.Category = "[LSCS]"
SWEP.PrintName = "Obi-Wan Kenobi"
SWEP.Author = "Deltaa"

SWEP.Slot = 0
SWEP.SlotPos = 3

SWEP.Spawnable = true
SWEP.AdminOnly = false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables(self)

	if SERVER then
		self:SetHiltR("kenobi")
		self:SetBladeR("blue")
	end
end

if CLIENT then return end

function SWEP:ForcePowersGive(ply)
	ply:lscsAddInventory("item_force_leap", true)
	ply:lscsAddInventory("item_force_push", true)
    ply:lscsAddInventory("item_force_pull", true)
    ply:lscsAddInventory("item_force_rockthrow", true)
    ply:lscsAddInventory("item_force_throw", true)
    ply:lscsAddInventory("item_force_sprint", true)
    ply:lscsAddInventory("item_force_breach", true)
    ply:lscsAddInventory("item_force_mindtrick", true)
    ply:lscsAddInventory("item_force_unarm", true)
    ply:lscsAddInventory("item_force_whirlwind", true)

	ply:lscsAddInventory("item_stance_soresu", true)
	ply:lscsAddInventory("item_stance_shiicho", true)
end

function SWEP:Deploy() 
	BaseClass.Deploy(self)
	if not IsValid(self:GetOwner()) then return end

    self:GetOwner():lscsWipeInventory()

	self:ForcePowersGive(self:GetOwner())
end
--addons/aoc_nextbots/lua/weapons/weapon_npc_droideka.lua:
AddCSLuaFile()

SWEP.Base   = "weapon_summes_npcbase"

SWEP.PrintName = "NPC: Droideka"
SWEP.Spawnable = false
SWEP.Author = "Summe"

SWEP.WorldModel = false
SWEP.Weight = 3

SWEP.NextShoot = 0.025
SWEP.Tracer = "effect_npc_laser_red"
SWEP.ImpactEffect = "rw_sw_impact_red"
SWEP.Sound = "summe/nextbots/droids/droideka/blaster.mp3"
SWEP.ClipSize = 40
SWEP.Damage = 20
SWEP.Spread = 0.05
--addons/aoc_nextbots/lua/entities/aocrp_nextbot_b2_jetpack.lua:
AddCSLuaFile()

ENT.Base = "summe_nextbot"
ENT.PrintName = "B2 Superkampfdroide (Jetpack)"
ENT.Category = "AOCRP | Nextbots"
ENT.Spawnable = false
ENT.AdminOnly = false

ENT.Model = "models/player/hydro/b2_battledroid/b2_battledroid.mdl"
ENT.Weapon = "weapon_npc_b2"
ENT.HP = 800
ENT.ShootingRange = 800
ENT.LooseRadius = 4000
ENT.Proficiency = 0.2
ENT.Speed = 60

ENT.Scale = 1.15

ENT.ThrowGrenades = false
ENT.Grenades = {"summe_gr_impact"}

ENT.Sounds = {
    ["killed"] = {
        "aoc/nextbot/b2/killed/death1.wav",
        "aoc/nextbot/b2/killed/death2.wav"
    },

    ["attacking"] = {
        "aoc/nextbot/b2/attack/nimm-das.wav",
        "aoc/nextbot/b2/attack/problem-geloest.wav"
    },
}

ENT.Anims = {
    ["shoot"] = {"idle_pistol"},
    ["reload"] = {"reload_pistol"},
    ["walk_slow"] = {"menu_walk"},
    ["walk_fast"] = {"menu_walk"},
    ["melee"] = {"swing"},
    ["jump"] = {"swimming_all"}
}

function ENT:DoConfrontEnemy(ent)
    if not ent or not IsValid(ent) then return end

    local shootRange, inRange = self:EnemyInRange()

    if shootRange then
        if self.Path:IsValid() then
            self:PathFollowerStop()
        end

        if self:GetNetVar("IsInAir", false) and math.random(0, 100) > 95 then
            self:ShootMissle()
            return
        end

        self:ShootEnemy()

        self.loco:FaceTowards(ent:GetPos())
    else
        if not inRange then
            self:SetEnemy(nil)
            self:GetNewEnemy()
            return
        end

        if self.IsJetBoosting then return end

        if math.random(0, 100) >= 50 then
            self.IsJetBoosting = true
            self:JumpTo(ent:GetPos())

            timer.Simple(2, function()
                self.IsJetBoosting = false
            end)
        else
            self:RunTo(ent:GetPos(), self.Speed * 3)
        end
    end
end

function ENT:ShootMissle()
    if IsValid(self.Missle) then return end
    local enemy = self:GetEnemy()
    if not enemy then return end

    self:EmitSound("weapons/rocket launcher/explosive_rocketlauncher_corebass_close_var_03.mp3", 100, 100, 1, CHAN_WEAPON)

    self.Missile = ents.Create("summe_b2missle")
    self.Missile:SetPos(self:EyePos())
    self.Missile:SetAngles(self:EyeAngles())
    self.Missile:SetOwner(self)
    self.Missile:Spawn()

    local pos = enemy:EyePos() - self:EyePos()
    pos = pos + Vector(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10))
    self.Missile.flightvector = pos:GetNormalized() * 100
end

function ENT:OnNPCSpawn()
    self.loco:SetGravity(70)
    self.loco:SetStepHeight(40)
    self.loco:SetDeathDropHeight(1000)
end

if SERVER then
    function ENT:Think()
        if not self.loco:IsOnGround() then
            self:SetNetVar("IsInAir", true)
        end
    end

    function ENT:OnLandOnGround()
        self:SetNetVar("IsInAir", false)
    end
end

if CLIENT then
    local MaterialGlow = Material("sprites/light_glow02_add")
    local ColorGlow = Color(255,174,0)

    function ENT:Draw()
        self:DrawModel()

        if not self.JetPackSound then
            self.JetPackSound = CreateSound(self, "thrusters/jet02.wav")
            self.JetPackSound:SetSoundLevel(80)
        end

        if self:GetNetVar("IsInAir", false) then
            self:DrawJetpackFire()

            self.JetPackSound:PlayEx(0.5, 125)
        else
            self.JetPackSound:FadeOut(0.1)
        end
    end

    local MatFire = Material( "effects/fire_cloud1" )

    local JetpackFireBlue = Color( 0 , 0 , 255 , 128 )
    local JetpackFireWhite = Color( 255 , 255 , 255 , 128 )
    local JetpackFireNone = Color( 255 , 255 , 255 , 0 )

    function ENT:DrawJetpackFire()
        local forwardA = self:GetAngles()
        forwardA.pitch = 0

        local normal = Vector(0, 0, -1)
        local pos = self:GetPos() + Vector(0, 0, 40) + forwardA:Forward() * -10
        local scale = 0.25

        local scroll = 1000 + UnPredictedCurTime() * -10

        --the trace makes sure that the light or the flame don't end up inside walls
        --although it should be cached somehow, and only do the trace every tick

        local tracelength = 50

        render.SetMaterial( MatFire )

        render.StartBeam( 3 )
            render.AddBeam( pos, 8 * scale , scroll , JetpackFireBlue )
            render.AddBeam( pos + normal * 60 * scale , 32 * scale , scroll + 1, JetpackFireWhite )
            render.AddBeam( pos + normal * tracelength , 32 * scale , scroll + 3, JetpackFireNone )
        render.EndBeam()

        render.SetMaterial( MatFire )

        render.StartBeam( 3 )
            render.AddBeam( pos, 100 * scale , scroll , JetpackFireBlue )
            render.AddBeam( pos + normal * 60 * scale , 40 * scale , scroll + 1, JetpackFireWhite )
            render.AddBeam( pos + normal * tracelength , 32 * scale , scroll + 3, JetpackFireNone )
        render.EndBeam()

        render.SetMaterial(MaterialGlow)
        render.DrawSprite(pos, 75, 75, ColorGlow)
    end

    function ENT:OnRemove()
        if SERVER then
            AOCRPNextbots.Cache[self] = nil
        end

        if self.JetPackSound then
            self.JetPackSound:Stop()
        end
    end
end
--addons/arccw_weapons/lua/entities/arccw_rocket_he/shared.lua:
ENT.Type 				= "anim"
ENT.Base 				= "base_entity"
ENT.PrintName 			= "RPG-7 HE Round"
ENT.Author 				= ""
ENT.Information 		= ""

ENT.Spawnable 			= false


AddCSLuaFile()

ENT.Model = "models/items/ar2_grenade.mdl"
ENT.Ticks = 0
ENT.FuseTime = 4.5

if SERVER then

function ENT:Initialize()
    local pb_vert = 1
    local pb_hor = 1
    self:SetModel(self.Model)
    self:PhysicsInitBox( Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor) )

    local phys = self:GetPhysicsObject()
    if phys:IsValid() then
        phys:Wake()
        phys:EnableGravity(false)
    end

    self.SpawnTime = CurTime()
    self.motorsound = CreateSound( self, "weapons/rpg/rocket1.wav")
    self.motorsound:Play()

    timer.Simple(0.1, function()
        if !IsValid(self) then return end
        self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
    end)
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:OnRemove()
    self.motorsound:Stop()
end

end

function ENT:Think()
    if SERVER then
        local phys = self:GetPhysicsObject()
        phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )

        if self.SpawnTime + self.FuseTime <= CurTime() then
            self:Detonate()
        end
    else
        if self.Ticks % 5 == 0 then
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end
            if !IsValid(emitter) then return end

            local smoke = emitter:Add("particle/particle_smokegrenade", self:GetPos())
            smoke:SetVelocity( VectorRand() * 25 )
            smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
            smoke:SetDieTime( math.Rand(1.5, 2.0) )
            smoke:SetStartAlpha( 255 )
            smoke:SetEndAlpha( 0 )
            smoke:SetStartSize( 0 )
            smoke:SetEndSize( 100 )
            smoke:SetRoll( math.Rand(-180, 180) )
            smoke:SetRollDelta( math.Rand(-0.2,0.2) )
            smoke:SetColor( 20, 20, 20 )
            smoke:SetAirResistance( 5 )
            smoke:SetPos( self:GetPos() )
            smoke:SetLighting( false )
            emitter:Finish()
        end

        self.Ticks = self.Ticks + 1
    end
end

function ENT:Detonate()
    if !self:IsValid() then return end
    local effectdata = EffectData()
        effectdata:SetOrigin( self:GetPos() )

    if self:WaterLevel() >= 1 then
        util.Effect( "WaterSurfaceExplosion", effectdata )
        self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
    else
        util.Effect( "Explosion", effectdata)
        self:EmitSound("phx/kaboom.wav", 125, 100, 1, CHAN_AUTO)
    end

    local attacker = self

    if self.Owner:IsValid() then
        attacker = self.Owner
    end

    util.BlastDamage(self, attacker, self:GetPos(), 550, 110)

    self:FireBullets({
        Attacker = attacker,
        Damage = 0,
        Tracer = 0,
        Distance = 20000,
        Dir = self:GetVelocity(),
        Src = self:GetPos(),
        Callback = function(att, tr, dmg)
            util.Decal("Scorch", tr.StartPos, tr.HitPos - (tr.HitNormal * 16), self)
        end
    })

    self:Remove()
end

function ENT:PhysicsCollide(colData, collider)
    self:Detonate()
end

function ENT:Draw()
    cam.Start3D() -- Start the 3D function so we can draw onto the screen.
        render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
        render.DrawSprite( self:GetPos(), math.random(100, 200), math.random(100, 200), Color(255, 175, 150) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
    cam.End3D()
end
--addons/arccw_weapons/lua/entities/arccw_thr_flash.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.PrintName = "Fragnade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE

ENT.Model = "models/arccw/meeks/flash_grenade.mdl"
ENT.FuseTime = 3.5
ENT.ArmTime = 0
ENT.Armed = true
ENT.ImpactFuse = false
ENT.TrailColor = Color(255, 247, 0, 255)
ENT.TrailTexture = "sprites/bluelaser1" -- this is exactly the one hl2 frag uses. Why blue? idk blame gaben

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.SpawnTime = CurTime()

        if self.FuseTime <= 0 then
            self:Detonate()
        end

        self.SpawnTime = CurTime()
        self.Trail = util.SpriteTrail(self, 0, self.TrailColor, false, 4, 0, 0.5, 4, self.TrailTexture or "sprites/bluelaser1")
        if IsValid(self.Trail) then
            self.Trail:SetRenderMode(RENDERMODE_TRANSADD)
            self.Trail:SetRenderFX(kRenderFxNone)
        end

        timer.Simple(0, function()
            if !IsValid(self) then return end
            self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
        end)
    end
    util.PrecacheSound("misc/BEEPTimer_Anticipation Beeps_01.wav")

    -- Play the sound when the entity is spawned
    self:EmitSound("misc/BEEPTimer_Anticipation Beeps_01.wav")
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
            self:EmitSound(Sound("weapons/grenades/wpn_fraggrenade_1p_hardsurface_bounce_01_lr_v" .. math.random(1,2) .. ".wav"))
        elseif data.Speed > 25 then
            self:EmitSound(Sound("weapons/grenades/grenade_bounce_2ch_v2_0" .. math.random(1,3) .. ".wav"))
        end

        if (CurTime() - self.SpawnTime >= self.ArmTime) and self.ImpactFuse then
            self:Detonate()
        end
    end
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:FlashBang()
    if !self:IsValid() then return end
    self:EmitSound("arccw_go/flashbang/flashbang_explode1.wav", 100, 100, 1, CHAN_ITEM)
    self:EmitSound("arccw_go/flashbang/flashbang_explode1_distant.wav", 140, 100, 1, CHAN_WEAPON)

    local attacker = self

    if self:GetOwner():IsValid() then
        attacker = self:GetOwner()
    end

    util.BlastDamage(self, attacker, self:GetPos(), 64, 10)

    local effectdata = EffectData()
    effectdata:SetOrigin( self:GetPos() )

    util.Effect( "arccw_flashexplosion", effectdata)

    local flashorigin = self:GetPos()

    local flashpower = 800
    local targets = ents.FindInSphere(flashorigin, flashpower)

    for _, k in pairs(targets) do
        if k:IsPlayer() then
            local dist = k:EyePos():Distance(flashorigin)
            local dp = (k:EyePos() - flashorigin):Dot(k:EyeAngles():Forward())

            local time = Lerp( dp, 2.5, 0.25 )

            time = Lerp( dist / flashpower, time, 0 )

            if k:VisibleVec( flashorigin ) then
                k:ScreenFade( SCREENFADE.IN, Color( 255, 255, 255, 255 ), 2.5, time )
            end

            k:SetDSP( 37, false )

        elseif k:IsNPC() then

            k:SetNPCState(NPC_STATE_PLAYDEAD)

            if timer.Exists( k:EntIndex() .. "_arccw_flashtimer" ) then
                timer.Remove( k:EntIndex() .. "_arccw_flashtimer" )
            end

            timer.Create( k:EntIndex() .. "_arccw_flashtimer", 10, 1, function()
                if !k:IsValid() then return end
                k:SetNPCState(NPC_STATE_ALERT)
            end)

        end
    end
end

function ENT:Detonate()
    if !self:IsValid() or self:WaterLevel() > 2 then return end
    if !self.Armed then return end

    self.Armed = false

    self:FlashBang()

    self:Remove()
end

function ENT:DrawTranslucent()
    self:Draw()
end

function ENT:Draw()
    self:DrawModel()
end
--addons/arccw_weapons/lua/entities/arccw_thr_inc/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Incendiary Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/tfa_starwars/w_incendiary.mdl"
ENT.FuseTime = 5
ENT.ArmTime = 0
ENT.FireTime = 15
ENT.ImpactFuse = true

ENT.Armed = false

ENT.NextDamageTick = 0

ENT.Ticks = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.SpawnTime = CurTime()

        timer.Simple(0, function()
            if !IsValid(self) then return end
            self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
        end)
    end
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        self:Detonate()
    end
end

function ENT:Think()
    if !self.SpawnTime then self.SpawnTime = CurTime() end

    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime and !self.Armed then
        self:Detonate()
    end

    if CLIENT then
        local emitter = ParticleEmitter(self:GetPos())

        if !self:IsValid() or self:WaterLevel() > 2 then return end
        if !IsValid(emitter) then return end



        emitter:Finish()

        self.Ticks = self.Ticks + 1
    end
end

function ENT:Detonate()
    if self.Exploded then return end
    self.Exploded = true
    self:EmitSound("arccw/inc/inc_detonate_1.wav", 75, 100, 1, CHAN_ITEM)
    self:EmitSound("arccw/inc/inc_detonate_main_far.wav", 100, 100, 1, CHAN_WEAPON)

    local cloud = ents.Create( "fire" )

    if !IsValid(cloud) then return end

    local vel = Vector(math.Rand(-1, 1), math.Rand(-1, 1), math.Rand(-1, 1)) * 1500

    cloud.Order = i
    cloud:SetPos(self:GetPos() - (self:GetVelocity() * FrameTime()) + VectorRand())
    cloud:SetAbsVelocity(vel + self:GetVelocity())
    cloud:SetOwner(self:GetOwner())
    cloud:Spawn()


    self:Remove()
end

function ENT:DrawTranslucent()
    self:Draw()
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()

        --cam.Start3D()
           -- render.SetMaterial( Material("sprites/orangeflare1") ) 
           -- render.DrawSprite( self:GetPos(), math.random(75, 100), math.random(75, 100), Color(255, 255, 255) ) 
        --cam.End3D()
    end
end
--addons/arccw_weapons/lua/entities/geo_sonic_wave/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Sonic Projectile"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/thermaldetonator_thrown.mdl"
ENT.FuseTime = 3
ENT.ArmTime = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
	phys:SetMass(3)
            phys:SetBuoyancyRatio(0)
            phys:EnableGravity( false )
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/star_wars_battlefront/cw/wpn_spderwalker_laser_lp.wav")
    end

    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
    if self.at <= CurTime() then
        self:Detonate()
    elseif self.at > CurTime() then
        -- local effectdata = EffectData()
            -- effectdata:SetOrigin( self:GetPos() )
        -- util.Effect( "RPGShotDown", effectdata)
        -- util.Effect( "StunstickImpact", effectdata)
        -- self:Remove()
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:Think()

    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        if self.Armed then
		-- ParticleEffectAttach( "astw2_swbf_muzzle_rep_sniper", PATTACH_POINT_FOLLOW, self, 0 )
		local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end
		if self:IsValid() then
		local smoke = emitter:Add("effects/swbf/flare4", self:GetPos())
        smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
        smoke:SetVelocity( self:GetAngles():Forward() * 100 )
        smoke:SetDieTime( math.Rand(0.2,0.3) )
        smoke:SetStartAlpha( 40 )
        smoke:SetEndAlpha( 0 )
        smoke:SetStartSize( 10 )
        smoke:SetEndSize( 80 )
        smoke:SetRoll( math.Rand(-180, 180) )
        smoke:SetRollDelta( math.Rand(-0.2,0.2) )
        smoke:SetColor( math.random(125,150), 255, math.random(45,75) )
        smoke:SetAirResistance( 50 )
        smoke:SetPos( self:GetPos() )
        smoke:SetLighting( false )
        emitter:Finish()
		return 1 
        end
    end
end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_cis_launcher", self:GetPos(), self:GetAngles() )
					sound.Play( "weapons/star_wars_battlefront/cw/wpn_cis_sonicblaster_fire.wav",  self:GetPos(), 55, 100 )

        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        	 -- util.BlastDamage(self, self.Owner, self:GetPos(), 65, 100)
	 local ent = self.Owner
	if !IsValid(ent) then ent = self end
	 local t = DamageInfo()
			t:SetDamage(55)
			t:SetDamageType(DMG_SHOCK)
			t:SetAttacker(ent)
			t:SetInflictor(self)
	util.BlastDamageInfo(t, self:GetPos(), 128)
	  -- local targets = ents.FindInSphere(self:GetPos(), 256)
        -- for _, k in pairs(targets) do
            -- if k:IsPlayer() or k:IsNPC() or scripted_ents.IsBasedOn( k:GetClass(), "base_nextbot" ) then
                -- local regen = FrameTime() * 900
                -- k:SetHealth( math.Clamp( k:Health() - regen, 0, k:GetMaxHealth()+k:GetMaxHealth() ) )
				-- if(SERVER) then
				-- k:Ignite( 10 )
				-- end
			-- if !k:IsPlayer() or !k:IsNPC() then
				-- end
            -- end
        -- end
        self:Remove()

    end
end

function ENT:Draw()
    if CLIENT then
        -- self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/swbf/flare0") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(32, 64), math.random(32, 64), Color(175, 255, 100,25) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            -- ParticleEffectAttach( "astw2_swbf_muzzle_imp_sniper", PATTACH_POINT_FOLLOW, self, 0 )
			cam.End3D()
        end
    end
end
--addons/tools/lua/entities/gmod_contr_spawner/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self.BaseClass.Draw(self)
	self.Entity:DrawModel()
end

--addons/tools/lua/entities/gmod_contr_spawner/shared.lua:
ENT.Type 			= "anim"
ENT.Base			= WireLib and "base_wire_entity" or "base_gmodentity"
ENT.PrintName		= "Contraption Spawner"
ENT.Author			= "TB"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

--addons/lvs_addons/lua/entities/hmp_concussionmissile.lua:
AddCSLuaFile()

ENT.Base = "lvs_protontorpedo"

ENT.Type            = "anim"

ENT.PrintName = "HMP Concussion Missile"
ENT.Author = "Luna"
ENT.Information = "sprengt dir ein zweites arschloch"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true

ENT.ExplosionEffect = "hmp_concussion_explosion"
ENT.GlowColor = Color( 255,255,255 )

if SERVER then
	function ENT:GetDamage() return
		(self._dmg or 400)
	end

	function ENT:GetRadius() 
		return (self._radius or 100)
	end

	return
end

ENT.GlowMat = Material( "sprites/light_glow02_add" )

function ENT:Enable()	
	if self.IsEnabled then return end

	self.IsEnabled = true

	self.snd = CreateSound(self, "npc/combine_gunship/gunship_crashing1.wav")
	self.snd:SetSoundLevel( 80 )
	self.snd:Play()

	local effectdata = EffectData()
		effectdata:SetOrigin( self:GetPos() )
		effectdata:SetEntity( self )
	util.Effect( "hmp_concussion_trail", effectdata )
end

function ENT:Draw()
	if not self:GetActive() then return end

	self:DrawModel()

	render.SetMaterial( self.GlowMat )

	local pos = self:GetPos()
	local dir = self:GetForward()

	for i = 0, 30 do
		local Size = ((15 - i) / 30) ^ 2 * 128

		render.DrawSprite( pos - dir * i * 7, Size, Size, self.GlowColor )
	end
end
--addons/arccw_weapons/lua/entities/ion_throwed/shared.lua:
ENT.Type 			= "anim"  
ENT.PrintName			= "Ion Throwed"  
ENT.Spawnable			= false
ENT.AdminSpawnable		= false

--local rSound = Sound("Missile.Accelerate")

if SERVER then
	AddCSLuaFile( "shared.lua" )

	function ENT:Initialize()   

		self.flightvector = self.Entity:GetForward() * ((30*15.5)/2)
		self.timeleft = CurTime() + 2
		self.Owner = self:GetOwner()
		self.Entity:SetModel( "models/weapons/star_wars_battlefront/thermaldetonator_thrown.mdl" )
		self.Entity:PhysicsInit( SOLID_VPHYSICS )	
		self.Entity:SetMoveType( MOVETYPE_NONE )
		self.Entity:SetSolid( SOLID_VPHYSICS )
		--self.Entity:EmitSound(rSound, 75, 100)
		self.Entity:SetNWBool("smoke", 10, true)
	end   

	function ENT:Think()

			if self.timeleft < CurTime() then
				self:Explosion()
				self.Entity:Remove()
			end

		Table	={} 			//Table name is table name
		Table[1]	=self.Owner 		//The person holding the gat
		Table[2]	=self.Entity 		//The cap

		local trace = {}
			trace.start = self.Entity:GetPos()
			trace.endpos = self.Entity:GetPos() + self.flightvector
			trace.filter = Table
		local tr = util.TraceLine( trace )
		

			if tr.HitSky then
				self:Explosion()
				self.Entity:Remove()
				return true
			end

			local dmg = math.Rand( 250, 275 )
			util.BlastDamage(self.Entity, self:OwnerGet(), tr.HitPos, 15, dmg)
		
			if tr.Hit then
					local effectdata = EffectData()
						effectdata:SetOrigin(tr.HitPos)
						effectdata:SetNormal(tr.HitNormal)
						--effectdata:SetEntity(self.Entity)
						effectdata:SetScale(3)
						effectdata:SetRadius(tr.MatType)
						effectdata:SetMagnitude(18)
						util.Effect( "ion_exp_effect", effectdata )
						--util.BlastDamage(self.Entity, self:OwnerGet(), tr.HitPos, 500, dmg)
						util.Decal("Scorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)
						self.Entity:SetNWBool("smoke", false)
				self:Explosion()
				self.Entity:Remove()	
			end
		
		self.Entity:SetPos(self.Entity:GetPos() + self.flightvector)
		self.flightvector = self.flightvector - (self.flightvector/1500)  + Vector(math.Rand(-0.2,0.2), math.Rand(-0.2,0.2),math.Rand(-0.2,0.2)) + Vector(0,0,-0.05)
		self.Entity:SetAngles(self.flightvector:Angle() + Angle(0,0,0))
		self.Entity:NextThink( CurTime() )
		return true
	end
	
	function ENT:Explosion()
		self:EmitSound("everfall/explosions/ion/destruction_explosions_modular_medium_bigion_discharge_close_var_01.mp3", 500, 100)	
		for k, v in pairs( ents.FindInSphere( self:GetPos(), 130 ) ) do
			if IsValid( v ) then
				if v.LFS then
					v:StopEngine()
					v:SetShield(0)
					v:SetHP( v:GetHP()/10 )
				end
				if v.LVS then
					v:StopEngine()
					v:SetShield(0)
					v:SetHP( v:GetHP()/10 )
				end
				if v:IsPlayer() or v:IsNPC() then
					damage = DamageInfo()
					damage:SetDamage( 5000000 )
					damage:SetAttacker( self:GetOwner() )
					damage:SetDamageType( DMG_DISSOLVE )
					v:TakeDamageInfo( damage )
				end
			end 
	end
end

function ENT:OwnerGet()
	if IsValid(self.Owner) then
		return self.Owner
	else
		return self.Entity
	end
end

end

if CLIENT then

    function ENT:Draw()
     pos = self:GetPos()
     render.SetMaterial(Material("particle/particle_glow_04_additive"))
     render.DrawSprite(pos, 30, 30, Color(255, 255, 0))
     render.SetMaterial(Material("particle/particle_glow_04_additive"))
     render.DrawSprite(pos, 15, 15, Color(255, 255, 0))
     render.SetMaterial(Material("particle/particle_glow_04_additive"))
     render.DrawSprite(pos, 5, 5, Color(255, 255, 0))
    end
 
    function ENT:Initialize()
        pos = self:GetPos()
        self.emitter = ParticleEmitter( pos )
    end
 
    function ENT:Think()
    end

end
--addons/weapon_joe_fort/lua/entities/joefort_ressource_1000/cl_init.lua:
include('shared.lua')

--lua/entities/ls_base_mine/cl_init.lua:
include("shared.lua")

--addons/weapon_jedi/lua/entities/lscs_hilt_base.lua:
AddCSLuaFile()

ENT.Base = "lscs_pickupable"
DEFINE_BASECLASS( "lscs_pickupable" )

ENT.Spawnable       = false
ENT.AdminSpawnable  = false

ENT.PickupSound = "physics/metal/weapon_impact_soft3.wav"
ENT.ImpactHardSound = "weapon.ImpactHard"
ENT.ImpactSoftSound = "weapon.ImpactSoft"

if SERVER then
	function ENT:Initialize()
		self:SetModel( self.MDL )
		BaseClass.Initialize( self )
	end
end
--addons/weapon_jedi/lua/entities/lscs_projectile.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false

ENT.AutomaticFrameAdvance = true
ENT.RenderGroup = RENDERGROUP_BOTH 

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "SWEP" )
end

if SERVER then
	function ENT:Initialize()
		self:SetModel( "models/lscs/saber_throw.mdl" )

		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:SetCollisionGroup( COLLISION_GROUP_NONE )

		local SWEP = self:GetSWEP()

		SWEP:SetActive( true )
		SWEP:SetProjectile( self )
		SWEP:CancelCombo( 100 )
		SWEP:SetDMGActive( true )

		self:PlayAnimation( "spin", 2.5 )

		self.SpawnTime = CurTime()
		self.StartThink = true

		self:DrawShadow( false )
	end

	function ENT:ResetProgress()
		self.Time = CurTime() + 1
	end

	function ENT:GetProgress()
		if not self.Time then
			return (2 + math.max(self.SpawnTime - CurTime(),-1)) / 2
		end

		return math.Clamp( (self.Time - CurTime()) / 2,0,1)
	end

	function ENT:CalcMove( ply )
		local FT = FrameTime()

		local ShootPos = ply:GetShootPos() 

		local trace = util.TraceLine( {
			start = ShootPos,
			endpos = ShootPos + ply:EyeAngles():Forward() * 5000,
			mask = MASK_SOLID_BRUSHONLY,
		} )

		local start = ShootPos - Vector(0,0,20)
		local sub = (trace.HitPos + trace.HitNormal * 20) - start
		local dir = sub:GetNormalized()
		local dist = math.min( sub:Length(), 800 )

		local TargetPos = start + dir * (dist * self:GetProgress() * 1.7)

		local MoveSub = TargetPos - self:GetPos()

		local MoveDist = math.min( MoveSub:Length() * 10, self:GetProgress() > 0.5 and 750 or 350 ) -- quick after throw, but slow on return
		local MoveDir = MoveSub:GetNormalized()

		local MoveSpeed = MoveDist * FT

		local Move = MoveDir * MoveSpeed

		self:SetPos( self:GetPos() + Move )

		local A = math.cos( math.rad(self:GetProgress() * 180 ) )
		self:SetAngles( ply:LocalToWorldAngles( Angle( math.min(A * 40,0),0,-A * 20 ) ) )
	end

	function ENT:CalcFP( ply, SWEP )
		local Time = CurTime()

		if (self._nextFP or 0) > Time then return end

		self._nextFP = Time + 1

		ply:lscsTakeForce( 5 )
		SWEP:DrainBP( 12 )

		if ply:lscsGetForce() > 0 then return end

		if not self.Returning then
			self.Returning = true
			ply._lscsThrownSaber:ResetProgress()
		end
	end

	function ENT:Think()
		self:NextThink( CurTime() )

		if self.StartThink then

			local SWEP = self:GetSWEP()

			if IsValid( SWEP ) then
				local ply = SWEP:GetOwner()

				if IsValid( ply ) then
					if not SWEP:GetActive() then
						self:Remove()

						return
					end

					self:CalcMove( ply )
					self:CalcFP( ply, SWEP )
	
					if (CurTime() - self.SpawnTime) > 0.5 then
						local Dist = (ply:GetShootPos() - self:GetPos()):Length()
						if self:GetProgress() <= 0.2 then
							if Dist <= 50 then
								ply:EmitSound("lscs/equip.mp3")
								self:Remove()
							end
						else
							if Dist <= 80 then
								ply:EmitSound("lscs/equip.mp3")
								self:Remove()
							end
						end
					end
				else
					self:Remove()
				end
			else
				self:Remove()
			end

		end

		return true
	end

	function ENT:OnRemove()
		local SWEP = self:GetSWEP()

		if not IsValid( SWEP ) then return end

		SWEP:SetProjectile( NULL )
		SWEP:SetDMGActive( false )
		SWEP:SetNextPrimaryAttack( CurTime() )

		local Active = SWEP:GetActive()

		if Active then
			SWEP:SetHoldType( SWEP:GetCombo().HoldType )
		else
			SWEP:SetHoldType( "normal" )
		end
	end

	function ENT:PlayAnimation( animation, playbackrate )
		playbackrate = playbackrate or 1

		local sequence = self:LookupSequence( animation )

		self:ResetSequence( sequence )
		self:SetPlaybackRate( playbackrate )
		self:SetSequence( sequence )
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end
else
	function ENT:Initialize()
		self.SND = CreateSound( self, "lscs/saber/saberspin_loop.wav" )
		self.SND:Play()
	end

	function ENT:OnRemove()
		if self.SND then
			self.SND:Stop()
		end
	end

	function ENT:Draw()
	end

	function ENT:DrawTranslucent()
		local SWEP = self:GetSWEP()

		if not IsValid( SWEP ) then return end

		self:SetupBones()

		SWEP:DrawWorldModelTranslucent( nil, self )
	end
end
--lua/entities/lvs_av7/shared.lua:
ENT.Type = "anim"
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "AV-7"
ENT.Author = "Dec"
ENT.Information = ""
ENT.Category = "[LVS] SW-Vehicles"

ENT.Spawnable		= true
ENT.AdminSpawnable	= false

ENT.RotorPos = Vector( 338, 0, 214 )

ENT.MDL = "models/helios/vehicles/av7/av7.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}


ENT.AITEAM = 2

ENT.MaxVelocityY = 0
ENT.BoostAddVelocityY = 0

ENT.ForceAngleMultiplier = 4
ENT.ForceAngleDampingMultiplier = 4

ENT.ForceLinearMultiplier = 0
ENT.ForceLinearRate = 0

ENT.MaxVelocityZ = 0
ENT.BoostAddVelocityZ = 0

ENT.MaxHealth = 2500
ENT.MaxShield = 0
ENT.MaxVelocityX = 0
ENT.BoostAddVelocitX = 0
ENT.IgnoreWater = false

ENT.MaxTurnRate = 1

ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

function ENT:InitWeapons()

	self.perst = 0

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 45
	weapon.Delay = 1.2
	weapon.HeatRateUp = 0.6
	weapon.HeatRateDown = 0.3
	weapon.Attack = function( ent )

		if self:GetBodygroup(1) == 1 then return end

		local veh = ent:GetVehicle()
		local Driver = ent:GetDriver()
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		for i = 1, 1 do
			timer.Simple( (i / 2) * 0.2, function()
				if not IsValid( ent ) then return end
				
				if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end
	
				ent:TakeAmmo()

				local ID_1 = self:LookupAttachment( "muzzle" )
				local Muzzle1 = self:GetAttachment( ID_1 )
				
				local Pos = Muzzle1.Pos				
				local Dir =  (Muzzle1.Ang):Up()
				
				local trace = ent:GetEyeTrace()

				local projectile = ents.Create( "lvs_fall_missel" )
				projectile:SetPos(Pos)
				projectile:SetAngles(Dir:Angle())
				projectile:SetParent()
				projectile:Spawn()
				projectile:Activate()
				projectile.GetTarget = function( missile ) return missile end
				projectile.GetTargetPos = function( missile )
					return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-10,10) )
				end
				projectile:SetAttacker( IsValid( Driver ) and Driver or self )
				projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
				projectile:Enable()
				projectile:EmitSound( "vehicle/starwars/av7/av7fire.wav" )

				util.ScreenShake(self:GetPos(), 100, 40, 1, 2000, true )
				for i=1,10 do
					local effectdata = EffectData()
					effectdata:SetOrigin( self:GetPos() )
					effectdata:SetRadius(500 * 500)
					effectdata:SetScale(24 * 20)
					util.Effect( "ThumperDust", effectdata, true, true )
				end
				self:SetPos(self:GetPos() - self:GetForward() * 1.5)
				timer.Simple(1.5, function()
					if IsValid(self) then
						self:SetPos(self:GetPos() + self:GetForward() * 1.5)
					end
				end)
			end)
		end
	end
	weapon.OnThink = function( ent, active )
		self.perst = self.perst + 1

		if self.perst == 4 then
			self.perst = 0
		end

		if self.perst == 0 then
			local Driver = self:GetDriver()

			if self:GetAI() or IsValid( Driver ) then		
				local EyeAngles = Driver:EyeAngles()
				local Yawn =  EyeAngles.y

				local Pitch =  EyeAngles.x
			
				if Pitch > 20 then 
					Pitch = 20
				end

				if Pitch < -50 then 
					Pitch = -50
				end
			
				local Pitch =  Pitch
			
				self:ManipulateBoneAngles(self:LookupBone("gun"), Angle(0, 0, Pitch))
		
			end
		end
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 30) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
	end
	self:AddWeapon( weapon )

	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 25
	weapon.Delay = 0.9
	weapon.HeatRateUp = 0.6
	weapon.HeatRateDown = 0.3
	weapon.Attack = function( ent )

		if self:GetBodygroup(1) == 1 then return end

		local veh = ent:GetVehicle()
		local Driver = ent:GetDriver()

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		for i = 1, 1 do
			timer.Simple( (i / 2) * 0.2, function()
				if not IsValid( ent ) then return end

				if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end
	
				ent:TakeAmmo()
				local ID_1 = self:LookupAttachment( "muzzle" )
				local Muzzle1 = self:GetAttachment( ID_1 )
				
				local Pos = Muzzle1.Pos
				local Dir =  (Muzzle1.Ang):Up()
			
				local projectile = ents.Create( "lvs_protontorpedo" )
				projectile:SetPos(Pos)
				projectile:SetAngles(Dir:Angle())
				projectile:SetParent()
				projectile:Spawn()
				projectile:SetDamage( 550 )
				projectile:SetRadius( 350 )
				projectile:Activate()
				projectile.GetTarget = function( missile ) return missile end
				projectile.GetTargetPos = function( missile )
					return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-1,1) )
				end
				projectile:SetAttacker( IsValid( Driver ) and Driver or self )
				projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
				projectile:Enable()
				projectile:EmitSound( "vehicle/starwars/av7/av7fire.wav" )

				util.ScreenShake(self:GetPos(), 100, 40, 1, 2000, true )
				for i=1,10 do
					local effectdata = EffectData()
					effectdata:SetOrigin( self:GetPos() )
					effectdata:SetRadius(500 * 500)
					effectdata:SetScale(24 * 20)
					util.Effect( "ThumperDust", effectdata, true, true )
				end
				self:SetPos(self:GetPos() - self:GetForward() * 1.5)
				timer.Simple(1.5, function()
					if IsValid(self) then
						self:SetPos(self:GetPos() + self:GetForward() * 1.5)
					end
				end)
			end)
		end
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 30) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnThink = function( ent, active )
		--[[local Driver = self:GetDriver()
		
		if not IsValid( Driver ) then return end
	
		local EyeAngles = Driver:EyeAngles()
	
		local Pitch =  EyeAngles.x
	
		if Pitch > 20 then 
			Pitch = 20
		end
	
		local Pitch =  -Pitch
	
		self:ManipulateBoneAngles(self:LookupBone("gun"), Angle(0, Pitch, 0))]]--
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("weapons/shotgun/shotgun_cock.wav")
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_reardoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function( ent )
		if self:GetAI() == true then return end 
		if (self.gateDown) then
			self.gateDown = false
			self:SetBodygroup(1, 0)
			ent.MaxVelocityY = 0
			ent.BoostAddVelocityY = 0
			ent.MaxVelocityX = 0
			ent.BoostAddVelocitX = 0
			ent.ForceLinearMultiplier = 0
			ent.ForceLinearRate = 0
		else
			self:SetBodygroup(1, 1)
			self.gateDown = true
			ent.MaxVelocityY = 100
			ent.BoostAddVelocityY = 150
			ent.MaxVelocityX = 200
			ent.BoostAddVelocitX = 300	
			ent.ForceLinearMultiplier = 2
			ent.ForceLinearRate = 0.8
		end

		self:EmitSound("lvs/vehicles/laat/door_large_open.wav")
	end
	self:AddWeapon( weapon )
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/iftx/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/iftx/loop_hi.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/iftx/dist.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 90,
	},
}

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-240,0,-120) -- position offset
ENT.LAATC_PICKUP_Angle = Angle(0,180,0) -- angle offset

--addons/lvs_addons/lua/entities/lvs_base_fakehover/sh_camera_eyetrace.lua:

function ENT:GetEyeTrace( trace_forward )
	local startpos = self:LocalToWorld( self:OBBCenter() )

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( pod:OBBCenter() )
	end

	local AimVector = trace_forward and self:GetForward() or self:GetAimVector()

	local data = {
		start = startpos,
		endpos = (startpos + AimVector * 50000),
		filter = self:GetCrosshairFilterEnts(),
	}

	local trace = util.TraceLine( data )

	return trace
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if not IsValid( Driver ) then return self:GetForward() end

	if SERVER then
		local pod = self:GetDriverSeat()

		if not IsValid( pod ) then return Driver:EyeAngles():Forward() end

		return pod:WorldToLocalAngles( Driver:EyeAngles() ):Forward()
	else
		return Driver:EyeAngles():Forward()
	end
end

--addons/lvs_addons/lua/entities/lvs_base_fakehover/cl_camera.lua:

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	return pos, angles, fov
end

function ENT:CalcViewDriver( ply, pos, angles, fov, pod )
	local view = {}
	view.origin = pos
	view.fov = fov
	view.drawviewer = true
	view.angles = ply:EyeAngles()

	if not pod:GetThirdPersonMode() then

		view.drawviewer = false

		return view
	end

	local radius = 550
	radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = view.origin - view.angles:Forward() * radius  + view.angles:Up() * (radius * 0.2 + radius * pod:GetCameraHeight())
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = view.origin,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.origin = tr.HitPos

	if tr.Hit and not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

function ENT:CalcViewPassenger( ply, pos, angles, fov, pod )
	return LVS:CalcView( self, ply, pos, angles, fov, pod )
end

function ENT:LVSCalcView( ply, original_pos, original_angles, original_fov, pod )
	local pos, angles, fov = self:CalcViewOverride( ply, original_pos, original_angles, original_fov, pod )

	if self:GetDriverSeat() == pod then
		return self:CalcViewDriver( ply, pos, angles, fov, pod )
	else
		return self:CalcViewPassenger( ply, pos, angles, fov, pod )
	end
end
--addons/lvs_addons/lua/entities/lvs_concussionmissile.lua:
AddCSLuaFile()

ENT.Base = "lvs_protontorpedo"

ENT.Type            = "anim"

ENT.PrintName = "Concussion Missile"
ENT.Author = "Luna"
ENT.Information = "sprengt dir ein zweites arschloch"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= true

ENT.ExplosionEffect = "lvs_concussion_explosion"
ENT.GlowColor = Color( 255, 40, 100, 255 )

if SERVER then
	function ENT:GetDamage() return
		(self._dmg or 400)
	end

	function ENT:GetRadius() 
		return (self._radius or 150)
	end

	return
end

ENT.GlowMat = Material( "sprites/light_glow02_add" )

function ENT:Enable()	
	if self.IsEnabled then return end

	self.IsEnabled = true

	self.snd = CreateSound(self, "npc/combine_gunship/gunship_crashing1.wav")
	self.snd:SetSoundLevel( 80 )
	self.snd:Play()

	local effectdata = EffectData()
		effectdata:SetOrigin( self:GetPos() )
		effectdata:SetEntity( self )
	util.Effect( "lvs_concussion_trail", effectdata )
end

function ENT:Draw()
	if not self:GetActive() then return end

	self:DrawModel()

	render.SetMaterial( self.GlowMat )

	local pos = self:GetPos()
	local dir = self:GetForward()

	for i = 0, 30 do
		local Size = ((30 - i) / 30) ^ 2 * 128

		render.DrawSprite( pos - dir * i * 7, Size, Size, self.GlowColor )
	end
end
--addons/lvs_addons/lua/entities/lvs_fakehover_aat/sh_turret.lua:

function ENT:SetPoseParameterTurret( weapon )
	if self:GetIsCarried() then
		self:SetPoseParameter("turret_pitch", 0 )
		self:SetPoseParameter("turret_yaw",  0 )

		if self.TurretWasSet then
			self.TurretWasSet = nil

			self:SetTurretPitch( 0 )
			self:SetTurretYaw( 0 )
		end

		return
	end

	self.TurretWasSet = true

	if not IsValid( weapon:GetDriver() ) and not weapon:GetAI() then return end

	local AimAng = weapon:WorldToLocal( weapon:GetPos() + weapon:GetAimVector() ):Angle()
	AimAng:Normalize()

	local AimRate = self.TurretTurnRate * FrameTime() 

	self:SetTurretPitch( math.ApproachAngle( self:GetTurretPitch(), AimAng.p, AimRate ) )
	self:SetTurretYaw( math.ApproachAngle( self:GetTurretYaw(), AimAng.y, AimRate ) )

	self:SetPoseParameter("turret_pitch", self:GetTurretPitch() )
	self:SetPoseParameter("turret_yaw", self:GetTurretYaw() )
end

function ENT:TraceTurret()
	local ID = self:LookupAttachment( "muzzle" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:InitTurret()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = -1
	weapon.Delay = 0.3
	weapon.HeatRateUp = 1.25
	weapon.HeatRateDown = 0.2
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/vehicles/aat/overheat.mp3")
	end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return true end

		local ID = base:LookupAttachment( "muzzle" )
		local Muzzle = base:GetAttachment( ID )

		if not Muzzle then return end

		local bullet = {}
		bullet.Src 	= Muzzle.Pos
		bullet.Dir 	= Muzzle.Ang:Up()
		bullet.Spread 	= Vector(0,0,0)
		bullet.TracerName = "lvs_laser_red_aat"
		bullet.Force	= 16000
		bullet.HullSize 	= 30
		bullet.Damage	= 500
		bullet.SplashDamage = 250
		bullet.SplashDamageRadius = 250
		bullet.Velocity = 6000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion_aat", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Muzzle.Ang:Up() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		base:PlayAnimation( "fire" )

		local PhysObj = base:GetPhysicsObject()
		if IsValid( PhysObj ) then
			PhysObj:ApplyForceOffset( -Muzzle.Ang:Up() * 25000, Muzzle.Pos )
		end

		if not IsValid( base.SNDTurret ) then return end

		base.SNDTurret:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetPoseParameterTurret( ent )
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local ID = base:LookupAttachment( "turret_view" )
		local Att = base:GetAttachment( ID )

		if Att then
			local Pos,_= LocalToWorld( Vector(0,12,30), Angle(0,0,0), Att.Pos, Att.Ang )
			view.origin = Pos
		end

		if not pod:GetThirdPersonMode() then
			return view
		end

		local mn = self:OBBMins()
		local mx = self:OBBMaxs()
		local radius = ( mn - mx ):Length()
		local radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = self:LocalToWorld( Vector(-75,0,140) )
		local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * radius * 0.2

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.angles = angles + Angle(5,0,0)
		view.origin = tr.HitPos

		if tr.Hit and  not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if base:GetIsCarried() then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

--addons/lvs_addons/lua/entities/lvs_fakehover_wheel.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
end

if SERVER then
	function ENT:Initialize()	
		self:SetModel( "models/props_vehicles/tire001c_car.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:DrawShadow( false )

		self:AddEFlags( EFL_NO_PHYSCANNON_INTERACTION )

		self:SetCollisionGroup( COLLISION_GROUP_PASSABLE_DOOR )
	end

	function ENT:Define( data )
		local bbox = Vector(data.radius,data.radius,data.radius)

		self:PhysicsInitSphere( data.radius, "gmod_silent" )
		self:SetCollisionBounds( -bbox, bbox )

		local PhysObj = self:GetPhysicsObject()
		if IsValid( PhysObj ) then
			PhysObj:EnableDrag( false )
			PhysObj:EnableMotion( false )
			PhysObj:SetMass( data.mass )
			PhysObj:SetBuoyancyRatio( data.buoyancyratio )
		end
	end

	function ENT:SetPhysics( enable )
		if enable then
			if self.PhysicsEnabled then return end

			self:GetPhysicsObject():SetMaterial("jeeptire")
			self.PhysicsEnabled = true
		else
			if self.PhysicsEnabled == false then return end

			self:GetPhysicsObject():SetMaterial("friction_00")
			self.PhysicsEnabled = false
		end
	end

	function ENT:CheckPhysics()
		local base = self:GetBase()

		if not IsValid( base ) then return end

		if not base:GetEngineActive() then
			self:SetPhysics( true )

			self:NextThink( CurTime() + 0.25 )

			return
		end

		self:NextThink( CurTime() + 0.1 )

		local Ang = base:GetAngles()
		local steer = math.abs( base:WorldToLocalAngles( Angle(Ang.p,base:GetSteerTo(),Ang.r) ).y )
		local move = base:GetMove()
		local speed = base:GetVelocity():LengthSqr()

		local enable = (math.abs( move.x ) + math.abs( move.y )) < 0.001 and steer < 3 and speed < 600

		self:SetPhysics( enable )
	end

	function ENT:Think()
		self:CheckPhysics()

		return true
	end

	function ENT:OnTakeDamage( dmginfo )
		local base = self:GetBase()

		if not IsValid( base ) then return end

		base:TakeDamageInfo( dmginfo )
	end

	return
end

function ENT:Initialize()
end

function ENT:Think()
	local T = CurTime()

	if (self._nextFX or 0) > T then return end

	self._nextFX = T + 0.02

	local base = self:GetBase()

	if not IsValid( base ) then return end

	if base:GetVelocity():Length() < 50 then return end

	local data = {
		start = self:LocalToWorld( self:OBBCenter() ),
		endpos = self:LocalToWorld( Vector(0,0,self:OBBMins().z - 10 ) ),
		filter = base:GetCrosshairFilterEnts(),
		mask = MASK_WATER
	}

	local traceWater = util.TraceLine( data )

	if not traceWater.Hit then
		return
	end

	local effectdata = EffectData()
		effectdata:SetOrigin( traceWater.HitPos )
		effectdata:SetEntity( base )
		effectdata:SetMagnitude( self:BoundingRadius() )
	util.Effect( "lvs_hover_water", effectdata )
end

function ENT:Draw()
end

function ENT:OnRemove()
end

--addons/lvs_base/lua/entities/lvs_item_ammocrate.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Ammo Crate"
ENT.Information = "Single-Use Ammo Refil Item"
ENT.Author = "Luna"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal * 5 )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:Initialize()	
		self:SetModel( "models/items/item_item_crate.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:PhysWake()
	end

	function ENT:Think()
		return false
	end

	function ENT:Refil( entity )
		if self.MarkForRemove then return end

		if not IsValid( entity ) then return end

		if not entity.LVS then return end

		if entity:WeaponRestoreAmmo() then
			entity:EmitSound("items/ammo_pickup.wav")

			self.MarkForRemove = true

			SafeRemoveEntityDelayed( self, 0 )
		end
	end

	function ENT:PhysicsCollide( data, physobj )
		self:Refil( data.HitEntity )
	end

	function ENT:OnTakeDamage( dmginfo )
	end
end

if CLIENT then
	function ENT:Draw( flags )
		self:DrawModel( flags )
	end

	function ENT:OnRemove()
	end

	function ENT:Think()
	end
end

--addons/lvs_addons/lua/entities/lvs_laatle_patrolgunship_imp/cl_init.lua:
include("shared.lua")


ENT.LightGlow = Material( "sprites/light_glow02_add" )
ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )

function ENT:OnSpawn()
end

function ENT:OnFrame()
	self:AnimFins()
end

function ENT:StartWindSounds()
    self:StopWindSounds()

    if LocalPlayer():lvsGetVehicle() ~= self then return end

    self._WaterSFX = CreateSound( self, "LVS.Physics.Water" )
    self._WaterSFX:PlayEx(0,100)
end

function ENT:AnimFins()
end

function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end
end

function ENT:OnRemoved()
	self:RemoveLight()
end

function ENT:PreDrawTranslucent()
	if self:GetSpotlightToggle() == false then 
		self:RemoveLight()
		return false
	end

	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 10 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 5000 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 40 )
		self.projector = thelamp
	end

	local attachment = {
		Pos = Vector(170,0,30),
		Ang = Angle(135, 0, 0)
	}

	if attachment then
		local StartPos = self:LocalToWorld(attachment.Pos)
		local Dir = self:LocalToWorldAngles(attachment.Ang):Up()

		render.SetMaterial( self.LightGlow )
		render.DrawSprite( StartPos + Dir * 20, 200, 200, Color( 255, 255, 255, 255) )

		render.SetMaterial( self.LightMaterial )
		render.DrawBeam(  StartPos - Dir * 10,  StartPos + Dir * 1500, 350, 0, 0.99, Color( 255, 255, 255, 10) ) 
		
		if IsValid( self.projector ) then
			self.projector:SetPos( StartPos )
			self.projector:SetAngles( Dir:Angle() )
			self.projector:Update()
		end
	end

	return false
end

function ENT:CalcViewOverride(ply, pos, angles, fov, pod)

	if pod ~= self:GetDriverSeat() and pod ~= self:GetGunnerSeat() and not pod:GetThirdPersonMode() then
		return pod:LocalToWorld(Vector(0, 0, 68)), angles, fov
	end

	return pos, angles, fov
end 

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 0, 80, 255 )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "^lvs/vehicles/laat/boost_"..math.random(1,2)..".wav", 85 )
end

function ENT:OnStopBoost()
end
--addons/lvs_addons/lua/entities/lvs_neutralstarfighter_swtor/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Neutral Transporter"
ENT.Author = "Ophra"
ENT.Information = "Neutral Transporter"
ENT.Category = "[LVS] - SWTOR"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/ophra/ships/veh_neu_heavy_utility_starship_no_landing_gear.mdl"
ENT.GibModels = {
	"models/salza/arc170_gib1.mdl",
	"models/salza/arc170_gib2.mdl",
	"models/salza/arc170_gib3.mdl",
	"models/salza/arc170_gib4.mdl",
	"models/salza/arc170_gib5.mdl",
	"models/salza/arc170_gib6.mdl"
}

ENT.AITEAM = 3

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 800
ENT.MaxShield = 100

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )
	self:AddDT( "Entity", "TailGunnerSeat" )

	if SERVER then
		self:NetworkVarNotify( "Foils", self.OnFoilsChanged )
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(207.65,-303.52,-48.35),
		Vector(207.65,303.52,-48.35),
	}
end 

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "ophra/ships/flysound5.wav",
		Volume = 3000,
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}

--addons/laat_g/lua/entities/lvs_repulsorlift_gunship_heavy/shared.lua:

ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "LAAT/g"
ENT.Author = "Luna & Tic"
ENT.Information = "Heavy Close Air Support Gunship of the Galactic Republic"
ENT.Category = "[LVS] - Star Wars"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/laatg.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxVelocity = 1000
ENT.MaxThrust = 1000

ENT.MaxPitch = 60

ENT.ThrustVtol = 200
ENT.ThrustRateVtol = 1

ENT.TurnRatePitch = 0.3
ENT.TurnRateYaw = 0.3
ENT.TurnRateRoll = 0.3

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 15000

ENT.AutomaticFrameAdvance = true

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "BTPodL" )
	self:AddDT( "Entity", "SecondGunnerSeat" )
	self:AddDT( "Entity", "ThirdGunnerSeat" )

	self:AddDT( "Bool", "WingTurretFire" )
	self:AddDT( "Vector", "WingTurretTarget" )

	self:AddDT( "Bool", "BTLFire" )

	self:AddDT( "Bool", "Gunner2Fire" )
	self:AddDT( "Bool", "Gunner3Fire" )

	self:AddDT( "Bool", "LightsActive" )
end

function ENT:InitWeapons()
	self:InitWeaponDriver()
	self:InitWeaponGunner()
	self:InitWeaponBTL()
	self:InitWeaponGunner2()
	self:InitWeaponGunner3()
end

sound.Add( {
	name = "LVS.LAAT.FLYBY",
	sound = {
		"lvs/vehicles/laat/flyby1.wav",
		"lvs/vehicles/laat/flyby2.wav",
		"lvs/vehicles/laat/flyby3.wav",
		"lvs/vehicles/laat/flyby4.wav",
		"lvs/vehicles/laat/flyby5.wav",
	}
} )

ENT.FlyByAdvance = 1
ENT.FlyBySound = "LVS.LAAT.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/laat/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/laat/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 110,
	},
}

function ENT:CalcMainActivity( ply )
	local Pod = ply:GetVehicle()

	if Pod == self:GetDriverSeat() or Pod == self:GetGunnerSeat() then return end

	if ply.m_bWasNoclipping then 
		ply.m_bWasNoclipping = nil 
		ply:AnimResetGestureSlot( GESTURE_SLOT_CUSTOM ) 

		if CLIENT then 
			ply:SetIK( true )
		end 
	end 

	if Pod == self:GetBTPodL() then
		ply.CalcIdeal = ACT_STAND
		ply.CalcSeqOverride = ply:LookupSequence( "drive_jeep" )

		return ply.CalcIdeal, ply.CalcSeqOverride
	end

	ply.CalcIdeal = ACT_STAND
	ply.CalcSeqOverride = ply:LookupSequence( "sit" )

	if ply:GetAllowWeaponsInVehicle() and IsValid( ply:GetActiveWeapon() ) then

		local holdtype = ply:GetActiveWeapon():GetHoldType()

		if holdtype == "smg" then 
			holdtype = "smg1"
		end

		local seqid = ply:LookupSequence( "idle_" .. holdtype )

		if seqid ~= -1 then
			ply.CalcSeqOverride = seqid
		end
	end

	return ply.CalcIdeal, ply.CalcSeqOverride
end

function ENT:CalcVtolThrottle( ply, cmd )
	local Delta = FrameTime()

	local ThrottleZero = self:GetThrottle() <= 0

	local VtolX = 0
	local VtolY = 0
	local VtolZ = ((ply:lvsKeyDown( "+VTOL_Z_SF" ) and 1 or 0) - (ply:lvsKeyDown( "-VTOL_Z_SF" ) and 1 or 0))

	local DesiredVtol = Vector(VtolX,VtolY,VtolZ)
	local NewVtolMove = self:GetNWVtolMove() + (DesiredVtol - self:GetNWVtolMove()) * self.ThrustRateVtol * Delta

	if not ThrottleZero or self:WorldToLocal( self:GetPos() + self:GetVelocity() ).x > 100 then
		NewVtolMove.x = 0
	end

	self:SetVtolMove( NewVtolMove )
end
--addons/lvs_addons/lua/entities/lvs_repulsorlift_gunship_space/shared.lua:
ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "LAAT/i Space"
ENT.Author = "Luna, Deltaa, Fisher"
ENT.Information = "Gunship/Troop Transport of the Galactic Republic"
ENT.Category = "[LVS] - Republik"

ENT.IsLAAT = true

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/fisher/laat/laatspace.mdl"

ENT.MaxHealth = 4000

ENT.AITEAM = 2

ENT.MaxVelocity = 2400
ENT.MaxThrust = 2400

ENT.MaxPitch = 60

ENT.ThrustVtol = 50
ENT.ThrustRateVtol = 2

ENT.TurnRatePitch = 0.7
ENT.TurnRateYaw = 0.7
ENT.TurnRateRoll = 0.7

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "RearHatch")
	self:AddDT("Bool", "WingTurretFire")
	self:AddDT("Bool", "LightsActive")

	self:AddDT("Entity", "GunnerSeat")
	self:AddDT("Entity", "HatchSeat")

	self:AddDT("Int", "DoorMode")
	self:AddDT("Int", "LightsMode")

	self:AddDT("Vector", "WingTurretTarget")
end

function ENT:InitWeapons()
	self:InitDriverWeapons()
	self:InitGunnerWeapons()
end

function ENT:IsSpotlightMounted()
	return self:GetBodygroup(7) == 1
end

ENT.FlyByAdvance = 1
ENT.FlyBySound = "LVS.LAAT.FLYBY"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "laat_bf2/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}

function ENT:CalcMainActivity(ply)
	local Pod = ply:GetVehicle()

	if Pod == self:GetDriverSeat() or Pod == self:GetGunnerSeat() then return end

	if ply.m_bWasNoclipping then
		ply.m_bWasNoclipping = nil
		ply:AnimResetGestureSlot(GESTURE_SLOT_CUSTOM)

		if CLIENT then
			ply:SetIK(true)
		end
	end

	ply.CalcIdeal = ACT_STAND
	ply.CalcSeqOverride = ply:LookupSequence("idle_all_02")

	if ply:GetAllowWeaponsInVehicle() and IsValid( ply:GetActiveWeapon() ) then

		local holdtype = ply:GetActiveWeapon():GetHoldType()

		if holdtype == "smg" then
			holdtype = "smg1"
		end

		local seqid = ply:LookupSequence("idle_" .. holdtype)

		if seqid ~= -1 then
			ply.CalcSeqOverride = seqid
		end
	end

	return ply.CalcIdeal, ply.CalcSeqOverride
end
--lua/entities/lvs_space_laat/shared.lua:

ENT.Base = "lvs_base_repulsorlift"

ENT.PrintName = "LAAT-I Space"
ENT.Author = "Dec"
ENT.Information = "Spaace version of the LAAT"
ENT.Category = "[LVS] SW-Vehicles"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/fisher/laat/laatspace.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.DamageSounds = {
	"physics/metal/metal_sheet_impact_bullet2.wav",
	"physics/metal/metal_sheet_impact_hard2.wav",
	"physics/metal/metal_sheet_impact_hard6.wav",
}

ENT.AITEAM = 2

ENT.MaxVelocity = 2650
ENT.MaxThrust = 2650

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1.25

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 6000
ENT.MaxShield = 0

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "WingTurretFire" )
	self:AddDT( "Vector", "WingTurretTarget" )
	self:NetworkVar( "Int", 23, "LampMode" )
	self:AddDT( "Float", "Activetime" )
	self:AddDT( "Bool", "Foils" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "SecondGunnerSeat" )
	self:NetworkVar( "Bool", 24, "SpotlightOn" )
	self:AddDT( "Bool", "SpotlightToggle" )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "laat_bf2/laat_takeoff.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

function ENT:CalcMainActivity( ply )
	local Pod = ply:GetVehicle()

	if Pod == self:GetDriverSeat() or Pod == self:GetGunnerSeat() then return end

	ply.CalcIdeal = ACT_STAND
	ply.CalcSeqOverride = ply:LookupSequence( "idle_all_02" )

	if ply:GetAllowWeaponsInVehicle() and IsValid( ply:GetActiveWeapon() ) then

		local holdtype = ply:GetActiveWeapon():GetHoldType()

		if holdtype == "smg" then 
			holdtype = "smg1"
		end

		local seqid = ply:LookupSequence( "idle_" .. holdtype )

		if seqid ~= -1 then
			ply.CalcSeqOverride = seqid
		end
	end

	return ply.CalcIdeal, ply.CalcSeqOverride
end

ENT.EngineSounds = {
	{
		sound = "laat_bf2/engine_loop.mp3",
		Pitch = 90,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 85,
	},
	{
		sound = "laat_bf2/laat_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 75,
	},
}

sound.Add( {
	name = "LAAT_FIREMISSILE",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 125,
	pitch = {95, 105},
	sound = "laat_bf2/rocket_shot.mp3"
} )


function ENT:SetNextRearGunFire( delay )
	self._NextRGFire = CurTime() + delay
end

function ENT:CanFireRearGun()
	return (self._NextRGFire or 0) < CurTime()
end

function ENT:GetRearGunInRange( ent )
	return ent:AngleBetweenNormal( ent:GetAimVector(), -ent:GetForward() ) < 35
end

function ENT:HandleRearGun( ent, ShouldFire )

	local trace = ent:GetEyeTrace()

	local Pos,Ang = WorldToLocal( Vector(100,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,180,0) ) )

	if not self:GetRearGunInRange( ent ) then 
		self:SetPoseParameter("back_turret_y", 0 )

		return false
	end

	self:SetPoseParameter("back_turret_z", Ang.p )
	self:SetPoseParameter("back_turret_y", -Ang.y )

	if not ShouldFire or not self:CanFireRearGun() then self:GetRearGunInRange( ent ) return end

	local startpos = self:GetBonePosition(self:LookupBone("Rear_Gun_End"))

	self:SetNextRearGunFire( 0.2 )

	local bullet = {}
	bullet.Src 	= ent:LocalToWorld( Vector(-500,0 ,-20) )
	bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
	bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
	bullet.TracerName = "lvs_laser_green_short"
	bullet.Force	= 10
	bullet.HullSize 	= 25
	bullet.Damage	= 65
	bullet.Velocity = 20000
	bullet.Attacker 	= ent:GetDriver()
	bullet.Callback = function(att, tr, dmginfo)
		local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) ) 
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
		util.Effect( "lvs_laser_impact", effectdata )
	end
	ent:LVSFireBullet( bullet )

	local NewHeat = ent:GetHeat() + 0.2


	ent:SetHeat( NewHeat )
	if NewHeat >= 1 then
		ent:SetOverheated( true )
	end

	if not IsValid( self.SNDTail ) then return end

	self.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( Vector(100,0,103) )
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:InitWeapons()
	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)
	local MaxRange = 60
	local MaxTailRange = 35

	self.lor = 1

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 600
	weapon.Delay = 0.18
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.1
	weapon.Attack = function( ent )
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		if ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= 20 then return true end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = ent:GetEyeTrace()

		local bullet = {}
		bullet.Spread 	= Vector( 0.02,  0.02, 0.02 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 60
		bullet.SplashDamage = 200
		bullet.SplashDamageRadius = 200
		bullet.Velocity = 28000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(50,255,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
	
		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld( Vector(320,32 * i,37) )
			bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
			local effectdata = EffectData()
			effectdata:SetStart( Vector(50,255,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
				
			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )
		local trace = ent:GetEyeTrace()

		local AimAngles = ent:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld(  Vector(256,0,36) ) ):GetNormalized():Angle() )

		ent.frontgunYaw = -AimAngles.y

		if math.abs( ent.frontgunYaw ) > 100 then
			ent:SetPoseParameter("Front_Turret_Z", 0 )
			ent:SetPoseParameter("Front_Turret_Y", 0 )

			return
		end

		ent:SetPoseParameter("Front_Turret_Z", AimAngles.p )
		ent:SetPoseParameter("Front_Turret_Y", -AimAngles.y )
	end
	self:AddWeapon( weapon )

	self:AddWeapon( LVS:GetWeaponPreset( "TURBO" ) )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0.4
	weapon.HeatRateDown = 0
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.StartAttack = function( ent )
		ent.ShouldFire = true
	end
	weapon.FinishAttack = function( ent )
		ent.ShouldFire = false

		local base = ent:GetVehicle()

		local snd = {
			[-1] = base.WingLeftSND,
			[1] = base.WingRightSND,
		}

		for _, sound in pairs( snd ) do
			if not IsValid( sound ) then continue end

			sound:Stop()
		end
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		local ShouldFire = (ent.ShouldFire == true) and ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) < MaxRange
	
		if base:HandleRearGun( ent, ent.ShouldFire ) then
			ShouldFire = false
		end

		if base:SetWingTurretFire() ~= ShouldFire then
			base:SetWingTurretFire( ShouldFire ) 
		end

		local snd = {
			[-1] = base.WingLeftSND,
			[1] = base.WingRightSND,
		}

		if ent._oldShouldFire ~= ShouldFire then
			ent._oldShouldFire = ShouldFire
			if ShouldFire then
				for _, sound in pairs( snd ) do
					if not IsValid( sound ) then continue end

					sound:EmitSound( "lvs/vehicles/laat/ballturret_fire.mp3", 110 )
				end
			end
		end

		if not ShouldFire then
			for _, sound in pairs( snd ) do
				if not IsValid( sound ) then continue end
				sound:Stop()
			end

			ent:SetHeat( ent:GetHeat() - FrameTime() )

			return
		end
	
		if not active then
			return
		end

		local trace = ent:GetEyeTrace()
		local DesEndPos = trace.HitPos

		base:SetWingTurretTarget( DesEndPos )

		if not base:GetWingTurretFire() then return end
		
		local DesStartPos --= Vector(-55, 350, 90)

		if base:WorldToLocal( DesEndPos ).z < 0 then
			DesStartPos = Vector(-55, 350, 90)
		else
			DesStartPos = Vector(-55, 370, 125)
		end

		local NewHeat = ent:GetHeat()

		for i = -1,1,2 do
			local StartPos = self:LocalToWorld( DesStartPos * Vector(1,i,1)  )
			local beam = util.TraceLine( { start = StartPos, endpos = DesEndPos} )

			self:BallturretDamage( beam.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - StartPos):GetNormalized() )

			if not IsValid( snd[i] ) then continue end

			if beam.Entity ~= base then
				snd[i]:Play()
				NewHeat = NewHeat + FrameTime() * 0.25
			else
				snd[i]:Stop()
			end
		end

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local radius = 800
		radius = radius + radius * pod:GetCameraDistance()

		local clamped_angles = pod:WorldToLocalAngles( angles )
		clamped_angles.p = math.max( clamped_angles.p, -20 )
		clamped_angles = pod:LocalToWorldAngles( clamped_angles )

		local StartPos = base:LocalToWorld( base:OBBCenter() ) + clamped_angles :Up() * (350 + radius * pod:GetCameraHeight())
		local EndPos = StartPos - clamped_angles:Forward() * radius

		local WallOffset = 4

		local tr = util.TraceHull( {
			start = StartPos,
			endpos = EndPos,
			filter = function( e )
				local c = e:GetClass()
				local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "player" ) and not e.LVS
				
				return collide
			end,
			mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
			maxs = Vector( WallOffset, WallOffset, WallOffset ),
		} )

		view.drawviewer = true
		view.origin = tr.HitPos

		if tr.Hit and not tr.StartSolid then
			view.origin = view.origin + tr.HitNormal * WallOffset
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )

		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 10
	weapon.Delay = 0 
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )

		local T = CurTime()
		local pos = 0
		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if self.lor == 1 then
			pos = Vector(-63.81,-263.11,132.86)
			self.lor = 2
		else
			pos = Vector(-65.8,271.86,131.86)
			self.lor = 1
		end

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( self:LocalToWorld( pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetDamage( 1250 )
		projectile:SetRadius( 350 )
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.2 )
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )

		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 40
	weapon.Delay = 2
	weapon.HeatRateUp = 1 
	weapon.HeatRateDown = 0.08
	weapon.Attack = function( ent )


		--if not ent:WeaponsInRange() then return true end
		local veh = ent:GetVehicle()
		local Driver = ent:GetDriver()

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()

		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 100 then return true end

		for i = 1, 2 do
			timer.Simple( (i / 7) * 0.1, function()
				if not IsValid( ent ) then return end


				if self.lor == 1 then
					pos = Vector(99.71,69.93,276.31)
					self.lor = 2
				else
					pos = Vector(88.08,-69.92,276.24)
					self.lor = 1
				end

				if ent:GetAmmo() <= 0 then ent:SetHeat( 1 ) return end
	
				ent:TakeAmmo()

				local trace = ent:GetEyeTrace()
				local Start = pos
				local Dir = (ent:GetEyeTrace().HitPos - veh:LocalToWorld(Start)):GetNormalized()
				local projectile = ents.Create( "lvs_protontorpedo" )
				projectile:SetPos(veh:LocalToWorld(Start))
				projectile:SetAngles( ent:GetAngles() )
				projectile:SetParent( )
				projectile:Spawn()
				projectile:Activate()
				projectile.GetTarget = function( missile ) return missile end
				projectile.GetTargetPos = function( missile )
					return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-5,5) )
				end
				projectile:SetAttacker( IsValid( Driver ) and Driver or self )
				projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
				projectile:SetDamage( 1250 )
				projectile:SetRadius( 550 )
				projectile:Enable()
				projectile:EmitSound("LAAT_FIREMISSILE" )
			end)
			self.RocketsModel:ResetSequence("Load_Missile")

		end
	end
	weapon.FinishAttack = function( ent )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()
	
		if not IsValid( base ) then return end
	
		local WingInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) >= MaxRange
		local RearGunInRange = not base:GetRearGunInRange( ent )
	
		local Col = (WingInRange and RearGunInRange) and COLOR_RED or COLOR_WHITE
	
		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 
	
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon, 2 )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.1
	weapon.StartAttack = function( ent )
		if (self.gateDown) then
			self.gateDown = false
			self:SetBodygroup(7, 0)
		else
			self:SetBodygroup(7, 1)
			self.gateDown = true
		end
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.1
	weapon.StartAttack = function( ent )
		if (self.gateDown) then
			self.gateDown = false
			self:SetSpotlightOn(false)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		else
			self:SetSpotlightOn(true)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
			self.gateDown = true
		end
	end
	self:AddWeapon( weapon, 2 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_reardoor.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.3
	weapon.StartAttack = function( ent )
		if self:GetAI() == true then return end
		self:ToggleHatch()
	end
	self:AddWeapon( weapon, 3 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dropship_grabber.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.1
	weapon.StartAttack = function( ent )
		if self:GetAI() == true then return end
		if (self.gateDown) then
			self.gateDown = false
			self:DropHeldEntity()
		else
			self:GrabEntity()
			self.gateDown = true
		end
	end
	self:AddWeapon( weapon, 3 )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_sidedoor.png")
	weapon.Ammo = -1
	weapon.Delay = 1.5
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.3
	weapon.StartAttack = function( ent )
		if self:GetAI() == true then return end
		self:DoorOC()
	end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/spotlight.png")
	weapon.Ammo = -1
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 1
	weapon.StartAttack = function( ent )
		if self:GetSpotlightToggle() == true then
			self:SetSpotlightToggle(false)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		else
			self:SetSpotlightToggle(true)
			self:EmitSound( "buttons/lightswitch2.wav", 75, 105 )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

function ENT:IsSpotlightMounted()
	return self:GetBodygroup(7) == 1
end

--addons/lvs_addons/lua/entities/lvs_starfighter_advdroid/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-151,152,48), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,-152,48), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineFXColor = Color( 230, 30, 0, 255)
ENT.EngineFxPos = {
			Vector(-172,-89,53),
			Vector(-175,-84,53),
			Vector(-178,-78,53),
			Vector(-180,-73,53),
			Vector(-181,-68,53),
			Vector(-183,-64,53),
			Vector(-185,-58,53),
			Vector(-187,-52,53),
			Vector(-190,-47,53),
			
			Vector(-191,-41,53),
			Vector(-192,-35,53),
			Vector(-193,-29,53),
			Vector(-194,-23,53),
			Vector(-195,-17,53),
			Vector(-196,-11,53),
			Vector(-197,-5,53),
			
			Vector(-197,0,53),
			
			Vector(-197,5,53),
			Vector(-196,11,53),
			Vector(-195,17,53),
			Vector(-194,23,53),
			Vector(-193,29,53),
			Vector(-192,35,53),
			Vector(-191,41,53),
			
			Vector(-190,47,53),
			Vector(-187,52,53),
			Vector(-185,58,53),
			Vector(-183,64,53),
			Vector(-181,68,53),
			Vector(-180,73,53),
			Vector(-178,78,53),
			Vector(-175,84,53),
			Vector(-172,89,53),
			
			-- Bottom
			
			Vector(-190,-47,44),
			Vector(-187,-52,44),
			Vector(-185,-58,44),
			Vector(-183,-64,44),
			Vector(-181,-68,44),
			Vector(-180,-73,44),
			Vector(-178,-78,44),
			Vector(-175,-84,44),
			Vector(-172,-89,44),
			
			Vector(-191,-41,44),
			Vector(-192,-35,44),
			Vector(-193,-29,44),
			Vector(-194,-23,44),
			Vector(-195,-17,44),
			Vector(-196,-11,44),
			Vector(-197,-5,44),
			
			Vector(-197,0,44),
	
			Vector(-197,5,44),
			Vector(-196,11,44),
			Vector(-195,17,44),
			Vector(-194,23,44),
			Vector(-193,29,44),
			Vector(-192,35,44),
			Vector(-191,41,44),
			
			Vector(-190,47,44),
			Vector(-187,52,44),
			Vector(-185,58,44),
			Vector(-183,64,44),
			Vector(-181,68,44),
			Vector(-180,73,44),
			Vector(-178,78,44),
			Vector(-175,84,44),
			Vector(-172,89,44),
}

function ENT:PostDraw()
	if not self:GetEngineActive() then return end
	
	-- Far Bottom
	
	cam.Start3D2D( self:LocalToWorld( Vector(-181,-65,45) ), self:LocalToWorldAngles( Angle(0,291.5,120) ), 1 )
		draw.NoTexture()
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRectRotated( 0, 0, 45, 6 , 0 )
	cam.End3D2D()
	
	cam.Start3D2D( self:LocalToWorld( Vector(-181,65,45) ), self:LocalToWorldAngles( Angle(0,68.5,-120) ), 1 )
		draw.NoTexture()
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRectRotated( 0, 0, 45, 6 , 0 )
	cam.End3D2D()
	
	-- Near Bottom 
	
	cam.Start3D2D( self:LocalToWorld( Vector(-192,-22,45) ), self:LocalToWorldAngles( Angle(0,276.5,120) ), 1 )
		draw.NoTexture()
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRectRotated( 0, 0, 45, 6 , 0 )
	cam.End3D2D()
	
	cam.Start3D2D( self:LocalToWorld( Vector(-192,22,45) ), self:LocalToWorldAngles( Angle(0,83.5,-120) ), 1 )
		draw.NoTexture()
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRectRotated( 0, 0, 45, 6 , 0 )
	cam.End3D2D()
	
	-- Far Top
	
	cam.Start3D2D( self:LocalToWorld( Vector(-181,-65,53) ), self:LocalToWorldAngles( Angle(0,291.5,60) ), 1 )
		draw.NoTexture()
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRectRotated( 0, 0, 45, 6 , 0 )
	cam.End3D2D()
	
	cam.Start3D2D( self:LocalToWorld( Vector(-181,65,53) ), self:LocalToWorldAngles( Angle(0,68.5,-60) ), 1 )
		draw.NoTexture()
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRectRotated( 0, 0, 45, 6 , 0 )
	cam.End3D2D()
	
	-- Near Top
	
	cam.Start3D2D( self:LocalToWorld( Vector(-192,-22,53) ), self:LocalToWorldAngles( Angle(0,276.5,60) ), 1 )
		draw.NoTexture()
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRectRotated( 0, 0, 45, 6 , 0 )
	cam.End3D2D()
	
	cam.Start3D2D( self:LocalToWorld( Vector(-192,22,53) ), self:LocalToWorldAngles( Angle(0,83.5,-60) ), 1 )
		draw.NoTexture()
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRectRotated( 0, 0, 45, 6 , 0 )
	cam.End3D2D()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 30 + self:GetThrottle() * 15 + self:GetBoost() * 0.4

	render.SetMaterial( self.EngineGlow )

	for _, v in pairs( self.EngineFxPos ) do
		local pos = self:LocalToWorld( v )
		render.DrawSprite( pos, Size, Size, self.EngineFXColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/vulturedroid/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vulturedroid/brake.wav", 85 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_consulcharger/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Republic Consular Class Charger"
ENT.Author = "CR90"
ENT.Information = "Repub Retrofitted Consular Class Charger"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/salty/consularclasscharger.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
	"models/salty/ConsGib1.mdl",
	"models/salty/ConsGib2.mdl",
	"models/salty/ConsGib3.mdl",
	"models/salty/ConsGib4.mdl",

}

ENT.AITEAM = 2

ENT.MaxVelocity = 1900
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 0.8
ENT.TurnRateYaw = 0.8
ENT.TurnRateRoll = 0.35

ENT.ForceLinearMultiplier = 0.5

ENT.ForceAngleMultiplier = 0.5
ENT.ForceAngleDampingMultiplier = 0.5

ENT.MaxHealth = 8500
ENT.MaxShield = 1000

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "SecondGunnerSeat" )
	self:AddDT( "Entity", "ThirdGunnerSeat" )
end

function ENT:GetAimAngles( ent )
    local trace = ent:GetEyeTrace()
    local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(100,300,30) ) ):GetNormalized():Angle() )

    return AimAngles
end

function ENT:WeaponsInRange( ent )
    local AimAngles = self:GetAimAngles( ent )

    return not (AimAngles.p >= 50 or AimAngles.p <= -50)
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(1635.53,-3.43,457.08),
		Vector(1635.46,-27.42,456.99),
	}
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = 1200
	weapon.Delay = 0.4
	weapon.HeatRateUp = 0.35
	weapon.HeatRateDown = .5
	weapon.Attack = function( ent )
		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 2 then self.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0,  0.03, 0.03 )
		bullet.TracerName = "lvs_laser_blue_long"
		bullet.Force	= 10
		bullet.HullSize 	= 40
		bullet.Damage	= 120
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,0,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_concussion_explosion", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(0,0,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )
		
		ent:LVSFireBullet( bullet )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 85 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)

local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.25
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()
		
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 50 then return true end

		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
		
		local bullet = {}
		bullet.Src = veh:LocalToWorld( ent.SwapTopBottom and Vector(417.46,303.79,331.56) or Vector(437.54,303.27,331.41) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 25
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,0,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		if not IsValid( base ) then 
			return LVS:CalcView( ent, ply, pos, angles, fov, pod )
		end

		if pod:GetThirdPersonMode() then
			pos = pos + base:GetUp() * 100
		end

		return LVS:CalcView( base, ply, pos, angles, fov, pod )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 50) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
	
local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.25
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()
		
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 50 then return true end

		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
		
		local bullet = {}
		bullet.Src = veh:LocalToWorld( ent.SwapTopBottom and Vector(430.88,-304.27,332.36) or Vector(410.34,-307.52,331.34) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 25
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,0,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		if not IsValid( base ) then 
			return LVS:CalcView( ent, ply, pos, angles, fov, pod )
		end

		if pod:GetThirdPersonMode() then
			pos = pos + base:GetUp() * 100
		end

		return LVS:CalcView( base, ply, pos, angles, fov, pod )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 50) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 3 )
	
local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.25
	weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()
		
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 8 then return true end

		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )
		
		local bullet = {}
		bullet.Src = veh:LocalToWorld( ent.SwapTopBottom and Vector(-626.25,-0.15,450.46) or Vector(-625.37,21.56,450.66) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01 )
		bullet.TracerName = "lvs_laser_blue"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 25
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,0,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		if not IsValid( base ) then 
			return LVS:CalcView( ent, ply, pos, angles, fov, pod )
		end

		if pod:GetThirdPersonMode() then
			pos = pos + base:GetUp() * 100
		end

		return LVS:CalcView( base, ply, pos, angles, fov, pod )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 8) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 4 )

end

ENT.FlyByAdvance = 0.90
ENT.FlyBySound = "lvs/vehicles/frigates/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/crash/crashingdown.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/frigates/loop3.wav",
		Pitch = 120,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_geo/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Nantex-class Fighter"
ENT.Author = "Luna"
ENT.Information = "Geonosian starfighter, quick and agile."
ENT.Category = "AOCRP - KUS - Flugobjekte"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/geon/geon1.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 1

ENT.MaxVelocity = 2500
ENT.MaxThrust = 2500

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 300
ENT.MaxShield = 100

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )
end

function ENT:InitWeapons()

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 3000
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
	
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( Vector(100,0,55) )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.025,  0.025, 0.025 )
		bullet.TracerName = "lvs_laser_purple"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 25
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(180,50,255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(180,50,255) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")

		if ent.SetFoils then ent:SetFoils( true ) end
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )


	self:AddWeapon( LVS:GetWeaponPreset( "TURBO" ) )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/vulturedroid/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/droidtrifighter/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/vulturedroid/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 100,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_kimogila/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()	
	self:RegisterTrail( Vector(-150,420,160), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-150,-420,160), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
end

--[[function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost()
	local Mirror = false

	render.SetMaterial( self.EngineGlow )

	for i = -1,1,2 do
		local pos = self:LocalToWorld( Vector(-380,0,120) )
		render.DrawSprite( pos, Size, Size, Color( 255, 49, 0, 255) )
	end
end]]

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for i = -1,1,2 do
		local vOffset = self:LocalToWorld( Vector(-380,0,120) )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "sprites/heatwave", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * math.Rand(1500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.2 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(70,90) )
		particle:SetEndSize( math.Rand(20,30) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		
		particle:SetColor( 255, 255, 255 )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/vwing/boost.wav", 125 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vwing/brake.wav", 125 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_repz95/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color( 255, 50, 0, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-310,98,40),
	Vector(-310,-98,40),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-200,345,39), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-200,-345,39), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 255, 50, 200 )
	end
end

function ENT:AnimGunner()
end

function ENT:AnimAstromech()
end

function ENT:AnimWings()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/arc170/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/arc170/brake.wav", 85 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_scyk/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "M3A Scyk"
ENT.Author = "Nashatok"
ENT.Information = "Light Interceptor designed by MandalMotors, popular among pirates and militias"
ENT.Category = "[LVS] - Star Wars"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/scyk/sfp_scyk.mdl"

ENT.AITEAM = 1

ENT.MaxVelocity = 2750
ENT.MaxThrust = 2750

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 350
ENT.MaxShield = 80

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(128,60,115),
		Vector(128,-60,115),
	}
	
	--Weapon 1 - Rapid-fire Laser Cannons
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 1200
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 2 then self.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_yellow"
		bullet.Force	= 10
		bullet.HullSize 	= 40
		bullet.Damage	= 30
		bullet.Velocity = 30000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(200,150,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(200,150,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )
		
		ent:LVSFireBullet( bullet )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
	
	self:AddWeapon( LVS:GetWeaponPreset( "TURBO" ) )
end

ENT.FlyByAdvance = 0.75
ENT.FlyBySound = "lvs/vehicles/naboo_n1_starfighter/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/naboo_n1_starfighter/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_spiral/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-80,160,0), 0, 20, 2, 500, 150 )
	self:RegisterTrail( Vector(-80,-160,0), 0, 20, 2, 500, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )
function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost()
	local Mirror = false

	render.SetMaterial( self.EngineGlow )

	render.DrawSprite( self:LocalToWorld( Vector(-150,71,57) ), Size, Size, Color( 255, 49, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(-150,-74,57) ), Size, Size, Color( 255, 49, 0, 255) )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01
	
		local emitter = ParticleEmitter( self:GetPos(), false )
		local Pos = {
			Vector(-150,71,57),
			Vector(-150,-74,57),
			}

		if emitter then
			for _, v in pairs( Pos ) do
				local Sub = Mirror and 1 or -1
				local vOffset = self:LocalToWorld( v )
				local vNormal = -self:GetForward()

				vOffset = vOffset + vNormal * 5

				local particle = emitter:Add( "effects/muzzleflash2", vOffset )
				if not particle then return end

				particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
				particle:SetLifeTime( 0 )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( 255 )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(15,25) )
				particle:SetEndSize( math.Rand(0,10) )
				particle:SetRoll( math.Rand(-1,1) * 100 )
				
				particle:SetColor( 255, 50, 200 )
			
				Mirror = true
			end
			
			emitter:Finish()
		end
end

function ENT:AnimAstromech()
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/vwing/boost.wav", 125 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vwing/brake.wav", 125 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_vulture/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Vulture Droid"
ENT.Author = "Deltaa"
ENT.Information = "Droid Starfighter of the Trade Federation"
ENT.Category = "AOCRP - KUS - Flugobjekte"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/vulturedroid.mdl"

ENT.AITEAM = 1

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1.3
ENT.TurnRateYaw = 1.3
ENT.TurnRateRoll = 1.3

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1.3
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 1000

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(50, 110, 120),
		Vector(50, -110, 120),
		Vector(50, 110, 110),
		Vector(50, -110, 110)
	}

	-- Primary Weapon
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(CurPos)
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 100
		bullet.HullSize = 40
		bullet.Damage = 40
		bullet.Velocity = 60000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(255,50,50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata)
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect("lvs_muzzle_colorable", effectdata)

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		else
			ent.SNDRight:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		end
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon( weapon )

	-- Torpedo Weapon
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 10
	weapon.Delay = 3
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		if IsValid(ent._ProtonTorpedo) then
			if ent._nextMissleTracking and ent._nextMissleTracking > CurTime() then return end
			ent._nextMissleTracking = CurTime() + 0.1

			ent._ProtonTorpedo:FindTarget(ent:GetPos(), ent:GetForward(), 30, 7500)
			return
		end

		if ent._nextMissle and ent._nextMissle > CurTime() then return end
		ent._nextMissle = CurTime() + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector(40, ent._swapMissile and -110 or 110, 115)
		local Driver = self:GetDriver()

		local projectile = ents.Create("lvs_concussionmissile")
		projectile:SetPos(ent:LocalToWorld(Pos))
		projectile:SetAngles(ent:GetAngles())
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker(IsValid( Driver ) and Driver or self)
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(ent:GetVelocity():Length() + 4000)

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack(CurTime() + 0.1) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid(ent._ProtonTorpedo) then return end

		local projectile = ent._ProtonTorpedo
		projectile:Enable()
		projectile:EmitSound("lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end

		ent:SetHeat( NewHeat )
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	-- Turbo Mode
	self:AddWeapon(LVS:GetWeaponPreset("TURBO"))
end

ENT.FlyByAdvance = 1
ENT.FlyBySound = "lvs/vehicles/vulturedroid/boost.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "^lvs/vehicles/vulturedroid/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_vulturedroid/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Vulture Droid"
ENT.Author = "Luna"
ENT.Information = "Droid Starfighter of the Trade Federation"
ENT.Category = "[LVS] - Star Wars"

ENT.VehicleCategory = "Star Wars"
ENT.VehicleSubCategory = "Starfighters"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/salza/vulture_droid.mdl"
ENT.GibModels = {
	"models/salza/vd_gib1.mdl",
	"models/salza/vd_gib2.mdl",
	"models/salza/vd_gib3.mdl",
	"models/salza/vd_gib4.mdl",
	"models/salza/vd_gib5.mdl",
}

ENT.AITEAM = 1

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1.25

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 250

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(56.82,105.6,4),
		Vector(56.82,-105.6,-4),
		Vector(56.82,105.6,-4),
		Vector(56.82,-105.6,4)
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 1200
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 40
		bullet.Damage	= 10
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 4
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 56.82, (ent._swapMissile and -105.6 or 105.6), 0 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/vulturedroid/fire_missile.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )



	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 400
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld( Vector(30,15.2 * i,6.5) )

			local effectdata = EffectData()
			effectdata:SetStart( Vector(255,50,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.SecondarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) end
	self:AddWeapon( weapon )
end

sound.Add( {
	name = "LVS.VULTURE.FLYBY",
	sound = {"lvs/vehicles/vulturedroid/flyby.wav","lvs/vehicles/vulturedroid/flyby_a.wav","lvs/vehicles/vulturedroid/flyby_b.wav","lvs/vehicles/vulturedroid/flyby_c.wav"}
} )

ENT.FlyByAdvance = 0
ENT.FlyBySound = "LVS.VULTURE.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/vulturedroid/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
	{
		sound = "^lvs/vehicles/vulturedroid/dist.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0.35,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		VolumeMin = 0,
		VolumeMax = 1,
		SoundLevel = 100,
	},
}
--addons/lvs_addons/lua/entities/lvs_turret_av/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )

	if self:GetGunnerSeat() == ply:GetVehicle() then
		if pod:GetThirdPersonMode() then
			return pos + self:GetUp() * 100, angles, fov
		end
	end

	return pos, angles, fov
end

function ENT:OnSpawn()
end

function ENT:OnFrame()
end

function ENT:PostDrawTranslucent()
end

function ENT:EngineEffects()
end

function ENT:AnimGunner()
end

function ENT:AnimAstromech()
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
end

function ENT:OnStopBoost()
end

--addons/lvs_addons/lua/entities/lvs_walker_atte_hoverscript/cl_init.lua:
include("shared.lua")

--addons/lvs_addons/lua/entities/lvs_zakheavy_swtor/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Zakuul Heavy"
ENT.Author = "Ophra"
ENT.Information = "Heavy Shuttle of the Zakuul Empire"
ENT.Category = "[LVS] - SWTOR"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/ophra/ships/veh_neu_zak_mach2_flying_open.mdl"


ENT.AITEAM = 3

ENT.MaxVelocity = 2000
ENT.MaxThrust = 1000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 0.5
ENT.TurnRateYaw = 0.5
ENT.TurnRateRoll = 0.5

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 2000
ENT.MaxShield = 300



function ENT:InitWeapons()
	self.FirePositions = {
		Vector(94.29,562.17,62.51),
		Vector(94.29,-562.17,62.51),
		Vector(94.29,562.17,62.51),
		Vector(94.29,-562.17,62.51),
	}

	


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 26
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector(-6.72,-3.22,220.17)


		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:GetAngles() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "ophra/ships/shootsound4heavy.wav", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("ophra/ships/weaponswitch.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 800
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_blue"
 		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0, 229, 255) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld (Vector(94.29,-562.17,62.51))
			

			local effectdata = EffectData()
			effectdata:SetStart( Vector(0, 229, 255) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld (Vector(94.29,562.17,62.51))
		
			

			local effectdata = EffectData()
			effectdata:SetStart( Vector(0, 229, 255) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.SecondarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("ophra/ships/weaponswitch.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

sound.Add( {
	name = "LVS.VULTURE.FLYBY",
	sound = {"lvs/vehicles/vulturedroid/flyby.wav","lvs/vehicles/vulturedroid/flyby_a.wav","lvs/vehicles/vulturedroid/flyby_b.wav","lvs/vehicles/vulturedroid/flyby_c.wav"}
} )

ENT.FlyByAdvance = 0
ENT.FlyBySound = "LVS.VULTURE.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "ophra/ships/flysound5.wav",
		Volume = 3000,
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}

--addons/star_wars_mortar/lua/entities/mortar_fire_shell/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end
--addons/star_wars_mortar/lua/entities/mortar_shell/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end
--addons/joes_stuff/lua/entities/shield_bubble/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName= "Shield Bubble"
ENT.Author= "Joe + JackJack + Nvc"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Category = "Joe"
ENT.AutomaticFrameAdvance = true

--addons/sse_101/lua/entities/sse_box_ammo.lua:
AddCSLuaFile()



ENT.Base = "sse_base"
ENT.Category        = "SSE"
ENT.PrintName		= "Ammobox"
ENT.Spawnable       = true
ENT.ConfigName = "AmmoBox"

    
if SERVER then

    function ENT:Use( activator, caller )


        wep = activator:GetActiveWeapon()
        if wep then
            activator:GiveAmmo(self:ConfigValue("Amount"), wep:GetPrimaryAmmoType())
            activator:GiveAmmo(self:ConfigValue("Amount"), wep:GetSecondaryAmmoType())
        end
    end


end


--addons/sse_101/lua/entities/sse_trainingroomcontrol.lua:
AddCSLuaFile()

ENT.Base = "sse_base"
ENT.PrintName		= "Training Room Control Panel"
ENT.Spawnable       = true
ENT.ConfigName = "TrainingRoomControlPanel"
ENT.ClientInteraction = true
ENT.Category        = "SSE"

if SERVER then



    util.AddNetworkString("SSE_TRAININGROOM_CONTROL_SETOWNER")
    net.Receive("SSE_TRAININGROOM_CONTROL_SETOWNER", function(len, ply)


        if SSE:AntiSpam(ply) then return end

        local roomName = net.ReadString()
        local ent = net.ReadEntity()
        local terminal = net.ReadEntity()

        --if ply == ent then ply:ChatPrint("*** "..terminal:ConfigValue("SelfRoom")) return end


        if !IsValid(terminal) then return end
        if terminal:GetClass() != "sse_trainingroomcontrol" then return end
   

        if !terminal:ConfirmUse(ply) then return end
 

        if ply:GetPos():DistToSqr(terminal:GetPos()) > 10000 then return end

     

        for k, v in ipairs(ents.FindByClass("sse_trainingboard")) do
            if !IsValid(v) then continue end
            if v:GetClass() != "sse_trainingboard" then continue end
            if v:GetRoomName() != roomName then continue end
            v:SetRoomOwner(ent)

            if !IsValid(ent) then
                v:ResetRoomLines()
            end
        end

        if IsValid(ent) then
            ent:ChatPrint(terminal:ConfigValue("NewOwner")..roomName)
        end

        terminal:InvalidateUseConfirm(ply)
    end)


end



if CLIENT then
    function SSE_TRAININGROOM_CONTROl_SELECTOWNER(roomName,terminal)
        if IsValid(SSE_SIMPLE_ATC_FRAME) then SSE_SIMPLE_ATC_FRAME:Remove() end
        SSE_SIMPLE_ATC_FRAME = SSE:DefaultFrame(SSE.Config.TrainingRoomControlPanel["SelectOwner"]..roomName)
        SSE_SIMPLE_ATC_FRAME:SetSize(ScrW() * 0.3, ScrH() * 0.8)
        SSE_SIMPLE_ATC_FRAME:Center()
        SSE_SIMPLE_ATC_FRAME:MakePopup()

        local scrollPanel = SSE:ScrollBar(SSE_SIMPLE_ATC_FRAME)
        scrollPanel:Dock( FILL )

        local button = SSE:Button(scrollPanel, SSE.Config.TrainingRoomControlPanel["SetToFree"], function()
            net.Start("SSE_TRAININGROOM_CONTROL_SETOWNER")
                net.WriteString(roomName)
                net.WriteEntity(nil)
                net.WriteEntity(terminal)
            net.SendToServer()
            SSE_SIMPLE_ATC_FRAME:Remove()
        end)
        button:Dock(TOP)


        for k, v in ipairs(player.GetHumans()) do
            local button = SSE:Button(scrollPanel, v:Nick(), function()
                net.Start("SSE_TRAININGROOM_CONTROL_SETOWNER")
                    net.WriteString(roomName)
                    net.WriteEntity(v)
                    net.WriteEntity(terminal)
                net.SendToServer()
                SSE_SIMPLE_ATC_FRAME:Remove()

            end)
            button:Dock(TOP)
        end
    end 

    local function SSE_TRAININGROOM_CONTROL(terminal)
        if IsValid(SSE_SIMPLE_ATC_FRAME) then SSE_SIMPLE_ATC_FRAME:Remove() end
        SSE_SIMPLE_ATC_FRAME = SSE:DefaultFrame(terminal:ConfigValue("FrameTitle"))
        SSE_SIMPLE_ATC_FRAME:SetSize(ScrW() * 0.3, ScrH() * 0.8)
        SSE_SIMPLE_ATC_FRAME:Center()
        SSE_SIMPLE_ATC_FRAME:MakePopup()

        local scrollPanel = SSE:ScrollBar(SSE_SIMPLE_ATC_FRAME)
        scrollPanel:Dock( FILL )

        local function fetchEntities(parent)

            local roomNames = {}
            for k, v in ipairs(ents.GetAll()) do
                if !IsValid(v) then continue end
                if v:GetClass() != "sse_trainingboard" then continue end
                if table.HasValue(roomNames, v:GetRoomName()) then continue end

    
                table.insert(roomNames, v:GetRoomName())

                local owner = terminal:ConfigValue("Free")

                if IsValid(v:GetRoomOwner()) then
                    owner = v:GetRoomOwner():Nick()
                end

                local button = SSE:Button(parent, v:GetRoomName() .. " - ".. owner, function()
                    SSE_TRAININGROOM_CONTROl_SELECTOWNER(v:GetRoomName(),terminal)
                end)
                button:Dock(TOP)
            end
        end

        fetchEntities(scrollPanel)

    end




    function ENT:ClientUse()
        SSE_TRAININGROOM_CONTROL(self)
    end
end
--addons/sse_101/lua/entities/sse_url_console.lua:
AddCSLuaFile()


ENT.Base = "sse_base"
ENT.PrintName		= "Web Console"
ENT.Spawnable       = true
ENT.Editable = true
ENT.ConfigName = "URLConsole"
ENT.ClientInteraction = true
ENT.Category        = "SSE"
function ENT:SetupDataTables()

    self:NetworkVar( "String", 0, "URL", { KeyName = "URL",	Edit = { type = "Text"  } } ) 
    self:NetworkVar( "String", 1, "Title", { KeyName = "Title",	Edit = { type = "Text"  } }  ) 


    if SERVER then
        self:SetURL("www.google.de")
        self:SetTitle("Google")
    end

end


if CLIENT then

    function ENT:Draw()
        self.BaseClass.Draw(self) 
        self.SSE_HUDName = self:GetTitle()
    end

    function ENT:ClientUse()

        local url = self:GetURL()
        local title = self:GetTitle()
        local frame =  SSE:DefaultFrame(title)
        frame:SetSize(ScrW() * 0.8, ScrH() * 0.8)
        frame:Center()

        local html = vgui.Create("DHTML", frame)
        html:Dock(FILL)
        html:OpenURL(url)

    end



end
--addons/arccw_weapons/lua/entities/tfa_battlefront_ent_nade_heal.lua:
ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.PrintName = "explosive Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false 

ENT.BounceSound = Sound("TFA_CSGO_SmokeGrenade.Bounce")
ENT.ExplodeSound = Sound("weapons/tfa_starwars/Smoke_Explosive_Puff_01.wav")

AddCSLuaFile()

function ENT:Initialize()
	if SERVER then
		self:SetModel("models/forrezzur/bactagrenade.mdl") 
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
		
		local phys = self:GetPhysicsObject()
		if phys:IsValid() then
			phys:Wake()
			phys:SetBuoyancyRatio(1)
		end
		
		self.Delay = CurTime() + 2
		self.NextParticle = 0
		self.ParticleCount = 0
		self.First = true
		self.IsDetonated = false
	end
	self:EmitSound("TFA_CSGO_SmokeGrenade.Throw")
end

function ENT:PhysicsCollide(data, physobj)
	if SERVER then
		self.HitP = data.HitPos
		self.HitN = data.HitNormal

		if self:GetVelocity():Length() > 30 then
			self:EmitSound(self.BounceSound)
		end
		
		if self:GetVelocity():Length() < 5 then
			self:SetMoveType(MOVETYPE_NONE)
		end
		
	end
end

function ENT:Think()
    if SERVER then    
        if CurTime() > self.Delay then
            if self.IsDetonated == false then
                self:Detonate(self,self:GetPos())
                self.IsDetonated = true
            end
        end
    end
    if self.IsDetonated == true then
        for k, v in pairs( ents.FindInSphere( self:GetPos(), 216 ) ) do
        if v:IsPlayer() then
            if v:Health() < v:GetMaxHealth() and v:Alive() then
				v:SetHealth( math.Clamp( v:Health() + math.random( 2, 4 ), 0, v:GetMaxHealth() ) )
                    end
                end
            end
        end
    self:NextThink( CurTime() + 0.75 )
    return true
end
	
function ENT:Detonate(self,pos)
	self.ParticleCreated = false
	self.ExtinguishParticleCreated = false
	if SERVER then
		if not self:IsValid() then return end
		self:SetNWBool("IsDetonated",true)
		self:EmitSound(self.ExplodeSound)
		local gas = EffectData()
		gas:SetOrigin(pos)
		gas:SetEntity(self.Owner)
		util.Effect("tfa_csgo_healnade", gas)
	end
	
	self:SetMoveType( MOVETYPE_NONE )
	
	if SERVER then
		SafeRemoveEntityDelayed(self,15)
	end
	
end

function ENT:Draw()
	if CLIENT then
		self:DrawModel()
	end
end
--addons/arccw_weapons/lua/entities/tfa_exp_base/cl_init.lua:

-- Copyright (c) 2018-2020 TFA Base Devs

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end

function ENT:IsTranslucent()
	return true
end
--lua/entities/turret_eweb_ammo/cl_init.lua:
include("shared.lua")

local color_lightwhite = Color(250,250,250)
local color_outline = Color(25,25,25,100)
local color_green = Color(39, 174, 96)

function ENT:Draw()
	self:DrawModel()

	

	local Ang = self:GetAngles()
	local Pos = self:GetPos()

	
	cam.Start3D2D(Pos + Ang:Up() * 20.9 + Ang:Forward()*13.5 + Ang:Right()*4, Ang, 0.07 )

		surface.SetDrawColor(color_green)
		surface.DrawRect(0,0, -95, -95 )

		draw.SimpleTextOutlined("100%", "DermaLarge", -47.5, -47.5,  color_lightwhite, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, color_outline )

	cam.End3D2D()

	

end



--addons/lvs_addons/lua/entities/tx-ex/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:OnFrame()
	self:AnimCabin()
end

function ENT:AnimCabin()
	local Fire = self:GetBTLFire()
	if Fire ~= self.OldFireBTL then
		self.OldFireBTL = Fire
		
		if Fire then			
			local effectdata = EffectData()
			effectdata:SetEntity( self )
			util.Effect( "tx_130_projector", effectdata )
		end
	end
	
	local bOn = self:GetActive()
	
	local TVal = bOn and 0 or 1
	
	local Speed = FrameTime() * 4
	
	self.SMcOpen = self.SMcOpen and self.SMcOpen + math.Clamp(TVal - self.SMcOpen,-Speed,Speed) or 0
	
	self:ManipulateBoneAngles( 20, Angle(0,0,self.SMcOpen * -95) ) 
	
end

function ENT:OnRemove()
	self:SoundStop()
end

function ENT:SoundStop()
	if self.DIST then
		self.DIST:Stop()
	end
	
	if self.ENG then
		self.ENG:Stop()
	end
end

function ENT:LVSCalcView( ply, pos, angles, fov, pod )
	local view = {}
	view.origin = pos
	view.fov = fov
	view.drawviewer = true
	view.angles = ply:EyeAngles()
	local gunners = self:GetGunnerSeat()
	local gunner = gunners:GetDriver()
	local Driver = self:GetDriver()
	if pod:GetThirdPersonMode() then
		if ply == Driver then
			local Pod = ply:GetVehicle()
			
				local radius = 400
				radius = radius + radius * Pod:GetCameraDistance()
				
				local StartPos = self:LocalToWorld( Vector(0,0,50) ) + view.angles:Up() * 100
				local EndPos = StartPos - view.angles:Forward() * radius
				
				local WallOffset = 4
		
				local tr = util.TraceHull( {
					start = StartPos,
					endpos = EndPos,
					filter = function( e )
						local c = e:GetClass()
						local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "player" ) and not e.LFS
						
						return collide
					end,
					mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
					maxs = Vector( WallOffset, WallOffset, WallOffset ),
				} )
				
				view.drawviewer = true
				view.origin = tr.HitPos
				
				if tr.Hit and not tr.StartSolid then
					view.origin = view.origin + tr.HitNormal * WallOffset
				end
			return view
		else
			local Pod = ply:GetVehicle()
			
			local radius = 400
			radius = radius + radius * Pod:GetCameraDistance()
			
			local StartPos = self:LocalToWorld( Vector(0,0,50) ) + view.angles:Up() * 100
			local EndPos = StartPos - view.angles:Forward() * radius
			
			local WallOffset = 4
	
			local tr = util.TraceHull( {
				start = StartPos,
				endpos = EndPos,
				filter = function( e )
					local c = e:GetClass()
					local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "player" ) and not e.LFS
					
					return collide
				end,
				mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
				maxs = Vector( WallOffset, WallOffset, WallOffset ),
			} )
			
			view.drawviewer = true
			view.origin = tr.HitPos
			
			if tr.Hit and not tr.StartSolid then
				view.origin = view.origin + tr.HitNormal * WallOffset
			end
			return view
		end
	end
	if not pod:GetThirdPersonMode() then

		view.drawviewer = false

		local gunners = self:GetGunnerSeat()
		
		local Driver = self:GetDriver()
		local Gunner = gunners:GetDriver()

		if ply == Driver then
			view.origin = self:LocalToWorld( Vector(-65,25,55) )
		elseif ply == Gunner then
			view.origin = self:LocalToWorld( Vector(-100,0,95) )
		else
			view.origin = self:LocalToWorld( Vector(-65,-25,55) )
		end
		
	return view
	end

	return view
end

function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end
end

function ENT:OnRemove()
	self:SoundStop()
	
	self:RemoveLight()
end


local spotlight = Material( "effects/lfs_base/spotlight_projectorbeam" )
local glow_spotlight = Material( "sprites/light_glow02_add" )

function ENT:Draw()
	self:DrawModel()

	if self:GetBodygroup( 9 ) ~= 1 then 
		self:RemoveLight()

		return
	end

	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 20 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( false ) 
		thelamp:SetFarZ( 2500 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 80 )
		self.projector = thelamp
	end

	local StartPos = self:LocalToWorld( Vector(60,0,10.5) )
	local Dir = self:GetForward()

	render.SetMaterial( glow_spotlight )
	render.DrawSprite( StartPos + Dir * -10 , 220, 120, Color( 255, 255, 255, 255) )


	render.SetMaterial( spotlight )
	render.DrawBeam(  StartPos - Dir * 10,  StartPos + Dir * 800, 250, 0, 0.99, Color( 255, 255, 255, 10) ) 
	
	if IsValid( self.projector ) then
		self.projector:SetPos( StartPos )
		self.projector:SetAngles( Dir:Angle() )
		self.projector:Update()
	end
end


--addons/arccw_weapons/lua/effects/arccw_apex_impact_lstar/init.lua:
function EFFECT:Init(data)
	self.Pos = data:GetOrigin()

	local dynlight = DynamicLight(0)
	dynlight.Pos = self.Pos
	dynlight.Size = 100
	dynlight.Decay = 320
	dynlight.R = 255
	dynlight.G = 111
	dynlight.B = 111
	dynlight.Brightness = 0.3
	dynlight.DieTime = CurTime()+.3
	
	ParticleEffect( "tfa_apex_lstar_explode_core", data:GetOrigin(), data:GetAngles(), self )
	
	self.Time = 0
	self.Size = 0
end

function EFFECT:Think()
	self.Time = self.Time + FrameTime()
	self.Size = 20

	return self.Time < .3
end

function EFFECT:Render()
end
--addons/arccw_weapons/lua/effects/astw2_halo2_explosion_bruteshot/init.lua:

function EFFECT:Init(data)
    self.Origin = data:GetOrigin()
    local emitter = ParticleEmitter( self.Origin + Vector( 0, 0, 16 ) )
local light = DynamicLight(self:EntIndex())
        if (light) then
            light.Pos = self:GetPos()
            light.r = 225
            light.g = 155
            light.b = 200
            light.Brightness = 3
            light.Decay = 10
            light.Size = 512
            light.DieTime = CurTime() + 0.3
        end
    local particle = emitter:Add("effects/halo3/explosive_burst", self.Origin)

    particle:SetVelocity( 25 * VectorRand() )
    particle:SetDieTime( 0.2 )
    particle:SetStartAlpha( 255 )
    particle:SetEndAlpha( 0 )
    particle:SetStartSize( math.Rand(5,15) )
    particle:SetEndSize( math.Rand(150,300) )
    particle:SetRoll( math.Rand(0,360) )
    particle:SetRollDelta( math.Rand(0,0) )
    particle:SetColor( 225, 215, 255 )
    particle:SetAirResistance( 55 )
    particle:SetLighting( false )
    particle:SetCollide( false )
	



    for i = 0,5 do
        particle = emitter:Add( "effects/halo3/flare1" , self.Origin )

        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.15, 0.25) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(10,15) )
        particle:SetEndSize( math.Rand(175,200) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 255,255,200 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )
    end

    particle = emitter:Add( "effects/halo3/electric_arcs", self.Origin )
        particle:SetVelocity( 1 * VectorRand() )
        particle:SetDieTime( math.Rand(0.25, 0.3) )
        particle:SetStartAlpha( 200 )
        particle:SetEndAlpha( 0 )
        particle:SetStartSize( math.Rand(20,35) )
        particle:SetEndSize( math.Rand(150,175) )
        particle:SetRoll( math.Rand(0,360) )
        particle:SetRollDelta( math.Rand(-1,1) )
        particle:SetColor( 200,200,255 )
        particle:SetAirResistance( 200 )
        particle:SetGravity( Vector( 0, 0, math.Rand(10,40) ) )
        particle:SetLighting( false )
        particle:SetCollide( true )
        particle:SetBounce( 0.5 )

    emitter:Finish()

end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
end
--addons/arccw_weapons/lua/effects/effect_astw2_halo2_tracer_bruteplasmarifle/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 96;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo_spv3/flash/muzzle_flash/muzzle_flash_pistol_side" );
local MaterialFront			= Material( "effects/halo_ce/flare_pr_overcharge" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 8, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo2_tracer_laser/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 16000;
EFFECT.Length				= 5096;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo3/muzzle_flash_01" );
local MaterialFront			= Material( "effects/halo_spv3/flash/smg_new" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 15, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo2_tracer_needler/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 36;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo_spv3/flash/muzzle_flash/muzzle_flash_needler_side" );
local MaterialFront			= Material( "effects/halo3/muzzle_needler" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 3, 5, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 4, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_impact_plasmarifle_brute/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/halo3/8pt_ringed_star_flare" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/flash_large", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.15 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 35 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 175, 175);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
	for i = 1, 1 do

			local particle = emitter:Add( "effects/halo_reach/plasma_bolt_red", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.1, 0.15 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 20 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 255, 255);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
				for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/electric_arcs", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.1 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 20 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 225, 225);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( 255, 155, 155, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_tracer_gauss/init.lua:

local Tracer = Material( "effects/halo2/contrail_human" )
local Tracer2  = Material( "effects/blueblacklargebeam" )
local Width = 35
local Width2 = 25

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.15
	self.LifeTime2 = 0.25
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 175, 125, v * 155 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 255, 255, 255, (v2 * 100)*3/2.5 ) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_tracer_monitor/init.lua:

local Tracer = Material( "effects/halo3/spartanlaser" )
local Width = 16

function EFFECT:Init( data )

	self.Entity=data:GetEntity()
	if !IsValid(self.Entity) then return end
	self.Position = self.Entity:GetAttachment(1).Pos
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.35
	self.DieTime = CurTime() + self.LifeTime

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()


	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	

	render.SetMaterial( Tracer )
	for i=1, 8 do
	render.DrawBeam( self.StartPos, self.EndPos, ( Width / i)* v, 0, (self.Dist/10)*math.Rand(-2,2), Color( 225, 200, 200, v * 100 ) )
	end
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_tracer_plasmapistol/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 48;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo_reach/trail_green" );
local MaterialFront			= Material( "effects/halo_reach/plasma_bolt_green" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - 2* self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 10, 10, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 15, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_ce_tracer_covsniper/init.lua:

local Tracer = Material( "effects/halo2/plasma_cannon_contrail" )
local Tracer2  = Material( "effects/halo2/c_gun_turret_contrail" )
local Width = 24
local Width2 = 24

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Dir = ( self.EndPos - self.StartPos ):GetNormalized()
	self.Dist = self.StartPos:Distance( self.EndPos )
	
	self.LifeTime = 0.15
	self.LifeTime2 = 0.25
	self.DieTime = CurTime() + self.LifeTime
	self.DieTime2 = CurTime() + self.LifeTime2

end

function EFFECT:Think()

	if ( CurTime() > self.DieTime ) then return false end
	return true

end

function EFFECT:Render()

	local r = 255
	local g = 255
	local b = 255
	
	local v = ( self.DieTime - CurTime() ) / self.LifeTime
	
	local v2 = ( self.DieTime2 - CurTime() ) / self.LifeTime2

	render.SetMaterial( Tracer )
	render.DrawBeam( self.StartPos, self.EndPos, (v * Width)*3/2, 0, (self.Dist/10)*math.Rand(-2,2), Color( 125, 155, 255, v * 155 ) )
	
	render.SetMaterial( Tracer2 )
	render.DrawBeam( self.StartPos, self.EndPos, (v2 * Width2)*2/3, 0, (self.Dist/10)*math.Rand(-2,2), Color( 200, 225, 255, (v2 * 100)*3/2.5 ) )

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_ce_tracer_ne/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 64;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain2			= Material( "effects/halo_spv3/flash/muzzle_flash/muzzle_flash_needler_side" );
local MaterialMain			= Material( "effects/halo_spv3/flash/muzzle_flash/muzzle_flash_pr_side" );
local MaterialFront			= Material( "effects/halo3/muzzle_needler" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 6.5, 1, 1, color_white );
	
	render.SetMaterial( MaterialMain2 );
	render.DrawBeam( startPos, endPos, 5, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_haloreach_tracer_plasma_repeater/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 64;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo_spv3/flash/muzzle_flash/muzzle_flash_pr_side" );
local MaterialFront			= Material( "effects/halo_reach/plasma_bolt" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - 2* self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 5, 0, 1, color_white );
	
end

--addons/aoc_nextbots/lua/effects/effect_npc_laser_red.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6

EFFECT.Speed = 6500
EFFECT.Length = 64
EFFECT.WhizDistance = 72

local MaterialMain = Material("effects/sw_laser_red_main")
local MaterialFront = Material("effects/sw_laser_red_front")
local MaterialGlow = Material("sprites/light_glow02_add")
local ColorRed = Color(255, 0, 0)

function EFFECT:GetTracerOrigin(data)
    local start = data:GetStart()

    if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
        local entity = data:GetEntity()

        if (not IsValid(entity)) then
            return start
        end
        if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then
            return start
        end

        if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
            local pl = entity:GetOwner()
            if (IsValid(pl)) then
                local vm = pl:GetViewModel()
                if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
                    entity = vm
                else
                    if (entity.WorldModel) then
                        entity:SetModel(entity.WorldModel)
                    end
                end
            end
        end

        local attachment = entity:GetAttachment(data:GetAttachment())
        if (attachment) then
            start = attachment.Pos
        end
    end

    return start
end

function EFFECT:Init(data)
    self.StartPos = self:GetTracerOrigin(data)
    self.EndPos = data:GetOrigin()

    self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)

    local diff = (self.EndPos - self.StartPos)

    self.Normal = diff:GetNormal()
    self.StartTime = 0
    self.LifeTime = (diff:Length() + self.Length) / self.Speed

    local weapon = data:GetEntity()
    if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
        local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
    end
end

function EFFECT:Think()
    self.LifeTime = self.LifeTime - FrameTime()
    self.StartTime = self.StartTime + FrameTime()

    return self.LifeTime > 0
end

function EFFECT:Render()
    local endDistance = self.Speed * self.StartTime
    local startDistance = endDistance - self.Length

    startDistance = math.max(0, startDistance)
    endDistance = math.max(0, endDistance)

    local startPos = self.StartPos + self.Normal * startDistance
    local endPos = self.StartPos + self.Normal * endDistance

    render.SetMaterial(MaterialFront)
    render.DrawSprite(endPos, 8, 8, color_white)

    render.SetMaterial(MaterialMain)
    render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)

    render.SetMaterial(MaterialGlow)
    render.DrawSprite(startPos, 50, 50, ColorRed)
end

--addons/arccw_weapons/lua/effects/electric_spark.lua:
function EFFECT:Init(data)
    self.Position = data:GetOrigin()
    self.Scale = data:GetMagnitude() or 1 -- Adjust scale as needed

    local entindex = data:GetEntity():EntIndex()

    -- Start a coroutine to create the electric spark effect
    coroutine.wrap(function()
        for i = 1, math.random(5, 10) do
            local lightning = ents.Create("point_tesla")
            lightning:SetPos(self.Position)
            lightning:SetKeyValue("m_SoundName", "")
            lightning:SetKeyValue("texture", "sprites/bluelight1.spr")
            lightning:SetKeyValue("m_Color", "255 255 150")
            lightning:SetKeyValue("m_flRadius", "150")
            lightning:SetKeyValue("beamcount_max", "15")
            lightning:SetKeyValue("thick_min", "15")
            lightning:SetKeyValue("thick_max", "30")
            lightning:SetKeyValue("lifetime_min", "0.15")
            lightning:SetKeyValue("lifetime_max", "0.4")
            lightning:SetKeyValue("interval_min", "0.15")
            lightning:SetKeyValue("interval_max", "0.25")
            lightning:Spawn()
            lightning:Fire("DoSpark", "", 0)
            lightning:Fire("kill", "", 0.2)

            local light = ents.Create("light_dynamic")
            light:SetPos(self.Position)
            light:Spawn()
            light:SetKeyValue("_light", "100 100 255")
            light:SetKeyValue("distance", "550")
            light:Fire("Kill", "", 0.20)

            sound.Play("k_lab.teleport_spark", self.Position, 110)

            -- Wait for a random interval before creating the next spark
            local interval = math.Rand(0.03, 0.1)
            coroutine.yield(interval)
        end
    end)()
end

function EFFECT:Think()
    -- No need to continue thinking
    return false
end

function EFFECT:Render()
end
--addons/arccw_weapons/lua/effects/emp_exp_effect.lua:
if SERVER then AddCSLuaFile() end

function EFFECT:Init(data)
	self.Start = data:GetOrigin()
	self.size = data:GetScale()
	self.Emitter = ParticleEmitter(self.Start)
	for i = 1, math.random(20, 50) do
		local p = self.Emitter:Add("effects/muzzleflash"..math.random(1,4), self.Start)
		p:SetDieTime(math.Rand(0.1*3, 0.25*3))
		p:SetStartAlpha(255)
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(50, 150) * self.size)
		p:SetEndSize(50 * self.size)
		p:SetRoll(math.Rand(-50, 50))
		p:SetRollDelta(math.Rand(-10, 10))
		p:SetCollide(true)
		p:SetVelocity(VectorRand():GetNormal() * math.random(25, 75) * self.size)
		p:SetColor(0, 180, 255)
	end
	for i = 1, 400 do
		local vec = VectorRand():GetNormal()
		vec.z = 0
		local pos = (self.Start + vec * 50)
		local p = self.Emitter:Add("sprites/orangeflare1", self.Start + vec * 10)
		p:SetDieTime(math.Rand(0.9, 1.1))
		p:SetStartAlpha(255)
		p:SetEndAlpha(35)
		p:SetStartSize(18)
		p:SetEndSize(12)
		p:SetVelocity(((pos - self.Start):GetNormal() * math.random(250, 285)) + Vector(0, 0, math.random(-80, 80)) * self.size)
		p:SetGravity( Vector( 0, 0, 0 ) );
		p:SetColor(0, 180, 255)
		p:SetCollide(false)
	end

	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end
--addons/weapon_jedi/lua/effects/force_push.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE


EFFECT.mat = Material( "sprites/heatwave" )
EFFECT.mat2 = Material( "effects/select_ring" )
EFFECT.mat3 = Material( "particle/smokesprites_0001" )

function EFFECT:Init( data )
	self.Ent = data:GetEntity()

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	if not IsValid( self.Ent ) then self.Ready = true return end

	self.Pos = self.Ent:GetShootPos()
	self.Dir = data:GetNormal()
	self.mat3 = Material( "particle/smokesprites_000"..math.random(1,9) )

	self.Ready = true
end

function EFFECT:Think()
	if not self.Ready then return true end

	if self.DieTime < CurTime() or not IsValid( self.Ent ) then 
		return false
	end

	return true
end

function EFFECT:Render()
	if not self.Ready or not IsValid( self.Ent ) then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	local InvScale =  (1 - Scale)

	render.SetMaterial( self.mat3 )
	render.DrawSprite( self.Pos + self.Dir * 200 * InvScale, 100 * Scale, 100 * Scale, Color( 150,200,255,50 ) )

	for i = 1, 3 do
		local Scale = (self.DieTime - CurTime()) / self.LifeTime / 3 * i

		local Pos = self.Pos + self.Dir * 200 * InvScale

		render.SetMaterial( self.mat )
		render.DrawSprite( Pos, 150 *  InvScale, 150 *  InvScale, Color( 255,255,255,255 ) )
	end
end
	

--addons/lvs_addons/lua/effects/lfs_fb_ballturret_left_projector.lua:
EFFECT.Mat = Material("effects/lfs_base/ballturret_projectorbeam")
EFFECT.HitMat = Material("sprites/light_glow02_add")

function EFFECT:Init( data )
	self.Entity = data:GetEntity()
	
	if IsValid(self.Entity) then
		self.ID = self.Entity:LookupAttachment("L_Ball_Attachement")
		
		if self.ID then
			local Muzzle = self.Entity:GetAttachment(self.ID)

			self:SetRenderBoundsWS(self.Entity:GetPos(), Muzzle.Ang:Up() * 50000)
		end
	end
end

function EFFECT:Think()
	if not IsValid(self.Entity) or not self.ID or not self.Entity:GetBTLFire() then
		return false
	end
	
	return true
end

function EFFECT:Render()
	if not self.ID or not IsValid(self.Entity) then return end
	
	local Muzzle = self.Entity:GetAttachment( self.ID )
	
	local Dir = Muzzle.Ang:Forward()
	local Up = Muzzle.Ang:Up()
	local StartPos = Muzzle.Pos + Up * 18 + Dir * 60
	local Trace = util.TraceLine( { start = StartPos, endpos = StartPos + Dir * 50000, filter = self } )
	local EndPos = Trace.HitPos
	
	self:SetRenderBoundsWS(StartPos, EndPos)
	
	render.SetMaterial(self.Mat)
	render.DrawBeam(StartPos, EndPos, 14 + math.random(0,4), 1, 0, Color(0, 255, 0, 255))
	render.DrawBeam(StartPos, EndPos, 3 + math.random(0,4), 1, 0, Color(255, 255, 255, 255))
	
	render.SetMaterial( self.HitMat )
	local A = 150 + math.random(0,20)
	local B = 70 + math.random(0,20)
	render.DrawSprite( StartPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( StartPos, B, B, Color(255,255,255,255) )
	
	render.DrawSprite( EndPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( EndPos + VectorRand() * 10, B, B, Color(255,255,255,255) )
	
	if math.random(0,5) == 1 then
		local emitter = ParticleEmitter( EndPos, false )
		local dir = (self.Entity:GetPos() - EndPos):GetNormalized()
		
		for i = 0, 10 do
			local particle = emitter:Add( "sprites/rico1", EndPos )
			
			local vel = VectorRand()  * 100 + dir * 40
			
			if particle then
				particle:SetVelocity( vel )
				particle:SetAngles( vel:Angle() + Angle(0,90,0) )
				particle:SetDieTime( math.Rand(0.1,0.3) * 0.5 )
				particle:SetStartAlpha( math.Rand( 200, 255 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(1,30) )
				particle:SetEndSize( 0 )
				particle:SetRoll( math.Rand(-100,100) )
				particle:SetRollDelta( math.Rand(-100,100) )

				particle:SetAirResistance( 0 )
			end
		end
		
		emitter:Finish()
	end
end

--addons/lvs_addons/lua/effects/lvs_bomb_cisexplosion.lua:

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,30 do
		local particle = emitter:Add(  Materials[ math.random(1, #Materials ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 800 )
			particle:SetDieTime( math.Rand(4,6) )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( math.Rand(300,600) )
			particle:SetEndSize( math.Rand(100,150) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 50,50,50 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/light_glow02_add", self.Pos )
		
		local vel = VectorRand() * 400
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.4,0.8) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(240,480) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( 255, 40, 100, 255 )
			particle:SetGravity( Vector(0,0,-600) )

			particle:SetAirResistance( 0 )
			
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end
	
	for i = 0, 40 do
		local particle = emitter:Add( "sprites/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( 0.14 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 50 )
			particle:SetEndSize( math.Rand(200,400) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 255, 40, 100, 255 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local Pos = self.Pos
	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		if delay <= 0.11 then
			sound.Play( "ambient/explosions/explode_9.wav", Pos, 85, 100, 1 - delay * 8 )
		end

		timer.Simple( delay, function()
			sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 400 * Scale, 400 * Scale, Color( 0, 127, 255, 255) )
	render.DrawSprite( self.Pos, 100 * Scale, 100 * Scale, Color( 255, 255, 255, 255) )
end

--addons/lvs_base/lua/effects/lvs_explosion.lua:
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.DecalMat = Material( util.DecalMaterial( "Scorch" ) )

function EFFECT:Init( data )
	local Pos = data:GetOrigin()

	self.DieTime = CurTime() + 1

	self:Explosion( Pos, 2 )

	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		timer.Simple( delay, function()
			sound.Play( "LVS.DYNAMIC_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.DYNAMIC_EXPLOSION", Pos )
	end
	
	for i = 1, 20 do
		timer.Simple(math.Rand(0,0.01) * i, function()
			if IsValid( self ) then
				local p = Pos + VectorRand() * 10 * i
				
				self:Explosion( p, math.Rand(0.5,0.8) )
			end
		end)
	end

	self:Debris( Pos )

	local traceSky = util.TraceLine( {
		start = Pos,
		endpos = Pos + Vector(0,0,50000),
		mask = MASK_SOLID_BRUSHONLY,
	} )

	local traceWater = util.TraceLine( {
		start = traceSky.HitPos,
		endpos = Pos - Vector(0,0,100),
		mask = MASK_WATER,
	} )

	if traceWater.Hit then
		local effectdata = EffectData()
		effectdata:SetOrigin( traceWater.HitPos )
		effectdata:SetScale( 100 )
		effectdata:SetFlags( 2 )
		util.Effect( "WaterSplash", effectdata, true, true )
	else
		local trace = util.TraceLine( {
			start = Pos + Vector(0,0,100),
			endpos = Pos - Vector(0,0,100),
			mask = MASK_SOLID_BRUSHONLY,
		} )

		if trace.Hit and not trace.HitNonWorld then
			for i = 1, 10 do
				local StartPos = trace.HitPos + Vector(math.random(-25,25) * i,math.random(-25,25) * i,0)
				local decalTrace = util.TraceLine( {
					start = StartPos + Vector(0,0,100),
					endpos = StartPos - Vector(0,0,100),
					mask = MASK_SOLID_BRUSHONLY,
				} )

				util.DecalEx( self.DecalMat, trace.Entity, decalTrace.HitPos + decalTrace.HitNormal, decalTrace.HitNormal, Color(255,255,255,255), math.Rand(2,3), math.Rand(2,3) )
			end
		end
	end
end

function EFFECT:Debris( pos )
	local emitter = ParticleEmitter( pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,60 do
		local particle = emitter:Add( "effects/fleck_tile"..math.random(1,2), pos )
		local vel = VectorRand() * math.Rand(200,600)
		vel.z = math.Rand(200,600)
		if particle then
			particle:SetVelocity( vel )
			particle:SetDieTime( math.Rand(10,15) )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( 5 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,0 )
			particle:SetGravity( Vector( 0, 0, -600 ) )
			particle:SetCollide( true )
			particle:SetBounce( 0.3 )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )
	
	if not IsValid( emitter ) then return end

	for i = 0,10 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )

		if particle then
			particle:SetVelocity( VectorRand() * 1500 * scale )
			particle:SetDieTime( math.Rand(0.75,1.5) * scale )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(60,120) * scale )
			particle:SetEndSize( math.Rand(220,320) * scale )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 40,40,40 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )

		if particle then
			particle:SetVelocity( VectorRand() * 1500 * scale )
			particle:SetDieTime( 0.2 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 20 * scale )
			particle:SetEndSize( math.Rand(180,240) * scale )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local dlight = DynamicLight( math.random(0,9999) )
	if dlight then
		dlight.pos = pos
		dlight.r = 255
		dlight.g = 180
		dlight.b = 100
		dlight.brightness = 8
		dlight.Decay = 2000
		dlight.Size = 300
		dlight.DieTime = CurTime() + 1
	end
end

function EFFECT:Think()
	if CurTime() < self.DieTime then return true end

	return false
end

function EFFECT:Render()
end

--addons/lvs_addons/lua/effects/lvs_laser_explosion.lua:

local GlowMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Col = data:GetStart() or Vector(255,100,0)

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/light_glow02_add", self.Pos )
		
		local vel = VectorRand() * 400
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.4,0.8) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(24,48) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( self.Col.x,self.Col.y,self.Col.z )
			particle:SetGravity( Vector(0,0,-600) )

			particle:SetAirResistance( 0 )
			
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end
	
	for i = 0, 20 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( 0.15 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 )
			particle:SetEndSize( 32 )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetRollDelta( math.Rand( -1, 1 ) * 100 )
			particle:SetColor( self.Col.x,self.Col.y,self.Col.z )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	if not self.Col then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 400 * Scale, 400 * Scale, Color( self.Col.x,self.Col.y,self.Col.z, 255) )
	render.DrawSprite( self.Pos, 100 * Scale, 100 * Scale, Color( 255, 255, 255, 255) )
end

--addons/lvs_base/lua/effects/lvs_tracer_yellow.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1600 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 3, 1, 0, Color( 255, 255, 125, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 10, 1, 0, Color( 125, 80, 0, 255 ) )
end

--addons/aoc_fire_system/lua/effects/rb655_extinguisher_effect.lua:

function EFFECT:Init( data )

	self.Player = data:GetEntity()
	self.Origin = data:GetOrigin()
	self.Attachment = data:GetAttachment()
	self.Forward = data:GetNormal()
	self.Scale = data:GetScale()

	if ( !IsValid( self.Player ) || !IsValid( self.Player:GetActiveWeapon() ) ) then return end

	self.Angle = self.Forward:Angle()
	self.Position = self:GetTracerShootPos( self.Origin, self.Player:GetActiveWeapon(), self.Attachment )

	if ( self.Position == self.Origin ) then
		local att = self.Player:GetAttachment( self.Player:LookupAttachment( "anim_attachment_RH" ) )
		if ( att ) then self.Position = att.Pos + att.Ang:Forward() * -2 end
	end

	local teh_effect = ParticleEmitter( self.Player:GetPos(), true )
	if ( !teh_effect ) then return end

	for i = 1, 12 * self.Scale do
		local particle = teh_effect:Add( "effects/splash4", self.Position )
		if ( particle ) then
			local Spread = 0.3
			particle:SetVelocity( ( Vector( math.sin( math.Rand( 0, 360 ) ) * math.Rand( -Spread, Spread ), math.cos( math.Rand( 0, 360 ) ) * math.Rand( -Spread, Spread ), math.sin( math.random() ) * math.Rand( -Spread, Spread ) ) + self.Forward ) * 750 )

			local ang = self.Angle
			if ( i / 2 == math.floor( i / 2 ) ) then ang = ( self.Forward * -1 ):Angle() end
			particle:SetAngles( ang )
			particle:SetDieTime( 0.25 )
			particle:SetColor( 255, 255, 255 )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 8 )
			particle:SetEndSize( 0 )
			particle:SetCollide( 1 )
			particle:SetCollideCallback( function( particleC, HitPos, normal )
				particleC:SetAngleVelocity( Angle( 0, 0, 0 ) )
				particleC:SetVelocity( Vector( 0, 0, 0 ) )
				particleC:SetPos( HitPos + normal * 0.1 )
				particleC:SetGravity( Vector( 0, 0, 0 ) )

				local angles = normal:Angle()
				angles:RotateAroundAxis( normal, particleC:GetAngles().y )
				particleC:SetAngles( angles )

				particleC:SetLifeTime( 0 )
				particleC:SetDieTime( 10 )
				particleC:SetStartSize( 8 )
				particleC:SetEndSize( 0 )
				particleC:SetStartAlpha( 128 )
				particleC:SetEndAlpha( 0 )
			end )
		end
	end

	teh_effect:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/arccw_weapons/lua/effects/rw_rocket_explosion.lua:
if SERVER then AddCSLuaFile() end

function EFFECT:Init(data)
	self.Start = data:GetOrigin()
	self.size = data:GetScale()
	self.Emitter = ParticleEmitter(self.Start)
	
	for i = 1, 55 do
		local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(1, 9), self.Start)
		p:SetDieTime(math.Rand((4/3), 4))
		p:SetStartAlpha(95)
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(100, 140) * self.size)
		p:SetEndSize(55 * self.size)
		p:SetRoll(math.Rand(-1, 1))
		p:SetRollDelta(math.Rand(-1, 1))
		p:SetCollide(true)	
		p:SetVelocity(VectorRand():GetNormal()*220)
		p:SetColor(115, 115, 115)
	end

	for i = 1, math.random(20, 50) do
		local p = self.Emitter:Add("effects/muzzleflash"..math.random(1,4), self.Start)
		p:SetDieTime(math.Rand(0.1, 0.25))
		p:SetStartAlpha(255)
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(50, 150) * self.size)
		p:SetEndSize(50 * self.size)
		p:SetRoll(math.Rand(-50, 50))
		p:SetRollDelta(math.Rand(-10, 10))
		p:SetCollide(true)
		p:SetVelocity(VectorRand():GetNormal() * math.random(25, 75) * self.size)
		p:SetColor(255, 150, 0)
	end

	for i = 1, math.random(40, 70) do
		local vec = VectorRand():GetNormal()
		vec.z = 0
		local pos = (self.Start + vec * 5)
		local p = self.Emitter:Add("sprites/orangeflare1", self.Start + vec * 10)
		p:SetDieTime(math.Rand(2, 3))
		p:SetStartAlpha(255)
		p:SetEndAlpha(0)
		p:SetStartSize(15)
		p:SetEndSize(3)
		p:SetVelocity(((pos - self.Start):GetNormal() * math.random(200, 350)) + Vector(0, 0, math.random(50, 300)) * self.size)
		p:SetGravity( Vector( 0, 0, -1750 ) );
		p:SetColor(255, 255, 255)
		p:SetCollide(true)
	end

	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end
--addons/weapon_jedi/lua/effects/saber_hit_generic.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	self:Spark( self.Pos )
	self:Smoke( self.Pos )
end


function EFFECT:Smoke( pos )
	local emitter = ParticleEmitter( pos, false )
	
	for i = 0,1 do
		local particle = emitter:Add( Materials[ math.random(1,table.Count( Materials )) ], pos )
		
		local vel = VectorRand() * math.Rand(10,30)
		
		if particle then			
			particle:SetVelocity( vel )
			particle:SetDieTime( math.Rand(0.5,1.5) )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 50 )
			particle:SetStartSize( 10 )
			particle:SetEndSize( 25 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 40,40,40 )
			particle:SetGravity( Vector(0,0,200) )
			particle:SetCollide( false )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Spark( pos )
	local emitter = ParticleEmitter( pos, false )
	
	for i = 0, 10 do
		local particle = emitter:Add( "sprites/rico1", pos )
		
		local vel = VectorRand() * 100
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( 0.5 )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 1 )
			particle:SetEndSize( 0.25 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 150, 0 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end
	
	return true
end

local mat = Material( "sprites/light_glow02_add" )

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( mat )
	render.DrawSprite( self.Pos, 25 * Scale, 25 * Scale, Color( 255, 100, 0, 255) ) 
end

--addons/arccw_weapons/lua/effects/tfa_csgo_smokenade/init.lua:
--Thanks Inconceivable/Generic Default
function EFFECT:Init(data)
	self.Entity = data:GetEntity()
	pos = data:GetOrigin()
	self.Emitter = ParticleEmitter(pos)
	for i=1, 100 do
		local particle = self.Emitter:Add( "tfa_csgo/particle/particle_smokegrenade", pos)
		if (particle) then
			particle:SetVelocity( VectorRand():GetNormalized()*math.Rand(150, 400) )
			if i <= 1 then 
				particle:SetDieTime( 25 )
			else
				particle:SetDieTime( math.Rand( 23,28 ) )
			end
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 44 )
			particle:SetEndSize( 144 )
			particle:SetRoll( math.Rand(0, 360) )
			particle:SetRollDelta( math.Rand(-1, 1)/3 )
			particle:SetColor( 65, 65, 65 ) 
			particle:SetAirResistance( 100 ) 
			//particle:SetGravity( Vector(math.Rand(-30, 30),math.Rand(-30, 30), -200 )) 	
			particle:SetCollide( true )
			particle:SetBounce( 1 )
		end
	end

end

function EFFECT:Think()
return false
end

function EFFECT:Render()

end
--addons/arccw_weapons/lua/effects/tfa_tracer_green/init.lua:
-- Credits: Meeks, Xan, Matsil
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(0, 255, 0)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(0, 255, 40)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 0
        dlight.g = 255
        dlight.b = 0
        dlight.brightness = 3
        dlight.Decay = 1000
        dlight.Size = 200
        dlight.DieTime = CurTime() + 3
    end
end
end
--addons/arccw_weapons/lua/effects/tracer_laser/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Col1 = Color(255, 60, 30) --Color(225,225,225,225)
EFFECT.Col2 = Color(255, 60, 30)
EFFECT.Speed = 18192
EFFECT.TracerLength = 4528

--[[---------------------------------------------------------
Init( data table )
-----------------------------------------------------------]]
function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	-- Keep the start and end pos - we're going to interpolate between them
	self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.Length = (self.EndPos - self.StartPos):Length()
	--self.Alpha = 255
	self.Life = 0
	self.MaxLife = self.Length / self.Speed
	self:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.CurPos = self.StartPos
end

--[[---------------------------------------------------------
THINK
-----------------------------------------------------------]]
function EFFECT:Think()
	self.Life = self.Life + FrameTime() * (1 / self.MaxLife)
	--self.Alpha = 255 * ( 1 - self.Life )

	return self.Life < 1
end

--[[---------------------------------------------------------
Draw the effect
-----------------------------------------------------------]]
local lerpedcol = Color(225, 225, 225, 225)

function EFFECT:Render()
render.SetMaterial(self.Mat)
lerpedcol.r = Lerp(self.Life, self.Col1.r, self.Col2.r)
lerpedcol.g = Lerp(self.Life, self.Col1.g, self.Col2.g)
lerpedcol.b = Lerp(self.Life, self.Col1.b, self.Col2.b)
lerpedcol.a = Lerp(self.Life, self.Col1.a, self.Col2.a)
local startbeampos = Lerp(self.Life, self.StartPos, self.EndPos)
local endbeampos = Lerp(self.Life + self.TracerLength / self.Length, self.StartPos, self.EndPos)
render.DrawBeam(startbeampos, endbeampos, 8, 0, 2, lerpedcol)
end

--addons/arccw_weapons/lua/effects/tracer_laser_big_hot/init.lua:
EFFECT.Thickness = 16
EFFECT.Life = 0.25
EFFECT.RotVelocity = 30
EFFECT.InValid = false
local Mat_Impact = Material("effects/combinemuzzle2")
local Mat_Beam = Material("effects/tool_tracer")
local Mat_TracePart = Material("effects/select_ring")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	self.Alpha = 255
	self.FlashA = 255
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt:GetOwner()

		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)

		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end

		if self.WeaponEntOG.Akimbo then
			self.Attachment = 2 - self.WeaponEntOG.AnimCycle
		end
	end

	local angpos

	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = vector_origin,
			Ang = angle_zero
		}
	end
	self.texcoord = math.Rand( 0, 20 )/3

	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end

	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	self.LifeTime = self.Life
	self.data = data
	self.rot = 0
	
end
EFFECT.Mat = Material( "effects/beam_generic01" )
function EFFECT:Think()
	if self.InValid then return false end
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	self.FlashA = self.FlashA - 1150 * FrameTime()
	if (self.FlashA < 0) then self.FlashA = 0 end

	self.Alpha = self.Alpha - 1150 * FrameTime()
	if (self.Alpha < 0) then return false end
	
	return self.LifeTime > 0
end



local beamcol = Color(255, 93, 0, 255)
local beamcol2 = Color(255, 93, 0, 255)

function EFFECT:Render()
	if self.InValid then return false end
	self.StartPos = self:GetTracerShootPos(self.StartPos, self.WeaponEnt, self.Attachment)
	local startPos = self.StartPos
	local endPos = self.EndPos
	
	local tracerpos
	beamcol.a = self.LifeTime / self.Life * 255
	self.rot = self.rot + FrameTime() * self.RotVelocity
	render.SetMaterial(Mat_Impact)
	render.DrawSprite(endPos, 12, 12, ColorAlpha(color_white, beamcol.a))
	render.SetMaterial(Mat_TracePart)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life - 0.1, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot - 60)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life - 0.05, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot - 30)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life + 0.05, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot + 30)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life + 0.1, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot + 60)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life + 0.15, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot + 30)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life + 0.2, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot + 60)
	render.SetMaterial(Mat_Beam)
	render.DrawBeam(startPos, endPos, self.Thickness, 0 + beamcol.a / 128, endPos:Distance(startPos) / 64 + beamcol.a / 128, beamcol)
	local texcoord = self.texcoord
	render.SetMaterial( self.Mat )
		render.DrawBeam( self.StartPos, 										// Start
					 self.EndPos,											// End
					 4,													// Width
					 texcoord,														// Start tex coord
					 texcoord + 8000 / 256,									// End tex coord
					 Color( 255, 93, 0, math.Clamp(self.Alpha, 0,255)) )		// Color (optional)'
end
