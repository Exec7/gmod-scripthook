--Stealed clientside server code by exechack.cc
--Hostname: Ψ UkraineRP #1 ◈ Оновлення◈ Набiр ◈ M9K - Part 6/10 - 06/04/2025


--PATH addons/dash/lua/dash/extensions/type.lua:
local getmetatable 	= getmetatable
local tonumber 		= tonumber

local STRING 	= getmetatable ''
local ANGLE 	= FindMetaTable 'Angle'
local MATRIX 	= FindMetaTable 'VMatrix'
local VECTOR 	= FindMetaTable 'Vector'
local MATERIAL 	= FindMetaTable 'IMaterial'
local ENTITY 	= FindMetaTable 'Entity'
local PLAYER 	= FindMetaTable 'Player'
local PHYS 		= FindMetaTable 'PhysObj'
local WEAPON 	= FindMetaTable 'Weapon'
local NPC 		= FindMetaTable 'NPC'
local NEXTBOT 	= FindMetaTable 'NextBot'
local VEHICLE 	= FindMetaTable 'Vehicle'
local CSENTITY	= FindMetaTable 'CSEnt'

local entmts = {
	[ENTITY] 	= true,
	[VEHICLE] 	= true,
	[PHYS] 		= true,
	[WEAPON] 	= true,
	[NPC] 		= true,
	[PLAYER]	= true,
}

if (SERVER) then
	entmts[NEXTBOT] = true
else
    entmts[CSENTITY] = true
end

function isstring(v)
	return (getmetatable(v) == STRING)
end

function isangle(v)
	return (getmetatable(v) == ANGLE)
end

function ismatrix(v)
	return (getmetatable(v) == MATRIX)
end

function isvector(v)
	return (getmetatable(v) == VECTOR)
end

function ismaterial(v)
	return (getmetatable(v) == MATERIAL)
end

function isnumber(v)
	return (v ~= nil) and (v == tonumber(v))
end

function isbool(v)
	return (v == true) or (v == false)
end

function isentity(v)
	return (entmts[getmetatable(v)] == true)
end
IsEntity = isentity

function isplayer(v)
	return (getmetatable(v) == PLAYER)
end


function ENTITY:IsPlayer()
	return false
end

function PLAYER:IsPlayer()
	return true
end

function PHYS:IsPlayer()
	return false
end

function WEAPON:IsPlayer()
	return false
end

function NPC:IsPlayer()
	return false
end


function ENTITY:IsWeapon()
	return false
end

function PLAYER:IsWeapon()
	return false
end

function PHYS:IsWeapon()
	return false
end

function WEAPON:IsWeapon()
	return true
end

function NPC:IsWeapon()
	return false
end


function ENTITY:IsNPC()
	return false
end

function PLAYER:IsNPC()
	return false
end

function PHYS:IsNPC()
	return false
end

function WEAPON:IsNPC()
	return false
end

function NPC:IsNPC()
	return true
end


function ENTITY:IsNextbot()
	return false
end

function PLAYER:IsNextbot()
	return false
end

function PHYS:IsNextbot()
	return false
end

function WEAPON:IsNextbot()
	return false
end

function NPC:IsNextbot()
	return false
end


function ENTITY:IsPhysObj()
	return false
end

function PLAYER:IsPhysObj()
	return false
end

function PHYS:IsPhysObj()
	return false
end

function WEAPON:IsPhysObj()
	return false
end

function NPC:IsPhysObj()
	return false
end


if (SERVER) then
	function NEXTBOT:IsPlayer()
		return false
	end

	function NEXTBOT:IsWeapon()
		return false
	end

	function NEXTBOT:IsNPC()
		return false
	end

	function NEXTBOT:IsPhysObj()
		return false
	end

	function NEXTBOT:IsNextbot()
		return true
	end
end

--PATH addons/__________tperson/lua/3tcore/hook/cl_hook.lua:
timer.Simple(1, function()
    hook.Add("PlayerButtonDown", "TPerson-BindPress", TPerson.OnPlayerButtonDown)
    hook.Add("HUDShouldDraw", "TPerson-DisableCrossHair", TPerson.HUDShouldDraw)
    hook.Add("HUDPaint", "TPerson-HUD", TPerson.DrawCrossHair)
    hook.Add("CalcView", "TPerson-CalcView", TPerson.CalcView)
    gameevent.Listen("player_spawn")
    hook.Add("player_spawn", "TPerson-OnPlayerSpawn", TPerson.OnPlayerSpawn)
end)
--PATH addons/__________tperson/lua/3tcore/hook/sh_hook.lua:
timer.Simple(1, function() hook.Add("PlayerSwitchWeapon", "TPerson-OnPlayerSwitchWeapons", TPerson.OnPlayerSwitchWeapons) end)
--PATH addons/shaccessorysystem/lua/accessory_addons.lua:
-- In this file you can decide what accessory add-on to use on your server.
-- Remember that the more add-ons enabled, the more files your players will have to download to join.
-- If you are enabling an add-on that isn't supported by default by this script, you'll have to create the accessory items!
-- (See help file)

/*
	You can check out a list of recommended add-ons to use with this script here:
	http://pastebin.com/AKcpgFmq

	You can of course add other add-ons here if you're planning to create accessories with custom content yourself.
*/

SH_ACC.Addons = {
	/*
		This is how you enable an add-on. Copy the below line (without the --),
		and replace the 000000000 by the workshop add-on's ID
		to automatically add that add-on to the list of content to download.
	*/
	-- ["000000000"] = true,
}

/*local atleast = false

for id, enable in pairs (SH_ACC.Addons) do
	if (!enable) then
		continue end

	atleast = true

	if (SERVER) then
		resource.AddWorkshop(id)
	end
end

if (!atleast) then
	MsgC(Color(52, 152, 219), "SH Accessories", Color(219, 52, 52), ": No accessory add-ons were enabled at all! Check the accessory_addons.lua file to enable an add-on to use!\n")
	MsgC(Color(219, 52, 52), "While no add-on is enabled, the Accessory Vendor will show up empty.\n")

	if (CLIENT) then
		chat.AddText(Color(52, 152, 219), "SH Accessories", Color(219, 52, 52), ": No accessory add-ons were enabled at all! Check the accessory_addons.lua file to enable an add-on to use!")
		chat.AddText(Color(219, 52, 52), "While no add-on is enabled, the Accessory Vendor will show up empty.")
	end
end*/

--PATH addons/_ballistic_shields/lua/autorun/ballistic_shields_loader.lua:
if SERVER then
	AddCSLuaFile( "ballistic_shields/cl_bs_util.lua" )
	AddCSLuaFile( "ballistic_shields/sh_bs_util.lua" )
	AddCSLuaFile( "ballistic_shields/sh_bs_lang.lua" )
	AddCSLuaFile( "libraries/cl_surfacegeturl.lua" )
	AddCSLuaFile( "bs_config.lua" )
end

include( "bs_config.lua" )
include( "libraries/cl_surfacegeturl.lua" )
include( "ballistic_shields/cl_bs_util.lua" )
include( "ballistic_shields/sh_bs_util.lua" )
include( "ballistic_shields/sh_bs_lang.lua" )
--PATH addons/_ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )
--------------------- BALLISTIC SHIELDS V1.1.9 -------------------------
---- CONFIG ----
-- AVALAIBLE LANGUAGES - English, German, French, Danish, Turkish, Ukrainian
bshields.config.language = "Ukrainian"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 10
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 10
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 50
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 20
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 30
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 1
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = true
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false
-- REMOVE DEPLOYED SHIELDS ON JOB CHANGE
bshields.config.removeonjobchange = true
-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---
-- HEAVY SHIELD
bshields.config.hShieldTexture = ""
-- RIOT SHIELD
bshields.config.rShieldTexture = ""
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = ""
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---
-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = false
--PATH addons/__new_main_all/lua/main/totem_language.lua:
AddCSLuaFile()
--[[-----------------------
function area
--------------------------]]

NAME_OF_TOTEM = ""

function ChooseLanguage()
    local nation, default = GetConVar( "gmod_language" ):GetString(), "en"
    local lang

    if TOU_Language[nation] then lang = nation else lang = default end

    NAME_OF_TOTEM = TOU_Language[lang]
end

--[[-------------------------------------------------------
There are different languages of TOU( Totem of undying )
---------------------------------------------------------]]

TOU_Language = {}

TOU_Language["zh-CN"] = {
    
    wep_name = "不死图腾",
    saying = "超越生死",

}

TOU_Language["en"] = {

    wep_name = "Totem of Undying",
    saying = "Postmortal",

}
--PATH addons/__main/lua/autorun/csgo_knife_snd_init.lua:
sound.Add( {
	name = "csgo_knife.Deploy",
	channel = CHAN_WEAPON,
	volume = 0.4,
	level = 65,
	sound = "csgo_knife/knife_deploy1.wav"
} )

sound.Add( {
	name = "csgo_knife.Hit",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 65,
	sound = { "csgo_knife/knife_hit1.wav", "csgo_knife/knife_hit2.wav", "csgo_knife/knife_hit3.wav", "csgo_knife/knife_hit4.wav" }
} )

sound.Add( {
	name = "csgo_knife.HitWall",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 65,
	sound = { "csgo_knife/knife_hit_01.wav", "csgo_knife/knife_hit_02.wav", "csgo_knife/knife_hit_03.wav", "csgo_knife/knife_hit_04.wav", "csgo_knife/knife_hit_05.wav" }
} )

sound.Add( {
	name = "csgo_knife.HitWall_old",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 65,
	sound = { "csgo_knife/knife_hitwall1.wav", "csgo_knife/knife_hitwall2.wav", "csgo_knife/knife_hitwall3.wav", "csgo_knife/knife_hitwall4.wav" }
} )

sound.Add( {
	name = "csgo_knife.Slash",
	channel = CHAN_WEAPON,
	volume = {0.5, 1.0},
	pitch = {97, 105},
	level = 65,
	sound = { "csgo_knife/knife_slash1.wav", "csgo_knife/knife_slash2.wav" }
} )

sound.Add( {
	name = "csgo_knife.Slash_old",
	channel = CHAN_WEAPON,
	volume = {0.5, 1.0},
	pitch = {97, 105},
	level = 65,
	sound = { "csgo_knife/knife_slash1_old.wav", "csgo_knife/knife_slash2_old.wav" }
} )

sound.Add( {
	name = "csgo_knife.Stab",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 65,
	sound = "csgo_knife/knife_stab.wav"
} )

-- Butterfly
sound.Add( {
	name = "csgo_ButterflyKnife.backstab01",
	channel = CHAN_ITEM,
	volume = 0.4,
	soundlevel = 65,
	sound = "csgo_knife/bknife_backstab01.wav"
} )

sound.Add( {
	name = "csgo_ButterflyKnife.backstab02",
	channel = CHAN_ITEM,
	volume = 0.4,
	soundlevel = 65,
	sound = "csgo_knife/bknife_backstab02.wav"
} )

sound.Add( {
	name = "csgo_ButterflyKnife.draw01",
	channel = CHAN_ITEM,
	volume = 0.6,
	soundlevel = 65,
	sound = "csgo_knife/bknife_draw01.wav"
} )

sound.Add( {
	name = "csgo_ButterflyKnife.draw02",
	channel = CHAN_ITEM,
	volume = 0.6,
	soundlevel = 65,
	sound = "csgo_knife/bknife_draw02.wav"
} )

sound.Add( {
	name = "csgo_ButterflyKnife.look01_a",
	channel = CHAN_ITEM,
	volume = 0.4,
	soundlevel = 65,
	sound = "csgo_knife/bknife_look01_a.wav"
} )

sound.Add( {
	name = "csgo_ButterflyKnife.look01_b",
	channel = CHAN_ITEM,
	volume = 0.4,
	soundlevel = 65,
	sound = "csgo_knife/bknife_look01_b.wav"
} )

sound.Add( {
	name = "csgo_ButterflyKnife.look02_a",
	channel = CHAN_ITEM,
	volume = 0.4,
	soundlevel = 65,
	sound = "csgo_knife/bknife_look02_a.wav"
} )

sound.Add( {
	name = "csgo_ButterflyKnife.look02_b",
	channel = CHAN_ITEM,
	volume = 0.4,
	soundlevel = 65,
	sound = "csgo_knife/bknife_look02_b.wav"
} )

sound.Add( {
	name = "csgo_ButterflyKnife.look03_a",
	channel = CHAN_ITEM,
	volume = 0.4,
	soundlevel = 65,
	sound = "csgo_knife/bknife_look03_a.wav"
} )

sound.Add( {
	name = "csgo_ButterflyKnife.look03_b",
	channel = CHAN_ITEM,
	volume = 0.4,
	soundlevel = 65,
	sound = "csgo_knife/bknife_look03_b.wav"
} )

sound.Add( {
	name = "csgo_KnifeFalchion.inspect",
	channel = CHAN_STATIC,
	volume = 1,
	soundlevel = 65,
	sound = "csgo_knife/knife_falchion_inspect.wav"
} )

sound.Add( {
	name = "csgo_KnifeFalchion.draw",
	channel = CHAN_STATIC,
	volume = {0.4, 0.9},
	pitch = {97, 105},
	soundlevel = 65,
	sound = "csgo_knife/knife_falchion_draw.wav"
} )

sound.Add( {
	name = "csgo_KnifeFalchion.Catch",
	channel = CHAN_STATIC,
	volume = {0.3, 0.7},
	pitch = {97, 105},
	soundlevel = 65,
	sound = "csgo_knife/knife_falchion_catch.wav"
} )

sound.Add( {
	name = "csgo_KnifeFalchion.Idlev2",
	channel = CHAN_STATIC,
	volume = 1,
	soundlevel = 65,
	sound = "csgo_knife/knife_falchion_idle.wav"
} )

sound.Add( {
	name = "csgo_Weapon.WeaponMove1", 
	channel = CHAN_ITEM,
	volume = 0.15,
	soundlevel = 65,
	sound = "csgo_knife/movement1.wav"
} )

sound.Add( {
	name = "csgo_Weapon.WeaponMove3",
	channel = CHAN_ITEM,
	volume = 0.15,
	soundlevel = 65,
	sound = "csgo_knife/movement3.wav"
} )

sound.Add( {
	name = "csgo_Weapon.WeaponMove2",
	channel = CHAN_ITEM,
	volume = 0.15,
	soundlevel = 65,
	sound = "csgo_knife/movement2.wav"
} )

sound.Add( {
	name = "csgo_KnifePush.Attack1Heavy",
	channel = CHAN_STATIC,
	volume = {0.1, 0.2},
	pitch = {98, 105},
	level = 65,
	sound = { "csgo_knife/knife_push_attack1_heavy_01.wav", "csgo_knife/knife_push_attack1_heavy_02.wav", "csgo_knife/knife_push_attack1_heavy_03.wav", "csgo_knife/knife_push_attack1_heavy_04.wav" }
} )

sound.Add( {
	name = "csgo_KnifePush.LookAtStart",
	channel = CHAN_STATIC,
	volume = 0.2,
	level = 65,
	sound = { "csgo_knife/knife_push_lookat_start.wav" }
} )

sound.Add( {
	name = "csgo_KnifePush.LookAtEnd",
	channel = CHAN_STATIC,
	volume = 0.2,
	level = 65,
	sound = { "csgo_knife/knife_push_lookat_end.wav" }
} )

sound.Add( {
	name = "csgo_KnifePush.Draw",
	channel = CHAN_STATIC,
	volume = 0.3,
	level = 65,
	sound = { "csgo_knife/knife_push_draw.wav" }
} )

sound.Add( {
	name = "KnifeBowie.draw",
	channel = CHAN_STATIC,
	volume = {0.7, 0.8},
    pitch = {99, 100},
	level = 65,
	sound = { "csgo_knife/knife_bowie_draw.wav" }
} )

sound.Add( {
	name = "KnifeBowie.LookAtStart",
	channel = CHAN_STATIC,
	volume = {0.2, 0.2},
    pitch = {99, 100},
	level = 65,
	sound = { "csgo_knife/knife_bowie_inspect_start.wav" }
} )

sound.Add( {
	name = "KnifeBowie.LookAtEnd",
	channel = CHAN_STATIC,
	volume = {0.2, 0.3},
    pitch = {99, 101},
	level = 65,
	sound = { "csgo_knife/knife_bowie_inspect_end.wav" }
} )
--PATH addons/_drones/lua/dronesrewrite/commands.lua:
local function findDrone(console, args)
	if not args[1] then return NULL end

	local drone = args[1] == "-sel" and console.SelectedDrone or DRONES_REWRITE.FindDroneByUnit(args[1])
	if IsValid(drone) then 
		if drone.IS_DRONE and not drone.IS_DRR then
			console:AddLine("Unknown system protocol! Console only supports drones from Drones Rewrite!", Color(255, 0, 0)) 
		end
	else
		console:AddLine("Drone is not found!", Color(255, 0, 0)) 
	end

	return drone
end

local commands_buf = { }

DRONES_REWRITE.AddCommand = function(name, func)
	commands_buf[name] = func
end

DRONES_REWRITE.Words = {
	[1] = { -- Very easy
	        "FRIED",
	        "TREES",
	        "RIGID",
	        "HIRED",
	        "TRIES",
	        "WRITE",
	        "TRIED",
	        "GREED",
	        "DRIED",
	        "BRAIN",
	        "SKIES",
	        "LAWNS",
	        "GHOST",
	        "CAUSE",
	        "PAINT",
	        "SHINY",
	        "MAKES",
	        "GAINS",
	        "THIEF",
	        "BASES",
	        "RAISE",
	        "REFER",
	        "CARES",
	        "TAKEN",
	        "WAKES",
	        "WAVES",
	        "WARNS",
	        "SAVES"
	},

	[2] = { -- Easy
	        "STATING",
	        "HEALING",
	        "COSTING",
	        "REASONS",
	        "SEASIDE",
	        "SPARING",
	        "CAUSING",
	        "CRAFTED",
	        "PRISONS",
	        "PRESENT",
	        "DEALING",
	        "SETTING",
	        "LEAVING",
	        "VERSION",
	        "DEATHLY",
	        "BLAZING",
	        "GRANITE",
	        "TESTING",
	        "TRAITOR",
	        "STAMINA",
	        "TRINITY",
	        "CALLING",
	        "TALKING",
	        "ACQUIRE",
	        "WELCOME",
	        "DECRIES",
	        "FALLING",
	        "PACKING",
	        "ALLOWED",
	        "SELLING",
	        "AFFRONT",
	        "WALKING"
	},

	[3] = { -- Average
	        "CONQUORER",
	        "CONSISTED",
	        "WONDERFUL",
	        "COMMITTEE",
	        "SURRENDER",
	        "SUBJECTED",
	        "CONVICTED",
	        "FORBIDDEN",
	        "FORTIFIED",
	        "COLLECTED",
	        "CONTINUED",
	        "PERIMETER",
	        "SOUTHEAST",
	        "RELEASING",
	        "SOMETHING",
	        "ACCEPTING",
	        "MUTATIONS",
	        "GATHERING",
	        "LITERALLY",
	        "REPAIRING",
	        "INCESSANT",
	        "INTERIORS",
	        "REGARDING",
	        "TELEPHONE",
	        "OBTAINING",
	        "EXTENSIVE",
	        "DEFEATING",
	        "REQUIRING",
	        "UNLOCKING",
	        "RECYCLING",
	        "INSTINCTS",
	        "BARTERING",
	        "LEUTENANT",
	        "COMMUNITY",
	        "BATTERIES",
	        "RECIEVING",
	        "INCLUDING",
	        "INITIALLY",
	        "INVOLVING",
	        "MOUNTAINS"
	},

	[4] = { -- Hard
	        "DISCOVERING",
	        "ELIMINATING",
	        "UNIMPORTANT",
	        "MISTRUSTING",
	        "MANUFACTURE",
	        "RADIOACTIVE",
	        "EXCLUSIVELY",
	        "BOMBARDMENT",
	        "DECEPTIVELY",
	        "INDEPENDENT",
	        "UNBELIEVERS",
	        "EFFECTIVELY",
	        "IMMEDIATELY",
	        "INFESTATION",
	        "DESCRIPTION",
	        "INFORMATION",
	        "REMEMBERING",
	        "NIGHTVISION",
	        "DESTRUCTION",
	        "OVERLOOKING"
	},

	[5] = { -- Very hard
	        "INFILTRATION",
	        "ORGANIZATION",
	        "AUTHENTICITY",
	        "APPRECIATION",
	        "SPOKESPERSON",
	        "LABORATORIES",
	        "INITIATEHOOD",
	        "SUBTERRANEAN",
	        "PURIFICATION",
	        "TRANSMISSION",
	        "CIVILIZATION",
	        "CONSTRUCTION",
	        "RESURRECTION",
	        "REPRIMANDING",
	        "ACCOMPANYING",
	        "OVERWHELMING",
	        "CONVERSATION",
	        "NORTHERNMOST",
	        "TRANSCRIBING",
	        "ANNOUNCEMENT",
	        "SECLUTIONIST"
	}
}

DRONES_REWRITE.GetCommands = function()
	local terminal = { }

	table.Add(terminal, commands_buf)

	terminal["health"] = function(self, args)
		self:AddLine(self.Hp)
	end

	terminal["break"] = function(self, args)
		self:Explode()
	end

	terminal["blockkeys"] = function(self, args)
		if not args[2] or (args[2] != "1" and args[2] != "0") then
			self:AddLine("Incorrect format! blockkeys DRONEID 1 or blockkeys DRONEID 0.", Color(255, 0, 0))
			return 
		end

		local drone = findDrone(self, args)

		if drone:IsValid() and self.User:IsAdmin() then
			local val = tobool(args[2])
			drone.BlockKeys = val
			val = val and "blocked" or "unblocked"
			self:AddLine("Keys has been " .. val .. ".")
		end
	end

	terminal["hints"] = function(self, args)
		if not args[1] or (args[1] != "1" and args[1] != "0") then
			self:AddLine("Incorrect format! hints 1 or hints 0.", Color(255, 0, 0))
			return 
		end

		self:SetNWBool("noHints", not tobool(args[1]))
	end

	terminal["say"] = function(self, args)
		if not args[1] then
			self:AddLine("Incorrect format! say TEXT.")
			return
		end

		local str = ""
		for k, v in ipairs(args) do str = str .. v .. " " end
		self.User:Say(str)
	end

	terminal["randscr"] = function(self, args)
		if not args[1] or (args[1] != "1" and args[1] != "0") then
			self:AddLine("Incorrect format! randscr 1 or randscr 0.", Color(255, 0, 0))
			return 
		end

		self:SetNWBool("noRandomScr", not tobool(args[1]))
	end

	terminal["exit"] = function(self, args)
		self:Exit()
	end

	terminal["lights"] = function(self, args)
		if not args[1] or (args[1] != "1" and args[1] != "0") then
			self:AddLine("Incorrect format! lights 1 or lights 0.", Color(255, 0, 0))
			return 
		end

		self:SetNWBool("noLights", not tobool(args[1]))
	end

	terminal["screen"] = function(self, args)
		if not args[1] or (args[1] != "1" and args[1] != "0") then
			self:AddLine("Incorrect format! screen 1 or screen 0.", Color(255, 0, 0))
			return 
		end

		self:SetNWBool("noScreen", not tobool(args[1]))
	end

	terminal["printbinds"] = function(self, args)
		for k, v in pairs(DRONES_REWRITE.Keys) do
			self:AddLine(k .. " binded to " .. DRONES_REWRITE.KeyNames[v] .. ".")
		end
	end

	terminal["overridepower"] = function(self, args)
		if not args[2] then
			self:AddLine("Incorrect format! overridepower DRONEID NUMBER or overridepower DRONEID OLD.", Color(255, 0, 0))
			return 
		end

		local drone = findDrone(self, args)

		if drone:IsValid() and drone:CanBeControlledBy_skipai(self.User) then
			if args[2] == "old" then args[2] = 2.2535 end

			drone.FlyConstant = args[2]
			self:AddLine("Overrided to " .. args[2] .. ".")
		end
	end

	terminal["presskeybind"] = function(self, args)
		if not args[2] then
			self:AddLine("Incorrect format! presskeybind DRONEID _KEY or presskeybind DRONEID _BIND.", Color(255, 0, 0))
			self:AddLine("You can find binds by typing printbinds.", Color(255, 0, 0))
			return 
		end

		local drone = findDrone(self, args)

		if drone:IsValid() and drone:CanBeControlledBy_skipai(self.User) then
			drone:ClickKey(args[2])
			self:AddLine("Clicked.")
		end
	end

	terminal["kick"] = function(self, args)
		local drone = findDrone(self, args)

		if drone:IsValid() and drone:CanBeControlledBy_skipai(self.User) then
			drone:SetDriver(NULL)
			self:AddLine("Driver has been kicked.")
		end
	end

	terminal["forcecontrol"] = function(self, args)
		if not args[2] then 
			self:AddLine("Incorrect format! forcecontrol DRONEID PLAYERNICK.", Color(255, 0, 0))
			return 
		end

		local ply = NULL

		for k, v in player.Iterator() do
			if string.find(string.lower(v:Name()), string.lower(args[2])) then
				ply = v
				break
			end
		end

		if not ply:IsValid() then
			self:AddLine("Could not find player with name " .. args[2] .. ".", Color(255, 0, 0))
			return 
		end

		local drone = findDrone(self, args)

		if drone:IsValid() and self.User:IsAdmin() then
			drone:SetDriver(NULL)
			drone:SetDriver(ply, 1000000, self)
			self:AddLine("Driver has been changed.")
		end
	end

	terminal["helpmenu"] = function(self, args)
		self.User:ConCommand("dronesrewrite_help")
	end

	terminal["screamdriver"] = function(self, args)
		local drone = findDrone(self, args)

		if drone:IsValid() and drone:CanBeControlledBy_skipai(self.User) then
			drone:EmitSound("npc/stalker/go_alert2.wav")
			self:AddLine("Screamed as hell!")
		end
	end

	terminal["info"] = function(self, args)
		local drone = findDrone(self, args)

		if drone:IsValid() then
			self:AddLine("Getting info...")
			self:AddLine("------------------------------------------")

			self:AddLine("Security level: " .. drone.HackValue)
			self:AddLine("HP: " .. drone:GetHealth())
			self:AddLine("Weapons: ")

			for k, v in pairs(drone.ValidWeapons) do
				self:AddLine("" .. k .. ": ")

				self:AddLine("    Primary ammo: " .. v.PrimaryAmmo)
				self:AddLine("    Secondary ammo: " .. v.SecondaryAmmo)

				self:AddLine("")
			end

			local name = "no driver"
			if drone:GetDriver():IsValid() then name = drone:GetDriver():Name() end
			self:AddLine("Driver: " .. name)

			local name = "no owner"
			if drone.Owner:IsValid() then name = drone.Owner:Name() end
			self:AddLine("Owner: " .. name)

			self:AddLine("Enabled: " .. tostring(drone.Enabled))
			self:AddLine("Public: " .. tostring(drone.AllowControl))
			self:AddLine("Speed: " .. (drone.Speed + drone.UpSpeed + drone.RotateSpeed) / 3)
			self:AddLine("Fuel: " .. drone:GetFuel())
			self:AddLine("Selected weapon: " .. drone.CurrentWeapon)

			self:AddLine("")

			self:AddLine("Installed modules: ")
			self.Commands["imodules"](self, args)

			self:AddLine("")

			self:AddLine("Hooks: ")

			for k, v in pairs(drone.hooks) do
				self:AddLine("Hook: " .. k)

				for name, foo in pairs(v) do
					self:AddLine("    " .. name)
				end

				self:AddLine("")
			end

			self:AddLine("------------------------------------------")
		end
	end

	terminal["print"] = function(self, args)
		if not args[1] then 
			self:AddLine("Incorrect format! print TEXT or print TEXT COLOR.", Color(255, 0, 0))
			return 
		end

		local color = { 255, 255, 255 }
		local str = ""

		local buf = { }
		table.Add(buf, args)

		if #args > 3 then
			for i = 0, 2 do
				local statement = args[#args - i]

				if tonumber(statement) then
					color[3 - i] = statement
					buf[#args - i] = nil
				else
					buf = { }
					table.Add(buf, args)

					color = { 255, 255, 255 }
					break
				end
			end
		end

		for k, v in pairs(buf) do str = str .. " " .. v end

		self:AddLine(str, Color(color[1], color[2], color[3]))
	end

	terminal["me"] = function(self, args)
		if not args[1] then 
			self:AddLine("Incorrect format! me TEXT or me TEXT COLOR.", Color(255, 0, 0))
			return 
		end

		args[1] = self.User:Name() .. " " .. args[1]
		self.Commands["print"](self, args)
	end

	terminal["control"] = function(self, args)
		local drone = findDrone(self, args)

		if drone:IsValid() and drone:CanBeControlledBy_skipai(self.User) then
			drone:SetDriver(self.User, 1000000, self)
			self:Exit()
		end
	end

	terminal["addmodule"] = function(self, args)
		local drone = findDrone(self, args)

		if drone:IsValid() and drone:CanBeControlledBy_skipai(self.User) then
			if not args[2] then
				self:AddLine("Incorrect format! removewep DRONEID MODULENAME.", Color(255, 0, 0))
				return
			end

			local a = { }
			for i = 2, #args do a[i - 1] = args[i] end
			local str = string.lower(table.concat(a, " "))

			drone:AddModule(str)
			self:AddLine(str .. " has been added.")
		end
	end

	terminal["removemodule"] = function(self, args)
		local drone = findDrone(self, args)

		if drone:IsValid() and drone:CanBeControlledBy_skipai(self.User) then
			if not args[2] then
				self:AddLine("Incorrect format! removewep DRONEID MODULENAME", Color(255, 0, 0))
				return
			end

			local a = { }
			for i = 2, #args do a[i - 1] = args[i] end
			local str = string.lower(table.concat(a, " "))

			drone:RemoveModule(str)
			self:AddLine(str .. " has been removed.")
		end
	end

	terminal["imodules"] = function(self, args)
		local drone = findDrone(self, args)

		if drone:IsValid() then
			self:AddLine("-- Found modules --")

			for k, v in pairs(drone.ValidModules) do
				self:AddLine(k)
			end
		end
	end

	terminal["removewep"] = function(self, args)
		local drone = findDrone(self, args)

		if drone:IsValid() and drone:CanBeControlledBy_skipai(self.User) then
			if not args[2] then
				self:AddLine("Incorrect format! removewep DRONEID WEPNAME.", Color(255, 0, 0))
				return
			end

			local a = { }
			for i = 2, #args do a[i - 1] = args[i] end
			local str = string.lower(table.concat(a, " "))

			drone:RemoveWeapon(str)
			self:AddLine(str .. " has been removed")
		end
	end

	terminal["addwep"] = function(self, args)
		local drone = findDrone(self, args)

		if drone:IsValid() and drone:CanBeControlledBy_skipai(self.User) and self.User:IsAdmin() then
			-- TODO: FIX SPACE BUG

			if not args[2] or not args[3] then
				self:AddLine("Incorrect format! addwep DRONEID WEPNAME YOURWEPNAME X Y Z P Y R VISIBLE PRIMARYASSECONDARY ATTACHMENT or addwep DRONEID WEAPON", Color(255, 0, 0))
				return
			end

			local wep = args[2]
			local name = args[3]
			
			local x = tonumber(args[4])
			local y = tonumber(args[5])
			local z = tonumber(args[6])

			local p = tonumber(args[7])
			local ya = tonumber(args[8])
			local r = tonumber(args[9])

			local select = tobool(args[10])
			local prims = tobool(args[11])
			local attachment = args[12]

			drone:FastAddWeapon(name, wep, Vector(x, y, z), { }, Angle(p, ya, r), select, prims, attachment)

			self:AddLine(name .. " has been added.")
		end
	end

	terminal["select"] = function(self, args)
		local drone = findDrone(self, args)

		if drone:IsValid() then
			self:AddLine("Selected " .. drone:GetUnit() .. ".")
			self:SetDrone(drone)
		end
	end

	terminal["unselect"] = function(self, args)
		if IsValid(self.SelectedDrone) then 
			self:AddLine(self.SelectedDrone:GetUnit() .. " has been unselected.") 
		end

		self:SetDrone(NULL)
	end

	terminal["clear"] = function(self, args)
		self:Clear()
	end

	terminal["printlist"] = function(self, args)
		self:AddLine("-- Found drones --")

		for k, v in ents.Iterator() do
			if v.IS_DRONE then self:AddLine(v:GetUnit()) end
		end
	end

	terminal["hack"] = function(self, args)
		if self.Failed then
			self.CatchCommand = function(self, args, cmd) 
				if cmd == "exit" then return true end
				return false 
			end

			self:AddLine(" ")
			self:AddLine("Waiting for protection system to reboot...")

			timer.Create("dronesrewrite_console_cooldown" .. self:EntIndex(), math.random(10, 12), 1, function()
				if IsValid(self) then 
					self.CatchCommand = nil 
					self.Failed = false 

					self:AddLine("Done.")
				end
			end)

			return
		end

		if self.Hacking then
			self:AddLine("Type exithack command first!")
			return
		end

		if self.CatchCommand then
			self:AddLine("Something went wrong...")
			return
		end

		local drone = findDrone(self, args)

		if drone:IsValid() then
			self:AddLine("Please wait. Getting info...")

			timer.Simple(math.Rand(2, 4), function()
				if not IsValid(self) then return end
				if not IsValid(drone) then return end

				local Words = DRONES_REWRITE.Words[drone.HackValue]
				if not Words then 
					self:AddLine("Something went wrong. Hacking failed.")
					return
				end

				self.Attempts = 4

				if drone.AllowControl then
					self:AddLine("Already hacked!")
					return
				end

				self:EmitSound("buttons/button24.wav", 60)

				self:AddLine(" ")
				self:AddLine("4 ATTEMPT(S) LEFT")
				self:AddLine(" ")

				local vals = { }
				local _vals = "!@#%^*()_-=+\\|/[]{}?\"\':;,.<>"
				for i = 1, string.len(_vals) do vals[i] = string.sub(_vals, i, i) end

				local left = math.floor(#Words * 0.7)
				local entered = { }
				local line = ""

				while left > 0 do
					local word = table.Random(Words)
					if entered[word] then continue end

					for i = 4, math.random(0, 20) + string.len(word) do line = line .. table.Random(vals) end
					line = line .. word

					entered[word] = word

					left = left - 1
				end

				-- Getting password
				local pass = table.Random(entered)
				local len = string.len(pass)

				local hex = math.random(1, 200) + 63744
				for i = 1, string.len(line), 51 do
					self:AddLine("0x" .. string.format("%x", hex):upper() .. "   " .. string.sub(line, i, i + 50))
					hex = hex + 12
				end

				self.CatchCommand = function(self, args, cmd)
					if not IsValid(drone) then 
						self:AddLine("Drone's signal was lost!", Color(255, 0, 0))
						self.Commands["exithack"](self)

						return false
					end
					
					if cmd == "show_password" then
						if drone:CanBeControlledBy_skipai(self.User) then
							self:AddLine("Password for this session: " .. pass)
						else
							self:AddLine("Access denied!")
						end

						return false
					elseif cmd == "exit" or cmd == "exithack" then
						return true
					elseif self.Commands[cmd] then
						self:AddLine("Type exithack command first!")
						return false
					end
					
					local checkpass = string.lower(pass)

					if checkpass == cmd then
						self:AddLine("Hacked!", Color(0, 255, 0))
						self:EmitSound("buttons/button5.wav")
						self.Commands["exithack"](self)
						drone.AllowControl = true
					else
						self:AddLine("Incorrect password.", Color(255, 0, 0))

						local count = 0
						for i = 1, len do
							if string.sub(cmd, i, i) == string.sub(checkpass, i, i) then
								count = count + 1
							end
						end

						self:AddLine(count .. " / " .. len .. " correct.")

						self:EmitSound("buttons/button10.wav")
						self.Attempts = self.Attempts - 1

						self:AddLine(self.Attempts .. " ATTEMPT(S) LEFT")

						if self.Attempts <= 0 then
							self.Commands["exithack"](self)
							self.Failed = true
						end
					end

					return false
				end

				self.Hacking = true
			end)
		end
	end

	terminal["exithack"] = function(self, args)
		if not self.Hacking then
			self:AddLine("We aren't hacking right now!")
			return
		end

		self:AddLine("Exiting from hacking...")

		self.Attempts = 4
		self.Hacking = false
		self.CatchCommand = nil
	end

	terminal["disable"] = function(self, args)
		local drone = findDrone(self, args)

		if drone:IsValid() and drone:CanBeControlledBy_skipai(self.User) then
			drone:SetEnabled(false)
			self:AddLine(drone:GetUnit() .. " has been disabled.")
		end
	end

	terminal["enable"] = function(self, args)
		local drone = findDrone(self, args)

		if drone:IsValid() and drone:CanBeControlledBy_skipai(self.User) then
			drone:SetEnabled(true)
			self:AddLine(drone:GetUnit() .. " has been enabled.")
		end
	end

	terminal["dropfuel"] = function(self, args)
		local drone = findDrone(self, args)

		if drone:IsValid() and drone:CanBeControlledBy_skipai(self.User) then
			drone:SetFuel(0)
			self:AddLine(drone:GetUnit() .. " has dropped fuel.")
		end
	end

	terminal["droppropellers"] = function(self, args)
		local drone = findDrone(self, args)

		if drone:IsValid() and drone:CanBeControlledBy_skipai(self.User) then
			drone:DropPropellers()
			self:AddLine(drone:GetUnit() .. " has dropped propellers.")
		end
	end

	terminal["destroy"] = function(self, args)
		local drone = findDrone(self, args)

		if drone:IsValid() and drone:CanBeControlledBy_skipai(self.User) then
			drone:Destroy()
			self:AddLine(drone:GetUnit() .. " has been destroyed.")
		end
	end

	terminal["modules"] = function(self, args)
		local drone = findDrone(self, args)

		if drone:IsValid() then
			self:AddLine("-- Found modules --")

			for k, v in pairs(drone.Modules) do
				self:AddLine(k)
			end
		end
	end

	terminal["dropmodules"] = function(self, args)
		local drone = findDrone(self, args)

		if drone:IsValid() and drone:CanBeControlledBy_skipai(self.User) then
			drone:RemoveAllModules()
			self:AddLine(drone:GetUnit() .. " has dropped modules.")
		end
	end

	terminal["dropweps"] = function(self, args)
		local drone = findDrone(self, args)

		if drone:IsValid() and drone:CanBeControlledBy_skipai(self.User) then
			drone:RemoveWeapons()
			self:AddLine(drone:GetUnit() .. " has dropped weapons.")
		end
	end

	terminal["help"] = function(self, args)
		local i = 1
		for k, v in pairs(DRONES_REWRITE.GetCommands()) do
			self:AddLine(i .. ". " .. k)
			i = i + 1
		end
	end

	return terminal
end
--PATH addons/_drones/lua/dronesrewrite/client/controls.lua:
local keys = { }
for i = 0, 113 do
	keys[i] = false
end

hook.Add("Think", "dronesrewrite_cl_keys", function()
	for i = 0, 113 do
		local oldpressed = keys[i]
		keys[i] = i >= 107 and input.IsMouseDown(i) or input.IsKeyDown(i)

		if oldpressed != keys[i] then
			hook.Run("DronesRewriteKey", i, keys[i])
		end
	end
end)

hook.Add("DronesRewriteKey", "dronesrewrite_controlkeys", function(key, pressed)
	local send = pressed
	if vgui.CursorVisible() and pressed then send = false end

	local ply = LocalPlayer()
	local drone = ply:GetNWEntity("DronesRewriteDrone")

	if drone:IsValid() then
		net.Start("dronesrewrite_keyvalue")
			net.WriteUInt(key, 7)
			net.WriteBit(send)
		net.SendToServer()
	end
end)

local function setup(p)
	local d = vgui.Create("DListView")
	d:SetSize(150, 400)
	d:AddColumn("Bind")
	d:AddColumn("Key")

	for k, v in pairs(DRONES_REWRITE.SortedKeys) do
		d:AddLine(v, string.upper(input.GetKeyName(DRONES_REWRITE.ClientCVars.Keys[v]:GetString())))
	end

	d.OnClickLine = function(parent, line, isselected)
		local bind = line:GetValue(1)

		timer.Create("dronesrewritekey", 0.1, 1, function()
			line:SetValue(2, "PRESS ANY BUTTON")

			hook.Add("DronesRewriteKey", "dronesrewrite_controlkeysset", function(key, pressed)
				RunConsoleCommand("dronesrewrite_key_" .. bind, key)

				line:SetValue(2, string.upper(input.GetKeyName(key)))

				hook.Remove("DronesRewriteKey", "dronesrewrite_controlkeysset")
			end)
		end)
	end

	p:AddItem(d)

	local btn = DRONES_REWRITE.CreateButton("Set to default", 0, 0, 150, 30, p, function()
		d:Clear()

		for bind, key in pairs(DRONES_REWRITE.Keys) do
			RunConsoleCommand("dronesrewrite_key_" .. bind, key)
			d:AddLine(bind, string.upper(input.GetKeyName(key)))
		end
	end)

	p:AddItem(btn)
end

hook.Add("PopulateToolMenu", "dronesrewrite_addmenukeys", function() spawnmenu.AddToolMenuOption("Options", "Drones Settings", "dronesrewrite_keys", "Controls / Keys", "", "", setup) end)
--PATH addons/_drones/lua/dronesrewrite/client/vgui.lua:
DRONES_REWRITE.Colors = { }

DRONES_REWRITE.Colors.Grey = Color(70, 70, 70, 255)
DRONES_REWRITE.Colors.DarkGrey = Color(32, 32, 32, 255)
DRONES_REWRITE.Colors.DarkGrey2 = Color(50, 50, 50, 255)
DRONES_REWRITE.Colors.DarkGrey3 = Color(80, 80, 80, 255)
DRONES_REWRITE.Colors.LightGrey = Color(200, 200, 200, 255)

DRONES_REWRITE.Colors.LightRed = Color(255, 180, 180)
DRONES_REWRITE.Colors.DarkRed = Color(150, 50, 50)

DRONES_REWRITE.Colors.DarkBlue = Color(30, 110, 110)
DRONES_REWRITE.Colors.LightBlue = Color(30, 130, 205)

DRONES_REWRITE.Colors.Green = Color(30, 200, 30)
DRONES_REWRITE.Colors.Red = Color(200, 30, 30)

DRONES_REWRITE.Colors.Border = Color(20, 20, 20, 255)

DRONES_REWRITE.CreateLabel = function(text, x, y, parent)
	local lab = vgui.Create("DLabel", parent)
	lab:SetPos(x, y)
	lab:SetText(text)
	lab:SetFont("DronesRewrite_customfont1")
	lab:SizeToContents()

	return lab
end

DRONES_REWRITE.CreateWindow = function(w, h)
	local win = vgui.Create("DFrame")
	win:SetSize(w, h)
	win:Center()
	win:SetTitle("")
	win:ShowCloseButton(false)
	win:MakePopup()

	function win:Paint()
		local w, h = self:GetWide(), self:GetTall()
		draw.RoundedBox(0, 0, 0, w, h, DRONES_REWRITE.Colors.Grey)
		draw.RoundedBox(0, 0, 0, w, 25, DRONES_REWRITE.Colors.DarkGrey2)
	end
	
	function win:OnCloseButton()
	end

	function win:SetupCloseButton()
		if IsValid(self.CloseBtn) then self.CloseBtn:Remove() end
		local w, h = self:GetWide(), self:GetTall()

		local close = vgui.Create("DButton", self)
		close:SetPos(w - 25, 0)
		close:SetSize(25, 25)
		close:SetText("")
		close.DoClick = function()
			if self:OnCloseButton() then return end
			self:Close()
		end
		close.Paint = function(close, w, h)
			surface.SetMaterial(Material("stuff/cross"))
			surface.SetDrawColor(Color(255, 255, 255))
			surface.DrawTexturedRect(6, 6, w - 12, h - 12)
		end

		self.CloseBtn = close
	end

	win:SetupCloseButton()

	return win
end

DRONES_REWRITE.CreateScrollPanel = function(x, y, w, h, win)
	local panel = vgui.Create("DScrollPanel", win)
	panel:SetPos(x, y)
	panel:SetSize(w, h)

	panel:GetVBar():SetWide(10)

	panel:GetVBar().btnUp.Paint = function(self)
		local w, h = self:GetWide(), self:GetTall()

		surface.SetMaterial(Material("stuff/arrow"))
		surface.SetDrawColor(Color(255, 255, 255))
		surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, w, h, 90)
	end

	panel:GetVBar().btnDown.Paint = function(self)
		local w, h = self:GetWide(), self:GetTall()

		surface.SetMaterial(Material("stuff/arrow"))
		surface.SetDrawColor(Color(255, 255, 255))
		surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, w, h, -90)
	end

	panel:GetVBar().Paint = function()
	end

	panel:GetVBar().btnGrip.Paint = function(self)
		local w, h = self:GetWide(), self:GetTall()

		local col = DRONES_REWRITE.Colors.LightGrey
		draw.RoundedBox(0, 0, 0, w, h, Color(col.r, col.g, col.b, 100))
	end

	local old = panel.PerformLayout
	function panel:PerformLayout()
		old(self)
		self.pnlCanvas:SetWide(self:GetWide())
	end

	return panel
end

DRONES_REWRITE.CreateButton = function(text, x, y, w, h, win, doclick)
	local btn = vgui.Create("DButton", win)
	btn:SetText(text)
	btn:SetPos(x, y)
	btn:SetSize(w, h)
	btn:SetFont("DronesRewrite_customfont1")
	btn:SetColor(Color(255, 255, 255)) -- Color for label

	btn.EntColor = DRONES_REWRITE.Colors.LightBlue
	btn.StaticColor = DRONES_REWRITE.Colors.DarkGrey

	function btn:Paint()
		local w, h = self:GetWide(), self:GetTall()

		local color = self.entered and self.EntColor or self.StaticColor
		draw.RoundedBox(0, 0, 0, w, h, color)
	end

	function btn:SetEnterColor(color) self.EntColor = color end
	function btn:SetStaticColor(color) self.StaticColor = color end
	
	function btn:OnCursorEntered() self.entered = true end
	function btn:OnCursorExited() self.entered = false end

	btn.DoClick = doclick

	return btn
end
--PATH addons/_drones/lua/dronesrewrite/weapons/blaster3.lua:
DRONES_REWRITE.Weapons["Green Blaster"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, "models/dronesrewrite/blaster/blaster.mdl", pos, ang, "models/dronesrewrite/attachment4/attachment4.mdl", pos)

		ent.PrimaryAmmo = 800
		ent.PrimaryAmmoMax = 800
		ent.PrimaryAmmoType = { DRONES_REWRITE.AmmoTypes.Plasma }

		ent.WaitTime = 0

		return ent
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)

		if gun.PlaySound and CurTime() > gun.NextShoot2 then
			gun:EmitSound("vehicles/tank_readyfire1.wav", 78, 255, 1, CHAN_WEAPON)
			gun.PlaySound = false
		end
	end,

	Attack = function(self, gun)
		if not self:IsKeyDown("Fire2") and  CurTime() > gun.NextShoot and gun:HasPrimaryAmmo() then
			local src = gun:GetPos() + gun:GetForward() * 64 + gun:GetUp()

			local ammo = ents.Create("dronesrewrite_gr_laser")
			ammo:SetPos(src)
			ammo:SetAngles(gun:GetAngles() + AngleRand() * 0.004)
			ammo:Spawn()
			ammo.Owner = self:GetDriver()
			
			constraint.NoCollide(ammo, self, 0, 0)

			ammo:EmitSound("drones/alien_fire.wav", 85, 100, 1, CHAN_WEAPON)

			local ef = EffectData()
			ef:SetOrigin(src - gun:GetForward() * 20)
			ef:SetNormal(gun:GetForward())
			util.Effect("dronesrewrite_muzzleflashblaster3", ef)
	
			gun:SetPrimaryAmmo(-1)
			gun.NextShoot = CurTime() + 0.1
		end
	end,

	Attack2 = function(self, gun)
		if not self:IsKeyDown("Fire1") and CurTime() > gun.NextShoot2 and gun:HasPrimaryAmmo() then
			local src = gun:GetPos() + gun:GetForward() * 64 - gun:GetUp() * 2.5

			local ammo = ents.Create("dronesrewrite_gr_laser_sm")
			ammo:SetPos(src)
			ammo:SetAngles(gun:GetAngles() + AngleRand() * 0.02)
			ammo:Spawn()
			ammo.Owner = self:GetDriver()
			
			constraint.NoCollide(ammo, self, 0, 0)

			ammo:EmitSound("drones/alien_fire.wav", 85, math.random(90, 120), 1, CHAN_WEAPON)

			local ef = EffectData()
			ef:SetOrigin(src - gun:GetForward() * 21)
			ef:SetNormal(gun:GetForward())
			util.Effect("dronesrewrite_muzzleflashblaster3", ef)	

			gun:SetPrimaryAmmo(-1)
			gun.NextShoot2 = CurTime() + 0.02

			gun.WaitTime = math.Approach(gun.WaitTime, 1, 0.01)
			if gun.WaitTime >= 1 then 
				gun.PlaySound = true
				gun.NextShoot2 = CurTime() + 3.6
				gun.WaitTime = 0
			end
		end
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/melongun.lua:
DRONES_REWRITE.Weapons["Melon Thrower"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].InitializeNoHandler(self, "models/weapons/w_rocket_launcher.mdl", pos, ang)

		ent.PrimaryAmmo = 100500
		ent.PrimaryAmmoMax = 100500
		ent.PrimaryAmmoType = {  }

		ent.WaitTime = 0

		return ent
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)
	end,

	Attack = function(self, gun)
		if CurTime() > gun.NextShoot and gun:HasPrimaryAmmo() then
			local ent = ents.Create("prop_physics")
			ent:SetModel("models/props_junk/watermelon01.mdl")
			ent:SetPos(gun:GetPos() + gun:GetForward() * 50)
			ent:Spawn()
			ent:EmitSound("weapons/ar2/ar2_altfire.wav")

			local phys = ent:GetPhysicsObject()
			if phys:IsValid() then phys:EnableGravity(false) phys:SetMass(50000) phys:SetVelocity(gun:GetForward() * 99999999) end
	
			gun.NextShoot = CurTime() + 0.1
		end
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/microwaves.lua:
DRONES_REWRITE.Weapons["Microwave"] = {
	Initialize = function(self)
		return DRONES_REWRITE.Weapons["Template"].InitializeNoDraw(self)
	end,

	Attack = function(self, gun)
		if CurTime() > gun.NextShoot then
			self:GetPhysicsObject():AddAngleVelocity(VectorRand() * 180)

			for k, v in ipairs(ents.FindInSphere(self:GetPos(), 250)) do
				if v == self then continue end

				if v.IS_DRONE then
					v:SetEnabled(false)

					local phys = v:GetPhysicsObject()

					phys:SetVelocity((v:GetPos() - self:GetPos()):GetNormal() * 450)
					phys:AddAngleVelocity(VectorRand() * 1200)
					
					v:TakeDamage(math.random(45,60), self:GetDriver(), self)

					timer.Simple(10, function()
						if v:IsValid() then 
							v:SetEnabled(true)
						end
					end)
				end

				ParticleEffect("vapor_collapse_drr", v:GetPos(), Angle(0, 0, 0))
				v:TakeDamage(math.random(10,15), self:GetDriver(), self)
			end

			ParticleEffect("vapor_collapse_drr", self:GetPos(), Angle(0, 0, 0))
			self:EmitSound("drones/nio_dissolve.wav", 100, 90)

			gun.NextShoot = CurTime() + 16
		end
	end
}
--PATH addons/_fpr/lua/fprofiler/cami.lua:
--[[
CAMI - Common Admin Mod Interface.
Makes admin mods intercompatible and provides an abstract privilege interface
for third party addons.

IMPORTANT: This is a draft script. It is very much WIP.

Follows the specification on this page:
https://docs.google.com/document/d/1QIRVcAgZfAYf1aBl_dNV_ewR6P25wze2KmUVzlbFgMI


Structures:
    CAMI_USERGROUP, defines the charactaristics of a usergroup:
    {
        Name
            string
            The name of the usergroup
        Inherits
            string
            The name of the usergroup this usergroup inherits from
    }

    CAMI_PRIVILEGE, defines the charactaristics of a privilege:
    {
        Name
            string
            The name of the privilege
        MinAccess
            string
            One of the following three: user/admin/superadmin
        HasAccess
            function(
                privilege :: CAMI_PRIVILEGE,
                actor     :: Player,
                target    :: Player
            ) :: bool
            optional
            Function that decides whether a player can execute this privilege,
            optionally on another player (target).
    }
]]

-- Version number in YearMonthDay format.
local version = 20150902.1

if CAMI and CAMI.Version >= version then return end

CAMI = CAMI or {}
CAMI.Version = version

--[[
usergroups
    Contains the registered CAMI_USERGROUP usergroup structures.
    Indexed by usergroup name.
]]
local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
    user = {
        Name = "user",
        Inherits = "user"
    },
    admin = {
        Name = "admin",
        Inherits = "user"
    },
    superadmin = {
        Name = "superadmin",
        Inherits = "admin"
    }
}

--[[
privileges
    Contains the registered CAMI_PRIVILEGE privilege structures.
    Indexed by privilege name.
]]
local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}

--[[
CAMI.RegisterUsergroup
    Registers a usergroup with CAMI.

    Parameters:
        usergroup
            CAMI_USERGROUP
            (see CAMI_USERGROUP structure)
        source
            any
            Identifier for your own admin mod. Can be anything.
            Use this to make sure CAMI.RegisterUsergroup function and the
            CAMI.OnUsergroupRegistered hook don't cause an infinite loop



    Return value:
        CAMI_USERGROUP
            The usergroup given as argument.
]]
function CAMI.RegisterUsergroup(usergroup, source)
    usergroups[usergroup.Name] = usergroup

    hook.Call("CAMI.OnUsergroupRegistered", nil, usergroup, source)
    return usergroup
end

--[[
CAMI.UnregisterUsergroup
    Unregisters a usergroup from CAMI. This will call a hook that will notify
    all other admin mods of the removal.

    Call only when the usergroup is to be permanently removed.

    Parameters:
        usergroupName
            string
            The name of the usergroup.
        source
            any
            Identifier for your own admin mod. Can be anything.
            Use this to make sure CAMI.UnregisterUsergroup function and the
            CAMI.OnUsergroupUnregistered hook don't cause an infinite loop

    Return value:
        bool
            Whether the unregistering succeeded.
]]
function CAMI.UnregisterUsergroup(usergroupName, source)
    if not usergroups[usergroupName] then return false end

    local usergroup = usergroups[usergroupName]
    usergroups[usergroupName] = nil

    hook.Call("CAMI.OnUsergroupUnregistered", nil, usergroup, source)

    return true
end

--[[
CAMI.GetUsergroups
    Retrieves all registered usergroups.

    Return value:
        Table of CAMI_USERGROUP, indexed by their names.
]]
function CAMI.GetUsergroups()
    return usergroups
end

--[[
CAMI.GetUsergroup
    Receives information about a usergroup.

    Return value:
        CAMI_USERGROUP
            Returns nil when the usergroup does not exist.
]]
function CAMI.GetUsergroup(usergroupName)
    return usergroups[usergroupName]
end

--[[
CAMI.UsergroupInherits
    Returns true when usergroupName1 inherits usergroupName2.
    Note that usergroupName1 does not need to be a direct child.
    Every usergroup trivially inherits itself.

    Parameters:
        usergroupName1
            string
            The name of the usergroup that is queried.
        usergroupName2
            string
            The name of the usergroup of which is queried whether usergroupName1
            inherits from.

    Return value:
        bool
            Whether usergroupName1 inherits usergroupName2.
]]
function CAMI.UsergroupInherits(usergroupName1, usergroupName2)
    repeat
        if usergroupName1 == usergroupName2 then return true end

        usergroupName1 = usergroups[usergroupName1] and
                         usergroups[usergroupName1].Inherits or
                         usergroupName1
    until not usergroups[usergroupName1] or
          usergroups[usergroupName1].Inherits == usergroupName1

    -- One can only be sure the usergroup inherits from user if the
    -- usergroup isn't registered.
    return usergroupName1 == usergroupName2 or usergroupName2 == "user"
end

--[[
CAMI.InheritanceRoot
    All usergroups must eventually inherit either user, admin or superadmin.
    Regardless of what inheritance mechism an admin may or may not have, this
    always applies.

    This method always returns either user, admin or superadmin, based on what
    usergroups eventually inherit.

    Parameters:
        usergroupName
            string
            The name of the usergroup of which the root of inheritance is
            requested

    Return value:
        string
            The name of the root usergroup (either user, admin or superadmin)
]]
function CAMI.InheritanceRoot(usergroupName)
    if not usergroups[usergroupName] then return end

    local inherits = usergroups[usergroupName].Inherits
    while inherits ~= usergroups[usergroupName].Inherits do
        usergroupName = usergroups[usergroupName].Inherits
    end

    return usergroupName
end

--[[
CAMI.RegisterPrivilege
    Registers a privilege with CAMI.
    Note: do NOT register all your admin mod's privileges with this function!
    This function is for third party addons to register privileges
    with admin mods, not for admin mods sharing the privileges amongst one
    another.

    Parameters:
        privilege
            CAMI_PRIVILEGE
            See CAMI_PRIVILEGE structure.

    Return value:
        CAMI_PRIVILEGE
            The privilege given as argument.
]]
function CAMI.RegisterPrivilege(privilege)
    privileges[privilege.Name] = privilege

    hook.Call("CAMI.OnPrivilegeRegistered", nil, privilege)

    return privilege
end

--[[
CAMI.UnregisterPrivilege
    Unregisters a privilege from CAMI. This will call a hook that will notify
    all other admin mods of the removal.

    Call only when the privilege is to be permanently removed.

    Parameters:
        privilegeName
            string
            The name of the privilege.

    Return value:
        bool
            Whether the unregistering succeeded.
]]
function CAMI.UnregisterPrivilege(privilegeName)
    if not privileges[privilegeName] then return false end

    local privilege = privileges[privilegeName]
    privileges[privilegeName] = nil

    hook.Call("CAMI.OnPrivilegeUnregistered", nil, privilege)

    return true
end

--[[
CAMI.GetPrivileges
    Retrieves all registered privileges.

    Return value:
        Table of CAMI_PRIVILEGE, indexed by their names.
]]
function CAMI.GetPrivileges()
    return privileges
end

--[[
CAMI.GetPrivilege
    Receives information about a privilege.

    Return value:
        CAMI_PRIVILEGE when the privilege exists.
            nil when the privilege does not exist.
]]
function CAMI.GetPrivilege(privilegeName)
    return privileges[privilegeName]
end

--[[
CAMI.PlayerHasAccess
    Queries whether a certain player has the right to perform a certain action.
    Note: this function does NOT return an immediate result!
    The result is in the callback!

    Parameters:
        actorPly
            Player
            The player of which is requested whether they have the privilege.
        privilegeName
            string
            The name of the privilege.
        callback
            function(bool, string)
            This function will be called with the answer. The bool signifies the
            yes or no answer as to whether the player is allowed. The string
            will optionally give a reason.
        targetPly
            Optional.
            The player on which the privilege is executed.
        extraInfoTbl
            Optional.
            Table containing extra information.
            Officially supported members:
                Fallback
                    string
                    Either of user/admin/superadmin. When no admin mod replies,
                    the decision is based on the admin status of the user.
                    Defaults to admin if not given.
                IgnoreImmunity
                    bool
                    Ignore any immunity mechanisms an admin mod might have.
                CommandArguments
                    table
                    Extra arguments that were given to the privilege command.

    Return value:
        None, the answer is given in the callback function in order to allow
        for the admin mod to perform e.g. a database lookup.
]]
-- Default access handler
local defaultAccessHandler = {["CAMI.PlayerHasAccess"] =
    function(_, actorPly, privilegeName, callback, _, extraInfoTbl)
        -- The server always has access in the fallback
        if not IsValid(actorPly) then return callback(true, "Fallback.") end

        local priv = privileges[privilegeName]

        local fallback = extraInfoTbl and (
            not extraInfoTbl.Fallback and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "user" and true or
            extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())


        if not priv then return callback(fallback, "Fallback.") end

        callback(
            priv.MinAccess == "user" or
            priv.MinAccess == "admin" and actorPly:IsAdmin() or
            priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()
            , "Fallback.")
    end,
    ["CAMI.SteamIDHasAccess"] =
    function(_, _, _, callback)
        callback(false, "No information available.")
    end
}
function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly,
extraInfoTbl)
    hook.Call("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly,
        privilegeName, callback, targetPly, extraInfoTbl)
end

--[[
CAMI.GetPlayersWithAccess
    Finds the list of currently joined players who have the right to perform a
    certain action.
    NOTE: this function will NOT return an immediate result!
    The result is in the callback!

    Parameters:
        privilegeName
            string
            The name of the privilege.
        callback
            function(players)
            This function will be called with the list of players with access.
        targetPly
            Optional.
            The player on which the privilege is executed.
        extraInfoTbl
            Optional.
            Table containing extra information.
            Officially supported members:
                Fallback
                    string
                    Either of user/admin/superadmin. When no admin mod replies,
                    the decision is based on the admin status of the user.
                    Defaults to admin if not given.
                IgnoreImmunity
                    bool
                    Ignore any immunity mechanisms an admin mod might have.
                CommandArguments
                    table
                    Extra arguments that were given to the privilege command.
]]
function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly,
extraInfoTbl)
    local allowedPlys = {}
    local allPlys = player.GetAll()
    local countdown = #allPlys

    local function onResult(ply, hasAccess, _)
        countdown = countdown - 1

        if hasAccess then table.insert(allowedPlys, ply) end
        if countdown == 0 then callback(allowedPlys) end
    end

    for _, ply in pairs(allPlys) do
        CAMI.PlayerHasAccess(ply, privilegeName,
            function(...) onResult(ply, ...) end,
            targetPly, extraInfoTbl)
    end
end

--[[
CAMI.SteamIDHasAccess
    Queries whether a player with a steam ID has the right to perform a certain
    action.
    Note: the player does not need to be in the server for this to
    work.

    Note: this function does NOT return an immediate result!
    The result is in the callback!

    Parameters:
        actorSteam
            Player
            The SteamID of the player of which is requested whether they have
            the privilege.
        privilegeName
            string
            The name of the privilege.
        callback
            function(bool, string)
            This function will be called with the answer. The bool signifies the
            yes or no answer as to whether the player is allowed. The string
            will optionally give a reason.
        targetSteam
            Optional.
            The SteamID of the player on which the privilege is executed.
        extraInfoTbl
            Optional.
            Table containing extra information.
            Officially supported members:
                IgnoreImmunity
                    bool
                    Ignore any immunity mechanisms an admin mod might have.
                CommandArguments
                    table
                    Extra arguments that were given to the privilege command.

    Return value:
        None, the answer is given in the callback function in order to allow
        for the admin mod to perform e.g. a database lookup.
]]
function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback,
targetSteam, extraInfoTbl)
    hook.Call("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam,
        privilegeName, callback, targetSteam, extraInfoTbl)
end

--[[
CAMI.SignalUserGroupChanged
    Signify that your admin mod has changed the usergroup of a player. This
    function communicates to other admin mods what it thinks the usergroup
    of a player should be.

    Listen to the hook to receive the usergroup changes of other admin mods.

    Parameters:
        ply
            Player
            The player for which the usergroup is changed
        old
            string
            The previous usergroup of the player.
        new
            string
            The new usergroup of the player.
        source
            any
            Identifier for your own admin mod. Can be anything.
]]
function CAMI.SignalUserGroupChanged(ply, old, new, source)
    hook.Call("CAMI.PlayerUsergroupChanged", nil, ply, old, new, source)
end

--[[
CAMI.SignalSteamIDUserGroupChanged
    Signify that your admin mod has changed the usergroup of a disconnected
    player. This communicates to other admin mods what it thinks the usergroup
    of a player should be.

    Listen to the hook to receive the usergroup changes of other admin mods.

    Parameters:
        ply
            string
            The steam ID of the player for which the usergroup is changed
        old
            string
            The previous usergroup of the player.
        new
            string
            The new usergroup of the player.
        source
            any
            Identifier for your own admin mod. Can be anything.
]]
function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
    hook.Call("CAMI.SteamIDUsergroupChanged", nil, steamId, old, new, source)
end

--PATH addons/__main/lua/autorun/groove_gangs.lua:
local function AddPlayerModel( name, model )
	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )
	player_manager.AddValidHands( "gang_1", "models/weapons/c_arms_citizen.mdl", 1, "00000000" )
	player_manager.AddValidHands( "gang_2", "models/weapons/c_arms_citizen.mdl", 1, "00000000" )
	player_manager.AddValidHands( "gang_groove_chem", "models/weapons/c_arms_citizen.mdl", 1, "00000000" )
	player_manager.AddValidHands( "gang_groove_boss", "models/weapons/c_arms_citizen.mdl", 1, "00000000" )
end

AddPlayerModel( "gang_1", "models/gang_groove/gang_1.mdl" )
AddPlayerModel( "gang_2", "models/gang_groove/gang_2.mdl" )
AddPlayerModel( "gang_groove_chem", "models/gang_chem/gang_groove_chem.mdl" )
AddPlayerModel( "gang_groove_boss", "models/gang_groove_boss/gang_groove_boss.mdl" )
--PATH addons/igs-core/lua/igs/dependencies/permasents.lua:
--[[-------------------------------------------------------------------------
	Для веб загрузки не подходит PermaProps аддон с воркшопа,
	поскольку он работает на InitPostEntity, который нельзя вызвать после веб загрузки

	Или можно..
---------------------------------------------------------------------------]]

local function getIndex()
	return util.JSONToTable(cookie.GetString("perma_index", "")) or {}
end

local function updateIndex(uid, class)
	local map = getIndex()
	map[uid] = class
	cookie.Set("perma_index", util.TableToJSON(map))
end

local function SpawnSent(class, pos, ang)
	local ent = ents.Create(class)
	ent:SetPos(pos)
	ent:SetAngles(ang)
	ent:Spawn()
	ent:Activate()

	local phys = ent:GetPhysicsObject()
	if phys:IsValid() then
		phys:EnableMotion(false)
	end

	return ent
end


function IGS.PermaSaveFeature(class)
	properties.Add(class .. "_perma_add", {
		MenuLabel = "Зберегти на карті",
		Order = 855,
		MenuIcon = "icon16/bullet_disk.png",

		Filter = function(self, ent, pl)
			return IsValid(ent) and pl:IsSuperAdmin() and ent:GetClass() == class
		end,
		Action = function(self, ent)
			self:MsgStart()
				net.WriteEntity( ent )
			self:MsgEnd()
		end,
		Receive = function(self, length, pl)
			local ent = net.ReadEntity()
			if not self:Filter(ent, pl) then return end

			if ent.permaSentUID then
				pl:ChatPrint("Ця ентіті вже збережена. Видаліть та збережіть знову, якщо хочете перемістити")
				return
			end

			local uid = math.random(0xFFFF)
			cookie.Set("perma_" .. class .. "_" .. uid, util.TableToJSON({ent:GetPos(), ent:GetAngles()}))
			pl:ChatPrint("Позиція збережена під UID " .. uid)
			ent.permaSentUID = uid

			updateIndex(uid, class)
		end
	})

	properties.Add(class .. "_perma_delete", {
		MenuLabel = "Видалити з карти",
		Order = 856,
		MenuIcon = "icon16/bin_closed.png",

		Filter = function(self, ent, pl)
			return IsValid(ent) and pl:IsSuperAdmin() and ent:GetClass() == class
		end,
		Action = function(self, ent)
			self:MsgStart()
				net.WriteEntity( ent )
			self:MsgEnd()
		end,
		Receive = function(self, length, pl)
			local ent = net.ReadEntity()
			if not self:Filter(ent, pl) then return end

			if not ent.permaSentUID then
				pl:ChatPrint("Ця ентіті не перманентна")
				return
			end

			local uid  = ent.permaSentUID
			cookie.Set("perma_" .. class .. "_" .. uid, nil)
			pl:ChatPrint("Об'єкт видалено. UID був " .. uid)
			ent:Remove()

			updateIndex(uid, nil)
		end
	})
end

if SERVER then
	hook.Add("IGS.Loaded", "IGS.PermaSents", function()
	timer.Simple(30, function()
		for _, ent in ipairs(ents.GetAll()) do
			if ent.permaSentUID then
				ent:Remove()
			end
		end

		local map = getIndex()
		for uid,class in pairs(map) do
			if scripted_ents.GetStored(class) then
				local dat = util.JSONToTable(cookie.GetString("perma_" .. class .. "_" .. uid))
				local ent = SpawnSent(class, util.StringToType(dat[1], "Vector"), util.StringToType(dat[2], "Angle"))
				ent.permaSentUID = uid

				print("IGS.PermaSents: Заспавнили " .. class)
			else
				print("IGS.PermaSents: " .. class .. " не існує на сервері")
			end
		end
	end)
	end)
end

--PATH addons/igs-core/lua/igs/objects/shop_item.lua:
setmetatable(IGS,{
	__call = function(self,...)
		return self.AddItem(...)
	end
})


--[[-------------------------------------------------------------------------
	МАКСИМАЛЬНОЕ КОЛ-ВО УЛУЧШЕНИЙ 255
---------------------------------------------------------------------------]]

local STORE_ITEM = FindMetaTable("IGSItem") or {}
STORE_ITEM.__index = STORE_ITEM
debug.getregistry().IGSItem = STORE_ITEM

local function set(self,var,val)
	self[var] = val
	return self
end


--[[-------------------------------------------------------------------------
	GET values (для тех значений, что нельзя Set)
---------------------------------------------------------------------------]]
function STORE_ITEM:Name()
	return self.name
end

function STORE_ITEM:UID()
	return self.uid
end

function STORE_ITEM:ID()
	return self.id
end

-- VIP, Huntsman Knifes. Присваивается через GROUP:AddItem
function STORE_ITEM:Group()
	return self.group
end

--[[-------------------------------------------------------------------------
	SET/GET values
---------------------------------------------------------------------------]]
-- Double цена товара в реальной валюте (не автодоната)
function STORE_ITEM:SetPrice(iPrice)
	return set(self,"price",iPrice)
end

function STORE_ITEM:Price()
	return self.price
end

-- Сбрасывает текущее описание и устанавливает указанное, если не указать bAppand
function STORE_ITEM:SetDescription(sDesc,bAppend)
	return set(self,"description",bAppend and (self:Description() .. sDesc) or sDesc)
end

function STORE_ITEM:Description()
	return self.description
end

-- Ссылка на картинку иконки товара 1:1. Желательно минимум 100 px
-- Или же путь к модельке, но тогда вторым аргументом указать true
function STORE_ITEM:SetIcon(sIcon, bIsModel)
	return CLIENT and set(self,"icon",{
		icon    = sIcon,
		isModel = bIsModel,
	}) or self
end

function STORE_ITEM:ICON()
	if self.icon then
		return self.icon["icon"], self.icon["isModel"]
	end
end

-- Цвет подсветки заголовка итема в списке
function STORE_ITEM:SetHighlightColor(color)
	return CLIENT and set(self,"highlight",color) or self
end

function STORE_ITEM:GetHighlightColor()
	return self.highlight
end

-- Пермапушки, права, группы, уровни
function STORE_ITEM:SetCategory(sCat)
	return set(self,"category",sCat)
end

function STORE_ITEM:Category()
	return self.category
end

-- Срок в днях, на который выдается услуга. 0 если одноразовая. nil, если вечная
function STORE_ITEM:SetTerm(iDays)
	return set(self,"termin",iDays)
end

function STORE_ITEM:SetPerma()
	return self:SetTerm(nil)
end

function STORE_ITEM:Term()
	return self.termin
end

-- Дает возможность мультипокупки. Полезно для лимита пропов, патронов при спавне и т.д.
function STORE_ITEM:SetStackable(b)
	return set(self,"stackable",b ~= false) -- nil = true; 1 = true; true = true; false = false
end

function STORE_ITEM:IsStackable()
	return self.stackable
end

-- Нужна ли информация о покупке на клиентсайде? (Будет в IGS.PlayerPurchases(ply))
function STORE_ITEM:SetNetworked(b)
	return set(self,"networked",b ~= false)
end

-- Баннер товара. Будет отображен под информацией о товаре. Рекомендуемый размер 1000х400
function STORE_ITEM:SetImage(sUrl)
	return set(self,"image_url",sUrl)
end

function STORE_ITEM:IMG()
	return self.image_url
end

-- Нельзя купить, но можно активировать с инвентаря.
-- Полезно, чтобы "удалять" ненужные, но еще активные у людей итемы
function STORE_ITEM:SetHidden(b)
	return set(self,"hidden",b ~= false)
end

function STORE_ITEM:IsHidden()
	return self.hidden
end

-- Для удобной установки метаданных итему вместо ITEM.key = val (полезно внутри функций, типа GROUP:Add(ITEM))
function STORE_ITEM:SetMeta(key, value)
	if (not self.meta) then self.meta = {} end
	self.meta[key] = value
	return self
end

function STORE_ITEM:GetMeta(key)
	return self.meta and self.meta[key]
end

function STORE_ITEM:SetDiscountedFrom(i) -- internal
	return set(self,"discounted_from", i)
end

-- function STORE_ITEM:DiscountedFrom()
-- 	return self.discounted_from
-- end



--[[-------------------------------------------------------------------------
	Функции
---------------------------------------------------------------------------]]
-- функции передается игрок
-- Должна вернуть ОШИБКУ (строку) или nil/false, если все ок
function STORE_ITEM:SetCanBuy(fCallback)
	return SERVER and set(self,"canbuy",fCallback) or self
end

-- После удачной покупки передает в каллбэк игрока
function STORE_ITEM:SetOnBuy(fCallback)
	return SERVER and set(self,"onbuy",fCallback) or self
end

-- "Установщик" услуги. Внутренняя функция, чтобы не оверрайдить :SetOnActivate
-- Осторожнее в комбинации с :SetValidator
function STORE_ITEM:SetInstaller(fCallback)
	return SERVER and set(self,"installer",fCallback) or self
end

-- Как и SetCanBuy, но для активации с инвентаря
function STORE_ITEM:SetCanActivate(fCallback)
	return SERVER and set(self,"canactivate",fCallback) or self
end

-- Для выдачи бонусов etc. Игрок в каллбэке
-- Выполнять только при реальной активации игроком или выдаче через панель,
-- а не автовосстановлении etc
function STORE_ITEM:SetOnActivate(fCallback)
	return SERVER and set(self,"onactivate",fCallback) or self
end

-- Если fChecker вернет false, то выполнится installer
function STORE_ITEM:SetValidator(fChecker)
	return SERVER and set(self,"validator",fChecker) or self
end

if SERVER then
	function STORE_ITEM:Setup(pl) -- внутренняя
		if self.installer then
			self.installer(pl)
		end
	end

	function STORE_ITEM:OnActivate(pl) -- публичная
		self:Setup(pl)

		if self.onactivate then
			self.onactivate(pl)
		end
	end

	-- Активация
	-- Возвращает boolErr и errMsg
	function STORE_ITEM:CanActivate(pl, iInvId)
		if (not self:IsStackable() and pl:HasPurchase( self:UID() )) then
			return false,"Послуга вже активна"
		end

		local canActivate,err = hook.Run("IGS.CanPlayerActivateItem", pl, self, iInvId)
		if canActivate ~= nil then
			return canActivate,err
		end

		if self.canactivate then
			local er = self.canactivate(pl, iInvId)
			if er then
				return false,er
			end
		end

		return true
	end

	-- Покупка
	function STORE_ITEM:CanBuy(pl)
		local canBuy,err = hook.Run("IGS.CanPlayerBuyItem", pl, self)
		if canBuy ~= nil then
			return canBuy,err
		end

		if self.canbuy then
			local er = self.canbuy(pl)
			if er then -- Обратная совместимость с SetCanBuy
				return false,er
			end
		end

		return true
	end
	function STORE_ITEM:Buy(pl)
		if self.onbuy then
			self.onbuy(pl)
		end
	end

	-- Разные функции
	function STORE_ITEM:IsValid(pl)
		if self.validator then
			return self.validator(pl)
		end
	end
end


--[[-------------------------------------------------------------------------
	MISC
---------------------------------------------------------------------------]]
-- Вставка этого итема в таблицу под указанным ключом
-- Используется при создании модулей для упрощения кода
-- До:    https://img.qweqwe.ovh/1494247121142.png
-- После: https://img.qweqwe.ovh/1494247134028.png
function STORE_ITEM:Insert(to, key)
	to[key] = to[key] or {}
	if not table.HasValue(to[key],self) then
		table.insert(to[key], self)
	end
	return key
end

function STORE_ITEM:PriceInCurrency()
	return IGS.PriceInCurrency(self.price)
end


--[[-------------------------------------------------------------------------
	CORE
---------------------------------------------------------------------------]]
function IGS.Item(sName, sUID)
	return setmetatable({
		name = sName,
		uid  = sUID,
		-- id   = ,
		description = "",
		termin = 0 -- если не изменить, то услуга не добавится в покупки. Только в транзакции
	}, STORE_ITEM)
end



IGS.ITEMS = IGS.ITEMS or {
	STORED = {},
	MAP    = {},
}

function IGS.AddItem(sName, sUID, iPrice)
	sUID = sUID:lower()

	-- Поле БД 32. Но с "P: " UID надо сокращать
	-- P: entity_hpwand_spell_simple_wand
	if #sUID > 28 then
		IGS.print(Color(250,20,20),
			"UID " .. sUID .. " має довжину більше 28 символів, що не допускається\n" ..
			"Причиною також можуть стати кириличні (українські) або інші (emoji) символи.\n" ..
			"UniqueID предмета повинен складатися з маленьких англійских (латинських) букв без пробілів і бути менше ніж 28 символів"
		)
		-- return -- из-за этого в консоль вылезет ошибка, т.е. не вернется объект

		local old = sUID
		sUID = old:sub(1, 28)
		IGS.print(Color(250,20,20), "UID " .. old .. " скорочений до " .. sUID .. "\n")
	end

	-- Защита от сбивания айдишников из-за рефреша файла с добавлением итемов
	-- Чтобы счетчик не набивался
	local ITEM = IGS.ITEMS.MAP[sUID]
	if ITEM then
		ITEM:SetPrice(iPrice or ITEM:Price()) -- обновляем цену, вдруг изменилась
		ITEM.name = sName -- и имя

		return ITEM
	end

	local t = IGS.Item(sName, sUID)
	t.id = #IGS.ITEMS.STORED + 1

	if iPrice then
		t:SetPrice(iPrice)
	end

	IGS.ITEMS.MAP[t.uid]   = t
	IGS.ITEMS.STORED[t.id] = t -- just insert

	return t
end


local null = IGS.Item("null", "null"):SetPrice(0)
	:SetDescription("Цей предмет, більше всього, колись існував або існує на іншому сервері, но не тут")
	:SetIcon("http://i.imgur.com/NfpcFdy.png")
	:SetImage("http://i.imgur.com/32iTOFi.jpg")
	:SetCanBuy(function() return "Цього предмета на сервері немає. Як ви знайшли його?" end)
	:SetCanActivate(function() return "Цього предмета на сервері немає. Можете знищити його" end) -- например купил в инвентарь, а потом uid сменился

null.isnull = true -- для проверки во время активации
null.id = 0 -- на всякий

-- IGS.NULL = null -- альтернативный способ сравнения

function IGS.GetItem(id_or_uid) -- AKA ItemExists
	return IGS.ITEMS.STORED[id_or_uid] or IGS.ITEMS.MAP[id_or_uid]
end

function IGS.GetItemByUID(sUID)
	return IGS.ITEMS.MAP[sUID:lower()] or null
end

function IGS.GetItems()
	return IGS.ITEMS.STORED
end

--PATH addons/igs-modification/lua/igs/settings/sh_additems.lua:
local newprice = 1.5

IGS('Battle Pass Premium','bppremium')
:SetCategory('Battle Pass')
:SetDescription('')
:SetPrice(600 * newprice)
:SetCanActivate(function(pl)
	return pl.BattlePass.Owned.owned and 'У вас вже є бойова перепустка'
end)
:SetOnActivate(function(pl)
	BATTLEPASS:SetOwned(pl, true)
	net.Start("BATTLEPASS.GivePass")
	net.Send(pl)
end)

IGS('Battle Pass LVL','bplvl')
:SetCategory('Battle Pass')
:SetDescription('')
:SetStackable()
:SetPrice(40 * newprice)
:SetOnActivate(function(pl)
	local tiers = 1
	BATTLEPASS:AddTier(pl, tiers)

	tiers = pl.BattlePass.Owned.tier or 0
	net.Start("BATTLEPASS.SetTiers")
	net.WriteUInt(tiers, 16)
	net.Send(pl)
end)


IGS("CYBER Пушка", "cyberitem")
    :SetWeapon('microwave_gun')
    :SetIcon("models/weapons/w_pistol.mdl", true)
    :SetPrice(600)
    :SetDiscountedFrom(1200)
    :SetPerma()
    :SetDescription("Купи меня!")
    :SetCategory("Оружие")


IGS("Smart Pistol из Titanfall", "smartpistol")
    :SetPrice(600)
    :SetDiscountedFrom(1200)
    :SetWeapon("mp_weapon_smart_pistol")
    :SetIcon("models/weapons/p2011sp/w_p2011sp.mdl", true)
    :SetCategory("Оружие")
    :SetPerma()
    :SetDescription("Легендарный смарт пистолет из прекрасной игры под названием Titanfall \nПозволяет мгновенно нейтрализовать врагов.")


IGS("Mauser M1896 | Royal Dragon", "mauserdragon") -- второй параметр ДОЛЖЕН!!!!!!!! быть уникальным(Не повторяться с другими итемамы!) и на латиннице
    :SetPrice(40)
    :SetDiscountedFrom(80)
    :SetPerma()
    :SetWeapon("mauserdragon")
    :SetDescription("Купи меня!")
    :SetCategory("Оружие")
    :SetHighlightColor(Color(255,0,0)) -- руб
    :SetIcon("models/weapons/w_royl_p228.mdl", true)


IGS("Ковбойка 1337", "weapon_cowboy"):SetWeapon("weapon_long_revolver")
    :SetPrice(2000)
    :SetDiscountedFrom(3900)
    :SetPerma()
    :SetCategory("Оружие")
    :SetHighlightColor(Color(255,215,0))
    :SetDescription("Легендарное оружие! Выдача строго запрещена!")
    :SetIcon("models/weapons/w_357.mdl", true)


IGS("RPG", "ree_rpgsuka")
  :SetPrice(999)
  :SetDiscountedFrom(1500)
  :SetPerma()
    :SetHighlightColor(Color(255,0,0)) -- руб
  :SetWeapon("weapon_rpg")
  :SetCategory("Оружие")
  :SetDescription("Купи меня!")
  :SetIcon("models/weapons/w_rocket_launcher.mdl", true)


IGS("AK-47 | Золотая коллекция ", "weapon_shitty_gold_akkk") -- второй параметр ДОЛЖЕН!!!!!!!! быть уникальным(Не повторяться с другими итемамы!) и на латиннице
    :SetPrice(225)
    :SetDiscountedFrom(300)
    :SetPerma()
    :SetWeapon("weapon_shitty_gold_ak")
    :SetDescription("Купи меня!")
    :SetCategory("Оружие")
    :SetIcon("models/weapons/w_rif_ak47_gold.mdl", true)


IGS("C4", "weapon_c4") -- второй параметр ДОЛЖЕН!!!!!!!! быть уникальным(Не повторяться с другими итемамы!) и на латиннице
    :SetPrice(450)
    :SetDiscountedFrom(900)
    :SetPerma()
    :SetWeapon("weapon_c4")
    :SetDescription("Может разнести пропы врага!")
    :SetCategory("Оружие")
    :SetIcon("models/weapons/w_c4.mdl", true)


IGS("SG552", "wep_arbalet")
    :SetPrice(150)
    :SetDiscountedFrom(300)
    :SetPerma()
    :SetWeapon("swb_sg552")
    :SetCategory("Оружие")
    :SetDescription("Разрешает спавнить это оружие через спавн меню в любое время")
    :SetIcon("models/weapons/w_rif_sg552.mdl", true) -- true значит, что указана моделька, а не ссылка


IGS("Скорострельный Дробовик", "wep_drobovik")
    :SetPrice(250)
    :SetDiscountedFrom(500)
    :SetPerma()
    :SetWeapon("swb_xm1014")
    :SetCategory("Оружие")
    :SetDescription("Разрешает спавнить это оружие через спавн меню в любое время. Запрещено выдавать другим игрокам.")
    :SetIcon("models/weapons/w_shot_xm1014.mdl", true) -- true значит, что указана моделька, а не ссылка


IGS("Пистолет Deagle", "wep_deagle")
    :SetPrice(150)
    :SetDiscountedFrom(300)
    :SetPerma()
    :SetWeapon("swb_deagle")
    :SetCategory("Оружие")
    :SetDescription("Разрешает спавнить это оружие через спавн меню в любое время. Запрещено выдавать другим игрокам.")
    :SetIcon("models/weapons/w_pist_deagle.mdl", true) -- true значит, что указана моделька, а не ссылка

IGS("Пистолет Пулемет TMP", "wep_tmp")
    :SetPrice(200)
    :SetDiscountedFrom(400)
    :SetPerma()
    :SetWeapon("swb_tmp") -- fas2_sks
    :SetCategory("Оружие")
    :SetDescription("Разрешает спавнить это оружие через спавн меню в любое время. Запрещено выдавать другим игрокам.")
    :SetIcon("models/weapons/w_smg_tmp.mdl", true) -- true значит, что указана моделька, а не ссылка

IGS("Снайперская Винтовка Scout", "wep_scout")
    :SetPrice(200)
    :SetDiscountedFrom(400)
    :SetPerma()
    :SetWeapon("swb_scout")
    :SetCategory("Оружие")
    :SetDescription("Разрешает спавнить это оружие через спавн меню в любое время. Запрещено выдавать другим игрокам.")
    :SetIcon("models/weapons/w_snip_scout.mdl", true) -- true значит, что указана моделька, а не ссылка

IGS("Stunstick", "wep_stunstick")
    :SetPrice(40)
    :SetDiscountedFrom(80)
    :SetPerma()
    :SetWeapon("weapon_stunstick")
    :SetCategory("Оружие")
    :SetDescription("Разрешает спавнить это оружие через спавн меню в любое время. Запрещено выдавать другим игрокам.")
    :SetIcon("models/weapons/w_stunbaton.mdl", true) -- true значит, что указана моделька, а не ссылка
local IGS_CAT_Money    = "Набір бабла"
IGS.C.DefaultIcon = "https://i.ibb.co/fGLj7wJ/logo.png"
local ITEM = IGS('150.000 $',"money_" .. 165 .. "mi") -- money_10mi
	:SetPrice(30 * newprice)
	:SetStackable()
	:SetDescription("Миттєво та без проблем поповнює баланс игрової валюти на 150.000 тисяч $. Чим більше валюти ви купуєте - тим вигідніша ціна")
	:SetOnActivate(function(pl) pl:AddMoney((150 * 1000)) end)
	:SetCategory(IGS_CAT_Money)
	:SetIcon("https://i.ibb.co/fGLj7wJ/logo.png")

local ITEM = IGS('300.000 $',"money_" .. 310 .. "mi") -- money_10mi
	:SetPrice(45 * newprice)
	:SetStackable()
	:SetDescription("Миттєво та без проблем поповнює баланс игрової валюти на 300.000 тисяч $. Чим більше валюти ви купуєте - тим вигідніша ціна")
	:SetOnActivate(function(pl) pl:AddMoney((300 * 1000)) end)
	:SetCategory(IGS_CAT_Money)
	:SetIcon("https://i.ibb.co/fGLj7wJ/logo.png")

local ITEM = IGS('600.000 ',"money_" .. 605 .. "mi") -- money_10mi
	:SetPrice(60 * newprice)
	:SetStackable()
	:SetDescription("Миттєво та без проблем поповнює баланс игрової валюти на 600.000 тисяч $. Чим більше валюти ви купуєте - тим вигідніша ціна")
	:SetOnActivate(function(pl) pl:AddMoney((600 * 1000)) end)
	:SetCategory(IGS_CAT_Money)
	:SetIcon("https://i.ibb.co/fGLj7wJ/logo.png")

IGS("Сумка з патронами", "ammos")
    :SetPrice(100 * newprice)
    :SetDiscountedFrom(200)
    :SetPerma()
    :SetWeapon("ammogiver")
    :SetCategory("Оружие")
    :SetDescription("Разрешает спавнить это оружие через спавн меню в любое время. Запрещено выдавать другим игрокам.")
    :SetIcon("models/items/battery.mdl", true)
    

IGS("Серцеїд", "mac_lara")
 	:SetPrice(449 * newprice) 
 	:SetPerma()
 	:SetWeapon('mac_lara')
 	:SetDescription("Ексклюзивна зброя. Видається під час спавну за будь-яку професію на завжди.") 
 	:SetCategory('Хелуїнська зброя')
 	:SetHighlightColor(Color(212, 124, 0))
 	:SetIcon('models/weapons/w_smg_macla.mdl',true) 

IGS("Парасолька", "m3_umbrella")
 	:SetPrice(449 * newprice) 
 	:SetPerma()
 	:SetWeapon('m3_umbrella')
 	:SetDescription("Ексклюзивна зброя. Видається під час спавну за будь-яку професію на завжди.") 
 	:SetCategory('Хелуїнська зброя')
 	:SetHighlightColor(Color(212, 124, 0))
 	:SetIcon('models/weapons/w_shot_m3umbrela.mdl',true) 

IGS("Арбалет Вампіра", "scout_xbow")
 	:SetPrice(449 * newprice) 
 	:SetPerma()
 	:SetWeapon('scout_xbow')
 	:SetDescription("Ексклюзивна зброя. Видається під час спавну за будь-яку професію на завжди.") 
 	:SetCategory('Хелуїнська зброя')
 	:SetHighlightColor(Color(212, 124, 0))
 	:SetIcon('models/weapons/w_snip_xxbow.mdl',true) 


IGS("Червоний дракон", "tmp_dragon")
 	:SetPrice(449 * newprice) 
 	:SetPerma()
 	:SetWeapon('tmp_dragon')
 	:SetDescription("Ексклюзивна зброя. Видається під час спавну за будь-яку професію на завжди.") 
 	:SetCategory('Хелуїнська зброя')
 	:SetHighlightColor(Color(212, 124, 0))
 	:SetIcon('models/weapons/w_smg_tmd.mdl',true) 

IGS("L96 Dragon", "l96_dragon")
 	:SetPrice(1299 * newprice) 
 	:SetPerma()
 	:SetWeapon('l96_dragon')
 	:SetDescription("Ексклюзивна зброя. Видається під час спавну за будь-яку професію на завжди.") 
 	:SetCategory('Хелуїнська зброя')
 	:SetHighlightColor(Color(212, 124, 0))
 	:SetIcon('models/weapons/w_snip_awm.mdl',true) 



--[[-------------------------------------------------------------------------
ULTRA
---------------------------------------------------------------------------]]

IGS("MiniGun", "m9k_minigun") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(750 * newprice)
 	:SetDiscountedFrom(1200)
 	:SetPerma()
 	:SetWeapon('m9k_minigun')
 	:SetDescription("") -- описание
 	:SetCategory('Супер Зброя')
 	:SetIcon('models/weapons/w_m134_minigun.mdl',true) 

IGS("Double Barrel", "m9k_dbarrel") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(399)
 	:SetDiscountedFrom(300 * newprice)
 	:SetPerma()
 	:SetWeapon('m9k_dbarrel')
 	:SetDescription("") -- описание
 	:SetCategory('Супер Зброя')
 	:SetIcon('models/weapons/w_double_barrel_shotgun.mdl',true) 

IGS("Граната", "weapon_frag") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(359 * newprice)
 	:SetDiscountedFrom(900)
 	:SetPerma()
 	:SetWeapon('weapon_frag')
 	:SetDescription("") -- описание
 	:SetCategory('Супер Зброя')
 	:SetIcon('models/Items/grenadeAmmo.mdl',true) 

IGS("Міна", "weapon_slam") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(359 * newprice)
 	:SetDiscountedFrom(900)
 	:SetPerma()
 	:SetWeapon('weapon_slam')
 	:SetDescription("") -- описание
 	:SetCategory('Супер Зброя')
 	:SetIcon('models/weapons/w_slam.mdl',true) 

IGS("Набір вбивці", "3dgear") -- второй параметр не должен(!) повторяться с другими предметами
	:SetPrice(300 * newprice)
	:SetDiscountedFrom(900)
	:SetPerma()
	:SetWeapon('3dgear')
	:SetDescription("") -- описание
	:SetCategory('Супер Зброя')
	:SetIcon('models/aot/3dgear.mdl',true)

IGS("Аанг планер", "weapon_aang_glider") -- второй параметр не должен(!) повторяться с другими предметами
	:SetPrice(1000)
	:SetDiscountedFrom(2000)
	:SetPerma()
	:SetWeapon('weapon_aang_glider')
	:SetDescription("") -- описание
	:SetCategory('Супер Зброя')
	:SetIcon('models/avatar/Aang_Glider_Closed.mdl',true)

IGS("Deagle - Born Beast", "weapon_deagle_bornbeast") -- второй параметр не должен(!) повторяться с другими предметами
	:SetPrice(777)
	:SetDiscountedFrom(999)
	:SetPerma()
	:SetWeapon('weapon_deagle_bornbeast')
	:SetDescription("") -- описание
	:SetCategory('Супер Зброя')
	:SetIcon('models/cf/w_deagle_beast.mdl',true)

IGS("M4A1-S-Beast", "weapon_m4a1_beast") -- второй параметр не должен(!) повторяться с другими предметами
	:SetPrice(1299)
	:SetDiscountedFrom(1999)
	:SetPerma()
	:SetWeapon('weapon_m4a1_beast')
	:SetDescription("") -- описание
	:SetCategory('Супер Зброя')
	:SetIcon('models/cf/w_m4a1_beast.mdl',true)

/************************************************************
	Донат группы ULX
************************************************************/

IGS("VIP - 30 Днів", "vip3")
	:SetPrice(45 * newprice)
	:SetTerm(30)
	:SetStackable()
	:SetCategory("Привілегії")
	--:SetHighlightColor(Color(255,0,0))
	//(140)
	:SetDescription("З цею покупкою ви станете офігенними, тому що в ній оооось така купа крутих можливостей")
	:SetOnActivate(function(pl)
		sam.player.set_rank(pl, 'vip', 43200)
	end)

IGS("VIP", "vip")
	:SetPrice(90 * newprice)
	:SetStackable() -- 30 дней
	:SetCategory("Привілегії")
	//(400)
	--:SetHighlightColor(Color(255,0,0))
	:SetDescription("З цею покупкою ви станете офігенними, тому що в ній оооось така купа крутих можливостей")
	:SetOnActivate(function(pl)
		sam.player.set_rank(pl, 'vip', 0)
	end)	


IGS("Адміністратор - 30 Днів", "admin3")
	:SetPrice(275 * newprice)
	:SetStackable()
	--:SetHighlightColor(Color(255,0,0))
	:SetTerm(30)
	:SetCategory("Привілегії")
	//(900)
	:SetDescription([[

	Якщо ви Адміністратор то ви вже настільки крутий що крутіше тільки OWNER!

	Ви вмієте: 

	TP - переміщувати гравців
	Goto - переміститися до гравця
	Return - повернути гравця на минулу позицію

	UnArrest/Arrest - Ви можете посадити до в'язниці гравця
	UnCuff - Зняти наручники з любого гравця

	ScreenGrab - Ви можете робити скріншот екрана гравця
	WhoIs - Ви можете дізнатися де проживає гравець

	Slay - Ви можете вбивати гравця

	Demote - звільнити гравця з професії
	Ban - заблокувати гравця
	Cloak - стати невидимим

		]])
	:SetOnActivate(function(pl)
		sam.player.set_rank(pl, 'dadmin', 43200)
	end)

IGS("Адміністратор", "admin")
	:SetPrice(315 * newprice)
	:SetStackable()
	:SetPerma() -- 30 дней
	:SetCategory("Привілегії")
	--:SetHighlightColor(Color(255,0,0))
	//(1490)
	:SetDescription([[

	Якщо ви Адміністратор то ви вже настільки крутий що крутіше тільки OWNER!

	Ви вмієте: 

	TP - переміщувати гравців
	Goto - переміститися до гравця
	Return - повернути гравця на минулу позицію

	UnArrest/Arrest - Ви можете посадити до в'язниці гравця
	UnCuff - Зняти наручники з любого гравця

	ScreenGrab - Ви можете робити скріншот екрана гравця
	WhoIs - Ви можете дізнатися де проживає гравець

	Slay - Ви можете вбивати гравця

	Demote - звільнити гравця з професії
	Ban - заблокувати гравця
	Cloak - стати невидимим

		]])
	:SetOnActivate(function(pl)
		sam.player.set_rank(pl, 'dadmin', 0)
	end)


IGS("Головний Адміністратор - 30 Днів", "sadmin3")
	:SetPrice(360 * newprice)
	:SetStackable()
	--:SetHighlightColor(Color(255,0,0))
	:SetTerm(30)
	:SetCategory("Привілегії")
	//(900)
	:SetDescription([[

	Если вы Администратор то вы уже настолько крут что круче только OWNER!

	TP - переміщувати гравців
	Goto - переміститися до гравця
	Return - повернути гравця на минулу позицію

	UnArrest/Arrest - Ви можете посадити до в'язниці гравця
	UnCuff - Зняти наручники з любого гравця

	ScreenGrab - Ви можете робити скріншот екрана гравця
	WhoIs - Ви можете дізнатися де проживає гравець

	Slay - Ви можете вбивати гравця

	Demote - звільнити гравця з професії
	Ban - заблокувати гравця
	Cloak - стати невидимим

		]])
	:SetOnActivate(function(pl)
		sam.player.set_rank(pl, 'sadmind', 43200)
	end)

IGS("Головний Адміністратор", "sadmin")
	:SetPrice(450 * newprice)
	:SetStackable()
	:SetPerma() -- 30 дней
	:SetCategory("Привілегії")
	--:SetHighlightColor(Color(255,0,0))
	//(1490)
	:SetDescription([[

	Если вы Администратор то вы уже настолько крут что круче только OWNER!

	Вы умеете: 

	TP - переміщувати гравців
	Goto - переміститися до гравця
	Return - повернути гравця на минулу позицію

	UnArrest/Arrest - Ви можете посадити до в'язниці гравця
	UnCuff - Зняти наручники з любого гравця

	ScreenGrab - Ви можете робити скріншот екрана гравця
	WhoIs - Ви можете дізнатися де проживає гравець

	Slay - Ви можете вбивати гравця

	Demote - звільнити гравця з професії
	Ban - заблокувати гравця
	Cloak - стати невидимим

		]])
	:SetOnActivate(function(pl)
		sam.player.set_rank(pl, 'sadmind', 0)
	end)



 IGS("Аптечка", "apteka")
 	:SetPrice(60 * newprice) 
 	:SetPerma()
 	:SetWeapon('weapon_medkit')
 	:SetDescription("Дозволяє вам використовувати аптечку назавжди") -- описание
 	:SetCategory('Донатна зброя')

 IGS("Шокер", "crack") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(100 * newprice)
 	:SetPerma()
 	:SetWeapon('stungun')
 	:SetDescription("Дозволяє вам використовувати шокер назавжди") -- описание
 	:SetCategory('Донатна зброя')

/*
IGS('Наручники','weapon_cuff_rope'):SetWeapon('weapon_cuff_rope')
	:SetCategory('Донатна зброя')
	:SetDescription([[
	З допомогою цього крутого предмета ви зможете связати сусіда, 
	а також надавати йому триндюлів через те що шумів!)

	Всього за 449 гривень :)
	]])
	:SetPrice(449 * newprice)
  	:SetPerma()

*/

   -- название     -- уникальный айди              -- оружие 
IGS('Ніндзя Кунай','weapon_ninjaskunai'):SetWeapon('weapon_ninjaskunai')
	:SetCategory('Супер Зброя') -- категория можешь не трогать
	 --[[описание]] :SetDescription([[
	Ти можеш стати справжнім Ніндзя

	Всього за 1499 гривень :)
	]])
	//(1499) -- цена без скидки
	:SetPrice(265 * newprice) -- цена за какую можно купить 
  	:SetPerma() -- навсегда
  	:SetIcon("https://i.ibb.co/fGLj7wJ/logo.png")


IGS("Розбан", "razban") -- второй параметр не должен(!) повторяться с другими предметами
	  :SetPrice(300)
	  :SetStackable()
	  :SetDescription("Віднімає у вас 15 днів блокування після активації")
	  :SetCanActivate(function(pl)
		return not pl:IsBanned() and 'Вас не заблоковано'
	  end)
	  :SetOnActivate(function(pl)
		  local isban = pl:IsBanned()
		  local bantime = timer.TimeLeft('GBanPlayer' .. pl:SteamID())
		  if bantime < 0 then return false end
		  bantime = bantime - 1296000
		  if bantime > 0 then
			  bantime = bantime / 60
			  local reason = sql.QueryValue('SELECT Reason FROM gban WHERE SteamID=' .. pl:SteamID())
			  GBan.GiveBanPlayer(pl, nil, reason, bantime)
			  pl:ChatPrint("Вам було успішно прибрано 15 днів із бана.")
		  else
			  GBan.RemoveBanPlayer(pl)
			  pl:ChatPrint("Ви були успішно розблоковані. Надалі не порушуйте правила!")
		  end
	  end)
 	 -- описание

IGS("Анти голод", "antihunger") -- второй параметр не должен(!) повторяться с другими предметами
	:SetPrice(2999)
	:SetDiscountedFrom(4000)
	:SetPerma()
	:SetDescription("У вас не зменшуються голод")
	:SetCanActivate(function(pl)
		return BATTLEPASS:GetPermanentVariable( pl, 'antihunger' ) and 'У вас вже є антиголод'
	end)
	:SetOnActivate(function(pl)
		BATTLEPASS:SetPermanentVariable(pl, "antihunger", true)
	end)
 	 -- описание

IGS("Медичний Vape", "vape_medicinal") -- второй параметр не должен(!) повторяться с другими предметами
   :SetPrice(60 * newprice)
   :SetDiscountedFrom(120)
   :SetPerma()
   :SetWeapon('weapon_vape_medicinal')
   :SetDescription("Дозволяє Вам використовувати 'Медичний Vape' назавжди") -- описание
   :SetCategory('Донатна зброя')

IGS("Український Vape", "vape_ukraine") -- второй параметр не должен(!) повторяться с другими предметами
   :SetPrice(60 * newprice)
   :SetDiscountedFrom(120)
   :SetPerma()
   :SetWeapon('weapon_vape_american')
   :SetDescription("Дозволяє Вам використовувати 'Український Vape' назавжди") -- описание
   :SetCategory('Донатна зброя')

IGS("JackHammer", "m9k_jackhammer") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(149 * newprice)
 	:SetDiscountedFrom(300)
 	:SetPerma()
 	:SetWeapon('m9k_jackhammer')
 	:SetDescription("") -- описание
 	:SetCategory('Супер Зброя')
 	:SetIcon('models/weapons/w_pancor_jackhammer.mdl',true) 

IGS("USAS", "m9k_usas") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(160 * newprice)
 	:SetDiscountedFrom(300)
 	:SetPerma()
 	:SetWeapon('m9k_usas')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_usas_12.mdl',true) 

IGS("Barret M82", "m9k_barret_m82") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(349 * newprice)
 	:SetDiscountedFrom(600)
 	:SetPerma()
 	:SetWeapon('m9k_barret_m82') 
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_barret_m82.mdl',true) 

IGS("Dragunov", "m9k_dragunov") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(315 * newprice)
 	:SetDiscountedFrom(600)
 	:SetPerma()
 	:SetWeapon('m9k_dragunov')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_svd_dragunov.mdl',true) 

IGS("SIG Sauer P229R", "m9k_sig_p229r") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(30 * newprice)
 	:SetDiscountedFrom(90)
 	:SetPerma()
 	:SetWeapon('m9k_sig_p229r')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_sig_229r.mdl',true) 

IGS("P08 Luger", "m9k_luger") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(45 * newprice)
 	:SetDiscountedFrom(90)
 	:SetPerma()
 	:SetWeapon('m9k_luger')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_luger_p08.mdl',true)

IGS("Glock 18", "m9k_glock") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(65 * newprice)
 	:SetDiscountedFrom(125)
 	:SetPerma()
 	:SetWeapon('m9k_glock')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_dmg_glock.mdl',true) 

IGS("S&W Model 500", "m9k_model500") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(55 * newprice)
 	:SetDiscountedFrom(125)
 	:SetPerma()
 	:SetWeapon('m9k_model500')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_sw_model_500.mdl',true) 

IGS("Desert Eagle", "m9k_deagle") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(55 * newprice)
 	:SetDiscountedFrom(125)
 	:SetPerma()
 	:SetWeapon('m9k_deagle')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_tcom_deagle.mdl',true) 

IGS("Raging Bull", "m9k_scoped_taurus") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(70 * newprice)
 	:SetDiscountedFrom(200)
 	:SetPerma()
 	:SetWeapon('m9k_scoped_taurus')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_taurus_raging_bull.mdl',true) 

IGS("MP40", "m9k_mp40") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(90 * newprice)
 	:SetDiscountedFrom(240)
 	:SetPerma()
 	:SetWeapon('m9k_mp40')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_mp40smg.mdl',true) 

IGS("KRISS Vector", "m9k_vector") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(120 * newprice)
 	:SetDiscountedFrom(300)
 	:SetPerma()
 	:SetWeapon('m9k_vector')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_kriss_vector.mdl',true) 

IGS("AAC Honey Badger", "m9k_honeybadger") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(120 * newprice)
 	:SetDiscountedFrom(300)
 	:SetPerma()
 	:SetWeapon('m9k_honeybadger')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_aac_honeybadger.mdl',true) 

IGS("Tommy Gun", "m9k_thompson") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(120 * newprice)
 	:SetDiscountedFrom(300)
 	:SetPerma()
 	:SetWeapon('m9k_thompson')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_tommy_gun.mdl',true) 

IGS("AWP", "swb_awp") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(120 * newprice)
 	:SetDiscountedFrom(300)
 	:SetPerma()
 	:SetWeapon('swb_awp')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_snip_awp.mdl',true) 

IGS("M249", "swb_m249") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(120 * newprice)
 	:SetDiscountedFrom(300)
 	:SetPerma()
 	:SetWeapon('swb_m249')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_mach_m249para.mdl',true)

IGS("AK-74", "m9k_ak74") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(120 * newprice)
 	:SetDiscountedFrom(300)
 	:SetPerma()
 	:SetWeapon('m9k_ak74')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_tct_ak47.mdl',true) 

IGS("HK 416", "m9k_m416") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(150 * newprice)
 	:SetDiscountedFrom(499)
 	:SetPerma()
 	:SetWeapon('m9k_m416')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_hk_416.mdl',true) 

IGS("SR-3M Vikhr", "m9k_vikhr") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(150 * newprice)
 	:SetDiscountedFrom(499)
 	:SetPerma()
 	:SetWeapon('m9k_vikhr')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_dmg_vikhr.mdl',true) 

IGS("M16A4 ACOG", "m9k_m16a4_acog") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(150 * newprice)
 	:SetDiscountedFrom(499)
 	:SetPerma()
 	:SetWeapon('m9k_m16a4_acog')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_dmg_m16ag.mdl',true) 

IGS("Steyr AUG A3", "m9k_auga3") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(170 * newprice)
 	:SetDiscountedFrom(699)
 	:SetPerma()
 	:SetWeapon('m9k_auga3')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_auga3.mdl',true) 

IGS("AS VAL", "m9k_val") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(170 * newprice)
 	:SetDiscountedFrom(699)
 	:SetPerma()
 	:SetWeapon('m9k_val')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_dmg_vally.mdl',true) 

IGS("73 Winchester Carbine", "m9k_winchester73") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(180 * newprice)
 	:SetDiscountedFrom(699)
 	:SetPerma()
 	:SetWeapon('m9k_winchester73')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_winchester_1873.mdl',true) 

IGS("SCAR", "m9k_scar") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(180 * newprice)
 	:SetDiscountedFrom(699)
 	:SetPerma()
 	:SetWeapon('m9k_scar')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_fn_scar_h.mdl',true) 

IGS("F2000", "m9k_f2000") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(230 * newprice)
 	:SetDiscountedFrom(800)
 	:SetPerma()
 	:SetWeapon('m9k_f2000')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_fn_f2000.mdl',true) 

IGS("Mossberg 590", "m9k_mossberg590") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(200 * newprice)
 	:SetDiscountedFrom(699)
 	:SetPerma()
 	:SetWeapon('m9k_mossberg590')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_mossberg_590.mdl',true) 

IGS("Remington 870", "m9k_remington870") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(200 * newprice)
 	:SetDiscountedFrom(699)
 	:SetPerma()
 	:SetWeapon('m9k_remington870')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_remington_870_tact.mdl',true) 

IGS("Striker 12", "m9k_striker12") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(300 * newprice)
 	:SetDiscountedFrom(699)
 	:SetPerma()
 	:SetWeapon('m9k_striker12')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_striker_12g.mdl',true) 

IGS("Winchester 1897", "m9k_1897winchester") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(220 * newprice)
 	:SetDiscountedFrom(599)
 	:SetPerma()
 	:SetWeapon('m9k_1897winchester')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_winchester_1897_trench.mdl',true) 

IGS("Winchester 87", "m9k_1887winchester") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(220 * newprice)
 	:SetDiscountedFrom(599)
 	:SetPerma()
 	:SetWeapon('m9k_1887winchester')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_winchester_1887.mdl',true) 

IGS("SVT 40", "m9k_svt40") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(180 * newprice)
 	:SetDiscountedFrom(599)
 	:SetPerma()
 	:SetWeapon('m9k_svt40')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_svt_40.mdl',true) 

IGS("Intervention", "m9k_intervention") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(270 * newprice)
 	:SetDiscountedFrom(699)
 	:SetPerma()
 	:SetWeapon('m9k_intervention')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_snip_int.mdl',true) 

IGS("PKM", "m9k_pkm") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(300 * newprice)
 	:SetDiscountedFrom(799)
 	:SetPerma()
 	:SetWeapon('m9k_pkm')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_mach_russ_pkm.mdl',true) 

IGS("M60 Machine Gun", "m9k_m60") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(300 * newprice)
 	:SetDiscountedFrom(799)
 	:SetPerma()
 	:SetWeapon('m9k_m60')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/weapons/w_mach_russ_pkm.mdl',true) 

 IGS("Ніж", "knife") -- второй параметр не должен(!) повторяться с другими предметами
     :SetPrice(20 * newprice)
     :SetPerma()
     :SetWeapon('swb_knife')
     :SetDescription("Дозволяє вам використовувати ніж назавжди") -- описание
     :SetCategory('Донатна зброя')

 IGS("Роздатчик Броні", "weapon_armorkit") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(60 * newprice)
 	:SetPerma()
 	:SetWeapon('weapon_armorkit')
 	:SetDescription("Дозволяє вам використовувати роздатчик броні назавжди") -- описание
 	:SetCategory('Донатна зброя')
/*
 IGS("Паркур", "park") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(199 * newprice)
 	:SetPerma()
 	:SetWeapon('climb_swep2')
 	:SetDescription("Дозволяє вам використовувати паркур назавжди") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon("https://i.ibb.co/fGLj7wJ/logo.png")*/

IGS('Відмичка','lockpick'):SetWeapon('lockpick')
	:SetCategory('Донатна зброя')
	:SetDescription([[
	Відмичка завжди в знадобиться вгосподарстві!
	Взламує двері, грошові принтери

	Всього за 99 гривень :)
	]])
	:SetPrice(30 * newprice)
  	:SetPerma()
	:SetIcon("https://i.ibb.co/fGLj7wJ/logo.png")


 IGS("Кейпад Крякер", "cracker") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(40 * newprice)
 	:SetPerma()
 	:SetWeapon('base_keypadcracker')
 	:SetDescription("Дозволяє вам використовувати кейпад крякер назавжди") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon("https://i.ibb.co/fGLj7wJ/logo.png")

 IGS("Танці з Фортнайта", "fortnai") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(50 * newprice)
 	:SetPerma()
 	:SetWeapon('wos_fortnite_dancer')
 	:SetDescription("Танці з Фортнайта") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon("https://i.ibb.co/fGLj7wJ/logo.png")	

IGS("Death Note", "death_note") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(1000 * newprice)
 	:SetDiscountedFrom(2000)
 	:SetPerma()
 	:SetWeapon('death_note')
 	:SetDescription("") -- описание
 	:SetCategory('Донатна зброя')
 	:SetIcon('models/death_note/deathnote.mdl',true) 
 	:SetHidden(true)


local function getter(pl)
	return tonumber(util.GetPData( pl:SteamID(), 'propov', 0 )) >= 500 and 'Ліміт пропів було досягнуто'
end

IGS("+5 пропов", "5propov") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(10)
 	:SetDescription("Дозволяє вам 5 пропов") -- описание
 	:SetCategory('Донатна зброя')
	:SetStackable(true)
	:SetCanActivate(function(pl)
		return getter(pl)
	end)
	:SetOnActivate(function(pl)
		local add = tonumber(util.GetPData( pl:SteamID(), 'propov', 0 )) + 5
		if add >= 500 then
			util.SetPData( pl:SteamID(), 'propov', 500 )
			return
		end
		--
		util.SetPData( pl:SteamID(), 'propov', add )
	end)

IGS("+10 пропов", "10propov") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(20)
 	:SetDescription("Дозволяє вам 10 пропов") -- описание
 	:SetCategory('Донатна зброя')
	:SetStackable(true)
	:SetCanActivate(function(pl)
		return getter(pl)
	end)
	:SetOnActivate(function(pl)
		local add = tonumber(util.GetPData( pl:SteamID(), 'propov', 0 )) + 10
		if add >= 500 then
			util.SetPData( pl:SteamID(), 'propov', 500 )
			return
		end
		--
		util.SetPData( pl:SteamID(), 'propov', add )
	end)

IGS("+25 пропов", "25propov") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(40)
 	:SetDescription("Дозволяє вам 25 пропов") -- описание
 	:SetCategory('Донатна зброя')
	:SetStackable(true)
	:SetCanActivate(function(pl)
		return getter(pl)
	end)
	:SetOnActivate(function(pl)
		local add = tonumber(util.GetPData( pl:SteamID(), 'propov', 0 )) + 25
		if add >= 500 then
			util.SetPData( pl:SteamID(), 'propov', 500 )
			return
		end
		--
		util.SetPData( pl:SteamID(), 'propov', add )
	end)

IGS("+50 пропов", "50propov") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(40 * newprice)
 	:SetDescription("Дозволяє вам 50 пропов") -- описание
 	:SetCategory('Донатна зброя')
	:SetStackable(true)
	:SetCanActivate(function(pl)
		return getter(pl)
	end)
	:SetOnActivate(function(pl)
		local add = tonumber(util.GetPData( pl:SteamID(), 'propov', 0 )) + 50
		if add >= 500 then
			util.SetPData( pl:SteamID(), 'propov', 500 )
			return
		end
		--
		util.SetPData( pl:SteamID(), 'propov', add )
	end)

IGS("+75 пропов", "75propov") -- второй параметр не должен(!) повторяться с другими предметами
 	:SetPrice(65 * newprice)
 	:SetDescription("Дозволяє вам 75 пропов") -- описание
 	:SetCategory('Донатна зброя')
	:SetStackable(true)
	:SetCanActivate(function(pl)
		return getter(pl)
	end)
	:SetOnActivate(function(pl)
		local add = tonumber(util.GetPData( pl:SteamID(), 'propov', 0 )) + 75
		if add >= 500 then
			util.SetPData( pl:SteamID(), 'propov', 500 )
			return
		end
		--
		util.SetPData( pl:SteamID(), 'propov', add )
	end)

IGS("Щит", "deployable_shield") -- второй параметр не должен(!) повторяться с другими предметами
	:SetPrice(500 * newprice)
	:SetDiscountedFrom(700)
	:SetPerma()
	:SetWeapon('deployable_shield')
	:SetDescription("") -- описание
	:SetCategory('Донатна зброя')
	:SetIcon('models/bshields/dshield.mdl',true) 
	 
IGS("Катана", "weapon_mse_katana") -- второй параметр не должен(!) повторяться с другими предметами
	:SetPrice(300 * newprice)
	:SetPerma()
	:SetWeapon('weapon_mse_katana')
	:SetDescription("") -- описание
	:SetCategory('Донатна зброя')
	:SetIcon('models/weapons/w_katana.mdl',true) 

IGS("Cry Pistol", "weapon_ebony_ivory") -- второй параметр не должен(!) повторяться с другими предметами
	:SetPrice(1000 * newprice)
	:SetDiscountedFrom(2000)
	:SetPerma()
	:SetWeapon('weapon_ebony_ivory')
	:SetDescription("") -- описание
	:SetCategory('Донатна зброя')
	:SetIcon('models/w_models/w_pistol_dual_dmc3.mdl',true) 
	:SetHidden(true)
--PATH addons/igs-core/lua/igs/interface/vgui/igs_button.lua:
local PANEL = {}

function PANEL:Init()
	self:SetTextColor(IGS.col.HIGHLIGHTING)
	self:SetFont("igs.18")
end

-- Как блять по человечески оверрайднуть эту хуетоту?
-- function PANEL:SetText(text)
-- 	self.BaseClass:SetText(" " .. text .. " ") -- чтобы при SizeToContent было не вплотную к стенкам
-- end

function PANEL:SetActive(bActive)
	self.active = bActive

	self:SetTextColor(self.active and IGS.col.TEXT_ON_HIGHLIGHT or IGS.col.HIGHLIGHTING)
end

function PANEL:IsActive()
	return self.active
end

function PANEL:Paint(w,h)
	draw.RoundedBox(4,0,0,w,h,IGS.col.HIGHLIGHTING) -- outline

	if not self.active then
		draw.RoundedBox(4,1,1,w - 2,h - 2,IGS.col.PASSIVE_SELECTIONS) -- bg TODO изменить, сделав как-то прозрачным
	end
end

vgui.Register("igs_button",PANEL,"DButton")

-- IGS.UI()

--PATH addons/igs-core/lua/igs/interface/vgui/igs_panels_layout_list.lua:
local PANEL = {}

function PANEL:Init()
	-- categ_name > categpan
	self.list = {}
end

-- Одиночное добавление
function PANEL:Add(panel,sCategory)
	local cat = sCategory or "Різне"

	if not self.list[cat] then
		self.list[cat] = uigs.Create("igs_panels_layout", self)
		self.list[cat]:SetWide(650)
		self.list[cat]:SetName(sCategory)
		self.list[cat]:DisableAlignment(self.disabled_align)

		self:AddItem(self.list[cat])
	end

	self.list[cat]:Add(panel)

	return self.list[cat]
end

-- Отключает центрирование эллементов во всех панелях лэйаута
function PANEL:DisableAlignment(bDisable)
	self.disabled_align = bDisable
end

function PANEL:Clear()
	for _,panel in pairs(self.list) do -- categ
		panel:Remove()
	end

	self:Init()
end

vgui.Register("igs_panels_layout_list", PANEL, "igs_scroll")
-- IGS.UI()

--PATH addons/igs-core/lua/igs/modules/extra/_main.lua:
IGS.sv("don_grace_sv.lua")
IGS.sv("error_logging_sv.lua")
IGS.sv("installation_check_sv.lua")
IGS.cl("new_items_notify_cl.lua")

IGS.sh("init_sh.lua")
IGS.sv("init_sv.lua")
IGS.cl("init_cl.lua")

--PATH addons/igs-core/lua/igs/modules/inv_log/core_cl.lua:
IGS.IL = IGS.IL or {}

local callbacks,last,MAX = {},0,7
function IGS.IL.GetLog(fCb, iPage, s64_owner, gift_uid)
	net.Start("IGS.InvLog")
		net.WriteBool(s64_owner)
		if s64_owner then
			net.WriteString(s64_owner)
		end

		net.WriteBool(gift_uid)
		if gift_uid then
			net.WriteString(gift_uid)
		end

		net.WriteBool(iPage)
		if iPage then
			net.WriteUInt(iPage,8)
		end

		last = (last + 1) % MAX + 1
		callbacks[last] = fCb

		net.WriteUInt(last,3)
	net.SendToServer()
end
-- IGS.IL.GetLog(PRINT, 1, nil, "chat_prefix")

net.Receive("IGS.InvLog", function()
	local cb_id = net.ReadUInt(3)
	local cb = callbacks[cb_id]
	-- prt({callbacks = callbacks,cb_id = cb_id})
	assert(cb,"No callback with id " .. cb_id)

	local data = {[0] = net.ReadUInt(22)}
	for i = 1,net.ReadUInt(6) do
		data[i] = {
			owner     = net.ReadString(),
			inflictor = net.ReadString(),
			gift_uid  = net.ReadString(),
			gift_id   = net.ReadUInt(22),
			action    = net.ReadUInt(3),
			action_id = net.ReadUInt(22),
			date      = net.ReadUInt(32),
		}
	end

	cb(data)
	callbacks[cb_id] = nil
end)



local sid_to_name_cache = {}
function IGS.IL.NameRequest(fCb, s64)
	if sid_to_name_cache[s64] then -- cached or queued {}
		local cached = sid_to_name_cache[s64][0]
		if cached ~= nil then
			fCb(cached) -- mb false
		else -- добавляем еще одного желающего получить результат запроса
			table.insert(sid_to_name_cache[s64], fCb)
		end
	else
		-- скок же я проебался, забыв добавить в таблицу fCb
		sid_to_name_cache[s64] = {fCb}
		net.Start("IGS.NameRequest")
			net.WriteString(s64)
		net.SendToServer()
	end
end

net.Receive("IGS.NameRequest", function()
	local requested_s64 = net.ReadString()
	local name_ = net.ReadBool() and net.ReadString()

	local cbs = sid_to_name_cache[requested_s64]
	for i = #cbs,1,-1 do
		cbs[i](name_ or false)
		cbs[i] = nil
	end
	cbs[0] = name_ -- cache
end)
-- IGS.IL.NameRequest(PRINT, AMD():SteamID64())
-- IGS.IL.NameRequest(PRINT, "76561198109429966")


function IGS.DeactivateItem(iPurchID)
	net.Start("IGS.DeactivateItem")
		net.WriteUInt(iPurchID, IGS.BIT_PURCH_ID)
	net.SendToServer()
end

--PATH addons/igs-core/lua/igs/modules/pushes/_main.lua:
IGS.sv("akupol_sv.lua")
IGS.sv("init_sv.lua")
IGS.sv("actions_sv.lua")

--PATH addons/_hitreg/lua/leyhitreg/shared/spreadsystem/firebullets.lua:
function LeyHitreg:SpreadedEntityFireBullets(ply, wep, bullet, spread)
    if (LeyHitreg.Disabled) then
        return
    end

    if (LeyHitreg.BrokenDefaultSpread) then
        return
    end

    local bulletSpread = spread or LeyHitreg:GetWeaponSpread(ply, wep, bullet)
    local appliedAny, newDir = self:ApplyBulletSpread(ply, bullet.Dir, bulletSpread)

    if (not appliedAny) then
        return
    end

    bullet.Spread = vector_origin
    bullet.Dir = newDir
    return true
end

--PATH addons/lvs_base-main/lua/lvs_framework/autorun/lvs_net.lua:

if SERVER then
	util.AddNetworkString( "lvs_player_request_filter" )
	util.AddNetworkString( "lvs_player_enterexit" )
	util.AddNetworkString( "lvs_toggle_mouseaim" )

	net.Receive( "lvs_toggle_mouseaim", function( length, ply )
		ply:lvsBuildControls()

		local veh = ply:lvsGetVehicle()

		if not IsValid( veh ) then return end

		veh:AlignView( ply )
	end)

	net.Receive( "lvs_player_request_filter", function( length, ply )
		if not IsValid( ply ) then return end

		local ent = net.ReadEntity()

		if not IsValid( ent ) or not ent.GetCrosshairFilterEnts then return end -- TODO: Make this loop around and wait for ent.IsInitialized to exist and ent:IsInitialized() to return true

		local CrosshairFilterEnts = table.Copy( ent:GetCrosshairFilterEnts() )

		for id, entity in pairs( CrosshairFilterEnts ) do
			if not IsValid( entity ) or entity:GetNoDraw() then
				CrosshairFilterEnts[ id ] = nil
			end
		end

		net.Start( "lvs_player_request_filter" )
			net.WriteEntity( ent )
			net.WriteTable( CrosshairFilterEnts )
		net.Send( ply )
	end)
else
	net.Receive( "lvs_player_request_filter", function( length )
		local LVSent = net.ReadEntity()

		if not IsValid( LVSent ) then return end

		local Filter = {}

		for _, entity in pairs( net.ReadTable() ) do
			if not IsValid( entity ) then continue end
			table.insert( Filter, entity )
		end

		LVSent.CrosshairFilterEnts = Filter
	end )

	net.Receive( "lvs_player_enterexit", function( len )
		local Enable = net.ReadBool()
		local Vehicle = net.ReadEntity()

		if Enable then
			hook.Run( "LVS.PlayerEnteredVehicle", LocalPlayer(), Vehicle )
		else
			hook.Run( "LVS.PlayerLeaveVehicle", LocalPlayer(), Vehicle )
		end
	end )
end
--PATH addons/ukrp_main_content/lua/autorun/madara.lua:
/*
	Addon by Yevocore	
*/
player_manager.AddValidModel( "madara", "models/player/naruto/madara.mdl" );
list.Set( "PlayerOptionsModel", "madara", "models/player/naruto/madara.mdl" );
--PATH addons/_mayor_voting_systems/lua/panels/cl_votingpanel.lua:
/*---------------------------------------------------------
  START PlayerVotingPanel
---------------------------------------------------------*/
local PlayerVotingPanel = {}

function PlayerVotingPanel:Init()
	self:SetDrawBackground(false)
	self:SetDrawBorder(false)
	//self:SetStretchToFit(false)
	self:SetSize(350, 70)
	self.CurrentWidth = 350
	self.ColorBarWidth = 38
	self.CurrentAlpha = 0
	self.BackColor = VOTING.Theme.ControlColor
	self.TextColor = Color(255, 255, 255, 250 )
	self.HoverColor = Color(23, 55, 94, 250 )
	self.HoverTextColor = Color(142, 180, 227, 250)
	self.Hovering = false
	
	self.HeaderLbl = vgui.Create("DLabel", self)
	self.HeaderLbl:SetFont("Bebas24Font")
	self.HeaderLbl:SetColor(self.TextColor)
	
	self.VoteLbl = vgui.Create("DLabel", self)
	self.VoteLbl:SetFont("Bebas70Font")
	self.VoteLbl:SetColor(self.TextColor)
	
	self.PlayerIcon = vgui.Create("VotingPlayerIcon", self)
	
	self.VoteCircle = vgui.Create("DImage", self)
	self.VoteCircle:SetImage("mayorvoting/smallvotecircle.png")
	self.VoteCircle:SetSize(68, 65)
	self.VoteCircle:SetVisible(false)
	
	//self.BorderColor = Color(190,40,0,255)
end

function PlayerVotingPanel:SetNoActionEnbaled(results)
	self.NoAction = true
	self.HoverColor = Color(0, 0, 0, 155 )
	self.AlphaFade = 255
	self.StartAlphaFade = true
	self.HeaderLbl:SetColor(Color(153, 153, 153, 90 ))
	self.VoteLbl:SetColor(Color(153, 153, 153, 90 ))
	if results then
		self.PlayerIcon:SetVisible(false)
		self.VoteCircle:SetVisible(false)
	end
end

function PlayerVotingPanel:SetPlayer(ply)
	if not IsValid(ply) then self:SetNoActionEnbaled() end
	
	if (#ply:Nick() > 20) then
	self.HeaderLbl:SetText(string.sub(ply:Nick(), 1, 25) .. "...")
	else
	self.HeaderLbl:SetText(ply:Nick())
	end
	self.HeaderLbl:SizeToContents()
	self.CurrentPlayer = ply
	self.CurrentVotes = 0
	self.VoteLbl:SetText(tostring(self.CurrentVotes))
	self.VoteLbl:SizeToContents()
	
	self.PlayerIcon:InvalidateLayout( true )
	self.PlayerIcon:SetModel(ply:GetModel())
	self.PlayerIcon:SetSize(64, 64)
	self.PlayerIcon:SetToolTip(ply:Nick())
end

function PlayerVotingPanel:GetPlayer(ply)
	if IsValid(self.CurrentPlayer) then return self.CurrentPlayer
	else self:SetNoActionEnbaled() return nil end
end

function PlayerVotingPanel:SetColor(color)
	if not type(color) == "color" then return end
	//self.NoAction = true
	self.BackColor = color
	self.HoverTextColor = color
end

function PlayerVotingPanel:GetColor()
	return self.BackColor
end

function PlayerVotingPanel:IncreaseVote(num)
	self.CurrentVotes = (self.CurrentVotes + num)
	self.VoteLbl:SetText(tostring(self.CurrentVotes))
	self.VoteLbl:SizeToContents()
	self.CurrentAlpha = 255
end

function PlayerVotingPanel:SetText(text)
	self.HeaderLbl:SetText(text)
	self.HeaderLbl:SizeToContents()
end

function PlayerVotingPanel:SetSubText(text)
	self.SubLbl:SetText(text)
	self.SubLbl:SizeToContents()
	self.SubLbl:SetVisible(true)
end

function PlayerVotingPanel:PerformLayout()
	
	local offset = (self.CurrentWidth - self.HeaderLbl:GetWide()) * 0.5
	self.HeaderLbl:SetPos(offset, 3)
	
	self.VoteLbl:SetPos(300, 3)
	
	self.PlayerIcon:SetPos(3,3)

	self:SetWide( self.CurrentWidth )
end

function PlayerVotingPanel:Paint()

	if self.StartAlphaFade then
		self.AlphaFade = math.Approach( self.AlphaFade, 50, FrameTime() * 400 )
		local c = self.BackColor
		local r,g,b = c.r,c.g,c.b
		surface.SetDrawColor(r,g,b,self.AlphaFade)
	else
	surface.SetDrawColor(self.BackColor)
	end
	surface.DrawRect( 0, 0, self:GetWide(), self:GetTall())
	
	//Vote count box
	self.CurrentAlpha = math.Approach( self.CurrentAlpha, 0, FrameTime() * 200 )

	surface.SetDrawColor(self:ColorWithCurrentAlpha(VOTING.Theme.ControlColor))
	surface.DrawRect( 295, 0, self.VoteLbl:GetWide() + 10, self.VoteLbl:GetTall())
end

function PlayerVotingPanel:OnCursorEntered()
	self.Hovering = true
	self.ColorBarWidth = 38
	if not self.NoAction and not self.CurrentSelection and not LocalPlayer().HasVoted then
		self.VoteCircle:SetVisible(true)
	end
end

function PlayerVotingPanel:OnCursorExited()
	self.Hovering = false
	if not self.NoAction and not self.CurrentSelection and not LocalPlayer().HasVoted then
		self.VoteCircle:SetVisible(false)
	end
end

function PlayerVotingPanel:ToggleSelect(select)
	if select then
		self.CurrentSelection = true
	else
		self.CurrentSelection = false
	end
end

function PlayerVotingPanel:ColorWithCurrentAlpha(c)
	local r,g,b = c.r,c.g,c.b
	return Color(r,g,b,self.CurrentAlpha)
end

derma.DefineControl("PlayerVotingPanel", "Player voting panel for mayor elections", PlayerVotingPanel, "DImageButton")

/*---------------------------------------------------------
  End PlayerVotingPanel
---------------------------------------------------------*/
--PATH addons/media_player/lua/mediaplayer/controls/dhtmlcontrols.lua:
--[[__                                       _
 / _| __ _  ___ ___ _ __  _   _ _ __   ___| |__
| |_ / _` |/ __/ _ \ '_ \| | | | '_ \ / __| '_ \
|  _| (_| | (_|  __/ |_) | |_| | | | | (__| | | |
|_|  \__,_|\___\___| .__/ \__,_|_| |_|\___|_| |_|
                   |_| 2010 --]]

--[[---------------------------------------------------------
	Browser controls
-----------------------------------------------------------]]

local urllib = url

local PANEL = {}

AccessorFunc( PANEL, "HomeURL", "HomeURL", FORCE_STRING )

function PANEL:Init()

	local ButtonSize = 32
	local Margins = 2
	local Spacing = 0

	self.BackButton = vgui.Create( "DIconButton", self )
	self.BackButton:SetIcon( "mp-back" )
	self.BackButton:SetSize( ButtonSize, ButtonSize )
	self.BackButton:Dock( LEFT )
	self.BackButton:DockMargin( Spacing*3, Margins, Spacing, Margins )
	self.BackButton.DoClick = function()
		self.BackButton:SetDisabled( true )
		self:HTMLBack()
		self.Cur = self.Cur - 1
		self.Navigating = true
	end

	self.ForwardButton = vgui.Create( "DIconButton", self )
	self.ForwardButton:SetIcon( "mp-forward" )
	self.ForwardButton:SetSize( ButtonSize, ButtonSize )
	self.ForwardButton:Dock( LEFT )
	self.ForwardButton:DockMargin( Spacing, Margins, Spacing, Margins )
	self.ForwardButton.DoClick = function()
		self.ForwardButton:SetDisabled( true )
		self:HTMLForward()
		self.Cur = self.Cur + 1
		self.Navigating = true
	end

	self.RefreshButton = vgui.Create( "MPRefreshButton", self )
	self.RefreshButton:SetSize( ButtonSize, ButtonSize )
	self.RefreshButton:Dock( LEFT )
	self.RefreshButton:DockMargin( Spacing, Margins, Spacing, Margins )
	self.RefreshButton.DoClick = function()
		self.RefreshButton:SetDisabled( true )
		self.Refreshing = true
		self.HTML:Refresh()
	end

	self.HomeButton = vgui.Create( "DIconButton", self )
	self.HomeButton:SetIcon( "mp-home" )
	self.HomeButton:SetSize( ButtonSize, ButtonSize )
	self.HomeButton:Dock( LEFT )
	self.HomeButton:DockMargin( Spacing, Margins, Spacing*3, Margins )
	self.HomeButton.DoClick = function()
		self.HTML:Stop()
		self.HTML:OpenURL( self:GetHomeURL() )
	end

	self.AddressBar = vgui.Create( "DTextEntry", self )
	self.AddressBar:Dock( FILL )
	self.AddressBar:DockMargin( Spacing, Margins * 3, Spacing, Margins * 3 )
	self.AddressBar.OnEnter = function()
		self.HTML:Stop()
		self.HTML:OpenURL( self.AddressBar:GetValue() )
	end

	local AddrSetText = self.AddressBar.SetText
	self.AddressBar.SetText = function (panel, text)
		AddrSetText( panel, urllib.unescape(text) )
	end

	self.RequestButton = vgui.Create( "MPRequestButton", self )
	self.RequestButton:SetDisabled( true )
	self.RequestButton:Dock( RIGHT )
	self.RequestButton:DockMargin( 8, 4, 8, 4 )
	self.RequestButton.DoClick = function()
		MediaPlayer.MenuRequest( self.HTML:GetURL() )
	end

	self:SetHeight( ButtonSize + Margins * 2 )

	self.NavStack = 0
	self.History = {}
	self.Cur = 1

	-- This is the default look, feel free to change it on your created control :)
	self:SetButtonColor( Color( 250, 250, 250, 200 ) )
	self.BorderSize = 4
	self.BackgroundColor = Color( 33, 33, 33, 255 )
	self:SetHomeURL( "http://www.google.com" )

end

function PANEL:SetHTML( html )

	self.HTML = html

	if ( html.URL ) then
		self:SetHomeURL( self.HTML.URL )
	end

	self.RefreshButton:SetHTML(html)
	self.AddressBar:SetText( self:GetHomeURL() )
	self:UpdateHistory( self:GetHomeURL() )

	local OnFinishLoading = self.HTML.OnFinishLoading
	self.HTML.OnFinishLoading = function( panel )

		local url = self.HTML:GetURL()

		self.AddressBar:SetText( url )
		self:FinishedLoading()

		if OnFinishLoading then
			OnFinishLoading( panel )
		end

	end

	local OnURLChanged = self.HTML.OnURLChanged
	self.HTML.OnURLChanged = function ( panel, url )

		self.AddressBar:SetText( url )
		self.NavStack = self.NavStack + 1
		self:StartedLoading()
		self:UpdateHistory( url )

		-- Check for valid URL
		local isValidUrl = MediaPlayer.ValidUrl( url )
		self.RequestButton:SetDisabled( not isValidUrl )

		if ( OnURLChanged ) then
			OnURLChanged( panel, url )
		end

	end

end

function PANEL:UpdateHistory( url )

	--print( "PANEL:UpdateHistory", url )
	self.Cur = math.Clamp( self.Cur, 1, table.Count( self.History ) )

	local top = self.History[self.Cur]

	-- Ignore page refresh
	if top == url then
		return
	end

	if ( self.Refreshing ) then

		self.Refreshing = false
		self.RefreshButton:SetDisabled( false )
		return

	end

	if ( self.Navigating ) then

		self.Navigating = false
		self:UpdateNavButtonStatus()
		return

	end

	-- We were back in the history queue, but now we're navigating
	-- So clear the front out so we can re-write history!!
	if ( self.Cur < table.Count( self.History ) ) then

		for i = self.Cur+1, table.Count( self.History ) do
			self.History[i] = nil
		end

	end

	self.Cur = table.insert( self.History, url )

	self:UpdateNavButtonStatus()

end

function PANEL:HTMLBack()
	if self.Cur <= 1 then return end
	self.Cur = self.Cur - 1
	self.HTML:OpenURL( self.History[ self.Cur ], true )
end

function PANEL:HTMLForward()
	if self.Cur == #self.History then return end
	self.Cur = self.Cur + 1
	self.HTML:OpenURL( self.History[ self.Cur ], true )
end

function PANEL:FinishedLoading()

	self.RefreshButton:SetDisabled( false )

end

function PANEL:StartedLoading()

	self.RefreshButton:SetDisabled( true )

end

function PANEL:UpdateNavButtonStatus()

	--print( self.Cur, table.Count( self.History ) )

	self.ForwardButton:SetDisabled( self.Cur >= table.Count( self.History ) )
	self.BackButton:SetDisabled( self.Cur == 1 )

end

function PANEL:SetButtonColor( col )

	self.BackButton:SetColor( col )
	self.ForwardButton:SetColor( col )
	self.RefreshButton:SetColor( col )
	self.HomeButton:SetColor( col )

end

function PANEL:Paint()

	draw.RoundedBoxEx( self.BorderSize, 0, 0, self:GetWide(), self:GetTall(), self.BackgroundColor, true, true, false, false )

end

derma.DefineControl( "MPHTMLControls", "", PANEL, "Panel" )


--[[---------------------------------------------------------
	Media request button
	Embedded inside of the browser controls.
-----------------------------------------------------------]]

local RequestButton = {}

-- RequestButton.DisabledColor = Color(189, 195, 199)
-- RequestButton.DepressedColor = Color(192, 57, 43)
RequestButton.HoverColor = Color(192, 57, 43)
RequestButton.DefaultColor = Color(231, 76, 60)
RequestButton.DisabledColor = RequestButton.DefaultColor
RequestButton.DepressedColor = RequestButton.DefaultColor

RequestButton.DefaultTextColor = Color(236, 236, 236)
RequestButton.DisabledTextColor = Color(158, 48, 36)

function RequestButton:Init()
	DButton.Init(self)

	local ButtonSize = 32

	self:SetSize( ButtonSize*8, ButtonSize )
	self:SetFont( "MediaRequestButton" )

	self:SetDisabled( true )
end

function RequestButton:SetDisabled( disabled )
	if disabled then
		self:SetText( "SEARCH FOR MEDIA" )
	else
		self:SetText( "REQUEST URL" )
	end

	DButton.SetDisabled( self, disabled )
end

function RequestButton:UpdateColours()
	if self:GetDisabled() then
		return self:SetTextStyleColor( self.DisabledTextColor )
	else
		return self:SetTextStyleColor( self.DefaultTextColor )
	end
end

function RequestButton:Paint( w, h )
	local col

	if self:GetDisabled() then
		col = self.DisabledColor
	elseif self.Depressed or self.m_bSelected then
		col = self.DepressedColor
	elseif self:IsHovered() then
		col = self.HoverColor
	else
		-- Pulse effect
		local h, s, v = ColorToHSV( self.DefaultColor )
		v = 0.7 + math.sin(RealTime() * 10) * 0.3

		col = HSVToColor(h,s,v)
	end

	draw.RoundedBox( 2, 0, 0, w, h, col )
end

derma.DefineControl( "MPRequestButton", "", RequestButton, "DButton" )


--[[---------------------------------------------------------
	Media refresh button
	Embedded inside of the browser controls.
-----------------------------------------------------------]]

local RefreshButton = {}

AccessorFunc( RefreshButton, "HTML", "HTML" )

function RefreshButton:Init()
	self.BaseClass.Init( self )
	self:SetIcon( "mp-refresh" )
	self:SetText( "" )
end

local Matrix = Matrix
local vecTranslate = Vector()
local angRotate = Angle()

function RefreshButton:Paint( w, h )

	if ValidPanel(self.HTML) and self.HTML:IsLoading() then
		local x, y = self:LocalToScreen(0,0)

		vecTranslate.x = x + w * 0.5
		vecTranslate.y = y + h * 0.5

		angRotate.y = RealTime() * 512

		local mat = Matrix()
		mat:Translate( vecTranslate )
		mat:Rotate( angRotate )
		mat:Translate( -vecTranslate )
		cam.PushModelMatrix( mat )
		self._PushedMatrix = true
	end

	self.BaseClass.Paint( self, w, h )

end

function RefreshButton:PaintOver()

	if self._PushedMatrix then
		cam.PopModelMatrix()
		self._PushedMatrix = nil
	end

end

derma.DefineControl( "MPRefreshButton", "", RefreshButton, "DIconButton" )

--PATH addons/media_player/lua/mediaplayer/sh_mediaplayer.lua:
if SERVER then
	include "players/components/vote.lua"
	include "players/components/voteskip.lua"
end

--[[---------------------------------------------------------
	Media Player Types
-----------------------------------------------------------]]

MediaPlayer.Type = {}

local function setBaseClass( name, tbl )
	local classname = "mp_" .. name

	if MediaPlayer.Type[name] ~= nil then
		if MediaPlayer.DEBUG then
			Msg("Media player type '" .. name .. "' is already registered. ")
			Msg("Clearing baseclass...\n")
		end

		-- HACK: removes registered baseclass if it already exists to avoid Lua
		-- refresh table.Merge errors...
		local _, BaseClassTable = debug.getupvalue(baseclass.Get, 1)
		BaseClassTable[classname] = nil
	end

	baseclass.Set( classname, tbl )
end

---
-- Registers a media player type.
--
-- @param tbl	Media player type table.
--
function MediaPlayer.Register( tbl )

	local name = tbl.Name

	if not name then
		ErrorNoHalt("MediaPlayer.Register - Must include name property\n")
		debug.Trace()
		return
	end

	name = name:lower() -- always use lowercase names
	tbl.Name = name
	tbl.__index = tbl

	-- Set base meta table
	local base = tbl.Base or "base"
	if base and name ~= "base" then
		base = base:lower()

		if not MediaPlayer.Type[base] then
			ErrorNoHalt("MediaPlayer.Register - Invalid base name: " .. base .. "\n")
			debug.Trace()
			return
		end

		base = MediaPlayer.Type[base]

		setmetatable(tbl, {
			__index = base,
			__tostring = base.__tostring
		})
	end

	-- Store media player type as a base class
	setBaseClass( name, tbl )

	-- Save player type
	MediaPlayer.Type[name] = tbl

	if MediaPlayer.DEBUG then
		Msg( "MediaPlayer.Register\t" .. name .. "\n" )
	end

end

function MediaPlayer.IsValidType( type )
	return MediaPlayer.Type[type] ~= nil
end

-- Load players
do
	local path = "players/"
	local players = {
		"base", -- MUST LOAD FIRST!
		"entity"
	}

	for _, player in ipairs(players) do
		local clfile = path .. player .. "/cl_init.lua"
		local svfile = path .. player .. "/init.lua"

		MEDIAPLAYER = {}

		if SERVER then
			AddCSLuaFile(clfile)
			include(svfile)
		else
			include(clfile)
		end

		MediaPlayer.Register( MEDIAPLAYER )
		MEDIAPLAYER = nil
	end
end


--[[---------------------------------------------------------
	Media Player Helpers
-----------------------------------------------------------]]

MediaPlayer.List = MediaPlayer.List or {}
MediaPlayer._count = MediaPlayer._count or 0

---
-- Creates a media player object.
--
-- @param id		Media player ID.
-- @param type?		Media player type (defaults to 'base').
-- @return table	Media player object.
--
function MediaPlayer.Create( id, type )
	-- Inherit media player type
	local PlayerType = MediaPlayer.Type[type]
	PlayerType = PlayerType or MediaPlayer.Type.base

	-- Create media player object
	local mp = setmetatable( {}, { __index = PlayerType } )

	-- Assign unique ID
	if id then
		mp.id = id
	elseif SERVER then
		MediaPlayer._count = MediaPlayer._count + 1
		mp.id = MediaPlayer._count
	else
		mp.id = id or -1
	end

	mp:Init()

	-- Add to media player list
	MediaPlayer.List[mp.id] = mp

	if MediaPlayer.DEBUG then
		print( "Created Media Player", mp, mp.Name, type )
	end

	return mp
end

---
-- Destroys the given media player object.
--
-- @param table		Media player object.
--
function MediaPlayer.Destroy( mp )
	-- TODO: does this need anything else?
	MediaPlayer.List[mp.id] = nil

	if MediaPlayer.DEBUG then
		print( "Destroyed Media Player '" .. tostring(mp.id) .. "'" )
	end
end

---
-- Gets the media player associated with the given ID.
--
-- @param id		Media player ID.
-- @return table 	Media player object.
--
function MediaPlayer.GetById( id )
	local mp = MediaPlayer.List[id]
	if mp then
		return mp
	else
		-- Since entity indexes can change, let's iterate the list just to
		-- be sure...
		for _, mp in pairs(MediaPlayer.List) do
			if mp:GetId() == id then
				return mp
			end
		end
	end
end

---
-- Gets all active media players.
--
-- @return table	Array of all active media players.
--
function MediaPlayer.GetAll()
	local tbl = {}

	for _, mp in pairs( MediaPlayer.List ) do
		table.insert( tbl, mp )
	end

	return tbl
end

---
-- Gets the media player associated with the given object.
--
-- @param obj Any object.
--
function MediaPlayer.GetByObject( obj )
	local mp = nil

	if isentity(obj) and obj.IsMediaPlayerEntity then
		mp = obj:GetMediaPlayer()
	elseif istable(obj) and obj.IsMediaPlayer then
		mp = obj
	elseif isstring(obj) then
		mp = MediaPlayer.GetById(obj)
	end

	return mp
end


--[[---------------------------------------------------------
	Media Player Think Loop
-----------------------------------------------------------]]

MediaPlayer.ThinkInterval = 0.2 -- seconds

local function MediaPlayerThink()
	for id, mp in pairs( MediaPlayer.List ) do
		local succ, err = pcall(mp.Think, mp)
		if not succ then
			ErrorNoHalt(err .. "\n")

			-- TODO: recreate mediaplayer object instead
			mp:Remove()
		end
	end
end

if timer.Exists( "MediaPlayerThink" ) then
	timer.Destroy( "MediaPlayerThink" )
end

-- TODO: only start timer when at least one mediaplayer is created; stop it when
-- there are none left.
timer.Create( "MediaPlayerThink", MediaPlayer.ThinkInterval, 0, MediaPlayerThink )
timer.Start( "MediaPlayerThink" )

--PATH addons/media_player/lua/mediaplayer/players/base/net.lua:
local net = net
local CeilPower2 = MediaPlayerUtils.CeilPower2

local EOT = "\4" -- End of transmission

MEDIAPLAYER.net = {}
local mpnet = MEDIAPLAYER.net

function mpnet.ReadDuration()
	return net.ReadUInt(16)
end

function mpnet.WriteDuration( seconds )
	net.WriteUInt( seconds, 16 )
end

function mpnet.ReadMedia()
	local uid = net.ReadString()

	if uid == EOT then
		return nil
	end

	local url = net.ReadString()
	local metadata = net.ReadTable()
	local ownerName = net.ReadString()
	local ownerSteamId = net.ReadString()

	-- Create media object
	local media = MediaPlayer.GetMediaForUrl( url, true )

	-- Set uniqud ID to match the server
	media._id = uid

	media:SetMetadata( metadata, true )
	media._OwnerName = ownerName
	media._OwnerSteamID = ownerSteamId

	return media
end

function mpnet.WriteMedia( media )
	if media then
		net.WriteString( media:UniqueID() )
		net.WriteString( media:Url() )
		net.WriteTable( media._metadata or {} )
		net.WriteString( media:OwnerName() )
		net.WriteString( media:OwnerSteamID() )
	else
		net.WriteString( EOT )
	end
end

local StateBits = CeilPower2(NUM_MP_STATE) * 0.5

function mpnet.ReadPlayerState()
	return net.ReadUInt(StateBits)
end

function mpnet.WritePlayerState( state )
	net.WriteUInt(state, StateBits)
end

---
-- Threshold for determining if server and client system time differ.
--
local TIME_OFFSET_THRESHOLD = 2

---
-- Adjusts time returned from the server since RealTime will always differ.
--
local function correctTime( time, serverTime )
	local curTime = RealTime()
	local diffTime = os.difftime( serverTime, curTime )

	if math.abs(diffTime) > TIME_OFFSET_THRESHOLD then
		return time - diffTime
	else
		return time
	end
end

function mpnet.ReadTime()
	local time = net.ReadInt(32)
	local sync = net.ReadBit() == 1

	if sync then
		local serverTime = net.ReadInt(32)
		return correctTime(time, serverTime)
	else
		return time
	end
end

---
-- Writes the given epoch.
--
-- @param time Epoch.
-- @param sync Whether the time should be synced on the client (default: true).
--
function mpnet.WriteTime( time, sync )
	if sync == nil then sync = true end
	sync = tobool(sync)

	net.WriteInt( time, 32 )
	net.WriteBit( sync )

	if sync then
		-- We must send the current time in case either the server or the
		-- client's system clock is offset.
		net.WriteInt( RealTime(), 32 )
	end
end

---
-- Read a vote value or count.
--
function mpnet.ReadVote()
	return net.ReadInt(9)
end

---
-- Write a vote value or count.
--
function mpnet.WriteVote( value )
	net.WriteInt( value, 9 )
end

--PATH addons/media_player/lua/mediaplayer/sh_services.lua:
MediaPlayer.Services = {}

function MediaPlayer.RegisterService( service )

	local base

	if service.Base then
		base = MediaPlayer.Services[service.Base]
	elseif MediaPlayer.Services.base then
		base = MediaPlayer.Services.base
	end

	-- Inherit base service
	setmetatable( service, { __index = base } )

	-- Create base class for service
	baseclass.Set( "mp_service_" .. service.Id, service )

	-- Store service
	MediaPlayer.Services[ service.Id ] = service

	if MediaPlayer.DEBUG then
		print( "MediaPlayer.RegisterService", service.Name )
	end

end

function MediaPlayer.GetValidServiceNames( whitelist )
	local tbl = {}

	for _, service in pairs(MediaPlayer.Services) do
		if not rawget(service, "Abstract") then
			if whitelist then
				if table.HasValue( whitelist, service.Id ) then
					table.insert( tbl, service.Name )
				end
			else
				table.insert( tbl, service.Name )
			end
		end
	end

	return tbl
end

function MediaPlayer.GetSupportedServiceIDs()
	local tbl = {}

	for _, service in pairs(MediaPlayer.Services) do
		if not rawget(service, "Abstract") then
			table.insert( tbl, service.Id )
		end
	end

	return tbl
end

function MediaPlayer.ValidUrl( url )

	for id, service in pairs(MediaPlayer.Services) do
		if service:Match( url ) then
			return true
		end
	end

	return false

end

function MediaPlayer.GetMediaForUrl( url, webpageFallback )

	local service

	for id, s in pairs(MediaPlayer.Services) do
		if s:Match( url ) then
			service = s
			break
		end
	end

	if not service then
		if webpageFallback then
			service = MediaPlayer.Services.www
		else
			service = MediaPlayer.Services.base
		end
	end

	return service:New( url )

end

-- Load services
do
	local path = "services/"

	local fullpath = "mediaplayer/" .. path

	local services = {
		"base", -- MUST LOAD FIRST!

		-- Browser
		"browser", -- base
		"youtube",
		"googledrive",
		"twitch",
		"twitchstream",
		"vimeo",

		-- HTML Resources
		"resource", -- base
		"image",
		"html5_video",
		"webpage",

		-- IGModAudioChannel
		"audiofile",
		"shoutcast",
		"soundcloud"
	}

	for _, name in ipairs(services) do
		local clfile = path .. name .. "/cl_init.lua"
		local svfile = path .. name .. "/init.lua"
		local shfile = fullpath .. name .. ".lua"

		if file.Exists(shfile, "LUA") then
			clfile = shfile
			svfile = shfile
		end

		SERVICE = {}

		if SERVER then
			AddCSLuaFile(clfile)
			include(svfile)
		else
			include(clfile)
		end

		MediaPlayer.RegisterService( SERVICE )
		SERVICE = nil
	end
end

--PATH addons/media_player/lua/mediaplayer/services/image.lua:
SERVICE.Name 	= "Image"
SERVICE.Id 		= "img"
SERVICE.Base 	= "res"

SERVICE.FileExtensions = { 'png', 'jpg', 'jpeg', 'gif' }

if CLIENT then

	local EmbedHTML = [[
<div style="background-image: url(%s);
			background-repeat: no-repeat;
			background-size: contain;
			background-position: center center;
			width: 100%%;
			height: 100%%;">
</div>
]]

	function SERVICE:GetHTML()
		return EmbedHTML:format( self.url )
	end

end
--PATH addons/__main/lua/autorun/moxxie_cmankar.lua:
player_manager.AddValidModel( "Moxxie_Helluvaboss", 					"models/custom/cmankarthecat/helluvaboss/moxxie_pm.mdl" )
player_manager.AddValidHands( "Moxxie_Helluvaboss",                  "models/custom/cmankarthecat/helluvaboss/moxxie_arms.mdl", 0, "0" )
--PATH addons/____onyx_framework_2/lua/onyx/framework/libs/sh_netchunk.lua:
--[[
MIT License

Copyright (c) 2023 Aleksandrs Filipovskis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

if (netchunk) then return end

netchunk = netchunk or {}
netchunk.chunks = netchunk.chunks or {}
netchunk.registered = netchunk.registered or {}
-- netchunk.maxBytes = 32768
netchunk.maxBytes = 16384

local split do
    local len = string.len
    local sub = string.sub
    local maxBytes = netchunk.maxBytes

    function split(data)
        local length = len(data)
        local index = 1
        local last = 1
        local chunks = {}

        for i = 1, length do
            if (i - last + 1) > maxBytes then
                chunks[index] = sub(data, last, i)
                index = index + 1
                last = i + 1
            end
        end

        chunks[index] = sub(data, last, length)

        return chunks
    end
end

local function merge(chunks)
    local result = ''

    for i = 1, #chunks do
        result = result .. chunks[i]
    end

    return result
end

function netchunk.Register(name)
    if (SERVER) then
        util.AddNetworkString('netchunk[' .. name .. ']:Send')
    end

    netchunk.registered[name] = true
    netchunk.chunks[name] = {}
end

if (SERVER) then
    local function send(ply)
        if ply then
            net.Send(ply)
        else
            net.Broadcast()
        end
    end

    function netchunk.Send(ply, name, data)
        assert(netchunk.registered[name], 'Trying to send data during unregistered channel (`' .. name .. '`)')

        local encoded = pon.encode(data)
        local chunks = split(encoded)
        local count = #chunks

        for i = 1, count do
            local chunk = chunks[i]
            local length = #chunk

            net.Start('netchunk[' .. name .. ']:Send')
                net.WriteString(name)
                net.WriteUInt(length, 16)
                net.WriteData(chunks[i], length)
                net.WriteBool(i == count)
            send(ply)
        end
    end
else
    netchunk.callbacks = netchunk.callbacks or {}

    local ReadString = net.ReadString
    local ReadUInt = net.ReadUInt
    local ReadData = net.ReadData
    local ReadBool = net.ReadBool

    function netchunk.Callback(name, callback)
        assert(name)
        assert(callback)

        net.Receive('netchunk[' .. name .. ']:Send', function()
            local name = ReadString()
            local length = ReadUInt(16)
            local chunk = ReadData(length)
            local finished = ReadBool()

            local chunks = netchunk.chunks[name]

            chunks[#chunks + 1] = chunk

            if finished then
                local raw = merge(chunks)
                local amt = #chunks

                netchunk.chunks[name] = {}

                local data = pon.decode(raw)

                callback(data, #raw, amt)
            end
        end)
    end
end
--PATH addons/____onyx_framework_2/lua/onyx/ui/libs/thirdparty/cl_ui3d2d.lua:
if (ui3d2d) then return end

ui3d2d = ui3d2d or {}

do --Input handling
    local useBind = input.LookupBinding("+use", true)
    local attackBind = input.LookupBinding("+attack", true)

    do
        local lookupBinding = input.LookupBinding
        timer.Create("ui3d2d.lookupBindings", 5, 0, function() --Keep our use and attack bind keys up to date
            useBind = lookupBinding("+use", true)
            attackBind = lookupBinding("+attack", true)
        end)
    end

    do
        local getRenderTarget, cursorVisible = render.GetRenderTarget, vgui.CursorVisible
        local getKeyCode, isButtonDown = input.GetKeyCode, input.IsButtonDown

        local inputEnabled, isPressing, isPressed

        hook.Add("PreRender", "ui3d2d.inputHandler", function() --Check the input state before rendering UIs
            if getRenderTarget() then inputEnabled = false return end
            if cursorVisible() then inputEnabled = false return end

            local useKey = useBind and getKeyCode(useBind)
            local attackKey = attackBind and getKeyCode(attackBind)

            inputEnabled = true

            local wasPressing = isPressing
            isPressing = (useKey and isButtonDown(useKey)) or (attackKey and isButtonDown(attackKey))
            isPressed = not wasPressing and isPressing
        end)

        function ui3d2d.isPressing() --Returns true if an input is being held
            return inputEnabled and isPressing
        end

        function ui3d2d.isPressed() --Returns true if an input was pressed this frame
            return inputEnabled and isPressed
        end
    end
end

do --Rendering context creation and mouse position getters
    local localPlayer

    hook.Add("PreRender", "ui3d2d.getLocalPlayer", function() --Keep getting the local player until it's available
        localPlayer = LocalPlayer()
        if IsValid(localPlayer) then hook.Remove("PreRender", "ui3d2d.getLocalPlayer") end
    end)

    local traceLine = util.TraceLine

    local baseQuery = {filter = {}}

    local function isObstructed(eyePos, hitPos, ignoredEntity) --Check if the cursor trace is obstructed by another ent
        local query = baseQuery
        query.start = eyePos
        query.endpos = hitPos
        query.filter[1] = localPlayer
        query.filter[2] = ignoredEntity

        return traceLine(query).Hit
    end

    local mouseX, mouseY

    do
        local start3d2d = cam.Start3D2D
        local isCursorVisible, isHoveringWorld = vgui.CursorVisible, vgui.IsHoveringWorld
        local screenToVector, mousePos = gui.ScreenToVector, gui.MousePos
        local intersectRayWithPlane = util.IntersectRayWithPlane

        local isRendering

        function ui3d2d.startDraw(pos, angles, scale, ignoredEntity) --Starts a new 3d2d ui rendering context
            if isRendering then print("[ui3d2d] Attempted to draw a new 3d2d ui without ending the previous one.") return end

            local eyePos = localPlayer:EyePos()
            local eyePosToUi = pos - eyePos

            do --Only draw the UI if the player is in front of it
                local normal = angles:Up()
                local dot = eyePosToUi:Dot(normal)

                if dot >= 0 then return end
            end

            isRendering = true
            mouseX, mouseY = nil, nil

            start3d2d(pos, angles, scale)

            local cursorVisible, hoveringWorld = isCursorVisible(), isHoveringWorld()
            if not hoveringWorld and cursorVisible then return true end

            local eyeNormal
            do
                if cursorVisible and hoveringWorld then
                    eyeNormal = screenToVector(mousePos())
                else
                    eyeNormal = localPlayer:GetEyeTrace().Normal
                end
            end

            local hitPos = intersectRayWithPlane(eyePos, eyeNormal, pos, angles:Up())
            if not hitPos then return true end

            if isObstructed(eyePos, hitPos, ignoredEntity) then return true end

            do
                local diff = pos - hitPos
                mouseX = diff:Dot(-angles:Forward()) / scale
                mouseY = diff:Dot(-angles:Right()) / scale
            end

            return true
        end

        local end3d2d = cam.End3D2D

        function ui3d2d.endDraw() --Safely ends the 3d2d ui rendering context
            if not isRendering then print("[ui3d2d] Attempted to end a non-existant 3d2d ui rendering context.") return end
            isRendering = false
            end3d2d()
        end
    end

    function ui3d2d.getCursorPos() --Returns the current 3d2d cursor position
        return mouseX, mouseY
    end

    function ui3d2d.isHovering(x, y, w, h) --Returns whether the cursor is within a specified area
        local mx, my = mouseX, mouseY
        return mx and my and mx >= x and mx <= (x + w) and my >= y and my <= (y + h)
    end
end

hook.Run("ui3d2d.fullyLoaded")
--PATH addons/____onyx_framework_2/lua/onyx/ui/core/cl_draw_functions.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

18/11/2023

--]]

do
    for thickness = 1, 6 do
        onyx.spoly.Generate('onyx_circle_outline_' .. thickness, function(w, h)
            local scaledThickness = thickness * 32

            local x = w * .5
            local y = h * .5
            local r = h * .5
            local vertices = 64

            local circleInner = onyx.CalculateCircle(x, y, r - scaledThickness, vertices)
            local circleOuter = onyx.CalculateCircle(x, y, r, vertices)

            onyx.InverseMaskFn(function()
                surface.DrawPoly(circleInner)
            end, function()
                surface.DrawPoly(circleOuter)
            end)
        end)
    end
end

do
    onyx.spoly.Generate('onyx_circle', function(w, h)
        local x0, y0 = w * .5, h * .5
        local r = h * .5
        local vertexs = 64
        local circle = onyx.CalculateCircle(x0, y0, r, vertexs)

        surface.DrawPoly(circle)
    end)
end

--[[------------------------------
Draws a smooth outline for a circle
Available thickness: [1; 6]
--------------------------------]]
function onyx.DrawOutlinedCircle(x0, y0, r, thickness, color)
    local id = 'onyx_circle_outline_' .. thickness
    local d = r * 2

    onyx.spoly.DrawRotated(id, x0, y0, d, d, 0, color)
end

--[[------------------------------
Draws a smooth circle
--------------------------------]]
function onyx.DrawCircle(x0, y0, r, color)
    local x = x0 - r
    local y = y0 - r
    local d = r * 2

    if (color) then
        surface.SetDrawColor(color)
    end
    onyx.spoly.Draw('onyx_circle', x, y, d, d)
end
--PATH addons/____onyx_framework_2/lua/onyx/ui/elements/cl_scrollpanel_canvas.lua:
--[[

Author: tochonement
Email: tochonement@gmail.com

22.08.2021

--]]

local PANEL = {}

AccessorFunc(PANEL, 'm_iSpace', 'Space')

function PANEL:Init()
    self.container = self:Add('Panel')

    self:SetSpace(ScreenScale(2))
end

function PANEL:PerformLayout(w, h)
    self:UpdateSize()
end

function PANEL:GetPanels()
    return self.container:GetChildren()
end

function PANEL:CalculateTall()
    local panels = self:GetPanels()
    local count = #panels
    local size = 0

    for index, child in ipairs(panels) do
        if child:IsVisible() then
            local _, top, _, bottom = child:GetDockMargin()

            size = size + child:GetTall()
            size = size + top
            size = size + (index ~= count and bottom or 0)
        end
    end

    return size
end

function PANEL:UpdateSize()
    local w, h = self:GetWide(), self:CalculateTall()

    self.container:SetSize(w, h)

    self:Call('OnContainerTallUpdated', nil, self:GetTall(), h)
end

function PANEL:AddPanel(panel)
    panel:SetParent(self.container)
    panel:Dock(TOP)
    panel:DockMargin(0, 0, 0, self:GetSpace())

    local class = panel.ClassName or 'Panel'
    if (not class:find('onyx')) then
        onyx.gui.Extend(panel)
    end

    panel:InjectEventHandler('PerformLayout')
    panel:On('PerformLayout', function()
        self:UpdateSize()
    end)

    panel:Call('OnPanelAdded', nil, panel)
end

function PANEL:OnPanelAdded()
end

onyx.gui.Register('onyx.ScrollPanel.Canvas', PANEL)

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .66, .66, function(self)
--     self:MakePopup()

--     local list = self:Add('onyx.ScrollPanel')
--     list:Dock(FILL)

--     for i = 1, 1024 do
--         local button = list:Add('onyx.Button')
--         button:SetText('Button #' .. i)
--         button:SetTall(32)
--     end
-- end)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/core/cl_core.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

08/05/2023

--]]

local creditstore = onyx.creditstore

function creditstore:OpenStore()
    if (IsValid(self.frame)) then
        return
    end

    self.frame = vgui.Create('onyx.creditstore.Frame')
    self.frame:SetSize(ScrW() * .65, ScrH() * .65)
    self.frame:MakePopup()
    self.frame:Center()
end

net.Receive('onyx.creditstore:OpenStore', function(len, ply)
    creditstore:OpenStore()
end)

concommand.Add('onyx_store_open', function()
    creditstore:OpenStore()
end)

concommand.Add('onyx_store_close', function()
    if (IsValid(creditstore.frame)) then
        creditstore.frame:Remove()
    end
end)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/core/sh_integration.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

01/05/2023

--]]

local creditstore = onyx.creditstore

creditstore.integrations = creditstore.integrations or {}

function creditstore:RegisterIntegration(uniqueID, tblIntegration)
    self.integrations[uniqueID] = tblIntegration

    creditstore:Print('Registered a new integration: #', uniqueID)

    if (creditstore.gamemodeLoaded) then
        if (tblIntegration:Check()) then
            tblIntegration:Load()
        end
    end
end

onyx.WaitForGamemode('onyx.creditstore.Integrations', function()
    for uniqueID, tblIntegration in pairs(creditstore.integrations) do
        if (tblIntegration:Check()) then
            tblIntegration:Load()
        end
    end

    creditstore.gamemodeLoaded = true
end)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/core/admin/cl_admin.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/03/2023

--]]

function onyx.creditstore.OpenAdminSettings()
    local frame = vgui.Create('onyx.Frame')
    frame:SetSize(ScrW() * .66, ScrH() * .66)
    frame:Center()
    frame:MakePopup()
    frame:SetTitle('ADMIN PANEL')

    local p = onyx.ScaleTall(15)
    local content = frame:Add('Panel')
    content:Dock(FILL)
    content:DockPadding(p, p, p, p)

    local sidebar = frame:Add('onyx.Sidebar')
    sidebar:SetContainer(content)
    sidebar:SetWide(frame:GetWide() * .2)
    sidebar:Dock(LEFT)

    sidebar:AddTab({
        name = onyx.lang:Get('players_u'),
        desc = 'Edit players\' inventories',
        icon = 'https://i.imgur.com/LT0UQx1.png',
        class = 'onyx.creditstore.AdminPlayers'
    })

    CAMI.PlayerHasAccess(LocalPlayer(), 'onyx_creditstore_edit', function(bAllowed)
        if (bAllowed and IsValid(sidebar)) then
            sidebar:AddTab({
                name = onyx.lang:Get('items_u'),
                desc = 'Edit items',
                icon = 'https://i.imgur.com/eCOYBhL.png',
                class = 'onyx.creditstore.AdminItems'
            })
    
            sidebar:AddTab({
                name = onyx.lang:Get('settings_u'),
                desc = 'Configure the addon',
                icon = 'https://i.imgur.com/ECLKU9s.png',
                class = 'onyx.Configuration',
                onSelected = function(panel)
                    panel:LoadAddonSettings('creditstore')
                    panel:OpenCategories()
                end
            })
        end
    end)

    sidebar:AddTab({
        name = onyx.lang:Get('return_u'),
        desc = 'Return to store',
        icon = 'https://i.imgur.com/iTONhJq.png',
        onClick = function()
            frame:Remove()
            onyx.creditstore:OpenStore()
            return false
        end
    })

    sidebar:ChooseTab(1)

    return frame
end

function onyx.creditstore.OpenAdminPlayerInventory(steamid64)
    local frame = vgui.Create('onyx.Frame')
    frame:SetSize(ScrW() * .5, ScrH() * .75)
    frame:Center()
    frame:MakePopup()
    frame:SetTitle('ADMIN INVENTORY EDITOR')

    local content = frame:Add('onyx.creditstore.AdminPlayerInventory')
    content:Dock(FILL)
    content:Request(steamid64)

    return frame
end

--[[------------------------------
Networking
--------------------------------]]
net.Receive('onyx.creditstore:AdminRequestInventory', function()
    local balance = net.ReadUInt(32)
    local inventory = onyx.net.ReadTable()

    if (IsValid(onyx.AdminPlayerInventoryPanel)) then
        onyx.AdminPlayerInventoryPanel.inventory:LoadItems(inventory)
        onyx.AdminPlayerInventoryPanel:LoadBalance(balance)
    end
end)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/core/salary/sh_salary.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

08/05/2023

--]]

local creditstore = onyx.creditstore

creditstore:RegisterOption('salary_enabled', {
    title = 'Enabled',
    desc = 'Enable salary module',
    category = 'Salary',
    cami = 'onyx_creditstore_edit',
    type = 'bool',
    default = false
})

creditstore:RegisterOption('salary_rate', {
    title = 'Interval',
    desc = 'The interval in minutes between salaries',
    category = 'Salary',
    cami = 'onyx_creditstore_edit',
    type = 'int',
    default = 30,
    min = 1,
    max = 180
})

creditstore:RegisterOption('salary_amount', {
    title = 'Amount',
    desc = 'The amount of credits to give',
    category = 'Salary',
    cami = 'onyx_creditstore_edit',
    type = 'int',
    default = 5,
    min = 1,
    max = 300
})
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/ui/cl_admin_players.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/04/2023

--]]

local PANEL = {}

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorTertiary = onyx:Config('colors.tertiary')
local colorGray = onyx:Config('colors.gray')
local font0 = onyx.Font('Comfortaa Bold@18')
local font1 = onyx.Font('Comfortaa@16')

function PANEL:Init()
    self.toolbar = self:Add('Panel')
    self.toolbar:Dock(TOP)
    self.toolbar:SetTall(onyx.ScaleTall(35))
    self.toolbar:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    local padding = onyx.ScaleTall(5)
    self.toolbar.Paint = function(p, w, h)
        draw.RoundedBox(8, 0, 0, w, h, colorSecondary)
    end

    self.toolbar:DockPadding(padding, padding, padding, padding)

    self.search = self.toolbar:Add('onyx.TextEntry')
    self.search:SetPlaceholderText(onyx.lang:Get('searchNameSteamID'))
    self.search:SetPlaceholderIcon('https://i.imgur.com/Nk3IUJT.png', 'smooth mips')
    self.search:Dock(LEFT)
    self.search:SetWide(onyx.ScaleWide(200))
    self.search:SetUpdateOnType(true)
    self.search.OnValueChange = function(panel, value)
        value = onyx.utf8.lower(value)

        for _, item in ipairs(self.grid:GetItems()) do
            if (onyx.utf8.lower(item.playerName):find(value, nil, true) or item.playerSteamID:lower() == value) then
                item:SetVisible(true)
            else
                item:SetVisible(false)
            end
        end

        self.grid:InvalidateLayout(true)
    end

    self.list = self:Add('onyx.ScrollPanel')
    self.list:Dock(FILL)

    self.grid = self.list:Add('onyx.Grid')
    self.grid:Dock(TOP)
    self.grid:SetColumnCount(3)
    self.grid:SetSpace(onyx.ScaleTall(5))

    self:LoadPlayers()
end

function PANEL:LoadPlayers()
    local padding = onyx.ScaleTall(5)
    for _, ply in ipairs(player.GetAll()) do
        local name = ply:GetName()
        local sg = ply:GetUserGroup()
        local sgColor = colorGray
        if (sg ~= 'user') then
            sgColor = colorAccent
        end

        local button = self.grid:Add('onyx.Button') 
        button:SetText('')
        button:SetTall(onyx.ScaleTall(40))
        button:SetColorIdle(colorSecondary)
        button:SetColorHover(colorTertiary)
        button:AddClickEffect()
        button:AddHoverSound()
        button:Padding(padding)
        button:InjectEventHandler('Paint')
        button:On('Paint', function(panel, w, h)
            draw.SimpleText(name, font0, h + onyx.ScaleWide(5), h * .5, color_white, 0, 4)
            draw.SimpleText(sg, font1, h + onyx.ScaleWide(5), h * .5, sgColor, 0, 0)
        end)

        button.playerName = name
        button.playerSteamID = ply:SteamID()
        button.playerSteamID64 = ply:SteamID64()
        button.DoClick = function(panel)
            if (IsValid(ply)) then
                onyx.creditstore.OpenAdminPlayerInventory(panel.playerSteamID64)
            end
        end

        local container = button:Add('Panel')
        container:Dock(LEFT)
        container:SetWide(button:GetTall() - padding * 2)
        container.PerformLayout = function(panel, w, h)
            panel.mask = onyx.CalculateCircle(w * .5, h * .5, h * .5, 24)
        end
        container.Paint = function(panel, w, h)
            local mask = panel.mask
            local avatar = panel.avatar
            if (mask and avatar) then
                onyx.MaskFn(function()
                    onyx.DrawPoly(mask)
                end, function()
                    avatar:PaintManual()
                end)
            end
        end

        local avatar = container:Add('AvatarImage')
        avatar:Dock(FILL)
        avatar:SetPlayer(ply, 64)
        avatar:SetPaintedManually(true)
        container.avatar = avatar
    end
end

vgui.Register('onyx.creditstore.AdminPlayers', PANEL)
--PATH addons/____onyx_f4/lua/onyx/modules/f4/languages/cl_english.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/12/2023

--]]

local LANG = {}

-- TABS
LANG.f4_jobs_u = 'JOBS'
LANG.f4_jobs_desc = 'Choose your path'

LANG.f4_dashboard_u = 'DASHBOARD'
LANG.f4_dashboard_desc = 'General information'

LANG.f4_shop_u = 'SHOP'
LANG.f4_shop_desc = 'Purchase any goods'

LANG.f4_admin_u = 'ADMIN'
LANG.f4_admin_desc = 'Configure the addon'

LANG.f4_donate_u = 'DONATE'
LANG.f4_donate_desc = 'Support the server'

LANG.addon_settings_u = 'SETTINGS'
LANG.addon_settings_desc = 'Configure the addon'

LANG.addon_return_u = 'RETURN'
LANG.addon_return_desc = 'Return to the frame'

-- Other
LANG.f4_salary = 'Salary'
LANG.f4_price = 'Price'
LANG.f4_loading = 'Loading'
LANG.f4_purchases = 'Purchases'
LANG.f4_switches = 'Switches'
LANG.f4_unavailable = 'Unavailable'
LANG.f4_description_u = 'DESCRIPTION'
LANG.f4_weapons_u = 'WEAPONS'
LANG.f4_entities_u = 'ENTITIES'
LANG.f4_ammo_u = 'AMMO'
LANG.f4_food_u = 'FOOD'
LANG.f4_shipments_u = 'SHIPMENTS'
LANG.f4_become_u = 'BECOME'
LANG.f4_create_vote_u = 'CREATE VOTE'
LANG.f4_general_u = 'GENERAL'
LANG.f4_police_u = 'POLICE'
LANG.f4_mayor_u = 'MAYOR'
LANG.f4_confirm_u = 'CONFIRM'
LANG.f4_cancel_u = 'CANCEL'
LANG.f4_mostpopular_u = 'MOST POPULAR'
LANG.f4_chart_u = 'CHART'
LANG.f4_loading_u = 'LOADING'
LANG.f4_empty_u = 'EMPTY'
LANG.f4_favorite_u = 'FAVORITE'

LANG.f4_playersonline_u = 'PLAYERS ONLINE'
LANG.f4_totalmoney_u = 'TOTAL MONEY'
LANG.f4_staffonline_u = 'STAFF ONLINE'
LANG.f4_actions_u = 'ACTIONS'

LANG.f4_show_favorite = 'Show Favorites'

LANG.requires_level = 'Requires Level {level}'

-- Actions
LANG['f4_action_input_amount'] = 'Input the amount'
LANG['f4_action_input_text'] = 'Input the text'
LANG['f4_action_input_reason'] = 'Input the reason'
LANG['f4_action_choose_player'] = 'Choose a player'

LANG['f4_action_confirm_action'] = 'Confirm the action'
LANG['f4_action_drop_money'] = 'Drop Money'
LANG['f4_action_give_money'] = 'Give Money'
LANG['f4_action_change_name'] = 'Change Name'
LANG['f4_action_drop_weapon'] = 'Drop Weapon'
LANG['f4_action_sell_doors'] = 'Sell All Doors'

LANG['f4_action_warrant'] = 'Make Warrant'
LANG['f4_action_wanted'] = 'Make Wanted'

LANG['f4_toggle_lockdown'] = 'Toggle Lockdown'
LANG['f4_give_license'] = 'Give License'

-- Phrases
LANG['f4_search_text'] = 'Search by name...'

-- Settings
LANG['f4.option_url_desc'] = 'Input the URL (leave empty to disable)'

LANG['f4.discord_url.name'] = 'Discord'
LANG['f4.discord_url.desc'] = 'Join our Discord server'

LANG['f4.forum_url.name'] = 'Forum'
LANG['f4.forum_url.desc'] = 'Meet the community'

LANG['f4.steam_url.name'] = 'Steam'
LANG['f4.steam_url.desc'] = 'Join our Steam group'

LANG['f4.rules_url.name'] = 'Rules'
LANG['f4.rules_url.desc'] = 'Know the rules'

LANG['f4.donate_url.name'] = 'Donate'

LANG['f4.website_ingame.name'] = 'Browser'
LANG['f4.website_ingame.desc'] = 'Use in-game browser to open website URL'

LANG['f4.title.name'] = 'Title'
LANG['f4.title.desc'] = 'The title for the frame'

LANG['f4.hide_donate_tab.name'] = 'Hide Donate Tab'
LANG['f4.hide_donate_tab.desc'] = 'Hide the creditstore integration tab'

LANG['f4.edit_job_colors.name'] = 'Modify Job Colors'
LANG['f4.edit_job_colors.desc'] = 'Should job colors be displayed lighter'

LANG['f4.hide_admins.name'] = 'Hide Admins Section'
LANG['f4.hide_admins.desc'] = 'Hide the dashboard admin list section'

LANG['f4.admin_on_duty.name'] = 'Admin Job Enabled'
LANG['f4.admin_on_duty.desc'] = 'Display as an admin only a person with a certain job'

LANG['f4.admin_on_duty_job.name'] = 'Admin Job Name'
LANG['f4.admin_on_duty_job.desc'] = 'The admin\'s job name*'

LANG['f4.colored_items.name'] = 'Colorized Gradient'
LANG['f4.colored_items.desc'] = 'Enable slight gradient on items/jobs'

LANG['f4.item_columns.name'] = 'Columns'
LANG['f4.item_columns.desc'] = 'The amount of columns for Items'

LANG['f4.job_columns.name'] = 'Columns'
LANG['f4.job_columns.desc'] = 'The amount of columns for Jobs'

LANG['f4.model_3d.name'] = '3D Models'
LANG['f4.model_3d.desc'] = 'Enable realtime rendering for Item/Job icons'

LANG['f4.item_show_unavailable.name'] = 'Unavailable Items'
LANG['f4.item_show_unavailable.desc'] = 'Show items that failed customCheck'

LANG['f4.job_show_unavailable.name'] = 'Unavailable Jobs'
LANG['f4.job_show_unavailable.desc'] = 'Show jobs that failed customCheck'

LANG['f4.job_show_requirejob.name'] = 'Dependent Jobs'
LANG['f4.job_show_requirejob.desc'] = 'Show jobs that cannot be chosen due player\'s wrong job'

onyx.lang:AddPhrases('english', LANG)
--PATH addons/____onyx_f4/lua/onyx/modules/f4/languages/cl_spanish.lua:
--[[
 
Author: Goran
GmodStore Profile: https://www.gmodstore.com/users/Goran
 
05/01/2024
 
--]]
 
local LANG = {}
 
-- TABS
LANG.f4_jobs_u = 'TRABAJOS'
LANG.f4_jobs_desc = 'Elige tu camino'
 
LANG.f4_dashboard_u = 'TABLERO'
LANG.f4_dashboard_desc = 'Información general'
 
LANG.f4_shop_u = 'TIENDA'
LANG.f4_shop_desc = 'Compra bienes'
 
LANG.f4_admin_u = 'ADMIN'
LANG.f4_admin_desc = 'Configuración del addon'
 
LANG.f4_donate_u = 'DONAR'
LANG.f4_donate_desc = 'Colabora con el servidor'
 
LANG.addon_settings_u = 'AJUSTES'
LANG.addon_settings_desc = 'Configuración del addon'
 
LANG.addon_return_u = 'REGRESAR'
LANG.addon_return_desc = 'Regresar'
 
-- Other
LANG.f4_salary = 'Salario'
LANG.f4_price = 'Precio'
LANG.f4_loading = 'Cargando'
LANG.f4_purchases = 'Compras'
LANG.f4_switches = 'Interruptores'
LANG.f4_unavailable = 'No disponible'
LANG.f4_description_u = 'DESCRIPCIÓN'
LANG.f4_weapons_u = 'ARMAS'
LANG.f4_entities_u = 'ENTIDADES'
LANG.f4_ammo_u = 'MUNICIÓN'
LANG.f4_food_u = 'COMIDA'
LANG.f4_shipments_u = 'CARGAMENTOS'
LANG.f4_become_u = 'TOMAR'
LANG.f4_create_vote_u = 'CREAR VOTACIÓN'
LANG.f4_general_u = 'GENERAL'
LANG.f4_police_u = 'POLICÍA'
LANG.f4_mayor_u = 'ALCALDE'
LANG.f4_confirm_u = 'CONFIRMAR'
LANG.f4_cancel_u = 'CANCELAR'
LANG.f4_mostpopular_u = 'EL MÁS POPULAR'
LANG.f4_chart_u = 'TABLA'
LANG.f4_loading_u = 'CARGANDO'
LANG.f4_empty_u = 'VACÍO'
 
LANG.f4_playersonline_u = 'JUGADORES EN LÍNEA'
LANG.f4_totalmoney_u = 'DINERO TOTAL'
LANG.f4_staffonline_u = 'STAFF EN LÍNEA'
LANG.f4_actions_u = 'ACCIONES'
 
-- Actions
LANG['f4_action_input_amount'] = 'Ingresa la cantidad'
LANG['f4_action_input_text'] = 'Ingresa el texto'
LANG['f4_action_input_reason'] = 'Ingresa la razón'
LANG['f4_action_choose_player'] = 'Elige a un jugador'
 
LANG['f4_action_confirm_action'] = 'Confirma la acción'
LANG['f4_action_drop_money'] = 'Soltar Dinero'
LANG['f4_action_give_money'] = 'Dar Dinero'
LANG['f4_action_change_name'] = 'Cambiar Nombre'
LANG['f4_action_drop_weapon'] = 'Soltar Arma'
LANG['f4_action_sell_doors'] = 'Vender Todas Las Puertas'
 
LANG['f4_action_warrant'] = 'Establecer Orden De Allanamiento'
LANG['f4_action_wanted'] = 'Establecer Orden De Búsqueda'
 
LANG['f4_toggle_lockdown'] = 'Alternar toque de queda'
LANG['f4_give_license'] = 'Dar Licencia'
 
-- Phrases
LANG['f4_search_text'] = 'Busca por nombre...'
 
-- Settings
LANG['f4.option_url_desc'] = 'Ingresa la URL (deja vacío para desactivar)'
 
LANG['f4.discord_url.name'] = 'Discord'
LANG['f4.discord_url.desc'] = 'Únete a nuestro servidor de Discord'
 
LANG['f4.forum_url.name'] = 'Foro'
LANG['f4.forum_url.desc'] = 'Conoce a la comunidad'
 
LANG['f4.steam_url.name'] = 'Steam'
LANG['f4.steam_url.desc'] = 'Únete a nuestro grupo de Steam'
 
LANG['f4.rules_url.name'] = 'Reglas'
LANG['f4.rules_url.desc'] = 'Conoce las reglas'
 
LANG['f4.donate_url.name'] = 'Donar'
 
LANG['f4.website_ingame.name'] = 'Buscador'
LANG['f4.website_ingame.desc'] = 'Utilizar el buscador del juego para abrir la URL del sitio'
 
LANG['f4.title.name'] = 'Título'
LANG['f4.title.desc'] = 'El título del menú '
 
LANG['f4.hide_donate_tab.name'] = 'Ocultar ventana de Donaciones'
LANG['f4.hide_donate_tab.desc'] = 'Ocultar ventana de la integración de Creditstore'
 
LANG['f4.edit_job_colors.name'] = 'Modificar color de los trabajos'
LANG['f4.edit_job_colors.desc'] = 'Deberían los colores de los trabajos mostrarse más claros'
 
LANG['f4.hide_admins.name'] = 'Ocultar sección de administración'
LANG['f4.hide_admins.desc'] = 'Ocultar la sección de administración'
 
LANG['f4.admin_on_duty.name'] = 'Trabajo de Administrador habilitado'
LANG['f4.admin_on_duty.desc'] = 'Mostrar sólo a las personas con un trabajo en específico como admins.'
 
LANG['f4.admin_on_duty_job.name'] = 'Nombre del Trabajo de Administrador'
LANG['f4.admin_on_duty_job.desc'] = 'El nombre del Trabajo de Administrador*'
 
LANG['f4.colored_items.name'] = 'Degradado coloreado'
LANG['f4.colored_items.desc'] = 'Habilitar un ligero degradado en elementos/trabajos'
 
LANG['f4.item_columns.name'] = 'Columnas'
LANG['f4.item_columns.desc'] = 'La cantidad de columnas de objetos'
 
LANG['f4.job_columns.name'] = 'Columnas'
LANG['f4.job_columns.desc'] = 'La cantidad de columnas de trabajos'
 
LANG['f4.model_3d.name'] = 'Modelos 3D'
LANG['f4.model_3d.desc'] = 'Habilitar renderización en tiempo real de los íconos de Objetos/Trabajos'
 
LANG['f4.item_show_unavailable.name'] = 'Objetos No Disponibles'
LANG['f4.item_show_unavailable.desc'] = 'Mostrar objetos que no pasan el customCheck'
 
LANG['f4.job_show_unavailable.name'] = 'Trabajos No Disponibles'
LANG['f4.job_show_unavailable.desc'] = 'Mostrar trabajos que no pasan el customCheck'
 
LANG['f4.job_show_requirejob.name'] = 'Trabajos Dependientes'
LANG['f4.job_show_requirejob.desc'] = 'Mostrar trabajos que no pueden ser tomados cuando el jugador no tiene el trabajo adecuado'
 
onyx.lang:AddPhrases('spanish', LANG)
--PATH addons/____onyx_f4/lua/onyx/modules/f4/languages/cl_turkish.lua:
-- Discord: sethlimited

local LANG = {}

-- TABS
LANG.f4_jobs_u = 'MESLEKLER'
LANG.f4_jobs_desc = 'Yolunu seç'

LANG.f4_dashboard_u = 'GÖSTERGE PANELİ'
LANG.f4_dashboard_desc = 'Genel Bilgi'

LANG.f4_shop_u = 'MARKET'
LANG.f4_shop_desc = 'Ürün satın al'

LANG.f4_admin_u = 'YETKİLİ'
LANG.f4_admin_desc = 'Eklentiyi yapılandır'

LANG.f4_donate_u = 'BAĞIŞ'
LANG.f4_donate_desc = 'Sunucuyu destekle'

LANG.addon_settings_u = 'AYARLAR'
LANG.addon_settings_desc = 'Eklentiyi yapılandır'

LANG.addon_return_u = 'GERİ DÖN'
LANG.addon_return_desc = 'Panele geri dön'

-- Other
LANG.f4_salary = 'Maaş'
LANG.f4_price = 'Ücret'
LANG.f4_loading = 'Yükleniyor'
LANG.f4_purchases = 'Satın alımlar'
LANG.f4_switches = 'Geçişler'
LANG.f4_unavailable = 'Kullanım dışı'
LANG.f4_description_u = 'AÇIKLAMA'
LANG.f4_weapons_u = 'SİLAHLAR'
LANG.f4_entities_u = 'VARLIKLAR'
LANG.f4_ammo_u = 'MERMİ'
LANG.f4_food_u = 'YEMEK'
LANG.f4_shipments_u = 'SEVKİYATLAR'
LANG.f4_become_u = 'MESLEĞE GEÇ'
LANG.f4_create_vote_u = 'OYLAMA BAŞLAT'
LANG.f4_general_u = 'GENEL'
LANG.f4_police_u = 'POLİS'
LANG.f4_mayor_u = 'BAŞKAN'
LANG.f4_confirm_u = 'ONAYLA'
LANG.f4_cancel_u = 'İPTAL ET'
LANG.f4_mostpopular_u = 'EN POPÜLER'
LANG.f4_chart_u = 'GRAFİK'
LANG.f4_loading_u = 'YÜKLENİYOR'
LANG.f4_empty_u = 'BOŞ'

LANG.f4_playersonline_u = 'AKTİF OYUNCULAR'
LANG.f4_totalmoney_u = 'TOPLAM PARA'
LANG.f4_staffonline_u = 'AKTİF YETKİLİLER'
LANG.f4_actions_u = 'EYLEMLER'

-- Actions
LANG['f4_action_input_amount'] = 'Tutar girin'
LANG['f4_action_input_text'] = 'Metin girin'
LANG['f4_action_input_reason'] = 'Sebep girin'
LANG['f4_action_choose_player'] = 'Oyuncu seçin'

LANG['f4_action_confirm_action'] = 'Eylemi onayla'
LANG['f4_action_drop_money'] = 'Para bırak'
LANG['f4_action_give_money'] = 'Para ver'
LANG['f4_action_change_name'] = 'İsim değiştir'
LANG['f4_action_drop_weapon'] = 'Silah bırak'
LANG['f4_action_sell_doors'] = 'Tüm kapıları sat'

LANG['f4_action_warrant'] = 'Baskın emri çıkart'
LANG['f4_action_wanted'] = 'Aranma oluştur'

LANG['f4_toggle_lockdown'] = 'Lockdown oluştur'
LANG['f4_give_license'] = 'Lisans ver'

-- Phrases
LANG['f4_search_text'] = 'İsme göre ara...'

-- Settings
LANG['f4.option_url_desc'] = 'URL girin (iptal için boş bırakın)'

LANG['f4.discord_url.name'] = 'Discord'
LANG['f4.discord_url.desc'] = 'Discord sunucumuza katıl'

LANG['f4.forum_url.name'] = 'Forum'
LANG['f4.forum_url.desc'] = 'Toplulukla tanışın'

LANG['f4.steam_url.name'] = 'Steam'
LANG['f4.steam_url.desc'] = 'Steam grubumuza katıl'

LANG['f4.rules_url.name'] = 'Kurallar'
LANG['f4.rules_url.desc'] = 'Kuralları bil'

LANG['f4.donate_url.name'] = 'Bağış'

LANG['f4.website_ingame.name'] = 'Tarayıcı'
LANG['f4.website_ingame.desc'] = 'URL açmak için oyun içi tarayıcısını kullan'

LANG['f4.title.name'] = 'Başlık'
LANG['f4.title.desc'] = 'Çerçeve için başlık'

LANG['f4.hide_donate_tab.name'] = 'Bağış sekmesini gizle'
LANG['f4.hide_donate_tab.desc'] = 'Kredi market entegrasyon sekmesini gizle'

LANG['f4.edit_job_colors.name'] = 'Meslek renklerini değiştir'
LANG['f4.edit_job_colors.desc'] = 'Meslek renkleri daha açık mı gösterilmeli'

LANG['f4.hide_admins.name'] = 'Yetkili bölümünü gizle'
LANG['f4.hide_admins.desc'] = 'Paneldeki yetkili bölümünü gizle'

LANG['f4.admin_on_duty.name'] = 'Yetkili mesleği etkin'
LANG['f4.admin_on_duty.desc'] = 'Yalnızca belirli meslekteki kişileri yetkili olarak göster'

LANG['f4.admin_on_duty_job.name'] = 'Yetkili meslek ismi'
LANG['f4.admin_on_duty_job.desc'] = 'Yetkilinin meslek ismi*'

LANG['f4.colored_items.name'] = 'Renklendirilmiş Gradyan'
LANG['f4.colored_items.desc'] = 'Mesleklerde/öğelerde hafif gradyanı etkinleştir'

LANG['f4.item_columns.name'] = 'Sütunlar'
LANG['f4.item_columns.desc'] = 'Öğeler için sütun miktarı'

LANG['f4.job_columns.name'] = 'Sütunlar'
LANG['f4.job_columns.desc'] = 'Meslekler için sütun miktarı'

LANG['f4.model_3d.name'] = '3D Modeller'
LANG['f4.model_3d.desc'] = 'Meslek/öğe simgeleri için gerçek zamanlı oluşturmayı etkinleştir'

LANG['f4.item_show_unavailable.name'] = 'Kullanılamayan öğeler'
LANG['f4.item_show_unavailable.desc'] = 'Kontrolde(customCheck) başarısız olan öğeleri göster'

LANG['f4.job_show_unavailable.name'] = 'Kullanılamayan meslekler'
LANG['f4.job_show_unavailable.desc'] = 'Kontrolde(customCheck) başarısız olan meslekleri göster'

LANG['f4.job_show_requirejob.name'] = 'Şartlı meslekler'
LANG['f4.job_show_requirejob.desc'] = 'Oyuncunun yanlış mesleği sebebi ile seçilemeyen meslekleri göster'

onyx.lang:AddPhrases('turkish', LANG)

--PATH addons/____onyx_f4/lua/onyx/modules/f4/core/cl_core.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

25/12/2023

--]]

onyx.f4.tabs = onyx.f4.tabs or {}
onyx.f4.actions = onyx.f4.actions or {}
onyx.f4.ranks = onyx.f4.ranks or {}

onyx.wimg.Register('favorite_fill', 'https://i.imgur.com/wviPFMQ.png')
onyx.wimg.Register('favorite_outline', 'https://i.imgur.com/FCXcBsu.png')

function onyx.f4:RegisterTab(id, data)
    onyx.AssertType(id, 'string', 'RegisterTab', 1)
    onyx.AssertType(data, 'table', 'RegisterTab', 2)

    data.id = id
    data.order = data.order or 99
    self.tabs[id] = data
end

function onyx.f4:DefineRank(id, data)
    onyx.AssertType(id, 'string', 'DefineRank', 1)
    onyx.AssertType(data, 'table', 'DefineRank', 2)
    assert(isstring(data.name), 'missing <name> field in data for `DefineRank`')

    data.id = id
    self.ranks[id] = data
end

function onyx.f4:RegisterAction(data)
    onyx.AssertType(data, 'table', 'RegisterAction', 1)

    table.insert(self.actions, data)
end

function onyx.f4.IsAdmin(ply)
    local jobOnly = onyx.f4:GetOptionValue('admin_on_duty')
    local jobName = onyx.f4:GetOptionValue('admin_on_duty_job')
    if (jobOnly) then
        local userGroup = ply:GetUserGroup()
        local jobTable = rp.Team[ply:Team()]
        if (jobTable and userGroup ~= 'user' and jobTable.name == jobName) then
            return true
        else
            return false
        end
    else
        return (ply:IsAdmin() or onyx.f4.ranks[ply:GetUserGroup()])
    end
end

function onyx.f4:GetSortedTabs()
    local sorted = {}

    for id, tab in pairs(onyx.f4.tabs) do
        table.insert(sorted, tab)
    end

    table.sort(sorted, function(a, b)
        return a.order < b.order
    end)

    return sorted
end

function onyx.f4.ConvertJobColor(color)
    local bEnabled = onyx.f4:GetOptionValue('edit_job_colors')
    if (bEnabled) then
        local h, s, v = ColorToHSV(color)
        return onyx.ColorEditHSV(color, nil, s - .2, v + .2)
    else
        return color
    end
end

function onyx.f4.OpenFrame()
    local frame = vgui.Create('onyx.f4.Frame')
    frame:SetSize(ScrW() * .65, ScrH() * .77)
    frame:Center()
    frame:MakePopup()

    return frame
end

function onyx.f4.OpenAdminSettings()
    local frame = vgui.Create('onyx.Frame')
    frame:SetSize(ScrW() * .66, ScrH() * .66)
    frame:Center()
    frame:MakePopup()
    frame:SetTitle('ONYX F4 (ADMIN)')

    local p = onyx.ScaleTall(15)
    local content = frame:Add('Panel')
    content:Dock(FILL)
    content:DockPadding(p, p, p, p)

    local sidebar = frame:Add('onyx.Sidebar')
    sidebar:SetContainer(content)
    sidebar:SetWide(frame:GetWide() * .2)
    sidebar:Dock(LEFT)

    sidebar:AddTab({
        name = onyx.lang:Get('addon_settings_u'),
        desc = onyx.lang:Get('addon_settings_desc'),
        icon = 'https://i.imgur.com/ECLKU9s.png',
        class = 'onyx.Configuration',
        onSelected = function(panel)
            panel:LoadAddonSettings('f4')
            panel:OpenCategories()
        end
    })

    sidebar:AddTab({
        name = onyx.lang:Get('addon_return_u'),
        desc = onyx.lang:Get('addon_return_desc'),
        icon = 'https://i.imgur.com/gCI6kX5.png',
        onClick = function()
            onyx.f4.OpenFrame()
            frame:Remove()
            return false
        end
    })

    sidebar:ChooseTab(1)

    return frame
end

concommand.Add('F4', function()
    if (not IsValid(onyx.f4.frame)) then
        onyx.f4.OpenFrame()
    end
end)

hook.Add('ShowSpare2', 'onyx.f4', function(ply)
    if (not IsValid(onyx.f4.frame)) then
        onyx.f4.OpenFrame()
    end
    return true
end)
--PATH addons/____onyx_f4/lua/onyx/modules/f4/core/cl_favorites.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

12/01/2024

--]]

onyx.f4.favorites = onyx.f4.favorites or {}

file.CreateDir('onyx_f4_favorites')

local function getFileName()
    local ip = game.GetIPAddress()
    return string.Explode(':', ip:gsub('%.', '_'))[1]
end

local function saveFavorites()
    local name = getFileName()

    file.Write('onyx_f4_favorites/' .. name .. '.json', util.TableToJSON(onyx.f4.favorites))
end

local function loadFavorites()
    local name = getFileName()
    local content = file.Read('onyx_f4_favorites/' .. name .. '.json', 'DATA')
    if (content) then
        local success, data = pcall(util.JSONToTable, content)
        if (success) then
            onyx.f4.favorites = data
        else
            onyx.f4:PrintError('Failed to load favorites.')
            print(data)
        end
    end
end
hook.Add('InitPostEntity', 'onyx.f4.LoadFavorites', loadFavorites)

function onyx.f4:SetFavorite(itemIdentifier, bState)
    self.favorites[itemIdentifier] = bState
    saveFavorites()
end

function onyx.f4:IsFavorite(itemIdentifier)
    return self.favorites[itemIdentifier]
end

function onyx.f4:FetchFavoriteObjects(itemType)
    local client = LocalPlayer()
    local clientTeam = client:Team()
    local showUnavailable = onyx.f4:GetOptionValue('job_show_unavailable')
    local showWrong = onyx.f4:GetOptionValue('job_show_requirejob')
    local result = {}
    local categories = {}

    if itemType == 'jobs' then
        categories = rp.Team
    elseif itemType == 'ammo' then
        categories = rp.Ammo
    elseif itemType == 'weapons' then
        categories = rp.Weapons
    else
        categories = rp.Entites
    end

    for r, u in pairs(categories) do
        if u.Desc and (itemType == 'naboi' and u.Desc ~= 'Набої' or itemType ~= 'naboi' and u.Desc == 'Набої') then continue end
        local canSee = isfunction(u.canSee) and not u.canSee(client)
        if canSee then continue end
        local id = (u.ENT or u.Command or u.Entity or u.name)
        local customCheck = u.customCheck
        local allowed = u.allowed
        local reason

        if id ~= 'mayor' then
            if (customCheck and not customCheck(client)) then
                if (showUnavailable) then
                    reason = onyx.lang:Get('f4_unavailable')
                else
                    continue
                end
            end
        end

        if (allowed and not allowed[clientTeam]) then
            continue
        end

        if (self:IsFavorite(id)) then
            table.insert(result, {
                job = u,
                item = u,
                reason = reason
            })
        end
    end

    return result
end
--PATH addons/____onyx_hud/lua/onyx/modules/hud/languages/cl_ukrainian.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/09/2024

--]]

local LANG = {}

--[[
    .............
    General Words
]]--

LANG[ 'hud_status_wanted' ] = 'В розшуку'
LANG[ 'hud_status_speaking' ] = 'Говорить'
LANG[ 'hud_status_typing' ] = 'Друкує'
LANG[ 'props' ] = 'Пропи'
LANG[ 'close' ] = 'Закрити'
LANG[ 'alert' ] = 'Оповіщення'
LANG[ 'message' ] = 'Повідомлення'
LANG[ 'unknown' ] = 'Невідомо'
LANG[ 'accept' ] = 'Прийняти'
LANG[ 'deny' ] = 'Відхилити'
LANG[ 'none' ] = 'Ні'
LANG[ 'add' ] = 'Додати'
LANG[ 'remove' ] = 'Видалити'
LANG[ 'jobs' ] = 'Роботи'
LANG[ 'door' ] = 'Двері'
LANG[ 'vehicle' ] = 'Транспорт'
LANG[ 'door_groups' ] = 'Групи дверей'
LANG[ 'display' ] = 'Відображення'
LANG[ 'general' ] = 'Загальні'
LANG[ 'speedometer' ] = 'Спідометр'
LANG[ 'fuel' ] = 'Паливо'
LANG[ 'vote' ] = 'Голосувати'
LANG[ 'question' ] = 'Питання'

--[[
    .......
    Timeout
]]--

LANG[ 'timeout_title' ] = 'З\'ЄДНАННЯ ВТРАЧЕНО'
LANG[ 'timeout_info' ] = 'Сервер зараз недоступний, просимо вибачення'
LANG[ 'timeout_status' ] = 'Перепідключення через %d секунд'

--[[
    ......
    Themes
]]--

LANG[ 'hud.theme.default.name' ] = 'За замовчуванням'
LANG[ 'hud.theme.forest.name' ] = 'Ліс'
LANG[ 'hud.theme.violet_night.name' ] = 'Фіолетова ніч'
LANG[ 'hud.theme.rustic_ember.name' ] = 'Вугілля, що тліє'
LANG[ 'hud.theme.green_apple.name' ] = 'Зелене яблуко'
LANG[ 'hud.theme.lavender.name' ] = 'Лаванда'
LANG[ 'hud.theme.elegance.name' ] = 'Елегантність'
LANG[ 'hud.theme.mint_light.name' ] = 'М\'ята'
LANG[ 'hud.theme.gray.name' ] = 'Сірий'
LANG[ 'hud.theme.rose_garden.name' ] = 'Рожевий сад'
LANG[ 'hud.theme.ocean_wave.name' ] = 'Океанська хвиля'
LANG[ 'hud.theme.sky_blue.name' ] = 'Небесно-блакитний'
LANG[ 'hud.theme.golden_dawn.name' ] = 'Золотий світанок'

--[[
    ....
    Help
    - Повна фраза: "Введіть <command> для відкриття налаштувань"
]]

LANG[ 'hud_help_type' ] = 'Введіть'
LANG[ 'hud_help_to' ] = 'для відкриття налаштувань'

--[[
    .............
    3D2D Doors
]]--

LANG[ 'door_purchase' ] = 'Придбати {object}'
LANG[ 'door_sell' ] = 'Продати {object}'
LANG[ 'door_addowner' ] = 'Додати власника'
LANG[ 'door_rmowner' ] = 'Видалити власника'
LANG[ 'door_rmowner_help' ] = 'Виберіть гравця, щоб видалити'
LANG[ 'door_addowner_help' ] = 'Виберіть гравця, щоб додати'
LANG[ 'door_title' ] = 'Встановити назву'
LANG[ 'door_title_help' ] = 'Яку назву ви хочете встановити?'
LANG[ 'door_admin_disallow' ] = 'Заборонити володіння'
LANG[ 'door_admin_allow' ] = 'Дозволити володіння'
LANG[ 'door_admin_edit' ] = 'Редагувати доступ'
LANG[ 'door_owned' ] = 'Приватна власність'
LANG[ 'door_unowned' ] = 'Продається'

LANG[ 'hud_door_help' ] = 'Натисніть {bind}, щоб купити за {price}'
LANG[ 'hud_door_owner' ] = 'Власник: {name}'
LANG[ 'hud_door_allowed' ] = 'Допущено до володіння'
LANG[ 'hud_door_coowners' ] = 'Співвласники'
LANG[ 'hud_and_more' ] = 'та інші...'

--[[
    .........
    Верхній регістр
]]--

LANG[ 'reconnect_u' ] = 'ПЕРЕПІДКЛЮЧИТИСЯ'
LANG[ 'disconnect_u' ] = 'ПОКИНУТИ СЕРВЕР'
LANG[ 'settings_u' ] = 'НАЛАШТУВАННЯ'
LANG[ 'configuration_u' ] = 'КОНФІГУРАЦІЯ'
LANG[ 'introduction_u' ] = 'ВСТУП'

--[[
    .........
    Нижній регістр
]]--

LANG[ 'seconds_l' ] = 'секунди'
LANG[ 'minutes_l' ] = 'хвилини'

--[[
    .............
    Конфігурація
]]--

LANG[ 'hud.timeout.name' ] = 'Тривалість  таймауту'
LANG[ 'hud.timeout.desc' ] = 'Скільки секунд до автом. перепідключення'

LANG[ 'hud.alert_queue.name' ] = 'Черга оповіщень'
LANG[ 'hud.alert_queue.desc' ] = 'Чи слід розміщувати оповіщення в чергу'

LANG[ 'hud.props_counter.name' ] = 'Лічильник пропов'
LANG[ 'hud.props_counter.desc' ] = 'Відображати лічильник пропів'

LANG[ 'hud.main_avatar_mode.name' ] = 'Тип головного аватара'
LANG[ 'hud.main_avatar_mode.desc' ] = 'Виберіть тип'

LANG[ 'hud.voice_avatar_mode.name' ] = 'Тип голосового аватара'
LANG[ 'hud.voice_avatar_mode.desc' ] = 'Виберіть тип'

LANG[ 'hud.hud_bar_type.name' ] = 'Тип смуги індикатора'
LANG[ 'hud.hud_bar_type.desc' ] = 'Виберіть тип'

LANG[ 'hud.restrict_themes.name' ] = 'Обмеження тем'
LANG[ 'hud.restrict_themes.desc' ] = 'Заборонити гравцям вибирати теми'

LANG[ 'hud.speedometer_mph.name' ] = 'Використовувати милі'
LANG[ 'hud.speedometer_mph.desc' ] = 'Переключити одиниці на милі на годину'

LANG[ 'hud.speedometer_max_speed.name' ] = 'Максимальна швидкість'
LANG[ 'hud.speedometer_max_speed.desc' ] = 'Максимальна швидкість для спідометра'

LANG[ 'hud.wpnsel_sounds.name' ] = 'Звуки перемикання зброї'
LANG[ 'hud.wpnsel_sounds.desc' ] = 'Увімкнути UI звуки перемикання зброї'

LANG[ 'hud_should_draw' ] = 'Відображати елемент'
LANG[ 'hud.main.name' ] = 'Основний HUD'
LANG[ 'hud.ammo.name' ] = 'Боєприпаси'
LANG[ 'hud.agenda.name' ] = 'Порядок денний'
LANG[ 'hud.alerts.name' ] = 'Оповіщення'
LANG[ 'hud.pickup_history.name' ] = 'Історія підбору'
LANG[ 'hud.voice.name' ] = 'Голосові панелі'
LANG[ 'hud.overhead_health.name' ] = '3D2D Здоров\'я над головою'
LANG[ 'hud.overhead_armor.name' ] = '3D2D Броня над головою'
LANG[ 'hud.vehicle.name' ] = 'HUD Транспорту'
LANG[ 'hud.notifications.name' ] = 'Уведомления'

--[[
    ........
    Налаштування
]]--

LANG[ 'hud.theme.name' ] = 'Тема'
LANG[ 'hud.theme.desc' ] = 'Виберіть тему HUD'

LANG[ 'hud.scale.name' ] = 'Масштаб'
LANG[ 'hud.scale.desc' ] = 'Відрегулюйте масштаб HUD'

LANG[ 'hud.roundness.name' ] = 'заокруглення'
LANG[ 'hud.roundness.desc' ] = 'Налаштування заокруглення HUD'

LANG[ 'hud.margin.name' ] = 'Відступ'
LANG[ 'hud.margin.desc' ] = 'Відстань між HUD та краями екрану'

LANG[ 'hud.icons_3d.name' ] = '3D моделі'
LANG[ 'hud.icons_3d.desc' ] = 'Відображати іконки моделей в 3D'

LANG[ 'hud.compact.name' ] = 'Компактний режим'
LANG[ 'hud.compact.desc' ] = 'Увімкнути компактний режим'

LANG[ 'hud.speedometer_blur.name' ] = 'Розмиття спідометра'
LANG[ 'hud.speedometer_blur.desc' ] = 'Увімкнути розмиття для спідометра'

LANG[ 'hud.3d2d_max_details.name' ] = 'Макс. деталі 3D2D'
LANG[ 'hud.3d2d_max_details.desc' ] = 'Макс. кількість деталей, що відображаються'

--[[
    ......
    Status
]]--

LANG[ 'hud_lockdown' ] = 'КОМ. ГОДИНА'
LANG[ 'hud_lockdown_help' ] = 'Поверніться додому!'

LANG[ 'hud_wanted' ] = 'В РОЗШУКУ'
LANG[ 'hud_wanted_help' ] = 'Причина: {reason}'

LANG[ 'hud_arrested' ] = 'ЗААРЕШТОВАНИЙ'
LANG[ 'hud_arrested_help' ] = 'Звільнення через {time}'
LANG[ 'hud_arrested_reason' ] = 'Причина ув\'язнення: {reason}'

onyx.lang:AddPhrases( 'ukrainian', LANG )
--PATH addons/____onyx_hud/lua/onyx/modules/hud/cfg/cl_level_systems.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

21/08/2024

--]]

onyx.hud.RegisterLevelSystem( 'vrodankis', {
    getLevel = function( ply )
        return ( ply:getDarkRPVar( 'level' ) or 1 )
    end,
    getXP = function( ply )
        return ( ply:getDarkRPVar( 'xp' ) or 0 )
    end,
    getMaxXP = function( ply )
        -- omg...
        -- this is from Vrondakis, there is no util func
        local level = ( ply:getDarkRPVar( 'level' ) or 1 )
        local maxXP = ( ( ( 10 + ( ( level * ( level + 1 ) * 90 ) ) ) ) * LevelSystemConfiguration.XPMult )
        return maxXP
    end,
    customCheck = function()
        return ( LevelSystemConfiguration ~= nil )
    end,
    onDetected = function()
        hook.Remove( 'HUDPaint', 'manolis:MVLevels:HUDPaintA' )
    end
} )

onyx.hud.RegisterLevelSystem( 'glorified', {
    getLevel = function( ply )
        return GlorifiedLeveling.GetPlayerLevel( ply )
    end,
    getXP = function( ply )
        return GlorifiedLeveling.GetPlayerXP( ply )
    end,
    getMaxXP = function( ply )
        return GlorifiedLeveling.GetPlayerMaxXP( ply )
    end,
    customCheck = function()
        return ( GlorifiedLeveling ~= nil )
    end,
    onDetected = function()
        hook.Remove( 'HUDPaint', 'GlorifiedLeveling.HUD.HUDPaint' )
    end
} )
--PATH addons/____onyx_hud/lua/onyx/modules/hud/elements/cl_ammo.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/07/2024

--]]

local COLOR_OUTLINE = onyx:Config( 'colors.primary' )
local COLOR_LOW = Color( 255, 98, 98)

local WIMG_SPEC_AMMO = onyx.wimg.Simple( 'https://i.imgur.com/CHWwWOq.png', 'smooth mips' )

local BUILD_WEAPONS = {
    [ 'weapon_physgun' ] = true,
    [ 'gmod_tool' ] = true,
}

local lastWeapon = NULL
local lerpClip1

local function drawAmmoHUD( client, scrW, scrH, weapon )
    local primaryAmmoType = weapon:GetPrimaryAmmoType()
    if ( primaryAmmoType < 0 ) then return end

    if ( lastWeapon ~= weapon ) then
        lastWeapon = weapon
        lerpClip1 = nil
    end

    local primaryAmmoCount = client:GetAmmoCount( primaryAmmoType )
    local primaryClip = weapon:Clip1()

    local secondaryAmmoType = weapon:GetSecondaryAmmoType()
    local hasSecondaryAmmo = secondaryAmmoType > 0
    local secondaryClip = weapon:Clip2()
    local secondaryAmmoCount = client:GetAmmoCount( secondaryAmmoType )
    
    local hideAmmoCount = false

    -- For grenades and etc.
    if ( primaryClip == -1 ) then 
        primaryClip = primaryAmmoCount
        hideAmmoCount = true
    end

    local lowAmmoStartRange = math.Round( weapon:GetMaxClip1() / 3 )
    local lowAmmoFraction = lowAmmoStartRange > 0 and math.min( 1, primaryClip / lowAmmoStartRange ) or 1
    if ( primaryClip == 0 ) then lowAmmoFraction = 0 end

    lerpClip1 = Lerp( FrameTime() * 16, lerpClip1 or primaryClip, primaryClip )
    
    -- Grab text size
    local textClip = math.Round( lerpClip1 )
    local textRemaining = hideAmmoCount and '' or ( ' / ' .. primaryAmmoCount )
    
    surface.SetFont( onyx.hud.fonts.AmmoClip )
    local textW1, textH1 = surface.GetTextSize( textClip )

    surface.SetFont( onyx.hud.fonts.AmmoRemaining )
    local textW2, textH2 = surface.GetTextSize( textRemaining )
    local totalW = textW1 + textW2
    
    -- Calculate positions and sizes
    local space = onyx.hud.GetScreenPadding()
    local padding = onyx.hud.ScaleTall( 20 )
    local w = totalW + padding * 2
    local h = onyx.hud.ScaleTall( 50 )

    local x = scrW - w - space
    local y = scrH - h - space

    local colorTextPrimary = onyx.hud:GetColor( 'textPrimary' )
    local colorTextSecondary = onyx.hud:GetColor( 'textSecondary' )

    -- Draw secondary ammo
    if ( hasSecondaryAmmo ) then
        local iconSize = h * .35
        surface.SetFont( onyx.hud.fonts.AmmoRemaining )
        local secAmmoTextW, secAmmoTextH = surface.GetTextSize( secondaryAmmoCount )
        local secAmmoTextSpace = onyx.hud.ScaleTall( 2 )
        local secAmmoTotalW = secAmmoTextW + secAmmoTextSpace + iconSize

        local secAmmoBlockWidth = secAmmoTotalW + padding * 1
        x = x - secAmmoBlockWidth

        local secAmmoStartX = x + w + secAmmoBlockWidth * .5 - secAmmoTotalW * .5
        local secAmmoColor = secondaryAmmoCount == 0 and colorTextSecondary or colorTextPrimary

        onyx.hud.DrawRoundedBoxEx( x + w, y, secAmmoBlockWidth, h, onyx.hud:GetColor( 'secondary' ), false, true, false, true )

        WIMG_SPEC_AMMO:Draw( secAmmoStartX, y + h * .5 - iconSize * .5, iconSize, iconSize, colorTextSecondary )
        onyx.hud.DrawCheapText( secondaryAmmoCount, onyx.hud.fonts.AmmoRemaining, secAmmoStartX + secAmmoTextSpace + iconSize, y + h * .5 - secAmmoTextH * .5, secAmmoColor )
    end

    -- Draw primary ammo
    local x0, y0 = x + w * .5, y + h * .5
    local textStartX = x0 - totalW * .5
    local colorClip = onyx.LerpColor( lowAmmoFraction, COLOR_LOW, colorTextPrimary )

    onyx.hud.DrawRoundedBoxEx( x, y, w, h, onyx.hud:GetColor( 'primary' ), true, not hasSecondaryAmmo, true, not hasSecondaryAmmo )
    onyx.hud.DrawCheapText( textClip, onyx.hud.fonts.AmmoClip, textStartX, y0 - textH1 * .5, colorClip, 0, 1 )
    onyx.hud.DrawCheapText( textRemaining, onyx.hud.fonts.AmmoRemaining, textStartX + textW1, y0 - textH2 * .5, colorTextSecondary, 0, 1 )

    -- Draw weapon name
    local name = weapon:GetPrintName()
    draw.SimpleTextOutlined( name, onyx.hud.fonts.SmallBold, scrW - space, y - onyx.hud.ScaleTall( 5 ), color_white, 2, 4, 1, COLOR_OUTLINE )
end

local function drawPropsHUD( client, scrW, scrH )
    if true then return end
    local curProps = client:GetCount( 'props' )
    local maxProps = onyx.hud.GetMaxProps( client)
    if ( maxProps < 1 ) then
        maxProps = '∞'
    end
    
    local clipText = curProps
    local maxText = ' / ' .. maxProps

    surface.SetFont( onyx.hud.fonts.AmmoRemaining )
    local clipTextW, clipTextH = surface.GetTextSize( clipText )
    local maxTextW, maxTextH = surface.GetTextSize( maxText )
    local totalTextW = clipTextW + maxTextW

    -- Positions
    local space = onyx.hud.GetScreenPadding()
    local horPadding = onyx.hud.ScaleTall( 20 )
    local verPadding = onyx.hud.ScaleTall( 5 )
    local w = totalTextW + horPadding * 2
    local h = onyx.hud.ScaleTall( 55 )

    local x = scrW - w - space
    local y = scrH - h - space

    local colorTextPrimary = onyx.hud:GetColor( 'textPrimary' )
    local colorTextSecondary = onyx.hud:GetColor( 'textSecondary' )

    -- Draw
    onyx.hud.DrawRoundedBox( x, y, w, h, onyx.hud:GetColor( 'primary' ) )
    draw.SimpleText( onyx.lang:Get( 'props' ), onyx.hud.fonts.Small, x + w * .5, y + verPadding, colorTextSecondary, 1, 0 )
    onyx.hud.DrawCheapText( clipText, onyx.hud.fonts.AmmoRemaining, x + horPadding, y + h - clipTextH - verPadding, colorTextPrimary )
    onyx.hud.DrawCheapText( maxText, onyx.hud.fonts.AmmoRemaining, x + horPadding + clipTextW, y + h - clipTextH - verPadding, colorTextSecondary )
end

onyx.hud:RegisterElement( 'ammo', {
    drawFn = function( self, client, scrW, scrH )
        local weapon = client:GetActiveWeapon()
        if ( not IsValid( weapon ) ) then return end
        if ( client:InVehicle() ) then return end

        local class = weapon:GetClass()
        if ( BUILD_WEAPONS[ class ] ) then
            if ( onyx.hud:GetOptionValue( 'props_counter' ) ) then
                drawPropsHUD( client, scrW, scrH )
            end
        else
            drawAmmoHUD( client, scrW, scrH, weapon )
        end
    end,
    hideElements = { 
        [ 'CHudAmmo' ] = true, 
        [ 'CHudSecondaryAmmo' ] = true 
    }
} )
--PATH addons/____onyx_hud/lua/onyx/modules/hud/elements/cl_pickup_history.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

local TYPE_AMMO = 0
local TYPE_WEAPON = 1
local TYPE_ITEM = 2
local HOLD_DURATION = 3

local hud = onyx.hud
local history = {}

-- Colors inspired by the original UI, so it would be easy to adapt for players
local TYPES = {
    [ TYPE_AMMO ] = Color( 107, 136, 255 ),
    [ TYPE_ITEM ] = Color( 107, 255, 166 ),
    [ TYPE_WEAPON ] = Color( 255, 198, 107),
}

local MAX_RECORDS = 10

local function addRecord( name, type, amount )
    table.insert( history, 1, {
        name = name,
        amount = amount,
        endtime = CurTime() + HOLD_DURATION,
        duration = HOLD_DURATION,
        type = type,
        color = TYPES[ type ],
        fraction = 0
    } )

    if ( #history > MAX_RECORDS ) then 
        table.remove( history, ( MAX_RECORDS + 1 ) )
    end
end

hook.Add( 'onyx.inconfig.Updated', 'onyx.hud.ClearPickupHistory', function( id, old, new )
    if ( id and id == 'hud_display_pickup_history' ) then
        history = {}
    end
end )

hook.Add( 'HUDAmmoPickedUp', 'onyx.hud.InsertPickupHistory', function( ammoID, amount )
    if ( onyx.hud:GetOptionValue( 'display_pickup_history' ) ) then
        local niceName = language.GetPhrase( string.format( '#%s_ammo', ammoID ) )
    
        for _, record in ipairs( history ) do
            if ( record.name == niceName ) then
                record.endtime = CurTime() + HOLD_DURATION
                record.fraction = 0
                record.amount = record.amount + amount
                return true
            end
        end
    
        addRecord( niceName, TYPE_AMMO, amount )
    end

    return true
end )

hook.Add( 'HUDWeaponPickedUp', 'onyx.hud.InsertPickupHistory', function( weapon )
    -- lol I have encountered a really weird bug when physgun_beam is passed here
    if ( IsValid( weapon ) and weapon:IsWeapon() and onyx.hud:GetOptionValue( 'display_pickup_history' ) ) then
        addRecord( language.GetPhrase( weapon:GetPrintName() ), TYPE_WEAPON, 1 )
    end
    return true
end )

hook.Add( 'HUDItemPickedUp', 'onyx.hud.InsertPickupHistory', function( itemName )
    if ( onyx.hud:GetOptionValue( 'display_pickup_history' ) ) then
        addRecord( language.GetPhrase( itemName ), TYPE_ITEM, 1 )
    end

    return true
end )

hook.Add( 'HUDDrawPickupHistory', 'onyx.hud.DrawPickupHistory', function()
    if ( #history == 0 ) then return true end
    if ( not onyx.hud:GetOptionValue( 'display_pickup_history' ) ) then return true end

    local scrW = ScrW()
    local scrH = ScrH()

    local screenPadding = onyx.hud.GetScreenPadding() * 0.5
    local baseY = scrH * .5
    local baseX = scrW - screenPadding

    local colorPrimary = onyx.hud:GetColor( 'primary' )
    local colorPrimaryText = onyx.hud:GetColor( 'textPrimary' )

    local recordW = hud.ScaleWide( 140 )
    local recordH = hud.ScaleTall( 22 )
    local recordSpace = hud.ScaleTall( 5 )
    local lineW = hud.ScaleWide( 5 )
    local padding = hud.ScaleTall( 5 )
    local posY = baseY

    for index, record in ipairs( history ) do
        local isExpired = record.endtime <= CurTime()
        local targetFraction = isExpired and 0 or 1
        local amount = record.amount

        record.fraction = math.Approach( record.fraction, targetFraction, FrameTime() * 8 )

        local posX = baseX - recordW

        record.x = Lerp( record.fraction, ScrW(), posX )
        record.y = Lerp( FrameTime() * 16, record.y or posY, posY )
        local x, y = record.x, record.y

        local prevAlpha = surface.GetAlphaMultiplier()

        surface.SetAlphaMultiplier( record.fraction )
    
            hud.DrawRoundedBox( x, y, recordW, recordH, colorPrimary )

            render.SetScissorRect( x, y, x + lineW, y + recordH, true )
                hud.DrawRoundedBox( x, y, recordW, recordH, record.color )
            render.SetScissorRect( 0, 0, 0, 0, false )

            draw.SimpleText( record.name, onyx.hud.fonts.TinyBold, x + padding + lineW, y + recordH * .5, colorPrimaryText, 0, 1 )

            if ( amount > 1 ) then
                draw.SimpleText( amount, onyx.hud.fonts.TinyBold, x + recordW - padding, y + recordH * .5, colorPrimaryText, 2, 1 )
            end
            
        surface.SetAlphaMultiplier( prevAlpha )

        posY = posY - recordH - recordSpace

        if ( isExpired and record.fraction == 0 ) then
            table.remove( history, index )
        end
    end

    return true
end )
--PATH addons/____onyx_hud/lua/onyx/modules/hud/elements/cl_votes.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

18/08/2024

--]]

onyx.hud.popups = onyx.hud.popups or {}

local L = function( ... ) return onyx.lang:Get( ... ) end
local hud = onyx.hud

local function startFadeAnimation( panel, target, callback )
    panel.animAlpha = panel:GetAlpha() / 255
    
    onyx.anim.Create( panel, .2, {
        index = 1,
        target = { animAlpha = target },
        easing = 'inOutSine',
        think = function( _, panel )
            panel:SetAlpha( panel.animAlpha * 255 )
        end,
        onFinished = function( _, panel )
            if ( callback ) then
                callback( panel )
            end
        end
    } )
end

local function movePopups()
    local padding = hud.GetScreenPadding()
    local space = hud.ScaleTall( 5 )
    local baseX = padding
    local baseY = padding
    local posY = baseY
    
    for _, popup in ipairs( onyx.hud.popups ) do
        popup.animY = popup.animY or posY

        popup:SetVisible( true )

        onyx.anim.Create( popup, .2, {
            index = 2,
            target = { animY = posY },
            easing = 'inOutSine',
            think = function( _, panel )
                panel:SetPos( baseX, panel.animY )
            end
        } )

        posY = posY + popup:GetTall() + space
    end
end

local function createPopup( title, desc, duration, acceptCallback, denyCallback, onRemove )
    local padding = hud.ScaleTall( 10 )
    local w = hud.ScaleWide( 200 )
    local titleFont = hud.fonts.TinyBold
    local descFont = hud.fonts.Tiny
    local isDark = onyx.hud:IsDark()

    desc = surface.textWrap( desc, descFont, w - padding * 2 )

    local duration = duration or 5
    local endtime = CurTime() + duration

    surface.SetFont( titleFont )
    local _, titleH = surface.GetTextSize( title )

    surface.SetFont( descFont )
    local _, descH = surface.GetTextSize( desc )

    local buttonHeight = hud.ScaleTall( 20 )
    local elementSpace = hud.ScaleTall( 10 )
    local titleSpace = hud.ScaleTall( 5 )
    local totalHeight = padding * 2 + buttonHeight + descH + titleH + elementSpace + titleSpace

    local screenPadding = hud.GetScreenPadding()
    local h = totalHeight
    
    local popup = vgui.Create( 'Panel' )
    popup:SetSize( w, h )
    popup:SetAlpha( 0 )
    popup:SetVisible( false )
    popup:DockPadding( padding, padding, padding, padding )
    popup.Paint = function( panel, w, h )
        hud.DrawRoundedBox( 0, 0, w, h, hud:GetColor( 'primary' ) )
    end
    popup.Close = function( panel )
        startFadeAnimation( panel, 0, function( this )
            this:Remove()
        end )
    end
    popup.OnRemove = function( panel )
        for index, popup2 in ipairs( onyx.hud.popups ) do
            if ( panel == popup2 ) then
                table.remove( onyx.hud.popups, index )
                break
            end
        end
    
        movePopups()

        if ( onRemove ) then
            onRemove( panel )
        end
    end
    popup.Think = function( panel )
        if ( CurTime() > endtime and not panel.closed ) then
            panel.closed = true
            panel:Close()
        end
    end

    table.insert( onyx.hud.popups, popup )
    movePopups()

    startFadeAnimation( popup, 1 )

    local lblTitle = popup:Add( 'DLabel' )
    lblTitle:SetText( onyx.utf8.upper( title ) )
    lblTitle:SetFont( titleFont )
    lblTitle:SetTall( titleH )
    lblTitle:SetTextColor( hud:GetColor( 'textSecondary' ) )
    lblTitle:Dock( TOP )
    lblTitle:DockMargin( 0, 0, 0, titleSpace )
    lblTitle.Paint = function( panel, w, h )
        local timeLeft = math.max( 0, endtime - CurTime() )

        draw.SimpleText( math.Round( timeLeft ), panel:GetFont(), w, h * .5, panel:GetTextColor(), 2, 1 )
    end
    popup.lblTitle = lblTitle

    local lblDesc = popup:Add( 'DLabel' ) 
    lblDesc:SetText( desc )
    lblDesc:SetFont( descFont )
    lblDesc:SetTextColor( hud:GetColor( 'textPrimary' ) )
    lblDesc:SetContentAlignment( 7 )
    lblDesc:Dock( FILL )
    lblDesc:DockMargin( 0, 0, 0, elementSpace )
    popup.lblDesc = lblDesc

    local conButtons = popup:Add( 'Panel' )
    conButtons:SetTall( buttonHeight )
    conButtons:Dock( BOTTOM )
    conButtons.PerformLayout = function( panel, w, h )
        local space = hud.ScaleTall( 5 )
        local wide = math.Round( ( w - space ) * 0.5 )
        for _, child in ipairs( panel:GetChildren() ) do
            child:SetWide( wide )
            child:DockMargin( 0, 0, space, 0 )
            child:Dock( LEFT )
        end
    end

    local btnAccept = conButtons:Add( 'onyx.Button' )
    btnAccept:SetText( L( 'accept' ) )
    btnAccept:SetFont( hud.fonts.TinyBold )
    btnAccept:SetMasking( true )
    btnAccept:SetColorIdle( hud:GetColor( not isDark and 'tertiary' or 'accent' ) )
    btnAccept:SetColorHover( onyx.OffsetColor( btnAccept:GetColorIdle(), -20 ) )
    btnAccept:SetGradientColor( onyx.OffsetColor( btnAccept:GetColorIdle(), -20 ) )
    btnAccept:SetGradientDirection( TOP )
    btnAccept.DoClick = function()
        popup:Close()
        if ( acceptCallback ) then
            acceptCallback()
        end
    end
    popup.btnAccept = btnAccept

    local btnDeny = conButtons:Add( 'onyx.Button' )
    btnDeny:SetText( L( 'deny' ) )
    btnDeny:SetFont( hud.fonts.TinyBold )
    btnDeny:SetMasking( true )
    btnDeny:SetColorIdle( hud:GetColor( 'tertiary' ) )
    btnDeny:SetColorHover( onyx.OffsetColor( hud:GetColor( 'tertiary' ), -10 ) )
    btnDeny:SetGradientColor( onyx.OffsetColor( btnDeny:GetColorIdle(), -20 ) )
    btnDeny:SetGradientDirection( TOP )
    btnDeny.DoClick = function()
        popup:Close()
        if ( denyCallback ) then
            denyCallback()
        end
    end
    popup.btnDeny = btnDeny

    hook.Add( 'onyx.hud.OnChangedTheme', popup, function( this )
        this.lblTitle:SetTextColor( hud:GetColor( 'textSecondary' ) )
        this.lblDesc:SetTextColor( hud:GetColor( 'textPrimary' ) )

        this.btnAccept:SetColorIdle( hud:GetColor( not isDark and 'tertiary' or 'accent' ) )
        this.btnAccept:SetColorHover( onyx.OffsetColor( this.btnAccept:GetColorIdle(), -20 ) )
        this.btnAccept:SetGradientColor( onyx.OffsetColor( this.btnAccept:GetColorIdle(), -20 ) )

        this.btnDeny:SetColorIdle( hud:GetColor( 'tertiary' ) )
        this.btnDeny:SetColorHover( onyx.OffsetColor( hud:GetColor( 'negative' ), -20 ) )
        this.btnDeny:SetGradientColor( onyx.OffsetColor( this.btnDeny:GetColorIdle(), -20 ) )
    end )

    return popup
end

local function overrideDarkRP()
    usermessage.Hook( 'DoVote', function( msg )
        local text = msg:ReadString()
        local voteID = msg:ReadShort()
        local duration = msg:ReadFloat()
    
        if ( duration == 0 ) then
            duration = 100
        end

        local popup = createPopup( L( 'vote' ), text, duration, function()
            LocalPlayer():ConCommand( 'vote ' .. voteID .. ' yea\n' )
        end, function()
            LocalPlayer():ConCommand( 'vote ' .. voteID .. ' nay\n' )
        end )

        popup.voteID = voteID
    end )

    usermessage.Hook( 'DoQuestion', function( msg )
        local text = msg:ReadString()
        local questionID = msg:ReadString()
        local duration = msg:ReadFloat()
    
        if ( duration == 0 ) then
            duration = 100
        end

        local popup = createPopup( L( 'question' ), text, duration, function()
            LocalPlayer():ConCommand( 'ans ' .. questionID .. ' 1\n' )
        end, function()
            LocalPlayer():ConCommand( 'ans ' .. questionID .. ' 2\n' )
        end )

        popup.questionID = questionID
    end )

    usermessage.Hook( 'KillVoteVGUI', function( msg )
        local id = msg:ReadShort()
        for _, popup in ipairs( hud.popups ) do
            if ( popup.voteID == id ) then
                popup:Close()
                break
            end
        end
    end )

    usermessage.Hook( 'KillQuestionVGUI', function( msg )
        local id = msg:ReadString()    
        for _, popup in ipairs( hud.popups ) do
            if ( popup.questionID == id ) then
                popup:Close()
                break
            end
        end
    end )

    concommand.Add( 'rp_vote', function( ply, cmd, args )
        local value = string.lower( args[ 1 ] or '' )
        local vote = 0
        if ( tonumber( value ) == 1 ) or ( value == 'yes' ) or ( value == 'true' ) then vote = 1 end
    
        for _, popup in ipairs( hud.popups ) do
            if ( popup.questionID ) then
                popup:Close()
                RunConsoleCommand( 'ans', popup.questionID, vote )
                break
            elseif ( popup.voteID ) then
                popup:Close()
                RunConsoleCommand( 'vote', popup.voteID, vote )
                break
            end
        end
    end )
end

onyx.hud.OverrideGamemode( 'onyx.hud.OverrideVoteMenus', overrideDarkRP )
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/core/cl_init.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

28/02/2024

--]]

onyx.scoreboard.Buttons = onyx.scoreboard.Buttons or {}

local function openFrame()
    local ratio = 1.641
    local scale = onyx.scoreboard:GetOptionValue('scale') / 100
    local height = math.min(math.ceil((702 / 1080 * ScrH()) * scale), ScrH() * .9)
    local width = math.ceil(height * ratio)

    onyx.scoreboard.Frame = vgui.Create('onyx.Scoreboard.Frame')
    onyx.scoreboard.Frame:SetSize(width, height)
    onyx.scoreboard.Frame:Center()
    onyx.scoreboard.Frame:MakePopup()
    onyx.scoreboard.Frame:SetKeyboardInputEnabled(false)
    onyx.scoreboard.Frame:ShowCloseButton(false)

    hook.Run('onyx.scoreboard.OnOpened', onyx.scoreboard.Frame)

    return onyx.scoreboard.Frame
end

function onyx.scoreboard:RegisterButton(name, data)
    assert(isstring(name), string.format('bad argument #1 (expected string, got %s)', type(name)))
    assert(istable(data), string.format('bad argument #2 (expected table, got %s)', type(data)))

    data.name = name
    table.insert(self.Buttons, data)
end

function onyx.scoreboard.IsBlurActive()
    return onyx.scoreboard:GetOptionValue('blur')
end

do
    local TTT_Names = {
        ['GROUP_TERROR'] = {'terrorists', Color(0, 200, 0)},
        ['GROUP_SPEC'] = {'spectators', Color(200, 200, 0)},
        ['GROUP_NOTFOUND'] = {'sb_mia', Color(130, 190, 130)},
        ['GROUP_FOUND'] = {'sb_confirmed', Color(130, 170, 10)},
    }

    local TTT_RoleColors = {
        default = Color(121, 121, 121),
        traitor = Color(255, 96, 96),
        detective = Color(60, 112, 255)
    }

    function onyx.scoreboard.IsTTT()
        return false
    end

    function onyx.scoreboard.GetTeamTTT(ply)
        local group = ScoreGroup(ply)
        local color = color_white
        local name = ''

        if (group) then
            for globalKey, data in pairs(TTT_Names) do
                local index = _G[globalKey]
                if (index == group) then
                    local langID = data[1]
                    local groupColor = data[2]

                    name = LANG.GetTranslation(langID)
                    color = groupColor

                    break
                end
            end
        end

        return group, name, color
    end

    function onyx.scoreboard.GetRoleColorTTT(ply)
        if (ply:IsTraitor()) then
            return TTT_RoleColors.traitor
        elseif (ply:IsDetective()) then
            return TTT_RoleColors.detective
        end

        return TTT_RoleColors.default
    end
end

function onyx.scoreboard.ConvertTeamColor(color)
    local h, s, v = ColorToHSV(color)
    return onyx.ColorEditHSV(color, nil, s - .2, v + .2)
end

function onyx.scoreboard.OpenAdminSettings(tab)                                                                                                                                                                                                                                         -- 9bd46d08-b472-493c-8cb7-294505375bac
    local frame = vgui.Create('onyx.Frame')
    frame:SetSize(ScrW() * .6, ScrH() * .6)
    frame:Center()
    frame:MakePopup()
    frame:SetTitle('ONYX SCOREBOARD (ADMIN)')

    local p = onyx.ScaleTall(15)
    local content = frame:Add('Panel')
    content:Dock(FILL)
    content:DockPadding(p, p, p, p)

    local sidebar = frame:Add('onyx.Sidebar')
    sidebar:SetContainer(content)
    sidebar:SetWide(frame:GetWide() * .2)
    sidebar:Dock(LEFT)

    sidebar:AddTab({
        name = onyx.lang:Get('addon_settings_u'),
        desc = '',
        icon = 'https://i.imgur.com/ECLKU9s.png',
        class = 'onyx.Configuration',
        onSelected = function(panel)
            panel:LoadAddonSettings('scoreboard')
            panel:OpenCategories()
        end
    })

    sidebar:AddTab({
        name = onyx.lang:Get('scoreboard_ranks_u'),
        desc = '',
        icon = 'https://i.imgur.com/vaYzFPG.png',
        class = 'onyx.scoreboard.RankEditor'
    })

    sidebar:AddTab({
        name = onyx.lang:Get('scoreboard_columns_u'),
        desc = '',
        icon = 'https://i.imgur.com/fUaIb3B.png',
        class = 'onyx.scoreboard.ColumnEditor'
    })

    sidebar:AddTab({
        name = onyx.lang:Get('addon_return_u'),
        desc = '',
        icon = 'https://i.imgur.com/B9XOMVX.png',
        onClick = function()
            frame:Remove()

            local scoreboard = openFrame()
            scoreboard.closeDisabled = true
            scoreboard:ShowCloseButton(true)

            return false
        end
    })

    sidebar:ChooseTab(tab or 1)

    return frame
end

hook.Add('ScoreboardShow', 'onyx.scoreboard.Show', function()
    if (IsValid(onyx.scoreboard.Frame)) then
        return true
    end

    openFrame()

    return true
end)

hook.Add('ScoreboardHide', 'onyx.scoreboard.Hide', function()
    if (IsValid(onyx.scoreboard.Frame) and not onyx.scoreboard.Frame.closeDisabled) then
        onyx.scoreboard.Frame:Remove()
        onyx.scoreboard.Frame:SetMouseInputEnabled(false)
        hook.Run('onyx.scoreboard.OnClosed')
    end

    return true
end)

onyx.WaitForGamemode('onyx.scoreboard.BlockFAdmin', function()
    hook.Remove('ScoreboardShow', 'FAdmin_scoreboard')
    hook.Remove('ScoreboardHide', 'FAdmin_scoreboard')
end)
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/core/ranks/sh_ranks.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/03/2024

--]]

onyx.scoreboard.ranks = onyx.scoreboard.ranks or {}

function onyx.scoreboard:GetRankData(rank)
    local rankData = onyx.scoreboard.ranks[rank]
    if (rankData) then
        if (CLIENT) then
            local effectID = rankData.effectID
            local effectData, effectIndex = onyx.scoreboard:FindNameEffect(effectID)

            rankData.effect = effectIndex
        end

        return rankData
    end
end
--PATH addons/_outfitter/lua/includes/modules/binfuncs.lua:
if SERVER then
	AddCSLuaFile()
end

do -- uint conversion..
	local mod   = math.fmod
	local floor = math.floor

	local function rshift(x,n)
		return floor((x%4294967296)*0.5^n)
	end

	local function band(x,y)
		local z,i,j = 0,1
		for j = 0,31 do
			if (mod(x,2)==1 and mod(y,2)==1) then
				z = z + i
			end
			x = rshift(x,1)
			y = rshift(y,1)
			i = i*2
		end
		return z
	end
	------------------------------------------------------------------

    local byte,char=string.byte,string.char
    to_u_int = function(i,endian)
        if type(i)~="number" then debug.Trace() error"need unsigned integer" end
        if i<0 then error"bad integer x<0" end
        if i>0xffffffff then error"bad integer x>0xffffffff" end
        return endian and char(
				band(i,255) ,
				band(rshift(i,8),255 ),
				band(rshift(i,16),255 ),
				band(rshift(i,24),255 ))
		or 	char(
				band(rshift(i,24),255 ),
				band(rshift(i,16),255 ),
				band(rshift(i,8),255 ),
				band(i,255) )
    end
    from_u_int = function(s,endian,offset)
		offset=offset and tonumber(offset) or 0
        if type(s)~="string" then error"string required" end
        --if s:len()~=4 then error"this is not a uint" end

        local b1,b2,b3,b4=
			byte(s,offset+(endian and 1 or 4)),
            byte(s,offset+(endian and 2 or 3)),
            byte(s,offset+(endian and 3 or 2)),
            byte(s,offset+(endian and 4 or 1))
        local n = b1 + b2*256 + b3*65536 + b4*16777216

       if n<0 then error"conversion failure, garry/python sucks" end
       if n>0xffffffff then error"conversion failure, garry/python sucks" end
       return n
    end

end

local d=0xFFFFFF00
local a=0x00FFFFFF
assert(from_u_int(to_u_int(a))==a)
assert(from_u_int(to_u_int(d))==d)
assert(from_u_int(to_u_int(d,true),true)==d)
assert(from_u_int(to_u_int(d,true),false)==a)

--PATH addons/_outfitter/lua/includes/modules/playerextras.lua:
if SERVER then
	AddCSLuaFile()
end

do -- is stuck checker

	local output = {}
	local pl_filt
	local filter_tbl  = {}
	local function filter_func(e)
		if e==pl_filt then return false end
		local cg = e:GetCollisionGroup()

		return
			cg~=15 -- COLLISION_GROUP_PASSABLE_DOOR
		and cg~=11 -- COLLISION_GROUP_WEAPON
		and cg~=1 -- COLLISION_GROUP_DEBRIS
		and cg~=2 -- COLLISION_GROUP_DEBRIS_TRIGGER
		and cg~=20 -- COLLISION_GROUP_WORLD

	end
	local t = {output = output ,mask=MASK_PLAYERSOLID}
	FindMetaTable"Player".IsStuck=function(pl,fast,pos)
		t.start = pos or pl:GetPos()
		t.endpos = t.start
		if fast then
			filter_tbl[1] = pl
			t.filter = filter_tbl
		else
			pl_filt = pl
			t.filter = filter_func
		end


		util.TraceEntity(t,pl)
		return output.StartSolid,output.Entity,output
	end

end


--------------

local Tag = "player_cache"

local next=next

local cache = player.GetAllCached and player.GetAllCached() or {}
local cache_count = player.CountAll and player.CountAll() or 0

function player.GetAllCached()
	return cache
end
function player.CountAll()
	return cache_count
end

function player.All()
	return next,cache
end

function player.iterator()
	local i=1
	local function iter_all()
		local val=cache[i]
		i=val and i+1 or 1
		return val
	end
	return iter_all
end


local SERVER=SERVER

local function EntityCreated(pl)
	--assert(pl:IsPlayer()==pl:IsPlayer(),"isplayer mismatch")
	if pl:IsPlayer() then
		--print("Creating", pl)
		if SERVER then
			local uid = pl:UserID()
			for k, v in next, cache do
				if uid == v:UserID() then

					table.remove(cache, k)
					cache_count = cache_count - 1
				   -- print("NOCREAET, CACHE REMOVE", pl:UserID(), pl)
					return
				end

			end

		end

		table.insert(cache, pl)
		cache_count = cache_count + 1
	end

end

if SERVER then
	hook.Add("OnEntityCreated", Tag, EntityCreated)
else
	hook.Add("NetworkEntityCreated", Tag, EntityCreated)
end

local function add(pl)
	for k,pl2 in next,cache do
		if pl2==pl then return end
	end
	table.insert(cache,pl)
	cache_count = cache_count + 1
end
for k, pl in next, player.GetAll() do
	add(pl)
end

local function EntityRemoved(pl)
	--assert(pl:IsPlayer()==pl:IsPlayer(),"isplayer mismatch")
	if pl:IsPlayer() then
		--print("Removing", pl)
		for k, v in next, cache do
			if pl == v then
				table.remove(cache, k)
				cache_count = cache_count - 1
				-- return -- Add or not? Recursion even?
			end

		end

	end

end

if SERVER then
	hook.Add("PlayerDisconnected", Tag, EntityRemoved)
end
hook.Add("EntityRemoved", Tag, EntityRemoved)




--[[ testing --


local function assertfind(t, pl)
	for k, v in next, t do
		if v == pl then
			return
		end

	end

	error("Did not find: " .. tostring(pl) .. ' - ' .. tostring(player.ToUserID(pl)) .. ' - ' .. tostring(player.UserIDToName(player.ToUserID(pl))) .. ' from ' .. (t == player.GetAllCached() and "cachetbl" or "playerall"))
end

hook.Add("Think", Tag, function()
	local t = player.GetAll()
	local t2 = player.GetAllCached()
	for k, v in next, t do
		assert(IsValid(v), "getall not valid")
		assert(v:IsPlayer(), "getall not valid IsPlayer1")
		assert(v:IsPlayer(), "getall not valid IsPlayer2")
		assertfind(t2, v)
	end

	for k, v in next, t2 do
		assert(IsValid(v), "cache not valid")
		assert(v:IsPlayer(), "cache not valid IsPlayer1")
		assert(v:IsPlayer(), "cache not valid IsPlayer2")
		assertfind(t, v)
	end

end)

--]]


-------------------------------------

local Tag = 'PlayerSlowThink'
--By: Python1320, original by Lixquid

local RealTime = RealTime
local player = player
local hook = hook
local next = next
local FrameTime = FrameTime
local math = math
local ticint
	local function getintervals()
		return ticint
	end

	local function getintervalc()
		local ft = FrameTime()
		return ft > 0.3 and 0.3 or ft
	end

	local getinterval
	getinterval = function()
		if SERVER then
			ticint = engine.TickInterval()
			getinterval = getintervals
		else
			getinterval = getintervalc
		end

		return getinterval()
	end

local iterating_players = {  }
local function refreshplayers(t)
	local pls = player.GetAllCached()
	local plsc = #pls
	for i = 1, plsc do
		iterating_players[i] = pls[i]
	end

	local ipc = #iterating_players
	if ipc == plsc then
		return plsc
	end

	for i = ipc, plsc + 1, -1 do
		iterating_players[i] = nil
	end

	return plsc
end

function GetPlayerThinkCache()
	return iterating_players
end

local function Call(pl)
	if not pl:IsValid() then
		return
	end

	hook.Call(Tag, nil, pl)
end

local iterid = 1
local function iter()
	iterid = iterid + 1
	local pl = iterating_players[iterid]
	if pl == nil then
		iterid = 1
		return true
	end

	Call(pl)
end

local iterations_per_tick
local iterations_per_tick_frac
local fracpart = 0
local nextthink = 0
local printed
local function Think()
	local pl = iterating_players[iterid]
	if pl == nil then
		local now = RealTime()
		if nextthink > now then
			--if not printed then
			--	printed = true
			--	--print("=========",nextthink - now)
			--end

			return
		end

		nextthink = now + 1
		--printed = false
		fracpart = fracpart >= 1 and 1 or fracpart
		local plc = refreshplayers(iterating_players)
		if plc == 0 then
			return
		end

		iterid = 1
		iterations_per_tick = #player.GetAllCached() * getinterval()
		iterations_per_tick_frac = iterations_per_tick - math.floor(iterations_per_tick)
		iterations_per_tick = math.floor(iterations_per_tick)
		pl = iterating_players[iterid]
		if pl == nil then
			return
		end
		if fracpart>=0.3 then
			fracpart = 0
			Call(pl)
			iterid = iterid + 1
			pl = iterating_players[iterid]
			if pl == nil then
				return
			end
		end
	end

	fracpart = fracpart + iterations_per_tick_frac
	if fracpart > 1 then
		fracpart = fracpart - 1
		Call(pl)
		iterid = iterid + 1
		pl = iterating_players[iterid]
		if pl == nil then
			return
		end

	end

	for i = 1, iterations_per_tick do
		Call(pl)
		iterid = iterid + 1
		pl = iterating_players[iterid]
		if pl == nil then
			return
		end

	end

end


hook.Add("Think", Tag, Think)


-- Fix parent positioning function --

local Tag="f_pp"
if SERVER then

	util.AddNetworkString(Tag)

	local Entity=FindMetaTable"Entity"
	function Entity:FixParentPositioning()

		local ply = self:GetParent()
		if not ply:IsPlayer() then error"Parent is not a player" end

		net.Start(Tag)
			net.WriteEntity(self)
		net.Send(ply)
	end

end


-- player revive
if SERVER then
	local Player = FindMetaTable"Player"
	Player.Revive=Player.Revive or function(pl)
		if pl:Alive() then return end
		local pos = pl:GetPos()
		pl:Spawn()
		pl:SetPos(pos)
	end
end

if SERVER then return end

local t={}

local added = false

local LocalPlayer=LocalPlayer

local function PreDrawOpaqueRenderables()
	local mypos=LocalPlayer():GetPos()
	local ok
	for _,ent in next,t do
		ok=true
		if not ent:IsValid() then
			t[_]=nil
			continue
		end
		ent:SetRenderAngles(ent:GetNetworkAngles())
		ent:SetRenderOrigin(ent:GetNetworkOrigin()+mypos)
	end
	if not ok then
		added=false
		hook.Remove("PreDrawOpaqueRenderables",Tag)
	end
end

net.Receive(Tag,function()
	if not added then
		hook.Add("PreDrawOpaqueRenderables",Tag,PreDrawOpaqueRenderables)
		added = true
	end

	local ent = net.ReadEntity()

	if not IsValid(ent) then return end

	table.insert(t,ent)

end)

player.GetByUserID = player.GetByID


--PATH addons/_outfitter/lua/outfitter/gui_ofworkshopicon.lua:
local Tag='outfitter'

module(Tag,package.seeall)


local PANEL = {}

function PANEL:Init()
	self:SetTall( 128 )
	self:SetWide( 128 )
end

-- Adapted from https://github.com/robotboy655/gmod-lua-menu/blob/master/lua/menu/custom/addons.lua
-- TODO: Use coroutines, cache results

local gDataTable = gDataTable or {}
function PANEL:SetAddon( data )
	self.Addon = data
	if ( gDataTable[ data.wsid ] ) then self.AdditionalData = gDataTable[ data.wsid ] return end

	steamworks.FileInfo( data.wsid, function( result )
		if not result then return end

		gDataTable[ data.wsid ] = result

		if ( !file.Exists( 'cache/workshop/' .. result.previewid .. '.cache',"GAME" ) ) then
			steamworks.Download( result.previewid, false, function( name ) end )
		end

		if ( !IsValid( self ) ) then return end

		self.AdditionalData = result

	end )
end

local missingMat = Material( "../html/img/addonpreview.png", "nocull smooth" )
local lastBuild = 0
local imageCache = {}
function PANEL:Paint( w, h )

	if ( self.AdditionalData && imageCache[ self.AdditionalData.previewid ] ) then
		self.Image = imageCache[ self.AdditionalData.previewid ]

	end

	if ( !self.Image && self.AdditionalData && file.Exists( "cache/workshop/" .. self.AdditionalData.previewid .. ".cache", "GAME" ) && CurTime() - lastBuild > 0.1 ) then
		self.Image = AddonMaterial( "cache/workshop/" .. self.AdditionalData.previewid .. ".cache" )
		imageCache[ self.AdditionalData.previewid ] = self.Image
		lastBuild = CurTime()
		self.errcheck = false
		self.errored = false
	end


	draw.RoundedBox( 4, 0, 0, w, h, Color( 0, 0, 0, 255 ) )
	
	if not self.errcheck then
		self.errcheck = true
		if self.Image and self.Image:IsError() then
			self.errored = true
		end
	end
	
	if self.Image and not self.errored then
		surface.SetMaterial( self.Image )
	else
		surface.SetMaterial( missingMat )
	end
	local imageSize = self:GetTall() - 10
	surface.SetDrawColor( color_white )
	surface.DrawTexturedRect( 5, 5, imageSize, imageSize )

	if ( self.Addon && self.Hovered ) then
		draw.RoundedBox( 0, 5, h - 25, w - 10, 15, Color( 0, 0, 0, 180 ) )
		draw.SimpleText( self.Addon.title, "Default", 8, h - 24, Color( 255, 255, 255 ) )
	end

end

vgui.Register( "DOWorkshopIcon", PANEL, "Panel" )
--PATH addons/_outfitter/lua/outfitter/net.lua:
local Tag='outfitter'
local NTag = 'OF'
local NTagSkin = 'OFSKin'

module(Tag,package.seeall)
_M.NTagSkin=NTagSkin
_M.NTag=NTag

hook.Add("NetData",Tag,function(...) return NetData(...) end)

function SHNetworkOutfit(pl,mdl,download_info)
	--assert(not download_info or tonumber(download_info),('NetworkOutfit INVALID: mdl=%q download_info=%q'):format(tostring(mdl),tostring(download_info)))
	
	if not mdl then mdl=nil download_info=nil end
	
	local encoded,err = mdl and EncodeOutfitterPayload(mdl,download_info)
	dbg("NetworkOutfit",pl,mdl,download_info,('%q'):format(tostring(encoded)),err)
	if not encoded then encoded=nil end
	
	pl:SetNetData(NTag,encoded)

end

if CLIENT then
	function CyclePlayerModel(pl)
		dbgn(2,"CyclePlayerModel()")
		assert(not pl or pl==LocalPlayer())
		net.Start(Tag)
		net.SendToServer()
	end
end

if SERVER then
	return
end

function NetData(plid,k,val)
	if k~=NTag then return end

	local pl = findpl(plid)
	dbg("NetData",pl or plid,k,"<-",val)
	if not pl then 
		dbgn(11,"Skip netdata callback for",plid)
		return
	end

	OnPlayerVisible(pl,net.IsPlayerVarsBurst())
	
end

-- Repeatedly called on all visible players and sometimes invisible players due to dormant player state updates
function OnPlayerVisible(pl,initial_sendings)
	
	-- check for changed outfit data
	local new = pl:GetNetData(NTag)
	local old = pl.outfitter_nvar
	
	if new==old then
		return
	end
	
	pl.outfitter_nvar_burst = initial_sendings
	
	local me = LocalPlayer()
	if pl==me then
		timer.Simple(1,function()
			--CyclePlayerModel(pl)
		end)
	end
	
	-- local player is special snowflake due to engine
	if pl~=me and new then
		
		if not IsEnabled() then
			pl.outfitter_nvar = nil
			dbgn(2,"OnPlayerVisible","IsEnabled",pl)
			return
		end
		
		if VisibleFilter(me,pl) then
			dbgn(2,"OnPlayerVisible","VisibleFiltering",pl)
			return
		end
			
		if IsHighPerf() then
			dbgn(2,"OnPlayerVisible","high perf blocking")
			return
		end
		
	end
	
	--if old == true then return end
	
	local mdl,download_info
	if new then
		mdl,download_info = DecodeOutfitterPayload(new)
	
		local ret = hook.Run("CanOutfit",pl,mdl,download_info)
		if ret == false then return end
		if ret ~= true then
			if not IsFriendly(pl) then
				dbgn(3,"OnPlayerVisible","unfriendly",pl)
				return
			end
		end
		
	end
	
	pl.outfitter_nvar = new
	
	hook.Run("CouldOutfit",pl,mdl,download_info)
	
	dbgn(2,"OnPlayerVisible",pl==me and "SKIP" or pl,mdl or "UNSET?",download_info)
	
	if pl==me then
		dbg("OnPlayerVisible","SKIP","LocalPlayer")
		return
	end
	
	OnChangeOutfit(pl,mdl,download_info)
	
end


hook.Add("NetworkEntityCreated",Tag,function(ent)
	if ent:IsPlayer() then
		OnPlayerVisible(ent)
	elseif ent:GetClass() == "class C_HL2MPRagdoll" then
		local owner = ent:GetRagdollOwner()
		if owner:IsValid() then
			OnDeathRagdollCreated(ent,owner)
			return
		end
	end
end)

local function OnPlayerPVS(pl,inpvs)
	if inpvs==false then return end
	OnPlayerInPVS(pl)
end

hook.Add("NotifyShouldTransmit",Tag,function(pl,inpvs)
	if pl:IsPlayer() then
		OnPlayerPVS(pl,inpvs)
	end
end)

-- I want to tell others about my outfit
function NetworkOutfit(...)
	return SHNetworkOutfit(LocalPlayer(),...)
end



function RequestSkin(n)

	--TODO: don't overwrite client's preferences
	RunConsoleCommand("cl_playerskin",tostring(n or 1))

	net.Start(NTagSkin)
		net.WriteUInt(n or 1, 10)
	net.SendToServer()
end

--PATH addons/_pcasino/lua/perfectcasino/derma/cl_elements.lua:
-- Function Cache
local color = Color
local draw_roundedbox = draw.RoundedBox
local draw_simpletext = draw.SimpleText
local draw_notexture = draw.NoTexture
local surface_setdrawcolor = surface.SetDrawColor
-- Color cache
local inputBlack = color(100, 100, 100)
local mainRed = color(155, 50, 50)
local mainBlack = color(38, 38, 38)
local textWhite = color(220, 220, 220)

-- Text Entry
local PANEL = {}
function PANEL:Init()
	self:DockMargin(5, 5, 5, 5)
	self:SetFont("pCasino.Textbox.Static")
	self:SetText("")
	self:SetDisplayText("Input")
end

function PANEL:SetDisplayText(text)
	self.placeholder = text
end

function PANEL:Paint(w, h)
	draw_roundedbox(3, 0, 0, w, h, mainRed)
	draw_roundedbox(3, 1, 1, w - 2, h - 2, mainBlack)

	self:DrawTextEntryText(textWhite, mainRed, mainRed)

	if(self:GetText() == "") and not self:HasFocus() then
		draw_simpletext(self.placeholder, "pCasino.Textbox.Static", 5, h*0.5, textWhite, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end
end
vgui.Register('pCasinoEntry', PANEL, 'DTextEntry')

-- Switch
-- Created by Livaco, edited by Owain.
local PANEL = {}
function PANEL:Init()
	self:SetText("")
	self.toggle = true

	self.lerp = 0.2
end
function PANEL:DoClick()
	self:Toggle()
end
function PANEL:Toggle()
	self:SetToggle(not self:GetToggle())
end
function PANEL:GetToggle()
	return self.toggle
end
function PANEL:SetToggle(value)
	self.toggle = value
end
function PANEL:Paint(w, h)
	draw_roundedbox(3, w*0.05, h*0.3, w*0.9, h*0.4, inputBlack)

	if self:GetToggle() then
		self.lerp = Lerp(0.1, self.lerp, 0.8)
	else
		self.lerp = Lerp(0.1, self.lerp, 0.2)
	end

	draw_notexture()
	surface_setdrawcolor(200-(200*self.lerp), 0+(200*self.lerp), 0, 255)
	PerfectCasino.UI.DrawCircle(w*self.lerp, h*0.5, h*0.35, 1)
end
vgui.Register('pCasinoSwitch', PANEL, 'DButton')


-- Circle Function
-- Created by Ben.
local sinCache = {}
local cosCache = {}
for i = 0, 360 do
	sinCache[i] = math.sin(math.rad(i))
	cosCache[i] = math.cos(math.rad(i))
end
function PerfectCasino.UI.DrawCircle(x, y, r, step)
    local positions = {}

    for i = 0, 360, step do
        table.insert(positions, {
            x = x + cosCache[i] * r,
            y = y + sinCache[i] * r
        })
    end

    return surface.DrawPoly(positions)
end

-- Rotate around point
-- Taken from wiki: https://wiki.facepunch.com/gmod/surface.DrawTexturedRectRotated
function PerfectCasino.UI.DrawTexturedRectRotatedPoint(x, y, w, h, rot, x0, y0)
	local c = math.cos(math.rad(rot))
	local s = math.sin(math.rad(rot))
	
	local newx = y0 * s - x0 * c
	local newy = y0 * c + x0 * s
	
	surface.DrawTexturedRectRotated(x + newx, y + newy, w, h, rot)
end

-- Rotate text
-- Taken from wiki: https://wiki.facepunch.com/gmod/cam.PushModelMatrix
function PerfectCasino.UI.TextRotated(text, x, y, color, font, ang, shift)
	local mat = Matrix()
	mat:Rotate(Angle(0, ang, 0))
	mat:SetTranslation(Vector(x, y, shift or 0))
	
	cam.PushModelMatrix(mat, true)
	    draw_simpletext(text, font, 0, 0, color, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	cam.PopModelMatrix()    
end

-- Apply st, nd, rd, th to a number. This only works to 20, but there will never be an internal usecase past 20
-- Taken from xSits: A custom addon written by Owain
function PerfectCasino.UI.NumberSuffix(i)
	if i == 1 then
		return i.."st"
	elseif i == 2 then
		return i.."nd"
	elseif i == 3 then
		return i.."rd"
	end

	return i.."th"
end

-- Wrap text
-- Taken from XYZUI: A custom UI library written by Owain
function PerfectCasino.UI.WrapText(text, wrap, font, posx, posy, color, align1, align2)
	text = string.Explode("", text)

	local newText = {}
	for i=1, math.ceil(#text/wrap) do
		newText[i] = ""
		for p=1 + ((i-1)*wrap), i*wrap do
			if not text[p] then break end

			newText[i] = newText[i]..text[p]
		end
	end

	text = newText

	local space = 30*#text
	local startingPos = posy-(space*0.5)+(30*0.5)

	for k, v in pairs(text) do
		draw_simpletext(v, font, posx, startingPos+((k-1)*30), color or color_white, align1, align2)
	end
end

--PATH addons/_pcasino/lua/perfectcasino/core/sh_core.lua:
-- The letters bodygroup and width
PerfectCasino.Core.Letter = {
	["a"] = {b = 0, w = 5},
	["b"] = {b = 1, w = 4},
	["c"] = {b = 2, w = 4.2},
	["d"] = {b = 3, w = 4.5},
	["e"] = {b = 4, w = 3.7},
	["f"] = {b = 5, w = 3.6},
	["g"] = {b = 6, w = 5},
	["h"] = {b = 7, w = 5},
	["i"] = {b = 8, w = 2},
	["j"] = {b = 9, w = 3.2},
	["k"] = {b = 10, w = 4.7},
	["l"] = {b = 11, w = 3.7},
	["m"] = {b = 12, w = 6},
	["n"] = {b = 13, w = 5},
	["o"] = {b = 14, w = 5},
	["p"] = {b = 15, w = 4},
	["q"] = {b = 16, w = 5},
	["r"] = {b = 17, w = 4.7},
	["s"] = {b = 18, w = 4},
	["t"] = {b = 19, w = 4.5},
	["u"] = {b = 20, w = 4.5},
	["v"] = {b = 21, w = 5.2},
	["w"] = {b = 22, w = 7.3},
	["x"] = {b = 23, w = 5},
	["y"] = {b = 24, w = 4.7},
	["z"] = {b = 25, w = 4.6},
	["0"] = {b = 26, w = 4.2},
	["1"] = {b = 27, w = 3},
	["2"] = {b = 28, w = 4},
	["3"] = {b = 29, w = 3.8},
	["4"] = {b = 30, w = 4.4},
	["5"] = {b = 31, w = 3.8},
	["6"] = {b = 32, w = 4.1},
	["7"] = {b = 33, w = 4.1},
	["8"] = {b = 34, w = 4.2},
	["9"] = {b = 35, w = 4.1},
	["-"] = {b = 36, w = 2.7},
	["!"] = {b = 37, w = 2},
	["."] = {b = 38, w = 2.3}
}

-- Who has "admin" perms
function PerfectCasino.Core.Access(user)
	if not IsValid(user) then return false end
	return PerfectCasino.Config.AccessGroups[user:GetUserGroup()] or PerfectCasino.Config.AccessGroups[user:SteamID64()] or PerfectCasino.Config.AccessGroups[user:SteamID()]
end

-- Chat messages
function PerfectCasino.Core.Msg(msg, ply)
	if SERVER then
		net.Start("pCasino:Msg")
			net.WriteString(msg)
		if not ply then
			net.Broadcast()
		else
			net.Send(ply)
		end
	else
		chat.AddText(PerfectCasino.Config.PrefixColor, PerfectCasino.Config.Prefix..": ", Color( 255, 255, 255 ), msg)
	end
end


if SERVER then return end

net.Receive("pCasino:Msg", function()
	PerfectCasino.Core.Msg(net.ReadString())
end)


--PATH addons/_pcasino/lua/perfectcasino/config/sh_config.lua:
-----------------------
--      IMPORTANT     -
-----------------------
-- The creation of the entities is done in-game with the toolgun.
-- This allows for you to easily have several of the same machine with different configurations,
-- making the addon easier to use in the process.


/* ============
 General Config
=============*/

-- Chat prefix
PerfectCasino.Config.PrefixColor = Color(175, 0, 0)
PerfectCasino.Config.Prefix = "[pCasino]"

--- The usergroups/SteamIDs that get access to the in-game entity maker
PerfectCasino.Config.AccessGroups = {}
PerfectCasino.Config.AccessGroups["superadmin"] = true



-- The following functions are for developers to add support to the currency they're using.
function PerfectCasino.Config.AddMoney(ply, amount)
	ply:AddMoney(amount)
end
function PerfectCasino.Config.CanAfford(ply, amount)
	return ply:CanAfford(amount)
end
function PerfectCasino.Config.FormatMoney(amount)
	return rp.FormatMoney(amount)
end


-- These are the reward functions that are run when prize wheels are triggered
-- ply is the user that is receiving the reward.
-- ent is the entity that is linked to the win. Most likely a slot machine or a prize wheel.
-- inputValue is the custom input used in the in-game config menu. This way, you can have 1 function for giving money, and just
-- provide it with different inputs
-- You can also return a string that will be a custom message, otherwise it will default to a preset one in the language file.
PerfectCasino.Config.RewardsFunctions = {}

-- No reward
PerfectCasino.Config.RewardsFunctions["nothing"] = function(ply, ent, inputValue)
	-- They won nothing, do nothing
end
-- RP money
PerfectCasino.Config.RewardsFunctions["money"] = function(ply, ent, inputValue)
	PerfectCasino.Config.AddMoney(ply, inputValue)
end
-- The machines Jackpot. This will only work on machines with jackpots.
PerfectCasino.Config.RewardsFunctions["jackpot"] = function(ply, ent, inputValue)
	local jackpotAmount = ent:GetCurrentJackpot()

	PerfectCasino.Config.AddMoney(ply, jackpotAmount)
	ent:SetCurrentJackpot(ent.data.jackpot.startValue) -- Reset the jackpot

	return "You have hit the jackpot, the payout is "..PerfectCasino.Config.FormatMoney(jackpotAmount)
end
-- Prize Wheel
PerfectCasino.Config.RewardsFunctions["prize_wheel"] = function(ply, ent, inputValue)
	PerfectCasino.Core.GiveFreeSpin(ply)
end
-- A weapon
PerfectCasino.Config.RewardsFunctions["weapon"] = function(ply, ent, inputValue)
	ply:Give(inputValue)
end
-- Health
PerfectCasino.Config.RewardsFunctions["health"] = function(ply, ent, inputValue)
	ply:SetHealth(inputValue)
end
-- Armor
PerfectCasino.Config.RewardsFunctions["armor"] = function(ply, ent, inputValue)
	ply:SetArmor(inputValue)
end
-- Kill
PerfectCasino.Config.RewardsFunctions["kill"] = function(ply, ent, inputValue)
	ply:Kill()
end
-- Job
PerfectCasino.Config.RewardsFunctions["setjob"] = function(ply, ent, inputValue)
	if not ply:Alive() then
		ply:Spawn()
	end

	for i, team in ipairs(rp.Team) do
		if team.name == inputValue then
			ply:ChangeTeam(i, true)
			ply:Spawn()

			break
		end
	end
end
--[[-- Set Playermodel
PerfectCasino.Config.RewardsFunctions["setmodel"] = function(ply, ent, inputValue)
	ply:SetModel(inputValue)
end
-- Pointshop 1 Points
PerfectCasino.Config.RewardsFunctions["ps1_points"] = function(ply, ent, inputValue)
	ply:PS_GivePoints(inputValue)
end
-- Pointshop 1 Item
PerfectCasino.Config.RewardsFunctions["ps1_item"] = function(ply, ent, inputValue)
	ply:PS_GiveItem(inputValue)
end
-- Pointshop 2 Points
PerfectCasino.Config.RewardsFunctions["ps2_points"] = function(ply, ent, inputValue)
	ply:PS2_AddStandardPoints(inputValue)
end
-- Pointshop 2 Item
PerfectCasino.Config.RewardsFunctions["ps2_item"] = function(ply, ent, inputValue)
	local item = Pointshop2.GetItemClassByPrintName(inputValue) 
	ply:PS2_EasyAddItem(item.className)
end
-- Pointshop 2 Premium Points
PerfectCasino.Config.RewardsFunctions["ps2_prempoints"] = function(ply, ent, inputValue)
	ply:PS2_AddPremiumPoints(inputValue)
end
-- SH Pointshop Points
PerfectCasino.Config.RewardsFunctions["pssh_points"] = function(ply, ent, inputValue)
	ply:SH_AddStandardPoints(inputValue)
end
-- SH Pointshop Item
PerfectCasino.Config.RewardsFunctions["pssh_item"] = function(ply, ent, inputValue)
	ply:SH_AddItem(inputValue)
end
-- SH Pointshop Premium Points
PerfectCasino.Config.RewardsFunctions["pssh_prempoints"] = function(ply, ent, inputValue)
	ply:SH_AddPremiumPoints(inputValue)
end
-- William's Car Dealer
PerfectCasino.Config.RewardsFunctions["wcd_givecar"] = function(ply, ent, inputValue)
	WCD:GiveVehicleToSteamID(ply:SteamID(), inputValue)
end
-- Fresh Car Dealer Give Car
PerfectCasino.Config.RewardsFunctions["fcd_givecar"] = function(ply, ent, inputValue)
	fcd.giveVehicle(ply, inputValue)
end
-- Brick Wall's Essentials
PerfectCasino.Config.RewardsFunctions["bwe_givexp"] = function(ply, ent, inputValue)
	ply:AddExperience(inputValue, "pCasino")
end
-- mTokens tokens
PerfectCasino.Config.RewardsFunctions["mtkn_tokens"] = function(ply, ent, inputValue)
	mTokens.AddPlayerTokens(ply, tonumber(inputValue))
end

PerfectCasino.Config.RewardsFunctions["srp_givecar"] = function(ply, ent, inputValue)
	ply:GetCharacter().Vehicles[inputValue] = {
		color = Color(255, 255, 255, 255)
    }
	GAMEMODE.Player:SetGameVar(ply, "vehicles", ply:GetCharacter().Vehicles)
	GAMEMODE.SQL:MarkDiffDirty(ply, "vehicles")
end
-- Brick's Credits
PerfectCasino.Config.RewardsFunctions["bc_credits"] = function(ply, ent, inputValue)
	ply:AddBRCS_Credits(inputValue)
end

PerfectCasino.Config.RewardsFunctions["vcmod_givecar"] = function(ply, ent, inputValue)
    if not ply:VC_CD_getOwnedVehicleData(inputValue) then
        ply:VC_CD_addVehicle(inputValue)
    end
end]]

if SERVER then return end
-- Here you can add custom icons that can be used in the prize wheels.
-- The formatting is as follows:
-- 1st argument: A unique name. This must be lowercase and have no spaces or special characters.
-- 2nd argument: This is the display name. This can be anything you like and will be what shows up the UIs
-- 3rd argument: This is the URL to the image. It must be a PNG and will be rescaled to a 1:1 aspect ration, so to provide it as a square image will help keep quality.
-- Example:
PerfectCasino.Core.AddIcon("car", "Car", "https://0wain.xyz/icons/pcasino/car.png")

--PATH addons/____plogs/lua/plogs/workarounds/sanity_checker.lua:
--[[
addons/lgos/lua/plogs/workarounds/sanity_checker.lua
--]]
-- Let's reduce support tickets by 50%
local function LowerKeys(tab)
	for k, v in pairs(tab) do
		tab[string.lower(k)] = v
	end
end

plogs.cfg.Command = string.lower(plogs.cfg.Command or 'plogs')
plogs.cfg.Command = string.Replace(plogs.cfg.Command, '/', '')
plogs.cfg.Command = string.Replace(plogs.cfg.Command, '!', '')

plogs.cfg.Width = math.Clamp((plogs.cfg.Width or .65), .25, 1)

plogs.cfg.Height = math.Clamp((plogs.cfg.Height or .65), .25, 1)

plogs.cfg.DarkUI = plogs.cfg.DarkUI or false

plogs.cfg.EchoServer = plogs.cfg.EchoServer or true

plogs.cfg.DevAccess = plogs.cfg.DevAccess or true

plogs.cfg.EnableMySQL = plogs.cfg.EnableMySQL or false

plogs.cfg.LogLimit = plogs.cfg.LogLimit or 128

plogs.cfg.ShowSteamID = plogs.cfg.ShowSteamID or true

plogs.cfg.LogTypes = plogs.cfg.LogTypes or {
	['chat'] 		= false,
	['commands']	= false,
	['connections'] = false,
	['kills'] 		= false,
	['props'] 		= false,
	['tools'] 		= false,
	['darkrp'] 		= true,
	['ulx']			= true,
	['pnlr']		= true, -- NLR Zones					|| 	https://scriptfodder.com/scripts/view/583
	['lac']			= true, -- Leys Serverside AntiCheat 	|| 	https://scriptfodder.com/scripts/view/1148
	['awarn2']		= true, -- AWarn2 						||	https://scriptfodder.com/scripts/view/629
	['hitmodule']	= true, -- Hitman Module				||	https://scriptfodder.com/scripts/view/1369
	['cuffs'] 		= false, -- Hand Cuffs 					||	https://scriptfodder.com/scripts/view/910
}

plogs.cfg.CommandBlacklist = plogs.cfg.CommandBlacklist or {
	['_sendDarkRPvars']		= true,
	['_sendAllDoorData']	= true,
	['ulib_cl_ready'] 		= true,
	['_xgui']				= true,
	['ulx']					= true,
}

LowerKeys(plogs.cfg.LogTypes)
--PATH addons/____sam/lua/sam/command/arguments/text.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

command.new_argument("text")
	:OnExecute(function(argument, input, ply, _, result, i)
		if sam.isstring(input) then
			input = input:sub(1, 255)
		end

		local invalid = false
		if input == nil then
			if not argument.optional then
				invalid = true
			end
		elseif argument.check and not argument.check(input, ply) then
			invalid = true
		end

		if invalid then
			ply:sam_send_message("invalid", {
				S = argument.hint or "text", S_2 = input
			})
			return false
		end

		result[i] = input
	end)
	:Menu(function(set_result, body, buttons, argument)
		local text_entry = buttons:Add("SAM.TextEntry")
		text_entry:SetTall(25)

		local default = argument.default
		text_entry:SetCheck(function(text)
			local valid = true
			if text == "" then
				if default then
					text = default
				elseif not argument.optional then
					valid = false
				end
			elseif argument.check and not argument.check(text, LocalPlayer()) then
				valid = false
			end

			set_result(valid and text or nil)

			return valid
		end)

		local hint = argument.hint or "text"
		if default then
			hint = hint .. " = " .. tostring(default)
		end

		text_entry:SetPlaceholder(hint)

		return text_entry
	end)
:End()
--PATH addons/____sui/lua/sui/libs/png_encoder.lua:
local string = string
local table = table
local bit = bit

local char = string.char
local byte = string.byte

local insert = table.insert
local concat = table.concat

local bor = bit.bor
local bxor = bit.bxor
local band = bit.band
local bnot = bit.bnot
local lshift = bit.lshift
local rshift = bit.rshift

local ceil = math.ceil

local SIGNATURE = char(137, 80, 78, 71, 13, 10, 26, 10)

local crc_table = {}; do
	local n = 0
	while n < 256 do
		local c = n
		local k = 0
		while k < 8 do
			if band(c, 1) ~= 0 then
				c = bxor(0xedb88320, rshift(c, 1))
			else
				c = rshift(c, 1)
			end
			k = k + 1
		end
		crc_table[n + 1] = c
		n = n + 1
	end
end

local crc = function(buf)
	local c = 0xffffffff
	for i = 1, #buf do
		c = bxor(crc_table[band(bxor(c, byte(buf, i)), 0xff) + 1], rshift(c, 8))
	end
	return bxor(c, 0xffffffff)
end

local dword_as_string = function(dword)
	return char(
		rshift(band(dword, 0xff000000), 24),
		rshift(band(dword, 0x00ff0000), 16),
		rshift(band(dword, 0x0000ff00), 8),
		band(dword, 0x000000ff)
	)
end

local create_chunk = function(type, data, length)
	local CRC = crc(type .. data)
	return concat({
		dword_as_string(length or #data),
		type,
		data,
		dword_as_string(CRC)
	}, "", 1, 4)
end

local create_IHDR; do
	local ARGS = (
		-- bit depth
		char(8) ..
		-- color type: 6=truecolor with alpha
		char(6) ..
		-- compression method: 0=deflate, only allowed value
		char(0) ..
		-- filtering: 0=adaptive, only allowed value
		char(0) ..
		-- interlacing: 0=none
		char(0)
	)

	create_IHDR = function(w, h)
		return create_chunk("IHDR", concat({
			dword_as_string(w),
			dword_as_string(h),
			ARGS
		}, "", 1, 3), 13)
	end
end

local deflate_pack; do
	local BASE = 6552
	local NMAX = 5552
	local adler32 = function(str)
		local s1 = 1
		local s2 = 0
		local n = NMAX

		for i = 1, #str do
			s1 = s1 + byte(str, i)
			s2 = s2 + s1

			n = n - 1
			if n == 0 then
				s1 = s1 % BASE
				s2 = s2 % BASE
				n = NMAX
			end
		end

		s1 = s1 % BASE
		s2 = s2 % BASE

		return bor(lshift(s2, 16), s1)
	end

	local splitChunks = function(chunk, chunkSize)
		local len = ceil(#chunk / chunkSize)
		local ret = {}
		for i = 1, len do
			ret[i - 1] = chunk:sub(((i - 1) * chunkSize) + 1, chunkSize)
		end
		return ret
	end

	deflate_pack = function(str)
		local ret = {"\x78\x9c"}

		local chunks = splitChunks(str, 0xFFFF)
		local len = #chunks

		local i = 0
		while i < (len + 1) do
			local chunk = chunks[i]
			local chunk_n = #chunk

			insert(ret, i < len and "\x00" or "\x01")
			insert(ret, char(band(chunk_n, 0xff), band(rshift(chunk_n, 8), 0xff)))
			insert(ret, char(band(bnot(chunk_n), 0xff), band(rshift(bnot(chunk_n), 8), 0xff)))
			insert(ret, chunk)
			i = i + 1
		end

		local t = adler32(str)
		t = char(
			band(rshift(t, 24), 0xff),
			band(rshift(t, 16), 0xff),
			band(rshift(t, 8), 0xff),
			band(t, 0xff)
		)

		insert(ret, t)

		return concat(ret)
	end
end

local create_IDAT; do
	local slice = function(a, s, e)
		local ret, j = {}, 0
		for i = s, e - 1 do
			ret[j] = char(band(a[i] or 0, 0xFF))
			j = j + 1
		end
		return ret
	end

	local array_split_chunks = function(w, h, array, chunkSize)
		local ret = {}
		local i = 0
		local len = ceil((w * h * 4 + 4) / chunkSize)
		while i < len do
			ret[i] = slice(array, i * chunkSize, (i + 1) * chunkSize)
			i = i + 1
		end
		return ret
	end

	create_IDAT = function(w, h, chunk)
		local scanlines = array_split_chunks(w, h, chunk, w * 4)

		local image_bytes = {}
		for i = 0, #scanlines do
			local scanline = scanlines[i]
			insert(image_bytes, char(band(0, 0xFF)))
			insert(image_bytes, concat(scanline, "", 0, #scanline))
		end
		image_bytes = deflate_pack(concat(image_bytes))

		return create_chunk("IDAT", image_bytes)
	end
end

local IEND = create_chunk("IEND", "", 0)
local to_return = {SIGNATURE, nil, nil, IEND}
local generate_png = function(w, h, chunk)
	local IHDR = create_IHDR(w, h)
	local IDAT = create_IDAT(w, h, chunk)

	to_return[2] = IHDR
	to_return[3] = IDAT

	return concat(to_return, "", 1, 4)
end

return generate_png
--PATH addons/____sui/lua/sui/vgui/sui_property_sheet.lua:
local draw = draw
local surface = surface
local vgui = vgui

local TYPE_MATERIAL = TYPE_MATERIAL

local RealFrameTime = RealFrameTime
local IsValid = IsValid
local Lerp = Lerp
local pairs = pairs
local TypeID = TypeID

local TDLib_Classes = sui.TDLib.LibClasses
local TextColor = TDLib_Classes.TextColor
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local PROPERTY_SHEET_FONT = SUI.CreateFont("PropertySheet", "Roboto Regular", 18)

local PANEL = {}

AccessorFunc(PANEL, "m_FontName", "Font", FORCE_STRING)

function PANEL:Init()
	self.tabs = {}

	self:SetFont(PROPERTY_SHEET_FONT)

	local tab_scroller = self:Add("DHorizontalScroller")
	tab_scroller:Dock(TOP)

	self.tabs_tall = 26
	self.tab_scroller = tab_scroller

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function PANEL:ScaleChanged()
	self.tab_scroller:SetTall(SUI.Scale(self.tabs_tall))

	for k, v in pairs(self.tab_scroller.Panels) do
		if v:IsValid() then
			if v.Material then
				v:SetWide(self.tab_scroller:GetTall())
			else
				v:SizeToContentsX()
			end
		end
	end

	self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
	self:RoundedBox("Background", 1, 0, 0, w, self.tab_scroller:GetTall(), SUI.GetColor("property_sheet_bg"))
end

function PANEL:PaintOver(w, h)
	local active_tab = self:GetActiveTab()
	if not IsValid(active_tab) then return end

	local tab_scroller = self.tab_scroller
	local offset = tab_scroller:GetTall() - SUI.Scale(1)

	local x = active_tab:LocalToScreen(0) - self:LocalToScreen(0)

	if not self.activeTabX then
		self.activeTabX = x
		self.activeTabW = active_tab:GetWide()
	end

	local delta = RealFrameTime() * 6
	if delta then
		self.activeTabX = Lerp(delta, self.activeTabX, x)
		self.activeTabW = Lerp(delta, self.activeTabW, active_tab:GetWide())
	end

	self:RoundedBox("Background2", 1, self.activeTabX, tab_scroller.y + offset, self.activeTabW, SUI.Scale(1), SUI.GetColor("property_sheet_tab_active"))
end

local tab_Paint = function(s, w, h)
	s.circle_click_color = SUI.GetColor("property_sheet_tab_click")
	if s.property_sheet:GetActiveTab() == s then
		TextColor(s, SUI.GetColor("property_sheet_tab_active"))
	else
		TextColor(s, SUI.GetColor("property_sheet_tab"))
	end
end

local tab_DoClick = function(s)
	s.parent:SetActiveTab(s)
end

local image_paint = function(s, w, h)
	surface.SetDrawColor(color_white)
	surface.SetMaterial(s.Material)
	surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, w - 10, h - 10, 0)
end

function PANEL:AddSheet(name, load_func)
	local tab = vgui.Create("DButton")
	if TypeID(name) == TYPE_MATERIAL then
		tab:SetText("")
		tab.Material = name
		tab.Paint = image_paint
		tab:SetWide(self.tab_scroller:GetTall())
	else
		tab:SetFont(self:GetFont())
		tab:SetText(name)
		tab:SetTextInset(10, 0)
		tab:SizeToContentsX()

		tab.Paint = tab_Paint
	end

	tab.parent = self
	tab.DoClick = tab_DoClick

	tab.load_func = load_func
	tab.property_sheet = self

	tab.On = TDLib_Classes.On
	TDLib_Classes.CircleClick(tab)

	self.tab_scroller:AddPanel(tab)

	if not self:GetActiveTab() then
		self:SetActiveTab(tab)
	end

	table.insert(self.tabs, tab)

	return tab
end

function PANEL:GetActiveTab()
	return self.active_tab
end

function PANEL:SetActiveTab(new_tab)
	if IsValid(new_tab) and not IsValid(new_tab.panel) then
		local panel = new_tab.load_func(self)
		panel:SetParent(self)
		panel:SetVisible(false)

		panel.tab = new_tab
		new_tab.panel = panel
	end

	if self.active_tab and IsValid(self.active_tab.panel) then
		self.active_tab.panel:SetVisible(false)
	end

	if IsValid(new_tab) then
		new_tab.panel:SetVisible(true)
	end

	self.active_tab = new_tab
end

sui.register("PropertySheet", PANEL, "EditablePanel")
--PATH addons/____sam/lua/sam/sh_motd.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config
local command = sam.command

if CLIENT then
	config.add_menu_setting("MOTD URL (Leave empty for no MOTD)", function()
		local entry = vgui.Create("SAM.TextEntry")
		entry:SetPlaceholder("")
		entry:SetNoBar(true)
		entry:SetConfig("MOTDURL", "")

		return entry
	end)
end

local motd
local load_motd = function()
	local url = config.get("MOTDURL", "")
	if url == "" then
		command.remove_command("motd")
		hook.Remove("HUDPaint", "SAM.OpenMOTD")
		return
	end

	if IsValid(motd) then
		motd:Remove()
	end

	command.set_category("Menus")

	command.new("motd")
		:Help("Open MOTD menu")
		:OnExecute(function(ply)
			sam.netstream.Start(ply, "OpenMOTD")
		end)
	:End()

	if CLIENT then
		function sam.menu.open_motd()
			if IsValid(motd) then
				motd:Remove()
			end

			motd = vgui.Create("SAM.Frame")
			motd:Dock(FILL)
			motd:DockMargin(40, 40, 40, 40)
			motd:MakePopup()

			function motd.close.DoClick()
				motd:Remove()
			end

			local html = motd:Add("DHTML")
			html:Dock(FILL)
			html:OpenURL(url)
		end

		sam.netstream.Hook("OpenMOTD", function()
			sam.menu.open_motd()
		end)

		hook.Add("HUDPaint", "SAM.OpenMOTD", function()
			sam.menu.open_motd()
			hook.Remove("HUDPaint", "SAM.OpenMOTD")
		end)
	end
end
config.hook({"MOTDURL"}, load_motd)
--PATH addons/____sam/lua/sam/modules/tellall.lua:
if SAM_LOADED then return end
--
local sam, command = sam, sam.command
--
command.set_category( 'NEW' )
--
command.new( 'tellall' ):SetPermission( 'tellall', 'superadmin' ):AddArg( 'text', {
    hint = 'message',
    check = function( str ) return str:match( '%S' ) ~= nil end
} ):GetRestArgs():Help( 'Відображення повідомлень на екрані всіх гравців' ):OnExecute( function( _, message )
    net.Start( 'TellAllMessage' )
    net.WriteString( message )
    net.Broadcast()
end ):End()

if CLIENT then
    local currentPanel = nil
    local tellallcol = Color( 37, 40, 47 )
    net.Receive( 'TellAllMessage', function()
        local message = net.ReadString()
        surface.SetFont( onyx.Font( 'Comfortaa@16' ) )
        local textWidth, textHeight = surface.GetTextSize( message )
        local panelHeight = textHeight + 20
        local panel = vgui.Create( 'onyx.Label' )
        panel:SetSize( math.max( textWidth + 20, 400 ), panelHeight )
        panel:SetAlpha( 0 )
        panel:SetText( message )
        panel:CenterText()
        if currentPanel then
            panel:SetPos( ScrW() * 0.5 - panel:GetWide() * 0.5, currentPanel:GetY() + currentPanel:GetTall() + 10 )
        else
            panel:SetPos( ScrW() * 0.5 - panel:GetWide() * 0.5, 50 )
        end

        panel.Paint = function( _, w, h ) draw.RoundedBox( 10, 0, 0, w, h, tellallcol ) end
        panel:AlphaTo( 255, 0.3, 0, function()
            timer.Simple( 5, function()
                if IsValid( panel ) then
                    panel:AlphaTo( 0, 0.3, 0, function()
                        panel:Remove()
                        if currentPanel == panel then currentPanel = nil end
                    end )
                end
            end )
        end )

        currentPanel = panel
    end )
else
    util.AddNetworkString( 'TellAllMessage' )
end
--PATH addons/____sam/lua/sam/modules/ttt.lua:
if SAM_LOADED then return end

local run = function(fn)
	if not GAMEMODE then
		timer.Simple(0, fn)
	else
		fn()
	end
end

run(function()
	if engine.ActiveGamemode() ~= "terrortown" then return end

	local sam, command, language = sam, sam.command, sam.language

	command.set_category("TTT")

	command.new("setslays")
		:SetPermission("setslays", "admin")

		:AddArg("player", {single_target = true})
		:AddArg("number", {hint = "amount", optional = true, min = 1, default = 1, round = true})

		:Help("setslays_help")

		:OnExecute(function(ply, targets, amount)
			targets[1]:sam_set_pdata("slays_amount", amount)

			sam.player.send_message(nil, "setslays", {
				A = ply, T = targets, V = amount
			})
		end)
	:End()

	command.new("removeslays")
		:SetPermission("removeslays", "admin")

		:AddArg("player", {single_target = true})

		:Help("removeslays_help")

		:OnExecute(function(ply, targets, amount)
			local target = targets[1]
			target:sam_set_pdata("slays_amount", nil)
			target:SetForceSpec(false)

			sam.player.send_message(nil, "removeslays", {
				A = ply, T = targets
			})
		end)
	:End()

	OldBeginRound = OldBeginRound or BeginRound
	function BeginRound(...)
		local players = player.GetAll()
		for i = 1, #players do
			local ply = players[i]

			local slays = ply:sam_get_pdata("slays_amount")
			if not slays then continue end

			if not ply:IsSpec() then
				ply:Kill()
			end

			GAMEMODE:PlayerSpawnAsSpectator(ply)

			ply:SetTeam(TEAM_SPEC)
			ply:SetForceSpec(true)
			ply:Spawn()

			ply:SetRagdollSpec(false) -- dying will enable this, we don't want it here

			slays = slays - 1

			if slays == 0 then
				timer.Simple(0, function()
					ply:SetForceSpec(false)
				end)
				ply:sam_set_pdata("slays_amount", nil)
			else
				ply:sam_set_pdata("slays_amount", slays)
			end

			sam.player.send_message(nil, "setslays_slayed", {
				T = {ply}, V = slays
			})
		end

		return OldBeginRound(...)
	end
end)
--PATH addons/__new_main_only_1st/lua/autorun/sck_bone_fix.lua:

if SERVER then util.AddNetworkString("sckbonefix_reset_bones") end

local function resetViewBones(ply, vm)
	local vm = vm or ply:GetViewModel()
	if !IsValid(vm) then return end
	
	if SERVER then 
		net.Start("sckbonefix_reset_bones")
		net.Send(ply)
		return
	end
	
	if (!vm:GetBoneCount()) then return end
	for i=0, vm:GetBoneCount() do
		vm:ManipulateBoneScale(i, Vector(1, 1, 1))
		vm:ManipulateBoneAngles(i, Angle(0, 0, 0))
		vm:ManipulateBonePosition(i, Vector(0, 0, 0))
	end
end

hook.Add("Initialize", "sckbonefix_setup", function()
	local player_table = FindMetaTable("Player")
	player_table.ResetViewBones = resetViewBones
end)


if CLIENT then
	net.Receive("sckbonefix_reset_bones", function()
		local p = LocalPlayer()
		if p.ResetViewBones then
			LocalPlayer():ResetViewBones()
		end
	end)
	
	return
end

hook.Add("PlayerSwitchWeapon", "sckbonefix_wepswitch", function(ply)
	ply:ResetViewBones()
end)

hook.Add("PlayerSpawn", "sckbonefix_plyspawn", function(ply)
	timer.Simple(0.1, function()
		if !IsValid(ply) or ply.ResetViewBones == nil then return end
		
		ply:ResetViewBones()
	end)
end)

--PATH addons/_boombox/lua/retroboombox/shared/sh_hooks.lua:
hook.Add( "PlayerSwitchWeapon", "PlayerSwitchWeapon.RetroBoombox", function( pPlayer, eOldWeapon, eNewWeapon )
	if IsValid( eOldWeapon ) and eOldWeapon.GetClass and eOldWeapon:GetClass() == "retroboombox_base" and eOldWeapon.Holster and isfunction( eOldWeapon.Holster ) then
		eOldWeapon:Holster()
	end
end )
--PATH addons/____slib/lua/autorun/slib_loader.lua:
local function slibInit()
    print("[slib] Loading")

    if SERVER then
        AddCSLuaFile("slib/sh_util.lua")
        include("slib/sv_storage.lua")
        include("slib/sh_util.lua")
    else
        include("slib/sh_util.lua")
    end
end

hook.Add("slib:loadBase", "slib.loadVGUI", function()
    slib.loadFolder("slib/vgui/", false, {{"slib/vgui/", "cl_sframe.lua"}})
end)

slibInit()
--PATH addons/____slib/lua/slib/sh_util.lua:
slib = slib or {}
slib.panels = slib.panels or {}
slib.cachedAvatars = slib.cachedAvatars or {}
slib.generalCooldowns = slib.generalCooldowns or {}

slib.config = {scale = {x = 1, y = 1}}

slib.getStatement = function(val)
    if isbool(val) then return "bool" end
    if isnumber(val) then return "int" end
    if istable(val) and val.r and val.g and val.b then return "color" end
    if istable(val) then return "table" end
    if isfunction(val) then return "function" end
    if isstring(val) then return "string" end

    return "bool"
end

local callNum = 1
local loadedCalls = {}

local function loadFile(folder, file)
    if string.StartWith(file, "sv_") or string.find(folder, "server") then
        if SERVER then
            include(folder .. file)
            loaded = true
        end
    elseif string.StartWith(file, "sh_") or string.find(folder, "shared") then
        AddCSLuaFile(folder .. file)
        include(folder .. file)
        loaded = true
    elseif string.StartWith(file, "cl_") or string.find(folder, "client") then
        AddCSLuaFile(folder .. file)
        if CLIENT then include(folder .. file) loaded = true end
    end

    if loaded then
        print("[slib] Loaded "..folder..file)

        return folder..file
    end
end

slib.loadFolder = function(folder, subdirectories, firstload, lastload, call)
    local files, directories = file.Find(folder .. "*", "LUA")
    loadedCalls[callNum] = loadedCalls[callNum] or {}

    if firstload then
        for k,v in pairs(firstload) do
            local result = loadFile(v[1], v[2])
            if !result then continue end
            loadedCalls[callNum][result] = true
        end
    end

    if lastload then
        for k,v in pairs(lastload) do
            loadedCalls[callNum][v[1]..v[2]] = true
        end
    end

    for k, v in pairs(files) do
        if loadedCalls[callNum][folder..v] then continue end
        loadFile(folder, v)
    end

    if subdirectories then
        for k,v in pairs(directories) do
            slib.loadFolder(folder..v.."/", true, nil, nil, call and call or callNum)
        end
    end

    if lastload then
        for k,v in pairs(lastload) do
            loadFile(v[1], v[2])
        end
    end

    if call then return end
    callNum = callNum + 1
end

slib.getCooldown = function(var)
    if !slib.generalCooldowns[var] then return true end
    
    return slib.generalCooldowns[var] and CurTime() >= slib.generalCooldowns[var]
end

slib.getTimeLeft = function(var)
    return slib.generalCooldowns[var] and slib.generalCooldowns[var] - CurTime() or 0
end

slib.setCooldown = function(var, cd)
    slib.generalCooldowns[var] = CurTime() + cd
end

slib.oldFunctions = {}

slib.wrapFunction = function(element, funcname, pre, post, returnresult)
    if !slib.oldFunctions[funcname.."Old"] then
        slib.oldFunctions[funcname.."Old"] = element[funcname]
    end

    element[funcname] = function(...)
        local result 
        
        if pre then
            local callback = pre(...)
            result = returnresult and callback or result
        end

        if isfunction(slib.oldFunctions[funcname.."Old"]) then
            result = slib.oldFunctions[funcname.."Old"](...) or result
        end 

        if post then
            local callback = post(...)
            result = returnresult and callback or result
        end

        return result
    end
end

slib.lang = slib.lang or {}

slib.setLang = function(addon, lang, id, str)
    slib.lang[addon] = slib.lang[addon] or {}
    slib.lang[addon][lang] = slib.lang[addon][lang] or {}

    slib.lang[addon][lang][id] = str
end

slib.getLang = function(addon, lang, id, ...)
    local args = {...}
    local unformatted = slib.lang[addon] and slib.lang[addon][lang] and slib.lang[addon][lang][id]

    if !unformatted then unformatted = slib.lang[addon] and slib.lang[addon]["en"] and slib.lang[addon]["en"][id] or id end

    return table.IsEmpty(args) and unformatted or string.format(unformatted, ...)
end

slib.notify = function(str, ply)
    str = tostring(str)
    if SERVER then
        net.Start("slib.msg")
        net.WriteString(str)
        net.Send(ply)
    elseif CLIENT then
        print(str)
        notification.AddLegacy(str, 0, 5)
    end
end

local function differenciate(a, b)
    if !(isstring(a) == isstring(b)) or isbool(a) or isbool(b) then
        return tostring(a), tostring(b)
    end

    return a, b
end

slib.sortAlphabeticallyByKeyValues = function(tbl, ascending)
    local normaltable = {}
    local cleantable = {}
    
    for k,v in pairs(tbl) do
        table.insert(normaltable, k)
    end

    if ascending then
        table.sort(normaltable, function(a, b) a, b = differenciate(a, b) return a < b end)
    else
        table.sort(normaltable, function(a, b) a, b = differenciate(a, b) return a > b end)
    end

    for k,v in pairs(normaltable) do
        cleantable[v] = k
    end

    return cleantable
end

slib.sortAlphabeticallyByValue = function(tbl, ascending, keyvalue)
    if keyvalue then
        tbl = table.Copy(tbl)
    end

    if ascending then
        table.sort(tbl, function(a, b) a, b = differenciate(a, b) return a < b end)
    else
        table.sort(tbl, function(a, b) a, b = differenciate(a, b) return a > b end)
    end

    local cleantable = {}

    for k, v in pairs(tbl) do
        cleantable[v] = k
    end

    return keyvalue and cleantable or tbl
end

slib.sid64ToPly = slib.sid64ToPly or {}

if SERVER then
    slib.playerCache = slib.playerCache or player.GetAll()

    util.AddNetworkString("slib.msg")

    local punished = {}
    slib.punish = function(ply, type, msg, duration)
        local sid = ply:SteamID()

        if punished[sid] then return end
        punished[sid] = true

        if type == 1 then
            ply:Kick(msg)
        elseif type == 2 then
            if duration == nil then duration = 0 end
            if sAdmin then
                RunConsoleCommand("sa","banid", ply:SteamID64(), duration, msg)
            elseif ULib then
                ULib.ban(ply, duration, msg)
            elseif sam then
                RunConsoleCommand("sam","banid", sid, duration, msg)
            elseif xAdmin then
                if xAdmin.Config then
                    if xAdmin.Config.MajorVersion == 1 then
                        RunConsoleCommand("xadmin_ban", sid, duration, msg)
                    else
                        RunConsoleCommand("xadmin","ban", sid, duration, msg)
                    end
                end
            elseif SERVERGUARD then
                RunConsoleCommand("serverguard","ban", sid, duration, msg)
            else
                ply:Ban(duration, true)
            end
        end
    end

    slib.isBanned = function(sid64, callback)
        local sid32 = util.SteamIDFrom64(sid64)

        if sAdmin and sAdmin.isBanned then
            return sAdmin.isBanned(sid64)
        elseif sam and sam.player and sam.player.is_banned then
            return sam.player.is_banned(sid32, callback)
        elseif ulx and ULib and ULib.bans then
            return tobool(ULib.bans[sid32])
        elseif xAdmin and xAdmin.Admin and xAdmin.Admin.Bans then
            local data = xAdmin.Admin.Bans[sid64]
            local endtime = data.StartTime + (data.Length * 60)

            return data and (tonumber(endtime) <= os.time()) or false
        end
    end

    slib.setRank = function(ply, rank)
        local sid64 = ply:SteamID64()

        if sAdmin then
            RunConsoleCommand("sa", "setrankid", sid64, rank)
        elseif sam then
            RunConsoleCommand("sam", "setrankid", sid64, rank)
        elseif ulx then
            RunConsoleCommand("ulx", "adduserid", ply:SteamID(), rank)
        elseif xAdmin then
            RunConsoleCommand("xadmin", "setgroup", ply:Nick(), rank) -- yes
        end
    end

    hook.Add("PlayerInitialSpawn", "slib.reconnected", function(ply)
        local sid = ply:SteamID()
        if punished[sid] then
            punished[sid] = nil
        end
    end)

    hook.Add("PlayerInitialSpawn", "slib.FullLoaded", function( ply )
        table.insert(slib.playerCache, ply)
        local sid64 = ply:SteamID64()
        slib.sid64ToPly[sid64] = ply

        local id = sid64.."_slib"
        hook.Add( "SetupMove", id, function( self, mv, cmd )
            if self == ply and not cmd:IsForced() then
                hook.Run("slib.FullLoaded", ply)
                hook.Remove("SetupMove", id)
            end
        end )
    end)

    hook.Add("PlayerDisconnected", "slib.handleDisconnect", function(ply)
        table.RemoveByValue(slib.playerCache, ply)
    end)
end

if CLIENT then
    local blur = Material("pp/blurscreen")

    slib.DrawBlur = function(panel, amount)
        local x, y = panel:LocalToScreen(0, 0)
        local scrW, scrH = ScrW(), ScrH()
        surface.SetDrawColor(255, 255, 255)
        surface.SetMaterial(blur)
        for i = 1, 3 do
            blur:SetFloat("$blur", (i / 3) * (amount or 6))
            blur:Recompute()
            render.UpdateScreenEffectTexture()
            surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
        end
    end

    slib.getScaledSize = function(num, axis, scale)
        scale = scale or {x = 1, y = 1}

        if axis == "x" then
            num = ScrW() * (num/1920)

            num = num * scale.x
        end
    
        if axis == "y" or axis == nil then
            num = ScrH() * (num/1080)

            num = num * scale.y
        end
        
        return math.Round(num)
    end

    slib.cachedFonts = slib.cachedFonts or {}

    slib.createFont = function(fontname, size, thickness, ignorescale)
        size = size or 13
        thickness = thickness or 500
        local identifier = string.gsub(fontname, " ", "_")

        if !fontname or !size or !thickness then return end

        local name = "slib."..identifier..size.."."..thickness
        
        if ignorescale then name = "real_"..name end
        
        if slib.cachedFonts[name] then return name end

        surface.CreateFont( name, {
            font = fontname,
            size = ignorescale and size or slib.getScaledSize(size, "y"),
            weight = thickness,
        })

        slib.cachedFonts[name] = true

        return name
    end

    slib.colorCached = {}

    slib.lerpColor = function(identifier, wantedcolor, multiplier, nolerp)
        wantedcolor = table.Copy(wantedcolor)
        slib.colorCached[identifier] = slib.colorCached[identifier] or wantedcolor
        multiplier = multiplier or 1
        local basespeed = (RealFrameTime() * 3)
        local speed = basespeed * multiplier

        if minspeed then speed = minspeed > speed and minspeed or speed end
        
        for k,v in pairs(slib.colorCached[identifier]) do
            local percentageleft = math.abs(wantedcolor[k] - v)

            slib.colorCached[identifier][k] = math.Approach(v, wantedcolor[k], speed * (nolerp and 100 or percentageleft))
        end

        return slib.colorCached[identifier]
    end

    slib.numCached = {}
    slib.lerpNum = function(identifier, wantednum, multiplier, nolerp)
        slib.numCached[identifier] = slib.numCached[identifier] or wantednum
        multiplier = multiplier or 1
        local basespeed = (RealFrameTime() * 3)
        local speed = basespeed * multiplier

        local percentageleft = math.abs(wantednum - slib.numCached[identifier])

        slib.numCached[identifier] = math.Approach(slib.numCached[identifier], wantednum, speed * (nolerp and 100 or percentageleft))

        return math.Round(slib.numCached[identifier])
    end

    slib.drawTooltip = function(str, parent, align)
        local font = slib.createFont("Roboto", 13)
        local cursortposx, cursortposy = input.GetCursorPos()
        cursortposx = cursortposx + 15
        local x, y = cursortposx, cursortposy
       
        surface.SetFont(font)
        local strw, strh = surface.GetTextSize(str)
       
        local w = strw + slib.getScaledSize(6, "x")

        if align == 1 then
            local parentparent = parent:GetParent()
            if !IsValid(parentparent) then return end
            local posx, posy = parent:GetPos()
            x, y = parentparent:LocalToScreen(posx, posy)
            y = y + parent:GetTall()

            x = x + parent:GetWide() * .5

            x = x - w * .5
        end

        local tooltip = vgui.Create("EditablePanel")
        tooltip:SetMouseInputEnabled(false)
        tooltip:SetPos(x, y)
        tooltip:SetSize(w, slib.getScaledSize(22, "y"))
        tooltip:MakePopup()
    
        tooltip.Paint = function(s,w,h)
            if !parent:IsHovered() and !s:IsHovered() or !s:HasFocus() and !parent.clickable then s:Remove() end
    
            surface.SetDrawColor(slib.getTheme("maincolor", 10))
            surface.DrawRect(0, 0, w, h)
    
            surface.SetDrawColor(120, 120, 120, 200)
            surface.DrawOutlinedRect(0, 0, w, h)
    
            draw.SimpleText(str, font, slib.getScaledSize(3, "x"), h * .5, slib.getTheme("textcolor"), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end

        return tooltip
    end

    slib.createTooltip = function(str, parent)
        if !str or !parent then return end

        surface.SetFont(parent.font)
        local textw, texth = surface.GetTextSize(parent.name)


        local tooltipbutton = vgui.Create("DButton", parent)
		tooltipbutton:SetText("")
		tooltipbutton:Dock(LEFT)
		tooltipbutton:DockMargin(textw + slib.getScaledSize(6,"x"),slib.getScaledSize(5,"x"),0,slib.getScaledSize(5,"x"))
        tooltipbutton:SetWide(slib.getScaledSize(25, "y") - (slib.getScaledSize(5,"x") + slib.getScaledSize(5,"x")))
        tooltipbutton.bg = slib.getTheme("maincolor")
        
        tooltipbutton.DoClick = function()
            tooltipbutton.clicked = !tooltipbutton.clicked
        end

		tooltipbutton.Paint = function(s,w,h)
            draw.RoundedBox(h * .5, 0, 0, w, h, s.bg)

			draw.SimpleText("?", slib.createFont("Roboto", 14), w * .5, h * .5, slib.getTheme("textcolor", -50), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

            if s.clickable and !s.clicked and IsValid(s.tooltip) then
                s.tooltip:Remove()
            end

            if s:IsHovered() then
                if IsValid(s.tooltip) then return end
                s.tooltip = slib.drawTooltip(str, tooltipbutton)
            else
                s.clicked = nil
			end
        end
        
        return tooltipbutton
    end

    slib.theme = slib.theme or {}

    slib.setTheme = function(var, val)
        slib.theme[var] = val
    end

    slib.getTheme = function(var, offset)
        local val = slib.theme[var]

        if istable(val) then
            val = table.Copy(val)
            
            if offset then
                for k,v in pairs(val) do
                    val[k] = v + offset
                end

                if val.r and val.g and val.b and val.a then
                    for k,v in pairs(val) do
                        val[k] = math.Clamp(v, 0, 255)
                    end
                end
            end 
        end

        return val
    end

    slib.isValidSID64 = function(sid64)
        return util.SteamIDFrom64(sid64) != "STEAM_0:0:0"
    end

    local loading_ico = Material("slib/load.png", "smooth")

    local matCache = {}
    local fetched = {}
    
    file.CreateDir("slib")
    
    local proxy = ""--"https://proxy.duckduckgo.com/iu/?u=" -- Disabled for now, it doesn't work
    slib.ImgurGetMaterial = function(id) -- RETURN THE LOADING MATERIAL UNTIL IT IS FOUND!!!
        if !matCache[id] then
            local link = proxy.."https://i.imgur.com/"..id..".png"

            if file.Exists("slib/"..id..".png", "DATA") then
                matCache[id] = Material("data/slib/"..id..".png", "noclamp smooth")

                if matCache[id]:IsError() then
                    file.Delete("slib/"..id..".png")

                    if !fetched[link] then
                        slib.ImgurGetMaterial(id)
                    end
                end
            else
                if fetched[link] then return loading_ico, true end
                
                fetched[link] = true
                
                http.Fetch(link,
                    function(body)
                        file.Write("slib/"..id..".png", body)
                        matCache[id] = Material("data/slib/"..id..".png", "noclamp smooth")
                    end
                )
            end
        else
            return matCache[id]
        end
        
        return loading_ico, true
    end

    local cachedNames = {}
    local requestedNames = {}

    slib.findName = function(sid64, rtrn_sid64)
        if cachedNames[sid64] then return cachedNames[sid64] end

        local servercheck = player.GetBySteamID64(sid64)
        local steamcheck = false

        if servercheck then
            cachedNames[sid64] = servercheck:Nick()
        else
            if requestedNames[sid64] then return rtrn_sid64 and sid64 end
            requestedNames[sid64] = true
            local start = "<title>Steam Community :: "
            local theEnd = '<link rel="shortcut icon" href="/favicon.ico" type="image/'

            http.Fetch("http://steamcommunity.com/profiles/"..sid64,
                function(data)
                    local nameStart = select(1, string.find(data, start))
                    local nameEnd = select(1, string.find(data, theEnd))

                    if !nameStart or !nameEnd then return end

                    nameStart = nameStart + #start
                    nameEnd = nameEnd - 12

                    local nick = string.sub(data, nameStart, nameEnd)

                    cachedNames[sid64] = nick
                end
            )

            if !rtrn_sid64 then
                cachedNames[sid64] = "N/A"
            end
        end

        return rtrn_sid64 and sid64 or cachedNames[sid64]
    end

    local function saveImageFromURL(url, path, cb)
        http.Fetch(url, function(data)
            file.Write(path, data)

            if cb then
                cb()
            end
        end)
    end

    local fetchingAvatar = {}
    local default_ico = Material("slib/default_steam.png", "smooth")

    slib.findAvatar = function(sid64, medium)
        if !sid64 then return end
        
        local path = "slib/avatars/"..sid64..(medium and "_medium" or "_full")..".jpg"
        local size = medium and "medium" or "full"

        slib.cachedAvatars[size] = slib.cachedAvatars[size] or {}

        if !slib.cachedAvatars[size][sid64] or slib.cachedAvatars[size][sid64]:IsError() then
            if file.Exists(path, "DATA") then
                slib.cachedAvatars[size][sid64] = Material("data/"..path, "smooth noclamp")

                return slib.cachedAvatars[size][sid64]
            end

            local start = "https://avatars.akamai.steamstatic.com/"
            local theEnd = '">'

            if !fetchingAvatar[sid64] then
                http.Fetch( "http://steamcommunity.com/profiles/"..sid64,
                    function(data)
                        local avatarStart = select(1, string.find(data, start))
                        local avatarEnd = avatarStart + select(1, string.find(string.sub(data, avatarStart, #data), theEnd))

                        if !avatarStart or !avatarEnd then return end

                        local imgLink = string.sub(data, avatarStart, avatarEnd - 2)

                        if medium then
                            imgLink = string.Replace(imgLink, "_full", "_medium")
                        end

                        saveImageFromURL(imgLink, path, function()
                            file.CreateDir("slib/avatars/")
                            slib.cachedAvatars[size][sid64] = Material("data/"..path, "smooth noclamp")
                        end)

                        cachedNames[sid64] = nick
                    end
                )

                fetchingAvatar[sid64] = true
            end

            return default_ico
        end

        return slib.cachedAvatars[size][sid64]
    end

    local storedImages = file.Find("slib/avatars/*.jpg", "DATA")

    for k,v in ipairs(storedImages) do
        if os.time() - file.Time("slib/avatars/"..v, "DATA") >= 259200 then
            file.Delete("slib/avatars/"..v)
        end
    end

    hook.Add("OnEntityCreated", "slib.CacheSid64ToPly", function(ent)
        if ent:IsPlayer() and !ent:IsBot() then
            local sid64 = ent:SteamID64()
            
            if !sid64 then return end

            slib.sid64ToPly[sid64] = ent
        end
    end)

    net.Receive("slib.msg", function(_, ply)
        slib.notify(net.ReadString())
    end)
end

hook.Run("slib:loadBase")
hook.Run("slib:loadedUtils")
--PATH addons/____sprinter/lua/s_printer/screens/cl_rackscreen.lua:
local margin, accent_col, successcolor, main_col, shade_5, shade_10, shade_20, shade_min10, text_col, text_colmin40, white, failcolor = 8, slib.getTheme("accentcolor"), slib.getTheme("successcolor"), slib.getTheme("maincolor"), slib.getTheme("maincolor", 5), slib.getTheme("maincolor", 10), slib.getTheme("maincolor", 20), slib.getTheme("maincolor", -10), slib.getTheme("textcolor"), slib.getTheme("textcolor", -40), Color(255,255,255), slib.getTheme("failcolor")
local money, income, withdraw, eject, repair_ico = Material("sprinter/money.png", "smooth"), Material("sprinter/income.png", "smooth"), Material("sprinter/withdraw.png", "smooth"), Material("sprinter/eject.png", "smooth"), Material("sprinter/repair.png", "smooth")
local back_ico, charge_ico, logs_ico, upgrades_ico, settings_ico, power_ico, manage_ico, auth_ico, lock_ico, fingerprint_ico, hack_ico, upgradeall_ico = Material("sprinter/back.png", "smooth"), Material("sprinter/energy.png", "smooth"), Material("sprinter/log.png", "smooth"), Material("sprinter/upgrade.png", "smooth"), Material("sprinter/settings.png", "smooth"), Material("sprinter/power.png", "smooth"), Material("sprinter/manage.png", "smooth"), Material("sprinter/user.png", "smooth"), Material("sprinter/lock.png", "smooth"), Material("sprinter/fingerprint.png", "smooth"), Material("sprinter/hacking.png", "smooth"), Material("sprinter/upgrade-all.png", "smooth")
local console_ico, minigame_bg, minigame_base, minigame_dot = Material("sprinter/console.png", "smooth"), Material("sprinter/minigame-bg.png", "smooth"), Material("sprinter/minigame-base.png", "smooth"), Material("sprinter/minigame-dot.png", "smooth")
local popup_menu_bg, dot_col, green_bg = Color(shade_min10.r, shade_min10.g, shade_min10.b, 250), Color(white.r, white.g, white.b, 100), Color(10, 119, 0)

local function openPrinterOption(ent, slot, page)
    ent.stopHover = true

    if IsValid(ent.rackScreen.main) then
        ent.rackScreen.main:SetVisible(false)
    end

    local printer = slot and ent:hasPrinter(slot)
    if slot and !IsValid(printer) then return end

    local oldtitle = ent.rackScreen.topbar.title
    ent.rackScreen.topbar.title = printer and printer.name or page
    local width, height = ent.rackScreen:GetWide(), ent.rackScreen:GetTall() - 45
    local frame = vgui.Create("EditablePanel", ent.rackScreen)
    frame:SetPos(0, 45)
    frame:SetSize(width, height)

    frame.OnRemove = function()
        if IsValid(ent) then
            if ent.rackScreen and IsValid(ent.rackScreen.main) then
                ent.rackScreen.main:SetVisible(true)
            end
            ent.stopHover = nil
        end
    end

    frame.Paint = function(s,w,h)
        if slot and !IsValid(ent:hasPrinter(slot)) then frame:Remove() end
        surface.SetDrawColor(main_col)
        surface.DrawRect(0, 0, w, h)
    end

    local topbar = vgui.Create("EditablePanel", frame)
    topbar:SetSize(width, 40)
    topbar.Paint = function(s,w,h)
        surface.SetDrawColor(shade_10)
        surface.DrawRect(0,0,w,h)

        surface.SetDrawColor(shade_20)
        surface.DrawRect(0,h - 1,w,1)

        draw.SimpleText(slot and page or "", slib.createFont("NasalizationRg-Regular", 32, nil, true), w * .5, h * .5, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    local back = vgui.Create("SButton", topbar)
    back:SetPos(5,0)
    back:SetSize(40,40)
    back.triggered = false
    back.Paint = function(s,w,h)
        if slot and !IsValid(ent:hasPrinter(slot)) then s.DoClick(true) end
        if s.Hovered and !sPrinter.ShouldDraw(ent) then s.Hovered = false end
        surface.SetDrawColor(slib.lerpColor(s, ent.page == slib.getLang("sprinter", sPrinter.config["language"], "main") and transparent or (s.Hovered and accent_col or white)))
        surface.SetMaterial(back_ico)
        local iconsize = h * .8
        surface.DrawTexturedRect(w * .5 - iconsize * .5, h * .5 - iconsize * .5, iconsize, iconsize)
    end

    back.DoClick = function(nosound)
        if ent.page == slib.getLang("sprinter", sPrinter.config["language"], "main") or back.triggered then return end
        if !nosound then surface.PlaySound("buttons/button15.wav") end
        frame:Remove()
        ent.rackScreen.topbar.title = oldtitle
        ent.overlayDrawn = nil
        back.triggered = true
    end

    local canvas = vgui.Create("SScrollPanel", frame)
    canvas:SetPos(0, 40)
    canvas:SetSize(width, height - 40)
    canvas:GetCanvas():DockPadding(margin,margin,margin,margin)
    canvas.PaintOver = function(s,w,h)
        if #canvas:GetCanvas():GetChildren() < 1 then
            draw.SimpleText(slib.getLang("sprinter", sPrinter.config["language"], "nothing-to-show"), slib.createFont("NasalizationRg-Regular", 32, nil, true), w * .5, h * .5, text_colmin40, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end

    local scrollbar = canvas:GetVBar()

    local scrollbarw, scrollbarh = scrollbar:GetWide(), canvas:GetTall()

    local upButtn = vgui.Create("SButton", scrollbar)
    upButtn:SetSize(scrollbarw, scrollbarh * .5)
    upButtn.Paint = function(s)
        if input.IsKeyDown(KEY_E) and s.Hovered and (!s.lastClick or (CurTime() - s.lastClick > .2)) then
            s.lastClick = CurTime()
            s.DoClick()
        end
    end

    upButtn.DoClick = function()
        local curScroll = scrollbar:GetScroll()
        scrollbar:SetScroll(curScroll - (40 + margin))
    end

    local downButtn = vgui.Create("SButton", scrollbar)
    downButtn:SetSize(scrollbarw, scrollbarh * .5)
    downButtn:SetPos(0, scrollbarh * .5)
    downButtn.Paint = function(s)
        if input.IsKeyDown(KEY_E) and s.Hovered and (!s.lastClick or (CurTime() - s.lastClick > .2)) then
            s.lastClick = CurTime()
            s.DoClick()
        end
    end

    downButtn.DoClick = function()
        local curScroll = scrollbar:GetScroll()
        scrollbar:SetScroll(curScroll + (40 + margin))
    end

    if page == "Logs" then 
        if !printer.addedLogs then
            printer.addedLogs = true
            net.Start("sP:Networking")
            net.WriteEntity(printer)
            net.WriteUInt(4,3)
            net.WriteUInt(2,2)
            net.SendToServer()
        end

        sPrinter.addLogEntries(printer, canvas)
    elseif page == "Settings" then
        sPrinter.addSettings(printer, canvas)
    elseif page == "Upgrades" then
        sPrinter.addUpgrades(printer, canvas)
    elseif page == slib.getLang("sprinter", sPrinter.config["language"], "authorization") then
        for k,v in ipairs(player.GetAll()) do
            if v == LocalPlayer() or v:IsBot() then continue end
            local ply = vgui.Create("SStatement", canvas)
            ply:SetTall(55)
            ply:DockMargin(0,0,0,margin)
            ply.font = slib.createFont("NasalizationRg-Regular", 32, nil, true)
            ply.Paint = function(s,w,h)
                if !IsValid(v) then s:Remove() return end
                surface.SetDrawColor(shade_10)
                surface.DrawRect(0, 0, w, h)
    
                draw.SimpleText(v:Nick(), s.font, 3, h * .5, text_colmin40, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
            end

            local sid64 = v:SteamID64()

            local _, element = ply:addStatement(name, ent.authorized[sid64] or false)
            element:DockMargin(5,5,5,5)
            element:SetWide(45)
    
            element.onValueChange = function(newval)
                net.Start("sP:Networking")
                net.WriteEntity(ent)
                net.WriteUInt(5,3)
                net.WriteUInt(1,2)
                net.WriteUInt(v:EntIndex(), 17)
                net.WriteBool(newval)
                net.SendToServer()

                ent.authorized[sid64] = newval or nil
            end
        end
    end

    ent.overlayDrawn = true

    topbar:MoveToFront()

    return printer
end

local handleWordGeneration = {}

local function getRandomHackWord(ent)
    local v, k = table.Random(sPrinter.config["hack_words"])
    handleWordGeneration[ent] = handleWordGeneration[ent] or {}
    
    if (handleWordGeneration[ent].cd or 0) < CurTime() then
        handleWordGeneration[ent].word = k

        handleWordGeneration[ent].cd = CurTime() + .1
    end

    return handleWordGeneration[ent].word
end

local ico_size = 148
local hack_size = 280

sPrinter.drawRackScreen = function(ent, opacity)
    local owner = ent:Getowning_ent()
    if !IsValid(ent.rackScreen) then
        ent.authorized = ent.authorized or {}
        
        ent.rackScreen = vgui.Create("EditablePanel")
        ent.rackScreen:SetSize(540, 598)
        ent.rackScreen:DockPadding(0,45,0,0)
        ent.rackScreen:SetPaintedManually(true)

        local hookName = "sP:DisableScreen_"..ent:EntIndex()
        hook.Add("sP:MouseEnabled", hookName, function(enabled)
            if !IsValid(ent) or !IsValid(ent.rackScreen) then hook.Remove("sP:MouseEnabled", hookName) return end

            ent.rackScreen:SetMouseInputEnabled(!enabled)
        end)

        ent.rackScreen.Paint = function(s,w,h)
            if s:IsMouseInputEnabled() == sPrinter.isMouseEnabled then s:SetMouseInputEnabled(!sPrinter.isMouseEnabled) end
            
            surface.SetDrawColor(main_col)
            surface.DrawRect(0,0,w,h)
        end

        ent.rackScreen.offset = 0
        ent.rackScreen.dotrotation = math.random(0,360)
        ent.rackScreen.hackRotation = ent.rackScreen.dotrotation + 10 
        ent.rackScreen.hackRotation = ent.rackScreen.hackRotation > 360 and ent.rackScreen.hackRotation - 360 or ent.rackScreen.hackRotation
        ent.rackScreen.hackCount = 0
        ent.rackScreen.hackDirection = true

        local animDown = true
        local console_size = 24

        ent.rackScreen.PaintOver = function(s,w,h)
            if ent:GetLocked() then
                local fps = math.Round(1/FrameTime())
                local lply = LocalPlayer()
                local canOpen = owner == lply or ent.authorized[lply:SteamID64()]

                if s:IsHovered() then
                    if input.IsKeyDown(KEY_E) then
                        if !s.clicked then
                            s.clicked = true
                            if !canOpen and !s.crackScreen then
                                s.crackScreen = true
                                ent.rackScreen.dotrotation = math.random(0,360)
                                ent.rackScreen.hackRotation = ent.rackScreen.dotrotation + 10 
                                ent.rackScreen.hackRotation = ent.rackScreen.hackRotation > 360 and ent.rackScreen.hackRotation - 360 or ent.rackScreen.hackRotation
                                
                                ent:HackHandler(false)
                            return end

                            if s.crackScreen then
                                local result = math.abs(s.hackRotation - s.dotrotation)
                                
                                if result <= 10 then
                                    surface.PlaySound("buttons/button14.wav")
                                    s.dotrotation = math.random(0,360)
                                    s.hackRotation = s.dotrotation + math.random(10,20) 
                                    s.hackRotation = s.hackRotation > 360 and s.hackRotation - 360 or s.hackRotation

                                    s.hackCount = s.hackCount + 1
                                    
                                    if s.hackCount >= 3 then
                                        s.hackedSuccess = true
                                    end

                                    if math.random(0,100) > 50 then
                                        s.hackDirection = !s.hackDirection
                                    end
                                else
                                    surface.PlaySound("buttons/blip1.wav")
                                    s.hackfailed = CurTime() + 1

                                    timer.Simple(1, function()
                                        if !IsValid(s) then return end
                                        s.crackScreen = nil
                                        s.hackCount = 0
                                    end)
                                end
                            else
                                s.attemptedUnlock = true
                            end
                        end
                    elseif s.clicked then
                        if s.hackedSuccess then
                            ent:HackHandler(true)
                            s.hackedSuccess = nil
                        end

                        if s.attemptedUnlock then
                            ent:AttemptUnlock()
                        end

                        s.clicked = nil
                    end
                end

                surface.SetDrawColor(main_col)
                surface.DrawRect(0, 0, w, h)
                
                local increment = 15 / fps
                s.offset = s.offset + (animDown and increment or -increment)
                if math.abs(s.offset) >= 8 then
                    animDown = !animDown
                end

                if !s.crackScreen then
                    surface.SetDrawColor(canOpen and white or successcolor)
                    surface.SetMaterial(canOpen and fingerprint_ico or hack_ico)
                    surface.DrawTexturedRect(w * .5 - ico_size * .5, h * .5 - ico_size * .5 - 65, ico_size, ico_size)

                    draw.SimpleText(canOpen and slib.getLang("sprinter", sPrinter.config["language"], "use_unlock") or slib.getLang("sprinter", sPrinter.config["language"], "use_hack"), slib.createFont("NasalizationRg-Regular", 38, nil, true), w *.5, h * .5 + 65 + s.offset, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                else
                    surface.SetDrawColor(shade_min10)
                    surface.DrawRect(0, 0, w, 35)

                    surface.SetDrawColor(white)
                    surface.SetMaterial(console_ico)
                    surface.DrawTexturedRect(8, 6, console_size, console_size)

                    draw.SimpleText(getRandomHackWord(ent)..".exe", slib.createFont("NasalizationRg-Regular", 20, nil, true), 36, 18, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

                    local centerh = (h - 35) * .5 + 35

                    surface.SetDrawColor(green_bg)
                    surface.SetMaterial(minigame_bg)
                    surface.DrawTexturedRect(0, 35, w, h - 35)

                    surface.SetDrawColor(white)
                    surface.SetMaterial(minigame_base)
                    surface.DrawTexturedRectRotated(w * .5, centerh, hack_size, hack_size, 0)

                    local increment = sPrinter.config["hack_speed"]

                    local curtime, elapsed = CurTime(), 0
                    if s.lastPaintOver and s.lastPaintOver >= curtime then increment = 0 else elapsed = s.lastPaintOver and curtime - s.lastPaintOver or 0 s.lastPaintOver = curtime + (1 / 60) end

                    if elapsed > 0 then
                        increment = increment + (elapsed / (1 / 60) * sPrinter.config["hack_speed"])
                    end

                    s.hackRotation = s.hackRotation + increment
                    s.hackRotation = s.hackRotation >= 360 and 0 or s.hackRotation

                    local isFailed = s.hackfailed and s.hackfailed > curtime

                    surface.SetDrawColor(isFailed and failcolor or green_bg)
                    surface.SetMaterial(minigame_dot)
                    surface.DrawTexturedRectRotated(w * .5, centerh, hack_size, hack_size, s.hackDirection and s.dotrotation or -s.dotrotation)

                    surface.SetDrawColor(dot_col)
                    surface.SetMaterial(minigame_dot)
                    surface.DrawTexturedRectRotated(w * .5, centerh, hack_size, hack_size, s.hackDirection and s.hackRotation or -s.hackRotation)

                    draw.SimpleText(s.hackCount.."/3", slib.createFont("NasalizationRg-Regular", 60, nil, true), w * .5, centerh, isFailed and failcolor or green_bg, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                end
            else
                s.crackScreen = nil
                s.hackCount = 0
            end

            sPrinter.DrawCursor(w, h, ent, 5)
        end

        ent.rackScreen.topbar = sPrinter.addTopbar(ent.rackScreen, ent)
        ent.rackScreen.topbar.title = slib.getLang("sprinter", sPrinter.config["language"], "rack")
        ent.rackScreen.topbar.PaintOver = function(s,w,h)
            if ent:drawingOverlay() or sPrinter.config["rack"]["godmode"] then return end

            local wide, height = 130, 20

            surface.SetDrawColor(main_col)
            surface.DrawRect(w - wide - h - (h * .8), h * .5 - height * .5, wide, height)

            surface.SetDrawColor(successcolor)
            surface.DrawRect(w - wide - h - (h * .8), h * .5 - height * .5, wide * (ent:Health() / 100), height)

            draw.SimpleText(math.Round(ent:Health()).."%", slib.createFont("NasalizationRg-Regular", 22, nil, true), w - wide - h - (h * .8) + 3, h * .5, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end

        ent.rackScreen.main = vgui.Create("EditablePanel", ent.rackScreen)
        ent.rackScreen.main:Dock(FILL)

        local bttnsize = ent.rackScreen.topbar:GetTall()

        local power_all = vgui.Create("SButton", ent.rackScreen.topbar)
        power_all:SetSize(bttnsize, bttnsize)
        power_all:SetPos(ent.rackScreen.topbar:GetWide() - bttnsize, 0)
        power_all.Paint = function(s,w,h)
            if ent:drawingOverlay() then return end
            if s.Hovered and !sPrinter.ShouldDraw(ent) then s.Hovered = false end
            surface.SetDrawColor(slib.lerpColor(s, ent:GetPower() and failcolor or successcolor))
            surface.SetMaterial(power_ico)
            local iconsize = h * .6
            surface.DrawTexturedRect(margin, h * .5 - iconsize * .5, iconsize, iconsize)
        end

        power_all.DoClick = function()
            surface.PlaySound("buttons/button15.wav")
            net.Start("sP:Networking")
            net.WriteEntity(ent)
            net.WriteUInt(1,3)
            net.WriteUInt(3,2)
            net.SendToServer()
        end
        
        local manage = vgui.Create("SButton", ent.rackScreen.topbar)
        manage:SetSize(bttnsize, bttnsize)
        manage:SetPos(ent.rackScreen.topbar:GetWide() - bttnsize * 1.8, 0)
        manage.Paint = function(s,w,h)
            if ent:drawingOverlay() then return end
            if s.Hovered and !sPrinter.ShouldDraw(ent) then s.Hovered = false end
            surface.SetDrawColor(slib.lerpColor(s, s.Hovered and accent_col or white))
            surface.SetMaterial(manage_ico)
            local iconsize = h * .6
            surface.DrawTexturedRect(margin, h * .5 - iconsize * .5, iconsize, iconsize)
        end

        manage.DoClick = function()
            surface.PlaySound("buttons/button15.wav")

            local canRepair = !sPrinter.config["rack"]["godmode"] and ent:Health() < 100
            local buttonCount = !canRepair and 2 or 3

            local canUpgradeAll = ent:GetUpgradeAllPrice() > 0
            if canUpgradeAll then
                buttonCount = buttonCount + 1
            end

            local buttonW = 145
            local popup_menu = vgui.Create("SFrame", ent.rackScreen)
            popup_menu:SetSize(((buttonW + margin) * buttonCount) + margin, 85 + (margin * 2) + popup_menu.topbarheight)
            :Center()
            :SetBG(true, false, popup_menu_bg)
            :addCloseButton()
            :setTitle(slib.getLang("sprinter", sPrinter.config["language"], "management"))
            :SetDraggable(false)
            
            if canRepair then
                local rep_price = sPrinter.config["currency"]..string.Comma(sPrinter.config["rack_repair_price"])
                local repair = sPrinter.addButton(popup_menu.frame, ent, function() return ent:Health() >= 100 and slib.getLang("sprinter", sPrinter.config["language"], "full_hp") or rep_price end, function()
                    if ent:Health() >= 100 then return end
                    
                    net.Start("sP:Networking")
                    net.WriteEntity(ent)
                    net.WriteUInt(2,3)
                    net.WriteUInt(2,2)
                    net.WriteBool(false)
                    net.SendToServer()

                    popup_menu:Remove()
                end, repair_ico)
                repair:SetWide(buttonW)
                repair:Dock(LEFT)
                repair:DockMargin(margin,margin,0,margin)
                repair.inverted = true

                repair.PaintOver = function(s)
                    if s.nextUpdate and CurTime() < s.nextUpdate then return end
                    s.nextUpdate = CurTime() + 1
        
                    s.resetText()
                end
            end

            local auth = sPrinter.addButton(popup_menu.frame, ent, slib.getLang("sprinter", sPrinter.config["language"], "authorize"), function()
                if ent:Getowning_ent() ~= LocalPlayer() then
                    slib.notify(sPrinter.config["prefix"]..slib.getLang("sprinter", sPrinter.config["language"], "insufficient-permissions"))
                return end

                openPrinterOption(ent, nil, slib.getLang("sprinter", sPrinter.config["language"], "authorization"))
                popup_menu:Remove()
            end, auth_ico)
            auth:SetWide(buttonW)
            auth:Dock(LEFT)
            auth:DockMargin(margin,margin,0,margin)
            auth.inverted = true

            local lock = sPrinter.addButton(popup_menu.frame, ent, slib.getLang("sprinter", sPrinter.config["language"], "lock"), function()
                if ent:Getowning_ent() ~= LocalPlayer() and !ent.authorized[LocalPlayer():SteamID64()] then
                    slib.notify(sPrinter.config["prefix"]..slib.getLang("sprinter", sPrinter.config["language"], "insufficient-permissions"))
                return end

                net.Start("sP:Networking")
                net.WriteEntity(ent)
                net.WriteUInt(5,3)
                net.WriteUInt(0,2)
                net.WriteBool(true)
                net.SendToServer()

                popup_menu:Remove()
            end, lock_ico)
            lock:SetWide(buttonW)
            lock:Dock(LEFT)
            lock:DockMargin(margin,margin,0,margin)
            lock.inverted = true

            if !canUpgradeAll then return end

            local upgrade_all = sPrinter.addButton(popup_menu.frame, ent, slib.getLang("sprinter", sPrinter.config["language"], "upgrade_all"), function()
                if ent:Getowning_ent() ~= LocalPlayer() and !ent.authorized[LocalPlayer():SteamID64()] then
                    slib.notify(sPrinter.config["prefix"]..slib.getLang("sprinter", sPrinter.config["language"], "insufficient-permissions"))
                return end
                
                local price = ent:GetUpgradeAllPrice()

                if price <= 0 then
                    slib.notify(sPrinter.config["prefix"]..slib.getLang("sprinter", sPrinter.config["language"], "already_upgraded"))
                return end

                sPrinter.MakePopup(ent, ent.rackScreen, slib.getLang("sprinter", sPrinter.config["language"], "this-will-cost", sPrinter.config["currency"]..string.Comma(price)), function()
                    net.Start("sP:Networking")
                    net.WriteEntity(ent)
                    net.WriteUInt(5,3)
                    net.WriteUInt(3,2)
                    net.SendToServer()
                end)

                popup_menu:Remove()
            end, upgradeall_ico)
            upgrade_all:SetWide(buttonW)
            upgrade_all:Dock(LEFT)
            upgrade_all:DockMargin(margin,margin,0,margin)
            upgrade_all.inverted = true

            local childs = popup_menu.frame:GetChildren()

            local function moveButtonsToRow(row, childs)
                local childIndex = row.i
                if row.i == 2 then childIndex = 3 end -- Just to target the childs of the frame

                childs[childIndex]:SetParent(row)
                childs[childIndex + 1]:SetParent(row)

                childs[childIndex]:DockMargin(margin, margin * (row.i == 2 and .5 or 1), 0, margin * (row.i == 2 and 1 or .5))
                childs[childIndex + 1]:DockMargin(margin, margin * (row.i == 2 and .5 or 1), 0, margin * (row.i == 2 and 1 or .5))

            end

            if #childs > 3 then
                for i = 1, 2, 1 do
                    local row = vgui.Create("EditablePanel", popup_menu.frame)
                    row:Dock(TOP)
                    row.i = i
                    row:SetTall(85 + margin)

                    moveButtonsToRow(row, childs)
                end

                popup_menu:SetSize(((buttonW + margin) * 2) + margin, (85 * 2) + (margin * 2) + popup_menu.topbarheight)
                :Center()
            end
        end

        local last = true
        local iteration = 0
        local made = 0
        for i= 1, 8 do
            local gap = margin
            local parentWide = ent.rackScreen:GetWide()
            local width, height = (parentWide * 0.5) - (gap * 1.5), 105
            local slot = vgui.Create("SButton", ent.rackScreen.main)
            local x, y = last and gap or parentWide - width - gap, gap + iteration * (height + gap)
            slot:setTitle(i)
            slot:SetSize(width, height)
            slot:SetPos(x, y)
            slot.Paint = function(s,w,h)
                if ent:drawingOverlay() then return end
                surface.SetDrawColor(shade_10)
                surface.DrawRect(0,0,w,h)

                surface.SetDrawColor(shade_5)
                surface.DrawRect(0, 0, w, margin + 20 + margin)

                local printer = ent:hasPrinter(i)
                draw.SimpleText(IsValid(printer) and printer.name or slib.getLang("sprinter", sPrinter.config["language"], "empty"), slib.createFont("NasalizationRg-Regular", 20, nil, true), margin, margin, IsValid(printer) and text_col or text_colmin40, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
                draw.SimpleText("#"..i, slib.createFont("NasalizationRg-Regular", 20, nil, true), w - margin, margin, text_colmin40, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)
            end

            slot.PaintOver = function(s,w,h)
                if ent:drawingOverlay() then return end
                local printer = ent:hasPrinter(i)
                if IsValid(printer) then return end
                local field = h - (margin + 20 + margin)
                surface.SetDrawColor(shade_10)
                surface.DrawRect(0, margin + 20 + margin, w, field)

                draw.SimpleText(slib.getLang("sprinter", sPrinter.config["language"], "nothing-to-show"), slib.createFont("NasalizationRg-Regular", 20, nil, true), w * .5, margin + 20 + margin + (field * .5), text_colmin40, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            end

            local wide = width / 3

            local logs = sPrinter.addButton(slot, ent, "", function()
                local printer = openPrinterOption(ent, i, "Logs")

                if printer and !printer.addedLogs then
                    printer.addedLogs = true
                    net.Start("sP:Networking")
                    net.WriteEntity(printer)
                    net.WriteUInt(4,3)
                    net.WriteUInt(2,2)
                    net.SendToServer()
                end
            end, logs_ico, LEFT, margin, function() return IsValid(ent:hasPrinter(i)) end, true)
            logs:DockMargin(0, 20 + margin + margin, 0, 0)
            logs:SetWide(wide)
            logs.iconsize = wide * .5
    
            local upgrades = sPrinter.addButton(slot, ent, "", function() openPrinterOption(ent, i, "Upgrades") end, upgrades_ico, LEFT, margin, function() return IsValid(ent:hasPrinter(i)) end, true)
            upgrades:DockMargin(0, 20 + margin + margin, 0, 0)
            upgrades:SetWide(wide)
            upgrades.iconsize = wide * .45
            upgrades.PaintOver = function(s,w,h)
                if ent:drawingOverlay() then return end
                
                surface.SetDrawColor(shade_5)
                surface.DrawRect(0,0,2,h)
                surface.DrawRect(w - 2,0,2,h)
            end
    
            local settings = sPrinter.addButton(slot, ent, "", function()
                local printer = openPrinterOption(ent, i, "Settings")

                if printer and !printer.addedSettings then
                    printer.addedSettings = true
                    net.Start("sP:Networking")
                    net.WriteEntity(printer)
                    net.WriteUInt(4,3)
                    net.WriteUInt(1,2)
                    net.SendToServer()
                end
            end, settings_ico, LEFT, margin, function() return IsValid(ent:hasPrinter(i)) end, true)
            settings:DockMargin(0, 20 + margin + margin, 0, 0)
            settings:SetWide(wide)
            settings.iconsize = wide * .45

            made = made + 1
            last = !last
            iteration = made >= 2 and iteration + 1 or iteration

            made = made >= 2 and 0 or made
        end
        
        local manageButtons = vgui.Create("EditablePanel", ent.rackScreen.main)
        manageButtons:Dock(BOTTOM)
        manageButtons:DockMargin(margin,0,margin,margin)
        manageButtons:DockPadding(margin,margin + 32,margin,margin)
        manageButtons:SetTall(61 + 32 - margin)
        manageButtons.Paint = function(s,w,h)
            if ent:drawingOverlay() then return end

            surface.SetDrawColor(shade_5)
            surface.DrawRect(0,0,w,h)

            draw.SimpleText(slib.getLang("sprinter", sPrinter.config["language"], "recharge"), slib.createFont("NasalizationRg-Regular", 22, nil, true), (w * .15) + (margin * 2.5), 20, text_colmin40, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            draw.SimpleText(slib.getLang("sprinter", sPrinter.config["language"], "repair"), slib.createFont("NasalizationRg-Regular", 22, nil, true), (w * .5), 20, text_colmin40, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            draw.SimpleText(slib.getLang("sprinter", sPrinter.config["language"], "withdraw"), slib.createFont("NasalizationRg-Regular", 22, nil, true), (w * .85) - (margin * 2.5), 20, text_colmin40, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end

        local recharge = sPrinter.addButton(manageButtons, ent, function()
            local money = 0

            for i = 1,8 do
                local printer = ent:hasPrinter(i)
                
                if !IsValid(printer) or printer:GetBattery() >= (sPrinter.config["rack"]["min_recharge"] or 0.8) then continue end
                
                money = money + printer:GetRechargePrice()
            end

            return money > 0 and (sPrinter.config["currency"]..string.Comma(money)) or "N/A"
        end, 
        function()
            net.Start("sP:Networking")
            net.WriteEntity(ent)
            net.WriteUInt(2,3)
            net.WriteUInt(1,2)
            net.SendToServer()
        end, charge_ico, LEFT, margin)
        recharge:DockMargin(0, 0, margin * .5, 0)

        recharge.PaintOver = function(s)
            if s.nextUpdate and CurTime() < s.nextUpdate then return end
            s.nextUpdate = CurTime() + 1

            s.resetText()
        end

        local repair = sPrinter.addButton(manageButtons, ent, function()
            local money = 0
            
            for i = 1,8 do
                local printer = ent:hasPrinter(i)
                if !IsValid(printer) or printer:Health() >= 100 then continue end
                money = money + printer.data.repairprice
            end

            return money > 0 and (sPrinter.config["currency"]..string.Comma(money)) or "N/A"
        end, 
        function()
            net.Start("sP:Networking")
            net.WriteEntity(ent)
            net.WriteUInt(2,3)
            net.WriteUInt(2,2)
            net.WriteBool(true)
            net.SendToServer()
        end, repair_ico, FILL, margin)
        repair:DockMargin(margin * .5, 0, margin * .5, 0)

        repair.PaintOver = function(s)
            if s.nextUpdate and CurTime() < s.nextUpdate then return end
            s.nextUpdate = CurTime() + 1

            s.resetText()
        end

        local withdraw = sPrinter.addButton(manageButtons, ent, function() 
            local money = 0

            for i = 1,8 do
                local printer = ent:hasPrinter(i)
                if !IsValid(printer) then continue end
                money = money + printer:GetWithdrawAmount()
            end

            return money > 0 and (sPrinter.config["currency"]..string.Comma(money)) or "N/A"
        end,
        function()
            net.Start("sP:Networking")
            net.WriteEntity(ent)
            net.WriteUInt(1,3)
            net.WriteUInt(1,2)
            net.SendToServer()
        end, withdraw, RIGHT, margin)
        withdraw:DockMargin(margin * .5, 0, 0, 0)

        withdraw.PaintOver = function(s)
            if s.nextUpdate and CurTime() < s.nextUpdate then return end
            s.nextUpdate = CurTime() + 1

            s.resetText()
        end

        manageButtons.OnSizeChanged = function(s, w, h)
            local size = w / 3 - (margin * 2 / 3) + 1.5

            recharge:SetWide(size)
            repair:SetWide(size)
            withdraw:SetWide(size)
        end

        return
    else
        ent.rackScreen:SetAlpha(opacity)
    end

    local pos = ent:LocalToWorld(Vector(-5.25 - 5.65, -6.5, 42.52 + 32.9))
	local ang = ent:LocalToWorldAngles(Angle(0,0,80))

	vgui.Start3D2DS( pos, ang, .03 )
        ent.rackScreen:SPaint3D2D(ent)
    vgui.End3D2DS()
end

--- DONT REMOVE INT:76561198843434403
--PATH addons/__main/lua/autorun/tails.lua:
player_manager.AddValidModel( "Tails",  	"models/player/tails.mdl" );
player_manager.AddValidHands( "Tails", "models/player/c_tails.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "Tails", "models/player/tails.mdl" );
--PATH addons/____plogs/lua/ui/theme.lua:
if SERVER then return end

surface.CreateFont("category_buttons", {
    font = "Robot",
    size = 20,
    weight = 750,
	antialias = true,
})

local SKIN 	= {
	PrintName 	= 'SUP',
	Author 	 	= 'aStonedPenguin'
}

local color_sup 			= ui.col.SUP
local color_background 		= ui.col.Background
local color_outline 		= ui.col.Outline
local color_hover 			= ui.col.Hover
local color_button 			= ui.col.Button
local color_button_hover	= ui.col.ButtonHover
local color_close 			= ui.col.Close
local color_close_bg 		= ui.col.CloseBackground
local color_close_hover 	= ui.col.CloseHovered

local color_offwhite 		= ui.col.OffWhite
local color_flat_black 		= ui.col.FlatBlack
local color_black 			= ui.col.Black
local color_white 			= ui.col.White
local color_red 			= ui.col.Red

-- Frames    
function SKIN:PaintFrame(self, w, h)
	--draw.Blur(self)
	EQRoundBox(0, 0, w, h, color_background, color_outline)
	EQRoundBox(0, 0, w, 28, color_background, color_outline)
end

function SKIN:PaintPanel(self, w, h)
	EQRoundBox(0, 0, w, h, color_background, color_outline)
end

function SKIN:PaintShadow() end


-- Buttons    
function SKIN:PaintButton(self, w, h)
	if (not self.m_bBackground) then return end

	if self:GetDisabled() then
		EQRoundBox(0, 0, w, h, color_flat_black, color_outline)
	elseif (self.Active == true) then
		EQRoundBox(0, 0, w, h, self.BackgroundColor or color_sup, color_outline)
	else
		EQRoundBox(0, 0, w, h, (self.Hovered and color_button_hover or color_button), color_outline)
	end

	self:SetTextColor((self.Hovered and (not self:GetDisabled()) and (not self.Active)) and color_black or color_white)

	if (not self.fontset) then
		self:SetFont('ui.20')
		self.fontset = true
	end
end

function SKIN:PaintAvatarImage(self, w, h)
	if self.Hovered then
		EQRoundBox(0, 0, w, h, color_hover, color_outline)
	end
end


-- Close Button                                               
function SKIN:PaintWindowCloseButton(panel, w, h)
	if (not panel.m_bBackground) then return end
	
	EQRoundBox(0, 0, w, h, (panel.Hovered and color_close_hover or color_close_bg), color_outline)
	
	draw.SimpleText("X", "category_buttons", w*0.5, h*0.5, (panel.Hovered and Color(255,255,255,151) or Color(255,255,255)), 1, 1)
	
end


-- Scrollbar
function SKIN:PaintVScrollBar(self, w, h) end
function SKIN:PaintButtonUp(self, w, h) end
function SKIN:PaintButtonDown(self, w, h) end
function SKIN:PaintButtonLeft(self, w, h) end
function SKIN:PaintButtonRight(self, w, h) end

function SKIN:PaintScrollBarGrip(self, w, h)
	EQRoundBox(0, 0, w, h, color_sup, color_outline)
end

function SKIN:PaintScrollPanel(self, w, h)
	EQRoundBox(0, 0, w, h, color_background, color_outline)
end

function SKIN:PaintUIScrollBar(self, w, h)
	EQRoundBox(0, self.scrollButton.y, w, self.height, color_sup, color_outline)
end


-- Slider
function SKIN:PaintUISlider(self, w, h)
	SKIN:PaintPanel(self, w, h)
	EQRoundBox(1, 1, self:GetValue() * w - self:GetValue() * 16, h - 2, color_sup, color_outline)
end


-- Text Entry
function SKIN:PaintTextEntry(self, w, h)
	EQRoundBox(0, 0, w, h, color_offwhite, color_outline)
	
	self:DrawTextEntryText(color_black, color_sup, color_black)
end


-- List View
function SKIN:PaintUIListView(self, w, h) 
	EQRoundBox(0, 0, w, h, color_offwhite, color_outline)
end


function SKIN:PaintListView(self, w, h) 
end

function SKIN:PaintListViewLine(self, w, h) -- todo, just make a new control and never use this
	if self.m_bAlt then
		EQRoundBox(0, 0, w, h, (self:IsSelected() or self:IsHovered()) and color_sup or color_hover, color_outline)
	else
		EQRoundBox(0, 0, w, h, (self:IsSelected() or self:IsHovered()) and color_sup or color_background, color_outline)
	end

	for k, v in ipairs(self.Columns) do
		if (self:IsSelected() or self:IsHovered()) then
			v:SetTextColor(color_black)
			v:SetFont('ui.20')
		else
			v:SetTextColor(color_white)
			v:SetFont('ui.17')
		end
	end
end


-- Checkbox
function SKIN:PaintCheckBox(self, w, h)
	EQRoundBox(0, 0, w, h, color_background, color_outline)

	if self:GetChecked() then 
		EQRoundBox(4, 4, w - 8, h - 8, color_sup, color_outline)
	end
end


-- Tabs
function SKIN:PaintTabButton(self, w, h)
	draw.OutlinedBox(0, 0, w, h, color_background, color_outline)
	
	self:SetTextColor(color_white)

	if self.Hovered then
		draw.Box(1, 1, 6, h - 2, color_sup)
		draw.Box(w - 6, 1, 6, h - 2, color_sup)
	elseif self.Active then
		draw.Box(1, 1, 3, h - 2, color_sup)
		draw.Box(w - 3, 1, 6, h - 2, color_sup)
	end
end

function SKIN:PaintTabListPanel(self, w, h)
	draw.OutlinedBox(149, 0, w - 149, h, color_background, color_outline)
end


-- ComboBox
function SKIN:PaintComboBox(self, w, h)
	if IsValid(self.Menu) and (not self.Menu.SkinSet) then
		self.Menu:SetSkin('SUP')
		self.Menu.SkinSet = true
	end

	self:SetTextColor(((self.Hovered or self.Depressed or self:IsMenuOpen()) and color_black or color_white))

	draw.Box(0, 0, w, h, ((self.Hovered or self.Depressed or self:IsMenuOpen()) and color_button_hover or color_background))
end

function SKIN:PaintComboDownArrow(self, w, h)
	surface.SetDrawColor(color_sup)
	draw.NoTexture()
	surface.DrawPoly({
		{x = 0, y = w * .5},
		{x = h, y = 0},
		{x = h, y = w}
	})
end


-- DMenu
function SKIN:PaintMenu(self, w, h)
	draw.Box(0, 0, w, h, color_background)
end

function SKIN:PaintMenuOption(self, w, h)
	if (not self.FontSet) then
		self:SetFont('ui.22')
		self:SetTextInset(5, 0)
		self.FontSet = true
	end
	
	self:SetTextColor(color_white)

	draw.Box(0, 0, w, h + 1, color_backgroun)
	
	if self.m_bBackground and (self.Hovered or self.Highlight) then
		draw.Box(0, 0, w, h + 1, color_sup)
		self:SetTextColor(color_button_hover)
	end
end

-- DPropertySheet
local propbackground = Color(200, 200, 200)
local prophovered = ui.col.ButtonHover
local propactive = Color(color_sup.r, color_sup.g, color_sup.b - 20)

function SKIN:PaintPropertySheet(self, w, h)
	draw.Box(0, self:GetActiveTab():GetTall(), w, h - self:GetActiveTab():GetTall(), propbackground)
end

function SKIN:PaintTab(self, w, h)
	local active = self:GetPropertySheet():GetActiveTab() == self
	
	if (active) then
		self:SetTextColor(propactive)
		draw.Box(0, 0, w, h, propbackground)
	elseif (self:IsHovered()) then
		self:SetTextColor(prophovered)
	else
		self:SetTextColor(propbackground)
	end
end

derma.DefineSkin('SUP', 'SUP\'s derma skin', SKIN)
--PATH addons/____plogs/lua/ui/controls/propertysheet.lua:

-----------------------------------------------------
local PANEL = {}

function PANEL:Paint(w, h)
	derma.SkinHook('Paint', 'PropertySheet', self, w, h)
end

vgui.Register('ui_propertysheet', PANEL, 'DPropertySheet')

--PATH addons/uweedadvancedcannabisgrowth/lua/uweed/derma/cl_fonts.lua:
-- This just creates the font. to keep them organised
surface.CreateFont( "uweed_font_30", {
	font = UWeed.Config.Font,
	size = 30,
	weight = 100
})
surface.CreateFont( "uweed_font_40", {
	font = UWeed.Config.Font,
	size = 40,
	weight = 100
})
surface.CreateFont( "uweed_font_60", {
	font = UWeed.Config.Font,
	size = 60,
	weight = 100
})
surface.CreateFont( "uweed_font_80", {
	font = UWeed.Config.Font,
	size = 80,
	weight = 100
})
surface.CreateFont( "uweed_Gram_Font", {
	font = "Calibri",
	size = ScreenScale(25),
	weight = 100
})
--PATH addons/uweedadvancedcannabisgrowth/lua/uweed/config/sh_language.lua:
/*
===================
The language config
===================
*/
UWeed.Translation.SeedBox = {}
UWeed.Translation.SeedBox.Title = "Коробка для насіння"
UWeed.Translation.Pot = {}
UWeed.Translation.Pot.Title = "Горшок для Трави"
UWeed.Translation.Pot.Counter = "Насіння:"

UWeed.Translation.Pot.PlantSeed = "Готові до зростання!"
UWeed.Translation.Pot.SeedNeeded = "Посади насіння!"

UWeed.Translation.Pot.PlantGorwing = "Наразі зростає"
UWeed.Translation.Pot.LightLvlGood = "Хороший рівень освітлення"
UWeed.Translation.Pot.LightLvlBad = "Необхідно більше світла"
UWeed.Translation.Pot.LightLvlRealBad = "Критично низький рівень світла"
UWeed.Translation.Pot.LightLvlBad2 = "Потрібно менше світла"
UWeed.Translation.Pot.LightLvlRealBad2 = "Критично високий рівень світла"

UWeed.Translation.Pot.HarvestReady = "Готові до збору урожаю!"
UWeed.Translation.Pot.BudCount = "Кількість трави:"

UWeed.Translation.Pot.HavestRuined = "Урожай зіпсований!"
UWeed.Translation.Pot.UseReset = "Не вистачає світла."
UWeed.Translation.Pot.UseReset2 = "Занадто багато світла"
UWeed.Translation.Bag = {}
UWeed.Translation.Bag.Title = "МІШОК ДЛЯ ТРАВИ"
UWeed.Translation.Bag.Capacity = "Місткість:"

UWeed.Translation.Bud = {}
UWeed.Translation.Bud.title = "ТРАВА"
UWeed.Translation.Bud.Estimated = "оцінений:"
UWeed.Translation.Bud.Gram = "g"

UWeed.Translation.Scale = {}
UWeed.Translation.Scale.NoBag = "n/a"
UWeed.Translation.Scale.Gram = "g"

UWeed.Translation.Skin = {}
UWeed.Translation.Skin.Title = "Скрутити папір"
UWeed.Translation.Skin.NoWeed = "Потребує траву"

UWeed.Translation.Seed = {}
UWeed.Translation.Seed.Title = "Насіння"
UWeed.Translation.Seed.Text = "Посади мене"

UWeed.Translation.Frontwoods = {}
UWeed.Translation.Frontwoods.Title = "Пачка папірців"
UWeed.Translation.Frontwoods.NoWeed = ""

UWeed.Translation.BIGLAMP = {}
UWeed.Translation.BIGLAMP.Title = "ПРОМИСЛОВЕ СВІТЛО"
UWeed.Translation.BIGLAMP.LittleTitle = "СВІТЛО"
UWeed.Translation.BIGLAMP.State = "Статус:"
UWeed.Translation.BIGLAMP.On = "On"
UWeed.Translation.BIGLAMP.Off = "Off"
UWeed.Translation.BIGLAMP.Battery = "Батарея:"

UWeed.Translation.NPC = {}
UWeed.Translation.NPC.Title = "НАРКО-ТОРГІВЕЦЬ"
UWeed.Translation.NPC.Sell = "Продаю за %s за грам"
UWeed.Translation.NPC.Holding = "Отримаєте:"
UWeed.Translation.NPC.SellMessage = "Ви продали %s трави за %s"

UWeed.Translation.Battery = {}
UWeed.Translation.Battery.Title = "БАТАРЕЯ"
UWeed.Translation.Battery.Restore = "Зараджає акумулятор ліхтаря"

UWeed.Translation.Blunt = {}
UWeed.Translation.Blunt.Text = "Tugs:"

UWeed.Translation.Chat = {}
UWeed.Translation.Chat.LoseBlunt = "Твої закручені косяки видалили, бо ти помер."
UWeed.Translation.Chat.Spawn = "Тобі дали косяк на спавні."
--PATH addons/__main/lua/wos/anim_extension/extensions/wos_base.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Base" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted wiltOS Animation Base\n" )
--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/classes/entity.lua:
local function __laux_concat_0(...)
  local arr = {
  ...
  }
  local result = {}
  for _, obj in ipairs(arr) do
    for i = 1, #obj do
      result[#result + 1] = obj[i]
    end
    for k, v in pairs(obj) do
      if type(k) == "number" and k > #obj then result[k] = v
      elseif type(k) ~= "number" then
        result[k] = v
      end
    end
  end
  return result
end
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Configurator.Entity",
    setDatabaseEntity = function(self, databaseEntity)
      self.databaseEntity = databaseEntity
      return self
    end,
    getDatabaseEntity = function(self)
      return self.databaseEntity
    end,
    getColumns = function(self)
      return self.columns
    end,
    getColumn = function(self, id)
      for i, v in ipairs(self.columns) do
        if (v.id != id) then continue end

        return v, i
      end
    end,
    addColumn = function(self, id, data)
      table.insert(self.columns, __laux_concat_0({
      id = id
      }, data))

      local name = id:sub(1, 1):upper() .. id:sub(2)
      self["set" .. tostring(name)] = function(self, val, deserialize)
        if deserialize then
          if (data.csv and isstring(val)) then
            val = string.Explode(",", val)
          elseif (isstring(val) and (data.type == "list" or data.json)) then
            val = util.JSONToTable(val)
          end
        end

        self[id] = val

        return self
      end
      self["set" .. tostring(id)] = function(self, ...)
        self["set" .. tostring(name)](self, ...)end
      self["get" .. tostring(name)] = function(self, serialize)
        if serialize then
          if (data.csv and istable(self[id])) then
            return table.concat(self[id], ",")
          elseif istable(self[id]) then
            return util.TableToJSON(self[id])
          end
        end

        return self[id]
      end
      self["get" .. tostring(id)] = function(self, ...)
        return self["get" .. tostring(name)](self, ...)end
    end,
    getSQLTableName = function(self)
      local str = self:getDatabaseEntity():lower()
      str = str:Replace(".", "_")

      return "xenin_configurator_entity_" .. str
    end,
    createSQLTable = function(self)
      local tableName = self:getSQLTableName()
      XeninUI.ORM.Table(XeninDB, tableName, function(tbl)
        for i, v in ipairs(self:getColumns()) do
          assert(v ~= nil, "cannot destructure nil value")
          local type, length, primary, null, default = v.type, v.length, v.primary, v.null, v.default
          local dataType = type == "list" and "text" or type
          local col = tbl[dataType](tbl, v.id)
          if primary then col:primary()end
          if length then col:length(length)end
          if null then col:nullable()end
          if default then
            local notExpressions = {
              integer = true,
              string = true
            }

            local isExpression = !notExpressions[type]
            col:default(default, isExpression)
          end
        end
      end, function()
        self:seed()
      end)
    end,
    seedData = function(self) end,
    seed = function(self)
      local data = self:seedData()
      if (!data) then return end
      local name = self:getSQLTableName()

      for i, v in ipairs(data) do
        XeninUI.Configurator.ORM:seed(name, v.version, v.code())
      end
    end,
    onNetworkSend = function(self)

      local cols = self:getColumns()
      local size = #cols
      local tbl = {}
      for i, v in ipairs(cols) do
        assert(v ~= nil, "cannot destructure nil value")
        local id = v.id
        local val = self["get" .. tostring(id)](self, true)
        if (!val) then continue end
        if (isstring(val) and val == "") then continue end

        tbl[id] = val
      end

      local size = table.Count(tbl)
      net.WriteUInt(size, 12)
      for i, v in pairs(tbl) do
        net.WriteString(i)
        XeninUI.Configurator.Network:write(v)
      end
    end,
    onNetworkReceive = function(self)
      local cols = self:getColumns()
      local size = net.ReadUInt(12)
      for i = 1, size do
        local id = net.ReadString()
        local val = XeninUI.Configurator.Network:read()

        self["set" .. tostring(id)](self, val, true)
      end
    end,
    onSave = function(self) end,
    onDelete = function(self) end,
    onLoad = function(self) end,
    validateColumn = function(self, id, input)
      local col = self:getColumn(id)
      if (!col) then return end

      if (!col.validate) then return true, "No validation"end

      return col.validate(input)
    end,
    shouldAllowNetwork = function(self, ply)
      return true end,
    save = function(self, admin)
      self:onSave()

      if (!admin) then return end

      if CLIENT then
        XeninUI.Configurator.Network:sendSaveEntity(self)

        return
      end

      XeninUI.Configurator.ORM:saveEntity(self)

      self:network()
    end,
    network = function(self, target)
      if (!target) then
        target = {}
        for i, v in ipairs(player.GetAll()) do
          if (!self:shouldAllowNetwork(v)) then continue end

          table.insert(target, v)
        end

        if (table.IsEmpty(target)) then return end
      end

      XeninUI.Configurator.Network:sendEntity(target, self)
    end,
    createNewEntity = function(self)
      if CLIENT then
        XeninUI.Configurator.Network:sendCreateEntity(self)

        return
      end

      XeninUI.Configurator.ORM:createEntity(self)
    end,
    delete = function(self, admin)
      self:onDelete()

      if (!admin) then return end

      if CLIENT then
        XeninUI.Configurator.Network:sendDeleteEntity(self)

        return
      end

      XeninUI.Configurator.ORM:deleteEntity(self)
    end,
    isDatabaseEntity = function(self)
      return true end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.columns = {}
    end,
    __base = _base_0,
    register = function(name, entity)
      local __laux_type = (istable(entity) and entity.__type and entity:__type()) or type(entity)
      assert(__laux_type == "XeninUI.Configurator.Entity", "Expected parameter `entity` to be type `XeninUI.Configurator.Entity` instead of `" .. __laux_type .. "`")
      XeninUI.Configurator.Entities:register(name, entity)
    end
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Configurator.Entity = _class_0
end

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/inputs/key.lua:
local x

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/animated_texture.lua:
local PANEL = {}

AccessorFunc(PANEL, "m_paused", "Paused")

function PANEL:Init()
    self.images = {}
    self.slots = {}
    self:SetPaused(false)
end

function PANEL:SetDirectory(dir)
    local files = file.Find("materials/" .. dir .. "/*", "GAME") or {}
    for k, v in pairs(files) do
        files[k] = tonumber(string.StripExtension(v))
    end

    table.sort(files, function(a, b)
        return a < b end)

    local new = {}
    for k, v in pairs(files) do
        new[k] = Material(dir .. "/" .. v .. ".png", "smooth")
    end

    self.dir = dir
    self.images = new
end

function PANEL:SetImages(tbl)
    self.images = tbl
end

function PANEL:SetTimes(normal, idle)
    self.times = {
        normal = normal or .02,
        idle = idle or 1
    }
end

function PANEL:PostInit()
    self.start_slot = 1
    self.end_slot = #self.images

    self.slots = {
        min = 1,
        max = #self.images
    }

    self.cur_image = self.slots.min
    self.next_change = UnPredictedCurTime() + self.times.normal

    self.can_draw = true
end

function PANEL:Paint(w, h)
    if !self.can_draw then return end

    if !self.images[self.cur_image] then return end

    surface.SetMaterial(self.images[self.cur_image])
    surface.SetDrawColor(255, 255, 255)
    surface.DrawTexturedRect(0, 0, w, h)

    if self.next_change < UnPredictedCurTime() and !self:GetPaused() then
        self.cur_image = self.cur_image < self.slots.max and self.cur_image + 1 or self.slots.min
        self.next_change = UnPredictedCurTime() + (self.cur_image < self.slots.max and self.times.normal or self.times.idle)
    end
end

vgui.Register("XeninUI.AnimatedTexture", PANEL, "Panel")

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/panel.lua:
local PANEL = {}

function PANEL:Init()
  self.notifications = {}
end

function PANEL:Notification(title, backgroundCol, textCol)
  local pnl = self:Add("DPanel")
  pnl:SetAlpha(0)
  pnl:AlphaTo(255, 0.1)
  pnl:SetZPos(2)
  pnl.uniqueID = SysTime()
  pnl.Paint = function(pnl, w, h)
    local x, y = pnl:LocalToScreen(0, 0)

    BSHADOWS.BeginShadow()
    draw.RoundedBox(6, x, y, w, h, backgroundCol or XeninUI.Theme.Primary)
    draw.SimpleText(title, "XeninUI.Notification", x + 8, y + 8, textCol or XeninUI:GetContrastColor(backgroundCol, color_white, color_black))
    BSHADOWS.EndShadow(1, 2, 2, 200, 0, 0)
  end

  surface.SetFont("XeninUI.Notification")
  local tw, th = surface.GetTextSize(title)
  pnl:SetSize(tw + 16, th + 16)

  local offset = 16
  for i, v in pairs(self.notifications) do
    offset = offset + v:GetTall() + 8
  end

  pnl:SetPos(self:GetWide() - 16 - pnl:GetWide(), offset)

  table.insert(self.notifications, pnl)

  timer.Simple(3, function()
    if (!IsValid(pnl)) then return end

    pnl:AlphaTo(0, 0.2)

    timer.Simple(0.2, function()
      if (!IsValid(pnl)) then return end

      for i, v in pairs(self.notifications) do
        if (v.uniqueID != pnl.uniqueID) then continue end

        table.remove(self.notifications, i)

        pnl:Remove()
      end
    end)
  end)
end

vgui.Register("XeninUI.Panel", PANEL)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/query_single_button.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.Query.Text", 18)
XeninUI:CreateFont("XeninUI.Query.Button", 18)

function PANEL:Init()
  self.onAccept = function() end
  self.onDecline = function() end

  self.background.text = self.background:Add("DLabel")
  self.background.text:SetText("XD")
  self.background.text:SetFont("XeninUI.Query.Text")
  self.background.text:SetContentAlignment(8)
  self.background.text:SetTextColor(Color(200, 200, 200))

  self.background.accept = self.background:Add("DButton")
  self.background.accept:SetText("Accept")
  self.background.accept:SetFont("XeninUI.Query.Button")
  self.background.accept:SetTextColor(Color(21, 21, 21))
  self.background.accept.Paint = function(pnl, w, h)
    draw.RoundedBox(6, 0, 0, w, h, self.acceptBtnColor or XeninUI.Theme.Green)
  end
  self.background.accept.DoClick = function(pnl)
    self:onAccept(pnl)
    self:Remove()
  end
end

function PANEL:PerformLayout(w, h)
  surface.SetFont(self.background.text:GetFont())
  local tw = surface.GetTextSize(self.background.text:GetText())
  self:SetBackgroundWidth(tw + 32)

  self.BaseClass.PerformLayout(self, w, h)

  self.background.text:SetWide(self.background:GetWide())
  self.background.text:SizeToContentsY()
  self.background.text:SetPos(0, 56)

  self.background.accept:SizeToContentsX(32)
  self.background.accept:SizeToContentsY(16)

  local y = self.background:GetTall() - self.background.accept:GetTall() - 16

  self.background.accept:SetPos(self.background:GetWide() * 0.5 - self.background.accept:GetWide() * 0.5, y)
end

function PANEL:SetText(text)
  self.background.text:SetText(text)
end

function PANEL:SetAccept(text, func)
  self.background.accept:SetText(text)
  self.onAccept = func
end

vgui.Register("XeninUI.QuerySingleButton", PANEL, "XeninUI.Popup")

function XeninUI:SimpleQuerySingle(title, text, yesText, yesFunc)
  local queryMenu = vgui.Create("XeninUI.QuerySingleButton")
  queryMenu:SetSize(ScrW(), ScrH())
  queryMenu:SetBackgroundHeight(140)

  queryMenu:SetTitle(title or "Title")
  queryMenu:SetText(text or "Text")

  queryMenu:SetAccept(yesText or "Yes", yesFunc or (function() end))

  queryMenu:MakePopup()

  return queryMenu
end

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/slider_pad.lua:
local PANEL = {}

function PANEL:Init()
  self.Rounding = 0

  self.Slider = self:Add("XeninUI.Slider")
  self.Slider:Dock(FILL)
  self.Slider:DockMargin(0, 0, 8, 0)
  self.Slider.OnValueChanged = function(pnl, frac)
    local value = math.Round(pnl:GetMin() + ((pnl:GetMax() - pnl:GetMin()) * frac), self.Rounding)
    self.Textentry:SetText(value)
    self:OnValueChanged(value)
  end

  self.Textentry = self:Add("XeninUI.TextEntry")
  self.Textentry:Dock(RIGHT)
  self.Textentry:SetNumeric(true)
  self.Textentry:SetUpdateOnType(true)
  self.Textentry.OnValueChange = function(pnl, text)
    local num = tonumber(text)
    if (!isnumber(num)) then return end
    num = math.Clamp(num, self:GetMin(), self:GetMax())
    num = math.Round(num, self.Rounding)

    self:SetValue(num, true)
    self:OnValueChanged(num)
  end

  self:SetValue(5)
end

function PANEL:SetValue(value, dontSetText)
  local frac = (value - self:GetMin()) / (self:GetMax() - self:GetMin())
  self:SetFraction(math.Clamp(frac, 0, 1))

  if (!dontSetText) then
    self.Textentry:SetText(value)
  end
  self.Slider:InvalidateLayout(true)
end

function PANEL:GetValue()
  return math.Clamp(self.Textentry:GetText(), self:GetMin(), self:GetMax())
end


function PANEL:OnValueChanged(value) end

function PANEL:SetMin(min)
  self.Slider:SetMin(min)end
function PANEL:GetMin()
  return self.Slider:GetMin()end
function PANEL:SetMax(max)
  self.Slider:SetMax(max)end
function PANEL:GetMax()
  return self.Slider:GetMax()end
function PANEL:SetColor(color)
  self.Slider:SetColor(color)end
function PANEL:GetColor()
  return self.Slider:GetColor()end
function PANEL:SetFraction(fraction)
  self.Slider.fraction = fraction end
function PANEL:GetFraction()
  return self.Slider.fraction end
function PANEL:SetRounding(rounding)
  self.Rounding = rounding end
function PANEL:GetRounding()
  return self.Rounding end

vgui.Register("XeninUI.SliderPad", PANEL, "Panel")

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/tooltip.lua:
surface.CreateFont("XeninUI.Tooltip", {
  font = "Montserrat",
  size = 18,
  weight = 500
})

local PanelMeta = FindMetaTable("Panel")

function PanelMeta:RemoveCooltip()
  if IsValid(self.Tooltip) then
    self.Tooltip:Hide()
  end

  self.EnableTooltip = false
end

function PanelMeta:SetCooltip(str, delay, offsetX, offsetY)
  self.EnableTooltip = true
  self.CursorEntered = 0
  self.ActivateTooltip = true
  self.TooltipStr = str
  self.TooltipDelay = delay or 0.2

  if self.Tooltip then
    self.Tooltip.Str = str

    surface.SetFont("XeninUI.Tooltip")
    local x, y = self:LocalToScreen(offsetX or 0, offsetY or 0)
    local width, height = surface.GetTextSize(self.TooltipStr)

    self.Tooltip:SetSize(width + 32, height + 24)
    self.Tooltip:SetPos(x + self:GetWide() * 0.5 - self.Tooltip:GetWide() * 0.5, y - self.Tooltip:GetTall() - 4)

    self.Tooltip:Show()
    return
  end

  local oldCursorEntered = self.OnCursorEntered
  self.OnCursorEntered = function(pnl)
    if oldCursorEntered then oldCursorEntered(pnl)end

    pnl.CursorEntered = CurTime() + pnl.TooltipDelay
  end

  local oldCursorExited = self.OnCursorExited
  self.OnCursorExited = function(pnl)
    if oldCursorExited then oldCursorExited(pnl)end

    pnl.CursorEntered = 0

    if IsValid(pnl.Tooltip) then
      pnl.Tooltip:Remove()
      pnl.Tooltip = nil
    end
  end

  local oldThink = self.Think
  self.Think = function(pnl)
    if oldThink then oldThink(pnl)end

    if (pnl.CursorEntered < CurTime() and !IsValid(pnl.Tooltip) and pnl:IsHovered() and pnl.EnableTooltip) then
      local x, y = pnl:LocalToScreen(offsetX or 0, offsetY or 0)
      local w = pnl:GetWide()

      surface.SetFont("XeninUI.Tooltip")
      local width, height = surface.GetTextSize(self.TooltipStr)

      pnl.Tooltip = vgui.Create("XeninUI.Tooltip")
      pnl.Tooltip:SetAlpha(0)
      pnl.Tooltip:SetDrawOnTop(true)
      pnl.Tooltip:SetSize(width + 32, height + 24)
      pnl.Tooltip:SetPos(x + self:GetWide() * 0.5 - pnl.Tooltip:GetWide() * 0.5, y - pnl.Tooltip:GetTall() - 4)
      pnl.Tooltip:AlphaTo(255, 0.15)
      pnl.Tooltip.Str = str
    end
  end

  local oldRemove = self.OnRemove
  self.OnRemove = function(pnl)
    if oldRemove then oldRemove(pnl)end

    if IsValid(pnl.Tooltip) then
      pnl.Tooltip:Remove()
    end
  end
end

function PanelMeta:SetCooltipString(str)
  self.TooltipStr = str
  if (!IsValid(self.Tooltip)) then return end
  self.Tooltip.Str = str

  local x, y = self:LocalToScreen(0, 0)
  local w = self:GetWide()

  surface.SetFont("XeninUI.Tooltip")
  local width, height = surface.GetTextSize(self.TooltipStr)

  self.Tooltip:SetSize(width + 32, height + 24)
  self.Tooltip:SetPos(x + self:GetWide() * 0.5 - self.Tooltip:GetWide() * 0.5, y - self.Tooltip:GetTall() - 4)
end

local PANEL = {}

function PANEL:Paint(w, h)
  local x, y = self:LocalToScreen(0, 0)

  BSHADOWS.BeginShadow()
  draw.RoundedBox(6, x, y, w, h - 8, color_white)
  draw.SimpleText(self.Str, "XeninUI.Tooltip", x + w * 0.5, y + (h - 8) * 0.5, Color(0, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
  BSHADOWS.EndShadow(2, 1, 1, 255, 0, 0)

  local tbl = {
    {
      x = w * 0.5 - 8,
      y = h - 8
    },
    {
      x = w * 0.5 + 8,
      y = h - 8
    },
    {
      x = w * 0.5,
      y = h
    },
    {
      x = w * 0.5 - 8,
      y = h - 8
    }
  }

  draw.NoTexture()
  surface.SetDrawColor(color_white)
  surface.DrawPoly(tbl)
end

vgui.Register("XeninUI.Tooltip", PANEL, "EditablePanel")

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/wyvern_scrollbar.lua:
local PANEL = {}

AccessorFunc(PANEL, "m_bVisibleFullHeight", "VisibleFullHeight", FORCE_BOOL)

function PANEL:Init()
    self.Offset = 0
    self.Scroll = 0
    self.CanvasSize = 1
    self.BarSize = 1

    self.scrollbar = vgui.Create("DScrollBarGrip", self)
    self.scrollbar.Paint = function(pnl, w, h)
        surface.SetDrawColor(255, 255, 255, 20)
        surface.DrawRect(0, 0, w, h)
    end

    self:SetSize(4, 4)

    self.scrollDelta = delta

    self:SetVisibleFullHeight(false)
end

function PANEL:SetEnabled(b)
    if not b then
        self.Offset = 0
        self:SetScroll(0)
        self.HasChanged = true
    end

    self:SetMouseInputEnabled(b)

    if not self:GetVisibleFullHeight() then
        self:SetVisible(b)
    end

    if self.Enabled ~= b then
        self:GetParent():InvalidateLayout()

        if self:GetParent().OnScrollbarAppear then
            self:GetParent():OnScrollbarAppear()
        end
    end

    self.Enabled = b
end

function PANEL:GetEnabled()
    return self.Enabled
end

function PANEL:Value()
    return self.Pos
end

function PANEL:BarScale()
    if self.BarSize == 0 then return 1 end

    return self.BarSize / (self.CanvasSize + self.BarSize)
end

function PANEL:SetUp(_barSize_, _canvasSize_)
    self.BarSize = _barSize_
    self.CanvasSize = math.max(_canvasSize_ - _barSize_, 1)

    self:SetEnabled(_canvasSize_ > _barSize_)

    self:InvalidateLayout()
end

function PANEL:OnMouseWheeled(dlta)
    if not self:IsVisible() then return false end

    return self:AddScroll(dlta * -2)
end

function PANEL:AddScroll(dlta)
    local oldScroll = self:GetScroll()

    dlta = dlta * 25
    self:SetScroll(oldScroll + dlta)

    return oldScroll ~= self:GetScroll()
end

function PANEL:SetScroll(scrll)
    if not self.Enabled then self.Scroll = 0 return end

    self.Scroll = math.Clamp(scrll, 0, self.CanvasSize + 75)
    self:InvalidateLayout()

    local func = self:GetParent().OnVScroll
    if func then
        func(self:GetParent(), self:GetOffset())
    else
        self:GetParent():InvalidateLayout()
    end
end

function PANEL:LimitScroll()
    if self.Scroll < 0 or self.Scroll > self.CanvasSize then
        self.Scroll = math.Clamp(self.Scroll, -75, self.CanvasSize + 75)
    end
end

function PANEL:AnimateTo(scrll, length, delay, ease)
    local anim = self:NewAnimation(length, delay, ease)
    anim.StartPos = self.Scroll
    anim.TargetPos = scrll
    anim.Think = function(anim, pnl, fraction)
        pnl:SetScroll(Lerp(fraction, anim.StartPos, anim.TargetPos))
    end
end

function PANEL:GetScroll()
    if not self.Enabled then self.Scroll = 0 end
    return self.Scroll
end

function PANEL:GetOffset()
    if not self.Enabled then return 0 end
    return self.Scroll * -1
end

function PANEL:Think() end

function PANEL:OnMousePressed()
    local x, y = self:CursorPos()

    local pageSize = self.BarSize

    if y > self.scrollbar.y then
        self:SetScroll(self:GetScroll() + pageSize)
    else
        self:SetScroll(self:GetScroll() - pageSize)
    end
end

function PANEL:OnMouseReleased()
    self.Dragging = false
    self.DraggingCanvas = nil
    self:MouseCapture(false)

    self.scrollbar.Depressed = false
end

function PANEL:OnCursorMoved(x, y)
    if not self.Enabled or not self.Dragging then return end

    local x = 0
    local y = gui.MouseY()
    local x, y = self:ScreenToLocal(x, y)

    y = y - self.HoldPos

    local trackSize = self:GetTall() - self.scrollbar:GetTall()
    y = y / trackSize

    self:SetScroll(math.Clamp(y * self.CanvasSize, 0, self.CanvasSize))
end

function PANEL:Grip()
    if not self.Enabled or self.BarSize == 0 then return end

    self:MouseCapture(true)
    self.Dragging = true

    local x, y = 0, gui.MouseY()
    local x, y = self.scrollbar:ScreenToLocal(x, y)
    self.HoldPos = y

    self.scrollbar.Depressed = true
end

function PANEL:PerformLayout(w, h)
    self:LimitScroll()

    local scroll = self:GetScroll() / self.CanvasSize
    local barSize = math.max(self:BarScale() * self:GetTall(), 10)
    local track = self:GetTall() - barSize
    track = track + 1

    scroll = scroll * track

    local barStart = math.max(scroll, 0)
    local barEnd = math.min(scroll + barSize, self:GetTall())

    self.scrollbar:SetPos(0, barStart)
    self.scrollbar:SetSize(w, barEnd - barStart)
end


function PANEL:Paint(w, h) end

vgui.Register("XeninUI.Scrollbar.Wyvern", PANEL, "Panel")

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/units/main.lua:
XeninUI.Units = XeninUI.Units || {}

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/units/classes/spec.lua:
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Units.Spec",
    getName = function(self)
      return self.name end,
    getFunc = function(self)
      return self.func end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, name, func)
      self.name = name
      self.func = func
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Units.Spec = _class_0
end

--PATH addons/battlepass/lua/battlepass/challenges/podari_bezdomnomu_25000.lua:
local CHALLENGE = BATTLEPASS:CreateTemplateChallenge()
CHALLENGE:SetName("Подарить бездомному 25000$")
CHALLENGE:SetIcon("battlepass/challenges/shipments.png") -- <- ??
CHALLENGE:SetDesc("")
CHALLENGE:SetProgressDesc("---")
CHALLENGE:SetFinishedDesc("---")
CHALLENGE:SetID("podari_bezdomnomu_25000")
CHALLENGE:SetPremium(true)

CHALLENGE:AddHook("playerGiveMoneyPodarit_BattlePass", function(self, ply, _ply, ply2, sum)
  if (IsValid( _ply ) and ply == _ply and _ply.BattlePass.Owned.owned) and (IsValid(ply2) and ply ~= ply2 and ply2:Team() == TEAM_HOBO) then
    self:AddProgress(sum)
    self:NetworkProgress()
  end
end)

BATTLEPASS:RegisterChallenge(CHALLENGE)
--PATH addons/battlepass/lua/battlepass/network/client.lua:
net.Receive("BATTLEPASS.TotalSync", function(len)
  local ply = LocalPlayer()
  local owned = net.ReadBool()
  local tier = net.ReadUInt(8)
  local progress = net.ReadFloat()
  local tbl = net.ReadTable()
  local claimsTbl = net.ReadTable()
  local varsTbl = net.ReadTable()

  BATTLEPASS:SetOwned(ply, owned)
  BATTLEPASS:SetTier(ply, tier)
  BATTLEPASS:SetProgress(ply, progress)
  BATTLEPASS:SetVariables(ply, varsTbl)

  ply.ActiveChallenges = ply.ActiveChallenges or {}

  for cat, challengeTbl in pairs(BATTLEPASS.Pass.challenges) do
    ply.ActiveChallenges[cat] = ply.ActiveChallenges[cat] or {}

    for i, challenge in pairs(challengeTbl) do
      local oldChallenge = ply.ActiveChallenges[cat][i] or {}
      local progress = oldChallenge.progress or 0
      if (tbl[cat] and tbl[cat][i]) then
        progress = tbl[cat][i]
      end
      ply.ActiveChallenges[cat][i] = BATTLEPASS:CreateChallengeFromID(challenge.id)
	  --ply.ActiveChallenges[cat][i]:SetStage(challenge.stage or 1)

      ply.ActiveChallenges[cat][i]:SetProgress(progress)
      ply.ActiveChallenges[cat][i]:SetGoal(challenge.goal)
      ply.ActiveChallenges[cat][i]:SetReward(challenge.reward)
	    ply.ActiveChallenges[cat][i]:CalculateStage()
      ply.ActiveChallenges[cat][i]:SetUniqueID(cat .. i)
      ply.ActiveChallenges[cat][i]:SetPlayer(ply)
      ply.ActiveChallenges[cat][i].cat = cat
      ply.ActiveChallenges[cat][i].index = i
    end
  end

  ply.BattlePass.ClaimedItems = ply.BattlePass.ClaimedItems or {}
  for i = 1, BATTLEPASS.Pass.tiers do
    ply.BattlePass.ClaimedItems[i] = { premium = {} }
  end

  for i, v in pairs(claimsTbl) do
    local tier = tonumber(v.tier)
    local premium = tobool(v.premium)
    local index = tonumber(v.item_index)

    ply.BattlePass.ClaimedItems[tier] = ply.BattlePass.ClaimedItems[tier] or {}
    
    if (premium) then
      ply.BattlePass.ClaimedItems[tier].premium = ply.BattlePass.ClaimedItems[tier].premium or {}
      ply.BattlePass.ClaimedItems[tier].premium[index] = true
    else
      ply.BattlePass.ClaimedItems[tier].free = true
    end
  end

  if (BATTLEPASS.Config.OpenMenuOnJoin) then
    ply:ConCommand("battlepass")
  end
end)

net.Receive("BATTLEPASS.SyncChallengeProgress", function(len)
  local ply = LocalPlayer()
  BATTLEPASS:SetupPass(ply)
  local cat = net.ReadString()
  local index = net.ReadUInt(10)
  local progress = net.ReadFloat()
  local star = net.ReadUInt(8)
  ply.ActiveChallenges = ply.ActiveChallenges or {}
  local tbl = ply.ActiveChallenges[cat]
  if (!tbl) then return end
  tbl = tbl[index]
  if (!tbl) then return end

  if (progress >= tbl:GetGoal()) then
    ply.BattlePass.Owned.progress = star
    tbl:AddStageNotification(tbl.stage)
  end
  
  ply.ActiveChallenges[cat][index]:SetProgress(progress, true)
end)

net.Receive("BATTLEPASS.AddTier", function(len)
  local amt = net.ReadUInt(8)

  BATTLEPASS:AddTier(LocalPlayer(), amt)
end)

net.Receive("BATTLEPASS.GivePass", function(len)
  local ply = LocalPlayer()

  BATTLEPASS:SetOwned(ply, true)

  hook.Run("BATTLEPASS.Purchased")
end)

net.Receive("BATTLEPASS.RemovePass", function(len)
  local ply = LocalPlayer()

  BATTLEPASS:SetOwned(ply, false)

  hook.Run("BATTLEPASS.Removed")
end)

net.Receive("BATTLEPASS.SetTiers", function(len)
  local ply = LocalPlayer()
  local amt = net.ReadUInt(16)

  BATTLEPASS:SetupPass(ply)
  
  ply.BattlePass.Owned.tier = amt
end)

net.Receive("BattlePass.OpenMenu", function(len)
  LocalPlayer():ConCommand("battlepass")
end)
--PATH addons/________anticrash/lua/z_anticrash/client/cl_meta.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

local Panel = FindMetaTable('Panel')

function Panel:GetBottomY()
	
	local x,y,w,h = self:GetBounds()
	
	return y+h
	
end

function Panel:GetRightX()
	
	local x,y,w,h = self:GetBounds()
	
	return x+w
	
end
--PATH addons/________anticrash/lua/z_anticrash/panels/p_utils.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER]]

function CL_ANTICRASH.CreateInfoLabel(x, y, h, txt, col, font, parent)

	local infoLbl = vgui.Create( "onyx.Label", parent )
	infoLbl:SetPos(x, y)
	infoLbl:SetFont(font)
	infoLbl:SetContentAlignment( 5 )
	infoLbl:SetTextColor(col)
	infoLbl:SetText(txt)
	infoLbl.UpdateSize = function(self)
		self:SetSize(0,h)
		self:SizeToContentsX()
	end
	infoLbl:UpdateSize()
	
	return infoLbl
	
end

function CL_ANTICRASH.CreateGraphInfoLabel(x, y, w, h, txt, infoKey, showFraction, parent, drawBorders)

	local infoCol = CL_ANTICRASH.GRAPH.COL[infoKey]
	local edgeOffset = 2
	local infoLblOffset = 8

	local bgPanel = vgui.Create("onyx.Panel",parent)
	bgPanel:SetPos(x,y)
	bgPanel:SetSize(w,h)
	bgPanel.Paint = function(self, w, h)
		
		if drawBorders then
		
			-- Left edge
			onyx.hud.DrawRoundedBox( 0, 0, w*0.5, h, infoCol )
			
			-- Right edge
			onyx.hud.DrawRoundedBox( w*0.5, 0, w*0.5, h, infoCol )
			
		end
		
		-- Bg
		onyx.hud.DrawRoundedBox(  edgeOffset, 0, w-(edgeOffset*2), h, onyx:Config('colors.primary') )
		
	end
	
	-- Info name
	CL_ANTICRASH.CreateInfoLabel(x+infoLblOffset,y,h,txt,infoCol, onyx.Font('Comfortaa@20'), parent)

	-- Info value
	local valLbl = CL_ANTICRASH.CreateInfoLabel(0,y,h,"",infoCol, onyx.Font('Comfortaa@20'), parent)
	
	-- Keep value up to date
	valLbl.Think = function()
	
		local graphInfo = CL_ANTICRASH.GRAPH.INFO[infoKey]
		local valTxt = graphInfo.cur
		
		if !showFraction then
			local num = math.Clamp(math.Round(100*(graphInfo.cur/graphInfo.max)),0,100)
			-- valTxt = num.."%"
			valTxt = num
		end
		
		valLbl:SetText(valTxt)
		valLbl:UpdateSize()
		valLbl:SetPos(bgPanel:GetRightX()-infoLblOffset-valLbl:GetWide(),y)
	
	end
	
	return bgPanel
	
end

function CL_ANTICRASH.CreateGraph(x, y, w, h, parent)

	local graphPanel = vgui.Create("onyx.Panel",parent)
	graphPanel:SetPos(x,y)
	graphPanel:SetSize(w,h)
	
	local graphLineOffset = h/6
	local graphLineCount = SH_ANTICRASH.SETTINGS.GRAPH.TIMEWINDOW
	
	graphPanel.Paint = function(self, w, h)
	
		-- Bg
		
		onyx.hud.DrawRoundedBoxEx( 0, 0, w, h, onyx:Config('colors.gray') )
		
		-- Bg Lines
		for i=1, 6 do
			
			local lineY = graphLineOffset*i
		
			surface.SetDrawColor( onyx:Config('colors.primary') )
			surface.DrawLine( 0, lineY, w, lineY)
			
		end
	
		-- Graph Lines
		for k,points in SortedPairs(CL_ANTICRASH.GRAPH.POINTS) do

			local prevGraphPoint = nil
			local lineCol = CL_ANTICRASH.GRAPH.COL[k]
			
			for i=1, #points do
				
				local pointInfo = points[i]
				
				if !prevGraphPoint then
					prevGraphPoint = pointInfo
					continue
				end
				
				local startX, startY = (w/graphLineCount) * (graphLineCount-i+2), h - (h * prevGraphPoint.cur/prevGraphPoint.max)
				local endX, endY = (w/graphLineCount) * (graphLineCount-i+1), h - (h * pointInfo.cur/pointInfo.max)
				
				startY = math.Clamp(startY,1,h-2)
				endY = math.Clamp(endY,1,h-2)
				
				surface.SetDrawColor( lineCol )
				surface.DrawLine( startX, startY+1, endX, endY+1 )
				surface.DrawLine( startX, startY-1, endX, endY-1 )
				surface.DrawLine( startX, startY, endX, endY )
				
				prevGraphPoint = pointInfo
			
			end	
		
		end

	
	end
	
	
	
	return graphPanel

end

function CL_ANTICRASH.CreateUserInfoPanel(x, y, w, h, txt, colKey, funcKey, target, parent)

	local infoLblOffset = 5
	
	-- Info panel
	local infoPanel = vgui.Create("onyx.Panel",parent)
	infoPanel:SetPos(x,y)
	infoPanel:SetSize(w,h)
	infoPanel.Paint = function(self, w, h)
		
		-- Bg
		
		onyx.hud.DrawRoundedBox( 0, 0, w, h, onyx:Config('colors.primary') )
		
	end
	
	-- Info name
	CL_ANTICRASH.CreateInfoLabel(infoLblOffset,0,h,txt,color_white, onyx.Font('Comfortaa@16'), infoPanel)

	-- Info value
	local valLbl = CL_ANTICRASH.CreateInfoLabel(0,0,h,"",color_white, onyx.Font('Comfortaa@16'), infoPanel)
	
	-- Keep value up to date
	local nextThink = 0
	valLbl.Think = function()
	
		if !parent.isExpanded then return end
		
		if nextThink < CurTime() then
	
			local valTxt = CL_ANTICRASH.USERDATA[funcKey](target)
			
			valLbl:SetText(valTxt)
			valLbl:UpdateSize()
			valLbl:SetPos(infoPanel:GetWide()-infoLblOffset-valLbl:GetWide(),0)
			
			nextThink = CurTime() + 0.5
	
		end
	
	end
	
	return infoPanel
	
end

function CL_ANTICRASH.HookSearchInputFilter(searchInput, filterPanels)

	searchInput.OnChange = function(self)
		
		local filter = string.Trim( self:GetText():lower() ) 
		
		local prevFilterPnl = nil
		
		for i=1, #filterPanels do
		
			local filterStr, filterPanel = filterPanels[i].filterStr, filterPanels[i].filterPanel
			
			-- show panel if there is no filter or the filter matches
			if #filter == 0 or string.find( filterStr:lower(), filter, 1, true ) ~= nil then
			
				-- set filtered panel to auto adjust position
				if prevFilterPnl ~= nil then
					filterPanel.prevPnl = prevFilterPnl
				else
					-- make sure the first filtered result is on the start position
					filterPanel.prevPnl = nil
					filterPanel:SetPos(5,searchInput:GetBottomY()+filterPanel.panelOffset)
				end
			
				filterPanel:SetVisible(true)
				
				prevFilterPnl = filterPanel
				
				continue
			end
			
			filterPanel:Hide()
		
		end
		
	end

end
--PATH addons/____bricks_gangs/lua/bricks_server/bricks_server_luacfg_gangs.lua:
--[[ LUA CONFIG ]]--
BRICKS_SERVER.GANGS.LUACFG = {}
BRICKS_SERVER.GANGS.LUACFG.UseMySQL = false -- Whether or not MySQL should be used (enter your details in bricks-gangs/lua/bricks_server/bricks_gangs/sv_mysql.lua)

BRICKS_SERVER.GANGS.LUACFG.MenuCommands = {
    ["!gang"] = true,
    ["/gang"] = true,
    ["!bricksgang"] = true,
    ["/bricksgang"] = true
}
--PATH addons/____bricks_gangs/lua/bricks_server/languages/bricks_gangs/french.lua:
BRICKS_SERVER.Func.AddLanguageStrings( "french", {
    ["gang"] = "Gang",
    ["gangNew"] = "Nouveau Gang",
    ["gangRequestCooldown"] = "Veuillez patienter avant de refaire une demande!",
    ["gangRequestDataCooldown"] = "Veuillez patienter avant de refaire une demande!",
    ["gangNewUpgrade"] = "Nouvelle Amélioration",
    ["gangUpgradeTierEdit"] = "%s - Tier %d",
    ["gangNewAchievement"] = "Nouveau Succès",
    ["gangNewTerritory"] = "Nouveau Territoire",
    ["gangRewardTime"] = "Cooldown des récompenses",
    ["gangRewardTimeQuery"] = "À quelle fréquence le gang occupant doit-il recevoir des récompenses ?",
    ["gangRewards"] = "Récompenses",
    ["gangNewLeaderboard"] = "Nouveau Classement",
    ["gangRankQuery"] = "Quel rang souhaitez-vous lui attribuer ?",
    ["gangPlayerAlreadyRank"] = "Le joueur est déjà de ce rang !",
    ["gangInvalidRank"] = "Rang invalide.",
    ["gangKick"] = "Kick",
    ["gangKickConfirm"] = "Êtes-vous sûr de vouloir virer ce membre ?",
    ["gangSetOwner"] = "Mettre chef",

    ["gangInbox"] = "Boite de réception du gang",
    ["gangNoNotifications"] = "Vous n'avez pas de notification",
    ["gangTimeAgo"] = "il y a %s secondes",
    ["gangNotification"] = "Notification de gang",
    ["gangNotificationHeader"] = "Que voudriez-vous que l'en-tête de la notification soit?",
    ["gangAdminNotification"] = "Admin Notification",
    ["gangNotificationBody"] = "Que souhaitez-vous que le contenu principal de la notification soit?",
    ["gangAdminNotificationSent"] = "Vous avez envoyer une notification à %s!",

    ["gangVariables"] = "Variable de gang",
    ["gangUpgrades"] = "Amélioration de gang",
    ["gangAchievements"] = "Succès du gang",
    ["gangTerritories"] = "Territoires du gang",
    ["gangLeaderboards"] = "Classement des gangs",

    ["gangClaimedAchievement"] = "Vous avez réclamer les récompenses avec succès!",
    ["gangAlreadyAssociation"] = "Votre gang à déjà ce type d'alliance avec ce gang!",
    ["gangAlreadySentAssociation"] = "Votre gang à déjà envoyer une demande d'alliance!",
    ["gangAssociationSent"] = "Demande d'alliance envoyer!",
    ["gangAssociationAccepted"] = "Demande accepter!",
    ["gangNoAssociation"] = "Votre gang n'a aucune alliance avec ce gang!",
    ["gangAssociationDissolved"] = "Alliance dissoute!",

    ["gangOwner"] = "Chef",
    ["gangOfficer"] = "Officier",
    ["gangMember"] = "Membre",

    ["gangCannotDeposit"] = "Vous ne pouvez pas déposer cette arme!",
    ["gangStorageFullError"] = "L'entrepôt de votre gang est plein!",
    ["gangDepositedItem"] = "Vous avez déposez un item dans l'entrepôt du gang!",
    ["gangDroppedItem"] = "Vous avez sortit un objet de l'entrepôt du gang.",
    ["gangUsedItem"] = "Vous avez utiliez un objet depuis l'entrepôt du gang.",
    ["gangCantUse"] = "Vous ne pouvez pas l'utilisez!",

    ["gangKicked"] = "Vous avez été viré du gang %s!",
    ["gangAlreadyIn"] = "Vous êtes déjà dans un gang!",
    ["gangNameLength"] = "Le nom du gang ne peut être plus long que %d caractères!",
    ["gangIconLength"] = "L'URL de l'icône du gang ne peut pas être plus longue que %d caractères!",
    ["gangCreatedFor"] = "Votre nouveau gang a été créé pour %s!",
    ["gangCreated"] = "Votre nouveau gang a été créé!",
    ["gangCreationNoMoney"] = "Vous n'avez pas assez d'argent, vous avez besoin de %s!",
    ["gangWaitBeforeSaving"] = "Veuillez patienter %d quelques secondes avant de sauvegarder à nouveau vos modifications !",
    ["gangRolesUpdated"] = "Rôles du gangs mis à jour!",
    ["gangCannotTarget"] = "Vous ne pouvez pas cibler ce joueur!",
    ["gangRankNotExists"] = "Ce rang n'existe pas !",
    ["gangCantPromote"] = "Vous ne pouvez pas promouvoir quelqu'un à un rang supérieur ou égal au vôtre !",
    ["gangRankSet"] = "Rang attribué avec succès !",
    ["gangRankSetFail"] = "Impossible de fixer le rang !",
    ["gangSettingsUpdated"] = "Paramètres du gangs mis à jour !",
    ["gangPlayerKicked"] = "Vous avez viré avec succès  %s de votre gang !",
    ["gangPlayerKickError"] = "Erreur lors du renvoi du membre du gang!",
    ["gangWaitBeforeInvite"] = "Veuillez attendre 5 secondes avant d'inviter un autre joueur !",
    ["gangPlayerOffline"] = "Ce joueur n'est plus en ligne !",
    ["gangPlayerAlreadyInvited"] = "Ce joueur a déjà été invité !",
    ["gangPlayerInvited"] = "Vous avez invité  %s dans votre gang !",
    ["gangInviteReceived"] = "Vous avez été invité à rejoindre le gang %s ! Tapez !gang pour accepter.",
    ["gangLeaveCurrent"] = "Vous devez d'abord quitter votre gang actuel !",
    ["gangReachedMemberLimit"] = "Le gang a atteint sa limite de membres !",
    ["gangJoined"] = "Vous avez rejoint avec succèsle gang %s!",
    ["gangNotEnoughMoney"] = "Vous n'avez pas assez d'argent !",
    ["gangDepositedMoney"] = "Vous avez réussi à déposer %s dans votre gang !",
    ["gangWithdrewMoney"] = "Vous avez réussi à retirer  %s de votre gang !",
    ["gangDisbanded"] = "Vous avez dissous : %s!",
    ["gangOwnershipTransfered"] = "Transfert de la propriété de %s à %s réussi !",
    ["gangLeft"] = "Vous avez quitté le gang : %s!",

    ["gangTerritoryCaptured"] = "Votre gang a conquis le territoire suivant : %s!",
    ["gangIncorrectLevel"] = "Votre gang n'est pas le bon niveau pour acheter cette amélioration !",
    ["gangIncorrectGroup"] = "Vous n'êtes pas dans le bon groupe pour acheter cette amélioration !",
    ["gangUpgradeBought"] = "Amélioration achetée pour %s!",
    ["gangNotEnoughFunds"] = "Votre gang n'a pas assez de fonds pour acheter cette amélioration !",

    ["gangAddAchievement"] = "Ajouter un succès",
    ["gangNewAchievementType"] = "Quel doit être le type de ce nouveau succès ?",
    ["gangAddLeaderboard"] = "Ajouter un classement",
    ["gangNewLeaderboardType"] = "Quel devrait être le type du nouveau classement ?",
    ["gangAddTerritory"] = "Ajouter un Territoire",
    ["gangAddTier"] = "Ajouter un Tier",
    ["gangTierX"] = "Tier %d",
    ["gangNewUpgradeType"] = "Quel devrait être le type de l'amélioration?",
    ["gangNewUpgradeDesc"] = "Description de la nouvelle amélioration.",

    ["gangDepositMenu"] = "Gang - Menu de dépôt",
    ["gangDepositInventoryQuery"] = "Souhaitez-vous déposer %s de votre inventaire?",
    ["gangDepositPlayerQuery"] = "Vous voulez déposer %s depuis votre équipement?",
    ["gangNoDepositItems"] = "Vous n'avez aucun objet pouvant être déposé !",

    ["gangMenu"] = "Menu du Gang",
    ["gangNone"] = "Vous n'êtes pas dans un gang",
    ["gangID"] = "ID: %d",
    ["gangDashboard"] = "Tableau de bord",
    ["gangMembers"] = "Membres",
    ["gangStorage"] = "Stockage",
    ["gangUpgrades"] = "Améliorations",
    ["gangBalance"] = "Banque",
    ["gangAchievements"] = "Succès",
    ["gangAssociations"] = "Alliances",
    ["gangLeaderboards"] = "Classements",
    ["gangTerritories"] = "Territoires",
    ["gangRanks"] = "Rangs",
    ["gangCreate"] = "Créer un gang",
    ["gangProgress"] = "Progression: %s",

    ["gangNoneFound"] = "Aucun gang n'a été trouvé correspondant à votre recherche.",
    ["gangMemberCount"] = "%d/%d Membres",
    ["gangFailedToLoad"] = "Échec du chargement des données sur le gang!",
    ["gangSetRank"] = "Modifier le rang",
    ["gangDissolveAssociation"] = "Souhaitez-vous dissoudre cette alliance?",
    ["gangAssociationStatus"] = "Status: %s",
    ["gangNeutral"] = "Neutre",
    ["gangCreateString"] = "Créer un gang pour %s",
    ["gangName"] = "Nom du Gang:",
    ["gangIcon"] = "Icon URL:",
    
    ["gangInformation"] = "INFORMATIONS DU GANG",
    ["gangChat"] = "CHAT",
    ["gangMessage"] = "Message de gang",
    ["gangActions"] = "ACTIONS",
    ["gangDepositMoney"] = "Déposer de l'argent",
    ["gangDepositMoneyQuery"] = "Quel montant souhaitez-vous déposer ?",
    ["gangDepositMoneyLess"] = "Vous ne pouvez pas déposer moins de %s!",
    ["gangDepositMoneyMuch"] = "Votre compte de gang ne peut pas contenir autant, vous devez améliorer votre stockage d'argent !",
    ["gangWithdrawMoney"] = "Retirer de l'argent",
    ["gangWithdrawMoneyQuery"] = "Quel montant souhaitez-vous retirer ?",
    ["gangWithdrawMoneyLess"] = "Vous ne pouvez pas retirer moins de %s!",
    ["gangWithdrawMoneyMuch"] = "Votre gang n'a pas assez de fonds!",
    ["gangInvitePlayer"] = "Inviter un joueur",
    ["gangInvitePlayerQuery"] = "Quel joueur souhaitez-vous inviter ?",
    ["gangDisband"] = "Dissoudre le gang",
    ["gangDisbandQuery"] = "La suppression de votre gang ne peut pas être annulée, tapez %s pour la supprimer.",
    ["gangTransfer"] = "Transfert de propriété",
    ["gangTransferQuery"] = "À qui souhaitez-vous transférer la propriété du gang?",
    ["gangLeave"] = "Quitter le gang",
    ["gangLeaveQuery"] = "Êtes-vous sûr de vouloir quitter ce gang ?",
    ["gangMemberUpper"] = "MEMBRES DU GANG",
    ["gangHighestRank"] = "Rang le plus élevé",
    ["gangLowestRank"] = "Rang le plus bas",

    ["gangUnsavedChanges"] = "Attention ! Vous avez des modifications non sauvegardées.",
    ["gangSaveChanges"] = "Enregistrer les modifications",
    ["gangReset"] = "Reset",
    ["gangRanksUpper"] = "RANGS",
    ["gangNewRank"] = "Nouveau rang",
    ["gangRankName"] = "Nom du Rang",
    ["gangRankColor"] = "Couleur",
    ["gangClearPerms"] = "Nettoyer les permissions",
    ["gangDeleteRank"] = "Supprimer le rang",
    ["gangDeleteRankQuery"] = "Êtes-vous sûr de vouloir supprimer ce rang ?",

    ["gangStorageUpper"] = "STOCKAGE",
    ["gangStorageProgress"] = "Stockage %d/%d",
    ["gangClaimed"] = "Déjà Réclamé",
    ["gangUnclaimed"] = "Disponible",
    ["gangClaimedAgo"] = "Réclamé il y a %s secondes",
    ["gangRewardsEvery"] = "Donner toutes les %s secondes",
    ["gangBuyUpgrade"] = "Voulez-vous acheter cette amélioration pour %s?",
    ["gangUpgradeTier"] = "Tier d'amélioration %d/%d",
    ["gangCurrent"] = "Tier actuel: %s",
    ["gangNext"] = "Prochain tier: %s",

    ["gangTerritoryUpper"] = "TERRITOIRE",
    ["gangCaptured"] = "CAPTURÉ",
    ["gangTerritoryAlready"] = "Votre gang a déjà conquis ce territoire !",
    ["gangCaptureFail"] = "Vous vous êtes trop éloigné ou vous êtes mort, la capture a échoué !",
    ["gangTerritoryPlaced"] = "Territoire placé avec succès.",
    ["gangInvalidTerritory"] = "Territoire non valide, choisissez un territoire valide dans le menu outil.",
    ["gangTerritoryRemoved"] = "Territoire retiré avec succès.",
    ["gangTerritoryRemoveFail"] = "Vous ne pouvez utiliser cet outil que pour supprimer/créer un territoire.",
    ["gangTerritoryDesc"] = "Placer et retirer des territoires du serveur, Clic gauche - placer, Clic droit - retirer.",
    ["gangTerritory"] = "Territoire",
    ["gangTerritoryPlacer"] = "Outil de territoire",
    ["gangTerritoryDescSmall"] = "Placer et supprimer des territoires",
    ["gangTerritoryInstructions"] = "Clic gauche - placer, Clic droit - supprimer.",

    ["gangSettings"] = "Paramètres",
    ["gangManagement"] = "Gestion",
    ["gangChatLower"] = "Chat du gang",
    ["gangDepositItems"] = "Déposer des objets",
    ["gangWithdrawItems"] = "Retirer des objets",
    ["gangViewStorage"] = "Voir le stockage",
    ["gangEditRoles"] = "Modifier les rôles",
    ["gangEditSettings"] = "Modifier les paramètres",
    ["gangInvitePlayers"] = "Inviter des joueurs",
    ["gangKickPlayers"] = "Exclure des joueurs",
    ["gangChangeRank"] = "Changer le rang des joueurs",
    ["gangPurchaseUpgrades"] = "Acheter des améliorations",
    ["gangAcceptDeclineInbox"] = "Accepter/décliner les notifications",
    ["gangAssociationSend"] = "Envoyer des demandes d'alliance",
    ["gangAssociationAccept"] = "Accepter des demandes d'alliance",
    ["gangSendChatMessages"] = "Envoyer un message dans le chat",
    ["gangMaxMembers"] = "Nombre de membres maximum",
    ["gangMaxBalance"] = "Argent maximum dans la banque",
    ["gangStorageSlots"] = "Slots de stockages",
    ["gangXSlots"] = "%d Slots",
    ["gangSlots"] = "Slots",
    ["gangIncreasedHealth"] = "Une santé accrue",
    ["gangExtraHealth"] = "Santé supplémentaire",
    ["gangXHP"] = "+%d HP",
    ["gangIncreasedArmor"] = "Un blindage renforcé",
    ["gangXAP"] = "+%d AP",
    ["gangExtraArmor"] = "Armure supplémentaire",
    ["gangIncreasedSalary"] = "Augmentation du salaire",
    ["gangExtraSalary"] = "Salaire supplémentaire",
    ["gangPermWeapon"] = "Arme permanente",
    ["gangWeapon"] = "Arme",
    ["gangBalanceFull"] = "Banque du gang",
    ["gangMembersFull"] = "Membres du gang",
    ["gangStorageFull"] = "Stockage du gang",
    ["gangItems"] = "Items",
    ["gangItem"] = "Item",
    ["gangLevel"] = "Level du gang",
    ["gangInvite"] = "Invitations",
    ["gangInviteReceivedInbox"] = "Vous avez été invité à rejoindre le gang %s !",
    ["gangAssociationInvite"] = "Demandes d'alliance",
    ["gangAssociationInviteInbox"] = "Le gang %s a demandé une alliance %s avec votre gang!",
    ["gangAssociationCreated"] = "Alliance créée",
    ["gangAssociationCreatedInbox"] = "Votre gang a maintenant en alliance %s avec le gang %s !",
    ["gangAssociationDissolved"] = "Alliance dissoute",
    ["gangAssociationDissolvedInbox"] = "Votre alliance avec le gang %s a été dissoute!",
    ["gangInboxAchievement"] = "Succès",
    ["gangInboxAchievementCompleted"] = " Votre gang a accomplis le succès '%s!",
    ["gangInboxAchievementCompletedReward"] = "Votre gang a accomplis le succès '%s', récompenses : %s!",
    ["gangExperienceFull"] = "Expérience du Gang",
    ["gangJobWhitelist"] = "Job Whitelist",
    ["gangJobs"] = "Jobs",
    ["gangJobsSelect"] = "Sélectionnez les métiers dont les joueurs sont inscrits sur la whitelist.",
    ["gangStorageItems"] = "Objets de stockage",
    ["gangAllyRequest"] = "Êtes-vous sûr de vouloir demander à vous allier à ce gang?",
    ["gangWarRequest"] = "Êtes-vous sûr de vouloir demander une guerre avec ce gang?",
    ["gangSetLevel"] = "Set Level",
    ["gangSetLevelQuery"] = "Quel devrait être le nouveau niveau du gang ?",
    ["gangSetLevelMsg"] = "Vous avez réussi à fixer le niveau du gang %s à %d!",
    ["gangAddExperience"] = "Ajouter de l'expérience",
    ["gangAddExperienceQuery"] = "Combien d'expérience souhaitez-vous ajouter au gang?",
    ["gangAddExperienceMsg"] = "Vous avez ajouter %s  d'expérience au gang %s!",
    ["gangSetBalance"] = "Changer le solde ",
    ["gangSetBalanceQuery"] = "Quel devrait être le nouveau solde de la banque du gang ??",
    ["gangSetBalanceMsg"] = "Vous avez réussi à mettre à jour le solde de %s du gang %s!",
    ["gangAddBalance"] = "Ajouter de l'argent",
    ["gangAddBalanceQuery"] = "Combien d'argent souhaitez-vous ajouter au solde du gang?",
    ["gangAddBalanceMsg"] = "Vous avez ajouté %s au solde du gang %s!",
    ["gangViewMembers"] = "Voir les membres",
    ["gangCantKickOwner"] = "Vous ne pouvez pas donner exclure le propriétaire du gang!",
    ["gangKickSuccessAdmin"] = "Vous avez exclus le membre du gang!",
    ["gangKickFailAdmin"] = "Impossible d'exclure le membre du gang!",
    ["gangSetRankSuccessAdmin"] = "Vous avez mis à jour le rang de ce membre!",
    ["gangSetRankFailAdmin"] = "Impossible de changer le rang de ce membre!",
    ["gangMemberAlreadyOwner"] = "Ce membre est déjà le propriétaire de ce gang!",
    ["gangNotMember"] = "Ce joueur n'est pas membre du gang!",
    ["gangOwnershipTransferedAdmin"] = "Vous avez transférer le rôle de chef du gang!",
    ["gangDeleteAdminQuery"] = "La suppression d'un gang ne peut pas être annulée, tapez %s pour le supprimer.",
    ["gangDeleteSuccessAdmin"] = "Vous avez supprimer le gang %s!",
    ["gangMenuBind"] = "Touche pour le menu des gangs",
} )
--PATH addons/____bricks_gangs/lua/bricks_server/languages/bricks_gangs/german.lua:
BRICKS_SERVER.Func.AddLanguageStrings( "german", {
    ["gang"] = "Gang",
    ["gangNew"] = "Neue Gang",
    ["gangRequestCooldown"] = "Bitte warte, bevor du weitere Gangs anforderst!",
    ["gangRequestDataCooldown"] = "Bitte warte, bevor du Daten über eine andere Gang anforderst.",
    ["gangNewUpgrade"] = "Neue Verbesserung",
    ["gangUpgradeTierEdit"] = "%s - Stufe %d",
    ["gangNewAchievement"] = "Neuen Erfolg",
    ["gangNewTerritory"] = "Neues Gebiet",
    ["gangRewardTime"] = "Belohnungszeit",
    ["gangRewardTimeQuery"] = "Wie oft sollen Gangmitglieder Belohnungen erhalten?",
    ["gangRewards"] = "Belohnungen",
    ["gangNewLeaderboard"] = "Neue Bestenliste",
    ["gangRankQuery"] = "Auf welchen Rang möchtest du das setzen?",
    ["gangPlayerAlreadyRank"] = "Der Spieler hat schon diesen Rang.",
    ["gangInvalidRank"] = "Ungültiger Rang.",
    ["gangKick"] = "Rauswerfen",
    ["gangKickConfirm"] = "Bist du dir sicher, dass du diesen Spieler aus der Gang werfen möchtest?",
    ["gangSetOwner"] = "Leiter einstellen",

    ["gangInbox"] = "GANG-POSTEINGANG",
    ["gangNoNotifications"] = "Du hast keine Benachrichtigungen.",
    ["gangTimeAgo"] = "vor %s",
    ["gangNotification"] = "Gang Benachrichtigung",
    ["gangNotificationHeader"] = "Was soll der Titel der Benachrichtigung sein?",
    ["gangAdminNotification"] = "Admin-Benachrichtigung",
    ["gangNotificationBody"] = "Was soll der Inhalt der Benachrichtigung sein?",
    ["gangAdminNotificationSent"] = "Sende eine Admin-Benachrichtigung an %s!",

    ["gangVariables"] = "Gangvariablen",
    ["gangUpgrades"] = "Gangverbesserungen",
    ["gangAchievements"] = "Gangerfolge",
    ["gangTerritories"] = "Ganggebiete",
    ["gangLeaderboards"] = "Gang-Bestenlisten",

    ["gangClaimedAchievement"] = "Erfolgreich beanspruchte Belohnungen",
    ["gangAlreadyAssociation"] = "Deine Gang führt bereits eine Art dieser Diplomatie mit einer anderen Gang.",
    ["gangAlreadySentAssociation"] = "Deine Gang hat bereits eine Diplomatie-Anfrage an diese Gang versendet!",
    ["gangAssociationSent"] = "Diplomatie-Anfrage erfolgreich versendet.",
    ["gangAssociationAccepted"] = "Diplomatie-Anfrage angenommen.",
    ["gangNoAssociation"] = "Deine Gang führt keine Diplomatie mit dieser Gang.",
    ["gangAssociationDissolved"] = "Diplomatie aufgelöst!",

    ["gangOwner"] = "Besitzer",
    ["gangOfficer"] = "Offizier",
    ["gangMember"] = "Mitglied",

    ["gangCannotDeposit"] = "Du kannst diese Waffe nicht einlagern.",
    ["gangStorageFullError"] = "Dein Ganglager ist voll!",
    ["gangDepositedItem"] = "Du hast einen Gegenstand in das Lager deiner Gang eingezahlt.",
    ["gangDroppedItem"] = "Einen Gegenstand aus dem Lager der Gang fallen gelassen.",
    ["gangUsedItem"] = "Benutze einen Gegenstand aus dem Lager deiner Gang.",
    ["gangCantUse"] = "Du kannst das nicht benutzen!",

    ["gangKicked"] = "Du wurdest aus der Gang %s geworfen!",
    ["gangAlreadyIn"] = "Du bist bereits Mitglied einer Gang!",
    ["gangNameLength"] = "Der Gangname kann nicht länger als %d Zeichen sein!",
    ["gangIconLength"] = "Die URL des Ganglogos kann nicht länger als %d Zeichen sein!",
    ["gangCreatedFor"] = "Du hast eine neue Gang für %s erstellt!",
    ["gangCreated"] = "Deine neue Gang wurde erstellt.",
    ["gangCreationNoMoney"] = "Du hast nicht genügend Geld, du brauchst %s!",
    ["gangWaitBeforeSaving"] = "Bitte warte %d Sekunden warten, bevor du erneut Änderungen speicherst.",
    ["gangRolesUpdated"] = "Gangrollen aktualisiert!",
    ["gangCannotTarget"] = "Du kannst diesen Spieler nicht auswählen!",
    ["gangRankNotExists"] = "Dieser Rang existiert nicht.",
    ["gangCantPromote"] = "Du kannst niemanden in einen höheren oder gleichrangigen Rang befördern.",
    ["gangRankSet"] = "Der Rang wurde erfolgreich gesetzt.",
    ["gangRankSetFail"] = "Es gab einen Fehler bei der Rangvergabe.",
    ["gangSettingsUpdated"] = "Gangeinstellungen erfolgreich aktualisiert.",
    ["gangPlayerKicked"] = "Du hast den Spieler %s aus deiner Gang geworfen.",
    ["gangPlayerKickError"] = "Es gab einen Fehler beim Rauswurf aus der Gang.",
    ["gangWaitBeforeInvite"] = "Bitte warte 5 Sekunden, bevor du einen neuen Spieler einlädst.",
    ["gangPlayerOffline"] = "Dieser Spieler ist nicht länger online.",
    ["gangPlayerAlreadyInvited"] = "Dieser Spieler wurde bereits eingeladen.",
    ["gangPlayerInvited"] = "Du hast den Spieler %s in deine Gang eingeladen.",
    ["gangInviteReceived"] = "Du wurdest eingeladen, der Gang %s beizutreten! Schreibe !gang um beizutreten.",
    ["gangLeaveCurrent"] = "Du musst zuerst deine aktuelle Gang verlassen.",
    ["gangReachedMemberLimit"] = "Die Gang hat bereits ihr Mitgliederlimit erreicht.",
    ["gangJoined"] = "Du bist erfolgreich der Gang %s beizutreten!",
    ["gangNotEnoughMoney"] = "Du hast nicht genügend Geld dabei!",
    ["gangDepositedMoney"] = "Du hast %s in die Gang eingezahlt.",
    ["gangWithdrewMoney"] = "Du hast dir %s aus der Gang ausgezahlt.",
    ["gangDisbanded"] = "Du hast die Gang %s erfolgreich aufgelöst!",
    ["gangOwnershipTransfered"] = "Du hast die Besitztümerrechte der Gang %s auf %s übertragen!",
    ["gangLeft"] = "Du hast die Gang %s verlassen!",

    ["gangTerritoryCaptured"] = "Deine Gang hat das Gebiet %s erfolgreich eingenommen!",
    ["gangIncorrectLevel"] = "Deine Gang hat nicht die benötigte Stufe, um diese Verbesserung freizuschalten.",
    ["gangIncorrectGroup"] = "Du hast nicht den richtigen Rang, um die Verbesserung freizuschalten.",
    ["gangUpgradeBought"] = "Verbesserung für %s gekauft!",
    ["gangNotEnoughFunds"] = "Deine Gang hat nicht genügend Geld, um diese Verbesserung zu kaufen.",

    ["gangAddAchievement"] = "Erfolg hinzufügen",
    ["gangNewAchievementType"] = "Welche Art von Erfolg möchtest du hinzufügen?",
    ["gangAddLeaderboard"] = "Bestenliste hinzufügen",
    ["gangNewLeaderboardType"] = "Welche Art von Bestenliste möchtest du hinzufügen?",
    ["gangAddTerritory"] = "Gebiet hinzufügen",
    ["gangAddTier"] = "Stufe hinzufügen",
    ["gangTierX"] = "Stufe %d",
    ["gangNewUpgradeType"] = "Was soll die neue Verbesserung sein?",
    ["gangNewUpgradeDesc"] = "Beschreibung der neuen Verbesserung",

    ["gangDepositMenu"] = "Gang - Einzahlungsmenü",
    ["gangDepositInventoryQuery"] = "Möchtest du %s aus deinem Inventar einzahlen?",
    ["gangDepositPlayerQuery"] = "Möchtest du %s einzahlen?",
    ["gangNoDepositItems"] = "Du hast keinen Gegenstand, der eingezahlt werden kann.",

    ["gangMenu"] = "Gang Menü",
    ["gangNone"] = "Keine Gang",
    ["gangID"] = "ID: %d",
    ["gangDashboard"] = "Startseite",
    ["gangMembers"] = "Mitglieder",
    ["gangStorage"] = "Lager",
    ["gangUpgrades"] = "Verbesserungen",
    ["gangBalance"] = "Kontostand",
    ["gangAchievements"] = "Erfolge",
    ["gangAssociations"] = "Diplomatie",
    ["gangLeaderboards"] = "Bestenlisten",
    ["gangTerritories"] = "Gebiete",
    ["gangRanks"] = "Ränge",
    ["gangCreate"] = "Erstelle eine Gang",
    ["gangProgress"] = "Fortschritt: %s",

    ["gangNoneFound"] = "Es wurde keine Gang gefunden, die deiner Suchanfrage entspricht.",
    ["gangMemberCount"] = "%d/%d Mitglieder",
    ["gangFailedToLoad"] = "Es gab einen Fehler beim Laden der Gangdata!",
    ["gangSetRank"] = "Setze Rang",
    ["gangDissolveAssociation"] = "Möchtest du diese diplomatische Beziehung auflösen?",
    ["gangAssociationStatus"] = "Status: %s",
    ["gangNeutral"] = "Neutral",
    ["gangCreateString"] = "Erstelle eine Gang für %s",
    ["gangName"] = "Gangname:",
    ["gangIcon"] = "Logo URL:",
    
    ["gangInformation"] = "GANG INFORMATION",
    ["gangChat"] = "GANG CHAT",
    ["gangMessage"] = "Schreibe eine Nachricht",
    ["gangActions"] = "GANG AKTIONEN",
    ["gangDepositMoney"] = "Geld einzahlen",
    ["gangDepositMoneyQuery"] = "Wie viel Geld möchtest du einzahlen?",
    ["gangDepositMoneyLess"] = "Du kannst nicht weniger als %s einzahlen!",
    ["gangDepositMoneyMuch"] = "Dein Gangkonto kann die Summe nicht halten, du musst den maximalen Kontostand erhöhen!",
    ["gangWithdrawMoney"] = "Geld auszahlen",
    ["gangWithdrawMoneyQuery"] = "Wie viel Geld möchtest du auszahlen?",
    ["gangWithdrawMoneyLess"] = "Du kannst nicht weniger als %s auszahlen!",
    ["gangWithdrawMoneyMuch"] = "Deine Gang hat nicht genug Geld auf dem Konto!",
    ["gangInvitePlayer"] = "Spieler einladen",
    ["gangInvitePlayerQuery"] = "Welchen Spieler möchtest du in die Gang einladen?",
    ["gangDisband"] = "Gang auflösen",
    ["gangDisbandQuery"] = "Die Löschung einer Gang kann nicht widerrufen werden, gebe %s zur Bestätigung ein.",
    ["gangTransfer"] = "Eigentum übertragen",
    ["gangTransferQuery"] = "Wer soll der neue Eigentümer der Gang sein?",
    ["gangLeave"] = "Gang verlassen",
    ["gangLeaveQuery"] = "Bist du dir sicher, dass du diese Gang verlassen möchtest?",
    ["gangMemberUpper"] = "GANG MITGLIEDER",
    ["gangHighestRank"] = "Höchster Rang",
    ["gangLowestRank"] = "Niedrigster Rang",

    ["gangUnsavedChanges"] = "Warnung! Du hast ungespeicherte Änderungen vorgenommen.",
    ["gangSaveChanges"] = "Änderungen speichern",
    ["gangReset"] = "Zurücksetzen",
    ["gangRanksUpper"] = "GANGRÄNGE",
    ["gangNewRank"] = "Neuer Rang",
    ["gangRankName"] = "Rangname",
    ["gangRankColor"] = "Rangfarbe",
    ["gangClearPerms"] = "Berechtigungen löschen",
    ["gangDeleteRank"] = "Lösche Rang",
    ["gangDeleteRankQuery"] = "Bist du dir sicher, dass du diesen Rang entfernen möchtest?",

    ["gangStorageUpper"] = "GANGLAGER",
    ["gangStorageProgress"] = "Lagerbestand %d/%d",
    ["gangClaimed"] = "Erobert",
    ["gangUnclaimed"] = "Frei",
    ["gangClaimedAgo"] = "Vor %s erobert",
    ["gangRewardsEvery"] = "Alle %s vergeben",
    ["gangBuyUpgrade"] = "Möchtest du diese Verbesserung für %s kaufen?",
    ["gangUpgradeTier"] = "Verbesserungsstufe %d/%d",
    ["gangCurrent"] = "Aktuell: %s",
    ["gangNext"] = "Nächste Stufe: %s",

    ["gangTerritoryUpper"] = "GEBIETE",
    ["gangCaptured"] = "EROBERT",
    ["gangTerritoryAlready"] = "Deine Gang hat dieses Gebiet bereits erobert!",
    ["gangCaptureFail"] = "Du bist zu weit entfernt oder gestorben, Eroberung fehlgeschlagen!",
    ["gangTerritoryPlaced"] = "Gebiet erfolgreich platziert.",
    ["gangInvalidTerritory"] = "Ungültiges Gebiet, wähle ein gültiges Gebiet im Toolgun Menü.",
    ["gangTerritoryRemoved"] = "Gebiet erfolgreich entfernt.",
    ["gangTerritoryRemoveFail"] = "Du kannst dieses Tool nur zum Platzieren/Entfernen von Gebieten genutzt werden.",
    ["gangTerritoryDesc"] = "Entfernt und Platziert Gebiete von Bricks Servers, Linksklick - Platzieren, Rechtsklick - Entfernen.",
    ["gangTerritory"] = "Gebiet",
    ["gangTerritoryPlacer"] = "Gebieteplatzierer",
    ["gangTerritoryDescSmall"] = "Platziert und Entfernt Gebiete von Bricks Servers.",
    ["gangTerritoryInstructions"] = "Linksklick - Platzieren, Rechtsklick - Entfernen.",

    ["gangSettings"] = "Einstellungen",
    ["gangManagement"] = "Management",
    ["gangChatLower"] = "Gangchat",
    ["gangDepositItems"] = "Gegenstände einlagern",
    ["gangWithdrawItems"] = "Gegenstände auslagern",
    ["gangViewStorage"] = "Lagerbestand ansehen",
    ["gangEditRoles"] = "Gruppen bearbeiten",
    ["gangEditSettings"] = "Einstellungen bearbeiten",
    ["gangInvitePlayers"] = "Spieler einladen",
    ["gangKickPlayers"] = "Spieler rauswerfen",
    ["gangChangeRank"] = "Ändert den Rang eines Spielers",
    ["gangPurchaseUpgrades"] = "Kaufe Verbesserungen",
    ["gangAcceptDeclineInbox"] = "Posteingangs-Benachrichtigungen akzeptieren/ablehnen",
    ["gangAssociationSend"] = "Sende Diplomatieanfrage",
    ["gangAssociationAccept"] = "Akzeptiere Diplomatieeinladung",
    ["gangSendChatMessages"] = "Sende Chatnachrichten",
    ["gangMaxMembers"] = "Max Mitglieder",
    ["gangMaxBalance"] = "Max Kontostand",
    ["gangStorageSlots"] = "Lagerplätze",
    ["gangXSlots"] = "%d Plätze",
    ["gangSlots"] = "Plätze",
    ["gangIncreasedHealth"] = "Verbesserte Gesundheit",
    ["gangExtraHealth"] = "Extra Gesundheit",
    ["gangXHP"] = "+%d HP",
    ["gangIncreasedArmor"] = "Verbesserte Rüstung",
    ["gangXAP"] = "+%d AP",
    ["gangExtraArmor"] = "Extra Rüstung",
    ["gangIncreasedSalary"] = "Erhöhtes Gehalt",
    ["gangExtraSalary"] = "Extra Gehalt",
    ["gangPermWeapon"] = "Permanente Waffe",
    ["gangWeapon"] = "Waffen",
    ["gangBalanceFull"] = "Gang-Kontostand",
    ["gangMembersFull"] = "Gangmitglieder",
    ["gangStorageFull"] = "Ganglager",
    ["gangItems"] = "Gegenstände",
    ["gangItem"] = "Gegenstand",
    ["gangLevel"] = "Ganglevel",
    ["gangInvite"] = "Gangeinladung",
    ["gangInviteReceivedInbox"] = "Du wurdest eingeladen, der Gang %s beizutreten!",
    ["gangAssociationInvite"] = "Diplomatie-Anfrage",
    ["gangAssociationInviteInbox"] = "Die Gang %s hat angefragt, die Diplomatie mit eurer Gang auf '%s' zu setzen!",
    ["gangAssociationCreated"] = "Diplomatie gestartet",
    ["gangAssociationCreatedInbox"] = "Deine Gang führt nur die Diplomatieart '%s'mit der Gang %s!",
    ["gangAssociationDissolved"] = "Diplomatisches Verhältnis aufgelöst!",
    ["gangAssociationDissolvedInbox"] = "Euer diplomatisches Verhältnis mit der Gang %s wurde aufgelöst.",
    ["gangInboxAchievement"] = "Gangerfolg",
    ["gangInboxAchievementCompleted"] = "Deine Gang hat den Erfolg '%s' erreicht.",
    ["gangInboxAchievementCompletedReward"] = "Deine Gang hat den Erfolg '%s' abgeschlossen, Belohnung(en): %s!",
    ["gangExperienceFull"] = "Gangerfahrung",
    ["gangJobWhitelist"] = "Job Whitelist",
    ["gangJobs"] = "Jobs",
    ["gangJobsSelect"] = "Wähle die Teams aus, für welche die Spieler gewhitelistet werden.",
    ["gangStorageItems"] = "Lagere Gegenstände",
    ["gangAllyRequest"] = "Bist du dir sicher, dass du mit dieser Gang ein Bündnis anfragen möchtest?",
    ["gangWarRequest"] = "Bist du dir sicher, dass du mit dieser Gang Krieg führen möchtest?",
    ["gangSetLevel"] = "Setze Level",
    ["gangSetLevelQuery"] = "Was soll das neue Level der Gang sein?",
    ["gangSetLevelMsg"] = "Das Level der Gang %s wurde auf %d gesetzt!",
    ["gangAddExperience"] = "Füge Erfahrung hinzu",
    ["gangAddExperienceQuery"] = "Wie viel Erfahrung möchtest du dieser Gang hinzufügen?",
    ["gangAddExperienceMsg"] = "Du hast %s Erfahrungspunkte der Gang %s hinzugefügt!",
    ["gangSetBalance"] = "Setze Kontostand",
    ["gangSetBalanceQuery"] = "Was soll der neue Kontostand der Gang sein?",
    ["gangSetBalanceMsg"] = "Du hast den Kontostand der Gang %s auf %s gesetzt!",
    ["gangAddBalance"] = "Kontostand erhöhen",
    ["gangAddBalanceQuery"] = "Wie viel Geld möchtest du der Gang hinzufügen?",
    ["gangAddBalanceMsg"] = "Du hast %s dem Kontostand der Gang %s hinzugefügt!",
    ["gangViewMembers"] = "Mitglieder ansehen",
    ["gangCantKickOwner"] = "Du kannst den Besitzer der Gang nicht rauswerfen!",
    ["gangKickSuccessAdmin"] = "Du hast das Mitglied der Gang erfolgreich rausgeworfen.",
    ["gangKickFailAdmin"] = "Es gab einen Fehler beim Rauswurf des Gangmitglieds.",
    ["gangSetRankSuccessAdmin"] = "Den Rang des Gangmitglieds erfolgreich gesetzt.",
    ["gangSetRankFailAdmin"] = "Es gab einen Fehler beim Setzen des Rangs des Gangmitglieds.",
    ["gangMemberAlreadyOwner"] = "Dieser Spieler ist bereits der Besitzer der Gang.",
    ["gangNotMember"] = "Dieser Spieler ist nicht Mitglied der Gang.",
    ["gangOwnershipTransferedAdmin"] = "Besitztumsrechte der Gang erfolgreich übertragen.",
    ["gangDeleteAdminQuery"] = "Die Löschung einer Gang kann nicht widerrufen werden, gebe %s zur Bestätigung ein.",
    ["gangDeleteSuccessAdmin"] = "Du hast die Gang %s erfolgreich gelöscht!",
    ["gangMenuBind"] = "Gangmenü - Bind",

    ["gangTerritoryBeingCaptured"] = "Dein Ganggebiet %s wird gerade erobert!",
} )
--PATH addons/____bricks_gangs/lua/bricks_server/bricks_gangs/sh_clientconfig.lua:
--[[
    !!WARNING!!
        ALL CONFIG IS DONE INGAME, DONT EDIT ANYTHING HERE
        Type !bricksserver ingame or use the f4menu
    !!WARNING!!
]]--

-- Gangs --
if( BRICKS_SERVER.Func.IsModuleEnabled( "gangs" ) ) then
    BRICKS_SERVER.BASECLIENTCONFIG.GangMenuBind = { BRICKS_SERVER.Func.L( "gangMenuBind" ), "bind", 0 }
end
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_colsheet.lua:

local PANEL = {}

AccessorFunc( PANEL, "ActiveButton", "ActiveButton" )

function PANEL:Init()
	self.Navigation = vgui.Create( "bricks_server_scrollpanel", self )
	self.Navigation:Dock( LEFT )
	self.Navigation:SetWidth( BRICKS_SERVER.DEVCONFIG.MainNavWidth )
	self.Navigation:DockMargin( 0, 0, 0, 0 )
	self.Navigation.Paint = function( self2, w, h )
		draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ), false, false, true, false )
	end

	self.Content = vgui.Create( "Panel", self )
	self.Content:Dock( FILL )

	self.Items = {}
end

function PANEL:AddLinebreak()
	local lineBreak = vgui.Create( "DPanel", self.Navigation )
	lineBreak:Dock( TOP )
	lineBreak:DockMargin( 0, 0, 0, 10 )
	lineBreak:SetTall( 5 )
	lineBreak.Paint = function( self2, w, h )
		surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
		surface.DrawRect( 0, 0, w, h )
	end
end

function PANEL:AddSheet( label, panel, onLoad, icon, color1, color2 )
	if ( !IsValid( panel ) ) then return end

	local Sheet = {}
	Sheet.Button = vgui.Create( "DButton", self.Navigation )
	Sheet.Button.Target = panel
	Sheet.Button:Dock( TOP )
	Sheet.Button:DockMargin( 7, 0, 7, 10 )
	Sheet.Button:SetText( "" )
	Sheet.Button:SetTall( BRICKS_SERVER.Func.ScreenScale( 40 ) )
	Sheet.Button:SetColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( string.upper( label ) )
	local iconMat
	BRICKS_SERVER.Func.GetImage( icon or "", function( mat ) iconMat = mat end )
	local iconSize = BRICKS_SERVER.Func.ScreenScale( 24 )
	local boxH, boxHMin = 0, 20
	Sheet.Button.Paint = function( self2, w, h )
		if( self2:IsHovered() or self2.m_bSelected ) then
			boxH = math.Clamp( boxH+3, boxHMin, h )
		else
			boxH = math.Clamp( boxH-3, boxHMin, h )
		end

		local textColor = Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 75 )

		if( self2.m_bSelected ) then
			textColor = BRICKS_SERVER.Func.GetTheme( 6 )
		end

		if( boxH > boxHMin ) then
			if( not color1 or not color2 ) then
				draw.RoundedBox( 8, 0, (h*0.5)-(boxH*0.5), w, boxH, self2:GetColor() )
			else
				BRICKS_SERVER.Func.DrawGradientRoundedBox( 8, 0, (h*0.5)-(boxH*0.5), w, boxH, 0, color1, color2 )
			end
		end

		if( iconMat ) then
			surface.SetDrawColor( textColor )
			surface.SetMaterial( iconMat )
			surface.DrawTexturedRect( 12, (h*0.5)-(iconSize*0.5), iconSize, iconSize )
		end

		draw.SimpleText( string.upper( label ), "BRICKS_SERVER_Font23", 12+iconSize+12, h*0.5-1, textColor, 0, TEXT_ALIGN_CENTER )

		if( Sheet.notifications and Sheet.notifications > 0 ) then
			local nX, nY, nW, nH = h+textX+5, (h*0.5)-(20*0.5), 20, 20
			draw.RoundedBox( 5, nX, nY, nW, nH, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red )
			draw.SimpleText( Sheet.notifications, "BRICKS_SERVER_Font20", nX+(nW*0.5), nY+(nH*0.5), BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
	end
	Sheet.Button.DoClick = function()
		self:SetActiveButton( Sheet.Button )
	end

	Sheet.Button.label = label

	Sheet.Panel = panel
	Sheet.Panel:SetParent( self.Content )
	Sheet.Panel:SetAlpha( 0 )
	Sheet.Panel:SetVisible( false )

	if( onLoad ) then
		Sheet.Button.loaded = false

		if( istable( onLoad ) ) then
			Sheet.Button.onLoad = onLoad[1]
			Sheet.Button.onEntered = onLoad[2]
		else
			Sheet.Button.onLoad = onLoad
		end
	end

	table.insert( self.Items, Sheet )

	if ( !IsValid( self.ActiveButton ) ) then
		self:SetActiveButton( Sheet.Button )
	end
	
	return Sheet
end

function PANEL:Think()
	for k, v in pairs( self.Items ) do
		if( v.Think ) then
			v.Think()
		end
	end
end

function PANEL:SetActiveButton( active )
	if ( self.ActiveButton == active ) then return end

	if( self.OnSheetChange ) then
		self.OnSheetChange( active )
	end
	
	if ( self.ActiveButton && self.ActiveButton.Target ) then
		local targetPanel = self.ActiveButton.Target
		targetPanel:SetVisible( false )
		targetPanel:SetAlpha( 0 )
		self.ActiveButton:SetSelected( false )
		self.ActiveButton:SetToggle( false )
		self.ActiveButton:ColorTo( BRICKS_SERVER.Func.GetTheme( 2 ), 0.2 )
	end

	self.ActiveButton = active
	active.Target:SetVisible( true )
	active.Target:AlphaTo( 255, 0.2, 0, function() end )
	active:SetSelected( true )
	active:SetToggle( true )
	active:ColorTo( BRICKS_SERVER.Func.GetTheme( 5 ), 0.2 )

	if( active.onLoad and not active.loaded ) then
		active.onLoad()
		active.loaded = true
	elseif( active.onLoad and active.onEntered ) then
		active.onEntered()
	end

	self.Content:InvalidateLayout()
end

function PANEL:SetActiveSheet( sheetLabel )
	if( not sheetLabel ) then return end

	for k, v in pairs( self.Items ) do
		if( v.Button and v.Button.label and v.Button.label == sheetLabel ) then
			self:SetActiveButton( v.Button )
			break
		end
	end
end

derma.DefineControl( "bricks_server_colsheet", "", PANEL, "Panel" )

--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_colsheet_left.lua:

local PANEL = {}

AccessorFunc( PANEL, "ActiveButton", "ActiveButton" )

function PANEL:Init()
	self.Navigation = vgui.Create( "bricks_server_scrollpanel", self )
	self.Navigation:Dock( LEFT )
	self.Navigation:SetWidth( 200 )
	self.Navigation.Paint = function( self2, w, h )
		if( not self.dontRoundBack ) then
			draw.RoundedBox( 5, 0, 0, w, h,  BRICKS_SERVER.Func.GetTheme( 2, 200 ) )
		else
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2, 200 ) )
			surface.DrawRect( 0, 0, w, h )
		end
	end

	self.Content = vgui.Create( "Panel", self )
	self.Content:Dock( FILL )

	self.Items = {}
	self.Categories = {}
end

function PANEL:CreateSearchBar()
	self.searchBack = vgui.Create( "DPanel", self.Navigation )
	self.searchBack:Dock( TOP )
	self.searchBack:SetTall( 30 )
	local search = Material( "materials/bricks_server/search_16.png" )
	local alpha = 0
	self.searchBack.Paint = function( self2, w, h )
		surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3, 100 ) )
		surface.DrawRect( 0, 0, w, h )

		if( self.searchBar:IsEditing() ) then
			alpha = math.Clamp( alpha+5, 0, 100 )
		else
			alpha = math.Clamp( alpha-5, 0, 100 )
		end
		
		surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3, alpha ) )
		surface.DrawRect( 0, 0, w, h )
	
		surface.SetDrawColor( 255, 255, 255, 20+((alpha/100)*255) )
		surface.SetMaterial( search )
		local size = 16
		surface.DrawTexturedRect( w-size-(h-size)*0.5, (h-size)*0.5, size, size )
	end

	self.searchBar = vgui.Create( "bricks_server_search", self.searchBack )
	self.searchBar:Dock( FILL )
	self.searchBar:SetFont( "BRICKS_SERVER_Font20" )
	self.searchBar.OnChange = function()
		self:RefreshSheetButtons()
	end
end

function PANEL:UseButtonOnlyStyle()
	self.ButtonOnly = true
end

function PANEL:AddSheet( label, panel, color, onLoad, categoryName, categoryColor )
	if ( !IsValid( panel ) ) then return end

	if( table.Count( self.Categories ) <= 0 ) then
		self.Categories["Default"] = vgui.Create( "bricks_server_navcategorycollapse", self.Navigation )
		self.Categories["Default"]:Dock( TOP )
		self.Categories["Default"]:SetLabel( "Default" )
		self.Categories["Default"]:SetBackColor( BRICKS_SERVER.Func.GetTheme( 5 ) )
	end

	categoryName = categoryName or "Default"
	categoryColor = categoryColor or BRICKS_SERVER.Func.GetTheme( 5 )

	if( not self.Categories[categoryName] ) then
		self.Categories[categoryName] = vgui.Create( "bricks_server_navcategorycollapse", self.Navigation )
		self.Categories[categoryName]:Dock( TOP )
		self.Categories[categoryName]:SetLabel( categoryName )
		self.Categories[categoryName]:SetBackColor( categoryColor )
	end

	self.Categories[categoryName].Count = (self.Categories[categoryName].Count or 0)+1

	local Sheet = {}
	Sheet.Button = vgui.Create( "DButton", self.Categories[categoryName] )
	Sheet.Button.Target = panel
	Sheet.Button:Dock( TOP )
	Sheet.Button:DockMargin( 5, ((self.Categories[categoryName].Count == 1 and 5) or 0), 5, 0 )
	Sheet.Button:SetText( "" )
	Sheet.Button:SetTall( 30 )
	local changeAlpha = 0
	Sheet.Button.Paint = function( self2, w, h )
		local backColor = (isfunction( color ) and color()) or color

		if( self2:IsDown() or self2.m_bSelected ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 50 )
		elseif( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 10 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 50 )
		end

		surface.SetAlphaMultiplier( changeAlpha/255 )
			draw.RoundedBox( 5, 0, 0, w, h, backColor or BRICKS_SERVER.Func.GetTheme( 4 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( label, "BRICKS_SERVER_Font20", 10, h*0.5, (backColor or BRICKS_SERVER.Func.GetTheme( 5 )), 0, TEXT_ALIGN_CENTER )
	end

	Sheet.Button.DoClick = function()
		if( not Sheet.Button.m_bSelected ) then
			changeAlpha = 0
		end

		self:SetActiveButton( Sheet.Button )

		if( self.OnSheetChange ) then
			self.OnSheetChange( label )
		end
	end

	Sheet.Button.label = label

	Sheet.Panel = panel
	Sheet.Panel:SetParent( self.Content )
	Sheet.Panel:SetVisible( false )

	if( onLoad ) then
		Sheet.Button.loaded = false
		Sheet.Button.onLoad = onLoad
	end

	if ( self.ButtonOnly ) then
		Sheet.Button:SizeToContents()
	end

	table.insert( self.Items, Sheet )

	if ( !IsValid( self.ActiveButton ) ) then
		self:SetActiveButton( Sheet.Button )
	end
	
	return Sheet
end

function PANEL:FinishAddingSheets()
	for k, v in pairs( BRICKS_SERVER.DLCMODULES ) do
		if( self.Categories[v.Name] ) then continue end
		
		self.Categories[v.Name] = vgui.Create( "bricks_server_navcategorycollapse", self.Navigation )
		self.Categories[v.Name]:Dock( TOP )
		self.Categories[v.Name]:SetLabel( v.Name )
		self.Categories[v.Name]:SetBackColor( v.Color )
		self.Categories[v.Name]:SetExpanded( false )

		local hasDLC = false
		for key, val in pairs( v.Modules ) do
			if( BRICKS_SERVER.Modules[val] ) then
				hasDLC = true
				break
			end
		end

		if( not hasDLC ) then
			self.Categories[v.Name].Header.DoClick = function()
				gui.OpenURL( v.Link )
			end
		end
	end

	if( self.OnNavCollapse ) then
		for k, v in pairs( self.Categories ) do
			v.OnNavCollapse = self.OnNavCollapse
		end
	end
end

function PANEL:RefreshSheetButtons()
	if( not IsValid( self.searchBar ) ) then return end

	for k, v in pairs( self.Items ) do
		if( self.searchBar:GetValue() != "" and not string.find( string.lower( v.Button.label ), string.lower( self.searchBar:GetValue() ) ) ) then
			v.Button:SetTall( 0 )
		else
			v.Button:SetTall( 30 )
		end
	end
end

function PANEL:Think()
	for k, v in pairs( self.Items ) do
		if( v.Think ) then
			v.Think()
		end
	end
end

function PANEL:SetActiveButton( active )
	if ( self.ActiveButton == active ) then return end

	if ( self.ActiveButton && self.ActiveButton.Target ) then
		local targetPanel = self.ActiveButton.Target
		targetPanel:SetVisible( false )
		self.ActiveButton:SetSelected( false )
		self.ActiveButton:SetToggle( false )
	end

	self.ActiveButton = active
	active.Target:SetVisible( true )
	active:SetSelected( true )
	active:SetToggle( true )

	if( active.onLoad and not active.loaded ) then
		active.onLoad()
		active.loaded = true
	end

	self.Content:InvalidateLayout()
end

function PANEL:SetActiveSheet( sheetLabel )
	if( not sheetLabel ) then return end

	for k, v in pairs( self.Items ) do
		if( v.Button and v.Button.label and v.Button.label == sheetLabel ) then
			self:SetActiveButton( v.Button )
			break
		end
	end
end

function PANEL:ClearSheets()
	self.Items = {}
	self.Navigation:Clear()
	self.Content:Clear()
end

derma.DefineControl( "bricks_server_colsheet_left", "", PANEL, "Panel" )

--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_config_groups.lua:
local PANEL = {}

function PANEL:Init()
    self.margin = 0
end

function PANEL:FillPanel()
    self.panelWide, self.panelTall = ScrW()*0.6-BRICKS_SERVER.DEVCONFIG.MainNavWidth, ScrH()*0.65-40

    self.topBar = vgui.Create( "DPanel", self )
    self.topBar:Dock( TOP )
    self.topBar:SetTall( 60 )
    self.topBar.Paint = function( self, w, h ) 
        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
        surface.DrawRect( 0, 0, w, h )
    end 

    surface.SetFont( "BRICKS_SERVER_Font20" )
    local textX, textY = surface.GetTextSize( "Create Group" )
    local totalContentW = 16+5+textX

    local createNewButton = vgui.Create( "DButton", self.topBar )
    createNewButton:Dock( RIGHT )
    createNewButton:DockMargin( 10, 10, 25, 10 )
    createNewButton:SetWide( totalContentW+27 )
    createNewButton:SetText( "" )
    local alpha = 0
    local addMat = Material( "bricks_server/add_16.png" )
    createNewButton.Paint = function( self2, w, h )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )

        if( not self2:IsDown() and self2:IsHovered() ) then
            alpha = math.Clamp( alpha+10, 0, 255 )
        else
            alpha = math.Clamp( alpha-10, 0, 255 )
        end

        surface.SetAlphaMultiplier( alpha/255 )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )
        surface.SetAlphaMultiplier( 1 )

        BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )

        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6, 20+(235*(alpha/255)) ) )
        surface.SetMaterial( addMat )
        local iconSize = 16
        surface.DrawTexturedRect( 12, (h*0.5)-(iconSize*0.5), iconSize, iconSize )

        draw.SimpleText( "Create Group", "BRICKS_SERVER_Font20", 12+iconSize+5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6, 20+(235*(alpha/255)) ), 0, TEXT_ALIGN_CENTER )
    end
    createNewButton.DoClick = function()
        BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newGroupName" ), BRICKS_SERVER.Func.L( "groupName" ), function( text ) 
            for key, val in pairs( (BS_ConfigCopyTable or BRICKS_SERVER.CONFIG).GENERAL.Groups ) do
                if( val[1] == text ) then
                    BRICKS_SERVER.Func.CreateTopNotification( BRICKS_SERVER.Func.L( "groupAlreadyExists" ), 3, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red )
                    return
                end
            end
            
            table.insert( BS_ConfigCopyTable.GENERAL.Groups, { text, {} } )
            self:Refresh()
            BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
        end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
    end

    self.searchBar = vgui.Create( "bricks_server_searchbar", self.topBar )
    self.searchBar:Dock( LEFT )
    self.searchBar:DockMargin( 25, 10, 10, 10 )
    self.searchBar:SetWide( ScrW()*0.2 )
    self.searchBar:SetBackColor( BRICKS_SERVER.Func.GetTheme( 1 ) )
    self.searchBar:SetHighlightColor( BRICKS_SERVER.Func.GetTheme( 0 ) )
    self.searchBar.OnChange = function()
        self:Refresh()
    end

    self.scrollPanel = vgui.Create( "bricks_server_scrollpanel_bar", self )
    self.scrollPanel:Dock( FILL )
    self.scrollPanel:DockMargin( 25, 25, 25, 25 )
    self.scrollPanel.Paint = function( self, w, h ) end 

    local slotsWide = 3
    self.spacing = 10
    local gridWide = self.panelWide-50-10-self.spacing
    self.slotWide, self.slotTall = (gridWide-((slotsWide-1)*self.spacing))/slotsWide, 60+10+40+10+60

    self.slotPanels = {}
    for i = 1, slotsWide do
        self.slotPanels[i] = vgui.Create( "DPanel", self.scrollPanel )
        self.slotPanels[i]:SetPos( ((i-1)*(self.slotWide+self.spacing)), 0 )
        self.slotPanels[i]:SetSize( self.slotWide, 0 )
        self.slotPanels[i].slotCount = 0
        self.slotPanels[i].Paint = function() end
    end

    self:Refresh()
end

function PANEL:Refresh()
    local removeMat = Material( "materials/bricks_server/delete.png" )
    local editMat = Material( "materials/bricks_server/edit.png" )
    local upMat = Material( "materials/bricks_server/up.png" )
    local downMat = Material( "materials/bricks_server/down.png" )

    for k, v in ipairs( self.slotPanels ) do
        v:Clear()
        v:SetTall( 0 )
        v.slotCount = 0
    end

    for k, v in ipairs( BS_ConfigCopyTable.GENERAL.Groups ) do
        if( self.searchBar:GetValue() != "" and not string.find( string.lower( v[1] ), string.lower( self.searchBar:GetValue() ) ) ) then
            continue
        end

        local slotParent = self.slotPanels[1]
        for key, val in ipairs( self.slotPanels ) do
            if( val.slotCount < slotParent.slotCount ) then
                slotParent = val
                break
            end
        end

        slotParent.slotCount = slotParent.slotCount+1
        slotParent.targetHeight = slotParent:GetTall()+self.slotTall+(slotParent.slotCount == 1 and 0 or self.spacing)
        slotParent:SetTall( slotParent.targetHeight )

        surface.SetFont( "BRICKS_SERVER_Font25" )
        local headerX, headerY = surface.GetTextSize( v[1] )

        local groupCount = table.Count( v[2] )
        surface.SetFont( "BRICKS_SERVER_Font17" )
        local groupX, groupY = surface.GetTextSize( groupCount .. " User Group" .. (groupCount != 1 and "s" or "") )

        local contentH = headerY+groupY-10

        local topH = 60
        local groupBack = vgui.Create( "DPanel", slotParent )
        groupBack:Dock( TOP )
        groupBack:DockMargin( 0, 0, 0, self.spacing )
        groupBack:DockPadding( 0, topH, 0, 0 )
        groupBack:SetTall( self.slotTall )
        groupBack.targetHeight = self.slotTall
        groupBack.Paint = function( self2, w, h )
            draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

            draw.RoundedBoxEx( 8, 0, 0, w, topH, BRICKS_SERVER.Func.GetTheme( 3 ), true, true, false, false )
            draw.RoundedBoxEx( 8, 0, 0, w, topH, BRICKS_SERVER.Func.GetTheme( 1, 75 ), true, true, false, false )

            draw.SimpleText( v[1] .. " - " .. k, "BRICKS_SERVER_Font25", w*0.5, (topH*0.5)-(contentH*0.5)-4, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
            draw.SimpleText( groupCount .. " User Group" .. (groupCount != 1 and "s" or ""), "BRICKS_SERVER_Font17", w*0.5, (topH*0.5)+(contentH*0.5), BRICKS_SERVER.Func.GetTheme( 6, 75 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
        end

        local actionBack = vgui.Create( "DPanel", groupBack )
        actionBack:Dock( TOP )
        actionBack:DockMargin( 10, 10, 10, 0 )
        actionBack:SetTall( 40 )
        actionBack:DockPadding( 0, 0, 10, 0 )
        actionBack.Paint = function( self2, w, h ) end
        actionBack.AddButton = function( self2, material, func )
            local button = vgui.Create( "DButton", self2 )
            button:Dock( LEFT )
            button:SetWide( self2:GetTall() )
            button:DockMargin( 0, 0, 5, 0 )
            button:SetText( "" )
            local alpha = 0
            local x, y = 0, 0
            button.Paint = function( self3, w, h )
                local toScreenX, toScreenY = self3:LocalToScreen( 0, 0 )
                if( x != toScreenX or y != toScreenY ) then
                    x, y = toScreenX, toScreenY
                end
        
                if( self3:IsHovered() ) then
                    alpha = math.Clamp( alpha+10, 0, 105 )
                else
                    alpha = math.Clamp( alpha-10, 0, 105 )
                end
        
                draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )
                draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3, 150+alpha ) )
        
                surface.SetMaterial( material )
                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6, 150+alpha ) )
                local iconSize = 24
                surface.DrawTexturedRect( (w*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
            end
            button.DoClick = function()
                func( x, y, button:GetWide(), button:GetWide() )
            end
        end

        actionBack:AddButton( removeMat, function( x, y, w, h )
            table.remove( BS_ConfigCopyTable.GENERAL.Groups, k )
            self:Refresh()
            BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
        end )
        actionBack:AddButton( editMat, function( x, y, w, h )
            actionBack.Menu = vgui.Create( "bricks_server_dmenu" )
            actionBack.Menu:AddOption( BRICKS_SERVER.Func.L( "editUserGroups" ), function()
                BRICKS_SERVER.Func.CreateGroupEditor( (v[2] or {}), function( userGroups ) 
                    BS_ConfigCopyTable.GENERAL.Groups[k][2] = userGroups or {}
                    self:Refresh()
                    BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
                end, function() end, true )
            end )
            actionBack.Menu:AddOption( BRICKS_SERVER.Func.L( "editColor" ), function()
                BRICKS_SERVER.Func.ColorRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newGroupColor" ), (v[3] or BRICKS_SERVER.Func.GetTheme( 5 )), function( color ) 
                    BS_ConfigCopyTable.GENERAL.Groups[k][3] = color or BRICKS_SERVER.Func.GetTheme( 5 )
                    self:Refresh()
                    BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
                end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
            end )
            actionBack.Menu:AddOption( BRICKS_SERVER.Func.L( "editName" ), function()
                BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newGroupName" ), (v[1] or "GroupName"), function( text ) 
                    for key, val in pairs( BS_ConfigCopyTable.GENERAL.Groups ) do
                        if( val[1] == text ) then
                            notification.AddLegacy( BRICKS_SERVER.Func.L( "groupAlreadyExists" ), 1, 5 )
                            return
                        end
                    end
                    
                    BS_ConfigCopyTable.GENERAL.Groups[k][1] = text
                    self:Refresh()
                    BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
                end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
            end )
            actionBack.Menu:Open()
            actionBack.Menu:SetPos( x+w+5, y+(h*0.5)-(actionBack.Menu:GetTall()*0.5) )
        end )
        actionBack:AddButton( downMat, function( x, y, w, h )
            if( k+1 <= #BS_ConfigCopyTable.GENERAL.Groups ) then
                if( BS_ConfigCopyTable.GENERAL.Groups[k+1] ) then
                    BS_ConfigCopyTable.GENERAL.Groups[k] = BS_ConfigCopyTable.GENERAL.Groups[k+1]
                end

                BS_ConfigCopyTable.GENERAL.Groups[k+1] = v
                self:Refresh()
                BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
            end
        end )
        actionBack:AddButton( upMat, function( x, y, w, h )
            if( k-1 >= 1 ) then
                if( BS_ConfigCopyTable.GENERAL.Groups[k-1] ) then
                    BS_ConfigCopyTable.GENERAL.Groups[k] = BS_ConfigCopyTable.GENERAL.Groups[k-1]
                end

                BS_ConfigCopyTable.GENERAL.Groups[k-1] = v
                self:Refresh()
                BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
            end
        end )

        local rarityBox = vgui.Create( "bricks_server_raritybox", groupBack )
        rarityBox:SetSize( self.slotWide, 10 )
        rarityBox:Dock( BOTTOM )
        rarityBox:SetRarityInfo( (istable( v[3] ) and v[3][1] == "") and v[3] or { "", "SolidColor", (v[3] or BRICKS_SERVER.Func.GetTheme( 5 )) } )
        rarityBox:SetCornerRadius( 8 )
        rarityBox:SetRoundedBoxDimensions( false, -10, false, 20 )

        local userGroupsBack = vgui.Create( "DPanel", groupBack )
        userGroupsBack:Dock( TOP )
        userGroupsBack:DockMargin( 10, 10, 10, 10 )
        userGroupsBack:SetTall( 40 )
        userGroupsBack.Paint = function( self2, w, h ) 
            draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )
        end

        userGroupsBack.expandButton = vgui.Create( "DButton", userGroupsBack )
        userGroupsBack.expandButton:Dock( TOP )
        userGroupsBack.expandButton:SetTall( userGroupsBack:GetTall() )
        userGroupsBack.expandButton:SetText( "" )
        local alpha = 0
        local arrow = Material( "bricks_server/down_16.png" )
        userGroupsBack.expandButton.textureRotation = -90
        userGroupsBack.expandButton.Paint = function( self2, w, h )
            local expanded = userGroupsBack:GetTall() > 40

            if( expanded ) then
                alpha = math.Clamp( alpha+5, 0, 75 )
            elseif( not self2:IsDown() and self2:IsHovered() ) then
                alpha = math.Clamp( alpha+5, 0, 100 )
            else
                alpha = math.Clamp( alpha-5, 0, 100 )
            end

            draw.RoundedBoxEx( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3, 150 ), true, true, not expanded, not expanded )

            surface.SetAlphaMultiplier( alpha/255 )
            draw.RoundedBoxEx( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ), true, true, not expanded, not expanded )
            surface.SetAlphaMultiplier( 1 )

            draw.SimpleText( "Edit User Groups", "BRICKS_SERVER_Font20", w*0.5, h*0.5-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

            surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
            surface.SetMaterial( arrow )
            local iconSize = 16
            surface.DrawTexturedRectRotated( w-((h-iconSize)*0.5)-(iconSize*0.5), h*0.5, iconSize, iconSize, math.Clamp( (self2.textureRotation or 0), -90, 0 ) )
        end
        userGroupsBack.expandButton.DoAnim = function( expanding )
            local anim = userGroupsBack.expandButton:NewAnimation( 0.2, 0, -1 )
        
            anim.Think = function( anim, pnl, fraction )
                if( expanding ) then
                    userGroupsBack.expandButton.textureRotation = (1-fraction)*-90
                else
                    userGroupsBack.expandButton.textureRotation = fraction*-90
                end
            end
        end
        userGroupsBack.expandButton.DoClick = function()
            userGroupsBack.Expanded = not userGroupsBack.Expanded

            if( userGroupsBack.Expanded ) then
                groupBack.targetHeight = groupBack.targetHeight+userGroupsBack.expandedExtraH
                slotParent.targetHeight = slotParent.targetHeight+userGroupsBack.expandedExtraH
                userGroupsBack:SizeTo( self.slotWide-20, 40+userGroupsBack.expandedExtraH, 0.2 )
                userGroupsBack.expandButton.DoAnim( true )
            else
                groupBack.targetHeight = groupBack.targetHeight-userGroupsBack.expandedExtraH
                slotParent.targetHeight = slotParent.targetHeight-userGroupsBack.expandedExtraH
                userGroupsBack:SizeTo( self.slotWide-20, 40, 0.2 )
                userGroupsBack.expandButton.DoAnim( false )
            end

            groupBack:SizeTo( self.slotWide, groupBack.targetHeight, 0.2 )
            slotParent:SizeTo( self.slotWide, slotParent.targetHeight, 0.2 )
        end

        userGroupsBack.searchBar = vgui.Create( "DPanel", userGroupsBack )
        userGroupsBack.searchBar:Dock( TOP )
        userGroupsBack.searchBar:SetTall( 30 )
        local search = Material( "materials/bricks_server/search_16.png" )
        local alpha = 0
        userGroupsBack.searchBar.Paint = function( self2, w, h )
            surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3, 100 ) )
            surface.DrawRect( 0, 0, w, h )
    
            if( self2.entry:IsEditing() ) then
                alpha = math.Clamp( alpha+5, 0, 100 )
            else
                alpha = math.Clamp( alpha-5, 0, 100 )
            end
            
            surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2, alpha ) )
            surface.DrawRect( 0, 0, w, h )
        
            surface.SetDrawColor( 255, 255, 255, 20+((alpha/100)*255) )
            surface.SetMaterial( search )
            local size = 16
            surface.DrawTexturedRect( w-size-(h-size)*0.5, (h-size)*0.5, size, size )
        end
    
        userGroupsBack.searchBar.entry = vgui.Create( "bricks_server_search", userGroupsBack.searchBar )
        userGroupsBack.searchBar.entry:Dock( FILL )
        userGroupsBack.searchBar.entry:SetFont( "BRICKS_SERVER_Font20" )
        userGroupsBack.searchBar.entry.OnChange = function()
            userGroupsBack.list.RefreshEntries()
        end

        local userGroupTall, userGroupSpacing = 25, 10
        userGroupsBack.list = vgui.Create( "DPanel", userGroupsBack )
        userGroupsBack.list:Dock( TOP )
        userGroupsBack.list:SetTall( 0 )
        userGroupsBack.list:DockMargin( 0, userGroupSpacing, 0, userGroupSpacing )
        userGroupsBack.list.Paint = function( self2, w, h ) end
        userGroupsBack.list.RefreshEntries = function()
            userGroupsBack.list:Clear()
            userGroupsBack.list:SetTall( 0 )

            local possibleUserGroups = BRICKS_SERVER.Func.GetAdminSystemRanks()
            for key, val in pairs( v[2] ) do
                if( not possibleUserGroups[key] ) then
                    BS_ConfigCopyTable.GENERAL.Groups[k][2][key] = nil
                end
            end

            for key, val in pairs( possibleUserGroups ) do
                if( userGroupsBack.searchBar.entry:GetValue() != "" and not string.find( string.lower( val ), string.lower( userGroupsBack.searchBar.entry:GetValue() ) ) ) then
                    continue
                end

                local userGroupEntry = vgui.Create( "DPanel", userGroupsBack.list )
                userGroupEntry:Dock( TOP )
                userGroupEntry:DockMargin( 20, 0, 20, userGroupSpacing )
                userGroupEntry:SetTall( userGroupTall )
                userGroupEntry.Paint = function( self2, w, h )
                    draw.SimpleText( val, "BRICKS_SERVER_Font20", 0, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
                end

                local userGroupButton = vgui.Create( "bricks_server_dcheckbox", userGroupEntry )
                userGroupButton:Dock( RIGHT )
                userGroupButton:SetValue( v[2][key] )
                userGroupButton:SetTitle( "" )
                userGroupButton.backgroundCol = BRICKS_SERVER.Func.GetTheme( 2 )
                userGroupButton.OnChange = function( value )
                    if( value == true ) then
                        BS_ConfigCopyTable.GENERAL.Groups[k][2][key] = true
                    else
                        BS_ConfigCopyTable.GENERAL.Groups[k][2][key] = nil
                    end
                    BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
                end

                userGroupsBack.list:SetTall( userGroupsBack.list:GetTall()+userGroupEntry:GetTall()+(userGroupsBack.list:GetTall() > 0 and userGroupSpacing or 0) )
            end

            if( userGroupsBack.Expanded ) then
                groupBack.targetHeight = groupBack.targetHeight-userGroupsBack.expandedExtraH
                slotParent.targetHeight = slotParent.targetHeight-userGroupsBack.expandedExtraH
    
                userGroupsBack.expandedExtraH = (userGroupSpacing*2)+userGroupsBack.list:GetTall()+userGroupsBack.searchBar:GetTall()

                groupBack.targetHeight = groupBack.targetHeight+userGroupsBack.expandedExtraH
                slotParent.targetHeight = slotParent.targetHeight+userGroupsBack.expandedExtraH
                
                userGroupsBack:SizeTo( self.slotWide-20, 40+userGroupsBack.expandedExtraH, 0.1 )
                groupBack:SizeTo( self.slotWide, groupBack.targetHeight, 0.1 )
                slotParent:SizeTo( self.slotWide, slotParent.targetHeight, 0.1 )
            else
                userGroupsBack.expandedExtraH = (userGroupSpacing*2)+userGroupsBack.list:GetTall()+userGroupsBack.searchBar:GetTall()
            end
        end
        userGroupsBack.list.RefreshEntries()
    end
end

function PANEL:Paint( w, h )
    
end

vgui.Register( "bricks_server_config_groups", PANEL, "DPanel" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_textentry.lua:

local PANEL = {}

local strAllowedNumericCharacters = "1234567890.-"

AccessorFunc( PANEL, "m_bAllowEnter", "EnterAllowed", FORCE_BOOL )
AccessorFunc( PANEL, "m_bUpdateOnType", "UpdateOnType", FORCE_BOOL ) -- Update the convar as we type
AccessorFunc( PANEL, "m_bNumeric", "Numeric", FORCE_BOOL )
AccessorFunc( PANEL, "m_bHistory", "HistoryEnabled", FORCE_BOOL )
AccessorFunc( PANEL, "m_bDisableTabbing", "TabbingDisabled", FORCE_BOOL )

AccessorFunc( PANEL, "m_FontName", "Font" )
AccessorFunc( PANEL, "m_bBorder", "DrawBorder" )
AccessorFunc( PANEL, "m_bBackground", "PaintBackground" )
AccessorFunc( PANEL, "m_bBackground", "DrawBackground" ) -- Deprecated

AccessorFunc( PANEL, "m_colText", "TextColor" )
AccessorFunc( PANEL, "m_hintText", "HintText" )
AccessorFunc( PANEL, "m_colHighlight", "HighlightColor" )
AccessorFunc( PANEL, "m_colCursor", "CursorColor" )

AccessorFunc( PANEL, "m_colPlaceholder", "PlaceholderColor" )
AccessorFunc( PANEL, "m_txtPlaceholder", "PlaceholderText" )

Derma_Install_Convar_Functions( PANEL )

function PANEL:Init()

	self:SetHistoryEnabled( false )
	self.History = {}
	self.HistoryPos = 50

	--
	-- We're going to draw these ourselves in
	-- the skin system - so disable them here.
	-- This will leave it only drawing text.
	--
	self:SetPaintBorderEnabled( false )
	self:SetPaintBackgroundEnabled( false )

	--
	-- These are Lua side commands
	-- Defined above using AccessorFunc
	--
	self:SetDrawBorder( true )
	self:SetPaintBackground( true )
	self:SetEnterAllowed( true )
	self:SetUpdateOnType( false )
	self:SetNumeric( false )
	self:SetAllowNonAsciiCharacters( true )

	-- Nicer default height
	self:SetTall( 20 )

	-- Clear keyboard focus when we click away
	self.m_bLoseFocusOnClickAway = true

	-- Beam Me Up Scotty
	self:SetCursor( "beam" )

	self:SetFont( "BRICKS_SERVER_Font23" )
	self:SetText( "" )
	self:SetTextColor( Color( 255, 255, 255, 20 ) )
	self:SetCursorColor( Color( 255, 255, 255 ) )
	self:DockMargin( 10, 0, 0, 0 )
end

function PANEL:IsEditing()
	return self == vgui.GetKeyboardFocus()
end

function PANEL:OnKeyCodeTyped( code )

	self:OnKeyCode( code )

	if ( code == KEY_ENTER && !self:IsMultiline() && self:GetEnterAllowed() ) then

		if ( IsValid( self.Menu ) ) then
			self.Menu:Remove()
		end

		self:FocusNext()
		self:OnEnter()
		self.HistoryPos = 0

	end

	if ( self.m_bHistory || IsValid( self.Menu ) ) then

		if ( code == KEY_UP ) then
			self.HistoryPos = self.HistoryPos - 1
			self:UpdateFromHistory()
		end

		if ( code == KEY_DOWN || code == KEY_TAB ) then
			self.HistoryPos = self.HistoryPos + 1
			self:UpdateFromHistory()
		end

	end

end

function PANEL:OnKeyCode( code )
end

function PANEL:ApplySchemeSettings()

	self:SetFontInternal( self.m_FontName )

	derma.SkinHook( "Scheme", "TextEntry", self )

end

function PANEL:GetTextColor()

	return self.m_colText || self:GetSkin().colTextEntryText

end

function PANEL:GetHintText()

	return self.m_hintText

end

function PANEL:GetPlaceholderColor()

	return self.m_colPlaceholder || self:GetSkin().colTextEntryTextPlaceholder

end

function PANEL:GetHighlightColor()

	return self.m_colHighlight || self:GetSkin().colTextEntryTextHighlight

end

function PANEL:GetCursorColor()

	return self.m_colCursor || self:GetSkin().colTextEntryTextCursor

end

function PANEL:UpdateFromHistory()

	if ( IsValid( self.Menu ) ) then
		return self:UpdateFromMenu()
	end

	local pos = self.HistoryPos
	-- Is the Pos within bounds?
	if ( pos < 0 ) then pos = #self.History end
	if ( pos > #self.History ) then pos = 0 end

	local text = self.History[ pos ]
	if ( !text ) then text = "" end

	self:SetText( text )
	self:SetCaretPos( text:len() )

	self:OnTextChanged()

	self.HistoryPos = pos

end

function PANEL:UpdateFromMenu()

	local pos = self.HistoryPos
	local num = self.Menu:ChildCount()

	self.Menu:ClearHighlights()

	if ( pos < 0 ) then pos = num end
	if ( pos > num ) then pos = 0 end

	local item = self.Menu:GetChild( pos )
	if ( !item ) then
		self:SetText( "" )
		self.HistoryPos = pos
		return
	end

	self.Menu:HighlightItem( item )

	local txt = item:GetText()

	self:SetText( txt )
	self:SetCaretPos( txt:len() )

	self:OnTextChanged( true )

	self.HistoryPos = pos

end

function PANEL:OnTextChanged( noMenuRemoval )

	self.HistoryPos = 0

	if ( self:GetUpdateOnType() ) then
		self:UpdateConvarValue()
		self:OnValueChange( self:GetText() )
	end

	if ( IsValid( self.Menu ) && !noMenuRemoval ) then
		self.Menu:Remove()
	end

	local tab = self:GetAutoComplete( self:GetText() )
	if ( tab ) then
		self:OpenAutoComplete( tab )
	end

	self:OnChange()

end

function PANEL:OnChange()
end

function PANEL:OpenAutoComplete( tab )

	if ( !tab ) then return end
	if ( #tab == 0 ) then return end

	self.Menu = DermaMenu()

	for k, v in pairs( tab ) do

		self.Menu:AddOption( v, function() self:SetText( v ) self:SetCaretPos( v:len() ) self:RequestFocus() end )

	end

	local x, y = self:LocalToScreen( 0, self:GetTall() )
	self.Menu:SetMinimumWidth( self:GetWide() )
	self.Menu:Open( x, y, true, self )
	self.Menu:SetPos( x, y )
	self.Menu:SetMaxHeight( ( ScrH() - y ) - 10 )

end

local Alpha = 20
function PANEL:Think()

	self:ConVarStringThink()

	if( self:IsEditing() and Alpha != 255 ) then
		Alpha = math.Clamp( Alpha+20, 20, 255 )
	elseif( not self:IsEditing() and Alpha != 20 ) then
		Alpha = math.Clamp( Alpha-20, 20, 255 )
	end

	if( self:GetTextColor() != Color( 255, 255, 255, 255 ) or self:GetTextColor() != Color( 255, 255, 255, 20 ) ) then
		self:SetTextColor( Color( 255, 255, 255, Alpha ) )
	end
end

function PANEL:OnEnter()

	-- For override
	self:UpdateConvarValue()
	self:OnValueChange( self:GetText() )

end

function PANEL:UpdateConvarValue()

	-- This only kicks into action if this variable has
	-- a ConVar associated with it.
	self:ConVarChanged( self:GetValue() )

end

function PANEL:Paint( w, h )
	if( self.backColor ) then
		if( self:IsEditing() ) then
			draw.RoundedBox( 5, 0, 0, w, h, self.backColor )
		else
			surface.SetAlphaMultiplier( 0.75 )
			draw.RoundedBox( 5, 0, 0, w, h, self.backColor )
			surface.SetAlphaMultiplier( 1 )
		end
	end

	local panel = self

	if ( panel.GetPlaceholderText && panel.GetPlaceholderColor && panel:GetPlaceholderText() && panel:GetPlaceholderText():Trim() != "" && panel:GetPlaceholderColor() && ( !panel:GetText() || panel:GetText() == "" ) ) then

		local oldText = panel:GetText()

		local str = panel:GetPlaceholderText()
		if ( str:StartWith( "#" ) ) then str = str:sub( 2 ) end
		str = language.GetPhrase( str )

		panel:SetText( str )
		panel:DrawTextEntryText( panel:GetPlaceholderColor(), panel:GetHighlightColor(), panel:GetCursorColor() )
		panel:SetText( oldText )

		return
	end

	panel:DrawTextEntryText( panel:GetTextColor(), panel:GetHighlightColor(), panel:GetCursorColor() )
end

function PANEL:PerformLayout()

	derma.SkinHook( "Layout", "TextEntry", self )

end

function PANEL:SetValue( strValue )

	-- Don't update if we're typing into it!
	-- I'm sure a lot of people will want to reverse this behaviour :(
	if ( vgui.GetKeyboardFocus() == self ) then return end

	local CaretPos = self:GetCaretPos()

	self:SetText( strValue )
	self:OnValueChange( strValue )

	self:SetCaretPos( CaretPos )

end

function PANEL:OnValueChange( strValue )
	-- For Override
end

function PANEL:CheckNumeric( strValue )

	-- Not purely numeric, don't run the check
	if ( !self:GetNumeric() ) then return false end

	-- God I hope numbers look the same in every language
	if ( !string.find( strAllowedNumericCharacters, strValue, 1, true ) ) then

		-- Noisy Error?
		return true

	end

	return false

end

function PANEL:SetDisabled( bDisabled )
	self:SetEnabled( !bDisabled )
end

function PANEL:GetDisabled( bDisabled )
	return !self:IsEnabled()
end

function PANEL:AllowInput( strValue )

	-- This is layed out like this so you can easily override and
	-- either keep or remove this numeric check.
	if ( self:CheckNumeric( strValue ) ) then return true end

end

function PANEL:SetEditable( b )

	self:SetKeyboardInputEnabled( b )
	self:SetMouseInputEnabled( b )

end

function PANEL:OnGetFocus()

	--
	-- These hooks are here for the sake of things like the spawn menu
	-- which don't have key focus until you click on one of the text areas.
	--
	-- If you make a control for the spawnmenu that requires keyboard input
	-- You should have these 3 functions in your panel, so it can handle it.
	--

	hook.Run( "OnTextEntryGetFocus", self )

end

function PANEL:OnLoseFocus()

	self:UpdateConvarValue()

	hook.Call( "OnTextEntryLoseFocus", nil, self )

end

function PANEL:OnMousePressed( mcode )

	self:OnGetFocus()

end

function PANEL:AddHistory( txt )

	if ( !txt || txt == "" ) then return end

	table.RemoveByValue( self.History, txt )
	table.insert( self.History, txt )

end

function PANEL:GetAutoComplete( txt )
	-- for override. Return a table of strings.
end

function PANEL:GetInt()

	return math.floor( tonumber( self:GetText() ) + 0.5 )

end

function PANEL:GetFloat()

	return tonumber( self:GetText() )

end

derma.DefineControl( "bricks_server_textentry", "A simple TextEntry control", PANEL, "TextEntry" )

--[[---------------------------------------------------------
	Clear the focus when we click away from us..
-----------------------------------------------------------]]
hook.Add( "VGUIMousePressed", "BRS_TextEntryLoseFocus", function( panel, mcode )
	hook.Remove( "VGUIMousePressed", "TextEntryLoseFocus" )

	local pnl = vgui.GetKeyboardFocus()
	if ( !pnl ) then return end
	if ( pnl == panel ) then return end
	if ( panel:GetName() == "bricks_server_dmenuoption" ) then return end
	if ( !pnl.m_bLoseFocusOnClickAway ) then return end

	pnl:FocusNext()
end )

--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/vgui/bricks_server_config_gang.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel( configPanel )
    BRICKS_SERVER.Func.FillVariableConfigs( self, "GANGS", "GANGS" )
end

function PANEL:Paint( w, h )
    
end

vgui.Register( "bricks_server_config_gangs", PANEL, "bricks_server_scrollpanel" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/vgui/bricks_server_gangmenu_roles.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:CreatePopup( text )
    if( IsValid( self.popup ) ) then return end

    local margin = 25

    self.popup = vgui.Create( "DPanel", self )
    self.popup:SetSize( self.panelWide-(2*margin), 50 )
    self.popup:SetPos( margin, ScrH()*0.65-40 )
    self.popup:MoveTo( margin, ScrH()*0.65-40-margin-self.popup:GetTall(), 0.2 )
    local yBound = (ScrH()*0.5)-(ScrH()*0.65*0.5)
    self.popup.Paint = function( self2, w, h )
        local x, y = self2:LocalToScreen( 0, 0 )

        BRICKS_SERVER.BSHADOWS.BeginShadow( 0, yBound, ScrW(), yBound+(ScrH()*0.65) )
        draw.RoundedBox( 5, x, y, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )			
        BRICKS_SERVER.BSHADOWS.EndShadow( 1, 2, 2, 255, 0, 0, false )
    
        draw.SimpleText( text, "BRICKS_SERVER_Font23", 15, h*0.5-2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
    end

    return self.popup
end

function PANEL:SettingChanged()
    if( not self.roleChanged ) then
        self.roleChanged = true
        local popup = self:CreatePopup( BRICKS_SERVER.Func.L( "gangUnsavedChanges" ) )

        if( IsValid( popup ) ) then
            surface.SetFont( "BRICKS_SERVER_Font23" )
            local textX, textY = surface.GetTextSize( BRICKS_SERVER.Func.L( "gangSaveChanges" ) )

            local margin = 8

            local saveChanges = vgui.Create( "DButton", popup )
            saveChanges:Dock( RIGHT )
            saveChanges:DockMargin( 0, margin, margin, margin )
            saveChanges:SetWide( textX+10 )
            saveChanges:SetText( "" )
            local alpha = 0
            saveChanges.Paint = function( self2, w, h )
                if( self2:IsDown() ) then
                    alpha = 0
                elseif( self2:IsHovered() ) then
                    alpha = math.Clamp( alpha+10, 0, 255 )
                else
                    alpha = math.Clamp( alpha-10, 0, 255 )
                end

                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.Green )

                surface.SetAlphaMultiplier( alpha/255 )
                    draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen )		
                surface.SetAlphaMultiplier( 1 )
            
                draw.SimpleText( BRICKS_SERVER.Func.L( "gangSaveChanges" ), "BRICKS_SERVER_Font20", w*0.5, h*0.5-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            end
            saveChanges.DoClick = function()
                local rolesData = util.Compress( util.TableToJSON( self.rolesTableCopy ) )
                net.Start( "BRS.Net.SaveGangRoles" )
                    net.WriteData( rolesData, string.len( rolesData ) )
                net.SendToServer()
            end

            surface.SetFont( "BRICKS_SERVER_Font23" )
            local text2X, text2Y = surface.GetTextSize( BRICKS_SERVER.Func.L( "gangReset" ) )

            local resetChanges = vgui.Create( "DButton", popup )
            resetChanges:Dock( RIGHT )
            resetChanges:DockMargin( margin, 10, margin, margin )
            resetChanges:SetWide( text2X+10 )
            resetChanges:SetText( "" )
            local alpha = 0
            local whiteColor = BRICKS_SERVER.Func.GetTheme( 6 )
            resetChanges.Paint = function( self2, w, h )
                if( self2:IsDown() ) then
                    alpha = 0
                elseif( self2:IsHovered() ) then
                    alpha = math.Clamp( alpha+10, 0, 255 )
                else
                    alpha = math.Clamp( alpha-10, 0, 255 )
                end

                surface.SetAlphaMultiplier( alpha/255 )
                    draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )		
                surface.SetAlphaMultiplier( 1 )
            
                draw.SimpleText( BRICKS_SERVER.Func.L( "gangReset" ), "BRICKS_SERVER_Font20", w*0.5, h*0.5-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            end
            resetChanges.DoClick = function()
                popup:MoveTo( 25, ScrH()*0.65-40, 0.2, 0, -1, function()
                    if( IsValid( popup ) ) then
                        popup:Remove()
                    end
                end )

                self.roleChanged = false
                self.rolesTableCopy = table.Copy( ((BRICKS_SERVER_GANGS or {})[LocalPlayer():GetGangID()] or {}).Roles or {} )

                self.RefreshPanel()
            end
        end
    end
end

function PANEL:FillPanel()
    self:Clear()

    self.sheet = vgui.Create( "bricks_server_colsheet_ranks", self )
    self.sheet:Dock( FILL )
    self.sheet:DockMargin( 10, 10, 10, 10 )

    self.roleChanged = false
    self.rolesTableCopy = table.Copy( ((BRICKS_SERVER_GANGS or {})[LocalPlayer():GetGangID()] or {}).Roles or {} )

    function self.RefreshPanel()
        if( IsValid( self.sheet.ActiveButton ) ) then
            self.previousSheet = self.sheet.ActiveButton.label
        end

        self.sheet:ClearSheets()

        local addNewRole = vgui.Create( "DPanel", self.sheet.Navigation )
        addNewRole:Dock( TOP )
        addNewRole:DockMargin( 0, 0, 0, 0 )
        addNewRole:SetTall( 35 )
        addNewRole.Paint = function( self2, w, h )
            draw.SimpleText( BRICKS_SERVER.Func.L( "gangRanksUpper" ), "BRICKS_SERVER_Font17", 10, h*0.5, BRICKS_SERVER.Func.GetTheme( 5 ), 0, TEXT_ALIGN_CENTER )
        end

        local addNewRoleButton = vgui.Create( "DButton", addNewRole )
        addNewRoleButton:Dock( RIGHT )
        addNewRoleButton:DockMargin( 0, 0, 0, 0 )
        addNewRoleButton:SetWide( addNewRole:GetTall() )
        addNewRoleButton:SetText( "" )
        local addMat = Material( "bricks_server/add_circle.png" )
        addNewRoleButton.Paint = function( self2, w, h )
            if( self2:IsHovered() ) then
                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 4 ) )
            else
                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 5 ) )
            end
			surface.SetMaterial( addMat )
			local iconSize = 16
			surface.DrawTexturedRect( (w*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
        end
        addNewRoleButton.DoClick = function()
            if( table.Count( self.rolesTableCopy ) >= BRICKS_SERVER.DEVCONFIG.GangRankLimit ) then
                notification.AddLegacy( BRICKS_SERVER.Func.L( "gangRankLimit", BRICKS_SERVER.DEVCONFIG.GangRankLimit ), 1, 5 )
                return
            end

            if( not self.roleChanged ) then
                self:SettingChanged()
            end

            table.insert( self.rolesTableCopy, { BRICKS_SERVER.Func.L( "gangNewRank" ), Color( 189, 195, 199 ), {} } )

            self.RefreshPanel()
        end

        local draggingButton, dragTarget

        local dropSections, buttons = {}, {}
        local function addDropSection( topMargin, belowRank )
            local dropSection = vgui.Create( "DPanel", self.sheet.Navigation )
            dropSection:Dock( TOP )
            dropSection:DockMargin( 5, (topMargin or 0), 5, 0 )
            dropSection:SetTall( 0 )
            dropSection.belowRank = belowRank
            dropSection.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )
            end
            dropSection.Think = function( self2 )
                if( self2:GetTall() != 0 ) then
                    if( not IsValid( draggingButton ) or dragTarget != self2 ) then
                        self2:SetTall( 0 )
                    else
                        local aboveButton, belowButton = buttons[belowRank], buttons[belowRank+1]

                        local aboveHovered = false
                        if( IsValid( aboveButton ) and aboveButton:IsHovered() ) then
                            aboveHovered = true
                        end

                        local belowHovered = false
                        if( IsValid( belowButton ) and belowButton:IsHovered() ) then
                            belowHovered = true
                        end

                        if( not self2:IsHovered() and not aboveHovered and not belowHovered ) then
                            self2:SetTall( 0 )
                        end
                    end
                end
            end

            table.insert( dropSections, belowRank, dropSection )
        end

        addDropSection( 5, 0 )

        for k, v in ipairs( self.rolesTableCopy ) do
            local rolePanel = vgui.Create( "bricks_server_scrollpanel", self.sheet )
            rolePanel:Dock( FILL )
            rolePanel:DockMargin( 5, 0, 0, 0 )
            rolePanel.Paint = function( self2, w, h ) end
            rolePanel.AddHeader = function( text )
                local roleHeader = vgui.Create( "DPanel", rolePanel )
                roleHeader:Dock( TOP )
                roleHeader:DockMargin( 0, 0, 0, 5 )
                roleHeader:DockPadding( 10, 25, 10, 0 )
                roleHeader:SetTall( 25 )
                roleHeader.Paint = function( self2, w, h )
                    draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

                    draw.SimpleText( string.upper( text ), "BRICKS_SERVER_Font17", 10, 5, BRICKS_SERVER.Func.GetTheme( 5 ), 0, 0 )
                end

                return roleHeader
            end

            local roleNameBack = rolePanel.AddHeader( BRICKS_SERVER.Func.L( "gangRankName" ) )

            local roleName = vgui.Create( "bricks_server_textentry", roleNameBack )
            roleName:Dock( TOP )
            roleName:DockMargin( 0, 0, 0, 0 )
            roleName:SetTall( 40 )
            roleName:SetValue( v[1] )
            roleName.backColor = BRICKS_SERVER.Func.GetTheme( 2 )
            roleName.OnChange = function()
                if( not self.roleChanged ) then
                    self:SettingChanged()
                end

                self.rolesTableCopy[k][1] = roleName:GetValue()
            end

            roleNameBack:SetTall( roleNameBack:GetTall()+50 )

            local roleColorBack = rolePanel.AddHeader( BRICKS_SERVER.Func.L( "gangRankColor" ) )

            local roleColor = vgui.Create( "DColorMixer", roleColorBack )
            roleColor:Dock( TOP )
            roleColor:DockMargin( 0, 0, 0, 0 )
            roleColor:SetTall( 100 )
            roleColor:SetPalette( false )
            roleColor:SetAlphaBar( false) 
            roleColor:SetWangs( true )
            roleColor:SetColor( v[2] )
            roleColor.ValueChanged = function()
                if( not self.roleChanged ) then
                    self:SettingChanged()
                end

                self.rolesTableCopy[k][2] = roleColor:GetColor()
            end

            roleColorBack:SetTall( roleColorBack:GetTall()+110 )

            local permissions = {}
            for key, val in pairs( BRICKS_SERVER.DEVCONFIG.GangPermissions ) do
                if( not permissions[val[2]] ) then
                    permissions[val[2]] = {}
                end

                permissions[val[2]][key] = val
            end


            for key, val in pairs( permissions ) do
                local rolePermHeaderBack = rolePanel.AddHeader( key .. " Permissions" )
                rolePermHeaderBack:SetTall( rolePermHeaderBack:GetTall()+5 )

                for key2, val2 in pairs( val ) do
                    local rolePermBack = vgui.Create( "DPanel", rolePermHeaderBack )
                    rolePermBack:Dock( TOP )
                    rolePermBack:DockMargin( 0, 0, 0, 5 )
                    rolePermBack:SetTall( 25 )
                    rolePermBack.Paint = function( self2, w, h )
                        draw.SimpleText( val2[1], "BRICKS_SERVER_Font20", 0, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
                    end

                    local rolePermToggle = vgui.Create( "bricks_server_dcheckbox", rolePermBack )
                    rolePermToggle:Dock( RIGHT )
                    rolePermToggle:DockMargin( 0, (rolePermBack:GetTall()-20)*0.5, 0, (rolePermBack:GetTall()-20)*0.5 )
                    rolePermToggle:SetWide( 50 )
                    rolePermToggle:SetValue( v[3][key2] or false )
                    rolePermToggle:SetTitle( "" )
                    rolePermToggle.backgroundCol = BRICKS_SERVER.Func.GetTheme( 2 )
                    rolePermToggle.OnChange = function( value )
                        if( not self.roleChanged ) then
                            self:SettingChanged()
                        end
        
                        self.rolesTableCopy[k][3][key2] = value
                    end

                    rolePermHeaderBack:SetTall( rolePermHeaderBack:GetTall()+30 )
                end
            end

            local actionsBack = vgui.Create( "DPanel", rolePanel )
            actionsBack:Dock( TOP )
            actionsBack:DockMargin( 0, 0, 0, 5 )
            actionsBack:SetTall( 35 )
            actionsBack.Paint = function( self2, w, h ) end

            local actions = {
                [1] = {
                    Name = BRICKS_SERVER.Func.L( "gangClearPerms" ),
                    Color = Color( 127, 140, 141 ),
                    Func = function()
                        if( not self.roleChanged ) then
                            self:SettingChanged()
                        end
        
                        self.rolesTableCopy[k][3] = {}

                        self.RefreshPanel()
                    end
                },
                [2] = {
                    Name = BRICKS_SERVER.Func.L( "gangDeleteRank" ),
                    Color = Color( 231, 76, 60 ),
                    Func = function()
                        BRICKS_SERVER.Func.Query( BRICKS_SERVER.Func.L( "gangDeleteRankQuery" ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ), BRICKS_SERVER.Func.L( "cancel" ), function() 
                            if( table.Count( self.rolesTableCopy ) <= 1 ) then
                                notification.AddLegacy( BRICKS_SERVER.Func.L( "gangRankLowLimit" ), 1, 5 )
                                return
                            end

                            if( not self.roleChanged ) then
                                self:SettingChanged()
                            end
                
                            table.remove( self.rolesTableCopy, k )
                
                            self.RefreshPanel()
                        end )
                    end
                }
            }

            for k, v in ipairs( actions ) do
                surface.SetFont( "BRICKS_SERVER_Font20" )
                local textX, textY = surface.GetTextSize( v.Name )

                local actionButton = vgui.Create( "DButton", actionsBack )
                actionButton:Dock( LEFT )
                actionButton:DockMargin( 0, 0, 5, 0 )
                actionButton:SetText( "" )
                actionButton:SetWide( textX+20 )
                local changeAlpha = 0
                actionButton.Paint = function( self2, w, h )
                    local backColor = v.Color
            
                    if( self2:IsDown() or self2.m_bSelected ) then
                        changeAlpha = math.Clamp( changeAlpha+10, 5, 50 )
                    elseif( self2:IsHovered() ) then
                        changeAlpha = math.Clamp( changeAlpha+10, 5, 25 )
                    else
                        changeAlpha = math.Clamp( changeAlpha-10, 5, 50 )
                    end
            
                    surface.SetAlphaMultiplier( changeAlpha/255 )
                    draw.RoundedBox( 5, 0, 0, w, h, backColor or BRICKS_SERVER.Func.GetTheme( 4 ) )
                    surface.SetAlphaMultiplier( 1 )
            
                    draw.SimpleText( v.Name, "BRICKS_SERVER_Font20", 10, h*0.5, (backColor or BRICKS_SERVER.Func.GetTheme( 5 )), 0, TEXT_ALIGN_CENTER )
                end
                actionButton.DoClick = v.Func
            end

            local rankSheet = self.sheet:AddSheet( function() return self.rolesTableCopy[k][1] end, rolePanel, function() return self.rolesTableCopy[k][2] end )

            rankSheet.Button.rankID = k
            rankSheet.Button:Droppable( "droppableRank" )
            rankSheet.Button.Think = function( self2 ) 
                if( self2:IsDragging() ) then
                    if( draggingButton != self2 ) then
                        draggingButton = self2
                    end
                elseif( IsValid( draggingButton ) ) then
                    if( draggingButton == self2 ) then
                        draggingButton = nil
                    end

                    if( self2:IsHovered() ) then
                        local targetPanel

                        local w, h = 190, self2:GetTall()
                        local cursorX, cursorY = input.GetCursorPos()
                        local toScreenX, toScreenY = self2:LocalToScreen( 0, 0 )

                        local withinXBounds = false
                        if( cursorX > toScreenX and cursorX < toScreenX+w ) then
                            withinXBounds = true
                        end

                        if( withinXBounds ) then
                            if( cursorY > toScreenY and cursorY < toScreenY+(h*0.5) ) then
                                if( dropSections[k-1] and IsValid( dropSections[k-1] ) ) then
                                    targetPanel = dropSections[k-1]
                                end
                            elseif( cursorY > toScreenY+(h*0.5) and cursorY < toScreenY+h ) then
                                if( dropSections[k] and IsValid( dropSections[k] ) ) then
                                    targetPanel = dropSections[k]
                                end
                            end
                            
                            if( IsValid( targetPanel ) and IsValid( draggingButton ) and targetPanel:GetTall() == 0 and targetPanel.belowRank != draggingButton.rankID-1 and targetPanel.belowRank != draggingButton.rankID ) then
                                dragTarget = targetPanel
                                targetPanel:SetTall( 30 )
                            end
                        end
                    end
                end
            end
            rankSheet.Button.OnStopDragging = function( self2 )
                if( not IsValid( dragTarget ) ) then return end

                local dropPanelRank = self2.rankID
                local receiverRank = dragTarget.belowRank

                if( dropPanelRank == receiverRank ) then return end

                local newRankPos
                if( dropPanelRank != 1 and receiverRank == 0 ) then
                    newRankPos = 1
                elseif( receiverRank == #self.rolesTableCopy ) then
                    newRankPos = #self.rolesTableCopy
                elseif( receiverRank != 0 ) then
                    newRankPos = receiverRank+1
                end

                if( newRankPos ) then
                    local rankTable = table.Copy( self.rolesTableCopy[dropPanelRank] )

                    table.remove( self.rolesTableCopy, dropPanelRank )
                    table.insert( self.rolesTableCopy, newRankPos, rankTable )

                    if( not self.roleChanged ) then
                        self:SettingChanged()
                    end
        
                    self.RefreshPanel()
                end
            end

            table.insert( buttons, k, rankSheet.Button )

            addDropSection( 0, k )
        end

        if( self.previousSheet ) then
            self.sheet:SetActiveSheet( self.previousSheet )
        end
    end
    self.RefreshPanel()
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_gangmenu_roles", PANEL, "DPanel" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/submodules/achievements/client/cl_gang_achievements.lua:
BRICKS_SERVER.Func.AddConfigPage( BRICKS_SERVER.Func.L( "gangAchievements" ), "bricks_server_config_gang_achievements", "gangs" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/submodules/storage/vgui/bricks_server_gangmenu_storage.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel( gangTable )
    local topPanel = vgui.Create( "DPanel", self )
    topPanel:Dock( TOP )
    topPanel:DockMargin( 10, 10, 10, 0 )
    topPanel:SetTall( 80 )
    topPanel.Paint = function( self2, w, h ) 
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

        draw.SimpleText( BRICKS_SERVER.Func.L( "gangStorageUpper" ), "BRICKS_SERVER_Font17", 15, 5, BRICKS_SERVER.Func.GetTheme( 5 ), 0, 0 )
    end

    if( LocalPlayer():GangHasPermission( "DepositItem" ) ) then
        local storageDeposit = vgui.Create( "DButton", topPanel )
        storageDeposit:Dock( RIGHT )
        storageDeposit:DockMargin( 0, 10, 10, 10 )
        storageDeposit:SetWide( topPanel:GetTall()-20 )
        storageDeposit:SetText( "" )
        local Alpha = 0
        local depositMat = Material( "bricks_server/deposit.png" )
        storageDeposit.Paint = function( self2, w, h )
            if( self2:IsDown() ) then
                Alpha = 0
            elseif( self2:IsHovered() ) then
                Alpha = math.Clamp( Alpha+5, 0, 75 )
            else
                Alpha = math.Clamp( Alpha-5, 0, 75 )
            end
        
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
            surface.SetAlphaMultiplier( Alpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
            surface.SetAlphaMultiplier( 1 )
        
            surface.SetDrawColor( 255, 255, 255, 20+(235*(Alpha/75)) )
            surface.SetMaterial( depositMat )
            local iconSize = 32
            surface.DrawTexturedRect( (w*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
        end
        storageDeposit.DoClick = function()
            if( not IsValid( BRICKS_SERVER_GANGDEPOSIT ) ) then
                BRICKS_SERVER_GANGDEPOSIT = vgui.Create( "bricks_server_gang_deposit" )
            end
        end
    end

    local storageProgress = vgui.Create( "DPanel", topPanel )
    storageProgress:Dock( BOTTOM )
    if( LocalPlayer():GangHasPermission( "DepositItem" ) ) then
        storageProgress:DockMargin( 10, 10, 5, 10 )
    else
        storageProgress:DockMargin( 10, 10, 10, 10 )
    end
    storageProgress:SetTall( 40 )
    storageProgress.Paint = function( self2, w, h ) 
        local storageCount, maxStorage = table.Count( gangTable.Storage or {} ), BRICKS_SERVER.Func.GangGetUpgradeInfo( LocalPlayer():GetGangID(), "StorageSlots" )[1]

        local decimal = math.Clamp( storageCount/maxStorage, 0, 1 )

        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
        draw.RoundedBox( 5, 0, 0, w*decimal, h, BRICKS_SERVER.Func.GetTheme( 5 ) )

        draw.SimpleText( BRICKS_SERVER.Func.L( "gangStorageProgress", storageCount, maxStorage ), "BRICKS_SERVER_Font20", 15, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
        
        draw.SimpleText( math.Round( decimal*100, 2 ) .. "%", "BRICKS_SERVER_Font20", w-15, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
    end

    local storageScroll = vgui.Create( "bricks_server_scrollpanel", self )
    storageScroll:Dock( FILL )
    storageScroll:DockMargin( 10, 10, 10, 10 )
    storageScroll.Paint = function( self, w, h ) end 

    local spacing = 5
    local storageGrid = vgui.Create( "DIconLayout", storageScroll )
    storageGrid:Dock( TOP )
    storageGrid:SetSpaceY( spacing )
    storageGrid:SetSpaceX( spacing )

    local gridWide = self.panelWide-20
    local slotSize = 125
    local slotsWide = math.floor( gridWide/slotSize )
    local actualSlotSize = (gridWide-((slotsWide-1)*spacing))/slotsWide

    function self.RefreshPanel()
        storageGrid:Clear()

        local maxStorage = BRICKS_SERVER.Func.GangGetUpgradeInfo( LocalPlayer():GetGangID(), "StorageSlots" )[1]
        local slotsTall = math.ceil( maxStorage/slotsWide )
        storageGrid:SetTall( (slotsTall*actualSlotSize)+((slotsTall-1)*spacing) )

        for i = 1, maxStorage do
            local slotBack = storageGrid:Add( "DPanel" )
            slotBack:SetSize( actualSlotSize, actualSlotSize )
            slotBack.Paint = function( self2, w, h )
                surface.SetAlphaMultiplier( 75/255 )
                draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                surface.SetAlphaMultiplier( 1 )
            end

            if( gangTable.Storage and gangTable.Storage[i] ) then
                local v = gangTable.Storage[i]

                local x, y, w, h = 0, 0, actualSlotSize, actualSlotSize
                local changeAlpha = 0

                local itemInfo = {}
                if( BRICKS_SERVER.Func.GetInvTypeCFG( ((v or {})[2] or {})[1] or "" ).GetInfo ) then
                    itemInfo = BRICKS_SERVER.Func.GetInvTypeCFG( ((v or {})[2] or {})[1] or "" ).GetInfo( v[2] )
                else
                    itemInfo = BRICKS_SERVER.DEVCONFIG.INVENTORY.DefaultEntFuncs.GetInfo( v[2] )
                end
                
                
                local tooltipInfo = {}
                tooltipInfo[1] = { itemInfo[1], false, "BRICKS_SERVER_Font23B" }
                local rarityInfo
                if( itemInfo[3] ) then
                    rarityInfo = BRICKS_SERVER.Func.GetRarityInfo( itemInfo[3] )
                    tooltipInfo[2] = { itemInfo[3], function() return BRICKS_SERVER.Func.GetRarityColor( rarityInfo ) end, "BRICKS_SERVER_Font17" }
                end
                table.insert( tooltipInfo, itemInfo[2] )
                if( #itemInfo > 3 ) then
                    for i = 4, #itemInfo do
                        table.insert( tooltipInfo, itemInfo[i] )
                    end
                end

                slotBack.Paint = function( self2, w, h )
                    local toScreenX, toScreenY = self2:LocalToScreen( 0, 0 )
                    if( x != toScreenX or y != toScreenY ) then
                        x, y = toScreenX, toScreenY
                        self2.itemModel:SetBRSToolTip( x, y, w, h, tooltipInfo )
                    end

                    draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
                    
                    if( self2.itemModel:IsDown() ) then
                        changeAlpha = 0
                    elseif( self2.itemModel:IsHovered() ) then
                        changeAlpha = math.Clamp( changeAlpha+10, 0, 50 )
                    else
                        changeAlpha = math.Clamp( changeAlpha-10, 0, 50 )
                    end

                    surface.SetAlphaMultiplier( changeAlpha/255 )
                    draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )
                    surface.SetAlphaMultiplier( 1 )

                    if( (v[1] or 1) > 1 ) then
                        draw.SimpleText( "x" .. (v[1] or 1), "BRICKS_SERVER_Font20B", w-12, h-7, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM )
                    end
                end

                if( rarityInfo ) then
                    local rarityBox = vgui.Create( "bricks_server_raritybox", slotBack )
                    rarityBox:SetSize( slotBack:GetWide(), 5 )
                    rarityBox:SetPos( 0, slotBack:GetTall()-rarityBox:GetTall() )
                    rarityBox:SetRarityName( rarityInfo[1] )
                    rarityBox:SetCornerRadius( 8 )
                    rarityBox:SetRoundedBoxDimensions( false, -15, false, 20 )
                end

                slotBack.itemModel = vgui.Create( "DModelPanel" , slotBack )
                slotBack.itemModel:Dock( FILL )
                slotBack.itemModel:SetModel( ((v or {})[2] or {})[2] or "models/error.mdl" )
                slotBack.itemModel:SetFOV( 50 )
                function slotBack.itemModel:LayoutEntity( Entity ) return end

                if( BRICKS_SERVER.Func.GetInvTypeCFG( ((v or {})[2] or {})[1] or "" ).ModelDisplay ) then
                    BRICKS_SERVER.Func.GetInvTypeCFG( ((v or {})[2] or {})[1] or "" ).ModelDisplay( slotBack.itemModel, v[2] )
                else
                    BRICKS_SERVER.DEVCONFIG.INVENTORY.DefaultEntFuncs.ModelDisplay( slotBack.itemModel, v[2] )
                end

                if( LocalPlayer():GangHasPermission( "WithdrawItem" ) ) then
                    local actions = {
                        [BRICKS_SERVER.Func.L( "drop" )] = function() 
                            net.Start( "BRS.Net.GangStorageDrop" )
                            net.WriteUInt( 1, 8 )
                                net.WriteUInt( i, 10 )
                            net.SendToServer()
                        end
                    }
            
                    if( BRICKS_SERVER.Func.GetInvTypeCFG( v[2][1] or "" ).OnUse ) then
                        actions[BRICKS_SERVER.Func.L( "use" )] = function() 
                            net.Start( "BRS.Net.GangStorageUse" )
                                net.WriteUInt( i, 10 )
                            net.SendToServer()
                        end
                    end
            
                    if( BRICKS_SERVER.Func.GetInvTypeCFG( v[2][1] or "" ).CanDropMultiple and (v[1] or 1) > 1 ) then
                        actions[BRICKS_SERVER.Func.L( "dropAll" )] = function() 
                            net.Start( "BRS.Net.GangStorageDrop" )
                                net.WriteUInt( (v[1] or 1), 8 )
                                net.WriteUInt( i, 10 )
                            net.SendToServer()
                        end
                    end
            
                    slotBack.itemModel.DoClick = function()
                        slotBack.itemModel.Menu = vgui.Create( "bricks_server_popupdmenu" )
                        for k, v in pairs( actions ) do
                            slotBack.itemModel.Menu:AddOption( k, v )
                        end
                        slotBack.itemModel.Menu:Open( slotBack.itemModel, x+w-5, y+(h*0.5)-(slotBack.itemModel.Menu:GetTall()*0.5) )
                    end
                end
            end
        end
    end
    self.RefreshPanel()

    hook.Add( "BRS.Hooks.RefreshGang", self, function( self, valuesChanged )
        if( IsValid( self ) ) then
            if( valuesChanged and (valuesChanged["Storage"] or valuesChanged["Upgrades"]) ) then
                self.RefreshPanel()
            end
        else
            hook.Remove( "BRS.Hooks.RefreshGang", self )
        end
    end )
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_gangmenu_storage", PANEL, "DPanel" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/submodules/leaderboards/vgui/bricks_server_gangmenu_leaderboards.lua:
local PANEL = {}

function PANEL:Init()
    self:DockMargin( 10, 10, 10, 10 )
end

function PANEL:FillPanel( gangTable )
    BRICKS_SERVER.Func.RequestGangLeaderboards()

    function self.RefreshPanel()
        self:Clear()

        for k, v in pairs( BRICKS_SERVER.CONFIG.GANGS.Leaderboards or {} ) do
            local leaderboardTable = (BRS_GANG_LEADERBOARDS or {})[k] or {}

            local itemBack = vgui.Create( "DPanel", self )
            itemBack:Dock( TOP )
            itemBack:DockMargin( 0, 0, 0, 5 )
            itemBack:SetTall( 140 )
            itemBack.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
            end

            local topBar = vgui.Create( "DPanel", itemBack )
            topBar:Dock( TOP )
            topBar:SetTall( 40 )
            surface.SetFont( "BRICKS_SERVER_Font20" )
            local nameX, nameY = surface.GetTextSize( v.Name )
            topBar.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

                BRICKS_SERVER.Func.DrawPartialRoundedBox( 5, 0, 0, 3, h, (v.Color or BRICKS_SERVER.Func.GetTheme( 5 )), 10, h )
            
                draw.SimpleText( v.Name, "BRICKS_SERVER_Font20", 15, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
            end

            local occupyingGangTable = {}
            if( leaderboardTable.GangID ) then
                if( BRICKS_SERVER_GANGS[leaderboardTable.GangID or 0] ) then
                    occupyingGangTable = BRICKS_SERVER_GANGS[leaderboardTable.GangID or 0]
                else
                    BRICKS_SERVER.Func.RequestLeaderboardGangs()
                end
            end

            local rightBackTall = itemBack:GetTall()-topBar:GetTall()

            local rightBack = vgui.Create( "DPanel", itemBack )
            rightBack:Dock( RIGHT )
            rightBack:DockMargin( 0, 0, 15, 0 )
            rightBack:SetWide( 150 )
            rightBack.Paint = function( self2, w, h ) end

            local noticeBack = vgui.Create( "DPanel", rightBack )
            noticeBack:SetSize( 0, 35 )
            noticeBack:SetPos( (rightBack:GetWide()*0.5)-(noticeBack:GetWide()*0.5), (rightBackTall*0.5)-(noticeBack:GetTall()*0.5) )
            noticeBack.Paint = function( self2, w, h ) end

            local itemNotices = {}

            local devConfig = BRICKS_SERVER.DEVCONFIG.GangLeaderboards[v.Type]

            if( devConfig ) then
                table.insert( itemNotices, { devConfig.FormatDescription( leaderboardTable.SortValue or 0 ), devConfig.Color } )
            end

            for k, v in pairs( itemNotices ) do
                surface.SetFont( "BRICKS_SERVER_Font23" )
                local textX, textY = surface.GetTextSize( v[1] )
                local boxW, boxH = textX+15, textY+5

                local itemInfoNotice = vgui.Create( "DPanel", noticeBack )
                itemInfoNotice:Dock( LEFT )
                itemInfoNotice:DockMargin( 0, 0, 5, 0 )
                itemInfoNotice:SetWide( boxW )
                itemInfoNotice.Paint = function( self2, w, h ) 
                    draw.RoundedBox( 5, 0, 0, w, h, (v[2] or BRICKS_SERVER.Func.GetTheme( 5 )) )
                    draw.SimpleText( v[1], "BRICKS_SERVER_Font23", w*0.5, (h*0.5)-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                end

                if( noticeBack:GetWide() <= 5 ) then
                    noticeBack:SetSize( noticeBack:GetWide()+boxW, boxH )
                else
                    noticeBack:SetSize( noticeBack:GetWide()+5+boxW, boxH )
                end

                if( noticeBack:GetWide() > rightBack:GetWide() ) then
                    rightBack:SetWide( noticeBack:GetWide() )
                end

                noticeBack:SetPos( (rightBack:GetWide()*0.5)-(noticeBack:GetWide()*0.5), (rightBackTall*0.5)-(noticeBack:GetTall()*0.5) )
            end

            local avatarBack = vgui.Create( "DPanel", itemBack )
            avatarBack:Dock( FILL )
            avatarBack:DockMargin( 15, 15, 15, 15 )
            local avatarBackSize = 70
            local avatarSize = (occupyingGangTable.Icon and avatarBackSize*0.6) or 32
            avatarBack.Paint = function( self2, w, h )
                local textStartPos = avatarBackSize+15

                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3 ) )
                draw.NoTexture()
                BRICKS_SERVER.Func.DrawCircle( (h-avatarBackSize)*0.5+(avatarBackSize*0.5), h*0.5, avatarBackSize*0.5, 45 )
        
                draw.SimpleText( (occupyingGangTable.Name or BRICKS_SERVER.Func.L( "gangNone" )), "BRICKS_SERVER_Font23", textStartPos, h*0.5+2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_BOTTOM )
        
                draw.SimpleText( BRICKS_SERVER.Func.L( "gangID", (leaderboardTable.GangID or 0) ), "BRICKS_SERVER_Font17", textStartPos, h*0.5-2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
            end

            local gangIcon = vgui.Create( "bricks_server_gangicon", avatarBack )
            gangIcon:SetSize( avatarSize, avatarSize )
            gangIcon:SetPos( (avatarBackSize-avatarSize)*0.5, (avatarBackSize-avatarSize)*0.5 )
            gangIcon:SetIconURL( occupyingGangTable.Icon or "bricks_server/question.png" )
        end
    end
    self.RefreshPanel()

    hook.Add( "BRS.Hooks.RefreshGangLeaderboards", self, function()
        if( IsValid( self ) ) then
            self.RefreshPanel()
        else
            hook.Remove( "BRS.Hooks.RefreshGangLeaderboards", self )
        end
    end )
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_gangmenu_leaderboards", PANEL, "bricks_server_scrollpanel" )
--PATH addons/_bitminers2ex/lua/bitminers2_extra_config.lua:
BM2EXTRACONFIG = {}
--The capacity of the extra fuel tanks
BM2EXTRACONFIG.ExtraFuelTankSize = 5000
--Then someone destroyed a fuel tank that still has fuel in it it will explopde.
--This will disable it if set to true
BM2EXTRACONFIG.DisableFuelTankExplosion = false
--If set to true this will disable the requirment of solar panels having power
--Setting this to false will require that solar panels have direct line of sight with the skybox
BM2EXTRACONFIG.DisableLightRequirment = false
--This is how much it costs to purchase the remote access upgrade on a bitminer
BM2EXTRACONFIG.RemoteAccessPrice = 2500
--This is the command used to access the phone in game
BM2EXTRACONFIG.RemoteAccessCommand = "!remotebitminers"
--Edit the entities here
hook.Add( "BM2_DLC_loadCustomDarkRPItems", "BM2.RegisterEntities", function()
	DarkRP.createEntity( "Fuel Line", {
		ent = "bm2_extra_fuel_line",
		model = "models/bitminers2/bm2_extra_fuel_plug.mdl",
		price = 1500,
		max = 2,
		cmd = "buyfuelline",
		category = "Bitminers 2"
	} )

	DarkRP.createEntity( "Large Fuel", {
		ent = "bm2_large_fuel",
		model = "models/props/de_train/barrel.mdl",
		price = 4000,
		max = 4,
		cmd = "buylargefuel",
		category = "Bitminers 2"
	} )

	DarkRP.createEntity( "Fuel Tank", {
		ent = "bm2_extra_fuel_tank",
		model = "models/bitminers2/bm2_extra_fueltank.mdl",
		price = 10000,
		max = 2,
		cmd = "buyfueltank",
		category = "Bitminers 2"
	} )

	DarkRP.createEntity( "Solar Cable", {
		ent = "bm2_solar_cable",
		model = "models/bitminers2/bm2_solar_plug.mdl",
		price = 500,
		max = 10,
		cmd = "buysolarcable",
		category = "Bitminers 2"
	} )

	DarkRP.createEntity( "Solar Converter", {
		ent = "bm2_solarconverter",
		model = "models/bitminers2/bm2_solar_converter.mdl",
		price = 20000,
		max = 1,
		cmd = "buysolarconverter",
		category = "Bitminers 2"
	} )

	DarkRP.createEntity( "Solar Panel", {
		ent = "bm2_solar_panel",
		model = "models/bitminers2/bm2_solar_panel.mdl",
		price = 15000,
		max = 10,
		cmd = "buysolarpanel",
		category = "Bitminers 2"
	} )
end )
--PATH addons/__main/lua/permaprops/cl_menu.lua:
/*
   ____          _          _   ____          __  __       _ _                     
  / ___|___   __| | ___  __| | | __ ) _   _  |  \/  | __ _| | |__   ___  _ __ ___  
 | |   / _ \ / _` |/ _ \/ _` | |  _ \| | | | | |\/| |/ _` | | '_ \ / _ \| '__/ _ \ 
 | |__| (_) | (_| |  __/ (_| | | |_) | |_| | | |  | | (_| | | |_) | (_) | | | (_) |
  \____\___/ \__,_|\___|\__,_| |____/ \__, | |_|  |_|\__,_|_|_.__/ \___/|_|  \___/ 
                                      |___/                                        
*/

surface.CreateFont( "pp_font", {
	font = "Arial",
	size = 20,
	weight = 700,
	shadow = false
} )

local function pp_open_menu()

	local Len = net.ReadFloat()
	local Data = net.ReadData( Len )
	local UnCompress = util.Decompress( Data )
	local Content = util.JSONToTable( UnCompress )

 	local Main = vgui.Create( "DFrame" )
	Main:SetSize( 600, 355 )
	Main:Center()
	Main:SetTitle("")
	Main:SetVisible( true )
	Main:SetDraggable( true )
	Main:ShowCloseButton( true )
	Main:MakePopup()
	Main.Paint = function(self)

		draw.RoundedBox( 0, 0, 0, self:GetWide(), self:GetTall(), Color(155, 155, 155, 220) )
		surface.SetDrawColor( 17, 148, 240, 255 )
		surface.DrawOutlinedRect( 0, 0, self:GetWide(), self:GetTall() )	

		draw.RoundedBox( 0, 0, 0, self:GetWide(), 25, Color(17, 148, 240, 200) )
		surface.SetDrawColor( 17, 148, 240, 255 )
		surface.DrawOutlinedRect( 0, 0, self:GetWide(), 25 )
		draw.DrawText( "PermaProps Config", "pp_font", 10, 2.2, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT )

	end

	local BSelect
	local PSelect

	local MainPanel = vgui.Create( "DPanel", Main )
	MainPanel:SetPos( 190, 51 )
	MainPanel:SetSize( 390, 275 )
	MainPanel.Paint = function( self )
		surface.SetDrawColor( 50, 50, 50, 200 ) 
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
		surface.DrawOutlinedRect(0, 15, self:GetWide(), 40)
	end
	PSelect = MainPanel

	local MainLabel = vgui.Create("DLabel", MainPanel)
	MainLabel:SetFont("pp_font")
	MainLabel:SetPos(140, 25) 
	MainLabel:SetColor(Color(50, 50, 50, 255)) 
	MainLabel:SetText("Hey ".. LocalPlayer():Nick() .." !") 
	MainLabel:SizeToContents()

	local MainLabel2 = vgui.Create("DLabel", MainPanel)
	MainLabel2:SetFont("pp_font")
	MainLabel2:SetPos(80, 80) 
	MainLabel2:SetColor(Color(50, 50, 50, 255)) 
	MainLabel2:SetText("There are ".. ( Content.MProps or 0 ) .." props on this map.\n\nThere are ".. ( Content.TProps or 0 ) .." props in the DB.") 
	MainLabel2:SizeToContents()

	local RemoveMapProps = vgui.Create( "DButton", MainPanel )
	RemoveMapProps:SetText( " Clear map props " )
	RemoveMapProps:SetFont("pp_font")
	RemoveMapProps:SetSize( 370, 30)
	RemoveMapProps:SetPos( 10, 160 )
	RemoveMapProps:SetTextColor( Color( 50, 50, 50, 255 ) )
	RemoveMapProps.DoClick = function()
		net.Start("pp_info_send")
			net.WriteTable({CMD = "CLR_MAP"})
		net.SendToServer()
	end
	RemoveMapProps.Paint = function(self)
		surface.SetDrawColor(50, 50, 50, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end

	local ClearMapProps = vgui.Create( "DButton", MainPanel )
	ClearMapProps:SetText( " Clear map props in the DB " )
	ClearMapProps:SetFont("pp_font")
	ClearMapProps:SetSize( 370, 30)
	ClearMapProps:SetPos( 10, 200 )
	ClearMapProps:SetTextColor( Color( 50, 50, 50, 255 ) )
	ClearMapProps.DoClick = function()

		Derma_Query("Are you sure you want clear map props in the db ?\nYou can't undo this action !", "PermaProps 4.0", "Yes", function() net.Start("pp_info_send") net.WriteTable({CMD = "DEL_MAP"}) net.SendToServer() end, "Cancel")

	end
	ClearMapProps.Paint = function(self)
		surface.SetDrawColor(50, 50, 50, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end

	local ClearAllProps = vgui.Create( "DButton", MainPanel )
	ClearAllProps:SetText( " Clear all props in the DB " )
	ClearAllProps:SetFont("pp_font")
	ClearAllProps:SetSize( 370, 30)
	ClearAllProps:SetPos( 10, 240 )
	ClearAllProps:SetTextColor( Color( 50, 50, 50, 255 ) )
	ClearAllProps.DoClick = function()

		Derma_Query("Are you sure you want clear all props in the db ?\nYou can't undo this action !", "PermaProps 4.0", "Yes", function() net.Start("pp_info_send") net.WriteTable({CMD = "DEL_ALL"}) net.SendToServer() end, "Cancel")

	end
	ClearAllProps.Paint = function(self)
		surface.SetDrawColor(50, 50, 50, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end

	local BMain = vgui.Create("DButton", Main)
	BSelect = BMain
	BMain:SetText("Main")
	BMain:SetFont("pp_font")
	BMain:SetSize(160, 50)
	BMain:SetPos(15, 27 + 25)
	BMain:SetTextColor( Color( 255, 255, 255, 255 ) )
	BMain.PaintColor = Color(17, 148, 240, 100)
	BMain.Paint = function(self)

		draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.PaintColor)
		surface.SetDrawColor(17, 148, 240, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())

	end
	BMain.DoClick = function( self )

		if BSelect then BSelect.PaintColor = Color(0, 0, 0, 0) end
		BSelect = self
		self.PaintColor = Color(17, 148, 240, 100)

		if PSelect then PSelect:Hide() end
		MainPanel:Show()
		PSelect = MainPanel

	end

	local ConfigPanel = vgui.Create( "DPanel", Main )
	ConfigPanel:SetPos( 190, 51 )
	ConfigPanel:SetSize( 390, 275 )
	ConfigPanel.Paint = function( self )
		surface.SetDrawColor( 50, 50, 50, 200 ) 
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	end
	ConfigPanel:Hide()

	local CheckCustom = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckCustom:SetPos( 5, 30 )
	CheckCustom:SetText( "Custom permissions" )
	CheckCustom:SetValue( 0 )
	CheckCustom:SizeToContents()
	CheckCustom:SetTextColor( Color( 0, 0, 0, 255) )
	CheckCustom:SetDisabled( true )

	local GroupsList = vgui.Create( "DComboBox", ConfigPanel )
	GroupsList:SetPos( 5, 5 )
	GroupsList:SetSize( 125, 20 )
	GroupsList:SetValue( "Select a group..." )

	local CheckBox1 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox1:SetPos( 150, 10 )
	CheckBox1:SetText( "Menu" )
	CheckBox1:SizeToContents()
	CheckBox1:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox1:SetDisabled( true )
	CheckBox1.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Menu", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox2 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox2:SetPos( 150, 30 )
	CheckBox2:SetText( "Edit permissions" )
	CheckBox2:SizeToContents()
	CheckBox2:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox2:SetDisabled( true )
	CheckBox2.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Permissions", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox3 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox3:SetPos( 150, 50 )
	CheckBox3:SetText( "Physgun permaprops" )
	CheckBox3:SizeToContents()
	CheckBox3:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox3:SetDisabled( true )
	CheckBox3.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Physgun", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox4 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox4:SetPos( 150, 70 )
	CheckBox4:SetText( "Tool permaprops" )
	CheckBox4:SizeToContents()
	CheckBox4:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox4:SetDisabled( true )
	CheckBox4.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Tool", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox5 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox5:SetPos( 150, 90 )
	CheckBox5:SetText( "Property permaprops" )
	CheckBox5:SizeToContents()
	CheckBox5:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox5:SetDisabled( true )
	CheckBox5.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Property", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox6 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox6:SetPos( 150, 110 )
	CheckBox6:SetText( "Save props" )
	CheckBox6:SizeToContents()
	CheckBox6:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox6:SetDisabled( true )
	CheckBox6.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Save", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox7 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox7:SetPos( 150, 130 )
	CheckBox7:SetText( "Delete permaprops" )
	CheckBox7:SizeToContents()
	CheckBox7:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox7:SetDisabled( true )
	CheckBox7.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Delete", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local CheckBox8 = vgui.Create( "DCheckBoxLabel", ConfigPanel )
	CheckBox8:SetPos( 150, 150 )
	CheckBox8:SetText( "Update permaprops" )
	CheckBox8:SizeToContents()
	CheckBox8:SetTextColor( Color( 0, 0, 0, 255) )
	CheckBox8:SetDisabled( true )
	CheckBox8.OnChange = function(Self, Value)

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Update", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	GroupsList.OnSelect = function( panel, index, value )
		
		CheckCustom:SetDisabled( false )
		CheckCustom:SetChecked( Content.Permissions[value].Custom )

		CheckBox1:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox1:SetChecked( Content.Permissions[value].Menu )
		CheckBox2:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox2:SetChecked( Content.Permissions[value].Permissions )
		CheckBox3:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox3:SetChecked( Content.Permissions[value].Physgun )
		CheckBox4:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox4:SetChecked( Content.Permissions[value].Tool )
		CheckBox5:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox5:SetChecked( Content.Permissions[value].Property )
		CheckBox6:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox6:SetChecked( Content.Permissions[value].Save )
		CheckBox7:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox7:SetChecked( Content.Permissions[value].Delete )
		CheckBox8:SetDisabled( !Content.Permissions[value].Custom )
		CheckBox8:SetChecked( Content.Permissions[value].Update )

	end

	for k, v in pairs(Content.Permissions) do
		
		GroupsList:AddChoice(k)

	end

	CheckCustom.OnChange = function(Self, Value)

		CheckBox1:SetDisabled( !Value )
		CheckBox2:SetDisabled( !Value )
		CheckBox3:SetDisabled( !Value )
		CheckBox4:SetDisabled( !Value )
		CheckBox5:SetDisabled( !Value )
		CheckBox6:SetDisabled( !Value )
		CheckBox7:SetDisabled( !Value )
		CheckBox8:SetDisabled( !Value )

		net.Start("pp_info_send")
			net.WriteTable({CMD = "VAR", Val = Value, Data = "Custom", Name = GroupsList:GetValue()})
		net.SendToServer()

	end

	local BConfig = vgui.Create("DButton", Main)
	BConfig:SetText("Configuration")
	BConfig:SetFont("pp_font")
	BConfig:SetSize(160, 50)
	BConfig:SetPos(15, 71 + 55)
	BConfig:SetTextColor( Color( 255, 255, 255, 255 ) )
	BConfig.PaintColor = Color(0, 0, 0, 0)
	BConfig.Paint = function(self)
		draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.PaintColor)
		surface.SetDrawColor(17, 148, 240, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end
	BConfig.DoClick = function( self )

		if BSelect then BSelect.PaintColor = Color(0, 0, 0, 0) end
		BSelect = self
		self.PaintColor = Color(17, 148, 240, 100)

		if PSelect then PSelect:Hide() end
		ConfigPanel:Show()
		PSelect = ConfigPanel

	end

	local PropsPanel = vgui.Create( "DPanel", Main )
	PropsPanel:SetPos( 190, 51 )
	PropsPanel:SetSize( 390, 275 )
	PropsPanel.Paint = function( self )
		surface.SetDrawColor( 50, 50, 50, 200 ) 
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
	end
	PropsPanel:Hide()

	local PropsList = vgui.Create( "DListView", PropsPanel )
	PropsList:SetMultiSelect( false )
	PropsList:SetSize( 390, 275 )
	local ColID = PropsList:AddColumn( "ID" )
	local ColEnt = PropsList:AddColumn( "Entity" )
	local ColMdl = PropsList:AddColumn( "Model" )
	ColID:SetMinWidth(50)
	ColID:SetMaxWidth(50)
	PropsList.Paint = function( self )
		surface.SetDrawColor(17, 148, 240, 255)
	end

	PropsList.OnRowRightClick = function(panel, line)

		local MenuButtonOptions = DermaMenu()
	    MenuButtonOptions:AddOption("Draw entity", function() 

	    	if not LocalPlayer().DrawPPEnt or not istable(LocalPlayer().DrawPPEnt) then LocalPlayer().DrawPPEnt = {} end

	    	if LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] and LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)]:IsValid() then return end

		    local ent = ents.CreateClientProp( Content.PropsList[PropsList:GetLine(line):GetValue(1)].Model ) 
			ent:SetPos( Content.PropsList[PropsList:GetLine(line):GetValue(1)].Pos )
			ent:SetAngles( Content.PropsList[PropsList:GetLine(line):GetValue(1)].Angle )

			LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] = ent

		end )

		if LocalPlayer().DrawPPEnt and LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] then
			
			MenuButtonOptions:AddOption("Stop Drawing", function() 

				LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)]:Remove()
				LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] = nil

			end )

		end

		if LocalPlayer().DrawPPEnt != nil and istable(LocalPlayer().DrawPPEnt) and table.Count(LocalPlayer().DrawPPEnt) > 0 then

			MenuButtonOptions:AddOption("Stop Drawing All", function() 

				for k, v in pairs(LocalPlayer().DrawPPEnt) do
					
					LocalPlayer().DrawPPEnt[k]:Remove()
					LocalPlayer().DrawPPEnt[k] = nil

				end

			end )
			
		end

	    MenuButtonOptions:AddOption("Remove", function()

	    	net.Start("pp_info_send")
	    		net.WriteTable({CMD = "DEL", Val = PropsList:GetLine(line):GetValue(1)})
	    	net.SendToServer()

	    	if LocalPlayer().DrawPPEnt and LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] != nil then

	    		LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)]:Remove()
				LocalPlayer().DrawPPEnt[PropsList:GetLine(line):GetValue(1)] = nil
				
	    	end

	    	PropsList:RemoveLine(line)


		end )
	    MenuButtonOptions:Open()
		
	end

	for k, v in pairs(Content.PropsList) do
		
		PropsList:AddLine(k, v.Class, v.Model)

	end

	local BProps = vgui.Create("DButton", Main)
	BProps:SetText("Props List")
	BProps:SetFont("pp_font")
	BProps:SetSize(160, 50)
	BProps:SetPos(15, 115 + 85)
	BProps:SetTextColor( Color( 255, 255, 255, 255 ) )
	BProps.PaintColor = Color(0, 0, 0, 0)
	BProps.Paint = function(self)
		draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.PaintColor)
		surface.SetDrawColor(17, 148, 240, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end
	BProps.DoClick = function( self )

		if BSelect then BSelect.PaintColor = Color(0, 0, 0, 0) end
		BSelect = self
		self.PaintColor = Color(17, 148, 240, 100)

		if PSelect then PSelect:Hide() end
		PropsPanel:Show()
		PSelect = PropsPanel

	end

	local AboutPanel = vgui.Create( "DPanel", Main )
	AboutPanel:SetPos( 190, 51 )
	AboutPanel:SetSize( 390, 275 )
	AboutPanel.Paint = function( self )
		surface.SetDrawColor( 50, 50, 50, 200 ) 
		surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
		surface.DrawOutlinedRect(0, 15, self:GetWide(), 40)
	end
	AboutPanel:Hide()

	local AboutLabel = vgui.Create("DLabel", AboutPanel)
	AboutLabel:SetFont("pp_font")
	AboutLabel:SetPos(140, 25) 
	AboutLabel:SetColor(Color(50, 50, 50, 255)) 
	AboutLabel:SetText("PermaProps 4.0") 
	AboutLabel:SizeToContents()

	local AboutLabel2 = vgui.Create("DLabel", AboutPanel)
	AboutLabel2:SetFont("pp_font")
	AboutLabel2:SetPos(30, 80) 
	AboutLabel2:SetColor(Color(50, 50, 50, 255)) 
	AboutLabel2:SetText("Author:              Malboro\n\nContributor:      Entoros | ARitz Cracker\n\n\n           Special thanks to all donors !") 
	AboutLabel2:SizeToContents()

	local DonationsTxT = vgui.Create( "DButton", AboutPanel )
	DonationsTxT:SetText( " Donate " )
	DonationsTxT:SetFont("pp_font")
	DonationsTxT:SetSize( 370, 30)
	DonationsTxT:SetPos( 10, 240 )
	DonationsTxT:SetTextColor( Color( 50, 50, 50, 255 ) )
	DonationsTxT.DoClick = function() gui.OpenURL("https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=CJ5EUHFAQ7NLN") end
	DonationsTxT.Paint = function(self)
		surface.SetDrawColor(50, 50, 50, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end

	local BAbout = vgui.Create("DButton", Main)
	BAbout:SetText("About")
	BAbout:SetFont("pp_font")
	BAbout:SetSize(160, 50)
	BAbout:SetPos(15, 159 + 115)
	BAbout:SetTextColor( Color( 255, 255, 255, 255 ) )
	BAbout.PaintColor = Color(0, 0, 0, 0)
	BAbout.Paint = function(self)
		draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.PaintColor)
		surface.SetDrawColor(17, 148, 240, 255)
		surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
	end
	BAbout.DoClick = function( self )
	
		if BSelect then BSelect.PaintColor = Color(0, 0, 0, 0) end
		BSelect = self
		self.PaintColor = Color(17, 148, 240, 100)

		if PSelect then PSelect:Hide() end
		AboutPanel:Show()
		PSelect = AboutPanel

	end

	if !file.Exists("permaprops_donate.txt", "DATA") then
		
		Derma_Query("Please don't Forget to Donate", "PermaProps 4.0", "Donate", function() gui.OpenURL("https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=CJ5EUHFAQ7NLN") end, "Cancel", function() file.Write("permaprops_donate.txt") end)

	end

end
net.Receive("pp_open_menu", pp_open_menu)
--PATH addons/mobile_phone/lua/autorun/client/cl_rubyphone_listview.lua:
local PANEL = {}
Derma_Hook(PANEL, 'Paint', 'Paint', 'UIListView')

function PANEL:Init()
    self.Rows = {}
    self.SearchResults = {}
    self.HideInvisible = true
    self.RowHeight = 30
    self:SetSpacing(2)
end

function PANEL:SetRowHeight(height)
    self.RowHeight = height
end

function PANEL:AddCustomRow(row, disabled)
    self:AddItem(row)
    self.Rows[#self.Rows + 1] = row
    self.SearchResults[#self.SearchResults + 1] = row

    return row
end

function PANEL:AddRow(value, disabled)
    local row = vgui.Create('onyx.Button')
    row:SetText(tostring(value))
    row:SetTall(self.RowHeight)

    if disabled == true then
        row:SetDisabled(true)
    end

    self:AddItem(row)
    self.Rows[#self.Rows + 1] = row
    self.SearchResults[#self.SearchResults + 1] = row

    row.DoClick = function()
        if IsValid(self.Selected) then
            self.Selected.Active = false
        end

        row.Active = true
        self.Selected = row
    end

    return row
end

function PANEL:AddImageRow()
    local btn = vgui.Create('rubyphoneImageRow')
    self.Rows[#self.Rows + 1] = btn

    btn.DoClick = function()
        if IsValid(self.Selected) then
            self.Selected.Active = false
        end

        btn.Active = true
        self.Selected = btn
    end

    self:AddItem(btn)

    return btn
end

function PANEL:AddPlayer(pl, steamid64)
    local btn = self:AddImageRow()
    btn:SetPlayer(pl, steamid64)

    return btn
end

function PANEL:AddSpacer(value)
    local row = self:AddRow(value, true)
    row:SetTall(35)
    row:SetFont('font_roboto_22')

    return row
end

function PANEL:AddYou(value)
    local you = self:AddYou(value, true)
    you:SetTall(35)
    you:SetFont('font_roboto_22')

    return you
end

function PANEL:GetSelected()
    return self.Selected
end

function PANEL:Search(value)
    self.SearchResults = {}

    if (not value) or (value == '') then
        for k, v in ipairs(self.Rows) do
            if IsValid(v) then
                v:SetVisible(true)
                self.SearchResults[#self.SearchResults + 1] = v
            end
        end

        if IsValid(self.NoResultsSpacer) then
            self.NoResultsSpacer:Remove()
        end

        self:PerformLayout()
    else
        local c = 0

        for k, v in ipairs(self.Rows) do
            if not IsValid(v) then continue end

            if self:FilterSearchResult(v, value) then
                c = c + 1
                v:SetVisible(true)
                self.SearchResults[#self.SearchResults + 1] = v
            else
                v:SetVisible(false)
            end
        end

        if c == 0 then
            if IsValid(self.NoResultsSpacer) then
                self.NoResultsSpacer:SetVisible(true)
            else
                self.NoResultsSpacer = self:AddSpacer(self.NoResultsMessage or 'No results found!')
            end
        elseif IsValid(self.NoResultsSpacer) then
            self.NoResultsSpacer:SetVisible(false)
        end

        self:PerformLayout()
    end
end

function PANEL:SetNoResultsMessage(msg)
    self.NoResultsMessage = msg
end

function PANEL:GetSearchResults()
    return self.SearchResults
end

function PANEL:FilterSearchResult(row, value)
    return string.find(row:GetText():lower(), value:lower(), 1, true) ~= nil
end

vgui.Register('rubyphoneListView', PANEL, 'rubyphoneScrollPanel')
--PATH addons/mobile_phone/lua/autorun/client/cl_rubyphone_scrollpanel.lua:
local SCROLLBAR = {}

function SCROLLBAR:Init()
    self.parent = self:GetParent()
    self.scrollButton = vgui.Create('Panel', self)

    self.scrollButton.OnMousePressed = function(s, mb)
        if mb == MOUSE_LEFT and not self:GetParent().ShouldHideScrollbar then
            local _, my = s:CursorPos()
            s.scrolling = true
            s.mouseOffset = my
        end
    end

    self.scrollButton.OnMouseReleased = function(s, mb)
        if mb == MOUSE_LEFT then
            s.scrolling = false
            s.mouseOffset = nil
        end
    end

    self.height = 0
end

function SCROLLBAR:Think()
    if self.scrollButton.scrolling then
        if not input.IsMouseDown(MOUSE_LEFT) then
            self.scrollButton:OnMouseReleased(MOUSE_LEFT)

            return
        end

        local _, my = self.scrollButton:CursorPos()
        local diff = my - self.scrollButton.mouseOffset
        local maxOffset = self.parent:GetCanvas():GetTall() - self.parent:GetTall()
        local perc = (self.scrollButton.y + diff) / (self:GetTall() - self.height)
        self.parent.yOffset = math.Clamp(perc * maxOffset, 0, maxOffset)
        self.parent:InvalidateLayout()
    end
end

function SCROLLBAR:PerformLayout()
    local maxOffset = self.parent:GetCanvas():GetTall() - self.parent:GetTall()
    self:SetPos(self.parent:GetWide() - self:GetWide(), 0)
    self.heightRatio = self.parent:GetTall() / self.parent:GetCanvas():GetTall()
    self.height = math.Clamp(math.ceil(self.heightRatio * self.parent:GetTall()), 20, math.huge)
    self.scrollButton:SetSize(self:GetWide() - 4, self.height)
    self.scrollButton:SetPos((self:GetWide() - self.scrollButton:GetWide()) * 0.5, math.Clamp(self.parent.yOffset / maxOffset, 0, 1) * (self:GetTall() - self.height))
end

function SCROLLBAR:Paint(w, h)
    if self:GetParent().ShouldHideScrollbar then return end
    derma.SkinHook('Paint', 'UIScrollBar', self, w, h)
end

function SCROLLBAR:OnMouseWheeled(delta)
    self.parent:OnMouseWheeled(delta)
end

vgui.Register('rubyphoneScrollBaron', SCROLLBAR, 'Panel')
local SCROLLABLE = {}

function SCROLLABLE:Init()
    self.scrollBar = vgui.Create('rubyphoneScrollBaron', self)
    self.scrollBar:SetMouseInputEnabled(true)
    self.contentContainer = vgui.Create('Panel', self)
    self.contentContainer:SetMouseInputEnabled(true)
    self.yOffset = 0
    self.ySpeed = 0
    self.scrollSize = 4
    self.SpaceTop = 1
    self.Padding = 0
    self.scrollBar:Dock(RIGHT)
    self.scrollBar:SetWidth(12)

    function self.contentContainer.OnChildRemoved(s, child)
        self:PerformLayout()
    end
end

function SCROLLABLE:Reset()
    self:GetCanvas():Clear(true)
    self.yOffset = 0
    self.ySpeed = 0
    self.scrollSize = 1
    self:PerformLayout()
end

function SCROLLABLE:AddItem(child)
    child:SetParent(self:GetCanvas())
    self:PerformLayout()

    return child
end

function SCROLLABLE:SetSpacing(i)
    self.SpaceTop = i
end

function SCROLLABLE:SetPadding(i)
    self.Padding = i
end

function SCROLLABLE:GetCanvas()
    return self.contentContainer
end

function SCROLLABLE:SetScrollSize(int)
    self.scrollSize = int
end

function SCROLLABLE:ScrollTo(y)
    self.yOffset = y
    self:InvalidateLayout()
end

function SCROLLABLE:OnMouseWheeled(delta)
    if (delta > 0 and self.ySpeed < 0) or (delta < 0 and self.ySpeed > 0) then
        self.ySpeed = 0
    else
        self.ySpeed = self.ySpeed + (delta * self.scrollSize)
    end

    if system.IsOSX() then
        self.ySpeed = self.ySpeed * 0.1
    end

    self:PerformLayout()
end

function SCROLLABLE:SetOffset(offSet)
    local maxOffset = self:GetCanvas():GetTall() - self:GetTall()

    if maxOffset < 0 then
        maxOffset = 0
    end

    self.yOffset = math.Clamp(offSet, 0, maxOffset)
    self:PerformLayout()
    if self.yOffset == 0 or self.yOffset == maxOffset then return true end
end

function SCROLLABLE:Think()
    if self.ySpeed ~= 0 then
        if self:SetOffset(self.yOffset - self.ySpeed) then
            self.ySpeed = 0
        else
            if self.ySpeed < 0 then
                self.ySpeed = math.Clamp(self.ySpeed + (FrameTime() * self.scrollSize * 4), self.ySpeed, 0)
            else
                self.ySpeed = math.Clamp(self.ySpeed - (FrameTime() * self.scrollSize * 4), 0, self.ySpeed)
            end
        end
    end
end

function SCROLLABLE:PerformLayout()
    local canvas = self:GetCanvas()
    local y = 0
    local lastChild

    for k, v in ipairs(canvas:GetChildren()) do
        if (not v:IsVisible()) and self.HideInvisible then continue end
        local childY = y + (k > 1 and self.Padding or 0)

        if v.x ~= self.Padding or v.y ~= childY then
            v:SetPos(math.max(0, self.Padding), childY)
        end

        if v:GetWide() ~= canvas:GetWide() - self.Padding * 2 then
            v:SetWide(math.min(canvas:GetWide(), canvas:GetWide() - self.Padding * 2))
        end

        y = v.y + v:GetTall() + self.SpaceTop + self.Padding
        lastChild = v
    end

    y = lastChild and lastChild.y + lastChild:GetTall() or y

    if canvas:GetTall() ~= y then
        canvas:SetTall(y)
    end

    if (self.ShouldHideScrollbar or canvas:GetTall() <= self:GetTall()) and self.scrollBar:IsVisible() then
        canvas:SetTall(self:GetTall())
        self.scrollBar:SetVisible(false)
        self.scrollBar:SetWide(0)
    elseif (not self.ShouldHideScrollbar and canvas:GetTall() > self:GetTall()) and not self.scrollBar:IsVisible() then
        self.scrollBar:SetVisible(true)
        self.scrollBar:SetWide(12)
    end

    local maxOffset = self:GetCanvas():GetTall() - self:GetTall()

    if self.yOffset > maxOffset then
        self.yOffset = maxOffset
    end

    if self.yOffset < 0 then
        self.yOffset = 0
    end

    local canvasWidth = self:GetWide() - self.scrollBar:GetWide()

    if canvas:GetWide() ~= canvasWidth then
        canvas:SetWide(canvasWidth)
    end

    if canvas.x ~= 0 or canvas.y ~= -self.yOffset then
        canvas:SetPos(0, -self.yOffset)
        self.scrollBar:InvalidateLayout()
    end
end

function SCROLLABLE:IsAtMaxOffset()
    local maxOffset = math.Clamp(self:GetCanvas():GetTall() - self:GetTall(), 0, math.huge)

    return self.yOffset == maxOffset
end

function SCROLLABLE:Paint(w, h)
end

function SCROLLABLE:HideScrollbar(bool)
    self.ShouldHideScrollbar = bool
end

function SCROLLABLE:DockToFrame()
    local p = self:GetParent()
    local x, y = p:GetDockPos()
    self:SetPos(x, y)
    self:SetSize(p:GetWide() - 10, p:GetTall() - (y + 5))
end

vgui.Register('rubyphoneScrollPanel', SCROLLABLE, 'Panel')
--PATH addons/__main/lua/drugs_effects/savav_watermelon.lua:
local mat_fb = Material( "pp/fb" )
local WMmat = Material( "Melon_screen" )
local DRUG = "savav_watermelon"

hook.Add( "PostDrawSkyBox", "PostDrawSkyBoxDGUG_savav_watermelon", function()
	if LocalPlayer().ALPHA1 != nil then 
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then
	render.SetMaterial( WMmat )
	--render.DrawScreenQuad()
	render.DrawQuadEasy(LocalPlayer():EyePos()+Vector(0,0,100), Vector( -1, 0, -90 ), 2920, 2080, Color(255,255,255,LocalPlayer().ALPHA1), 0 )
end
end
	end
end)


hook.Add( "PostDrawOpaqueRenderables", "PostDrawOpaqueRenderablesDRUG_savav_watermelon", function()
	if LocalPlayer().ALPHA1 != nil then 
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then

for i=1, 100 do
	if LocalPlayer().WaterMdodel[i] == nil then
		LocalPlayer().WaterMdodel[i] = ClientsideModel( "models/props_junk/watermelon01.mdl" )
		LocalPlayer().WaterMdodel[i]:SetRenderMode( RENDERMODE_TRANSALPHA ) 
		LocalPlayer().WaterMdodel[i]:SetPos(LocalPlayer():GetPos()+Vector(0,0,100))
		LocalPlayer().WaterMdodel[i]:DrawModel()
	end
	
	if LocalPlayer().WaterMdodel[i]:GetPos().z > LocalPlayer():GetPos().z-50 then
		LocalPlayer().WaterMdodel[i]:SetPos(LocalPlayer().WaterMdodel[i]:GetPos()+Vector(0,0,-1.5))
	else
		LocalPlayer().WaterMdodel[i]:SetPos(LocalPlayer():GetPos()+Vector(math.random(-1000,1000),math.random(-1000,1000),math.random(400,700)))
	end
	
	LocalPlayer().WaterMdodel[i]:SetColor( Color( 255, 255, 255, LocalPlayer().ALPHA1 ) )
	
end
	
	end

end
	end
end)


hook.Add( "RenderScreenspaceEffects", "DrugsREcts_savav_watermelon", function()
	if LocalPlayer().ALPHA1 != nil then 
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then
	DrawColorModify( 
{
	[ "$pp_colour_addr" ] = 0,
	[ "$pp_colour_addg" ] = 0,
	[ "$pp_colour_addb" ] = 0,
	[ "$pp_colour_brightness" ] = 0-LocalPlayer().ALPHA1/590,
	[ "$pp_colour_contrast" ] = 1+LocalPlayer().ALPHA1/590,
	[ "$pp_colour_colour" ] = 1+LocalPlayer().ALPHA1/80,
	[ "$pp_colour_mulr" ] = 0,
	[ "$pp_colour_mulg" ] = 0,
	[ "$pp_colour_mulb" ] = 0
}

	)
end
end
	end

end )


local function MyCalcView( ply, pos, angles, fov )
	if LocalPlayer().ALPHA1 != nil then 
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then
		local view = {}
		
		view.origin = pos+angles:Forward()*LocalPlayer().ALPHA1/7
		view.angles = angles+Angle(0,math.cos(CurTime())*LocalPlayer().ALPHA1/120,0)
		view.fov = fov + LocalPlayer().ALPHA1/3.6
		view.drawviewer = false

		return view
	end
end
	end
end

hook.Add( "CalcView", "CalcViewDrugsRect_savav_watermelon", MyCalcView )

hook.Add( "HUDPaint", "DrugsREct_savav_watermelon", function()

if LocalPlayer().ALPHA1 != nil then
if LocalPlayer().Active == 0 then
if LocalPlayer().ALPHA1 > 0 then LocalPlayer().ALPHA1 = LocalPlayer().ALPHA1 - 0.05 end
if LocalPlayer().ALPHA2 > 0 then LocalPlayer().ALPHA2 = LocalPlayer().ALPHA2 - 0.05 end
end

	if LocalPlayer().DrugType == DRUG then
	if LocalPlayer().Active == 1 then
		if LocalPlayer().ALPHA1 < 255 then LocalPlayer().ALPHA1 = LocalPlayer().ALPHA1 + 0.05 end
	if !LocalPlayer():Alive() then
	LocalPlayer().MUSIC:ChangePitch( 0, 60 )
	LocalPlayer().MUSIC:ChangeVolume( 0, 100 )
	LocalPlayer().Active = 0
	end
	end


		surface.SetDrawColor( math.sin(CurTime())*255, 255, math.sin(CurTime())*255, ( LocalPlayer().ALPHA1/35 ) )
		surface.DrawRect( 0, 0, ScrW(), ScrH() )
		
		if LocalPlayer().ALPHA1 <= 0 then

			LocalPlayer().DrugType = "0"
				LocalPlayer().MUSIC:Stop()
			
		end

	end
end
end )


local function DrugEffect_savav_watermelon(data)


if LocalPlayer().Active == 0 or LocalPlayer().Active == nil then
LocalPlayer().DrugType = data:ReadString()
LocalPlayer().Active = 1
LocalPlayer().ALPHA1 = 0
LocalPlayer().ALPHA2 = 0

LocalPlayer().MUSIC = CreateSound( LocalPlayer(), "awoo.wav" )

LocalPlayer().MUSIC:Play()
LocalPlayer().MUSIC:ChangePitch( 0, 0 )
LocalPlayer().MUSIC:ChangeVolume( 0, 0 )
LocalPlayer().MUSIC:ChangePitch( 100, 9 )
LocalPlayer().MUSIC:ChangeVolume( 1, 6 )
LocalPlayer().WaterMdodel = {}
timer.Simple(60,function()

LocalPlayer().MUSIC:ChangePitch( 0, 60 )
LocalPlayer().MUSIC:ChangeVolume( 0, 100 )
LocalPlayer().Active = 0


end)
end


end


local function DrugEffect_WATER(data)
LocalPlayer().Active = 0
end

usermessage.Hook("DrugEffect_WATER", DrugEffect_WATER ) 
usermessage.Hook("DrugEffect_savav_watermelon", DrugEffect_savav_watermelon ) 
 
--PATH addons/__main/lua/drugs_effects/savav_lcd.lua:
local mat_fb = Material( "pp/fb" )
local RICARDO = Material( "ricardo" )
local DRUG = "savav_LCD"
--inQuad( delta, ScrH(), -ScrH() )


hook.Add( "PostPlayerDraw" , "manual_model_draw_example" , function( ply )
	if LocalPlayer().ALPHA1 != nil then 
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then
	if not IsValid( ply ) or not ply:Alive() then return end

	local POS = ply:GetBonePosition( ply:LookupBone( "ValveBiped.Bip01_Head1" ) )

	render.SetMaterial( RICARDO )
	render.DrawQuadEasy( POS-EyeAngles():Forward()*5, (EyeAngles()+Angle(-90,0,0)):Up(), 20, 20, Color( 255, 255, 255,LocalPlayer().ALPHA1 ), 180 )
end
end
	end
	
end )

hook.Add( "RenderScreenspaceEffects", "DrugsREcts", function()

	if LocalPlayer().ALPHA1 != nil then 
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then
	DrawColorModify( 

{
	[ "$pp_colour_addr" ] = 0,
	[ "$pp_colour_addg" ] = 0,
	[ "$pp_colour_addb" ] = 0,
	[ "$pp_colour_brightness" ] = -LocalPlayer().ALPHA1/500,
	[ "$pp_colour_contrast" ] = 1+LocalPlayer().ALPHA1/500,
	[ "$pp_colour_colour" ] = 1+LocalPlayer().ALPHA1/250,
	[ "$pp_colour_mulr" ] = 0,
	[ "$pp_colour_mulg" ] = 0,
	[ "$pp_colour_mulb" ] = 0
}

	)
end
end
	end

end )

--[[
hook.Add( "Think", "ThinkDrugsREct_savav_beer", function()
	if LocalPlayer().ALPHA1 != nil then  
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then
		
		if math.random(0,600) == 1 then

				LocalPlayer():ConCommand( "+jump" )
				
		elseif math.random(0,200) == 2 then	
		LocalPlayer():ConCommand( "+forward" )
			timer.Simple(0.1,function()
				LocalPlayer():ConCommand( "-forward" )
			end)
		elseif math.random(0,600) == 2 then
				LocalPlayer():SetEyeAngles(LocalPlayer():EyeAngles()+Angle(0,math.random(-90,90),0))
		else
				LocalPlayer():ConCommand( "-jump" )
				
		end
		
	end
end
	end
end)
-]]

local LERPANGL = Angle()

local function MyCalcView( ply, pos, angles, fov )
	if LocalPlayer().ALPHA1 != nil then 
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then
		local view = {}
		
local blah = WorldToLocal( ply:GetVelocity(), Angle(0,0,0) , Vector(0,0,0), Angle(0,ply:EyeAngles().yaw,0) ) 
LERPANGL = LerpAngle(LocalPlayer().ALPHA1/258,angles,LERPANGL)
		view.origin = ( pos+ply:GetVelocity()/80 ) + angles:Forward()*LocalPlayer().ALPHA1/12
		view.angles = LERPANGL+Angle(((blah.x/4550)*LocalPlayer().ALPHA1),((blah.y/2550)*LocalPlayer().ALPHA1),((blah.y/2550)*LocalPlayer().ALPHA1)+math.cos(CurTime())*LocalPlayer().ALPHA1/10)
		view.fov = fov + LocalPlayer().ALPHA1/3.7
		view.drawviewer = false

		return view
	end
end
	end
end

hook.Add( "CalcView", "CalcViewDrugsRect_savav_LCD", MyCalcView )

hook.Add( "HUDPaint", "DrugsREct_savav_LCD", function()
if LocalPlayer().ALPHA1 != nil then
if LocalPlayer().Active == 0 then
if LocalPlayer().ALPHA1 > 0 then LocalPlayer().ALPHA1 = LocalPlayer().ALPHA1 - 0.05 end
if LocalPlayer().ALPHA2 > 0 then LocalPlayer().ALPHA2 = LocalPlayer().ALPHA2 - 0.05 end
end

if LocalPlayer().ALPHA1 != nil then
	if LocalPlayer().DrugType == DRUG then
	if LocalPlayer().Active == 1 then
		if LocalPlayer().ALPHA1 < 255 then LocalPlayer().ALPHA1 = LocalPlayer().ALPHA1 + 0.05 end
	if !LocalPlayer():Alive() then
	LocalPlayer().MUSIC:ChangePitch( 0, 60 )
	LocalPlayer().MUSIC:ChangeVolume( 0, 100 )
	LocalPlayer().Active = 0
	end
	end
 
LocalPlayer():SetEyeAngles(LocalPlayer():EyeAngles()+Angle((math.cos(CurTime())/2550)*LocalPlayer().ALPHA1,(math.sin(CurTime()*2)/2550)*LocalPlayer().ALPHA1,0))

	for i=1,30 do

	local Cos = math.cos(i*0.5) * LocalPlayer().ALPHA1
	local Sin = math.sin(i*0.5) * LocalPlayer().ALPHA1
	local Sinonius = math.cos(CurTime())* LocalPlayer().ALPHA1/10
	local Cosonius = math.sin(CurTime())* LocalPlayer().ALPHA1/10

		surface.SetDrawColor( 255, 255, 255, ( LocalPlayer().ALPHA1/22 ))
		surface.SetMaterial( mat_fb	) 
		surface.DrawTexturedRect( Cos-Cosonius, (Sin-Sinonius), ScrW(), ScrH() )
	end

		surface.SetDrawColor(255, 0, 255, LocalPlayer().ALPHA1/30 )
		surface.DrawRect( 0, 0, ScrW(), ScrH() )

		if LocalPlayer().ALPHA1 <= 0 then

			LocalPlayer().DrugType = "0"
				LocalPlayer().MUSIC:Stop()
			
		end
end

	end
end
end )


local function DrugEffect_savav_LCD(data)



if LocalPlayer().Active == 0 or LocalPlayer().Active == nil then
LocalPlayer().DrugType = data:ReadString()
LocalPlayer().Active = 1
LocalPlayer().ALPHA1 = 0
LocalPlayer().ALPHA2 = 0


LocalPlayer().MUSIC = CreateSound( LocalPlayer(), "U Got That.wav" )

LocalPlayer().MUSIC:Play()
LocalPlayer().MUSIC:ChangePitch( 0, 0 )
LocalPlayer().MUSIC:ChangeVolume( 0, 0 )
LocalPlayer().MUSIC:ChangePitch( 100, 25 )
LocalPlayer().MUSIC:ChangeVolume( 0.4, 6 )

timer.Simple(110,function()

LocalPlayer().MUSIC:ChangePitch( 0, 10 )
LocalPlayer().MUSIC:ChangeVolume( 0, 19 )
LocalPlayer().Active = 0


end)

end

end


local function DrugEffect_WATER(data)
LocalPlayer().Active = 0
end

usermessage.Hook("DrugEffect_WATER", DrugEffect_WATER ) 
usermessage.Hook("DrugEffect_savav_LCD", DrugEffect_savav_LCD ) 
 
--PATH addons/unbox/lua/unbox_config_2.lua:
if SERVER then
	AddCSLuaFile()
	AddCSLuaFile("uc2_subconfig.lua")
end

include("uc2_subconfig.lua")
BUC2.GivePermaWeaponsOnSpawn = true
BUC2.AnnounceUnboxings = true
BUC2.CanTradePermaWeapons = false
BUC2.BuyItemsWithPoints = false
BUC2.BuyItemsWithPoints2 = false

BUC2.RanksThatCanGiveItems = {"superadmin"}

BUC2.ShouldDropCratesAndKeys = false
BUC2.DropTimer = 25
BUC2.DropsAreRankLimited = true
BUC2.DropRankList = {}
local hats = {
	list = {},
	mappings = {}
}

local c = 0

function hats.Add(data)
	c = c + 1
	data.model = string.lower(data.model or "")
	data.model = string.Replace(data.model, "\\", "/")
	data.model = string.gsub(data.model, "[\\/]+", "/")

	if CLIENT then
		util.PrecacheModel(data.model)
	end

	hats.list[data.model] = {
		name = data.name or 'unkown',
		model = data.model,
		price = data.price,
		scale = data.scale or 1,
		offpos = data.offpos or Vector(0, 0, 0),
		offang = data.offang or Angle(0, 0, 0),
		ID = c
	}

	hats.mappings[c] = data.model
end

hats.Add{
	name = 'Лютий Кодьяк',
	price = 75000,
	model = 'models/sal/bear.mdl',
	offpos = Vector(0, 0, 2),
	offang = Angle(2, 0, 0),
	scale = 1.0
}

hats.Add{
	name = 'Котяча краса',
	price = 65000,
	model = 'models/sal/cat.mdl',
	offpos = Vector(0, 0, 2),
	offang = Angle(2, 0, 0),
	scale = 1.0
}

hats.Add{
	name = 'Люта Лиса',
	price = 80000,
	model = 'models/sal/fox.mdl',
	offpos = Vector(0, 0, 2),
	offang = Angle(2, 0, 0),
	scale = 1.1
}

hats.Add{
	name = 'Печенюшка',
	price = 60000,
	model = 'models/sal/gingerbread.mdl',
	offpos = Vector(0.5, 0, 2),
	offang = Angle(0, 6, 0),
	scale = 1.0
}

hats.Add{
	name = 'Орел (Білий)',
	price = 65000,
	model = 'models/sal/hawk_1.mdl',
	offpos = Vector(1, 0, 0),
	offang = Angle(0, 0, 0),
	scale = 1.1
}

hats.Add{
	name = 'Орел (Коричневий)',
	price = 65000,
	model = 'models/sal/hawk_2.mdl',
	offpos = Vector(1, 0, 0),
	offang = Angle(0, 0, 0),
	scale = 1.1
}

hats.Add{
	name = 'Філіпін',
	price = 75000,
	model = 'models/sal/owl.mdl',
	offpos = Vector(0, 0, 0),
	offang = Angle(2, 3, 0),
	scale = 1.1
}

hats.Add{
	name = 'Інтелектуальний пінгвін',
	price = 850000,
	model = 'models/sal/penguin.mdl',
	offpos = Vector(1, 0, 2),
	offang = Angle(2, 15, 0),
	scale = 1.1,
	infooffset = 15
}

hats.Add{
	name = 'Міська свиня',
	price = 70000,
	model = 'models/sal/pig.mdl',
	offpos = Vector(0, 0, 1),
	offang = Angle(4, 0, 0),
	scale = 1.1
}

hats.Add{
	name = 'Швидкий вовк',
	price = 80000,
	model = 'models/sal/wolf.mdl',
	offpos = Vector(0, 0, 1),
	offang = Angle(4, 0, 0),
	scale = 1.1
}

hats.Add{
	name = 'Перший завжди',
	price = 70000,
	model = 'models/sal/acc/fix/beerhat.mdl',
	offpos = Vector(0, -0.3, 3.5),
	offang = Angle(2, 5, 0),
	scale = 1.0
}

hats.Add{
	name = 'Смертельна маска (Блакитна)',
	price = 65000,
	model = 'models/sal/acc/fix/mask_2.mdl',
	offpos = Vector(1.0, 0, 0.5),
	offang = Angle(5, 15, 0),
	scale = 1.0
}

hats.Add{
	name = 'Смертельна маска (Сіра)',
	price = 65000,
	model = 'models/sal/acc/fix/mask_4.mdl',
	offpos = Vector(1.0, 0, 0),
	offang = Angle(5, 15, 0),
	scale = 1.0
}

hats.Add{
	name = 'Шарф (Білий)',
	price = 50000,
	model = 'models/sal/acc/fix/scarf01.mdl',
	offpos = Vector(1.0, 0, -25),
	offang = Angle(5, 15, 0),
	scale = 1.0
}

hats.Add{
	name = 'Сумка з Н-Атомом',
	price = 50000,
	model = 'models/sal/halloween/bag.mdl',
	offpos = Vector(1, 0, 1.5),
	offang = Angle(0, 0, 0),
	scale = 1.0
}

hats.Add{
	name = 'Лікар',
	price = 50000,
	model = 'models/sal/halloween/doctor.mdl',
	offpos = Vector(-0.5, -0.3, 1.25),
	offang = Angle(0, 0, 0),
	scale = 1.0
}

hats.Add{
	name = 'Обгортка',
	price = 65000,
	model = 'models/sal/halloween/headwrap1.mdl',
	offpos = Vector(1, 0, 1),
	offang = Angle(5, 0, 0),
	scale = 1.0
}

hats.Add{
	name = 'Обруч (Сірий)',
	price = 50000,
	model = 'models/sal/halloween/headwrap2.mdl',
	offpos = Vector(1, 0, 1),
	offang = Angle(5, 0, 0),
	scale = 1.0
}

hats.Add{
	name = 'Маска мавпи',
	price = 75000,
	model = 'models/sal/halloween/monkey.mdl',
	offpos = Vector(0.7, 0, 1.3),
	offang = Angle(3.5, 5, 0),
	scale = 1.0
}

hats.Add{
	name = 'Ніньзяго',
	price = 65000,
	model = 'models/sal/halloween/ninja.mdl',
	offpos = Vector(0, -0.5, 2),
	offang = Angle(0, 0, 0),
	scale = 1.1
}

hats.Add{
	name = 'Череп (Сірий)',
	price = 60000,
	model = 'models/sal/halloween/skull.mdl',
	offpos = Vector(0, -0.3, 2.6),
	offang = Angle(0, 0, 0),
	scale = 1.1
}

hats.Add{
	name = 'Маска монстра',
	price = 75000,
	model = 'models/sal/halloween/zombie.mdl',
	offpos = Vector(0.5, -0.3, 2.0),
	offang = Angle(0, 0, 0),
	scale = 1.1
}

hats.Add{
	name = 'Бандана бандита',
	price = 50000,
	model = 'models/modified/bandana.mdl',
	offpos = Vector(0.5, -0.3, -0.5),
	offang = Angle(0, 0, 0),
	scale = 1.1
}

hats.Add{
	name = 'Окуляри батаніка',
	price = 50000,
	model = 'models/modified/glasses01.mdl',
	offpos = Vector(0, -0.35, 3.5),
	offang = Angle(2, 0, 0),
	scale = 1.0
}

hats.Add{
	name = 'Окуляри хіпстера',
	price = 50000,
	model = 'models/modified/glasses02.mdl',
	offpos = Vector(0, -0.35, 3.5),
	offang = Angle(2, 0, 0),
	scale = 1.0
}

hats.Add{
	name = 'Шапка (Сіра)',
	price = 50000,
	model = 'models/modified/hat01_fix.mdl',
	offpos = Vector(0.5, -0.25, 4.5),
	offang = Angle(2, 8, 0),
	scale = 1.0
}

hats.Add{
	name = 'Відвисла шапка (Червона)',
	price = 50000,
	model = 'models/modified/hat03.mdl',
	offpos = Vector(0.5, -0.25, 4.5),
	offang = Angle(2, 8, 0),
	scale = 1.0
}

hats.Add{
	name = 'Шапка (Чорна)',
	price = 50000,
	model = 'models/modified/hat04.mdl',
	offpos = Vector(0, -0.5, 4.5),
	offang = Angle(2, 18, 0),
	scale = 1.0
}

hats.Add{
	name = 'Таксистка кепка',
	price = 50000,
	model = 'models/modified/hat06.mdl',
	offpos = Vector(1.5, 0, 4.5),
	offang = Angle(5, 18, 0),
	scale = 1.0
}

hats.Add{
	name = 'Ковпачок',
	price = 50000,
	model = 'models/modified/hat07.mdl',
	offpos = Vector(1.5, -0.3, 4.5),
	offang = Angle(2, 18, 0),
	scale = 1.0
}

hats.Add{
	name = 'Кепка',
	price = 50000,
	model = 'models/modified/hat08.mdl',
	offpos = Vector(1.0, -0.3, 4.5),
	offang = Angle(2, 12, 0),
	scale = 1.0
}

hats.Add{
	name = 'Навушники (Червоні)',
	price = 50000,
	model = 'models/modified/headphones.mdl',
	offpos = Vector(1.0, 0, 2.2),
	offang = Angle(2, 12, 0),
	scale = 1.0
}

hats.Add{
	name = 'Маска лютого вбивці',
	price = 65000,
	model = 'models/modified/mask5.mdl',
	offpos = Vector(1.0, 0, 0),
	offang = Angle(2, 12, 0),
	scale = 1.0
}

hats.Add{
	name = 'Маска невідомої',
	price = 65000,
	model = 'models/modified/mask6.mdl',
	offpos = Vector(1.0, 0, 0),
	offang = Angle(2, 12, 0),
	scale = 1.0
}

local Discount = 23
Discount = 1 - Discount / 100
--bu_addCrate(1, "Кейс шапок", "Кейс шапок", color_white, true, true, 25, nil, 'unbox/hatscase.png')
local i = 2
local cost = 0

for k, v in SortedPairsByMemberValue(hats.list, 'price', false) do
	cost = cost + 1 * 100
	local cacal = Color(75, 105, 255)

	if v.price > 64000 then
		cacal = Color(136, 71, 255)
	end

	if v.price > 65000 then
		cacal = Color(211, 44, 230)
	end

	if v.price > 75000 then
		cacal = Color(235, 75, 75)
	end

	if v.price > 95001 then
		cacal = Color(255, 215, 0)
	end

	--bu_addMoney(i, v['name'], v['model'], 'hat_' .. cost, cacal, "Кейс шапок", math.random(10, 100))
	i = i + 1
end

bu_addCrate(i, "Кейс с Оружием", "Кейс зі Зброєю", color_white, true, true, 289 + 10, nil, 'unbox/weaponcase.png')
i = i + 1
bu_addMoney(i, "Glock 18", "models/weapons/w_dmg_glock.mdl", "m9k_glock", Color(75, 105, 255), "Кейс с Оружием", 2)
i = i + 1
bu_addMoney(i, "USAS", "models/weapons/w_usas_12.mdl", "m9k_usas", Color(136, 71, 255), "Кейс с Оружием", 20)
i = i + 1
bu_addMoney(i, "JackHammer", "models/weapons/w_pancor_jackhammer.mdl", "m9k_jackhammer", Color(136, 71, 255), "Кейс с Оружием", 20)
i = i + 1
bu_addMoney(i, "Ніндзя Кунай", "models/weapons/maranzosabilitysweps/w_mas_ninjakunai.mdl", "weapon_ninjaskunai", Color(211, 44, 230), "Кейс с Оружием", 15)
i = i + 1
bu_addMoney(i, "Double Barrel", "models/weapons/w_double_barrel_shotgun.mdl", "m9k_dbarrel", Color(211, 44, 230), "Кейс с Оружием", 13)
i = i + 1
bu_addMoney(i, "Набір вбивці", "models/aot/3dgear.mdl", "3dgear", Color(211, 44, 230), "Кейс с Оружием", 10)
i = i + 1
bu_addMoney(i, "Dragunov", "models/weapons/w_svd_dragunov.mdl", "m9k_dragunov", Color(211, 44, 230), "Кейс с Оружием", 10)
i = i + 1
bu_addMoney(i, "Barret M82", "models/weapons/w_barret_m82.mdl", "m9k_barret_m82", Color(211, 44, 230), "Кейс с Оружием", 5)
i = i + 1
bu_addMoney(i, "Міна", "models/weapons/w_slam.mdl", "weapon_slam", Color(211, 44, 230), "Кейс с Оружием", 4)
i = i + 1
bu_addMoney(i, "MiniGun", "models/weapons/w_m134_minigun.mdl", "m9k_minigun", Color(235, 75, 75), "Кейс с Оружием", 1)
i = i + 1
--------
bu_addCrate(i, "Кейс Богач", "Кейс Богач", color_white, true, true, 410 + 10, nil, 'unbox/bogcase.png')
i = i + 1
bu_addMoney(i, "Набір вбивці", "models/aot/3dgear.mdl", "3dgear", Color(211, 44, 230), "Кейс Богач", 5)
i = i + 1
bu_addMoney(i, "Dragunov", "models/weapons/w_svd_dragunov.mdl", "m9k_dragunov", Color(211, 44, 230), "Кейс Богач", 10)
i = i + 1
bu_addMoney(i, "Barret M82", "models/weapons/w_barret_m82.mdl", "m9k_barret_m82", Color(211, 44, 230), "Кейс Богач", 15)
i = i + 1
bu_addMoney(i, "Міна", "models/weapons/w_slam.mdl", "weapon_slam", Color(211, 44, 230), "Кейс Богач", 25)
i = i + 1
bu_addMoney(i, "Граната", "models/Items/grenadeAmmo.mdl", "weapon_frag", Color(211, 44, 230), "Кейс Богач", 25)
i = i + 1
bu_addMoney(i, "Головний Адміністратор", "ukrainerp/logo.png", "sadmin", Color(235, 75, 75), "Кейс Богач", 13)
i = i + 1
bu_addMoney(i, "MiniGun", "models/weapons/w_m134_minigun.mdl", "m9k_minigun", Color(235, 75, 75), "Кейс Богач", 7)
i = i + 1
--------
bu_addCrate(i, "Кейс Бомж", "Кейс Бомж", color_white, true, true, 75 + 10, nil, 'unbox/bomjcase.png')
i = i + 1
bu_addMoney(i, "Відмичка", "models/weapons/w_crowbar.mdl", "lockpick", Color(75, 105, 255), "Кейс Бомж", 5)
i = i + 1
bu_addMoney(i, "300.000 $", "ukrainerp/logo.png", "money_300mi", Color(75, 105, 255), "Кейс Бомж", 7)
i = i + 1
bu_addMoney(i, "P08 Luger", "models/weapons/w_luger_p08.mdl", "m9k_luger", Color(75, 105, 255), "Кейс Бомж", 10)
i = i + 1
bu_addMoney(i, "VIP - 30 Днів", "ukrainerp/logo.png", "vip3", Color(75, 105, 255), "Кейс Бомж", 10)
i = i + 1
bu_addMoney(i, "Аптечка", "ukrainerp/logo.png", "apteka", Color(75, 105, 255), "Кейс Бомж", 10)
i = i + 1
bu_addMoney(i, "Glock 18", "models/weapons/w_dmg_glock.mdl", "m9k_glock", Color(75, 105, 255), "Кейс Бомж", 10)
i = i + 1
bu_addMoney(i, "VIP", "ukrainerp/logo.png", "vip", Color(75, 105, 255), "Кейс Бомж", 40)
i = i + 1
bu_addMoney(i, "JackHammer", "models/weapons/w_pancor_jackhammer.mdl", "m9k_jackhammer", Color(136, 71, 255), "Кейс Бомж", 5)
i = i + 1
bu_addMoney(i, "Double Barrel", "models/weapons/w_double_barrel_shotgun.mdl", "m9k_dbarrel", Color(211, 44, 230), "Кейс Бомж", 3)
i = i + 1
--------
bu_addCrate(i, "Кейс с Привилегиями", "Кейс з Привілеями", color_white, true, true, 250 + 10, nil, 'unbox/usergroupcase.png')
i = i + 1
bu_addMoney(i, "VIP - 30 Днів", "ukrainerp/logo.png", "vip3", Color(75, 105, 255), "Кейс с Привилегиями", 15)
i = i + 1
bu_addMoney(i, "VIP", "ukrainerp/logo.png", "vip", Color(75, 105, 255), "Кейс с Привилегиями", 20)
i = i + 1
bu_addMoney(i, "Адміністратор - 30 Днів", "ukrainerp/logo.png", "admin3", Color(211, 44, 230), "Кейс с Привилегиями", 30)
i = i + 1
bu_addMoney(i, "Адміністратор", "ukrainerp/logo.png", "admin", Color(211, 44, 230), "Кейс с Привилегиями", 20)
i = i + 1
bu_addMoney(i, "Головний Адміністратор - 30 Днів", "ukrainerp/logo.png", "sadmin3", Color(235, 75, 75), "Кейс с Привилегиями", 10)
i = i + 1
bu_addMoney(i, "Головний Адміністратор", "ukrainerp/logo.png", "sadmin", Color(235, 75, 75), "Кейс с Привилегиями", 5)
i = i + 1
--------
bu_addCrate(i, "Лотерейный Кейс", "Лотерейний Кейс", color_white, true, true, 50 + 10, nil, 'unbox/lot.png')
i = i + 1
bu_addMoney(i, "0 грн", "ukrainerp/logo.png", "0grn", Color(75, 105, 255), "Лотерейный Кейс", 35, true, 0)
i = i + 1
bu_addMoney(i, "25 грн", "ukrainerp/logo.png", "25grn", Color(75, 105, 255), "Лотерейный Кейс", 25, true, 25)
i = i + 1
bu_addMoney(i, "50 грн", "ukrainerp/logo.png", "50grn", Color(136, 71, 255), "Лотерейный Кейс", 18, true, 50)
i = i + 1
bu_addMoney(i, "100 грн", "ukrainerp/logo.png", "100grn", Color(211, 44, 230), "Лотерейный Кейс", 14, true, 100)
i = i + 1
bu_addMoney(i, "250 грн", "ukrainerp/logo.png", "250grn", Color(211, 44, 230), "Лотерейный Кейс", 5, true, 250)
i = i + 1
bu_addMoney(i, "500 грн", "ukrainerp/logo.png", "500grn", Color(211, 44, 230), "Лотерейный Кейс", 2, true, 500)
i = i + 1
bu_addMoney(i, "1000 грн", "ukrainerp/logo.png", "1000grn", Color(235, 75, 75), "Лотерейный Кейс", 1, true, 1000)
i = i + 1
bu_addCrate(i, "Кейс с Оружием #2", "Кейс зі Зброєю#2", color_white, true, false, -1, nil, 'unbox/weaponcase.png')
i = i + 1
bu_addMoney(i, "Stunstick", "models/weapons/w_stunbaton.mdl", "wep_stunstick", Color(75, 105, 255), "Кейс с Оружием #2", 15)
i = i + 1
bu_addMoney(i, "Mauser M1896 | Royal Dragon", "models/weapons/w_royl_p228.mdl", "mauserdragon", Color(75, 105, 255), "Кейс с Оружием #2", 15)
i = i + 1
bu_addMoney(i, "SG552", "models/weapons/w_rif_sg552.mdl", "wep_arbalet", Color(75, 105, 255), "Кейс с Оружием #2", 10)
i = i + 1
bu_addMoney(i, "Пистолет Deagle", "models/weapons/w_pist_deagle.mdl", "wep_deagle", Color(75, 105, 255), "Кейс с Оружием #2", 15)
i = i + 1
bu_addMoney(i, "Снайперская винтовка Scout", "models/weapons/w_snip_scout.mdl", "wep_scout", Color(136, 71, 255), "Кейс с Оружием #2", 9)
i = i + 1
bu_addMoney(i, "Пистолет Пулемет TMP", "models/weapons/w_smg_tmp.mdl", "wep_tmp", Color(136, 71, 255), "Кейс с Оружием #2", 9)
i = i + 1
bu_addMoney(i, "AK-47 gold", "models/weapons/w_rif_ak47_gold.mdl", "weapon_shitty_gold_akkk", Color(136, 71, 255), "Кейс с Оружием #2", 8)
i = i + 1
bu_addMoney(i, "Скорострельный дробовик", "models/weapons/w_shot_xm1014.mdl", "wep_drobovik", Color(211, 44, 230), "Кейс с Оружием #2", 7)
i = i + 1
bu_addMoney(i, "C4", "models/weapons/w_c4.mdl", "weapon_c4", Color(211, 44, 230), "Кейс с Оружием #2", 6)
i = i + 1
bu_addMoney(i, "Smartpistol из Titanfall", "models/weapons/p2011sp/w_p2011sp.mdl", "smartpistol", Color(235, 75, 75), "Кейс с Оружием #2", 4)
i = i + 1
bu_addMoney(i, "Cyber Пушка", "models/weapons/w_pistol.mdl", "cyberitem", Color(235, 75, 75), "Кейс с Оружием #2", 4)
i = i + 1
bu_addMoney(i, "RPG", "models/weapons/w_rocket_launcher.mdl", "ree_rpgsuka", Color(235, 75, 75), "Кейс с Оружием #2", 2)
i = i + 1
bu_addMoney(i, "LongRevolver(Ковбойка 1337)", "models/weapons/w_357.mdl", "weapon_cowboy", Color(181, 158, 36), "Кейс с Оружием #2", 1)
--print("[UNBOXING INFO] UNBOXING CONFIG LOADED!")

--[[if CLIENT then
	file.CreateDir("ua_unbox")
	-- Custom case icons;
	BUC2.CustomCrateIcons = {}

	for k, v in next, BUC2.CustomCrateIcons do
		BUC2.CustomCrateIcons[k] = nil

		http.Fetch(v[1], function(data)
			file.Write(v[2], data)
			BUC2.CustomCrateIcons[k] = Material("data/" .. v[2])
			BUC2.CustomCrateIcons[k]:GetTexture("$basetexture"):Download()
		end)
	end
end]]

-- Config for "upgrade" page:				Конфиг для "Апгрейд" вкладки:
-- Warning!! Use only IGS-item ids.			Внимание!! Используйте только IGS-ид предметов
local function getAllWeapons()
	local result = {}

	for k, v in pairs(BUC2.ITEMS) do
		if not v.amount then continue end
		result[v.amount] = true
	end

	return result
end

BUC2.UpgradeToItems = getAllWeapons()
BUC2.UpgradeFromItems = getAllWeapons()
--[[ 
-- "Upgrade to" items;					"Улучшить на" предметы
BUC2.UpgradeToItems = {
	[ "wep_kamera" ] = true,
	[ "weapon_medkitt" ] = true,
	[ "weapon_medkitt" ] = true,
}

-- Allowed items to upgrade 			Разрешенные оружия для улучшения
-- ("Upgrade from" items)				("Улучшить с" предметы)
BUC2.UpgradeFromItems = {
	[ "weapon_medkitt" ] = true,
	[ "wep_m9k_luger" ] = true,
	[ "wep_m9k_glock" ] = true,
}--]]

local tbl = {
	{"0grn", 1},
	{"25grn", 25},
	{"50grn", 50},
	{"100grn", 100},
	{"250grn", 250},
	{"500grn", 500},
	{"1000grn", 1000}
}

for r, u in pairs(tbl) do
	IGS('ХХХХХХХХХХХХХ', u[1]) -- второй параметр не должен(!) повторяться с другими предметами
		:SetPrice(u[2]) -- 1 рубль
		:SetPerma()
		:SetDescription("") -- описание
		:SetCategory('ХХХХХХХХХХХХХ')
		:SetHidden(true)
		:SetIcon("ukrainerp/logo.png")
end
--PATH addons/unbox/lua/uc2_subconfig.lua:
--DO NOT EDIT THIS!
--DO NOT EDIT THIS!

BUC2 = BUC2 or {}
BUC2.ITEMS = {} 
BUC2.ItemToID = {}
BUC2.IDToItem = {}  
BUC2.UpgradeToItems = {}
BUC2.UpgradeFromItems = {}
BUC2.History = BUC2.History or {}

function bu_addCrate(id, name1 , name2 , c , candrop , canBuy , price, discountedFrom, customicon)
	BUC2.ItemToID[name1] = id 
	BUC2.IDToItem[id] = name1
	BUC2.ITEMS[name1] = {
		items = {},
		color = c,
		canDrop = candrop,
		name1 = name1,
		name2 = name2,
		itemType = "Crate",
		canBuy = canBuy, 
		price = price,
		discountedFrom = discountedFrom or (price * 2),
		customicon = customicon or nil
	}
end

function bu_addWeapon(id, name1 , name2,  weaponName , model, c , crateName , chance , isPermanent)
	BUC2.ItemToID[name1] = id 
	BUC2.IDToItem[id] = name1
	if BUC2.ITEMS[crateName] ~= nil then 	
		BUC2.ITEMS[name1] = {
			name1 = name1, 
			name2 = name2,
			itemType = "Weapon",
			model = model,
			chance = chance,
			color = c, 
			canBuy = false,
			permanent = isPermanent,
			weaponName = string.lower( weaponName )
		}
		table.insert(BUC2.ITEMS[crateName].items , name1)
	else
		print("[UNBOXING ERROR] THE CRATE '"..crateName.."' FOR '"..name1.."' DOES NOT EXTIST.")
	end
end

function bu_addMoney(id, name1 , name2 , amount , c , crateName, chance, bbool, price)

	BUC2.ItemToID[name1] = id 
	BUC2.IDToItem[id] = name1
	if BUC2.ITEMS[crateName] ~= nil then 	
		BUC2.ITEMS[name1] = {
			name1 = name1, 
			name2 = name2,
			itemType = "IGS",
			amount = amount,
			chance = chance,
			color = c, 
			canBuy = false,
			isdonatemoney = isbool(bbool) and bbool or false,
			isdonatemoneyprice = price or 0,
		}
		table.insert(BUC2.ITEMS[crateName].items , name1)
	else
		print("[UNBOXING ERROR] THE CRATE '"..crateName.."' FOR '"..name1.."' DOES NOT EXTIST.")
	end
end
--PATH addons/unbox/lua/unbox/modelpanel.lua:
local GenerateOutline = (...).outline
local FixCam = (...).cam
local itemBackgroundMat = (...).mat1
local moneyIcon = (...).mat2


local ModelPanel = {}
ModelPanel.Base = "EditablePanel"

function ModelPanel:Init( )
	self:SetCursor "hand"
end
function ModelPanel:OnMouseReleased( )
	if self.DoClick and not BUC2.buttonsLocked then
		self:DoClick( )
	end
end
	local havemat = false
	local matt = itemBackgroundMat

function ModelPanel:Paint( w, h )
	if not self.OutlineTop then
		GenerateOutline( self )
	end

	local bc = self.item.color

	surface.SetDrawColor(bc)
	surface.SetMaterial(itemBackgroundMat)
	surface.DrawTexturedRect(0,0,w,h)


	--print(self.item.name2)

	if self.item.itemType == "IGS" and not string.find(self.item.name2,"model") then

		--print(self.item.amount)
		if havemat then
			surface.SetDrawColor(255,255,255,255)
			surface.SetMaterial(matt)
			surface.DrawTexturedRect(10,10,80,80)	

		else
			havemat = true
			matt = Material(self.item.name2)
		end
		

	end

	draw.NoTexture( )
	surface.DrawPoly( self.OutlineTop )
	surface.DrawPoly( self.OutlineBottom )

	if IsValid( self.mod ) then
		self.mod:PaintManual( )
	end

	draw.SimpleText(self.item.name1,"ub2_7", w*0.5, h - 4, Color(255,255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )

end
local function FixCam1( modelView )
        modelView:SetFOV(50)
        modelView:SetCamPos(Vector(15, 25, 0))
        modelView:SetLookAt(Vector(0, 0, 0))
end

function ModelPanel:Set( v )
	if IsValid( self.mod ) then self.mod:Remove() end // change item

	self.item = BUC2.ITEMS[v]
	--PrintTable(self.item)
	--print(self.item.name2)

	if self.item.itemType == "IGS" and string.find(self.item.name2,"model")  then
		local tmod = vgui.Create("DModelPanel", self)
		tmod:SetMouseInputEnabled( false )
		tmod:Dock( FILL )
		tmod:SetPaintedManually( true )
		if self.item.itemType == "IGS" then
			tmod:SetModel(self.item.name2)
			tmod:SetAnimated(false)
			if not tmod.Entity then return end
			tmod.ang = tmod.Entity:GetAngles() 
			function tmod:LayoutEntity(Entity)
				if ( self.bAnimated ) then
					self:RunAnimation()
				end
			end
			if string.find(self.item.amount,"hat_") then
				FixCam1( tmod )
			else
				FixCam( tmod )
			end
		end
		self.mod = tmod

	end
end

return ModelPanel
--PATH gamemodes/darkrp/gamemode/cfg/cfg_sh.lua:
local twoserver = IS_SERVER == 2
--
rp.Setting.DefaultWeapon = {
	['Citizen'] = { 'keys', 'weapon_fists', 'weapon_physgun', 'gmod_tool', 'weapon_hand', 'weapon_physcannon', 'itemstore_pickup', 'phone', 'weapon_passport' },
	['Police'] = { 'door_ram', 'weaponchecker', 'weapon_radio', 'stungun', 'weapon_cuff_rope', 'arrest_baton', 'unarrest_baton', 'stun_baton' },
	['Admin'] = {},
}

rp.Setting.RandomSpawn = { Vector( 225, -2486, 73 ), Vector( 266, -2581, 73 ), Vector( 271, -2676, 72 ), Vector( 276, -2796, 72 ), Vector( 282, -2909, 73 ), Vector( 171, -2989, 73 ), Vector( 131, -2916, 73 ), Vector( 132, -2805, 73 ), Vector( 133, -2687, 73 ), Vector( 33, -2543, 73 ), Vector( 32, -2615, 73 ), Vector( 31, -2724, 73 ), Vector( 30, -2837, 73 ), Vector( 30, -2931, 73 ), Vector( -52, -3002, 73 ), Vector( -38, -2847, 73 ), Vector( -28, -2720, 73 ), Vector( -29, -2535, 73 ), Vector( 45, -2495, 73 ), Vector( 134, -2491, 73 ), }
if twoserver then rp.Setting.RandomSpawn = { Vector( 3206.706543, 750.758484, -131.968750 ), Vector( 3302.527588, 1114.536255, -103.179855 ), Vector( 3306.219727, 1170.200562, -119.708351 ), Vector( 3078.172852, 883.384521, -117.746986 ), Vector( 3574.482422, 600.908386, -126.305466 ), Vector( 3605.227539, 1097.274658, -113.858353 ), Vector( 3608.827637, 1250.728760, -113.858353 ), Vector( 3516.802490, 1341.585449, -99.764580 ), Vector( 3207.558838, 953.825623, -80.795265 ), Vector( 3203.707764, 906.442017, -72.966156 ), Vector( 3253.322021, 904.815125, -72.711899 ), } end
rp.Setting.ChatRadius = 300
rp.Setting.DeathTime = 30
rp.Setting.HungerTime = 120
rp.Setting.SalaryTime = 600
rp.Setting.PropLimit = 75
rp.Setting.PropLimitVIP = 200
rp.Setting.ArrestTime = 180
rp.Setting.DefaultMoney = 25000
rp.Setting.DefaultSpeedRun = 250
rp.Setting.DefaultSpeedWalk = 150
rp.Setting.DoorCostMin = 150
rp.Setting.DoorCostMax = 45000
rp.Setting.LootLoadTime = math.random( 3, 5 )
rp.Setting.LootCoolDown = 300
rp.Setting.Limits = {
	['dynamite'] = 0,
	['hoverballs'] = 0,
	['turrets'] = 0,
	['spawners'] = 0,
	['emitters'] = 0,
	['effects'] = 0,
	['buttons'] = 5,
	['ragdolls'] = 0,
	['npcs'] = 0,
	['lamps'] = 0,
	['balloons'] = 0,
	['lights'] = 5,
	['props'] = 35,
	['vehicles'] = 0,
	['sents'] = 25,
	['skeypads'] = 12,
	['textscreens'] = 5,
	['cameras'] = 5
}

rp.Setting.Links = {
	['Правила'] = twoserver and 'https://sites.google.com/view/ukrainerp2/general' or 'https://docs.google.com/document/d/1kTm6IcLzvvXKMdQCwFXNP_7AS1t_M5hU4P8vyr_8Ss8/edit?tab=t.0#heading=h.vcj1tgc1dkmr',
	['Discord'] = 'https://discord.gg/ua-roleplay-gmod-1025769467466236014',
}

if SERVER then
	local workshop = {
		[1] = { '111863064', '3315567003', '3315556447' },
		[2] = { '3419777789', '3315556447', '3315570843' }
	}

	for _, v in ipairs( twoserver and workshop[2] or workshop[1] ) do
		resource.AddWorkshop( v )
	end
end

rp.Setting.TextSrceenFonts = { 'Roboto_12', 'Roboto_24', 'Roboto_36' }
-------
rp.Setting.AnonimPrice = 40000
rp.Setting.Commands = {}
rp.Setting.Commands.Client = {
	{
		name = { 'job' },
		description = 'Змінити назву професії',
		checkchat = true,
		execute = function( _, _, preExecute ) RunConsoleCommand( 'job_name', preExecute[1] ) end,
	},
	{
		name = { 'name' },
		description = 'Змінити ім\'я',
		checkchat = true,
		execute = function( _, _, preExecute ) RunConsoleCommand( 'rpname', preExecute[1] ) end,
	},
	{
		name = { 'sell' },
		description = 'Продати предмет навпроти',
		execute = function() RunConsoleCommand( 'sell' ) end,
	},
	{
		name = { 'sellall' },
		description = 'Продати всі предмети',
		execute = function() RunConsoleCommand( 'sellall' ) end,
	},
	{
		name = { 'dropmoney' },
		description = 'Викинути гроші',
		execute = function( _, options )
			if not options[1] then return end
			RunConsoleCommand( 'dropmoney', options[1] )
		end,
	},
	{
		name = { 'givemoney' },
		description = 'Передати гроші',
		execute = function( _, options )
			if not options[1] then return end
			RunConsoleCommand( 'givemoney', options[1] )
		end,
	},
	{
		name = { 'drop' },
		description = 'Викинути предмет із рук',
		execute = function() RunConsoleCommand( 'drop' ) end,
	},
	{
		name = { 'wanted' },
		description = 'Видати розшук',
		execute = function( _, options )
			if not options[1] or not options[2] then return end
			RunConsoleCommand( 'Wanted', options[1], options[2] )
		end,
		checkShow = function( ply ) return ply:IsPolice() end
	},
	{
		name = { 'unwanted' },
		description = 'Зняти розшук',
		execute = function( _, options )
			if not options[1] then return end
			RunConsoleCommand( 'UnWanted', options[1] )
		end,
		checkShow = function( ply ) return ply:IsPolice() end
	},
	{
		name = { 'lottery' },
		description = 'Запустити лотерею для громадян',
		jobs = { 'Mayor' },
		execute = function( _, options )
			if not options[1] then return end
			RunConsoleCommand( 'lottery', options[1] )
		end,
		checkShow = function( ply ) return ply:IsMayor() end
	},
}

rp.Setting.Commands.Server = {
	{
		name = { 'ooc', '/' },
		description = 'Глобальний чат',
		checkchat = true,
		execute = function( requester, _, preExecute )
			if not preExecute or not commandsLib.check_text( preExecute[1] ) then return end
			hook.Call( 'playerOOC', nil, requester, preExecute[1] )
			local result = commandsLib.parseText( requester, preExecute[1], commandsLib.parseNONRP, '<clr:white><bg_col:0,150,0> OOC <bg_col:none> ', team.GetColor( requester:Team() ), requester, color_white, ': ' )
			--
			echat:SendParsedMessageToPlayer( requester, player.GetAll(), result, preExecute[1] )
		end,
	},
	{
		name = { 'advert', 'ad' },
		description = 'Оголошення',
		preexecute = function( requester, options )
			if not options or not rp.Team[requester:Team()] then return false end
			--
			local noadvert = rp.Team[requester:Team()].noAdvert
			local unlimitadvert = rp.Team[requester:Team()].unlimitAdvert or false
			--
			if noadvert then return rp.Notify( requester, NOTIFY_ERROR, 'Ви не можете використовувати оголошення.', '' ) end
			if not unlimitadvert then
				requester.timeadvert = requester.timeadvert or 0
				if requester.timeadvert > CurTime() then
					rp.Notify( requester, NOTIFY_ERROR, string.format( 'Зачекайте %s секунд перед наступним оголошенням.', math.Round( requester.timeadvert - CurTime() ) ), '' )
					return ''
				end
			end
			return commandsLib.preChat( nil, options )
		end,
		execute = function( requester, _, preExecute )
			if not preExecute or preExecute[1] == '' or not commandsLib.check_text( preExecute[1] ) then return end
			hook.Call( 'playerAdverted', nil, requester, preExecute[1] )
			local result = commandsLib.parseText( requester, preExecute[1], commandsLib.parseRP, '<clr:white><bg_col:200,200,0> Оголошення <bg_col:none> ', team.GetColor( requester:Team() ), requester, color_white, ': ' )
			--
			echat:SendParsedMessageToPlayer( requester, player.GetAll(), result, preExecute[1] )
			--
			requester.timeadvert = CurTime() + 120
		end,
	},
	{
		name = { 'me' },
		description = 'Провести дію',
		checkchat = true,
		execute = function( requester, _, preExecute )
			if not preExecute or not commandsLib.check_text( preExecute[1] ) then return end
			hook.Call( 'playerMeeeee', nil, requester, preExecute[1] )
			local result = commandsLib.parseText( requester, preExecute[1], commandsLib.parseRP, '<clr:white><bg_col:200,200,0> Дія <bg_col:none> ', team.GetColor( requester:Team() ), requester, color_white, ' виконати дію: <clr:orange>' )
			--
			echat:SendParsedMessageToPlayer( requester, ents.FindInSphere( requester:GetPos(), rp.Setting.ChatRadius ), result, preExecute[1] )
		end,
	},
	{
		name = { 'do' },
		description = 'Підтвердження дії',
		checkchat = true,
		execute = function( requester, _, preExecute )
			if not preExecute or not commandsLib.check_text( preExecute[1] ) then return end
			hook.Call( 'playerDooooo', nil, requester, preExecute[1] )
			local result = commandsLib.parseText( requester, preExecute[1], commandsLib.parseRP, '<clr:white><bg_col:200,100,0> Do <bg_col:none> ', color_white, ' (', team.GetColor( requester:Team() ), requester, color_white, ') ', ' <clr:gold>' )
			--
			echat:SendParsedMessageToPlayer( requester, ents.FindInSphere( requester:GetPos(), rp.Setting.ChatRadius ), result, preExecute[1] )
		end,
	},
	{
		name = { 'y' },
		description = 'Крик',
		checkchat = true,
		execute = function( requester, _, preExecute )
			if not preExecute or not commandsLib.check_text( preExecute[1] ) then return end
			hook.Call( 'playerCrick', nil, requester, preExecute[1] )
			local result = commandsLib.parseText( requester, preExecute[1], commandsLib.parseRP, '<clr:white><bg_col:255,165,0> Кричати <bg_col:none> ', team.GetColor( requester:Team() ), requester, color_white, ': ' )
			--
			echat:SendParsedMessageToPlayer( requester, ents.FindInSphere( requester:GetPos(), rp.Setting.ChatRadius + 150 ), result, preExecute[1] )
		end,
	},
	{
		name = { 'w' },
		description = 'Шепіт',
		checkchat = true,
		execute = function( requester, _, preExecute )
			if not preExecute or not commandsLib.check_text( preExecute[1] ) then return end
			hook.Call( 'playerShepot', nil, requester, preExecute[1] )
			local result = commandsLib.parseText( requester, preExecute[1], commandsLib.parseRP, '<clr:white><bg_col:107,142,35> Шепіт <bg_col:none> ', team.GetColor( requester:Team() ), requester, color_white, ': ' )
			--
			echat:SendParsedMessageToPlayer( requester, ents.FindInSphere( requester:GetPos(), rp.Setting.ChatRadius - 250 ), result, preExecute[1] )
		end,
	},
	{
		name = { 'broadcast' },
		description = 'Оголошення від Мера',
		checkchat = true,
		jobs = { 'Mayor' },
		execute = function( requester, _, preExecute )
			if not preExecute or not commandsLib.check_text( preExecute[1] ) then return end
			local result = commandsLib.parseText( requester, preExecute[1], commandsLib.parseRP, '<clr:white><bg_col:150,0,0> Оголошення від Мера <bg_col:none> ', team.GetColor( requester:Team() ), requester, color_white, ': ' )
			--
			echat:SendParsedMessageToPlayer( requester, player.GetAll(), result, preExecute[1] )
		end,
		checkShow = function( ply ) return ply:IsMayor() end,
	},
	{
		name = { 'roll' },
		description = 'Випадкове число від 1 до 100',
		checkchat = true,
		preexecute = function() return math.random( 1, 100 ) end,
		execute = function( requester, _, preExecute )
			if not preExecute then return end
			local result = commandsLib.parseText( requester, '', commandsLib.parseRP, '<clr:white><bg_col:200,200,0> Кістки <bg_col:none> ', team.GetColor( requester:Team() ), requester, color_white, ' кинув кістки і кількість впав <clr:red>', preExecute[1] )
			--
			echat:SendParsedMessageToPlayer( requester, ents.FindInSphere( requester:GetPos(), rp.Setting.ChatRadius ), result, '' )
		end,
		checkShow = function( ply ) return ply:IsMayor() end,
	},
	{
		name = { 'anon' },
		description = 'Анонімно відправити повідомлення 40.000$',
		preexecute = function( requester, options )
			if not options then return false end
			--
			if requester:CanAfford( rp.Setting.AnonimPrice ) then
				requester:TakeMoney( rp.Setting.AnonimPrice )
				return commandsLib.preChat( nil, options )
			end

			rp.Notify( requester, NOTIFY_ERROR, 'Недостатньо коштів.', '' )
			return ''
		end,
		execute = function( requester, _, preExecute )
			if not preExecute or preExecute[1] == '' or not commandsLib.check_text( preExecute[1] ) then return end
			hook.Call( 'playerAnonim', nil, requester, preExecute[1] )
			--
			local admins, other = {}, {}
			for _, v in player.Iterator() do
				table.insert( CAMI.PlayerHasAccess( v, 'ukrp_checknameanonim' ) and admins or other, v )
			end

			local result = commandsLib.parseText( requester, preExecute[1], commandsLib.parseRP, '<clr:white><bg_col:45,78,78> Шепіт Вітру <bg_col:none> ', team.GetColor( requester:Team() ), requester, color_white, ': ' )
			local result2 = commandsLib.parseText( requester, preExecute[1], commandsLib.parseRP, '<clr:white><bg_col:45,78,78> Шепіт Вітру <bg_col:none> ', color_white, '?????: ' )
			--
			echat:SendParsedMessageToPlayer( requester, admins, result, preExecute[1] )
			echat:SendParsedMessageToPlayer( requester, other, result2, preExecute[1] )
		end,
	},
}
--PATH gamemodes/darkrp/gamemode/core/player/structure/init_sh.lua:
local GoodItem = { 'Color', 'Model', 'Weapons', 'Command', 'Max', 'Salary' }
function rp.FindPlayer( info )
	if not info or info == '' then return end
	info = tostring( info )
	for _, pl in player.Iterator() do
		if info == pl:SteamID() then
			return pl
		elseif info == pl:SteamID64() then
			return pl
		elseif string.find( string.lower( pl:Name() ), string.lower( info ), 1, true ) ~= nil then
			return pl
		end
	end
end

function PLAYER:Wealth( min, max )
	return math.min( math.floor( min + ( max - min ) * self:GetMoney() / 25000000 ), max )
end

rp.Team = {}
local function CV( t )
	for k, v in ipairs( GoodItem ) do
		local isFunction = type( v ) == 'function'
		if isFunction and not v( t[k] ) or not isFunction and t[v] == nil then return isFunction and k or v end
	end
end

local job_cost = 0
function rp.AddTeam( Name, cfg )
	job_cost = job_cost + 1
	rp.Team[job_cost] = cfg
	cfg.name = Name
	local check = CV( cfg, GoodItem )
	if check then return print( 'fall - ' .. Name ) end
	team.SetUp( #rp.Team, Name, cfg.Color )
	local t = #rp.Team
	cfg.team = t
	return t
end

local GoodItem = { 'Model', 'ENT', 'Command', 'Max', 'Price' }
local function CV( t )
	for k, v in ipairs( GoodItem ) do
		local isFunction = type( v ) == 'function'
		if isFunction and not v( t[k] ) or not isFunction and t[v] == nil then return isFunction and k or v end
	end
end

rp.Entites = {}
function rp.AddEntites( Name, cfg )
	cfg.name = Name
	cfg.allowed = cfg.allowed or {}
	if type( cfg.allowed ) == 'number' then cfg.allowed = { cfg.allowed } end
	if #cfg.allowed == 0 then
		for k in ipairs( team.GetAllTeams() ) do
			table.insert( cfg.allowed, k )
		end
	end

	local check = CV( cfg, GoodItem )
	if check then return print( 'fall - ' .. Name ) end
	local allowed = {}
	for _, v in ipairs( cfg.allowed ) do
		allowed[v] = true
	end

	cfg.allowed = allowed
	table.insert( rp.Entites, cfg )
	util.PrecacheModel( cfg.Model )
end

local GoodItem = { 'Model', 'Ammo', 'Price' }
local function CV( t )
	for k, v in ipairs( GoodItem ) do
		local isFunction = type( v ) == 'function'
		if isFunction and not v( t[k] ) or not isFunction and t[v] == nil then return isFunction and k or v end
	end
end

rp.Ammo = {}
function rp.AddAmmo( Name, cfg )
	cfg.name = Name
	local check = CV( cfg, GoodItem )
	if check then return print( 'fall - ' .. Name ) end
	table.insert( rp.Ammo, cfg )
	util.PrecacheModel( cfg.Model )
end

local GoodItem = { 'Model', 'ENT', 'Max', 'Price', 'Inventory' }
local function CV( t )
	for k, v in ipairs( GoodItem ) do
		local isFunction = type( v ) == 'function'
		if isFunction and not v( t[k] ) or not isFunction and t[v] == nil then return isFunction and k or v end
	end
end

rp.Weapons = {}
function rp.AddWeapon( Name, ... )
	dobr = { ... }
	cfg = {}
	if istable( dobr[1] ) then
		cfg = dobr[1]
	else
		cfg.allowed = dobr[8]
		cfg.name = Name
		cfg.Model = dobr[1]
		cfg.ENT = dobr[2]
		cfg.Inventory = true
		cfg.Price = dobr[3]
		cfg.Max = dobr[4]
	end

	table.insert( rp.Weapons, cfg )
	cfg.name = Name
	cfg.allowed = cfg.allowed or {}
	if type( cfg.allowed ) == 'number' then cfg.allowed = { cfg.allowed } end
	if #cfg.allowed == 0 then
		for k in ipairs( team.GetAllTeams() ) do
			table.insert( cfg.allowed, k )
		end
	end

	local check = CV( cfg, GoodItem )
	if check then return print( 'fall - ' .. Name ) end
	local allowed = {}
	for _, v in ipairs( cfg.allowed ) do
		allowed[v] = true
	end

	cfg.allowed = allowed
	util.PrecacheModel( cfg.Model )
end

rp.teamDoors = {}
function rp.CreateDoorGroup( name, ... )
	rp.teamDoors[name] = rp.teamDoors[name] or {}
	for _, v in ipairs( { ... } ) do
		if v ~= nil then rp.teamDoors[name][v] = true end
	end
end

function rp.AddDoorGroup( name, ... )
	if rp.teamDoors[name] then
		for _, v in ipairs( { ... } ) do
			if v ~= nil then rp.teamDoors[name][v] = true end
		end
	end
end
--PATH gamemodes/darkrp/gamemode/core/chat/chat_sh.lua:
IGS( 'Говорилка', 'voice' ):SetPrice( 999 ):SetPerma():SetDescription( 'Озвучує текст у чаті, написаний вами' ):SetCategory( 'Донатна зброя' )
--PATH gamemodes/darkrp/gamemode/core/prop/prop_cl.lua:
local PANEL = {}
function PANEL:Init()
	self.PanelList = vgui.Create( 'DPanelList', self )
	self.PanelList:SetPadding( 4 )
	self.PanelList:SetSpacing( 2 )
	self.PanelList:EnableVerticalScrollbar( true )
	self:BuildList()
end

function PANEL:BuildList()
	self.PanelList:Clear()
	for CategoryName in SortedPairs( PropWhiteList ) do
		local Category = vgui.Create( 'DCollapsibleCategory', self )
		self.PanelList:AddItem( Category )
		Category:SetExpanded( false )
		Category:SetLabel( CategoryName )
		Category:SetCookieName( 'EntitySpawn.' .. CategoryName )
		local Content = vgui.Create( 'DPanelList' )
		Category:SetContents( Content )
		Content:EnableHorizontal( true )
		Content:SetPaintBackground( false )
		Content:SetSpacing( 2 )
		Content:SetPadding( 2 )
		Content:SetAutoSize( true )
		number = 1
		for _, v in ipairs( PropWhiteList[CategoryName] ) do
			local Icon = vgui.Create( 'SpawnIcon', self )
			local Model = v
			Icon:SetModel( v )
			Icon.DoRightClick = function() SetClipboardText( Model ) end
			Icon.DoClick = function() RunConsoleCommand( 'gm_spawn', Model ) end
			local lable = vgui.Create( 'DLabel', Icon )
			lable:SetFont( 'DebugFixedSmall' )
			lable:SetTextColor( color_black )
			lable:SetText( Model )
			lable:SetContentAlignment( 5 )
			lable:SetWide( self:GetWide() )
			lable:AlignBottom( -42 )
			Content:AddItem( Icon )
			number = number + 1
		end
	end

	self.PanelList:InvalidateLayout()
end

function PANEL:PerformLayout()
	self.PanelList:StretchToParent( 0, 0, 0, 0 )
end

local CreationSheet = vgui.RegisterTable( PANEL, 'Panel' )
local function CreateContentPanel()
	local ctrl = vgui.CreateFromTable( CreationSheet )
	return ctrl
end

local function RemoveSandboxTabs()
	local tabstoremoveSup = { language.GetPhrase( 'spawnmenu.content_tab' ), language.GetPhrase( 'spawnmenu.category.npcs' ), language.GetPhrase( 'spawnmenu.category.entities' ), language.GetPhrase( 'spawnmenu.category.weapons' ), language.GetPhrase( 'spawnmenu.category.vehicles' ), language.GetPhrase( 'spawnmenu.category.postprocess' ), language.GetPhrase( 'spawnmenu.category.dupes' ), language.GetPhrase( 'spawnmenu.category.saves' ) }
	if CAMI.PlayerHasAccess( LocalPlayer(), 'ukrp_spawnmenu' ) then return end
	for _, v in pairs( g_SpawnMenu.CreateMenu.Items ) do
		if table.HasValue( tabstoremoveSup, v.Tab:GetText() ) then
			g_SpawnMenu.CreateMenu:CloseTab( v.Tab, true )
			RemoveSandboxTabs()
		end
	end
end

hook.Add( 'SpawnMenuOpen', 'blockmenutabs', RemoveSandboxTabs )
spawnmenu.AddCreationTab( 'Дозволені пропи', CreateContentPanel, 'icon16/application_view_tile.png', 4 )
local target = {
	active = false
}

local snaptarget = {
	active = false
}

local snapkey = false
local snaptime = false
local snaplock = false
local snapclick = false
local snapclickfade = 0
local snapcursor = false
local snapspawnmenu = false
local cache = {
	vPlayerPos = 0,
	vLookPos = 0,
	vLookClipPos = 0,
	vLookVector = 0,
}

local condefs = {
	snap_enabled = 1,
	snap_gcboost = 1,
	snap_gcstrength = 125,
	snap_hidegrid = 0,
	snap_clickgrid = 0,
	snap_toggledelay = 0,
	snap_disableuse = 0,
	snap_allentities = 0,
	snap_alltools = 0,
	snap_enabletoggle = 0,
	snap_lockdelay = 0.5,
	snap_distance = 250,
	snap_gridlimit = 16,
	snap_gridsize = 8,
	snap_gridalpha = 0.4,
	snap_gridoffset = 0.5,
	snap_boundingbox = 1,
	snap_revertaim = 1,
	snap_centerline = 1,
}

local convars = {}
for key in pairs( condefs ) do
	convars[#convars + 1] = key
end

local modelsaveset = {}
local modeloffsets = {}
---------
local function DrawScreenLine( vsA, vsB )
	surface.DrawLine( vsA.x, vsA.y, vsB.x, vsB.y )
end

local function ToScreen( vWorld )
	local vsScreen = vWorld:ToScreen()
	return Vector( vsScreen.x, vsScreen.y, 0 )
end

local function PointToScreen( vPoint )
	if cache.vLookVector:Dot( vPoint - cache.vLookClipPos ) > 0 then return ToScreen( vPoint ) end
end

local function LineToScreen( vStart, vEnd )
	local dotStart = cache.vLookVector:Dot( vStart - cache.vLookClipPos )
	local dotEnd = cache.vLookVector:Dot( vEnd - cache.vLookClipPos )
	if dotStart > 0 and dotEnd > 0 then
		return ToScreen( vStart ), ToScreen( vEnd )
	elseif dotStart > 0 or dotEnd > 0 then
		local vLength = vEnd - vStart
		local vIntersect = vStart + vLength * ( cache.vLookClipPos:Dot( cache.vLookVector ) - vStart:Dot( cache.vLookVector ) ) / vLength:Dot( cache.vLookVector )
		if dotStart <= 0 then
			return ToScreen( vIntersect ), ToScreen( vEnd )
		else
			return ToScreen( vStart ), ToScreen( vIntersect )
		end
	end
end

local function RayQuadIntersect( vOrigin, vDirection, vPlane, vX, vY )
	local vp = vDirection:Cross( vY )
	local d = vX:Dot( vp )
	if d <= 0.0 then return end
	local vt = vOrigin - vPlane
	local u = vt:Dot( vp )
	if u < 0.0 or u > d then return end
	local v = vDirection:Dot( vt:Cross( vX ) )
	if v < 0.0 or v > d then return end
	return Vector( u / d, v / d, 0 )
end

------------
local function OnInitialize()
	for key, value in pairs( condefs ) do
		CreateClientConVar( key, value, true, false )
	end

	for _, filename in ipairs( file.Find( 'smartsnap_offsets_*.png', 'GAME' ) ) do
		local file = file.Read( filename )
		if file then
			lines = string.Explode( '\n', file )
			header = table.remove( lines, 1 )
			if header == 'SMARTSNAP_OFFSETS' then
				for _, line in ipairs( lines ) do
					local pos = string.find( line, '=' )
					if pos then
						local key = string.lower( string.Trim( string.sub( line, 1, pos - 1 ) ) )
						local value = string.Trim( string.sub( line, pos + 1 ) )
						local c = string.Explode( ',', value )
						modeloffsets[key] = { tonumber( c[1] ), tonumber( c[2] ), tonumber( c[3] ), tonumber( c[4] ), tonumber( c[5] ), tonumber( c[6] ) }
					end
				end
			end
		end
	end
end

local function OnShutDown()
	output = file.Read( 'smartsnap_offsets_custom.png' )
	if output == nil then output = 'SMARTSNAP_OFFSETS\n' end
	for model, _ in pairs( modelsaveset ) do
		output = output .. model .. '=' .. table.concat( modeloffsets[model], ',' ) .. '\n'
	end

	file.Write( 'smartsnap_offsets_custom.png', output )
end

local function GetDevOffset()
	local model = string.lower( target.entity:GetModel() )
	if modeloffsets[model] == nil then modeloffsets[model] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } end
	return modeloffsets[model]
end

concommand.Add( 'snap_dev_alloffset', function( _, _, arguments )
	if target.active == true and #arguments >= 1 then
		local v = GetDevOffset()
		for i = 1, 6 do
			v[i] = v[i] + tonumber( arguments[1] )
		end
	end
end )

concommand.Add( 'snap_dev_gridoffset', function( _, _, arguments )
	if target.active == true and #arguments >= 1 then
		local v = GetDevOffset()
		v[target.face] = v[target.face] + tonumber( arguments[1] )
	end
end )

concommand.Add( 'snap_dev_saveoffset', function() if target.active == true then modelsaveset[string.lower( target.entity:GetModel() )] = true end end )
local function SnapToggleGrid()
	if GetConVarNumber( 'snap_enabled' ) == 0 then
		RunConsoleCommand( 'snap_enabled', '1' )
	else
		RunConsoleCommand( 'snap_enabled', '0' )
	end
end

local function SnapPress()
	if GetConVarNumber( 'snap_clickgrid' ) ~= 0 and not snapclick then
		snapclick = true
		snapclickfade = CurTime()
	elseif GetConVarNumber( 'snap_clickgrid' ) == 0 or snapclick then
		if snaplock or snapcursor then
			snaptime = false
		else
			local toggledelay = GetConVarNumber( 'snap_toggledelay' )
			if toggledelay > 0 and snaptime and snaptime + toggledelay > CurTime() then
				SnapToggleGrid()
				snaptime = false
				snaplock = false
			else
				snaptime = CurTime()
			end
		end

		snapkey = target.active
		if not snapcursor then snaplock = false end
	end
end

local function SnapRelease()
	snapkey = false
end

local function SnapLock()
	snaplock = not snaplock
end

local function OnSpawnMenu()
	snapspawnmenu = true
end

local function OnKeyPress( player, key )
	if key == IN_USE and GetConVarNumber( 'snap_disableuse' ) == 0 then SnapPress() end
end

local function OnKeyRelease( player, key )
	if key == IN_USE and GetConVarNumber( 'snap_disableuse' ) == 0 then SnapRelease() end
end

local function OnThink()
	if vgui.CursorVisible() then
		if not snapcursor and snaplock then snaptarget = table.Copy( target ) end
		snaptime = false
		snapcursor = true
	else
		if snapcursor and snaplock then target = snaptarget end
		snapspawnmenu = false
		snapcursor = false
	end

	if GetConVarNumber( 'snap_enabletoggle' ) ~= 0 and snapkey and snaptime and not snaplock and CurTime() > snaptime + GetConVarNumber( 'snap_lockdelay' ) then
		snaplock = true
		snaptime = false
	end

	local locked = target.locked and target.active
	target.locked = ( snapkey or snaplock and not snapcursor ) and target.active
	if not target.locked and locked and GetConVarNumber( 'snap_revertaim' ) ~= 0 then
		if snapcursor then
			local screen = target.entity:LocalToWorld( target.vector ):ToScreen()
			gui.SetMousePos( math.Round( screen.x ), math.Round( screen.y ) )
		else
			local angles = ( target.entity:LocalToWorld( target.vector ) - LocalPlayer():GetShootPos() ):Angle()
			LocalPlayer():SetEyeAngles( angles )
		end
	end
end

local function CalculateGridAxis( L )
	local length = L:Length()
	local grid = math.Clamp( math.floor( length / ( 2 * GetConVarNumber( 'snap_gridsize' ) ) ) * 2, 2, GetConVarNumber( 'snap_gridlimit' ) )
	local offset = math.Clamp( GetConVarNumber( 'snap_gridoffset' ) / length, 0, 1 / grid )
	local scale = 1 - offset * 2
	return {
		length = length,
		offset = offset,
		scale = scale,
		grid = grid,
	}
end

local function CalculateSnap( X, Y, v )
	local LX = CalculateGridAxis( X )
	local LY = CalculateGridAxis( Y )
	local BX = math.Clamp( math.Round( v.x * LX.grid ), 0, LX.grid )
	local BY = math.Clamp( math.Round( v.y * LY.grid ), 0, LY.grid )
	if BX == 1 and v.x < ( 1 / LX.grid + LX.offset ) * 0.5 then BX = 0 end
	if BX == LX.grid - 1 and v.x > 1 - ( 1 / LX.grid + LX.offset ) * 0.5 then BX = LX.grid end
	if BY == 1 and v.y < ( 1 / LY.grid + LY.offset ) * 0.5 then BY = 0 end
	if BY == LY.grid - 1 and v.y > 1 - ( 1 / LY.grid + LY.offset ) * 0.5 then BY = LY.grid end
	local RX = X * BX / LX.grid
	local RY = Y * BY / LY.grid
	if BX == 0 then RX = X * math.Clamp( LX.offset, 0, 1 / LX.grid ) end
	if BX == LX.grid then RX = X * ( 1 - math.Clamp( LX.offset, 0, 1 / LX.grid ) ) end
	if BY == 0 then RY = Y * math.Clamp( LY.offset, 0, 1 / LY.grid ) end
	if BY == LY.grid then RY = Y * ( 1 - math.Clamp( LY.offset, 0, 1 / LY.grid ) ) end
	return RX + RY
end

local function DrawGridLines( vOrigin, vSX, vSY, gridLines, offsetX, offsetY, sign )
	local centerline = GetConVarNumber( 'snap_centerline' ) ~= 0
	local vTemp = vOrigin + vSX * 0.5
	local vX = vTemp + vSY * offsetY
	local vY = vTemp + vSY * ( 1 - offsetY )
	local temp
	local xtemp = ToScreen( vX ) - ToScreen( vY )
	xtemp:Normalize()
	local vsNormal = xtemp
	if math.abs( vsNormal.x ) < 1 - math.abs( vsNormal.y ) then
		temp = -0.5 * sign
	else
		temp = 0.5 * sign
	end

	if math.abs( vsNormal.x ) < math.abs( vsNormal.y ) then
		vsOffset = Vector( temp, 0, 0 )
	else
		vsOffset = Vector( 0, temp, 0 )
	end

	if offsetX < 1 / gridLines then
		local vTemp = vOrigin + vSX * offsetX
		local vX = vTemp + vSY * offsetY
		local vY = vTemp + vSY * ( 1 - offsetY )
		local vsX, vsY = LineToScreen( vX, vY )
		if vsX then DrawScreenLine( vsX + vsOffset, vsY + vsOffset ) end
	end

	for i = 1, gridLines - 1 do
		local vTemp = vOrigin + vSX * i / gridLines
		local vX = vTemp + vSY * offsetY
		local vY = vTemp + vSY * ( 1 - offsetY )
		local vsX, vsY = LineToScreen( vX, vY )
		if vsX then
			if gridLines / i == 2 and centerline then
				DrawScreenLine( vsX + vsOffset * -1, vsY + vsOffset * -1 )
				DrawScreenLine( vsX + vsOffset * 3, vsY + vsOffset * 3 )
			else
				DrawScreenLine( vsX + vsOffset, vsY + vsOffset )
			end
		end
	end

	if offsetX < 1 / gridLines then
		local vTemp = vOrigin + vSX * ( 1 - offsetX )
		local vX = vTemp + vSY * offsetY
		local vY = vTemp + vSY * ( 1 - offsetY )
		local vsX, vsY = LineToScreen( vX, vY )
		if vsX then DrawScreenLine( vsX + vsOffset, vsY + vsOffset ) end
	end
end

local function DrawGrid( vOrigin, vSX, vSY )
	local LX = CalculateGridAxis( vSX )
	local LY = CalculateGridAxis( vSY )
	surface.SetDrawColor( 0, 0, 0, math.Round( GetConVarNumber( 'snap_gridalpha' ) * 255 ) )
	DrawGridLines( vOrigin, vSX, vSY, LX.grid, LX.offset, LY.offset, 1 )
	DrawGridLines( vOrigin, vSY, vSX, LY.grid, LY.offset, LX.offset, 1 )
	surface.SetDrawColor( 255, 255, 255, math.Round( GetConVarNumber( 'snap_gridalpha' ) * 255 ) )
	DrawGridLines( vOrigin, vSX, vSY, LX.grid, LX.offset, LY.offset, -1 )
	DrawGridLines( vOrigin, vSY, vSX, LY.grid, LY.offset, LX.offset, -1 )
end

local function DrawBoundaryLines( vOrigin, vOpposite )
	local vPoint
	if vOrigin:DistToSqr( vOpposite ) > 25 then
		local x = vOpposite - vOrigin
		x:Normalize()
		vPoint = vOrigin + x * 5
	else
		vPoint = vOrigin + ( vOpposite - vOrigin ) * 0.5
	end

	local vsA, vsB = LineToScreen( vPoint, vOrigin )
	if vsA then
		surface.SetDrawColor( 0, 0, 255, 192 )
		DrawScreenLine( vsA, vsB )
	end
end

local function DrawBoundary( vOrigin, vX, vY, vZ )
	DrawBoundaryLines( vOrigin, vX )
	DrawBoundaryLines( vOrigin, vY )
	DrawBoundaryLines( vOrigin, vZ )
end

local function DrawSnapCross( vsCenter, r, g, b )
	surface.SetDrawColor( 0, 0, 0, 255 )
	DrawScreenLine( vsCenter + Vector( -2.5, -2.0 ), vsCenter + Vector( 2.5, 3.0 ) )
	DrawScreenLine( vsCenter + Vector( 1.5, -2.0 ), vsCenter + Vector( -3.5, 3.0 ) )
	surface.SetDrawColor( r, g, b, 255 )
	DrawScreenLine( vsCenter + Vector( -1.5, -2.0 ), vsCenter + Vector( 3.5, 3.0 ) )
	DrawScreenLine( vsCenter + Vector( 2.5, -2.0 ), vsCenter + Vector( -2.5, 3.0 ) )
end

local function ComputeEdges( entity, obbmax, obbmin )
	return {
		lsw = entity:LocalToWorld( Vector( obbmin.x, obbmin.y, obbmin.z ) ),
		lse = entity:LocalToWorld( Vector( obbmax.x, obbmin.y, obbmin.z ) ),
		lnw = entity:LocalToWorld( Vector( obbmin.x, obbmax.y, obbmin.z ) ),
		lne = entity:LocalToWorld( Vector( obbmax.x, obbmax.y, obbmin.z ) ),
		usw = entity:LocalToWorld( Vector( obbmin.x, obbmin.y, obbmax.z ) ),
		use = entity:LocalToWorld( Vector( obbmax.x, obbmin.y, obbmax.z ) ),
		unw = entity:LocalToWorld( Vector( obbmin.x, obbmax.y, obbmax.z ) ),
		une = entity:LocalToWorld( Vector( obbmax.x, obbmax.y, obbmax.z ) ),
	}
end

local function OnPaintHUD()
	target.active = false
	if GetConVarNumber( 'snap_clickgrid' ) ~= 0 and not snapclick then return end
	snapclickprev = snapclick
	snapclick = snapclickprev and snapclickfade > CurTime()
	if GetConVarNumber( 'snap_enabled' ) == 0 then return end
	if not LocalPlayer():Alive() or LocalPlayer():InVehicle() then return end
	if target.locked then
		if not target.entity:IsValid() then return end
	else
		local trace = LocalPlayer():GetEyeTrace()
		cache.vLookTrace = trace
		if not trace.HitNonWorld then return end
		local entity = trace.Entity
		if not IsValid( entity ) or entity:IsPlayer() then return end
		local class = entity:GetClass()
		if class ~= 'prop_physics' and class ~= 'phys_magnet' and class ~= 'gmod_spawner' and GetConVarNumber( 'snap_allentities' ) == 0 then return end
		if GetConVarNumber( 'snap_allentities' ) == 1 and class == 'player' then return end
		if not LocalPlayer():GetActiveWeapon():IsValid() then return end
		if LocalPlayer():GetActiveWeapon():GetClass() == 'weapon_physgun' then return end
		if LocalPlayer():GetActiveWeapon():GetClass() ~= 'gmod_tool' and GetConVarNumber( 'snap_alltools' ) == 0 then return end
		target.entity = entity
	end

	--ErrorNoHalt(collectgarbage('count'))
	if GetConVarNumber( 'snap_gcboost' ) ~= 0 then collectgarbage( 'step', GetConVarNumber( 'snap_gcstrength' ) ) end
	snapclick = snapclickprev
	snapclickfade = CurTime() + 0.25
	-- updating the cache perhaps shouldn't be done here, CalcView?
	cache.vLookPos = LocalPlayer():GetShootPos()
	cache.vLookVector = LocalPlayer():GetAimVector()
	cache.vLookClipPos = cache.vLookPos + cache.vLookVector * 3
	local model = string.lower( target.entity:GetModel() )
	local offsets = modeloffsets[model]
	if not offsets then
		local offset = 0.25
		offsets = { offset, offset, offset, offset, offset, offset }
	end

	if cache.eEntity ~= target.entity or cache.vEntAngles ~= target.entity:GetAngles() or vEntPosition ~= target.entity:GetPos() then
		cache.eEntity = target.entity
		cache.vEntAngles = target.entity:GetAngles()
		cache.vEntPosition = target.entity:GetPos()
		local obbmax = target.entity:OBBMaxs()
		local obbmin = target.entity:OBBMins()
		local obvsnap = ComputeEdges( target.entity, obbmax, obbmin )
		local obbmax = target.entity:OBBMaxs() - Vector( offsets[5], offsets[3], offsets[1] )
		local obbmin = target.entity:OBBMins() + Vector( offsets[6], offsets[4], offsets[2] )
		local obvgrid = ComputeEdges( target.entity, obbmax, obbmin )
		local faces = { { obvgrid.unw, obvgrid.usw - obvgrid.unw, obvgrid.une - obvgrid.unw, obvgrid.lnw - obvgrid.unw, Vector( 0, 0, -offsets[1] ) }, { obvgrid.lsw, obvgrid.lnw - obvgrid.lsw, obvgrid.lse - obvgrid.lsw, obvgrid.usw - obvgrid.lsw, Vector( 0, 0, offsets[2] ) }, { obvgrid.unw, obvgrid.une - obvgrid.unw, obvgrid.lnw - obvgrid.unw, obvgrid.usw - obvgrid.unw, Vector( 0, -offsets[3], 0 ) }, { obvgrid.usw, obvgrid.lsw - obvgrid.usw, obvgrid.use - obvgrid.usw, obvgrid.unw - obvgrid.usw, Vector( 0, offsets[4], 0 ) }, { obvgrid.une, obvgrid.use - obvgrid.une, obvgrid.lne - obvgrid.une, obvgrid.unw - obvgrid.une, Vector( -offsets[5], 0, 0 ) }, { obvgrid.unw, obvgrid.lnw - obvgrid.unw, obvgrid.usw - obvgrid.unw, obvgrid.une - obvgrid.unw, Vector( offsets[6], 0, 0 ) }, }
		cache.aGrid = obvgrid
		cache.aSnap = obvsnap
		cache.aFaces = faces
	end

	local obvgrid = cache.aGrid
	local faces = cache.aFaces
	if not target.locked then
		-- should improve this by expanding the bounding box or something instead!
		-- create a larger bounding box and then planes for each side, and check distance from the plane
		-- separate function perhaps?
		local distance = ( LocalPlayer():GetPos() - target.entity:GetPos() ):Length() - ( obvgrid.unw - obvgrid.lse ):Length()
		if distance > GetConVarNumber( 'snap_distance' ) then return end
		for face, vertices in ipairs( faces ) do
			intersection = RayQuadIntersect( cache.vLookPos, cache.vLookVector, vertices[1], vertices[2], vertices[3] )
			if intersection then
				target.face = face
				break
			end
		end

		if intersection == nil then return end
	end

	if GetConVarNumber( 'snap_boundingbox' ) ~= 0 then
		DrawBoundary( obvgrid.unw, obvgrid.lnw, obvgrid.usw, obvgrid.une )
		DrawBoundary( obvgrid.une, obvgrid.lne, obvgrid.use, obvgrid.unw )
		DrawBoundary( obvgrid.lnw, obvgrid.unw, obvgrid.lsw, obvgrid.lne )
		DrawBoundary( obvgrid.lne, obvgrid.une, obvgrid.lse, obvgrid.lnw )
		DrawBoundary( obvgrid.usw, obvgrid.lsw, obvgrid.unw, obvgrid.use )
		DrawBoundary( obvgrid.use, obvgrid.lse, obvgrid.une, obvgrid.usw )
		DrawBoundary( obvgrid.lsw, obvgrid.usw, obvgrid.lnw, obvgrid.lse )
		DrawBoundary( obvgrid.lse, obvgrid.use, obvgrid.lne, obvgrid.lsw )
	end

	local vectorOrigin = faces[target.face][1]
	local vectorX = faces[target.face][2]
	local vectorY = faces[target.face][3]
	local vectorZ = faces[target.face][4]
	local vectorOffset = faces[target.face][5]
	local vectorGrid
	if not target.locked then
		vectorGrid = vectorOrigin + CalculateSnap( vectorX, vectorY, intersection )
		local trace = util.TraceLine( {
			start = target.entity:LocalToWorld( target.entity:WorldToLocal( vectorGrid ) - vectorOffset ) - vectorZ:GetNormalized() * 0.01,
			endpos = vectorGrid + vectorZ,
		} )

		local vectorSnap = trace.HitPos
		target.offset = target.entity:WorldToLocal( vectorSnap )
		target.vector = target.entity:WorldToLocal( vectorGrid )
		target.error = true
		if trace.Entity == nil or not trace.Entity:IsValid() then
			snaperror = -1
		elseif trace.Entity ~= target.entity then
			snaperror = -2
		elseif trace.HitPos == trace.StartPos then
			snaperror = -2
		else
			snaperror = ( LocalPlayer():GetEyeTrace().HitPos - trace.HitPos ):Length()
			target.error = false
			if ( vectorSnap - vectorGrid ):Length() > 0.5 then
				local marker = PointToScreen( vectorSnap )
				if marker then DrawSnapCross( marker, 255, 255, 255 ) end
			end
		end
	else
		vectorGrid = target.entity:LocalToWorld( target.vector )
		local vectorSnap = target.entity:LocalToWorld( target.offset )
		local marker = PointToScreen( vectorSnap )
		snaperror = ( LocalPlayer():GetEyeTrace().HitPos - vectorSnap ):Length()
		if marker then
			if target.error == true then
				snaperror = -2
				DrawSnapCross( marker, 0, 255, 255 )
			elseif snaperror < 0.001 then
				DrawSnapCross( marker, 0, 255, 0 )
			elseif snaperror < 0.1 then
				DrawSnapCross( marker, 255, 255, 0 )
			else
				DrawSnapCross( marker, 255, 0, 0 )
			end
		end
	end

	if GetConVarNumber( 'snap_hidegrid' ) == 0 then DrawGrid( vectorOrigin, vectorX, vectorY ) end
	target.active = true
	local vsCursor = PointToScreen( vectorGrid )
	if vsCursor then
		if snaperror == -1 then
			target.active = false
			DrawSnapCross( vsCursor, 0, 255, 255 )
		elseif snaperror == -2 then
			DrawSnapCross( vsCursor, 255, 0, 255 )
		elseif snaperror < 0.001 then
			DrawSnapCross( vsCursor, 0, 255, 0 )
		elseif snaperror < 0.1 then
			DrawSnapCross( vsCursor, 255, 255, 0 )
		else
			DrawSnapCross( vsCursor, 255, 0, 0 )
		end
	end
end

local function OnSnapView( player )
	local targetvalid = target.active and target.locked and target.entity:IsValid()
	local snaptargetvalid = snaptarget.active and snaptarget.locked and snaptarget.entity:IsValid()
	if snapcursor and not snapspawnmenu and targetvalid then
		local screen = ToScreen( target.entity:LocalToWorld( target.offset ) )
		gui.SetMousePos( math.Round( screen.x ), math.Round( screen.y ) )
	end

	if not snapcursor and targetvalid then
		return {
			angles = ( target.entity:LocalToWorld( target.offset ) - player:GetShootPos() ):Angle()
		}
	elseif snaplock and snaptargetvalid then
		return {
			angles = ( snaptarget.entity:LocalToWorld( snaptarget.offset ) - player:GetShootPos() ):Angle()
		}
	end
end

local function OnSnapAim( user )
	local targetvalid = target.active and target.locked and target.entity:IsValid() and target.entity:IsPlayer()
	local snaptargetvalid = snaptarget.active and snaptarget.locked and snaptarget.entity:IsValid() and snaptarget.entity:IsPlayer()
	if not snapcursor and targetvalid and player then
		user:SetViewAngles( ( target.entity:LocalToWorld( target.offset ) - LocalPlayer():GetShootPos() ):Angle() )
	elseif snaplock and snaptargetvalid then
		user:SetViewAngles( ( snaptarget.entity:LocalToWorld( snaptarget.offset ) - LocalPlayer():GetShootPos() ):Angle() )
	end
end

concommand.Add( '+snap', SnapPress )
concommand.Add( '-snap', SnapRelease )
concommand.Add( 'snaplock', SnapLock )
concommand.Add( 'snaptogglegrid', SnapToggleGrid )
hook( 'Initialize', 'SmartsnapInitialize', OnInitialize )
hook( 'SpawnMenuOpen', 'SmartsnapSpawnMenu', OnSpawnMenu )
hook( 'Think', 'SmartsnapThink', OnThink )
hook( 'ShutDown', 'SmartsnapShutDown', OnShutDown )
hook( 'KeyPress', 'SmartsnapKeyPress', OnKeyPress )
hook( 'KeyRelease', 'SmartsnapKeyRelease', OnKeyRelease )
hook( 'CreateMove', 'SmartsnapSnap', OnSnapAim )
hook( 'CalcView', 'SmartsnapSnapView', OnSnapView )
hook( 'SpawnMenuOpen', 'SmartsnapSpawnMenu', OnSpawnMenu )
hook( 'HUDPaintBackground', 'SmartsnapPaintHUD', OnPaintHUD )
local function OnPopulateToolPanel( panel )
	panel:AddControl( 'ComboBox', {
		Options = {
			['default'] = condefs
		},
		CVars = convars,
		Label = '',
		MenuButton = '1',
		Folder = 'smartsnap'
	} )

	panel:AddControl( 'CheckBox', {
		Label = 'Enable',
		Command = 'snap_enabled',
	} )

	panel:AddControl( 'CheckBox', {
		Label = 'Use click grid (USE temporarily enables grid)',
		Command = 'snap_clickgrid',
	} )

	panel:AddControl( 'CheckBox', {
		Label = 'Hide grid (only shows snap point)',
		Command = 'snap_hidegrid',
	} )

	panel:AddControl( 'CheckBox', {
		Label = 'Smart toggle enabled',
		Command = 'snap_enabletoggle',
	} )

	panel:AddControl( 'CheckBox', {
		Label = 'Revert aim to grid snap on detach',
		Command = 'snap_revertaim',
	} )

	panel:AddControl( 'CheckBox', {
		Label = 'Enable for all entities',
		Command = 'snap_allentities',
	} )

	panel:AddControl( 'CheckBox', {
		Label = 'Enable for all tools',
		Command = 'snap_alltools',
	} )

	panel:AddControl( 'CheckBox', {
		Label = 'Draw thick center lines',
		Command = 'snap_centerline',
	} )

	panel:AddControl( 'Slider', {
		Label = 'Grid toggle delay (double click snap-key)',
		Command = 'snap_toggledelay',
		Type = 'Float',
		Min = '0.0',
		Max = '0.2',
	} )

	panel:AddControl( 'Slider', {
		Label = 'Smart lock delay',
		Command = 'snap_lockdelay',
		Type = 'Float',
		Min = '0.0',
		Max = '5.0',
	} )

	panel:AddControl( 'CheckBox', {
		Label = 'Bounding box enabled',
		Command = 'snap_boundingbox',
	} )

	panel:AddControl( 'Slider', {
		Label = 'Grid draw distance',
		Command = 'snap_distance',
		Type = 'Integer',
		Min = '50',
		Max = '1000',
	} )

	panel:AddControl( 'Slider', {
		Label = 'Grid edge offset',
		Command = 'snap_gridoffset',
		Type = 'Float',
		Min = '0.0',
		Max = '2.5',
	} )

	panel:AddControl( 'Slider', {
		Label = 'Grid transparency',
		Command = 'snap_gridalpha',
		Type = 'Float',
		Min = '0.1',
		Max = '1.0',
	} )

	panel:AddControl( 'Slider', {
		Label = 'Maximum number of snap points on an axis',
		Command = 'snap_gridlimit',
		Type = 'Integer',
		Min = '2',
		Max = '64',
	} )

	panel:AddControl( 'Slider', {
		Label = 'Minimum distance between each snap point',
		Command = 'snap_gridsize',
		Type = 'Integer',
		Min = '2',
		Max = '64',
	} )

	panel:AddControl( 'Label', {
		Text = ''
	} )

	panel:AddControl( 'Label', {
		Text = 'The following option should prevent FPS drops from occuring, however it might have a slight impact on the average FPS while the grid is showing. Do NOT uncheck this option unless you are experiencing very low FPS or fully understands its purpose.'
	} )

	panel:AddControl( 'Label', {
		Text = 'NOTE: This option is only effective when the grid is showing, it does not impact regular gameplay!'
	} )

	panel:AddControl( 'Label', {
		Text = ''
	} )

	panel:AddControl( 'CheckBox', {
		Label = 'Garbage collection boost',
		Command = 'snap_gcboost',
	} )
end

function OnPopulateToolMenu()
	spawnmenu.AddToolMenuOption( 'Options', 'Player', 'SmartSnapSettings', 'SmartSnap', '', '', OnPopulateToolPanel, {
		SwitchConVar = 'snap_enabled'
	} )
end

hook( 'PopulateToolMenu', 'SmartSnapToolMenu', OnPopulateToolMenu )
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/spawnmenu_cl.lua:

local spawnmenu_border = CreateConVar("spawnmenu_border", "0.1", { FCVAR_ARCHIVE })

local PANEL = {}

--[[---------------------------------------------------------
   Name: Paint
-----------------------------------------------------------]]
function PANEL:Init()

	self.ToolMenu = vgui.Create("ToolMenu", self)
	self.ToolMenu:Dock(RIGHT)
	self.ToolMenu:DockMargin(0, 20, 3, 10)

	self.CreateMenu = vgui.Create("CreationMenu", self)
	self.CreateMenu:Dock(FILL)
	self.CreateMenu:DockMargin(3, 20, 3, 10)

	self.m_bHangOpen = false

	self:SetMouseInputEnabled(true)

	self.ToolToggle = vgui.Create("DImageButton", self)
	self.ToolToggle:SetMaterial("gui/spawnmenu_toggle")
	self.ToolToggle:SetSize(16, 16)
	self.ToolToggle.DoClick = function()

		self.ToolMenu:SetVisible(!self.ToolMenu:IsVisible())
		self:InvalidateLayout()

		if (self.ToolMenu:IsVisible()) then
			self.ToolToggle:SetMaterial("gui/spawnmenu_toggle")
		else
			self.ToolToggle:SetMaterial("gui/spawnmenu_toggle_back")
		end

	end

end


function PANEL:OpenCreationMenuTab(name)

	self.CreateMenu:SwitchToName(name)

end

function PANEL:GetToolMenu()
	return self.ToolMenu;
end

--[[---------------------------------------------------------
   Name: OnClick
-----------------------------------------------------------]]
function PANEL:OnMousePressed()

	self:Close()

end


--[[---------------------------------------------------------
   Name: HangOpen
-----------------------------------------------------------]]
function PANEL:HangOpen(bHang)
	self.m_bHangOpen = bHang
end

--[[---------------------------------------------------------
   Name: HangingOpen
-----------------------------------------------------------]]
function PANEL:HangingOpen()
	return self.m_bHangOpen
end

--[[---------------------------------------------------------
   Name: Paint
-----------------------------------------------------------]]
function PANEL:Open()

	RestoreCursorPosition()

	self.m_bHangOpen = false

	-- If the context menu is open, try to close it..
	if (g_ContextMenu:IsVisible()) then
		g_ContextMenu:Close(true)
	end

	if (self:IsVisible()) then return end

	CloseDermaMenus()

	self:MakePopup()
	self:SetVisible(true)
	self:SetKeyboardInputEnabled(false)
	self:SetMouseInputEnabled(true)
	self:SetAlpha(255)

	-- achievements.SpawnMenuOpen()

end

--[[---------------------------------------------------------
   Name: Paint
-----------------------------------------------------------]]
function PANEL:Close(bSkipAnim)

	if (self.m_bHangOpen) then
		self.m_bHangOpen = false
		return
	end

	RememberCursorPosition()

	CloseDermaMenus()

	self:SetKeyboardInputEnabled(false)
	self:SetMouseInputEnabled(false)
	self:SetVisible(false)

end

--[[---------------------------------------------------------
   Name: PerformLayout
-----------------------------------------------------------]]
function PANEL:PerformLayout()

	self:SetSize(ScrW(), ScrH())
	self:SetPos(0, 0)

	local MarginX = math.Clamp((ScrW() - 1024) * spawnmenu_border:GetFloat(), 25, 256)
	local MarginY = math.Clamp((ScrH() - 768) * spawnmenu_border:GetFloat(), 25, 256)

	self:DockPadding(0, 0, 0, 0)

	self.CreateMenu:DockMargin(MarginX, MarginY, 1, MarginY)
	self.ToolMenu:DockMargin(0, MarginY, MarginX, MarginY)

	self.ToolToggle:AlignRight(6)
	self.ToolToggle:AlignTop(6)

end

--[[---------------------------------------------------------
   Name: StartKeyFocus
-----------------------------------------------------------]]
function PANEL:StartKeyFocus(pPanel)

	self.m_pKeyFocus = pPanel
	self:SetKeyboardInputEnabled(true)
	self:HangOpen(true)

end

--[[---------------------------------------------------------
   Name: EndKeyFocus
-----------------------------------------------------------]]
function PANEL:EndKeyFocus(pPanel)

	if (self.m_pKeyFocus != pPanel) then return end
	self:SetKeyboardInputEnabled(false)

end

vgui.Register("SpawnMenu", PANEL, "EditablePanel")


--[[---------------------------------------------------------
   Called to create the spawn menu..
-----------------------------------------------------------]]
local function CreateSpawnMenu()

	-- If we have an old spawn menu remove it.
	if (IsValid(g_SpawnMenu)) then

		g_SpawnMenu:Remove()
		g_SpawnMenu = nil

	end

	-- Start Fresh
	spawnmenu.ClearToolMenus()

	-- Add defaults for the gamemode. In sandbox these defaults
	-- are the Main/Postprocessing/Options tabs.
	-- They're added first in sandbox so they're always first
	hook.Run("AddGamemodeToolMenuTabs")

	-- Use this hook to add your custom tools
	-- This ensures that the default tabs are always
	-- first.
	hook.Run("AddToolMenuTabs")

	-- Use this hook to add your custom tools
	-- We add the gamemode tool menu categories first
	-- to ensure they're always at the top.
	hook.Run("AddGamemodeToolMenuCategories")
	hook.Run("AddToolMenuCategories")

	-- Add the tabs to the tool menu before trying
	-- to populate them with tools.
	hook.Run("PopulateToolMenu")

	g_SpawnMenu = vgui.Create("SpawnMenu")
	g_SpawnMenu:SetVisible(false)

	CreateContextMenu()

	hook.Run("PostReloadToolsMenu")

end
-- Hook to create the spawnmenu at the appropriate time (when all sents and sweps are loaded)
hook("OnGamemodeLoaded", "CreateSpawnMenu", CreateSpawnMenu)
concommand.Add("spawnmenu_reload", CreateSpawnMenu)

function GM:OnSpawnMenuOpen()

	-- Let the gamemode decide whether we should open or not..
	if (!hook.Call("SpawnMenuOpen", GAMEMODE)) then return end

	if (IsValid(g_SpawnMenu)) then

		g_SpawnMenu:Open()
	end

end

function GM:OnSpawnMenuClose()

	if (IsValid(g_SpawnMenu)) then g_SpawnMenu:Close() end

	-- We're dragging from the spawnmenu but the spawnmenu is closed
	-- so keep the dragging going using the screen clicker
	if (dragndrop.IsDragging()) then
		gui.EnableScreenClicker(true)
	end

end

--[[---------------------------------------------------------
   Name: HOOK SpawnMenuKeyboardFocusOn
		Called when text entry needs keyboard focus
-----------------------------------------------------------]]
local function SpawnMenuKeyboardFocusOn(pnl)

	if (IsValid(g_SpawnMenu ) && IsValid(pnl) && pnl:HasParent(g_SpawnMenu)) then
		g_SpawnMenu:StartKeyFocus(pnl)
	end
	if (IsValid(g_ContextMenu ) && IsValid(pnl) && pnl:HasParent(g_ContextMenu)) then
		g_ContextMenu:StartKeyFocus(pnl)
	end

end
hook("OnTextEntryGetFocus", "SpawnMenuKeyboardFocusOn", SpawnMenuKeyboardFocusOn)


--[[---------------------------------------------------------
   Name: HOOK SpawnMenuKeyboardFocusOff
		Called when text entry stops needing keyboard focus
-----------------------------------------------------------]]
local function SpawnMenuKeyboardFocusOff(pnl)

	if (IsValid(g_SpawnMenu ) && IsValid(pnl) && pnl:HasParent(g_SpawnMenu)) then
		g_SpawnMenu:EndKeyFocus(pnl)
	end

	if (IsValid(g_ContextMenu ) && IsValid(pnl) && pnl:HasParent(g_ContextMenu)) then
		g_ContextMenu:EndKeyFocus(pnl)
	end

end
hook("OnTextEntryLoseFocus", "SpawnMenuKeyboardFocusOff", SpawnMenuKeyboardFocusOff)

--[[---------------------------------------------------------
   Name: HOOK SpawnMenuOpenGUIMousePressed
		Don't do context screen clicking if spawnmenu is open
-----------------------------------------------------------]]
local function SpawnMenuOpenGUIMousePressed()

	if (!IsValid(g_SpawnMenu)) then return end
	if (!g_SpawnMenu:IsVisible()) then return end

	return true

end
hook("GUIMousePressed", "SpawnMenuOpenGUIMousePressed", SpawnMenuOpenGUIMousePressed)

--[[---------------------------------------------------------
   Name: HOOK SpawnMenuOpenGUIMousePressed
		Close spawnmenu if it's open
-----------------------------------------------------------]]
local function SpawnMenuOpenGUIMouseReleased()

	if (!IsValid(g_SpawnMenu)) then return end
	if (!g_SpawnMenu:IsVisible()) then return end

	g_SpawnMenu:Close()

	return true

end

hook("GUIMouseReleased", "SpawnMenuOpenGUIMouseReleased", SpawnMenuOpenGUIMouseReleased)
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/controls/control_presets_cl.lua:
--
--  ___  ___   _   _   _    __   _   ___ ___ __ __
-- |_ _|| __| / \ | \_/ |  / _| / \ | o \ o \\ V /
--  | | | _| | o || \_/ | ( |_n| o ||   /   / \ /
--  |_| |___||_n_||_| |_|  \__/|_n_||_|\\_|\\ |_|  2009
--
--

local PANEL = {}

--[[---------------------------------------------------------
   Name: Init
-----------------------------------------------------------]]
function PANEL:Init()

	self.DropDown = vgui.Create("DComboBox", self)
	self.DropDown.OnSelect = function(dropdown, index, value, data ) self:OnSelect(index, value, data) end
	self.DropDown:SetText("Presets")
	self.DropDown:Dock(FILL)

	-- TODO: ICON!
	self.Button = vgui.Create("DImageButton", self)
	self.Button.DoClick = function() self:OpenPresetEditor() end
	self.Button:Dock(RIGHT)
	self.Button:SetMaterial("icon16/wrench.png")
	self.Button:SetStretchToFit(false)
	self.Button:SetSize(20, 20)
	self.Button:DockMargin(5, 0, 0, 0)

	self:SetTall(20)

	self.Options = {}
	self.ConVars = {}

end


--[[---------------------------------------------------------
   Name: SetLabel
-----------------------------------------------------------]]
function PANEL:SetLabel(strName)

	self.Label:SetText(strName)

end


--[[---------------------------------------------------------
   Name: AddOption
-----------------------------------------------------------]]
function PANEL:AddOption(strName, data)

	self.DropDown:AddChoice(strName, data)

	self.Options[ strName ] = data

end

--[[---------------------------------------------------------
   Name: SetOptions
    these are options given to by the CPanel (usually just defaults)
-----------------------------------------------------------]]
function PANEL:SetOptions(Options)
	if Options then
		table.Merge(self.Options, Options)
	end
end

--[[---------------------------------------------------------
   Name: OnSelect
-----------------------------------------------------------]]
function PANEL:OnSelect(index, value, data)

	if (!data) then return end

	for k, v in pairs(data) do
		RunConsoleCommand(k, v)
	end

end


--[[---------------------------------------------------------
   Name: OpenPresetEditor
-----------------------------------------------------------]]
function PANEL:OpenPresetEditor()

	if (!self.m_strPreset) then return end

	self.Window = vgui.Create("PresetEditor")
	self.Window:MakePopup()
	self.Window:Center()
	self.Window:SetType(self.m_strPreset)
	self.Window:SetConVars(self.ConVars)
	self.Window:SetPresetControl(self)

end

--[[---------------------------------------------------------
   Add A ConVar to store
-----------------------------------------------------------]]
function PANEL:AddConVar(convar)

	table.insert(self.ConVars, convar)

end


--[[---------------------------------------------------------
   Name: GetConVars
-----------------------------------------------------------]]
function PANEL:GetConVars(convar)

	return self.ConVars

end


--[[---------------------------------------------------------
   Name: SetPreset
-----------------------------------------------------------]]
function PANEL:SetPreset(strName)

	self.m_strPreset = strName
	self:ReloadPresets()

end


--[[---------------------------------------------------------
   Name: ReloadPresets
-----------------------------------------------------------]]
function PANEL:ReloadPresets()
	self:Clear()

	for name, data in pairs(self.Options) do
		self:AddOption(name, data)
	end

	local Presets = presets.GetTable(self.m_strPreset)
	local sortedPresets, i = {}, 1
	for name in pairs(Presets) do
		sortedPresets[i] = name
		i = i + 1
	end
	table.sort(sortedPresets)

	for _, name in ipairs(sortedPresets) do
		self.DropDown:AddChoice(name, Presets[ name ])
	end

end

--[[---------------------------------------------------------
   Name: Update
-----------------------------------------------------------]]
function PANEL:Update()

	self:ReloadPresets()

end

--[[---------------------------------------------------------
   Name: Clear
-----------------------------------------------------------]]
function PANEL:Clear()

	self.DropDown:Clear()

end



vgui.Register("ControlPresets", PANEL, "Panel")
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/creationmenu/content/contentheader_cl.lua:


surface.CreateFont( "ContentHeader",
{
	font		= "Helvetica",
	size		= 50,
	weight		= 1000
})


local PANEL = {}

--[[--------------------------------------------------------
   Name: Init
---------------------------------------------------------]]

function PANEL:Init()

	self:SetFont("ContentHeader")
	self:SetBright(true)
	self:SetExpensiveShadow(2, Color(0, 0, 0, 130))

	self:SetSize(64, 64)

	self.OwnLine = true

end

function PANEL:PerformLayout()

	self:SizeToContents();
	self:SetTall(64)

end

function PANEL:ToTable(bigtable)

	local tab = {}

	tab.type	= "header"
	tab.text	= self:GetText();

	table.insert(bigtable, tab)

end

function PANEL:Copy()

	local copy = vgui.Create("ContentHeader", self:GetParent())
	copy:SetText(self:GetText())
	copy:CopyBounds(self)

	return copy;

end

function PANEL:PaintOver(w, h)

	self:DrawSelections()

end

function PANEL:DoRightClick()
	local pCanvas = self:GetSelectionCanvas()
	if (IsValid(pCanvas) && pCanvas:NumSelectedChildren() > 0) then
		return hook.Run("SpawnlistOpenGenericMenu", pCanvas)
	end

	self:OpenMenu()
end

function PANEL:OpenMenu()
	local menu = DermaMenu()
		menu:AddOption("Delete", function() self:Remove(); hook.Run("SpawnlistContentChanged", self) end)
	menu:Open()
end

vgui.Register("ContentHeader", PANEL, "DLabelEditable")


spawnmenu.AddContentType("header", function(container, obj)

	if (!obj.text || !isstring(obj.text)) then return end

	local label = vgui.Create("ContentHeader", container)
	label:SetText(obj.text)

	container:Add(label)

end )
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/creationmenu/content/contentsearch_cl.lua:
if (!CONTENTSEARCHLOAD) then return end

AddCSLuaFile()

PANEL.Base = "Panel"

local ContentPanel = nil

function PANEL:Init()

	self:Dock(TOP)
	self:SetHeight(20)
	self:DockMargin(0, 0, 0, 3)

	self.Search = self:Add("DTextEntry")
	self.Search:Dock(FILL)
	--self.Search:SetWidth(150)

	self.Search.OnEnter = function() self:RefreshResults() end
	self.Search.OnFocusChanged = function(_, b ) if (b) then self:RefreshResults() end end
	self.Search:SetTooltip("Press enter to search")

	local btn = self.Search:Add("DImageButton")

	btn:SetImage("icon16/magnifier.png")
	btn:SetText("")
	btn:Dock(RIGHT)
	btn:DockMargin(4, 2, 4, 2)
	btn:SetSize(16, 16)
	btn:SetTooltip("Press to search")
	btn.DoClick = function()
		self:RefreshResults()
	end

	self.Search.OnKeyCode = function(p, code)

		if (code == KEY_F1 ) then hook.Run("OnSpawnMenuClose") end
		if (code == KEY_ESCAPE ) then hook.Run("OnSpawnMenuClose") end

	end

	hook("StartSearch", "StartSearch", function()

		if (g_SpawnMenu:IsVisible() ) then return hook.Run("OnSpawnMenuClose") end

		hook.Run("OnSpawnMenuOpen")
		hook.Run("OnTextEntryGetFocus", self.Search)

		self.Search:RequestFocus()
		self.Search:SetText("")

		--
		-- If we don't call this we'd have to press F1 twice to close it!
		-- It's in a timer because of some good reason that!
		--
		timer.Simple(0.1, function() g_SpawnMenu:HangOpen(false) end)

		ContentPanel:SwitchPanel(self.PropPanel)

	end);

	hook("SearchUpdate", "SearchUpdate", function()

		if (!g_SpawnMenu:IsVisible()) then return end
		self:RefreshResults()

	end);

	self.PropPanel = vgui.Create("ContentContainer", self)
	self.PropPanel:SetVisible(false)
	self.PropPanel:SetTriggerSpawnlistChange(false)

	g_SpawnMenu.SearchPropPanel = self.PropPanel

end

function PANEL:RefreshResults()

	local text = self.Search:GetText()
	if (text == "" or text:len() <= 2) then return end

	self.PropPanel:Clear()

	local results = search.GetResults(text)

	local Header = self:Add("ContentHeader")
		Header:SetText(#results .. " Results for \"".. text .."\"")
		self.PropPanel:Add(Header)

	for k, v in pairs(results) do
		self:AddSearchResult(v.text, v.func, v.icon)
	end

	self.PropPanel:SetParent(ContentPanel)
	ContentPanel:SwitchPanel(self.PropPanel)

end

function PANEL:AddSearchResult(text, func, icon)

	if (!IsValid(icon)) then return end

	icon:SetParent(self.PropPanel)
	self.PropPanel:Add(icon)

end


hook("PopulateContent", "AddSearchContent", function(pnlContent, tree, node)

	-- Add a node to the tree
	--local node = tree:AddNode("Search", "icon16/magnifier.png")

	-- If we click on the node populate it and switch to it.
	--node.DoClick = function(self)

	--	self:DoPopulate()
	--	pnlContent:SwitchPanel(self.PropPanel)

	--end

	ContentPanel = pnlContent

end )
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/creationmenu/content/contenttypes/entities_cl.lua:
hook("PopulateEntities", "AddEntityContent", function(pnlContent, tree, node)

	local Categorised = {}

	-- Add this list into the tormoil
	local SpawnableEntities = list.Get("SpawnableEntities")
	if (SpawnableEntities) then
		for k, v in pairs(SpawnableEntities) do

			v.SpawnName = k
			v.Category = v.Category or "Other"
			Categorised[ v.Category ] = Categorised[ v.Category ] or {}
			table.insert(Categorised[ v.Category ], v)

		end
	end

	--
	-- Add a tree node for each category
	--
	for CategoryName, v in SortedPairs(Categorised) do

		-- Add a node to the tree
		local node = tree:AddNode(CategoryName, "icon16/bricks.png")

			-- When we click on the node - populate it using this function
		node.DoPopulate = function(self)

			-- If we've already populated it - forget it.
			if (self.PropPanel) then return end

			-- Create the container panel
			self.PropPanel = vgui.Create("ContentContainer", pnlContent)
			self.PropPanel:SetVisible(false)
			self.PropPanel:SetTriggerSpawnlistChange(false)

			for k, ent in SortedPairsByMemberValue(v, "PrintName") do

				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel,
				{
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.SpawnName,
					material	= "entities/"..ent.SpawnName..".png",
					admin		= ent.AdminOnly

				})

			end

		end

		-- If we click on the node populate it and switch to it.
		node.DoClick = function(self)

			self:DoPopulate()
			pnlContent:SwitchPanel(self.PropPanel)

		end

	end

	-- Select the first node
	local FirstNode = tree:Root():GetChildNode(0)
	if (IsValid(FirstNode)) then
		FirstNode:InternalDoClick()
	end

end )


spawnmenu.AddCreationTab("#spawnmenu.category.entities", function()

	local ctrl = vgui.Create("SpawnmenuContentPanel")
	ctrl:CallPopulateHook("PopulateEntities")

	return ctrl

end, "icon16/bricks.png", 20, nil, function() return IsValid(LocalPlayer()) and LocalPlayer():IsSuperAdmin() end )
--PATH gamemodes/darkrp/gamemode/modules/context/cl_init.lua:
local sc
hook.Add( 'OnContextMenuClose', 'CMenuOnContextMenuClose', function()
	if IsValid( c_fr ) then c_fr:Close() end
	if IsValid( r_fr ) then r_fr:Close() end
	if IsValid( c_rplaws ) then c_rplaws:Remove() end
	if LocalPlayer():IsHitman() and IsValid( hit_menus ) then hit_menus:Remove() end
end )

local function c_button( data )
	local bt = vgui.Create( 'onyx.Button', sc )
	bt:Dock( TOP )
	bt:DockMargin( 2, 2, 2, 2 )
	bt:SetSize( 300, 25 )
	bt:SetText( data.Title )
	bt.DoClick = function() data.Function( data ) end
	return bt
end

local function category( name )
	local bt = vgui.Create( 'onyx.Label', sc )
	bt:SetSize( 300, 30 )
	bt:Dock( TOP )
	bt:CenterText()
	bt:DockMargin( 2, 2, 2, 2 )
	bt:SetText( name )
end

local function left_cmenu()
	local size = 40
	if IsValid( fr ) then fr:Remove() end
	c_fr = vgui.Create( 'onyx.Frame' )
	c_fr:SetTitle( 'Меню Сервера' )
	c_fr:MakePopup( true )
	c_fr:ShowCloseButton( false )
	c_fr:SetSize( 300, 200 )
	sc = vgui.Create( 'onyx.ScrollPanel', c_fr )
	sc:Dock( FILL )
	category( 'Основне' )
	local bt = c_button( {
		Title = 'Викинути Гроші',
		Icon = 'icon16/money.png',
		Function = function( data ) onyx.SimpleQuery( data.Title, 'Скільки Ви хочете викинути грошей?', true, function( num ) RunConsoleCommand( 'dropmoney', num ) end, 'Так', nil, 'Ні' ) end
	} )

	local bt = c_button( {
		Title = 'Передати Гроші',
		Icon = 'icon16/money.png',
		Function = function( data ) onyx.SimpleQuery( data.Title, 'Скільки Ви хочете передати грошей?', true, function( num ) RunConsoleCommand( 'givemoney', num ) end, 'Так', nil, 'Ні' ) end
	} )

	local bt = c_button( {
		Title = 'Викинути зброю',
		Icon = 'icon16/gun.png',
		Function = function() RunConsoleCommand( 'drop' ) end
	} )

	local bt = c_button( {
		Title = 'Купити набої для зброї',
		Icon = 'icon16/gun.png',
		Function = function()
			if not LocalPlayer():GetActiveWeapon().Primary then return end
			RunConsoleCommand( 'buyammo', LocalPlayer():GetActiveWeapon().Primary.Ammo )
		end,
		function()
			return IsValid( LocalPlayer():GetActiveWeapon() ) and istable( LocalPlayer():GetActiveWeapon().Primary ) and LocalPlayer():GetActiveWeapon().Primary.Ammo --[[ and fn.Head(fn.Filter(function(x) return x.ammoType == LocalPlayer():GetActiveWeapon().Primary.Ammo end, GAMEMODE.AmmoTypes))]]
		end
	} )

	local bt = c_button( {
		Title = 'Змінити Ім\'я',
		Icon = 'icon16/user.png',
		Function = function( data ) onyx.SimpleQuery( data.Title, 'Як вас будуть звати?', true, function( text ) RunConsoleCommand( 'rpname', text ) end, 'Так', nil, 'Ні' ) end
	} )

	local bt = c_button( {
		Title = 'Додати товариша до кейпаду',
		Icon = 'icon16/user_add.png',
		Function = function() RunConsoleCommand( 'ukrp_keypads_addfriends' ) end
	} )

	category( 'Додаткове' )
	local bt = c_button( {
		Title = 'Викликати Адміністратора',
		Icon = 'icon16/user_gray.png',
		Function = function( data ) onyx.SimpleQuery( data.Title, 'Напишіть на що скаржитесь', true, function( text ) RunConsoleCommand( 'say', '@ ' .. text ) end, 'Так', nil, 'Ні' ) end
	} )

	local bt = c_button( {
		Title = 'Донат',
		Icon = 'icon16/money_dollar.png',
		Function = function() RunConsoleCommand( 'say', '/donate' ) end
	} )

	category( 'Дії' )
	local bt = c_button( {
		Title = 'Ролл',
		Icon = 'icon16/controller.png',
		Function = function() RunConsoleCommand( 'say', '/roll' ) end
	} )

	local bt = c_button( {
		Title = 'Особисте повідомлення',
		Icon = 'icon16/user.png',
		Function = function( data ) onyx.ChoosePlayer( data.Title, 'Виберіть людину, якій хочете написати в лс', function( pl ) onyx.SimpleQuery( data.Title, 'Що ви хочете повідомити?', true, function( text ) RunConsoleCommand( 'sam', 'pm', pl:SteamID64(), text ) end, 'Так', nil, 'Ні' ) end, nil ) end
	} )

	category( 'Продажі' )
	local bt = c_button( {
		Title = 'Продати перед вами',
		Icon = 'icon16/money_dollar.png',
		Function = function() RunConsoleCommand( 'sell' ) end
	} )

	local bt = c_button( {
		Title = 'Продати всі предмети',
		Icon = 'icon16/money_dollar.png',
		Function = function() RunConsoleCommand( 'sellallents' ) end
	} )

	local bt = c_button( {
		Title = 'Продати всі Двері',
		Icon = 'icon16/door.png',
		Function = function( data ) onyx.SimpleQuery( data.Title, 'Ви впевнені що хочете продати двері?', false, function() RunConsoleCommand( 'sellall' ) end, 'Так', nil, 'Ні' ) end
	} )

	size = size + 4 * 4 + 30 * 4 + 25 * 14 + 4 * 14
	rgqw = bt
	if LocalPlayer():IsPolice() then
		category( 'Поліція' )
		local bt = c_button( {
			Title = 'Об\'явити у Розшук',
			Icon = 'icon16/shield.png',
			Function = function( data ) onyx.ChoosePlayer( data.Title, 'Виберіть людину, на яку хочете подати розшук', function( pl ) onyx.SimpleQuery( data.Title, 'Причина розшуку?', true, function( text ) RunConsoleCommand( 'wanted', pl:SteamID64(), text ) end, 'Так', nil, 'Ні' ) end, nil, function( ply ) return not ply:IsPolice() and not ply:IsWanted() and ply:Team() ~= TEAM_ADMIN end ) end
		} )

		local bt = c_button( {
			Title = 'Зняти Розшук',
			Icon = 'icon16/shield.png',
			Function = function( data ) onyx.ChoosePlayer( data.Title, 'Виберіть людину, з якої хочете зняти розшук', function( pl ) RunConsoleCommand( 'unwanted', pl:Name() ) end, nil, function( ply ) return ply:IsWanted() end ) end
		} )

		size = size + 2 * 25 + 2 * 4 + 30 + 4
	end

	if LocalPlayer():IsMayor() then
		category( 'Мер' )
		local bt = c_button( {
			Title = 'Оголосити Комендантську Годину',
			Function = function() RunConsoleCommand( 'lockdown' ) end
		} )

		local bt = c_button( {
			Title = 'Закінчити Комендантську Годину',
			Function = function() RunConsoleCommand( 'unlockdown' ) end
		} )

		local bt = c_button( {
			Title = 'Запустити лотерею',
			Icon = 'icon16/page_white_text.png',
			Function = function() onyx.SimpleQuery( 'Лотерея', 'Сума, на яку ви хочете запустити?', true, function( num ) RunConsoleCommand( 'lottery', num ) end, 'Так', nil, 'Ні' ) end
		} )

		local bt = c_button( {
			Title = 'Оголошення для Громадян',
			Icon = 'icon16/user.png',
			Function = function( data )
				onyx.SimpleQuery( data.Title, 'Що ви хочете повідомити?', true, function( text )
					net.Start( 'mervisral' )
					net.WriteString( text )
					net.SendToServer()
				end, 'Так', nil, 'Ні' )
			end
		} )

		local bt = c_button( {
			Title = 'Видати ліцензію',
			Icon = 'icon16/page_white_text.png',
			Function = function( data ) onyx.ChoosePlayer( data.Title, 'Виберіть людину, якій хочете видати ліцензію', function( pl ) RunConsoleCommand( 'give_licence', pl:SteamID64() ) end, nil ) end
		} )

		local bt = c_button( {
			Title = 'Редагувати закони',
			Icon = 'icon16/lock.png',
			Function = function() RunConsoleCommand( 'lawmenu' ) end
		} )

		size = size + 6 * 25 + 6 * 4 + 30 + 4
	end

	c_fr:SetTall( size )
	c_fr:CenterVertical()
end

function IsMayor( pl )
	if pl:IsMayor() then
		return true
	else
		return false
	end
end

hook.Add( 'OnContextMenuOpen', 'CMenuOnContextMenuOpen', function()
	if not IsValid( c_rplaws ) then c_rplaws = vgui.Create( 'rp.laws' ) end
	if LocalPlayer():IsHitman() then
		local tb = nw.GetGlobal( 'Hitman_Table' ) or {}
		--PrintTable(tb)
		hit_menus = TDLib( 'onyx.Frame' )
		hit_menus:SetSize( 500, ScrH() )
		hit_menus:SetTitle( 'ЗАМОВЛЕННЯ' )
		hit_menus.colorBG = ColorAlpha( onyx.OffsetColor( onyx:Config( 'colors.primary' ), -5 ), 100 )
		hit_menus:ShowCloseButton( false )
		hit_menus:SetPos( ScrW() - 500 )
		local players = {}
		local cost = 0
		for _, v in player.Iterator() do
			if v:IsHitman() then continue end
			if table.HasValue( tb, v ) then
				table.insert( players, v )
				cost = cost + 1
			end
		end

		for _, v in ipairs( players ) do
			if not istable( v ) and IsValid( v ) and cost ~= 0 then
				local bt = hit_menus:Add( 'onyx.Button' )
				bt:Dock( 4 )
				bt:DockMargin( 0, 0, 0, 5 )
				bt:SetText( v:Name() )
				bt:SetColorHover( Color( rp.Team[v:Team()].Color.r, rp.Team[v:Team()].Color.g, rp.Team[v:Team()].Color.b, 100 ) )
				bt:SetTall( 40 )
				local bt = bt:Add( 'onyx.Button' )
				bt:Dock( 3 )
				bt:DockMargin( 0, 0, 0, 0 )
				bt:SetText( rp.FormatMoney( tonumber( v:onyx_GetNetVar( 'Hitman_Money' ) or 0 ) ) )
			end
		end
	end

	local ent = LocalPlayer():GetEyeTrace().Entity
	if IsValid( ent ) and ent:GetClass() == 'mediaplayer_tv' then return end
	left_cmenu()
end )
--PATH gamemodes/darkrp/entities/weapons/gmod_tool/stools/colour.lua:
TOOL.Category = 'Render'
TOOL.Name = '#tool.colour.name'

TOOL.ClientConVar[ 'r' ] = 255
TOOL.ClientConVar[ 'g' ] = 0
TOOL.ClientConVar[ 'b' ] = 255
TOOL.ClientConVar[ 'a' ] = 255
-- qwth 
local function SetColour(Player, Entity, Data)
	if (Data.Color ) then Entity:SetColor(Color(Data.Color.r, Data.Color.g, Data.Color.b, math.Clamp(Data.Color.a, 25, 255))) end

	if (SERVER) then
		duplicator.StoreEntityModifier(Entity, 'colour', Data)
	end
end
duplicator.RegisterEntityModifier('colour', SetColour)

function TOOL:LeftClick(trace)
	local ent = trace.Entity
	if (IsValid(ent.AttachedEntity)) then ent = ent.AttachedEntity end

	if IsValid(ent) then

		if (CLIENT) then return true end

		local r = self:GetClientNumber('r', 0)
		local g = self:GetClientNumber('g', 0)
		local b = self:GetClientNumber('b', 0)
		local a = self:GetClientNumber('a', 0)

		if (r < 20) and (g < 20) and (b < 20) then
			r, g, b = 20, 20, 20
		end

		SetColour(self:GetOwner(), ent, { Color = Color(r, g, b, a)})

		return true

	end
end

function TOOL:RightClick(trace)
	local ent = trace.Entity
	if IsValid(ent.AttachedEntity) then ent = ent.AttachedEntity end

	if IsValid(ent) then

		if (CLIENT) then return true end

		SetColour(self:GetOwner(), ent, { Color = Color(255, 255, 255, 255), RenderMode = 0, RenderFX = 0 })
		return true

	end
end

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel(CPanel)
	CPanel:AddControl('Header', {Description	= '#tool.colour.desc'})
	CPanel:AddControl('ComboBox', {MenuButton = 1, Folder = 'colour', Options = {['#preset.default'] = ConVarsDefault }, CVars = table.GetKeys(ConVarsDefault)})
	CPanel:AddControl('Color', {Label = '#tool.colour.color', Red = 'colour_r', Green = 'colour_g', Blue = 'colour_b', Alpha = 'colour_a'})
end
--PATH gamemodes/darkrp/entities/weapons/gmod_tool/stools/material.lua:
TOOL.Category = "Render"
TOOL.Name = "#tool.material.name"

TOOL.ClientConVar[ "override" ] = "debug/env_cubemap_model"

--
-- Duplicator function
--
local function SetMaterial(Player, Entity, Data)

	if (SERVER) then

		--
		-- Make sure this is in the 'allowed' list in multiplayer - to stop people using exploits
		--
		if (!game.SinglePlayer() && !list.Contains("OverrideMaterials", Data.MaterialOverride) && Data.MaterialOverride != "") then return end

		Entity:SetMaterial(Data.MaterialOverride)
		duplicator.StoreEntityModifier(Entity, "material", Data)
	end

	return true

end
duplicator.RegisterEntityModifier("material", SetMaterial)

--
-- Left click applies the current material
--
function TOOL:LeftClick(trace)

	if (!IsValid(trace.Entity)) then return end

	if (CLIENT) then return true end

	local ent = trace.Entity
	if (IsValid(ent.AttachedEntity)) then ent = ent.AttachedEntity end

	local mat = self:GetClientInfo("override")
	SetMaterial(self:GetOwner(), ent, { MaterialOverride = mat })
	return true

end

--
-- Right click reverts the material
--
function TOOL:RightClick(trace)

	if (!IsValid(trace.Entity)) then return end

	if (CLIENT) then return true end

	local ent = trace.Entity
	if (IsValid(ent.AttachedEntity)) then ent = ent.AttachedEntity end

	SetMaterial(self:GetOwner(), ent, { MaterialOverride = "" })
	return true

end

function TOOL.BuildCPanel( CPanel )

	CPanel:AddControl( "Header", { Description = "#tool.material.help" } )

	local filter = CPanel:AddControl( "TextBox", { Label = "#spawnmenu.quick_filter_tool" } )
	filter:SetUpdateOnType( true )

	-- Remove duplicate materials. table.HasValue is used to preserve material order
	local materials = {}
	for id, str in pairs( list.Get( "OverrideMaterials" ) ) do
		if ( !table.HasValue( materials, str ) ) then
			table.insert( materials, str )
		end
	end

	local matlist = CPanel:MatSelect( "material_override", materials, true, 0.25, 0.25 )

	filter.OnValueChange = function( s, txt )
		for id, pnl in pairs( matlist.Controls ) do
			if ( !pnl.Value:lower():find( txt:lower() ) ) then
				pnl:SetVisible( false )
			else
				pnl:SetVisible( true )
			end
		end
		matlist:InvalidateChildren()
		CPanel:InvalidateChildren()
	end
end


--list.Add("OverrideMaterials", "Models/effects/comball_sphere")
--list.Add("OverrideMaterials", "Models/effects/comball_tape")
--list.Add("OverrideMaterials", "Models/effects/splodearc_sheet")
--list.Add("OverrideMaterials", "Models/effects/vol_light001")
--list.Add("OverrideMaterials", "models/props_combine/portalball001_sheet")
--list.Add("OverrideMaterials", "models/rendertarget")
--list.Add("OverrideMaterials", "models/airboat/airboat_blur02")
--list.Add("OverrideMaterials", "models/effects/splode1_sheet")
--list.Add("OverrideMaterials", "models/effects/portalrift_sheet")
--list.Add("OverrideMaterials", "models/props_combine/stasisfield_beam")
--list.Add("OverrideMaterials", "models/weapons/v_smg1/texture5")
--list.Add("OverrideMaterials", "models/props_c17/fisheyelens")
--list.Add("OverrideMaterials", "models/effects/comball_glow1")
--list.Add("OverrideMaterials", "models/effects/comball_glow2")
--list.Add("OverrideMaterials", "models/props_combine/stasisfield_beam")
--list.Add("OverrideMaterials", "models/alyx/emptool_glow")
--list.Add("OverrideMaterials", "models/roller/rollermine_glow")
--list.Add("OverrideMaterials", "models/airboat/airboat_blur02")
--list.Add("OverrideMaterials", "models/vortigaunt/pupil")
--list.Add("OverrideMaterials", "phoenix_storms/simplyMetallic2")
--list.Add("OverrideMaterials", "models/weapons/w_smg1/smg_crosshair")
--list.Add("OverrideMaterials", "phoenix_storms/mat/mat_phx_carbonfiber2")
--list.Add("OverrideMaterials", "models/props_c17/frostedglass_01a_dx60")

list.Add("OverrideMaterials", "models/wireframe")
list.Add("OverrideMaterials", "debug/env_cubemap_model")
list.Add("OverrideMaterials", "models/shadertest/shader3")
list.Add("OverrideMaterials", "models/shadertest/shader4")
list.Add("OverrideMaterials", "models/shadertest/shader5")
list.Add("OverrideMaterials", "models/shiny")
list.Add("OverrideMaterials", "models/debug/debugwhite")
list.Add("OverrideMaterials", "models/props_combine/stasisshield_sheet")
list.Add("OverrideMaterials", "models/props_combine/com_shield001a")
list.Add("OverrideMaterials", "models/props_c17/frostedglass_01a")
list.Add("OverrideMaterials", "models/props_lab/Tank_Glass001")
list.Add("OverrideMaterials", "models/props_combine/tprings_globe")
list.Add("OverrideMaterials", "models/screenspace")
list.Add("OverrideMaterials", "brick/brick_model")
list.Add("OverrideMaterials", "models/props_pipes/GutterMetal01a")
list.Add("OverrideMaterials", "models/props_pipes/Pipesystem01a_skin3")
list.Add("OverrideMaterials", "models/props_wasteland/wood_fence01a")
list.Add("OverrideMaterials", "models/props_foliage/tree_deciduous_01a_trunk")
list.Add("OverrideMaterials", "models/props_c17/FurnitureFabric003a")
list.Add("OverrideMaterials", "models/props_c17/FurnitureMetal001a")
list.Add("OverrideMaterials", "models/props_c17/paper01")
list.Add("OverrideMaterials", "models/flesh")
list.Add("OverrideMaterials", "phoenix_storms/metalset_1-2")
list.Add("OverrideMaterials", "phoenix_storms/metalfloor_2-3")
list.Add("OverrideMaterials", "phoenix_storms/plastic")
list.Add("OverrideMaterials", "phoenix_storms/wood")
list.Add("OverrideMaterials", "phoenix_storms/bluemetal")
list.Add("OverrideMaterials", "phoenix_storms/cube")
list.Add("OverrideMaterials", "phoenix_storms/dome")
list.Add("OverrideMaterials", "phoenix_storms/gear")
list.Add("OverrideMaterials", "phoenix_storms/stripes")
list.Add("OverrideMaterials", "phoenix_storms/wire/pcb_green")
list.Add("OverrideMaterials", "phoenix_storms/wire/pcb_red")
list.Add("OverrideMaterials", "phoenix_storms/wire/pcb_blue")
list.Add("OverrideMaterials", "hunter/myplastic")
list.Add("OverrideMaterials", "models/XQM/LightLinesRed_tool")
list.Add("OverrideMaterials", "models/XQM//Deg360")
list.Add("OverrideMaterials", "models/XQM//LightLinesGB")
list.Add("OverrideMaterials", "models/XQM//LightLinesRed")
list.Add("OverrideMaterials", "models/XQM//SquaredMat")
list.Add("OverrideMaterials", "models/XQM//WoodTexture_1")
list.Add("OverrideMaterials", "models/antlion/antlion_innards")
list.Add("OverrideMaterials", "models/barnacle/roots")
list.Add("OverrideMaterials", "models/combine_advisor/body9")
list.Add("OverrideMaterials", "models/combine_advisor/mask")
list.Add("OverrideMaterials", "models/combine_scanner/scanner_eye")
list.Add("OverrideMaterials", "models/dog/eyeglass")
list.Add("OverrideMaterials", "models/effects/slimebubble_sheet")
list.Add("OverrideMaterials", "models/effects/splode_sheet")
list.Add("OverrideMaterials", "models/gibs/metalgibs/metal_gibs")
list.Add("OverrideMaterials", "models/gibs/woodgibs/woodgibs01")
list.Add("OverrideMaterials", "models/gibs/woodgibs/woodgibs02")
list.Add("OverrideMaterials", "models/gibs/woodgibs/woodgibs03")
list.Add("OverrideMaterials", "models/player/player_chrome1")
list.Add("OverrideMaterials", "models/props_animated_breakable/smokestack/brickwall002a")
list.Add("OverrideMaterials", "models/props_building_details/courtyard_template001c_bars")
list.Add("OverrideMaterials", "models/props_buildings/destroyedbuilldingwall01a")
list.Add("OverrideMaterials", "models/props_buildings/plasterwall021a")
list.Add("OverrideMaterials", "models/props_c17/furniturefabric001a")
list.Add("OverrideMaterials", "models/props_c17/furniturefabric002a")
list.Add("OverrideMaterials", "models/props_c17/furnituremetal001a")
list.Add("OverrideMaterials", "models/props_c17/gate_door02a")
list.Add("OverrideMaterials", "models/props_c17/metalladder001")
list.Add("OverrideMaterials", "models/props_c17/metalladder002")
list.Add("OverrideMaterials", "models/props_c17/metalladder003")
list.Add("OverrideMaterials", "models/props_canal/canal_bridge_railing_01a")
list.Add("OverrideMaterials", "models/props_canal/canal_bridge_railing_01b")
list.Add("OverrideMaterials", "models/props_canal/canal_bridge_railing_01c")
list.Add("OverrideMaterials", "models/props_canal/canalmap_sheet")
list.Add("OverrideMaterials", "models/props_canal/coastmap_sheet")
list.Add("OverrideMaterials", "models/props_canal/metalcrate001d")
list.Add("OverrideMaterials", "models/props_canal/metalwall005b")
list.Add("OverrideMaterials", "models/props_canal/rock_riverbed01a")
list.Add("OverrideMaterials", "models/props_combine/citadel_cable")
list.Add("OverrideMaterials", "models/props_combine/citadel_cable_b")
list.Add("OverrideMaterials", "models/props_combine/combine_interface_disp")
list.Add("OverrideMaterials", "models/props_combine/combine_monitorbay_disp")
list.Add("OverrideMaterials", "models/props_combine/metal_combinebridge001")
list.Add("OverrideMaterials", "models/props_combine/pipes01")
list.Add("OverrideMaterials", "models/props_combine/pipes03")
list.Add("OverrideMaterials", "models/props_combine/prtl_sky_sheet")
list.Add("OverrideMaterials", "models/props_debris/building_template010a")
list.Add("OverrideMaterials", "models/props_debris/building_template022j")
list.Add("OverrideMaterials", "models/props_debris/composite_debris")
list.Add("OverrideMaterials", "models/props_debris/concretefloor013a")
list.Add("OverrideMaterials", "models/props_debris/concretefloor020a")
list.Add("OverrideMaterials", "models/props_debris/concretewall019a")
list.Add("OverrideMaterials", "models/props_debris/metalwall001a")
list.Add("OverrideMaterials", "models/props_debris/plasterceiling008a")
list.Add("OverrideMaterials", "models/props_debris/plasterwall009d")
list.Add("OverrideMaterials", "models/props_debris/plasterwall021a")
list.Add("OverrideMaterials", "models/props_debris/plasterwall034a")
list.Add("OverrideMaterials", "models/props_debris/plasterwall034d")
list.Add("OverrideMaterials", "models/props_debris/plasterwall039c")
list.Add("OverrideMaterials", "models/props_debris/plasterwall040c")
list.Add("OverrideMaterials", "models/props_debris/tilefloor001c")
list.Add("OverrideMaterials", "models/props_foliage/driftwood_01a")
list.Add("OverrideMaterials", "models/props_foliage/oak_tree01")
list.Add("OverrideMaterials", "models/props_interiors/metalfence007a")
list.Add("OverrideMaterials", "models/props_junk/plasticcrate01a")
list.Add("OverrideMaterials", "models/props_junk/plasticcrate01b")
list.Add("OverrideMaterials", "models/props_junk/plasticcrate01c")
list.Add("OverrideMaterials", "models/props_junk/plasticcrate01d")
list.Add("OverrideMaterials", "models/props_junk/plasticcrate01e")
list.Add("OverrideMaterials", "models/props_lab/cornerunit_cloud")
list.Add("OverrideMaterials", "models/props_lab/door_klab01")
list.Add("OverrideMaterials", "models/props_lab/security_screens")
list.Add("OverrideMaterials", "models/props_lab/security_screens2")
list.Add("OverrideMaterials", "models/props_lab/warp_sheet")
list.Add("OverrideMaterials", "models/props_lab/xencrystal_sheet")
list.Add("OverrideMaterials", "models/props_pipes/destroyedpipes01a")
list.Add("OverrideMaterials", "models/props_pipes/pipemetal001a")
list.Add("OverrideMaterials", "models/props_pipes/pipeset_metal02")
list.Add("OverrideMaterials", "models/props_pipes/pipesystem01a_skin1")
list.Add("OverrideMaterials", "models/props_pipes/pipesystem01a_skin2")
list.Add("OverrideMaterials", "models/props_vents/borealis_vent001")
list.Add("OverrideMaterials", "models/props_vents/borealis_vent001b")
list.Add("OverrideMaterials", "models/props_vents/borealis_vent001c")
list.Add("OverrideMaterials", "models/props_wasteland/concretefloor010a")
list.Add("OverrideMaterials", "models/props_wasteland/concretewall064b")
list.Add("OverrideMaterials", "models/props_wasteland/concretewall066a")
list.Add("OverrideMaterials", "models/props_wasteland/dirtwall001a")
list.Add("OverrideMaterials", "models/props_wasteland/metal_tram001a")
list.Add("OverrideMaterials", "models/props_wasteland/quarryobjects01")
list.Add("OverrideMaterials", "models/props_wasteland/rockcliff02a")
list.Add("OverrideMaterials", "models/props_wasteland/rockcliff02b")
list.Add("OverrideMaterials", "models/props_wasteland/rockcliff02c")
list.Add("OverrideMaterials", "models/props_wasteland/rockcliff04a")
list.Add("OverrideMaterials", "models/props_wasteland/rockgranite02a")
list.Add("OverrideMaterials", "models/props_wasteland/tugboat01")
list.Add("OverrideMaterials", "models/props_wasteland/tugboat02")
list.Add("OverrideMaterials", "models/props_wasteland/wood_fence01a_skin2")
list.Add("OverrideMaterials", "models/shadertest/predator")
list.Add("OverrideMaterials", "models/weapons/v_crossbow/rebar_glow")
list.Add("OverrideMaterials", "models/weapons/v_crowbar/crowbar_cyl")
list.Add("OverrideMaterials", "models/weapons/v_grenade/grenade body")
list.Add("OverrideMaterials", "models/XQM/BoxFull_diffuse")
list.Add("OverrideMaterials", "models/XQM/CellShadedCamo_diffuse")
list.Add("OverrideMaterials", "models/XQM/CinderBlock_Tex")
list.Add("OverrideMaterials", "models/XQM/JetBody2TailPiece_diffuse")
list.Add("OverrideMaterials", "models/XQM/PoleX1_diffuse")
list.Add("OverrideMaterials", "models/XQM/Rails/gumball_1")
list.Add("OverrideMaterials", "models/XQM/SquaredMatInverted")
list.Add("OverrideMaterials", "models/XQM/WoodPlankTexture")
list.Add("OverrideMaterials", "models/XQM/boxfull_diffuse")
list.Add("OverrideMaterials", "models/dav0r/hoverball")
list.Add("OverrideMaterials", "models/spawn_effect")
list.Add("OverrideMaterials", "phoenix_storms/Fender_chrome")
list.Add("OverrideMaterials", "phoenix_storms/Fender_white")
list.Add("OverrideMaterials", "phoenix_storms/Fender_wood")
list.Add("OverrideMaterials", "phoenix_storms/Future_vents")
list.Add("OverrideMaterials", "phoenix_storms/FuturisticTrackRamp_1-2")
list.Add("OverrideMaterials", "phoenix_storms/OfficeWindow_1-1")
list.Add("OverrideMaterials", "phoenix_storms/Pro_gear_side")
list.Add("OverrideMaterials", "phoenix_storms/black_brushes")
list.Add("OverrideMaterials", "phoenix_storms/black_chrome")
list.Add("OverrideMaterials", "phoenix_storms/blue_steel")
list.Add("OverrideMaterials", "phoenix_storms/camera")
list.Add("OverrideMaterials", "phoenix_storms/car_tire")
list.Add("OverrideMaterials", "phoenix_storms/checkers_map")
list.Add("OverrideMaterials", "phoenix_storms/cigar")
list.Add("OverrideMaterials", "phoenix_storms/concrete0")
list.Add("OverrideMaterials", "phoenix_storms/concrete1")
list.Add("OverrideMaterials", "phoenix_storms/concrete2")
list.Add("OverrideMaterials", "phoenix_storms/concrete3")
list.Add("OverrideMaterials", "phoenix_storms/construct/concrete_barrier00")
list.Add("OverrideMaterials", "phoenix_storms/construct/concrete_barrier2_00")
list.Add("OverrideMaterials", "phoenix_storms/construct/concrete_pipe_00")
list.Add("OverrideMaterials", "phoenix_storms/egg")
list.Add("OverrideMaterials", "phoenix_storms/gear_top")
list.Add("OverrideMaterials", "phoenix_storms/grey_chrome")
list.Add("OverrideMaterials", "phoenix_storms/grey_steel")
list.Add("OverrideMaterials", "phoenix_storms/heli")
list.Add("OverrideMaterials", "phoenix_storms/indentTiles2")
list.Add("OverrideMaterials", "phoenix_storms/iron_rails")
list.Add("OverrideMaterials", "phoenix_storms/mat/mat_phx_carbonfiber")
list.Add("OverrideMaterials", "phoenix_storms/mat/mat_phx_metallic")
list.Add("OverrideMaterials", "phoenix_storms/mat/mat_phx_metallic2")
list.Add("OverrideMaterials", "phoenix_storms/mat/mat_phx_plastic")
list.Add("OverrideMaterials", "phoenix_storms/mat/mat_phx_plastic2")
list.Add("OverrideMaterials", "phoenix_storms/metal_plate")
list.Add("OverrideMaterials", "phoenix_storms/metal_wheel")
list.Add("OverrideMaterials", "phoenix_storms/metalbox")
list.Add("OverrideMaterials", "phoenix_storms/metalbox2")
list.Add("OverrideMaterials", "phoenix_storms/metalfence004a")
list.Add("OverrideMaterials", "phoenix_storms/middle")
list.Add("OverrideMaterials", "phoenix_storms/mrref2")
list.Add("OverrideMaterials", "phoenix_storms/output_jack")
list.Add("OverrideMaterials", "phoenix_storms/pack2/chrome")
list.Add("OverrideMaterials", "phoenix_storms/pack2/interior_sides")
list.Add("OverrideMaterials", "phoenix_storms/pack2/train_floor")
list.Add("OverrideMaterials", "phoenix_storms/potato")
list.Add("OverrideMaterials", "phoenix_storms/pro_gear_top2")
list.Add("OverrideMaterials", "phoenix_storms/ps_grass")
list.Add("OverrideMaterials", "phoenix_storms/road")
list.Add("OverrideMaterials", "phoenix_storms/roadside")
list.Add("OverrideMaterials", "phoenix_storms/scrnspace")
list.Add("OverrideMaterials", "phoenix_storms/side")
list.Add("OverrideMaterials", "phoenix_storms/simplyMetallic1")
list.Add("OverrideMaterials", "phoenix_storms/smallwheel")
list.Add("OverrideMaterials", "phoenix_storms/spheremappy")
list.Add("OverrideMaterials", "phoenix_storms/t_light")
list.Add("OverrideMaterials", "phoenix_storms/thruster")
list.Add("OverrideMaterials", "phoenix_storms/tiles2")
list.Add("OverrideMaterials", "phoenix_storms/top")
list.Add("OverrideMaterials", "phoenix_storms/torpedo")
list.Add("OverrideMaterials", "phoenix_storms/trains/track_beamside")
list.Add("OverrideMaterials", "phoenix_storms/trains/track_beamtop")
list.Add("OverrideMaterials", "phoenix_storms/trains/track_plate")
list.Add("OverrideMaterials", "phoenix_storms/trains/track_plateside")
list.Add("OverrideMaterials", "phoenix_storms/white_brushes")
list.Add("OverrideMaterials", "phoenix_storms/white_fps")
list.Add("OverrideMaterials", "phoenix_storms/window")
list.Add("OverrideMaterials", "phoenix_storms/wood_dome")
list.Add("OverrideMaterials", "phoenix_storms/wood_side")
list.Add("OverrideMaterials", "models/cs_havana/wndb")
list.Add("OverrideMaterials", "models/cs_havana/wndd")
list.Add("OverrideMaterials", "models/cs_italy/plaster")
list.Add("OverrideMaterials", "models/cs_italy/pwtrim2")
list.Add("OverrideMaterials", "models/de_cbble/wndarch")
list.Add("OverrideMaterials", "models/de_chateau/ch_arch_b1")
list.Add("OverrideMaterials", "models/pi_window/plaster")
list.Add("OverrideMaterials", "models/pi_window/trim128")
list.Add("OverrideMaterials", "models/props/cs_assault/dollar")
list.Add("OverrideMaterials", "models/props/cs_assault/fireescapefloor")
list.Add("OverrideMaterials", "models/props/cs_assault/metal_stairs1")
list.Add("OverrideMaterials", "models/props/cs_assault/moneywrap")
list.Add("OverrideMaterials", "models/props/cs_assault/moneywrap02")
list.Add("OverrideMaterials", "models/props/cs_assault/moneytop")
list.Add("OverrideMaterials", "models/props/cs_assault/pylon")
list.Add("OverrideMaterials", "models/props/CS_militia/boulder01")
list.Add("OverrideMaterials", "models/props/CS_militia/milceil001")
list.Add("OverrideMaterials", "models/props/CS_militia/militiarock")
list.Add("OverrideMaterials", "models/props/CS_militia/militiarockb")
list.Add("OverrideMaterials", "models/props/CS_militia/milwall006")
list.Add("OverrideMaterials", "models/props/CS_militia/rocks01")
list.Add("OverrideMaterials", "models/props/CS_militia/roofbeams01")
list.Add("OverrideMaterials", "models/props/CS_militia/roofbeams02")
list.Add("OverrideMaterials", "models/props/CS_militia/roofbeams03")
list.Add("OverrideMaterials", "models/props/CS_militia/RoofEdges")
list.Add("OverrideMaterials", "models/props/cs_office/clouds")
list.Add("OverrideMaterials", "models/props/cs_office/file_cabinet2")
list.Add("OverrideMaterials", "models/props/cs_office/file_cabinet3")
list.Add("OverrideMaterials", "models/props/cs_office/screen")
list.Add("OverrideMaterials", "models/props/cs_office/snowmana")
list.Add("OverrideMaterials", "models/props/de_inferno/de_inferno_boulder_03")
list.Add("OverrideMaterials", "models/props/de_inferno/infflra")
list.Add("OverrideMaterials", "models/props/de_inferno/infflrd")
list.Add("OverrideMaterials", "models/props/de_inferno/inftowertop")
list.Add("OverrideMaterials", "models/props/de_inferno/offwndwb_break")
list.Add("OverrideMaterials", "models/props/de_inferno/roofbits")
list.Add("OverrideMaterials", "models/props/de_inferno/tileroof01")
list.Add("OverrideMaterials", "models/props/de_inferno/woodfloor008a")
list.Add("OverrideMaterials", "models/props/de_nuke/nukconcretewalla")
list.Add("OverrideMaterials", "models/props/de_nuke/nukecardboard")
list.Add("OverrideMaterials", "models/props/de_nuke/pipeset_metal")
list.Add("OverrideMaterials", "models/props_pipes/pipeset_metal")
list.Add("OverrideMaterials", "models/props_combine/combinethumper002")
list.Add("OverrideMaterials", "models/props_combine/tprotato1_sheet")
list.Add("OverrideMaterials", "models/props_debris/building_template012d")
list.Add("OverrideMaterials", "models/props_combine/tprings_sheet")
list.Add("OverrideMaterials", "models/weapons/v_stunbaton/w_shaft01a")
list.Add("OverrideMaterials", "models/props_wasteland/lighthouse_stairs")
list.Add("OverrideMaterials", "models/props_lab/generatorconsole_disp")
list.Add("OverrideMaterials", "models/props_combine/health_charger_glass")
list.Add("OverrideMaterials", "phoenix_storms/Airboat")
list.Add("OverrideMaterials", "phoenix_storms/Blue_steel")
list.Add("OverrideMaterials", "phoenix_storms/Indenttiles2")
list.Add("OverrideMaterials", "phoenix_storms/Indenttiles_1-2")
list.Add("OverrideMaterials", "phoenix_storms/MetalSet_1-2")
list.Add("OverrideMaterials", "phoenix_storms/Metalfloor_2-3")
list.Add("OverrideMaterials", "phoenix_storms/amraam")
list.Add("OverrideMaterials", "phoenix_storms/barrel")
list.Add("OverrideMaterials", "phoenix_storms/bomb")
list.Add("OverrideMaterials", "phoenix_storms/cannon")
list.Add("OverrideMaterials", "phoenix_storms/chrome")
list.Add("OverrideMaterials", "phoenix_storms/dome_side")
list.Add("OverrideMaterials", "phoenix_storms/explo_barrel")
list.Add("OverrideMaterials", "phoenix_storms/fender")
list.Add("OverrideMaterials", "phoenix_storms/fender_chrome")
list.Add("OverrideMaterials", "phoenix_storms/fender_white")
list.Add("OverrideMaterials", "phoenix_storms/fender_wood")
list.Add("OverrideMaterials", "phoenix_storms/future_vents")
list.Add("OverrideMaterials", "phoenix_storms/glass")
list.Add("OverrideMaterials", "phoenix_storms/lag_sign")
list.Add("OverrideMaterials", "phoenix_storms/metal")
list.Add("OverrideMaterials", "phoenix_storms/mrtire")
list.Add("OverrideMaterials", "phoenix_storms/point1")
list.Add("OverrideMaterials", "phoenix_storms/pack2/black")
list.Add("OverrideMaterials", "phoenix_storms/pack2/bluelight")
list.Add("OverrideMaterials", "phoenix_storms/pack2/darkblue")
list.Add("OverrideMaterials", "phoenix_storms/pack2/darkgrey")
list.Add("OverrideMaterials", "phoenix_storms/pack2/glass")
list.Add("OverrideMaterials", "phoenix_storms/pack2/interior_top")
list.Add("OverrideMaterials", "phoenix_storms/pack2/metalbox2")
list.Add("OverrideMaterials", "phoenix_storms/pack2/panel")
list.Add("OverrideMaterials", "phoenix_storms/pack2/redlight")
list.Add("OverrideMaterials", "models/effects/splode1_sheet")
list.Add("OverrideMaterials", "models/error/new light1")
list.Add("OverrideMaterials", "models/items/boxsniperrounds")
list.Add("OverrideMaterials", "models/weapons/v_slam/new light1")
list.Add("OverrideMaterials", "models/props_junk/ravenholmsign_sheet")
list.Add("OverrideMaterials", "models/props_junk/TrafficCone001a")
list.Add("OverrideMaterials", "models/Items/boxart1")
list.Add("OverrideMaterials", "models/props/de_tides/clouds")
list.Add("OverrideMaterials", "models/props/cs_office/offinspa")
list.Add("OverrideMaterials", "models/props/cs_office/offinspb")
list.Add("OverrideMaterials", "models/props/cs_office/offinspc")
list.Add("OverrideMaterials", "models/props/cs_office/offinspd")
list.Add("OverrideMaterials", "models/props/cs_office/offinspf")
list.Add("OverrideMaterials", "models/props/cs_office/offinspg")
list.Add("OverrideMaterials", "models/balloon/balloon_hl2")
list.Add("OverrideMaterials", "models/balloon/balloon_nips")
list.Add("OverrideMaterials", "models/balloon/balloon_milfman")
--PATH addons/__main/lua/weapons/m9k_browningauto5/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_browningauto5") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Shotguns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Browning Auto 5"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 32			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "shotgun"	-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_brown_auto5.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_browning_auto.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_shotty_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Weapon_a5.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 250		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 6			-- Size of a clip
SWEP.Primary.DefaultClip		= 30	-- Default number of bullets in a clip
SWEP.Primary.KickUp				= 1				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.8		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.6	-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "buckshot"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.ShellTime			= .35

SWEP.Primary.NumShots	= 9		//how many bullets to shoot, use with shotguns
SWEP.Primary.Damage		= 10	//base damage, scaled by game
SWEP.Primary.Spread		= .03	//define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .03 // has to be the same as primary.spread
-- Because irons don't magically give you less pellet spread!

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(1.953, 0, 1.388)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(1.953, 0, 1.388)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(-3.116, -3.935, 0.492)
SWEP.RunSightsAng = Vector(-19.894, -47.624, 10.902)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_contender/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_contender") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Sniper Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Thompson Contender G2"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 40			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= false		-- Set false if you want no crosshair from hip
SWEP.XHair					= false		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.Weight				= 50			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.BoltAction				= true		-- Is this a bolt action rifle?
SWEP.HoldType 				= "rpg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_contender2.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_g2_contender.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("contender_g2.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 35		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 1		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp				= 1				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 1			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 1		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "ar2"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.ScopeZoom			= 9	
SWEP.Secondary.UseACOG			= false -- Choose one scope type
SWEP.Secondary.UseMilDot		= true	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= false
SWEP.Secondary.UseMatador		= false

SWEP.data 				= {}
SWEP.data.ironsights		= 1
SWEP.ScopeScale 			= 0.7
SWEP.ReticleScale 			= 0.6

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 85	--base damage per bullet
SWEP.Primary.Spread		= .01	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .00015 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector(-3, -0.857, 0.36)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(-3, -0.857, 0.36)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(3.714, -1.429, 0)
SWEP.RunSightsAng = Vector(-11, 31, 0)

if (gmod.GetGamemode().Name == "Murderthon 9000") then

	SWEP.Slot		= 1				-- Slot in the weapon selection menu
	SWEP.Weight		= 3			-- rank relative ot other weapons. bigger is better

end

function SWEP:PrimaryAttack()
	if self.Owner:IsNPC() then return end
	if self:CanPrimaryAttack() and !self.Owner:KeyDown(IN_SPEED) then
		self:ShootBulletInformation()
		self.Weapon:EmitSound(self.Primary.Sound)
		self.Weapon:TakePrimaryAmmo(1)
		self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
		local fx 		= EffectData()
		fx:SetEntity(self.Weapon)
		fx:SetOrigin(self.Owner:GetShootPos())
		fx:SetNormal(self.Owner:GetAimVector())
		fx:SetAttachment(self.MuzzleAttachment)
		util.Effect("rg_muzzle_rifle",fx)
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
		self.Owner:MuzzleFlash()
		self.Weapon:SetNextPrimaryFire(CurTime()+10)
		self.RicochetCoin = (math.random(1,4))
		self:UseBolt()
	end
end

function SWEP:UseBolt()

	if self.Owner:GetAmmoCount( self.Weapon:GetPrimaryAmmoType() ) > 0 then
		timer.Simple(.25, function() 
		if SERVER and self.Weapon != nil then 
			self.Weapon:SetNWBool("Reloading", true)
			if self.Weapon:GetClass() == self.Gun and self.BoltAction then
				self.Owner:SetFOV( 0, 0.3 )
				self:SetIronsights(false)
				self.Owner:DrawViewModel(true)
				local boltactiontime = (self.Owner:GetViewModel():SequenceDuration())
				timer.Simple(boltactiontime, 
					function() if self.Weapon and self.Owner then if IsValid(self.Weapon) and IsValid(self.Owner) then 
					self.Weapon:SetNWBool("Reloading", false)
					if SERVER and self.Weapon != nil then
						if self.Owner:KeyDown(IN_ATTACK2) and self.Weapon:GetClass() == self.Gun then 
							self.Owner:SetFOV( 75/self.Secondary.ScopeZoom, 0.15 )                      		
							self.IronSightsPos = self.SightsPos					-- Bring it up
							self.IronSightsAng = self.SightsAng					-- Bring it up
							self.DrawCrosshair = false
							self:SetIronsights(true, self.Owner)
							self.Owner:DrawViewModel(false)
						
							self.Owner:RemoveAmmo(1, self.Primary.Ammo, false) -- out of the frying pan
							self.Weapon:SetClip1(self.Weapon:Clip1() + 1) --  into the fire
							self.Weapon:SetNextPrimaryFire(CurTime() + .1)
						--well, hope this works
						elseif !self.Owner:KeyDown(IN_ATTACK2) and self.Weapon:GetClass() == self.Gun then
							self.Owner:RemoveAmmo(1, self.Primary.Ammo, false) -- out of the frying pan
							self.Weapon:SetClip1(self.Weapon:Clip1() + 1) --  into the fire
							self.Weapon:SetNextPrimaryFire(CurTime() + .1)
						end
					end 
				end end end)
			-- else if self.Weapon:GetClass() == self.Gun and 
				-- self.BoltAction and	(self:GetIronsights() == false) then
					
			end
		end 
		end )
	else
		timer.Simple(.1, function() self:CheckWeaponsAndAmmo() end)
	end

end	

function SWEP:Reload()


//	self.Weapon:DefaultReload(ACT_VM_RELOAD)

		if not IsValid(self) then return end 
		if not IsValid(self.Owner) then return end
		if not IsValid(self.Weapon) then return end
		
		if  self.Weapon:GetNextPrimaryFire() > (CurTime() + 1) then 
			return 
		else
		   
			if self.Owner:IsNPC() then
					self.Weapon:DefaultReload(ACT_VM_RELOAD)
			return end
		   
			if self.Owner:KeyDown(IN_USE) then return end
		   
			if self.Silenced then
					self.Weapon:DefaultReload(ACT_VM_RELOAD_SILENCED)
			else
					self.Weapon:DefaultReload(ACT_VM_RELOAD)
			end
		   
			if !self.Owner:IsNPC() then
					if self.Owner:GetViewModel() == nil then self.ResetSights = CurTime() + 3 else
					self.ResetSights = CurTime() + self.Owner:GetViewModel():SequenceDuration()
					end
			end
		   
			if SERVER and self.Weapon != nil then
			if ( self.Weapon:Clip1() < self.Primary.ClipSize ) and !self.Owner:IsNPC() then
			-- //When the current clip < full clip and the rest of your ammo > 0, then
					self.Owner:SetFOV( 0, 0.3 )
					-- //Zoom = 0
					self:SetIronsights(false)
					-- //Set the ironsight to false
					self.Weapon:SetNWBool("Reloading", true)
			end
			local waitdammit = (self.Owner:GetViewModel():SequenceDuration())
			timer.Simple(waitdammit + .1,
					function()
					if self.Weapon == nil then return end
					self.Weapon:SetNWBool("Reloading", false)
					if self.Owner:KeyDown(IN_ATTACK2) and self.Weapon:GetClass() == self.Gun then
							if CLIENT then return end
							if self.Scoped == false then
									self.Owner:SetFOV( self.Secondary.IronFOV, 0.3 )
									self.IronSightsPos = self.SightsPos                                     -- Bring it up
									self.IronSightsAng = self.SightsAng                                     -- Bring it up
									self:SetIronsights(true, self.Owner)
									self.DrawCrosshair = false
							else return end
					elseif self.Owner:KeyDown(IN_SPEED) and self.Weapon:GetClass() == self.Gun then
							if self.Weapon:GetNextPrimaryFire() <= (CurTime() + .03) then
									self.Weapon:SetNextPrimaryFire(CurTime()+0.3)                   -- Make it so you can't shoot for another quarter second
							end
							self.IronSightsPos = self.RunSightsPos                                  -- Hold it down
							self.IronSightsAng = self.RunSightsAng                                  -- Hold it down
							self:SetIronsights(true, self.Owner)                                    -- Set the ironsight true
							self.Owner:SetFOV( 0, 0.3 )
					else return end
					end)
			end
		
		end
		
end

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_fal/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_fal") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "FN FAL"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 28			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 55
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_fnfalnato.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_fn_fal.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= true
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("fnfal.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 750			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 20		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.5		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.5		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "ar2"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 30	-- Base damage per bullet
SWEP.Primary.Spread		= .02	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .01 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-3.161, -1.068, 1.24)
SWEP.IronSightsAng = Vector(0.425, 0.05, 0)
SWEP.SightsPos = Vector(-3.161, -1.068, 1.24)
SWEP.SightsAng = Vector(0.425, 0.05, 0)
SWEP.RunSightsPos = Vector(2.598, -2.441, 0.36)
SWEP.RunSightsAng = Vector(-7.993, 37.756, -6.89)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_pkm/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_pkm") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Machine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "PKM"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 38			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 55
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_mach_russ_pkm.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_mach_russ_pkm.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= true
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("pkm.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 750			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 100		-- Size of a clip
SWEP.Primary.DefaultClip		= 200		-- Bullets you start with
SWEP.Primary.KickUp				= 0.6		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.5		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "ar2"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 33	-- Base damage per bullet
SWEP.Primary.Spread		= .035	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .02 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-2.215, -2.116, 0.36)
SWEP.IronSightsAng = Vector(-0.13, 0.054, 0)
SWEP.SightsPos = Vector(-2.215, -2.116, 0.36)
SWEP.SightsAng = Vector(-0.13, 0.054, 0)
SWEP.RunSightsPos = Vector(5.276, -3.859, 0)
SWEP.RunSightsAng = Vector(-14.606, 52.087, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_striker12/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_striker12")					-- must be the name of your swep
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Shotguns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Striker 12"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 28			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative to other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_striker_12g.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_striker_12g.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_shotty_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("ShotStriker12.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 365		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 12			-- Size of a clip
SWEP.Primary.DefaultClip			= 36	-- Default number of bullets in a clip
SWEP.Primary.KickUp			= 4				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.5		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal			= .6	-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "buckshot"

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 

SWEP.ShellTime			= .3

SWEP.Primary.NumShots	= 6		-- How many bullets to shoot per trigger pull, AKA pellets
SWEP.Primary.Damage		= 8	-- Base damage per bullet
SWEP.Primary.Spread		= .04	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .04	-- Ironsight accuracy, should be the same for shotguns
-- Because irons don't magically give you less pellet spread!

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(3.805, -1.045, 1.805)
SWEP.IronSightsAng = Vector(2.502, 3.431, 0)
SWEP.SightsPos = Vector(3.805, -1.045, 1.805)
SWEP.SightsAng = Vector(2.502, 3.431, 0)
SWEP.RunSightsPos = Vector(-3.237, -6.376, 1.167)
SWEP.RunSightsAng = Vector(-8.391, -63.543, 0)


if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/nintendo_switcheroo.lua:
/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


SWEP.Author = "large sweaty black male"
SWEP.Contact = "911"
SWEP.Purpose = "Switch places with a random player or NPC in the game"
SWEP.Instructions = "Primary fire to switch positions"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.ViewModel = "models/weapons/v_pistol.mdl"
SWEP.WorldModel = "models/weapons/w_pistol.mdl"
SWEP.PrintName = "Nintendo Switch"
SWEP.Category = "Weapons"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

local author_first_names = {"Luna", "Nova", "Vega", "Orion", "Phoenix", "Aurora", "Stella", "Nebula", "Galaxy", "Comet"}
local author_last_names = {"Starlight", "Nightsky", "Cosmos", "Moonbeam", "Skywatcher", "Solarflare", "Supernova", "Meteorite", "Celestial", "Astro"}

SWEP.Author = author_first_names[math.random(#author_first_names)] .. " " .. author_last_names[math.random(#author_last_names)]
SWEP.Contact = SWEP.Author:lower():gsub(" ", "") .. "@example.com"
SWEP.Purpose = "Switch places with a random player or NPC in the game"
SWEP.Instructions = "Primary fire to switch positions"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 70
SWEP.ViewModelFlip = false
SWEP.UseHands = true
SWEP.ViewModel = "models/weapons/c_grenade.mdl"
SWEP.WorldModel = "models/weapons/w_pistol.mdl"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false
SWEP.ViewModelBoneMods = {
	["ValveBiped.Grenade_body"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["switch"] = { type = "Model", model = "models/nintendo_switch/switch.mdl", bone = "ValveBiped.Grenade_body", rel = "", pos = Vector(-0.519, 4.675, -0.519), angle = Angle(-162.469, 3.506, -5.844), size = Vector(0.69, 0.69, 0.69), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["switch"] = { type = "Model", model = "models/nintendo_switch/switch.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.596, 7.791, 0.518), angle = Angle(180, -5.844, -12.858), size = Vector(0.69, 0.69, 0.69), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

function SWEP:PrimaryAttack()
    
    self:SetNextPrimaryFire(CurTime() + 20)

    local tr = self.Owner:GetEyeTrace()
    local target = tr.Entity

    
    if IsValid(target) and target:IsPlayer() and target != self.Owner then
        local ownerPos = self.Owner:GetPos()
        local targetPos = target:GetPos()

        
        self.Owner:SetPos(targetPos)
        target:SetPos(ownerPos)

        
        self.Owner:ScreenFade(SCREENFADE.IN, Color(255, 255, 255), 0.1, 0)
        self.Owner:EmitSound("switchclap.wav")
        self.Owner:ViewPunch(Angle(-10, 0, 0))
    end
end

function SWEP:SecondaryAttack()
end
--PATH addons/mobile_phone/lua/weapons/phone.lua:
if SERVER then
	AddCSLuaFile()
end

if CLIENT then
	SWEP.PrintName = 'Телефон'
	SWEP.Slot = 2
	SWEP.SlotPos = 5
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = false
end

SWEP.Author = ''
SWEP.Instructions = 'ЛКМ чтобы откыть меню'
SWEP.Contact = ''
SWEP.Purpose = ''
SWEP.ViewModel = 'models/jessev92/weapons/buddyfinder_c.mdl'
SWEP.WorldModel = 'models/jessev92/weapons/buddyfinder_w.mdl'
SWEP.ViewModelFOV = 72
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = 'rpg'
SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.Category = 'RP'
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ''
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ''
SWEP.UseHands = true

function SWEP:Initialize()
	self:SetWeaponHoldType('slam')
end

function SWEP:Deploy()
	if SERVER then
		self:GetOwner():DrawWorldModel(true)
	end
end

function SWEP:Menu()
	if IsValid(frphone) then return end
	frphone = vgui.Create('onyx.Frame')
	frphone:SetTitle('Телефон')
	frphone:SetSize(300, 325)
	frphone:Center()
	frphone:MakePopup()
	local playerrequest = vgui.Create('rubyphonePlayerRequest', frphone)
	playerrequest:Dock(FILL)
	playerrequest:SetPlayers(player.GetAll())

	playerrequest.OnSelection = function(s, row, pl)
		frphone:Close()

		if not IsValid(pl) and pl == '112' then
			net.Start('EmergencyDispatch:DispatchCallout:VictimNet')
			net.SendToServer()
			return
		end

		if IsValid(pl) then
			Phone.StartCall(pl)
		end
	end
end

function SWEP:PrimaryAttack()
	if CLIENT then
		self:Menu()
	end
end
--PATH addons/__________skeypads/lua/weapons/skeypad_cracker_base/shared.lua:
SWEP.Base = 'weapon_base'
SWEP.PrintName = 'Base Keypad Cracker'
SWEP.Author = 'Tom.bat & NoSharp'
SWEP.Instructions = 'Натисність на кейпад та зачейкате, щоб його зламати.'
SWEP.Category = 'RP'
SWEP.Slot = 4
SWEP.SlotPos = 1
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.ViewModel = Model( 'models/weapons/v_c4.mdl' )
SWEP.WorldModel = Model( 'models/weapons/w_c4.mdl' )
SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.AnimPrefix = 'python'
SWEP.Sound = Sound( 'weapons/deagle/deagle-1.wav' )
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ''
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ''
SWEP.Primary.ClipSize = 0
SWEP.Primary.Ammo = ''
SWEP.Secondary.Ammo = ''
SWEP.CrackTime = 10
SWEP.Deployable = false
function SWEP:Initialize()
    self:SetHoldType( 'slam' )
end

function SWEP:SecondaryAttack()
    if SERVER then self:Reset() end
end

function SWEP:Reload()
    return true
end

function SWEP:Reset()
    if SERVER then
        self:CallOnClient( 'Reset' )
        if IsValid( self.CrackingEnt ) then self.CrackingEnt:StopCrackEffects() end
    end

    self.IsCracking = false
    self.CrackingEnt = nil
    self:SetWeaponHoldType( 'slam' )
end
--PATH addons/swb_css/lua/weapons/swb_fiveseven/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "FN Five-seveN"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-5.949, -2.096, 2.88)
	SWEP.AimAng = Vector(-0.401, 0, 0)
		
	SWEP.SprintPos = Vector(0, -17.514, -12.271)
	SWEP.SprintAng = Vector(63.637, 0, 0)
	
	SWEP.ZoomAmount = 5
	SWEP.ViewModelMovementScale = 0.85
	SWEP.Shell = "smallshell"
	
	SWEP.IconLetter = "u"
	
	SWEP.MuzzleEffect = "swb_pistol_med"
end

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 10
SWEP.BulletDiameter = 5.7
SWEP.CaseLength = 28

SWEP.Kind = WEAPON_PISTOL
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_pistol_ttt"

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "Pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"semi"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_pist_fiveseven.mdl"
SWEP.WorldModel		= "models/weapons/w_pist_fiveseven.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 20
SWEP.Primary.DefaultClip	= 20
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "pistol"

SWEP.FireDelay = 0.145
SWEP.FireSound = Sound("Weapon_FiveSeven.Single")
SWEP.Recoil = 0.95

SWEP.HipSpread = 0.04
SWEP.AimSpread = 0.009
SWEP.VelocitySensitivity = 1.3
SWEP.MaxSpreadInc = 0.06
SWEP.SpreadPerShot = 0.01
SWEP.SpreadCooldown = 0.15
SWEP.Shots = 1
SWEP.Damage = 20
SWEP.DeployTime = 1
SWEP.DryFire = false
--PATH addons/swb_css/lua/weapons/swb_glock18/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Glock-18"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-5.772, -2.526, 2.79)
	SWEP.AimAng = Vector(0.419, -0.01, 0)
	
	SWEP.SprintPos = Vector(0, -17.514, -12.271)
	SWEP.SprintAng = Vector(63.637, 0, 0)
	
	SWEP.ZoomAmount = 5
	SWEP.ViewModelMovementScale = 0.85
	SWEP.Shell = "smallshell"
	
	SWEP.IconLetter = "c"
	
	SWEP.MuzzleEffect = "swb_pistol_small"
end

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 25
SWEP.BulletDiameter = 9
SWEP.CaseLength = 19

SWEP.Kind = WEAPON_PISTOL
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_pistol_ttt"

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "Pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"3burst", "semi"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_pist_glock18.mdl"
SWEP.WorldModel		= "models/weapons/w_pist_glock18.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 18
SWEP.Primary.DefaultClip	= 18
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "pistol"

SWEP.FireDelay = 0.05
SWEP.FireSound = Sound("Weapon_Glock.Single")
SWEP.Recoil = 0.7
SWEP.DryFire = true

SWEP.HipSpread = 0.038
SWEP.AimSpread = 0.013
SWEP.VelocitySensitivity = 1.2
SWEP.MaxSpreadInc = 0.06
SWEP.SpreadPerShot = 0.01
SWEP.SpreadCooldown = 0.1
SWEP.Shots = 1
SWEP.Damage = 16
SWEP.DeployTime = 1
SWEP.BurstCooldownMul = 3.5
--PATH addons/swb_base/lua/weapons/swb_knife/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.BounceWeaponIcon = false
	SWEP.DrawWeaponInfoBox = false
	SWEP.PrintName = "Knife"
	SWEP.BobScale = 0
	SWEP.SwayScale = 0
	SWEP.ViewbobIntensity = 1
	SWEP.ViewbobEnabled = true

   SWEP.EquipMenuData = {
      type = "item_weapon",
      desc = "knife_desc"
   };

   SWEP.Icon = "vgui/ttt/icon_knife"
end

SWEP.SpeedDec = 0
SWEP.Slot = 0
SWEP.SlotPos = 0
SWEP.SWBWeapon = true
SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.Category = "SUP Weapons"
SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel		= "models/weapons/w_knife_t.mdl"
SWEP.UseHands = true

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= -1					// Size of a clip
SWEP.Primary.DefaultClip	= -1				// Default number of bullets in a clip
SWEP.Primary.Automatic		= true				// Automatic/Semi Auto
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1				// Size of a clip
SWEP.Secondary.DefaultClip	= -1				// Default number of bullets in a clip
SWEP.Secondary.Automatic	= true				// Automatic/Semi Auto
SWEP.Secondary.Ammo			= "none"

SWEP.HitSound = Sound("SWB_Knife_Hit")
SWEP.SwingSound = Sound("SWB_Knife_Swing")
SWEP.HitSoundElse = Sound("SWB_Knife_HitElse")

SWEP.Kind = WEAPON_EQUIP
SWEP.CanBuy = {ROLE_TRAITOR} -- only traitors can buy
SWEP.LimitedStock = true -- only buyable once
SWEP.WeaponID = AMMO_KNIFE

SWEP.IsSilent = true

function SWEP:IsEquipment() -- I have no idea what I'm doing, help
	return WEPS.IsEquipment(self)
end

function SWEP:Initialize()
	self:SetHoldType("knife")
end

local vm, CT

function SWEP:Deploy()
	self:SendWeaponAnim(ACT_VM_DRAW)

	self:SetNextPrimaryFire(CurTime() + 0.7)
	return true
end

function SWEP:Reload()
end

function SWEP:Think()
	if self.DamageTime and CurTime() > self.DamageTime then
		if SERVER then
			self.Owner:LagCompensation(true)
		end

		self:Damage()

		if SERVER then
			self.Owner:LagCompensation(false)
		end

		self.DamageTime = nil
	end
end

function SWEP:PrimaryAttack()
	self.DamageMin = 10
	self.DamageMax = 10

	self.Owner:SetAnimation(PLAYER_ATTACK1)
	CT = CurTime()

	self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)

	if IsFirstTimePredicted() then
		self:EmitSound(self.SwingSound, 70, 100)
		self.DamageTime = CT + 0.15
	end

	self.Owner:SetDTFloat(0, 0.5)
	self:SetNextPrimaryFire(CT + 0.55)
	self:SetNextSecondaryFire(CT + 0.55)
end

function SWEP:SecondaryAttack()
	self.DamageMin = 40
	self.DamageMax = 50

	self.Owner:SetAnimation(PLAYER_ATTACK1)
	CT = CurTime()

	self:SendWeaponAnim(ACT_VM_SECONDARYATTACK)

	if IsFirstTimePredicted() then
		self:EmitSound(self.SwingSound, 70, 100)
		self.DamageTime = CT + 0.15
	end

	self.Owner:SetDTFloat(0, 0.5)
	self:SetNextPrimaryFire(CT + 1)
	self:SetNextSecondaryFire(CT + 1)
end

local td = {}
local tr, ent

function SWEP:Damage()
	td.start = self.Owner:GetShootPos()
	td.endpos = td.start + self.Owner:EyeAngles():Forward() * 50
	td.filter = self.Owner
	td.mins = Vector(-6, -6, -6)
	td.maxs = Vector(6, 6, 6)

	tr = util.TraceHull(td)

	if tr.Hit then
		ent = tr.Entity

		if IsValid(ent) then
			if ent:IsPlayer() or ent:IsNPC() then
				if SERVER then
					ent:TakeDamage(math.random(self.DamageMin, self.DamageMax), self.Owner, self.Owner)
				end

				ParticleEffect("blood_impact_red_01", tr.HitPos, tr.HitNormal:Angle(), ent)
				self:EmitSound(self.HitSound, 80, 100)
			else
				if SERVER then
					ent:TakeDamage(math.random(self.DamageMin, self.DamageMax), self.Owner, self.Owner)

					if ent:GetClass() == "func_breakable_surf" then
						ent:Input("Shatter", NULL, NULL, "")
						self:EmitSound("physics/glass/glass_impact_bullet1.wav", 80, math.random(95, 105))
					end
				end

				self:EmitSound(self.HitSoundElse, 80, 100)
			end
		else
			self:EmitSound(self.HitSoundElse, 80, 100)
		end
	end
end

if CLIENT then
	local wm, pos, ang

	function SWEP:DrawWorldModel()
		self:DrawModel()
	end
end

function SWEP:Holster(wep)
	self:OnRemove()

	return true
end

if CLIENT then
	SWEP.BlendPos = Vector(0, 0, 0)
	SWEP.BlendAng = Vector(0, 0, 0)
	SWEP.OldDelta = Angle(0, 0, 0)
	SWEP.AngleDelta = Angle(0, 0, 0)

	local reg = debug.getregistry()
	local Right = reg.Angle.Right
	local Up = reg.Angle.Up
	local Forward = reg.Angle.Forward
	local RotateAroundAxis = reg.Angle.RotateAroundAxis
	local GetVelocity = reg.Entity.GetVelocity
	local Length = reg.Vector.Length

	local Ang0, curang, curviewbob = Angle(0, 0, 0), Angle(0, 0, 0), Angle(0, 0, 0)
	function SWEP:CalcView(ply, pos, ang, fov)
		FT, CT = FrameTime(), CurTime()

		if self.ViewbobEnabled then
			ws = self.Owner:GetWalkSpeed()
			vel = Length(GetVelocity(self.Owner))

			if self.Owner:OnGround() and vel > ws * 0.3 then
				if vel < ws * 1.2 then
					cos1 = math.cos(CT * 15)
					cos2 = math.cos(CT * 12)
					curviewbob.p = cos1 * 0.15
					curviewbob.y = cos2 * 0.1
				else
					cos1 = math.cos(CT * 20)
					cos2 = math.cos(CT * 15)
					curviewbob.p = cos1 * 0.25
					curviewbob.y = cos2 * 0.15
				end
			else
				curviewbob = LerpAngle(FT * 10, curviewbob, Ang0)
			end
		end

		return pos, ang + curviewbob * self.ViewbobIntensity, fov
	end

	local Vec0 = Vector(0, 0, 0)
	local TargetPos, TargetAng, cos1, sin1, tan, ws, rs, mod, vel, FT, sin2, delta

	local SP = game.SinglePlayer()
	local PosMod, AngMod = Vector(0, 0, 0), Vector(0, 0, 0)
	local CurPosMod, CurAngMod = Vector(0, 0, 0), Vector(0, 0, 0)

	function SWEP:PreDrawViewModel()
		CT = UnPredictedCurTime()
		vm = self.Owner:GetViewModel()

		EA = EyeAngles()
		FT = FrameTime()

		delta = Angle(EA.p, EA.y, 0) - self.OldDelta
		delta.p = math.Clamp(delta.p, -10, 10)

		self.OldDelta = Angle(EA.p, EA.y, 0)
		self.AngleDelta = LerpAngle(math.Clamp(FT * 10, 0, 1), self.AngleDelta, delta)
		self.AngleDelta.y = math.Clamp(self.AngleDelta.y, -10, 10)

		vel = Length(GetVelocity(self.Owner))
		ws = self.Owner:GetWalkSpeed()

		PosMod, AngMod = Vec0 * 1, Vec0 * 1

		if vel < 10 or not self.Owner:OnGround() then
			cos1, sin1 = math.cos(CT), math.sin(CT)
			tan = math.atan(cos1 * sin1, cos1 * sin1)

			AngMod.x = AngMod.x + tan * 1.15
			AngMod.y = AngMod.y + cos1 * 0.4
			AngMod.z = AngMod.z + tan

			PosMod.y = PosMod.y + tan * 0.2
		elseif vel > 10 and vel < ws * 1.2 then
			mod = 6 + ws / 130
			mul = math.Clamp(vel / ws, 0, 1)
			sin1 = math.sin(CT * mod) * mul
			cos1 = math.cos(CT * mod) * mul
			tan1 = math.tan(sin1 * cos1) * mul

			AngMod.x = AngMod.x + tan1
			AngMod.y = AngMod.y - cos1
			AngMod.z = AngMod.z + cos1
			PosMod.x = PosMod.x - sin1 * 0.4
			PosMod.y = PosMod.y + tan1 * 1
			PosMod.z = PosMod.z + tan1 * 0.5
		elseif (vel > ws * 1.2 and self.Owner:KeyDown(IN_SPEED)) or vel > ws * 3 then
			rs = self.Owner:GetRunSpeed()
			mod = 7 + math.Clamp(rs / 100, 0, 6)
			mul = math.Clamp(vel / rs, 0, 1)
			sin1 = math.sin(CT * mod) * mul
			cos1 = math.cos(CT * mod) * mul
			tan1 = math.tan(sin1 * cos1) * mul

			AngMod.x = AngMod.x + tan1 * 0.2
			AngMod.y = AngMod.y - cos1 * 1.5
			AngMod.z = AngMod.z + cos1 * 3
			PosMod.x = PosMod.x - sin1 * 1.2
			PosMod.y = PosMod.y + tan1 * 1.5
			PosMod.z = PosMod.z + tan1
		end

		FT = FrameTime()

		CurPosMod = LerpVector(FT * 10, CurPosMod, PosMod)
		CurAngMod = LerpVector(FT * 10, CurAngMod, AngMod)
	end

	function SWEP:GetViewModelPosition(pos, ang)
		RotateAroundAxis(ang, Right(ang), CurAngMod.x + self.AngleDelta.p)
		RotateAroundAxis(ang, Up(ang), CurAngMod.y + self.AngleDelta.y * 0.3)
		RotateAroundAxis(ang, Forward(ang), CurAngMod.z + self.AngleDelta.y * 0.3)

		pos = pos + (CurPosMod.x + self.AngleDelta.y * 0.1) * Right(ang)
		pos = pos + (CurPosMod.y + self.BlendPos.y) * Forward(ang)
		pos = pos + (CurPosMod.z + self.BlendPos.z - self.AngleDelta.p * 0.1) * Up(ang)

		return pos, ang
	end
end

--PATH addons/swb_css/lua/weapons/swb_p90/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "FN P90"
	SWEP.CSMuzzleFlashes = true

	SWEP.AimPos = Vector(-1.93, -5.928, 1.82)
	SWEP.AimAng = Vector(1.162, 0, 0)
	
	SWEP.SprintPos = Vector(0.736, -3.971, 1.802)
	SWEP.SprintAng = Vector(-13.205, 37.048, 0)
	
	SWEP.ZoomAmount = 15
	SWEP.ViewModelMovementScale = 0.85
	SWEP.Shell = "smallshell"
	
	SWEP.IconLetter = "m"
	
	SWEP.MuzzleEffect = "swb_rifle_med"
end

SWEP.FadeCrosshairOnAim = false

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 20
SWEP.BulletDiameter = 5.7
SWEP.CaseLength = 28

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_smg1_ttt"

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_smg_p90.mdl"
SWEP.WorldModel		= "models/weapons/w_smg_p90.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 50
SWEP.Primary.DefaultClip	= 50
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "smg1"

SWEP.FireDelay = 0.0666
SWEP.FireSound = Sound("Weapon_P90.Single")
SWEP.Recoil = 0.9

SWEP.HipSpread = 0.043
SWEP.AimSpread = 0.007
SWEP.VelocitySensitivity = 1.5
SWEP.MaxSpreadInc = 0.05
SWEP.SpreadPerShot = 0.01
SWEP.SpreadCooldown = 0.1
SWEP.Shots = 1
SWEP.Damage = 18
SWEP.DeployTime = 1
SWEP.BurstCooldownMul = 3.5
--PATH addons/____sam/lua/weapons/t_sit_editor.lua:
AddCSLuaFile()
sam_sits = sam_sits or {}
if CLIENT then
    SWEP.DrawAmmo = true
    SWEP.DrawCrosshair = true
    SWEP.ViewModelFOV = 75
    SWEP.PrintName = "T-SIT Editor Tool"
    SWEP.Slot = 5
    SWEP.Slotpos = 5
end

SWEP.HoldType = "pistol"
SWEP.ViewModel = "models/weapons/c_toolgun.mdl"
SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.UseHands = true
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "pistol"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Primary.PlaceSit = "buttons/button3.wav"
SWEP.Primary.RemoveSit = "buttons/button10.wav"
-- Use this hook instead of Initialize, game.GetMap() might not return the right map if run too early.
hook.Add( "InitPostEntity", "T-SITS.ReadFiles", function()
    if file.Exists( "sam/" .. game.GetMap() .. ".txt", "DATA" ) then
        sam_sits[game.GetMap()] = util.JSONToTable( file.Read( "sam/" .. game.GetMap() .. ".txt", "DATA" ) )
    else
        sam_sits[game.GetMap()] = {}
    end
end )

local function UpdateSits( info )
    if not file.IsDir( "sam", "DATA" ) then file.CreateDir( "sam" ) end
    file.Write( "sam/" .. game.GetMap() .. ".txt", util.TableToJSON( info ) )
end

function SWEP:Initialize()
    self:SetHoldType( self.HoldType )
end

SWEP.time = 0
function SWEP:PrimaryAttack()
    if self.time > CurTime() then return end
    if not self:GetOwner():IsPlayer() or not self:GetOwner():IsSuperAdmin() then return end
    local tr = self:GetOwner():GetEyeTrace()
    table.insert( sam_sits[game.GetMap()], tr.HitPos )
    if SERVER then UpdateSits( sam_sits[game.GetMap()] ) end
    if CLIENT then
        surface.PlaySound( self.Primary.PlaceSit )
        notification.AddLegacy( "Sit position created!", NOTIFY_HINT, 3 )
    end

    self.time = CurTime() + 1
end

function SWEP:SecondaryAttack()
    if self.time > CurTime() then return end
    if not self:GetOwner():IsPlayer() or not self:GetOwner():IsSuperAdmin() then return end
    local tr = self:GetOwner():GetEyeTrace()
    for _, vec in pairs( sam_sits[game.GetMap()] ) do
        if tr.HitPos:DistToSqr( vec ) < 100 * 100 then
            table.RemoveByValue( sam_sits[game.GetMap()], vec )
            if SERVER then UpdateSits( sam_sits[game.GetMap()] ) end
            if #sam_sits[game.GetMap()] <= 0 and file.Exists( "sam/" .. game.GetMap() .. ".txt", "DATA" ) then file.Delete( "sam/" .. game.GetMap() .. ".txt" ) end
            if CLIENT then
                surface.PlaySound( self.Primary.RemoveSit )
                notification.AddLegacy( "Sit position removed!", NOTIFY_ERROR, 3 )
            end
        end
    end

    self.time = CurTime() + 1
end

function SWEP:Reload()
end

if CLIENT then
    function SWEP:DrawHUD()
        if istable( sam_sits[game.GetMap()] ) then
            for key, vec in pairs( sam_sits[game.GetMap()] ) do
                local pos = vec:ToScreen()
                if pos.visible then
                    draw.SimpleTextOutlined( "Sit Position: " .. tostring( key ), "DermaLarge", pos.x, pos.y - 15, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 2, color_black )
                end
            end
        end
    end
end
--PATH addons/__main/lua/weapons/weapon_ak47_beast.lua:
if SERVER then
	AddCSLuaFile()
else
	SWEP.ViewModelFOV = 60
	SWEP.BounceWeaponIcon = false
end

SWEP.Category = "Weapons"
SWEP.PrintName = "AK47 - Iron Beast"
SWEP.Slot = 2
SWEP.SlotPos = 1
SWEP.Base = "weapon_cf_base"
SWEP.Spawnable = true
SWEP.HoldType = "ar2"
SWEP.ViewModel = "models/cf/c_ak47_beast.mdl"
SWEP.WorldModel = "models/cf/w_ak47_beast.mdl"
SWEP.Primary.Sound = Sound( "weapons/ak47_beast/rifle_fire_1.wav" )
SWEP.Primary.Damage = 32
SWEP.Primary.Cone = 0.03
SWEP.Primary.ClipSize = 35
SWEP.Primary.Delay = 0.1
SWEP.Primary.DefaultClip = 140
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "ar2"
SWEP.MeleeRange = 62
SWEP.MeleeDamage = 51
SWEP.MeleeAttack = 0.22
SWEP.MeleeDuration = 0.85
SWEP.MeleeSound = "weapons/ak47_beast/rifle_melee.wav"
SWEP.MuzzleAttach = 2
SWEP.MuzzleScale = 1
SWEP.ShellEffect = true
function SWEP:CustomDeploy()
	timer.Simple( 0.03125, function()
		-- 1/fps
		if IsValid( self ) then self:SendWeaponAnim( ACT_VM_DEPLOY ) end
	end )
end
--PATH addons/_cuffs/lua/weapons/weapon_cuff_base.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- weapon_cuff_base.lua     SHARED --
--                                 --
-- Base swep for handcuffs.        --
-------------------------------------

SWEP.Base = "weapon_base"

SWEP.Category = "Other"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = ""

SWEP.Spawnable = false
SWEP.AdminOnly = false
SWEP.AdminSpawnable = false

SWEP.Slot = 3
SWEP.PrintName = "UnnamedHandcuff"

SWEP.ViewModelFOV = 60
SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.ViewModel = "models/weapons/c_bugbait.mdl"
SWEP.UseHands = true

SWEP.Primary.Recoil = 1
SWEP.Primary.Damage = 5
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0
SWEP.Primary.Delay = 0.25

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.ClipMax = -1

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.ClipMax = -1

SWEP.DeploySpeed = 1.5

SWEP.Spawnable = false
SWEP.AdminSpawnable = false
SWEP.AdminOnly = false

SWEP.PrimaryAnim = ACT_VM_PRIMARYATTACK
SWEP.ReloadAnim = ACT_VM_RELOAD
SWEP.HoldType = "slam"

SWEP.Spawnable = false
SWEP.AdminSpawnable = false
SWEP.AdminOnly = false

//
// Handcuff Vars
SWEP.CuffTime = 1.0 // Seconds to handcuff
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "phoenix_storms/metalfloor_2-3"
SWEP.CuffRope = "cable/cable2"

SWEP.CuffStrength = 0.1
SWEP.CuffRegen = 1
SWEP.RopeLength = 0

SWEP.CuffReusable = false // Can reuse (ie, not removed on use)
SWEP.CuffRecharge = 30 // Time before re-use

SWEP.CuffBlindfold = false

SWEP.CuffStrengthVariance = 0 // Randomise strangth
SWEP.CuffRegenVariance = 0 // Randomise regen

//
// Network Vars
function SWEP:SetupDataTables()
	self:NetworkVar( "Bool", 0, "IsCuffing" )
	self:NetworkVar( "Entity", 0, "Cuffing" )
	self:NetworkVar( "Float", 0, "CuffTime" )
end

//
// Standard SWEP functions
function SWEP:PrimaryAttack()
	if self:GetIsCuffing() then return end
	
	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
	
	if CLIENT then return end
	if self:GetCuffTime()>CurTime() then return end // On cooldown
	
	local tr = self:TargetTrace()
	if not tr then return end
	
	self:SetCuffTime( CurTime() + self.CuffTime )
	self:SetIsCuffing( true )
	self:SetCuffing( tr.Entity )
	
	sound.Play( self.CuffSound, self.Owner:GetShootPos(), 75, 100, 1 )
end
function SWEP:SecondaryAttack()
end
function SWEP:Reload()
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
end
function SWEP:Holster()
	if CLIENT and IsValid(self.Owner) and self.Owner==LocalPlayer() then
		local vm = self.Owner:GetViewModel()
		if not IsValid(vm) then return end
		
		vm:SetMaterial( "" )
	end
	if IsValid(self.cmdl_RightCuff) then self.cmdl_RightCuff:Remove() end
	if IsValid(self.cmdl_LeftCuff) then self.cmdl_LeftCuff:Remove() end
	
	return true
end
SWEP.OnRemove = SWEP.Holster

//
// Handcuff
function SWEP:DoHandcuff( target )
	if not (target and IsValid(target)) or target:IsHandcuffed() or not IsValid(self.Owner) then return end
	
	local cuff = target:Give( "weapon_handcuffed" )
	cuff:SetCuffStrength( self.CuffStrength + (math.Rand(-self.CuffStrengthVariance,self.CuffStrengthVariance)) )
	cuff:SetCuffRegen( self.CuffRegen + (math.Rand(-self.CuffRegenVariance,self.CuffRegenVariance)) )
	
	cuff:SetCuffMaterial( self.CuffMaterial )
	cuff:SetRopeMaterial( self.CuffRope )
	
	cuff:SetKidnapper( self.Owner )
	cuff:SetRopeLength( self.RopeLength )
	
	cuff:SetCanBlind( self.CuffBlindfold )
	
	cuff.CuffType = self:GetClass() or ""
	
	hook.Call( "OnHandcuffed", GAMEMODE, self.Owner, target, cuff )
	
	if not self.CuffReusable then
		if IsValid(self.Owner) then self.Owner:ConCommand( "lastinv1" ) end
		self:Remove()
	end
end

//
// Think
function SWEP:Think()
	if SERVER then
		if self:GetIsCuffing() then
			local tr = self:TargetTrace()
			if (not tr) or tr.Entity~=self:GetCuffing() then
				self:SetIsCuffing(false)
				self:SetCuffTime( 0 )
				return
			end
			
			if CurTime()>self:GetCuffTime() then
				self:SetIsCuffing( false )
				self:SetCuffTime( CurTime() + self.CuffRecharge )
				self:DoHandcuff( self:GetCuffing() )
			end
		end
	end
end

//
// Get Target
function SWEP:TargetTrace()
	if not IsValid(self.Owner) then return end
	
	local tr = util.TraceLine( {start=self.Owner:GetShootPos(), endpos=(self.Owner:GetShootPos() + (self.Owner:GetAimVector()*50)), filter={self, self.Owner}} )
	if IsValid(tr.Entity) and tr.Entity:IsPlayer() and tr.Entity~=self.Owner and not tr.Entity:IsHandcuffed() then
		if hook.Run( "CuffsCanHandcuff", self.Owner, tr.Entity )==false then return end
		return tr
	end
end

//
// HUD

local col1 = Color(255,255,255,20)
local col2 = Color(255,0,0)
local col3 = Color(0,255,0)
local font0
if CLIENT then
	font0 = onyx.Font('Comfortaa Bold@20')
end
function SWEP:DrawHUD()
	local w,h = (ScrW()*0.5), (ScrH()*0.5)

	if not self:GetIsCuffing() then
		if self:GetCuffTime()<=CurTime() then return end
		
		surface.SetDrawColor( color_black )
		surface.DrawOutlinedRect( w-101, h+54, 202, 22 )
		surface.SetDrawColor( col1 )
		surface.DrawRect( w-100, h+55, 200, 20 )
		
		local CuffingPercent = math.Clamp( ((self:GetCuffTime()-CurTime())/self.CuffRecharge), 0, 1 )
		onyx.hud.ScissorRect( w-100, h+55, CuffingPercent*200, 20, function()
			surface.SetDrawColor( col3 )
			surface.DrawRect( w-100,h+55, 200,20 )

			onyx.DrawMatGradient(w-100,h+55, 200,20, LEFT, col2)
		end)
		
		return
	end
	
	onyx.hud.DrawShadowText2D( "Одягаємо наручники...", font0, w+1, h+31, color_white, TEXT_ALIGN_CENTER )
	
	surface.SetDrawColor( color_black )
	surface.DrawOutlinedRect( w-101, h+54, 202, 22 )
	surface.SetDrawColor( col1 )
	surface.DrawRect( w-100, h+55, 200, 20 )
	
	local CuffingPercent = math.Clamp( 1-((self:GetCuffTime()-CurTime())/self.CuffTime), 0, 1 )
	
	onyx.hud.ScissorRect( w-100, h+55, CuffingPercent*200, 20, function()
		surface.SetDrawColor( col3 )
		surface.DrawRect( w-100,h+55, 200,20 )

		onyx.DrawMatGradient(w-100,h+55, 200,20, LEFT, col2)
	end)
end

//
// Rendering
local renderpos = {
	left = {pos=Vector(0,0,0), vel=Vector(0,0,0), gravity=1, ang=Angle(0,30,90)},
	right = {bone = "ValveBiped.Bip01_R_Hand", pos=Vector(3.2,2.1,0.4), ang=Angle(-2,0,80), scale = Vector(0.045,0.045,0.03)},
	rope = {l = Vector(0,0,2.0), r = Vector(2.3,-1.9,2.7)},
}
local CuffMdl = "models/hunter/tubes/tube2x2x1.mdl"
function SWEP:ViewModelDrawn( vm )
	if not IsValid(vm) then return end
	
	vm:SetMaterial( "engine/occlusionproxy" )
	
	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_LeftCuff:SetNoDraw( true )
		self.cmdl_LeftCuff:SetParent( vm )
		
		renderpos.left.pos = self.Owner:GetPos()
	end
	if not IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_RightCuff:SetNoDraw( true )
		self.cmdl_RightCuff:SetParent( vm )
	end
	
	-- local lpos, lang = self:GetBonePos( renderpos.left.bone, vm )
	local rpos, rang = self:GetBonePos( renderpos.right.bone, vm )
	if not (rpos and rang) then return end
	
	// Right
	local fixed_rpos = rpos + (rang:Forward()*renderpos.right.pos.x) + (rang:Right()*renderpos.right.pos.y) + (rang:Up()*renderpos.right.pos.z)
	self.cmdl_RightCuff:SetPos( fixed_rpos )
	local u,r,f = rang:Up(), rang:Right(), rang:Forward() // Prevents moving axes
	rang:RotateAroundAxis( u, renderpos.right.ang.y )
	rang:RotateAroundAxis( r, renderpos.right.ang.p )
	rang:RotateAroundAxis( f, renderpos.right.ang.r )
	self.cmdl_RightCuff:SetAngles( rang )
	
	local matrix = Matrix()
	matrix:Scale( renderpos.right.scale )
	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_RightCuff:SetMaterial( self.CuffMaterial )
	self.cmdl_RightCuff:DrawModel()
	
	// Left
	if CurTime()>(renderpos.left.NextThink or 0) then
		local dist = renderpos.left.pos:Distance( fixed_rpos )
		if dist>100 then
			renderpos.left.pos = fixed_rpos
			renderpos.left.vel = Vector(0,0,0)
		elseif dist > 10 then
			local target = (fixed_rpos - renderpos.left.pos)*0.3
			renderpos.left.vel.x = math.Approach( renderpos.left.vel.x, target.x, 1 )
			renderpos.left.vel.y = math.Approach( renderpos.left.vel.y, target.y, 1 )
			renderpos.left.vel.z = math.Approach( renderpos.left.vel.z, target.z, 3 )
		end
		
		renderpos.left.vel.x = math.Approach( renderpos.left.vel.x, 0, 0.5 )
		renderpos.left.vel.y = math.Approach( renderpos.left.vel.y, 0, 0.5 )
		renderpos.left.vel.z = math.Approach( renderpos.left.vel.z, 0, 0.5 )
		-- if renderpos.left.vel:Length()>10 then renderpos.left.vel:Mul(0.1) end
		
		local targetZ = ((fixed_rpos.z - 10) - renderpos.left.pos.z) * renderpos.left.gravity
		renderpos.left.vel.z = math.Approach( renderpos.left.vel.z, targetZ, 3 )
		
		renderpos.left.pos:Add( renderpos.left.vel )
		
		-- renderpos.left.NextThink = CurTime()+0.01
	end
	
	self.cmdl_LeftCuff:SetPos( renderpos.left.pos )
	self.cmdl_LeftCuff:SetAngles( renderpos.left.ang )
	
	-- self.cmdl_LeftCuff:SetAngles( rang )
	local matrix = Matrix()
	matrix:Scale( renderpos.right.scale )
	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_LeftCuff:SetMaterial( self.CuffMaterial )
	self.cmdl_LeftCuff:DrawModel()
	
	// Rope
	if not self.RopeMat then self.RopeMat = Material(self.CuffRope) end
	
	render.SetMaterial( self.RopeMat )
	render.DrawBeam( renderpos.left.pos + renderpos.rope.l,
		rpos + (rang:Forward()*renderpos.rope.r.x) + (rang:Right()*renderpos.rope.r.y) + (rang:Up()*renderpos.rope.r.z),
		0.7, 0, 5, color_white )
end

SWEP.wrender = {
	left = {pos=Vector(0,0,0), vel=Vector(0,0,0), gravity=1, ang=Angle(0,30,90)},
	right = {bone = "ValveBiped.Bip01_R_Hand", pos=Vector(2.95,2.5,-0.2), ang=Angle(30,0,90), scale = Vector(0.044,0.044,0.044)},
	rope = {l = Vector(0,0,2), r = Vector(3,-1.65,1)},
}
function SWEP:DrawWorldModel()
	if not IsValid(self.Owner) then return end
	local wrender = self.wrender
	
	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		if not IsValid(self.cmdl_LeftCuff) then return end
		self.cmdl_LeftCuff:SetNoDraw( true )
	end
	if not IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_RightCuff:SetNoDraw( true )
	end
	
	local rpos, rang = self:GetBonePos( wrender.right.bone, self.Owner )
	if not (rpos and rang) then return end
	
	// Right
	local fixed_rpos = rpos + (rang:Forward()*wrender.right.pos.x) + (rang:Right()*wrender.right.pos.y) + (rang:Up()*wrender.right.pos.z)
	self.cmdl_RightCuff:SetPos( fixed_rpos )
	local u,r,f = rang:Up(), rang:Right(), rang:Forward() // Prevents moving axes
	rang:RotateAroundAxis( u, wrender.right.ang.y )
	rang:RotateAroundAxis( r, wrender.right.ang.p )
	rang:RotateAroundAxis( f, wrender.right.ang.r )
	self.cmdl_RightCuff:SetAngles( rang )
	
	local matrix = Matrix()
	matrix:Scale( wrender.right.scale )
	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_RightCuff:SetMaterial( self.CuffMaterial )
	self.cmdl_RightCuff:DrawModel()
	
	// Left
	if CurTime()>(wrender.left.NextThink or 0) then
		local dist = wrender.left.pos:Distance( fixed_rpos )
		if dist>100 then
			wrender.left.pos = fixed_rpos
			wrender.left.vel = Vector(0,0,0)
		elseif dist > 10 then
			local target = (fixed_rpos - wrender.left.pos)*0.3
			wrender.left.vel.x = math.Approach( wrender.left.vel.x, target.x, 1 )
			wrender.left.vel.y = math.Approach( wrender.left.vel.y, target.y, 1 )
			wrender.left.vel.z = math.Approach( wrender.left.vel.z, target.z, 3 )
		end
		
		wrender.left.vel.x = math.Approach( wrender.left.vel.x, 0, 0.5 )
		wrender.left.vel.y = math.Approach( wrender.left.vel.y, 0, 0.5 )
		wrender.left.vel.z = math.Approach( wrender.left.vel.z, 0, 0.5 )
		-- if wrender.left.vel:Length()>10 then wrender.left.vel:Mul(0.1) end
		
		local targetZ = ((fixed_rpos.z - 10) - wrender.left.pos.z) * wrender.left.gravity
		wrender.left.vel.z = math.Approach( wrender.left.vel.z, targetZ, 3 )
		
		wrender.left.pos:Add( wrender.left.vel )
		
		-- wrender.left.NextThink = CurTime()+0
	end
	
	self.cmdl_LeftCuff:SetPos( wrender.left.pos )
	self.cmdl_LeftCuff:SetAngles( wrender.left.ang )
	
	local matrix = Matrix()
	matrix:Scale( wrender.right.scale )
	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_LeftCuff:SetMaterial( self.CuffMaterial )
	self.cmdl_LeftCuff:DrawModel()
	
	// Rope
	if not self.RopeMat then self.RopeMat = Material(self.CuffRope) end
	
	render.SetMaterial( self.RopeMat )
	render.DrawBeam( wrender.left.pos + wrender.rope.l,
		rpos + (rang:Forward()*wrender.rope.r.x) + (rang:Right()*wrender.rope.r.y) + (rang:Up()*wrender.rope.r.z),
		0.7, 0, 5, color_white )
end

//
// Bones
function SWEP:GetBonePos( bonename, vm )
	local bone = vm:LookupBone( bonename )
	if not bone then return end
	
	local pos,ang = Vector(0,0,0),Angle(0,0,0)
	local matrix = vm:GetBoneMatrix( bone )
	if matrix then
		pos = matrix:GetTranslation()
		ang = matrix:GetAngles()
	end
	
	if self.ViewModelFlip then ang.r = -ang.r end
	
	-- if pos.x==0 and pos.y==0 and pos.z==0 then print( bonename, vm ) end
	return pos, ang
end
--PATH addons/_drones/lua/weapons/weapon_drr_jammer.lua:
AddCSLuaFile()

SWEP.PrintName	= "Signal Jammer"
SWEP.Category = "Drones Rewrite Tools"
SWEP.Purpose = "Tool that allows you to jam drones"

SWEP.Spawnable	= true 
SWEP.UseHands	= true
SWEP.DrawAmmo	= false

SWEP.ViewModelFOV	= 55
SWEP.Slot			= 0
SWEP.SlotPos		= 6

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"

SWEP.ViewModel = "models/dronesrewrite/jammer/c_jammer.mdl"
SWEP.WorldModel = "models/dronesrewrite/jammer/w_jammer.mdl"

SWEP.TURNON = "buttons/button17.wav"
SWEP.SCREEN = {}
SWEP.SCREEN.ENABLED = false

function SWEP:Initialize()
	self:SetHoldType("pistol")
end

function SWEP:PrimaryAttack()
	self.Weapon:SendWeaponAnim(ACT_VM_PRIMARYATTACK)

-- egor opyat nichego ne sdelal
	timer.Simple(self:SequenceDuration(), function()
		if not IsValid(self) or not IsValid(self.Owner) then return end

		local entsInSphere = ents.FindInSphere(self:GetPos(), 200)
		for k, v in ipairs(entsInSphere) do
			if not v.IS_DRONE then continue end
			if v == self then continue end
			if v.ImmuneToJammer then continue end

			local phys = v:GetPhysicsObject()
			if not phys:IsValid() then continue end

			phys:SetVelocity((v:GetPos() - self:GetPos()):GetNormal() * 150)
			phys:AddAngleVelocity(VectorRand() * 500)
			
			v:TakeDamage(math.random(45, 60), self.Owner, self)

			if v.IS_DRR then
				v:SetEnabled(false)
				timer.Simple(10, function()
					if v:IsValid() then 
						v:SetEnabled(true)
					end
				end)
			end

			ParticleEffect("vapor_collapse_drr", v:GetPos(), Angle(0, 0, 0))
			v:TakeDamage(math.random(10,15), self.Owner, self)
			v:EmitSound("drones/nio_dissolve.wav", 100, 90)
		end
	end)

	timer.Simple(self:SequenceDuration() * 0.5, function()
		if not IsValid(self) then return end

		self:EmitSound("buttons/button14.wav", 50, 90)
	end)

	self:SetNextPrimaryFire(CurTime() + 15)
end

function SWEP:SecondaryAttack()
	self.Weapon:SendWeaponAnim(ACT_VM_SECONDARYATTACK)
end

function SWEP:OnRemove()
	timer.Stop("DRR_J_weapon_idle")
	timer.Stop("DRR_J_doBeep")
end

function SWEP:Holster()
	self:OnRemove()
	self.SCREEN.ENABLED = false
	return true
end

function SWEP:Deploy()
	self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
	self:DoIdle()
	self:SetDeploySpeed(1)

	timer.Create("DRR_J_doBeep", self:SequenceDuration()-0.8, 1, function()
		self.Owner:EmitSound(self.TURNON, 65, 150)
		self.SCREEN.ENABLED = true
	end)
	
	if CLIENT then
		timer.Create("DRR_J_weapon_idle", self:SequenceDuration(), 2, function() 
			if IsValid(self) then 
				self:SendWeaponAnim(ACT_VM_IDLE) 
				self:DoIdle()
			end 
		end)
	end
	
	return true
end

function SWEP:DoIdle()
	timer.Create("DRR_J_weapon_idle", self:SequenceDuration(), 2, function() 
		if IsValid(self) then 
			self:SendWeaponAnim(ACT_VM_IDLE) 
			self:DoIdle()
		end 
	end)
end
--PATH addons/_cuffs/lua/weapons/weapon_handcuffed.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- weapon_handcuffed.lua    SHARED --
--                                 --
-- Handcuffed. Limits what         --
-- equipping player can do.        --
-------------------------------------

SWEP.Base = "weapon_base"

SWEP.Category = "Other"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = ""

SWEP.Spawnable = false
SWEP.AdminSpawnable = false
SWEP.AdminOnly = false

SWEP.Slot = 4
SWEP.PrintName = "Руки"

SWEP.ViewModelFOV = 60
SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.ViewModel = "models/weapons/c_arms_citizen.mdl"
SWEP.UseHands = true

SWEP.Primary.Recoil = 1
SWEP.Primary.Damage = 5
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0
SWEP.Primary.Delay = 1

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.ClipMax = -1

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.ClipMax = -1

SWEP.DeploySpeed = 1.5

SWEP.PrimaryAnim = ACT_VM_PRIMARYATTACK
SWEP.ReloadAnim = ACT_VM_RELOAD
SWEP.HoldType = "duel"

SWEP.IsHandcuffs = true
SWEP.CuffType = ""

// For anything that might try to drop this
SWEP.CanDrop = false
SWEP.PreventDrop = true
-- Missing anything?

//
// DataTables
function SWEP:SetupDataTables()
	self:NetworkVar( "Entity", 0, "Kidnapper" )
	self:NetworkVar( "Entity", 1, "FriendBreaking" )
	
	self:NetworkVar( "Float", 0, "RopeLength" )
	self:NetworkVar( "Float", 1, "CuffBroken" )
	self:NetworkVar( "Float", 2, "CuffStrength" )
	self:NetworkVar( "Float", 3, "CuffRegen" )
	
	self:NetworkVar( "String", 0, "RopeMaterial" )
	self:NetworkVar( "String", 1, "CuffMaterial" )
	
	self:NetworkVar( "Bool", 2, "CanBlind" )
	self:NetworkVar( "Bool", 3, "IsBlind" )
end

hook.Add( "canDropWeapon", 'DropCuffs', function(ply, wep) if wep:GetClass() == 'weapon_handcuffed' then return false end end)

//
// Initialize
function SWEP:Initialize()
	if self:GetCuffStrength()<=0 then self:SetCuffStrength(1) end
	if self:GetCuffRegen()<=0 then self:SetCuffRegen(1) end
	self:SetCuffBroken( 0 )
	
	self:SetHoldType( self.HoldType )
end

//
// Standard SWEP functions
function SWEP:PrimaryAttack()
	if SERVER then self:AttemptBreak() end
end
function SWEP:SecondaryAttack() end
function SWEP:Reload() end

//
// Equip and Holster
function SWEP:Equip( newOwner )
	newOwner:SelectWeapon( self:GetClass() )
	
	timer.Simple( 0.1, function() // Fucking FA:S
		if IsValid(self) and  IsValid(newOwner) and newOwner:GetActiveWeapon()~=self then
			local wep = newOwner:GetActiveWeapon()
			if not IsValid(wep) then return end
			
			local oHolster = wep.Holster
			wep.Holster = function() return true end
			newOwner:SelectWeapon( self:GetClass() )
			wep.Holster = oHolster
		end
	end)
	
	return true
end
function SWEP:Holster()
	return false
end

//
// Deploy
function SWEP:Deploy()
	local viewModel = self.Owner:GetViewModel()
	viewModel:SendViewModelMatchingSequence( viewModel:LookupSequence("fists_idle_01") )
	
	return true
end
function SWEP:PreDrawViewModel( viewModel ) // Fixes visible base hands
	viewModel:SetMaterial( "engine/occlusionproxy" )
end
function SWEP:OnRemove() // Fixes invisible other weapons
	if IsValid(self.Owner) then
		local viewModel = self.Owner:GetViewModel()
		if IsValid(viewModel) then viewModel:SetMaterial("") end
	end
	if IsValid( self.cmdl_LeftCuff ) then self.cmdl_LeftCuff:Remove() end
	if IsValid( self.cmdl_RightCuff ) then self.cmdl_RightCuff:Remove() end
	return true
end

//
// Release
function SWEP:Uncuff()
	local ply = IsValid(self.Owner) and self.Owner
	
	self:Remove()
	
	if ply then ply:ConCommand( "lastinv1" ) end
end

//
// Breakout
if SERVER then
	concommand.Add('lastinv1', function(pl)
		-- FIX SCRIPT STUPID DEV
		pl:SelectWeapon("weapon_physgun")
	end)

	local BreakSound = Sound( "physics/metal/metal_barrel_impact_soft4.wav" )
	function SWEP:Breakout()
		if IsValid(self.Owner) then
			sound.Play( BreakSound, self.Owner:GetShootPos(), 75, 100, 1 )
			if IsValid( self:GetFriendBreaking() ) then
				hook.Call( "OnHandcuffBreak", GAMEMODE, self.Owner, self, self:GetFriendBreaking() )
			else
				hook.Call( "OnHandcuffBreak", GAMEMODE, self.Owner, self )
			end
		end
		
		self:Uncuff()
	end
	function SWEP:AttemptBreak()
		self:SetCuffBroken( self:GetCuffBroken() + math.abs(4/self:GetCuffStrength()) )
		
		if self:GetCuffBroken()>=100 then
			self:Breakout()
		end
	end
	
	local function GetTrace( ply )
		local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
		if IsValid(tr.Entity) and tr.Entity:IsPlayer() then
			local cuffed,wep = tr.Entity:IsHandcuffed()
			if cuffed then return tr,wep end
		end
	end
	function SWEP:Think()
		if (self.NextRegen or 0)<=CurTime() then
			local regen = self:GetCuffRegen()
			local friend = self:GetFriendBreaking()
			if IsValid(friend) and friend:IsPlayer() then
				local tr = GetTrace(friend)
				if tr and tr.Entity==self.Owner then
					regen = (regen*0.5) - (2/self:GetCuffStrength())
				else
					self:SetFriendBreaking( nil )
				end
			end
			
			self:SetCuffBroken( math.Approach( self:GetCuffBroken(), regen<0 and 100 or 0, math.abs(regen) ) )
			self.NextRegen = CurTime()+0.05
			
			if self:GetCuffBroken()>=100 then self:Breakout() end
		end
		if IsValid(self:GetKidnapper()) and (self:GetKidnapper():IsPlayer() and not self:GetKidnapper():Alive()) then
			self:SetKidnapper( nil )
		end
		if IsValid(self.Owner) then
			self.Owner.KnockoutTimer = CurTime()+10 // Fucking DarkRP
		end
	end
end

//
// UI
if CLIENT then
	local col1 = Color(255,255,255,20)
	local col2 = Color(255,0,0)
	local col3 = Color(0,255,0)
	local col4 = Color(0,0,0, 253)
	local font0 = onyx.Font('Comfortaa Bold@20')
	function SWEP:DrawHUD()
		local w,h = (ScrW()*0.5), (ScrH()*0.5)
		
		local TextPos = h+30
		
		onyx.hud.DrawShadowText2D( "Ви в наручниках!", font0, w, TextPos, color_white, TEXT_ALIGN_CENTER )
		
		if self:GetIsBlind() then
			TextPos = TextPos+20
			onyx.hud.DrawShadowText2D( "Очі були зав'язані для вас", font0, w, TextPos, color_white, TEXT_ALIGN_CENTER )
		end
		
		TextPos = TextPos+20
		str = string.format("%s щоб звільнитись", (input.LookupBinding("+attack") or "[Primary Fire]"):upper())
		onyx.hud.DrawShadowText2D( str, font0, w, TextPos, color_white, TEXT_ALIGN_CENTER )
		
		TextPos = TextPos+25
		surface.SetDrawColor( color_black )
		surface.DrawOutlinedRect( w-101, TextPos-1, 202, 22 )
		surface.SetDrawColor( col1 )
		surface.DrawRect( w-100, TextPos, 200, 20 )
		
		onyx.hud.ScissorRect( w-100, TextPos, ((self:GetCuffBroken()/100)*200), 20, function()
			surface.SetDrawColor( col3 )
			surface.DrawRect( w-100,TextPos, 200,20 )

			onyx.DrawMatGradient(w-100,TextPos, 200,20, LEFT, col2)
		end)
	end
	function SWEP:DrawHUDBackground()
		if self:GetIsBlind() then
			surface.SetDrawColor( col4 )
			surface.DrawRect( 0,0, ScrW(), ScrH() )
			
			surface.SetDrawColor( color_black )
			for i=1,ScrH(),5 do
				surface.DrawRect( 0,i, ScrW(), 4 )
			end
			for i=1,ScrW(),5 do
				surface.DrawRect( i,0, 4,ScrH() )
			end
		end
	end
end

//
// Rendering
local renderpos = {
	left = {pos=Vector(0.4,-0.15,-0.45), ang=Angle(90,0,0)},
	right = {pos=Vector(0.2,-0.15,0.35), ang=Angle(100,0,0)},
	rope = {l = Vector(-0.2,1.3,-0.25), r = Vector(0.4,1.4,-0.2)},
}
local CuffMdl = "models/hunter/tubes/tube2x2x1.mdl"
local DefaultRope = "cable/cable2"
function SWEP:ViewModelDrawn( vm )
	if not IsValid(vm) then return end
	
	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		if not IsValid(self.cmdl_LeftCuff) then return end
		self.cmdl_LeftCuff:SetNoDraw( true )
		self.cmdl_LeftCuff:SetParent( vm )
	end
	if not IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		self.cmdl_RightCuff:SetNoDraw( true )
		self.cmdl_RightCuff:SetParent( vm )
	end
	
	local lpos, lang = self:GetBonePos( "ValveBiped.Bip01_L_Wrist", vm )
	local rpos, rang = self:GetBonePos( "ValveBiped.Bip01_R_Wrist", vm )
	if not (lpos and rpos and lang and rang) then return end
	
	// Left
	self.cmdl_LeftCuff:SetPos( lpos + (lang:Forward()*renderpos.left.pos.x) + (lang:Right()*renderpos.left.pos.y) + (lang:Up()*renderpos.left.pos.z) )
	local u,r,f = lang:Up(), lang:Right(), lang:Forward() // Prevents moving axes
	lang:RotateAroundAxis( u, renderpos.left.ang.y )
	lang:RotateAroundAxis( r, renderpos.left.ang.p )
	lang:RotateAroundAxis( f, renderpos.left.ang.r )
	self.cmdl_LeftCuff:SetAngles( lang )
	
	local matrix = Matrix()
	matrix:Scale( Vector(0.035,0.035,0.015) )
	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_LeftCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_LeftCuff:DrawModel()
	
	// Right
	self.cmdl_RightCuff:SetPos( rpos + (rang:Forward()*renderpos.right.pos.x) + (rang:Right()*renderpos.right.pos.y) + (rang:Up()*renderpos.right.pos.z) )
	local u,r,f = rang:Up(), rang:Right(), rang:Forward() // Prevents moving axes
	rang:RotateAroundAxis( u, renderpos.right.ang.y )
	rang:RotateAroundAxis( r, renderpos.right.ang.p )
	rang:RotateAroundAxis( f, renderpos.right.ang.r )
	self.cmdl_RightCuff:SetAngles( rang )
	
	local matrix = Matrix()
	matrix:Scale( Vector(0.035,0.035,0.015) )
	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_RightCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_RightCuff:DrawModel()
	
	// Rope
	if self:GetRopeMaterial()~=self.LastMatStr then
		self.RopeMat = Material( self:GetRopeMaterial() )
		self.LastMatStr = self:GetRopeMaterial()
	end
	if not self.RopeMat then self.RopeMat = Material(DefaultRope) end
	
	render.SetMaterial( self.RopeMat )
	render.DrawBeam( lpos + (lang:Forward()*renderpos.rope.l.x) + (lang:Right()*renderpos.rope.l.y) + (lang:Up()*renderpos.rope.l.z),
		rpos + (rang:Forward()*renderpos.rope.r.x) + (rang:Right()*renderpos.rope.r.y) + (rang:Up()*renderpos.rope.r.z),
		0.7, 0, 5, color_white )
end

local wrender = {
	left = {pos=Vector(0,0,0), ang=Angle(90,0,0)},
	right = {pos=Vector(0.2,0,0), ang=Angle(90,0,0)},
	rope = {l = Vector(-0.2,1.3,-0.25), r = Vector(0.4,1.4,-0.2)},
}
function SWEP:DrawWorldModel()
	if not IsValid(self.Owner) then return end
	
	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		if not IsValid(self.cmdl_LeftCuff) then return end
		self.cmdl_LeftCuff:SetNoDraw( true )
		-- self.cmdl_LeftCuff:SetParent( vm )
	end
	if not IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		if not IsValid(self.cmdl_RightCuff) then return end
		self.cmdl_RightCuff:SetNoDraw( true )
		-- self.cmdl_RightCuff:SetParent( vm )
	end
	
	local lpos, lang = self:GetBonePos( "ValveBiped.Bip01_L_Hand", self.Owner )
	local rpos, rang = self:GetBonePos( "ValveBiped.Bip01_R_Hand", self.Owner )
	if not (lpos and rpos and lang and rang) then return end
	
	// Left
	self.cmdl_LeftCuff:SetPos( lpos + (lang:Forward()*wrender.left.pos.x) + (lang:Right()*wrender.left.pos.y) + (lang:Up()*wrender.left.pos.z) )
	local u,r,f = lang:Up(), lang:Right(), lang:Forward() // Prevents moving axes
	lang:RotateAroundAxis( u, wrender.left.ang.y )
	lang:RotateAroundAxis( r, wrender.left.ang.p )
	lang:RotateAroundAxis( f, wrender.left.ang.r )
	self.cmdl_LeftCuff:SetAngles( lang )
	
	local matrix = Matrix()
	matrix:Scale( Vector(0.035,0.035,0.035) )
	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_LeftCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_LeftCuff:DrawModel()
	
	// Right
	self.cmdl_RightCuff:SetPos( rpos + (rang:Forward()*wrender.right.pos.x) + (rang:Right()*wrender.right.pos.y) + (rang:Up()*wrender.right.pos.z) )
	local u,r,f = rang:Up(), rang:Right(), rang:Forward() // Prevents moving axes
	rang:RotateAroundAxis( u, wrender.right.ang.y )
	rang:RotateAroundAxis( r, wrender.right.ang.p )
	rang:RotateAroundAxis( f, wrender.right.ang.r )
	self.cmdl_RightCuff:SetAngles( rang )
	
	local matrix = Matrix()
	matrix:Scale( Vector(0.035,0.035,0.035) )
	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )
	
	self.cmdl_RightCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_RightCuff:DrawModel()
	
	// Rope
	if (lpos.x==0 and lpos.y==0 and lpos.z==0) or (rpos.x==0 and rpos.y==0 and rpos.z==0) then return end // Rope accross half the map...
	
	if self:GetRopeMaterial()~=self.LastMatStr then
		self.RopeMat = Material( self:GetRopeMaterial() )
		self.LastMatStr = self:GetRopeMaterial()
	end
	if not self.RopeMat then self.RopeMat = Material(DefaultRope) end
	
	render.SetMaterial( self.RopeMat )
	render.DrawBeam( lpos + (lang:Forward()*wrender.rope.l.x) + (lang:Right()*wrender.rope.l.y) + (lang:Up()*wrender.rope.l.z),
		rpos + (rang:Forward()*wrender.rope.r.x) + (rang:Right()*wrender.rope.r.y) + (rang:Up()*wrender.rope.r.z),
		0.7, 0, 5, color_white )
end

//
// Bones
function SWEP:GetBonePos( bonename, vm )
	local bone = vm:LookupBone( bonename )
	if not bone then return end
	
	local pos,ang = Vector(0,0,0),Angle(0,0,0)
	local matrix = vm:GetBoneMatrix( bone )
	if matrix then
		pos = matrix:GetTranslation()
		ang = matrix:GetAngles()
	end
	
	if self.ViewModelFlip then ang.r = -ang.r end
	
	-- if pos.x==0 and pos.y==0 and pos.z==0 then print( bonename, vm ) end
	return pos, ang
end
--PATH addons/_avatar/lua/weapons/weapon_sokka_sword.lua:
if CLIENT then
	SWEP.DrawWeaponInfoBox = false
	SWEP.BounceWeaponIcon = false
	language.Add( "weapon_sokka_sword", "Sokka Sword" )
end

SWEP.PrintName = "Sokka Sword"
SWEP.Category = "Avatar"
SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.AdminOnly = false
SWEP.ViewModelFOV = 75
SWEP.ViewModel = "models/weapons/c_invisstick2.mdl"
SWEP.WorldModel = "models/avatar/sokka_sword.mdl"
SWEP.ViewModelFlip = false
SWEP.BobScale = 1
SWEP.SwayScale = 1
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.Weight = 0
SWEP.Slot = 1
SWEP.SlotPos = 10
SWEP.UseHands = true
SWEP.HoldType = "melee"
SWEP.FiresUnderwater = true
SWEP.DrawCrosshair = true
SWEP.DrawAmmo = true
SWEP.CSMuzzleFlashes = 1
SWEP.Base = "weapon_base"
SWEP.ShowViewModel = false
SWEP.ShowWorldModel = true
SWEP.Idle = 0
SWEP.IdleTimer = CurTime()
SWEP.Primary.Sound = Sound( "common/null.wav" )
SWEP.Primary.ClipSize = 1
SWEP.Primary.DefaultClip = 1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Damage = 65
SWEP.Primary.DelayMiss = 0.5
SWEP.Primary.DelayHit = 0.4
SWEP.Primary.Force = 5000
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Delay = 0.5
SWEP.ViewModelBoneMods = {}
SWEP.VElements = {
	["v_element"] = {
		type = "Model",
		model = "models/avatar/sokka_sword.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector( 2.918, 1.518, -0.539 ),
		angle = Angle( 180, 90, 0 ),
		size = Vector( 1, 1, 1 ),
		color = Color( 255, 255, 255, 255 ),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
	self:SetWeaponHoldType( self.HoldType )
	self.Idle = 0
	self.IdleTimer = CurTime() + 1
	if CLIENT then
		-- Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )
		self:SetWeaponHoldType( self.HoldType )
		self:CreateModels( self.VElements ) -- create viewmodels
		-- init view model bone build function
		if IsValid( self:GetOwner() ) then
			local vm = self:GetOwner():GetViewModel()
			if IsValid( vm ) then
				self:ResetBonePositions( vm )
				-- Init viewmodel visibility
				if self.ShowViewModel == nil or self.ShowViewModel then
					vm:SetColor( Color( 255, 255, 255, 255 ) )
				else
					-- we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor( Color( 255, 255, 255, 1 ) )
					-- ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					-- however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial( "Debug/hsv" )
				end
			end
		end
	end
end

----------------------------------------------------
if CLIENT then
	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		local vm = self:GetOwner():GetViewModel()
		if not IsValid( vm ) then return end
		if not self.VElements then return end
		self:UpdateBonePositions( vm )
		if not self.vRenderOrder then
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}
			for k, v in pairs( self.VElements ) do
				if v.type == "Model" then
					table.insert( self.vRenderOrder, 1, k )
				elseif v.type == "Sprite" or v.type == "Quad" then
					table.insert( self.vRenderOrder, k )
				end
			end
		end

		for _, name in ipairs( self.vRenderOrder ) do
			local v = self.VElements[name]
			if not v then
				self.vRenderOrder = nil
				break
			end

			if v.hide then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			if not v.bone then continue end
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			if not pos then continue end
			if v.type == "Model" and IsValid( model ) then
				model:SetPos( pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				model:SetAngles( ang )
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale( v.size )
				model:EnableMatrix( "RenderMultiply", matrix )
				if v.material == "" then
					model:SetMaterial( "" )
				elseif model:GetMaterial() ~= v.material then
					model:SetMaterial( v.material )
				end

				if v.skin and v.skin ~= model:GetSkin() then model:SetSkin( v.skin ) end
				if v.bodygroup then
					for k, v in ipairs( v.bodygroup ) do
						if model:GetBodygroup( k ) ~= v then model:SetBodygroup( k, v ) end
					end
				end

				if v.surpresslightning then render.SuppressEngineLighting( true ) end
				render.SetColorModulation( v.color.r / 255, v.color.g / 255, v.color.b / 255 )
				render.SetBlend( v.color.a / 255 )
				model:DrawModel()
				render.SetBlend( 1 )
				render.SetColorModulation( 1, 1, 1 )
				if v.surpresslightning then render.SuppressEngineLighting( false ) end
			elseif v.type == "Sprite" and sprite then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial( sprite )
				render.DrawSprite( drawpos, v.size.x, v.size.y, v.color )
			elseif v.type == "Quad" and v.draw_func then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				cam.Start3D2D( drawpos, ang, v.size )
				v.draw_func( self )
				cam.End3D2D()
			end
		end
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		local bone, pos, ang
		if tab.rel and tab.rel ~= "" then
			local v = basetab[tab.rel]
			if not v then return end
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			if not pos then return end
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis( ang:Up(), v.angle.y )
			ang:RotateAroundAxis( ang:Right(), v.angle.p )
			ang:RotateAroundAxis( ang:Forward(), v.angle.r )
		else
			bone = ent:LookupBone( bone_override or tab.bone )
			if not bone then return end
			pos, ang = Vector( 0, 0, 0 ), Angle( 0, 0, 0 )
			local m = ent:GetBoneMatrix( bone )
			if m then pos, ang = m:GetTranslation(), m:GetAngles() end
			if IsValid( self:GetOwner() ) and self:GetOwner():IsPlayer() and ent == self:GetOwner():GetViewModel() and self.ViewModelFlip then
				ang.r = -ang.r -- Fixes mirrored models
			end
		end
		return pos, ang
	end

	function SWEP:CreateModels( tab )
		if not tab then return end
		for _, v in pairs( tab ) do
			if v.type == "Model" and v.model and v.model ~= "" and ( not IsValid( v.modelEnt ) or v.createdModel ~= v.model ) and string.find( v.model, ".mdl" ) and file.Exists( v.model, "GAME" ) then
				v.modelEnt = ClientsideModel( v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE )
				if IsValid( v.modelEnt ) then
					v.modelEnt:SetPos( self:GetPos() )
					v.modelEnt:SetAngles( self:GetAngles() )
					v.modelEnt:SetParent( self )
					v.modelEnt:SetNoDraw( true )
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			elseif v.type == "Sprite" and v.sprite and v.sprite ~= "" and ( not v.spriteMaterial or v.createdSprite ~= v.sprite ) and file.Exists( "materials/" .. v.sprite .. ".vmt", "GAME" ) then
				local name = v.sprite .. "-"
				local params = {
					["$basetexture"] = v.sprite
				}

				-- make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for _, j in ipairs( tocheck ) do
					if v[j] then
						params["$" .. j] = 1
						name = name .. "1"
					else
						name = name .. "0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial( name, "UnlitGeneric", params )
			end
		end
	end

	local allbones
	local hasGarryFixedBoneScalingYet = false
	function SWEP:UpdateBonePositions( vm )
		if self.ViewModelBoneMods then
			if not vm:GetBoneCount() then return end
			-- !! WORKAROUND !! --
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if not hasGarryFixedBoneScalingYet then
				allbones = {}
				for i = 0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName( i )
					if self.ViewModelBoneMods[bonename] then
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = {
							scale = Vector( 1, 1, 1 ),
							pos = Vector( 0, 0, 0 ),
							angle = Angle( 0, 0, 0 )
						}
					end
				end

				loopthrough = allbones
			end

			-- !! ----------- !! --
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone( k )
				if not bone then continue end
				-- !! WORKAROUND !! --
				local s = Vector( v.scale.x, v.scale.y, v.scale.z )
				local p = Vector( v.pos.x, v.pos.y, v.pos.z )
				local ms = Vector( 1, 1, 1 )
				if not hasGarryFixedBoneScalingYet then
					local cur = vm:GetBoneParent( bone )
					while cur >= 0 do
						local pscale = loopthrough[vm:GetBoneName( cur )].scale
						ms = ms * pscale
						cur = vm:GetBoneParent( cur )
					end
				end

				s = s * ms
				-- !! ----------- !! --
				if vm:GetManipulateBoneScale( bone ) ~= s then vm:ManipulateBoneScale( bone, s ) end
				if vm:GetManipulateBoneAngles( bone ) ~= v.angle then vm:ManipulateBoneAngles( bone, v.angle ) end
				if vm:GetManipulateBonePosition( bone ) ~= p then vm:ManipulateBonePosition( bone, p ) end
			end
		else
			self:ResetBonePositions( vm )
		end
	end

	function SWEP:ResetBonePositions( vm )
		if not vm:GetBoneCount() then return end
		for i = 0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector( 1, 1, 1 ) )
			vm:ManipulateBoneAngles( i, Angle( 0, 0, 0 ) )
			vm:ManipulateBonePosition( i, Vector( 0, 0, 0 ) )
		end
	end

	function table.FullCopy( tab )
		if not tab then return nil end
		local res = {}
		for k, v in pairs( tab ) do
			if type( v ) == "table" then
				res[k] = table.FullCopy( v )
			elseif type( v ) == "Vector" then
				res[k] = Vector( v.x, v.y, v.z )
			elseif type( v ) == "Angle" then
				res[k] = Angle( v.p, v.y, v.r )
			else
				res[k] = v
			end
		end
		return res
	end
end

----------------------------------------------------
function SWEP:Deploy()
	self:SetWeaponHoldType( self.HoldType )
	self:SendWeaponAnim( ACT_VM_DRAW )
	self:SetNextPrimaryFire( CurTime() + 0.5 )
	self:SetNextSecondaryFire( CurTime() + 0.5 )
	self.Idle = 0
	self.IdleTimer = CurTime() + self:GetOwner():GetViewModel():SequenceDuration()
	return true
end

function SWEP:Holster()
	self.Idle = 0
	self.IdleTimer = CurTime()
	return true
end

function SWEP:PrimaryAttack()
	self:GetOwner():LagCompensation( true )
	local tr = util.TraceLine( {
		start = self:GetOwner():GetShootPos(),
		endpos = self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * 82,
		filter = self:GetOwner(),
		mask = MASK_SHOT_HULL,
	} )

	if not IsValid( tr.Entity ) then
		tr = util.TraceHull( {
			start = self:GetOwner():GetShootPos(),
			endpos = self:GetOwner():GetShootPos() + self:GetOwner():GetAimVector() * 82,
			filter = self:GetOwner(),
			mins = Vector( -16, -16, 0 ),
			maxs = Vector( 16, 16, 0 ),
			mask = MASK_SHOT_HULL,
		} )
	end

	if SERVER and IsValid( tr.Entity ) then
		local dmginfo = DamageInfo()
		dmginfo:SetAttacker( self:GetOwner() )
		dmginfo:SetInflictor( self )
		if tr.Entity:GetClass():find( "zombi" ) then
			dmginfo:SetDamageType( 5 )
		else
			dmginfo:SetDamageType( DMG_SLASH )
		end

		dmginfo:SetDamage( self.Primary.Damage )
		if IsValid( tr.Entity:GetPhysicsObject() ) then
			dmginfo:SetDamageForce( self:GetOwner():GetAimVector() * 20 )
		else
			dmginfo:SetDamageForce( self:GetOwner():GetAimVector() * 5000 )
		end

		SuppressHostEvents( NULL )
		tr.Entity:TakeDamageInfo( dmginfo )
		SuppressHostEvents( self:GetOwner() )
	end

	if tr.Hit then
		if tr.Entity:IsPlayer() or tr.Entity:IsNPC() or tr.Entity.Type == "nextbot" or tr.Entity:GetClass() == "prop_ragdoll" then
			if SERVER then
				self:GetOwner():EmitSound( "weapons/blade_slice_" .. math.random( 2, 4 ) .. ".wav" )
				--self:GetOwner():EmitSound( "phx/epicmetal_hard" .. math.random(1, 7) .. ".wav",70,100,0.2)
			end

			local BLOOOD = EffectData()
			BLOOOD:SetOrigin( tr.HitPos )
			BLOOOD:SetMagnitude( math.random( 1, 3 ) )
			BLOOOD:SetEntity( tr.Entity )
			util.Effect( "bloodstream", BLOOOD )
		else
			if SERVER then self:GetOwner():EmitSound( "weapons/demo_sword_hit_world" .. math.random( 1, 2 ) .. ".wav" ) end
			local effectdata = EffectData()
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
			effectdata:SetMagnitude( 1 )
			effectdata:SetScale( 2 )
			effectdata:SetRadius( 1 )
			util.Effect( "Sparks", effectdata )
			util.Decal( "manhackcut", tr.HitPos + tr.HitNormal * 1, tr.HitPos + tr.HitNormal * -1, self:GetOwner() )
		end

		self:GetOwner():ViewPunch( Angle( -2, -1, 0 ) )
		self:SendWeaponAnim( ACT_VM_HITCENTER )
		self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
		self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
	else
		self:GetOwner():ViewPunch( Angle( 2, 1, 0 ) )
		self:EmitSound( "weapons/demo_sword_swing" .. math.random( 1, 2 ) .. ".wav" )
		self:SendWeaponAnim( ACT_VM_MISSCENTER )
		self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
		self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
	end

	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )
	self.Idle = 0
	self.IdleTimer = CurTime() + self:GetOwner():GetViewModel():SequenceDuration()
	self:GetOwner():LagCompensation( false )
end

function SWEP:SecondaryAttack()
end

function SWEP:Think()
	if self.Idle == 0 and self.IdleTimer <= CurTime() then
		if SERVER then self:SendWeaponAnim( ACT_VM_IDLE ) end
		self.Idle = 1
	end
end

if CLIENT then
	local WorldModel = ClientsideModel( SWEP.WorldModel )
	--WorldModel:SetSkin(1)
	WorldModel:SetNoDraw( true )
	function SWEP:DrawWorldModel()
		--self:Drawspiral()
		--self.Weapon:DrawModel()
		local _Owner = self:GetOwner()
		local ownervalid = IsValid( _Owner )
		if ownervalid then
			-- Specify a good position
			local offsetVec = Vector( 2.2, -0.8, -1 )
			local offsetAng = Angle( 180, -90, 0 )
			local boneid = _Owner:LookupBone( "ValveBiped.Bip01_R_Hand" ) -- Right Hand
			if not boneid then return end
			local matrix = _Owner:GetBoneMatrix( boneid )
			if not matrix then return end
			local newPos, newAng = LocalToWorld( offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles() )
			WorldModel:SetPos( newPos )
			WorldModel:SetAngles( newAng )
			WorldModel:SetupBones()
		else
			WorldModel:SetPos( self:GetPos() )
			WorldModel:SetAngles( self:GetAngles() )
		end

		WorldModel:DrawModel()
	end
end
--PATH addons/__main/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onions"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Vapes"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.VapeID = 1

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:PrimaryAttack()
	if SERVER then
		VapeUpdate(self.Owner, self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SecondaryAttack()
	if GetConVar("vape_block_sounds"):GetBool() then return end
	
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapegogreen.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (0.6*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Reload()
	if GetConVar("vape_block_sounds"):GetBool() then return end

	if self.reloading then return end
	self.reloading=true
	timer.Simple(0.5, function() self.reloading=false end)
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapenaysh.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (2.2*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Holster()
	if SERVER and IsValid(self.Owner) then
		ReleaseVape(self.Owner)
	end
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--PATH addons/__main/lua/weapons/weapon_vape_butterfly.lua:
-- weapon_vape_buttefly.lua
-- Defines a vape that flips like a butterfly knife

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end

SWEP.PrintName = "Butterfly Vape"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nA stealthy vape for masters of vape-jitsu."

SWEP.VapeAccentColor = Vector(0.2,0.2,0.3)
SWEP.VapeTankColor = Vector(0.1,0.1,0.1)

SWEP.VapeVMAng2 = Vector(360+170,720-108,132)
--PATH addons/__main/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onions"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Vapes"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.VapeID = 1

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:PrimaryAttack()
	if SERVER then
		VapeUpdate(self.Owner, self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SecondaryAttack()
	if GetConVar("vape_block_sounds"):GetBool() then return end
	
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapegogreen.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (0.6*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Reload()
	if GetConVar("vape_block_sounds"):GetBool() then return end

	if self.reloading then return end
	self.reloading=true
	timer.Simple(0.5, function() self.reloading=false end)
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapenaysh.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (2.2*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Holster()
	if SERVER and IsValid(self.Owner) then
		ReleaseVape(self.Owner)
	end
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--PATH addons/__main/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--PATH addons/__main/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onions"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Vapes"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.VapeID = 1

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:PrimaryAttack()
	if SERVER then
		VapeUpdate(self.Owner, self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SecondaryAttack()
	if GetConVar("vape_block_sounds"):GetBool() then return end
	
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapegogreen.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (0.6*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Reload()
	if GetConVar("vape_block_sounds"):GetBool() then return end

	if self.reloading then return end
	self.reloading=true
	timer.Simple(0.5, function() self.reloading=false end)
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapenaysh.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (2.2*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Holster()
	if SERVER and IsValid(self.Owner) then
		ReleaseVape(self.Owner)
	end
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--PATH addons/__main/lua/weapons/weapon_vape_dragon.lua:
-- weapon_vape_dragon.lua
-- Defines a vape which emits fire

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end

SWEP.PrintName = "Dragon's Breath Vape"

SWEP.Instructions = "LMB: Rip Flaming Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nThis juice is highly flammable! But don't worry, it's totally healthy."

SWEP.AdminOnly = true

SWEP.VapeScale = 1.7

SWEP.VapeVMPos1 = Vector(17,-3.2,-2.2)

SWEP.VapeVMPos2 = Vector(21,-7,-10)

SWEP.VapeID = 6

SWEP.SoundPitchMod = -40

SWEP.VapeAccentColor = Vector(1,0.3,0.1)
SWEP.VapeTankColor = Vector(1,0.6,0)
--PATH addons/__main/lua/weapons/weapon_vape_juicy.lua:
-- weapon_vape_juicy.lua
-- Defines a vape with selectable cloud colors

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end

SWEP.PrintName = "Juicy Vape"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB: Change Juice Flavor\nReload: Play Sound\n\nThis vape contains a flavor for everyone!"

SWEP.VapeAccentColor = nil

SWEP.VapeID = 20

--Add your own flavors here, obviously
JuicyVapeJuices = {
	{name = "Mountain Dew", color = Color(150,255,100,255)},
	{name = "Cheetos", color = Color(255,180,100,255)},
	{name = "Razzleberry", color = Color(250,100,200,255)},
	{name = "Banana", color = Color(255,255,100,255)},
	{name = "Black Licorice", color = Color(40,40,40,255)},
	{name = "Churro", color = Color(210,180,140,255)},
	{name = "Skittles", color = nil}, --nil means rainbow
}

if SERVER then
	function SWEP:Initialize()
		self.juiceID = 0
		timer.Simple(0.1, function() SendVapeJuice(self, JuicyVapeJuices[self.juiceID+1]) end)
	end

	util.AddNetworkString("VapeTankColor")
	util.AddNetworkString("VapeMessage")
end

function SWEP:SecondaryAttack()
	if SERVER then
		if not self.juiceID then self.juiceID = 0 end
		self.juiceID = (self.juiceID + 1) % (#JuicyVapeJuices)
		SendVapeJuice(self, JuicyVapeJuices[self.juiceID+1])

		--Client hook isn't called in singleplayer...
		if game.SinglePlayer() then	self.Owner:SendLua([[surface.PlaySound("weapons/smg1/switch_single.wav")]]) end
	else
		if IsFirstTimePredicted() then
			surface.PlaySound("weapons/smg1/switch_single.wav")
		end
	end
end

if SERVER then
	function SendVapeJuice(ent, tab)
		local col = tab.color
		if col then
			local min = math.min(col.r,col.g,col.b)*0.8
			col = (Vector(col.r-min, col.g-min, col.b-min)*1.0)/255.0
		else
			--means rainbow tank
			col = Vector(-1,-1,-1)
		end
		net.Start("VapeTankColor")
		net.WriteEntity(ent)
		net.WriteVector(col)
		net.Broadcast()

		if IsValid(ent.Owner) then
			net.Start("VapeMessage")
			net.WriteString("Loaded "..tab.name.." flavor juice")
			net.Send(ent.Owner)
		end
	end
else
	net.Receive("VapeTankColor", function()
		local ent = net.ReadEntity()
		local col = net.ReadVector()
		if IsValid(ent) then ent.VapeTankColor = col end
	end)

	VapeMessageDisplay = ""
	VapeMessageDisplayTime = 0

	net.Receive("VapeMessage", function()
		VapeMessageDisplay = net.ReadString()
		VapeMessageDisplayTime = CurTime()
	end)

	hook.Add("HUDPaint", "VapeDrawJuiceMessage", function()
		local alpha = math.Clamp((VapeMessageDisplayTime+3-CurTime())*1.5,0,1)
		if alpha == 0 then return end

		surface.SetFont("Trebuchet24")
		local w,h = surface.GetTextSize(VapeMessageDisplay)
		draw.WordBox(8, ((ScrW() - w)*0.5)-8, ScrH() - (h + 24), VapeMessageDisplay, "Trebuchet24", Color(0,0,0,128*alpha), Color(255,255,255,255*alpha))
	end)
end
--PATH addons/__main/lua/weapons/weapon_vape_mega.lua:
-- weapon_vape_mega.lua
-- Defines a big vape that makes massive clouds (admin only recommended)

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end

SWEP.PrintName = "Mega Vape"

SWEP.Instructions = "LMB: Rip MASSIVE Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nOriginally developed for military use, this powerful vape quickly creates a large vape-screen ideal for concealment."

SWEP.AdminOnly = true

SWEP.VapeID = 2

SWEP.SoundPitchMod = -30

SWEP.VapeScale = 2.5

SWEP.VapeVMPos1 = Vector(15,-3,-1.5)

SWEP.VapeVMPos2 = Vector(18,-6,-9)

--HOT ROD VAPE
SWEP.VapeAccentColor = Vector(1,0,0.3)
SWEP.VapeTankColor = Vector(0.1,0.1,0.1)

function SWEP:PrimaryAttack()
	if SERVER then
		VapeUpdate(self.Owner, self.VapeID)
	end
	--Takes slightly longer to breathe
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.15)
end
--PATH addons/_farmer/lua/entities/ba_product/cl_init.lua:
include("shared.lua");

surface.CreateFont("BA_Food_Text", {
	font = "Tahoma",
	size = 38,
	weight = 700,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	
end;


function ENT:Think()
end;

function ENT:Draw()
	self:DrawModel();
	
	local camPos = self:GetPos();
	local camAng = self:GetAngles();
	
	camAng:RotateAroundAxis(camAng:Up(), 0);
	camAng:RotateAroundAxis(camAng:Forward(), 0);	
	camAng:RotateAroundAxis(camAng:Right(), 0);
	
	local name = self:GetNWString("name");
	local length = (string.len(self:GetNWString("name"))*21);

	local color = string.Explode(",", self:GetNWString("color"));

	local priceText = tostring(self:GetNWInt("price").."$");
	local priceLength = (string.len(priceText)*21);
	
	
	if (LocalPlayer():GetPos():Distance(self:GetPos()) < B_Animals_Config.DrawDistance) then
		cam.Start3D2D(camPos + Vector(0, 0, self:OBBMaxs().z*1.4), Angle(0, LocalPlayer():EyeAngles().y-90, 90), 0.075)
			draw.RoundedBox(0, -(length*0.5), -8, length, 36, Color(0, 0, 0, 200));
			draw.SimpleText(self:GetNWString("name"), "BA_Food_Text", 0, 8, Color(tonumber(color[1]) or 0, tonumber(color[2]) or 0, tonumber(color[3]) or 0, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
			
			draw.RoundedBox(0, -(priceLength*0.675)+(math.sin(-CurTime()*8)*8), -62-(math.cos(CurTime()*8)*8), priceLength*1.4, 36, Color(72, 156, 92, 200));
			draw.SimpleText(priceText, "BA_Food_Text", 0+(math.sin(-CurTime()*8)*8), -46-(math.cos(CurTime()*8)*8), Color(190, 190, 190, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
		cam.End3D2D();
	end;
end;

--PATH gamemodes/darkrp/entities/entities/base_gmodentity.lua:

AddCSLuaFile()
DEFINE_BASECLASS( "base_anim" )

ENT.Spawnable = false

if ( CLIENT ) then
	ENT.MaxWorldTipDistance = 256

	function ENT:BeingLookedAtByLocalPlayer()
		local ply = LocalPlayer()
		if ( !IsValid( ply ) ) then return false end

		local view = ply:GetViewEntity()
		local dist = self.MaxWorldTipDistance
		dist = dist * dist

		-- If we're spectating a player, perform an eye trace
		if ( view:IsPlayer() ) then
			return view:EyePos():DistToSqr( self:GetPos() ) <= dist && view:GetEyeTrace().Entity == self
		end

		-- If we're not spectating a player, perform a manual trace from the entity's position
		local pos = view:GetPos()

		if ( pos:DistToSqr( self:GetPos() ) <= dist ) then
			return util.TraceLine( {
				start = pos,
				endpos = pos + ( view:GetAngles():Forward() * dist ),
				filter = view
			} ).Entity == self
		end

		return false
	end

	function ENT:Think()
		local text = self:GetOverlayText()

		if ( text != "" && self:BeingLookedAtByLocalPlayer() && !self:GetNoDraw() ) then
			AddWorldTip( self:EntIndex(), text, 0.5, self:GetPos(), self )

			halo.Add( { self }, color_white, 1, 1, 1, true, true )
		end
	end
end

function ENT:SetOverlayText( text )
	self:SetNWString( "GModOverlayText", text )
end

function ENT:GetOverlayText()

	local txt = self:GetNWString( "GModOverlayText" )

	if ( txt == "" ) then
		return ""
	end

	if ( game.SinglePlayer() ) then
		return txt
	end

	local PlayerName = self:GetPlayerName()

	return txt .. "\n(" .. PlayerName .. ")"

end

function ENT:SetPlayer( ply )

	self.Founder = ply

	if ( IsValid( ply ) ) then

		self:SetNWString( "FounderName", ply:Nick() )
		self.FounderSID = ply:SteamID64()
		self.FounderIndex = ply:UniqueID()

	else

		self:SetNWString( "FounderName", "" )
		self.FounderSID = nil
		self.FounderIndex = nil

	end

end

function ENT:GetPlayer()

	if ( self.Founder == nil ) then

		-- SetPlayer has not been called
		return NULL

	elseif ( IsValid( self.Founder ) ) then

		-- Normal operations
		return self.Founder

	end

	-- See if the player has left the server then rejoined
	local ply = player.GetBySteamID64( self.FounderSID )
	if ( not IsValid( ply ) ) then

		-- Oh well
		return NULL

	end

	-- Save us the check next time
	self:SetPlayer( ply )
	return ply

end

function ENT:GetPlayerIndex()

	return self.FounderIndex or 0

end

function ENT:GetPlayerSteamID()

	return self.FounderSID or ""

end

function ENT:GetPlayerName()

	local ply = self:GetPlayer()
	if ( IsValid( ply ) ) then
		return ply:Nick()
	end

	return self:GetNWString( "FounderName" )

end

--PATH addons/battlepass/lua/entities/battlepass_npc/cl_init.lua:
include("shared.lua")
function ENT:Draw()
  self:DrawModel()
	onyx.npc.label( self, BATTLEPASS.Config.NPC.Title )
end
--PATH addons/_bitminers2ex/lua/entities/bm2_base/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "BM2 base"
ENT.Spawnable = false
ENT.Category = "Bitminers"
--PATH addons/_bitminers2/lua/entities/bm2_extention_lead/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Extention Lead"
ENT.Spawnable = true
ENT.Category = "Bitminers"
function ENT:SetupDataTables()
end
--PATH addons/_bitminers2/lua/entities/bm2_plug_1/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Extention Lead"
ENT.Spawnable = false
ENT.Category = "Bitminers"
function ENT:SetupDataTables()
end
--PATH addons/_doctor/lua/entities/bp_chemical_17alph/cl_init.lua:
include("shared.lua")

local levelIcon = Material("blues_pharm/ui/level.png", "smooth")
local titleIcon = Material("blues_pharm/ui/title.png", "smooth")

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > BLUES_PHARMA.CONFIG.Cam3D2DRenderDist  then return end

	local ang = self:GetAngles()
	local pos = self:GetPos() + (ang:Up() * 15)

	local ang1 = self:WorldToLocalAngles((LocalPlayer():EyePos() - pos):Angle())
	local ang2 = self:LocalToWorldAngles(Angle(0, ang1.y + 90, 90))

	cam.Start3D2D(pos, ang2, 0.05)
		surface.SetMaterial(titleIcon)
		surface.SetDrawColor(Color(255, 255, 255, 255))
		surface.DrawTexturedRect(-160, -270, 280, 65)

		draw.RoundedBox(0, -160, -270, 20, 570, Color(43, 43, 43))

		draw.SimpleText(BLUES_PHARMA.Chemicals[self.ChemicalID].name, "BP_Chemical_Title",  -135, -270, Color(255, 255, 255), 0, 0)

		surface.SetMaterial(levelIcon)
		surface.SetDrawColor(Color(255, 255, 255, 60))
		surface.DrawTexturedRect(-135, -240, 32, 32)

		draw.SimpleText(self:GetLiquidAmount().."ml", "BP_Chemical_Amount",  - 100, -240, Color(255, 255, 255, 60), 0, 0)
	cam.End3D2D()
end
--PATH addons/_doctor/lua/entities/bp_chemical_acet/shared.lua:
ENT.Type = "anim"
ENT.Base = "bp_base"

ENT.PrintName = "Acetic Anhydride"
ENT.Spawnable = true
ENT.Category = "Blue's Pharmaceuticals"

ENT.RenderGroup = RENDERGROUP_BOTH

ENT.ChemicalID = 4


function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "LiquidAmount")
end
--PATH addons/_doctor/lua/entities/bp_chemical_acet2/shared.lua:
ENT.Type = "anim"
ENT.Base = "bp_base"

ENT.PrintName = "Acetone"
ENT.Spawnable = true
ENT.Category = "Blue's Pharmaceuticals"

ENT.RenderGroup = RENDERGROUP_BOTH

ENT.ChemicalID = 8

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "LiquidAmount")
end
--PATH addons/_doctor/lua/entities/bp_chemical_prop_acid/cl_init.lua:
include("shared.lua")

local levelIcon = Material("blues_pharm/ui/level.png", "smooth")
local titleIcon = Material("blues_pharm/ui/title.png", "smooth")

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > BLUES_PHARMA.CONFIG.Cam3D2DRenderDist  then return end

	local ang = self:GetAngles()
	local pos = self:GetPos() + (ang:Up() * 10.5)

	local ang1 = self:WorldToLocalAngles((LocalPlayer():EyePos() - pos):Angle())
	local ang2 = self:LocalToWorldAngles(Angle(0, ang1.y + 90, 90))

	cam.Start3D2D(pos, ang2, 0.05)
		surface.SetMaterial(titleIcon)
		surface.SetDrawColor(Color(255, 255, 255, 255))
		surface.DrawTexturedRect(-140, -270, 280, 65)

		draw.RoundedBox(0, -140, -270, 20, 470, Color(43, 43, 43))

		draw.SimpleText(BLUES_PHARMA.Chemicals[self.ChemicalID].name, "BP_Chemical_Title",  -115, -270, Color(255, 255, 255), 0, 0)

		surface.SetMaterial(levelIcon)
		surface.SetDrawColor(Color(255, 255, 255, 60))
		surface.DrawTexturedRect(-115, -240, 32, 32)

		draw.SimpleText(self:GetLiquidAmount().."ml", "BP_Chemical_Amount",  -80, -240, Color(255, 255, 255, 60), 0, 0)
	cam.End3D2D()
end
--PATH addons/____bricks_gangs/lua/entities/bricks_server_gangprinter/shared.lua:

ENT.Type = "anim"
ENT.Base = "base_gmodentity"
 
ENT.PrintName		= "Gang Printer"
ENT.Category		= "Brick's Gangs"
ENT.Author			= "Brickwall"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable		= false
ENT.IncomeTrackAmount = 10

function ENT:SetupDataTables()
	self:NetworkVar( "Int", 0, "Holding" )

	if( SERVER ) then
		self:NetworkVarNotify( "Holding", function( entity, name, old, new )
			if( #entity.IncomeTrackTable >= entity.IncomeTrackAmount ) then
				table.remove( entity.IncomeTrackTable, 1 )
			end

			table.insert( entity.IncomeTrackTable, new )
		end )
	end

	self:NetworkVar( "Int", 1, "HoldingEXP" )
	self:NetworkVar( "Int", 2, "Temperature" )
	self:NetworkVar( "Int", 3, "NextPrint" )

	self:NetworkVar( "Int", 4, "GangID" )
	self:NetworkVar( "Int", 5, "PrinterID" )
	self:NetworkVar( "Int", 6, "Servers" )

	self:NetworkVar( "Bool", 0, "Status" )
	self:NetworkVar( "Bool", 1, "Overheated" )
end

function ENT:GetPrintAmount()
	local printerConfigTable = BRICKS_SERVER.CONFIG.GANGPRINTERS.Printers[self:GetPrinterID()]

	if( not printerConfigTable ) then return 100 end

	local printAmount = 0
	for i = 1, self:GetServers() do
		local amountUpgradeTier = ((BRICKS_SERVER.CONFIG.GANGPRINTERS.ServerUpgrades["Amount"] or {}).Tiers or {})[self:GetNW2Int( "AmountServer" .. i, 0 )] or {}
		local multiplier = 1+((amountUpgradeTier.ReqInfo or {})[1] or 0)/100

		printAmount = printAmount+((printerConfigTable.ServerAmount or 0)*multiplier)
	end

	return printAmount
end

function ENT:GetTargetTemp()
	local printerConfigTable = BRICKS_SERVER.CONFIG.GANGPRINTERS.Printers[self:GetPrinterID()]

	if( not printerConfigTable ) then return 0 end

	local targetTemp = 0
	for i = 1, self:GetServers() do
		local amountUpgradeTier = ((BRICKS_SERVER.CONFIG.GANGPRINTERS.ServerUpgrades["Cooling"] or {}).Tiers or {})[self:GetNW2Int( "CoolingServer" .. i, 0 )] or {}
		local multiplier = 1-((amountUpgradeTier.ReqInfo or {})[1] or 0)/100

		targetTemp = targetTemp+((printerConfigTable.ServerHeat or 0)*multiplier)
	end

	return targetTemp
end

function ENT:GetPrintTime()
	local printerConfigTable = BRICKS_SERVER.CONFIG.GANGPRINTERS.Printers[self:GetPrinterID()]

	if( not printerConfigTable ) then return 1 end

	local printTime = 0
	for i = 1, self:GetServers() do
		local amountUpgradeTier = ((BRICKS_SERVER.CONFIG.GANGPRINTERS.ServerUpgrades["Speed"] or {}).Tiers or {})[self:GetNW2Int( "SpeedServer" .. i, 0 )] or {}
		local multiplier = math.Clamp( (1-((i-1)*BRICKS_SERVER.DEVCONFIG.GangPrinterServerTime))-((amountUpgradeTier.ReqInfo or {})[1] or 0)/100, 0, 1 )

		printTime = printTime+((printerConfigTable.ServerTime or 0)*multiplier)
	end

	return printTime
end

function ENT:GetTotalHealth()
	local health = BRICKS_SERVER.CONFIG.GANGPRINTERS["Base Printer Health"]

	local healthTier = BRICKS_SERVER.CONFIG.GANGPRINTERS.Upgrades["Health"].Tiers[self:GetNW2Int( "HealthUpgrade", 0 )]
	if( healthTier ) then
		health = health*(1+(healthTier.ReqInfo[1]/100))
	end

	return health
end
--PATH addons/_drones/lua/entities/dronesrewrite_coredr/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
//ENT.PrintName = "CR 'Core'"
ENT.PrintName = "Core"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.RenderInCam = false
ENT.UNIT = "CR"

ENT.Model = "models/maxofs2d/hover_rings.mdl"

ENT.Weight = 80

ENT.Speed = 600
ENT.UpSpeed = 3000
ENT.SprintCoefficient = 3
ENT.RotateSpeed = 4
ENT.AngOffset = 0
ENT.NoiseCoefficient = 0
ENT.Alignment = 3
ENT.PitchOffset = 0

ENT.DoExplosionEffect = "splode_drone_sparks"

ENT.FirstPersonCam_pos = Vector(12, 0, 0)
ENT.ThirdPersonCam_distance = 50
ENT.RenderCam = false

ENT.HUD_shouldDrawWeps = false
ENT.HUD_hudName = "No HUD"

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.AllowPitchRestrictions = false

ENT.HealthAmount = 50
ENT.DefaultHealth = 50

ENT.Sounds = { }

ENT.UseFlashlight = false
ENT.UseNightVision = false

ENT.NoPropellers = true
ENT.Propellers = {
	Model = "models/props_junk/PopCan01a.mdl",
	Info = { Vector(0, 0, 0) }
}

ENT.Weapons = { ["Invisible"] = { Name = "Invisible" } }

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/_drones/lua/entities/dronesrewrite_flower/cl_init.lua:
include("shared.lua")
--PATH addons/_drones/lua/entities/dronesrewrite_grenader/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self.BaseClass.Draw(self)

	if self:IsDroneWorkable() then
		local dlight = DynamicLight(self:EntIndex())
		if dlight then
			dlight.pos = self:LocalToWorld(self.FirstPersonCam_pos)
			dlight.r = 255
			dlight.g = 255
			dlight.b = 255
			dlight.brightness = 2
			dlight.Decay = 1000
			dlight.Size = 120
			dlight.DieTime = CurTime() + 0.1
		end

		render.SetMaterial(Material("particle/particle_glow_04_additive"))
		render.DrawSprite(self:LocalToWorld(self.FirstPersonCam_pos), 30, 30, Color(255, 255, 255, 30))
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_jiedr/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "JIE Drone"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "JIE"

ENT.HUD_hudName = "Drones 1"

ENT.Model = "models/dronesrewrite/jiedr/jiedr.mdl"

ENT.Weight = 700
ENT.SpawnHeight = 64

ENT.Speed = 4500
ENT.UpSpeed = 25000
ENT.AngOffset = 3
ENT.RotateSpeed = 3
ENT.Alignment = 1
ENT.PitchOffset = 0.4

ENT.HackValue = 4

ENT.Fuel = 500
ENT.MaxFuel = 500
ENT.FuelReduction = 0.9

ENT.NoiseCoefficient = 0
ENT.NoiseCoefficientAng = 0.1
ENT.NoiseCoefficientPos = 2

ENT.DoExplosionEffect = "splode_big_drone_main"

ENT.ThirdPersonCam_distance = 200
ENT.FirstPersonCam_pos = Vector(49, 0, 20)
ENT.RenderCam = false

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.AllowYawRestrictions = true
ENT.YawMin = -60
ENT.YawMax = 60

ENT.PitchMin = -30
ENT.PitchMax = 50

ENT.HealthAmount = 500
ENT.DefaultHealth = 500

ENT.Sounds = {
	PropellerSound = {
		Name = "npc/manhack/mh_engine_loop1.wav",
		Pitch = 60,
		Level = 82
	},

	ExplosionSound = {
		Name = "ambient/explosions/explode_1.wav",
		Level = 80
	}
}


ENT.Propellers = {
	Damage = 2,
	Health = 60,
	HitRange = 14,
	Model = "models/dronesrewrite/propellers/propeller1_5.mdl",

	Info = {
		Vector(-5.2, 70.6, 26),
		Vector(-5.2, -70.6, 26)
	}
}

ENT.Attachments = {
	["Left"] = {
		Pos = Vector(-5, 32, -10)
	},

	["LeftUp"] = {
		Pos = Vector(-5, 32, -5),
		Angle = Angle(0, 0, 180)
	},

	["Right"] = {
		Pos = Vector(-5, -32, -10)
	},

	["RightUp"] = {
		Pos = Vector(-5, -32, -5),
		Angle = Angle(0, 0, 180)
	},
}

ENT.Weapons = {
	["Rocket Launcher & Gun"] = {
		Name = "Rocket Launcher",
		Sync = { 
			["1"] = { fire1 = "fire2" } 
		},

		Attachment = "Left"
	},

	["1"] = {
		Name = "Double Gun",
		Select = false,
		PrimaryAsSecondary = true,
		Attachment = "Right"
	}
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/_drones/lua/entities/dronesrewrite_microwave/cl_init.lua:
include("shared.lua")
--PATH addons/_drones/lua/entities/dronesrewrite_mothership/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "Mothership"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"
ENT.AdminOnly = true

ENT.HackValue = 5
ENT.ImmuneToJammer = true

ENT.UNIT = "MSP"

ENT.Model = "models/dronesrewrite/mothership/mothership.mdl"
ENT.BlockRemoteController = true

ENT.Weight = 50000
ENT.SpawnHeight = 256
ENT.DisableInWater = false

ENT.HUD_hudName = "White Box"

ENT.UseNightVision = true
ENT.UseFlashlight = false

ENT.HackValue = 5

ENT.NoiseCoefficient = 0

ENT.HealthAmount = 25000
ENT.DefaultHealth = 25000

ENT.DoExplosionEffect = false

ENT.Speed = 600000
ENT.UpSpeed = 1200000
ENT.RotateSpeed = 1.2
ENT.AngOffset = 0
ENT.PitchOffset = 0
ENT.Alignment = 0.5

ENT.Fuel = 25000
ENT.MaxFuel = 25000
ENT.FuelReduction = 50

ENT.FirstPersonCam_pos = Vector(-550, 500, 710)
ENT.ThirdPersonCam_pos = Vector(300, 2200, 1310)
ENT.ThirdPersonCam_distance = 1800
ENT.CameraModel = "models/props_wasteland/light_spotlight01_lamp.mdl"

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.AllowPitchRestrictions = false

ENT.Sounds = {
	PropellerSound = {
		Name = "npc/attack_helicopter/aheli_rotor_loop1.wav",
		Pitch = 80,
		Level = 100,
		NoPitchChanges = true
	},

	ExplosionSound = {
		Name = "ambient/explosions/explode_5.wav",
		Level = 120
	}
}

ENT.Propellers = {
	Immortal = true,
	Damage = 999999,
	Model = "models/dronesrewrite/ms_propeller/ms_propeller.mdl",
	HitRange = 300,

	UnFreeze = true,
	Force = true,
	ForceVal = 1000,

	Info = {
		Vector(-80, 740, 400),
		Vector(-80, -740, 400),

		Vector(650, 740, 400),
		Vector(650, -740, 400),

		Vector(-820, 740, 400),
		Vector(-820, -740, 400),
	}
}

ENT.Attachments = {
	["BottomLauncher1"] = {
		Pos = Vector(900, -74, 380),
		Angle = Angle(-15, 0, 180),
	},

	["BottomLauncher2"] = {
		Pos = Vector(900, 74, 380),
		Angle = Angle(-15, 0, 180),
	},

	["BottomLauncher3Center"] = {
		Pos = Vector(900, 0, 380),
		Angle = Angle(-15, 0, 180),
	},



	["SideLauncher1"] = {
		Pos = Vector(230, 500, 455)
	},

	["SideLauncher2"] = {
		Pos = Vector(230, 450, 455)
	},



	["RightBridge2"] = {
		Pos = Vector(-970, -410, 665)
	},

	["RightBridge3"] = {
		Pos = Vector(-630, -410, 665)
	},

	["RightBridge4"] = {
		Pos = Vector(-800, -410, 665)
	},

	["RightBridge1"] = {
		Pos = Vector(-490, -410, 665)
	},
}

ENT.Weapons = {
	-- Bottom launchers
	["Bottom launchers"] = {
		Name = "Missile Battery",
		Sync = {
			["launch2"] = { fire1 = "fire1" },
			["launchb2"] = { fire1 = "fire1" }
		},

		Attachment = "BottomLauncher1"
	},

	["launch2"] = {
		Name = "Missile Battery",
		Select = false,
		Attachment = "BottomLauncher2"
	},

	["launchb2"] = {
		Name = "Missile Battery",
		Select = false,
		Attachment = "BottomLauncher3Center"
	},


	-- Side launchers
	["Left top launchers"] = {
		Name = "Missile Battery",
		Sync = {
			["launch3"] = { fire1 = "fire1" }
		},
		Attachment = "SideLauncher1"
	},

	["launch3"] = {
		Name = "Missile Battery",
		Select = false,
		Attachment = "SideLauncher2"
	},


	-- Right back bridge launchers
	["Right top launchers"] = {
		Name = "Missile Battery",
		Sync = {
			["launch4"] = { fire1 = "fire1" },
			["launchb4"] = { fire1 = "fire1" },
			["launchc4"] = { fire1 = "fire1" }
		},

		Attachment = "RightBridge4"
	},

	["launchc4"] = {
		Name = "Missile Battery",
		Select = false,
		Attachment = "RightBridge1"
	},

	["launchb4"] = {
		Name = "Missile Battery",
		Select = false,
		Attachment = "RightBridge2"
	},

	["launch4"] = {
		Name = "Missile Battery",
		Select = false,
		Attachment = "RightBridge3"
	},


	["Orbital Strike"] = {
		Name = "Orbital Strike"
	},
}

ENT.Modules = { } -- we do not need modules on big drone
--PATH addons/_drones/lua/entities/dronesrewrite_plotdr/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.DrrBaseType = "walker"
ENT.Type = "anim"
ENT.PrintName = "PLOT-130"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"
ENT.AdminOnly = true

ENT.UNIT = "PLOT"

ENT.Model = "models/dronesrewrite/plotdr/plotdr.mdl"

ENT.Weight = 4000
ENT.SpawnHeight = 32

ENT.OverlayName = "Black and white"

ENT.FirstPersonCam_pos = Vector(80, 0, 195)
ENT.ThirdPersonCam_pos = Vector(0, 0, 300)
ENT.ThirdPersonCam_distance = 260
ENT.RenderCam = false

ENT.AI_AllowDown = false
ENT.AI_AllowUp = false

ENT.Speed = 100000
ENT.SprintCoefficient = 1
ENT.RotateSpeed = 5
ENT.PitchOffset = 0
ENT.Hover = 110
ENT.AngOffset = 1.6

ENT.HackValue = 4
ENT.ImmuneToJammer = true

ENT.Fuel = 700
ENT.MaxFuel = 700
ENT.FuelReduction = 6

ENT.ExplosionForce = 2
ENT.ExplosionAngForce = 0
ENT.DoExplosionEffect = "splode_big_drone_main"

ENT.AllowPitchRestrictions = true
ENT.PitchMin = -90
ENT.PitchMax = 35

ENT.AllowYawRestrictions = true
ENT.YawMin = -80
ENT.YawMax = 50

ENT.NoiseCoefficient = 2

ENT.WaitForSound = 0.54

ENT.Slip = 170
ENT.AngSlip = 0.03



ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()
ENT.KeysFuncs.Physics["Up"] = function(self)
	if self:IsDroneOnGround() then
		local up = self:GetUp()
		local phys = self:GetPhysicsObject()

		if not self.JumpPower then self.JumpPower = 0 end
		self.JumpPower = math.Approach(self.JumpPower, 1000, 10)

		phys:ApplyForceCenter(-up * phys:GetMass() * 18)
	end
end

ENT.KeysFuncs.UnPressed["Up"] = function(self)
	if self:IsDroneOnGround() then
		local forward = self:GetForward()
		local up = self:GetUp()
		local phys = self:GetPhysicsObject()

		local ang = self:GetAngles()
		local angp = math.NormalizeAngle(ang.p)
		local angr = math.NormalizeAngle(ang.r)

		phys:ApplyForceCenter((forward * 200 + up * self.JumpPower) * phys:GetMass())
		phys:AddAngleVelocity(Vector(angr, angp, 0) * self.JumpPower * 0.018)

		self.JumpPower = 0
	end
end

ENT.KeysFuncs.Physics["Down"] = function(self)
	local up = self:GetUp()
	local phys = self:GetPhysicsObject()

	phys:ApplyForceCenter(-up * phys:GetMass() * 30)
end

ENT.HealthAmount = 1500
ENT.DefaultHealth = 1500

ENT.Sounds = {
	ExplosionSound = {
		Name = "ambient/explosions/explode_1.wav",
		Level = 82
	},

	FootSound = {
		Sounds = {
			--"physics/metal/metal_barrel_impact_hard1.wav",
			"physics/metal/metal_barrel_impact_hard2.wav"
		},

		Pitch = 120,
		Volume = 72
	}
}

ENT.Corners = {
	Vector(-8, -69, 110),
	Vector(-8, 64, 110),
	Vector(68, 64, 110),
	Vector(68, -69, 110)
}

ENT.Attachments = {
	["Minigun1"] = {
		Pos = Vector(52, -76, 192),
		Angle = Angle(0, 0, -95)
	},

	["Minigun2"] = {
		Pos = Vector(52, -76, 170),
		Angle = Angle(0, 0, -90)
	},

	["MissileL"] = {
		Pos = Vector(0, 84, 180),
		Angle = Angle(0, 0, -90)
	},

	["BackwardUp"] = {
		Pos = Vector(0, 0, 219),
		Angle = Angle(0, 0, 180)
	},

	["HeadUp"] = {
		Pos = Vector(35, 0, 213),
		Angle = Angle(0, 0, 180)
	}
}

ENT.Weapons = {
	["3-barrel Miniguns & Missile Batteries"] = {
		Name = "3-barrel Minigun",
		Sync = { 
			["1"] = { fire1 = "fire1" },
			["2"] = { fire1 = "fire2" }
		},
		Attachment = "Minigun2"
	},

	["1"] = {
		Name = "3-barrel Minigun",
		Select = false,
		Attachment = "Minigun1"
	},

	["2"] = {
		Name = "Missile Battery",
		Select = false,
		PrimaryAsSecondary = true,
		Attachment = "MissileL"
	}
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/_drones/lua/entities/dronesrewrite_rail.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false
ENT.ToRemove = false

if SERVER then
	function ENT:Initialize()
	    self:SetModel("models/dronesrewrite/railbolt/rail.mdl")
	    self:SetMoveType(MOVETYPE_VPHYSICS)
	    self:SetSolid(SOLID_VPHYSICS)
	    self:PhysicsInit(SOLID_VPHYSICS)

	    local phys = self:GetPhysicsObject()

		phys:EnableDrag(false)
	    if IsValid(phys) then phys:Wake() end
	end

	function ENT:PhysicsCollide(data, physobj)
		local cos = data.OurOldVelocity:Dot(data.HitNormal) / data.OurOldVelocity:Length()
		local oldVelLength = data.OurOldVelocity:LengthSqr()

		local ent = data.HitEntity
		if ent:IsValid() then
			local velocityMult = oldVelLength / 25000000
			if cos <= 0.35 then velocityMult = velocityMult / 3 end

			local damage = 15 * velocityMult
			local owner = self.Owner
			ent:TakeDamage(damage, owner, owner)
		end
			
		if oldVelLength > 500000 then
			self:EmitSound("weapons/crossbow/hit1.wav", 80, 130)
			
			if cos > 0.35 then
				local tr = util.TraceLine({
					start = self:GetPos(),
					endpos = self:GetPos() + self:GetForward() * 100,
					filter = self,
					mask = MASK_SOLID_BRUSHONLY
				})
				util.Decal("impact.concrete", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)

				self:Remove()
			end
		end
	end

	function ENT:PhysicsUpdate(phys)
		if self.LastPhys == CurTime() then return end

		local velocityLen = self:GetPhysicsObject():GetVelocity():LengthSqr()
		if velocityLen < 2000000 then phys:EnableGravity(true) end
		if not self.ToRemove and velocityLen < 100 then
			self.ToRemove = true
			timer.Simple(3, function()
				if self:IsValid() then self:Remove() end
			end)
		end

		self.LastPhys = CurTime()
	end
else
	function ENT:Draw()
		self:DrawModel()
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_rd_laser_sm.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

if SERVER then
	function ENT:Initialize()
	    self:SetModel("models/dronesrewrite/lray_sm/lray_sm.mdl")
	    self:SetMoveType(MOVETYPE_VPHYSICS)
	    self:SetSolid(SOLID_VPHYSICS)
	    self:PhysicsInit(SOLID_VPHYSICS)

	    self:DrawShadow(false)
		self:SetColor(Color(255, 255, 255))

	    local phys = self:GetPhysicsObject()

	    phys:SetMass(1)
		phys:EnableDrag(false)
		phys:EnableGravity(false)	
	    phys:Wake()

	    self:SetCustomCollisionCheck(true)
	end

	function ENT:PhysicsUpdate(phys)
		if self.LastPhys == CurTime() then return end

		if self:WaterLevel() >= 3 then self:Remove() end

		phys:ApplyForceCenter(self:GetForward() * 100000)

		self.LastPhys = CurTime()
	end

	function ENT:PhysicsCollide(data, physobj)
		local ent = data.HitEntity
		if ent:IsValid() then
			local owner = self.Owner
			ent:TakeDamage(math.random(2,4), owner, owner)
			ent:Ignite(0.3,1)
		end

		local tr = util.TraceLine({
			start = self:GetPos(),
			endpos = self:GetPos() + self:GetForward() * 1024,
			filter = self,
			mask = MASK_SOLID_BRUSHONLY
		})

		ParticleEffect("sparks_rdbl", self:GetPos(), Angle(0, 0, 0))

		util.Decal("FadingScorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)

		self:Remove()
	end
else
	function ENT:Draw()
		local dlight = DynamicLight(self:EntIndex())
		if dlight then
			dlight.pos = self:GetPos()
			dlight.r = 255
			dlight.g = 0
			dlight.b = 0
			dlight.brightness = 1
			dlight.Decay = 1000
			dlight.Size = 150
			dlight.DieTime = CurTime() + 0.3
		end	

		render.SetMaterial(Material("particle/particle_glow_04_additive"))

		local color = Color(255, 0, 0, 255)
		local xs = 18
		
		render.DrawSprite(self:GetPos() - self:GetForward() * 12, xs, xs, color)
		render.DrawSprite(self:GetPos() - self:GetForward() * 6, xs, xs, color)
		render.DrawSprite(self:GetPos(), xs, xs, color)
		render.DrawSprite(self:GetPos() + self:GetForward() * 6, xs, xs, color)
		render.DrawSprite(self:GetPos() + self:GetForward() * 12, xs, xs, color)

		self:DrawModel()
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_rocketbig.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

local rSound = Sound("Missile.Accelerate")

if SERVER then
	function ENT:Initialize()
	    self:SetModel("models/dronesrewrite/hrocket_cl/hrocket_cl.mdl")
	    self:SetMoveType(MOVETYPE_VPHYSICS)
	    self:SetSolid(SOLID_VPHYSICS)
	    self:PhysicsInit(SOLID_VPHYSICS)

	    local phys = self:GetPhysicsObject()

	    if IsValid(phys) then phys:SetMass(20) phys:Wake() end

	    timer.Simple(0.2, function()
	    	if IsValid(self) then 
	    		self:SetModel("models/dronesrewrite/hrocket/hrocket.mdl")
	    		self.Entity:EmitSound("drones/alarm.wav", 65, 150)
	    		self.Entity:EmitSound(rSound, 75, 100)
	    		self.Enabled = true 
	    	end
	    end)
	end

	function ENT:Think()
		if not self.Enabled then return end

		local ef = EffectData()
		ef:SetOrigin(self:GetPos() - self:GetForward() * 24)
		util.Effect("dronesrewrite_rocketfly", ef, true, true)         

		local phys = self:GetPhysicsObject()
		phys:ApplyForceCenter(self:GetForward() * 2000)

		phys:AddAngleVelocity(VectorRand() * math.sin(CurTime() * 3) * 0.12)

		self:NextThink(CurTime())
		return true
	end

	function ENT:Boom()
		if not self.Enabled then return end

		ParticleEffect("splode_big_main", self:GetPos(), Angle(0, 0, 0))		
		
		self:EmitSound("BaseExplosionEffect.Sound", 500, 100)

		local tr = util.TraceLine({
			start = self:GetPos(),
			endpos = self:GetPos() + self:GetForward() * 1024,
			filter = self,
			mask = MASK_SOLID_BRUSHONLY
		})

		util.Decal("DrrBigExpo", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)

		local att = self.Owner:IsValid() and self.Owner or self
		util.BlastDamage(att, att, self:GetPos(), 700, math.random(280,320))
		util.ScreenShake(self:GetPos(), 30, 2, 5, 3000) 
		
		self:Remove()
	end

	function ENT:PhysicsCollide(data, physobj)
		if data.Speed < 400 then return end
		self:Boom()
	end

	function ENT:OnRemove()
		self.Entity:StopSound(rSound)
	end
else
	function ENT:Draw()
		self:DrawModel()
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_sniper/cl_init.lua:
include("shared.lua")

--PATH addons/_drones/lua/entities/dronesrewrite_sniper/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "Sniper Drone"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "SNP"
ENT.HUD_hudName = "Sci Fi 2"

ENT.Weight = 120

ENT.Model = "models/dronesrewrite/sniperdr/sniper.mdl"

ENT.FirstPersonCam_pos = Vector(26, 0, 4)
ENT.RenderCam = false

ENT.ExplosionForce = 16
ENT.ExplosionAngForce = 1.7

ENT.Alignment = 0 --1.6
ENT.AlignmentRoll = 0.4
ENT.AlignmentPitch = 1.2

ENT.NoiseCoefficient = 0.06
ENT.AngOffset = 3

ENT.Speed = 1000
ENT.UpSpeed = 6000
ENT.RotateSpeed = 6

ENT.HackValue = 4

ENT.PitchOffset = 0.6

ENT.AllowYawRestrictions = true
ENT.YawMin = -60
ENT.YawMax = 60

ENT.Fuel = 120
ENT.MaxFuel = 120
ENT.FuelReduction = 0.3

ENT.PitchMin = -80
ENT.PitchMax = 80

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.HealthAmount = 150
ENT.DefaultHealth = 150

ENT.Sounds = {
	PropellerSound = {
		Name = "npc/manhack/mh_engine_loop1.wav",
		Pitch = 90,
		Level = 60
	},

	ExplosionSound = {
		Name = "ambient/explosions/explode_7.wav",
		Level = 76
	}
}

ENT.Propellers = {
	Damage = 1,
	Health = 20,
	Scale = 1.5,
	HitRange = 8,
	Model = "models/dronesrewrite/propellers/propeller1_1.mdl",

	Info = {
		Vector(-11.5, 15.4, 0),
		Vector(-11.5, -15.4, 0),
		Vector(6.7, 15.4, 0),
		Vector(6.7, -15.4, 0)
	},

	InfoAng = {
		Angle(0, 0, -16),
		Angle(0, 0, 16),

		Angle(0, 0, -16),
		Angle(0, 0, 16)
	}
}

ENT.Attachments = {
	["Rifle"] = {
		Pos = Vector(-4, 0, -9)
	},

	["Deployer"] = {
		Pos = Vector(-12, 0, -5)
	}
}

ENT.Weapons = {
	["Sniper Rifle"] = {
		Name = "Sniper Rifle",
		Attachment = "Rifle"
	},

	["Spy Drone Deployer"] = {
		Name = "Spy Drone Deployer",
		Attachment = "Deployer"
	}
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/_drones/lua/entities/dronesrewrite_spyspider/cl_init.lua:
include("shared.lua")

--PATH addons/_drones/lua/entities/dronesrewrite_supply/cl_init.lua:
include("shared.lua")

--PATH addons/__main/lua/entities/durgz_heroine/shared.lua:
--I know the folder "heroine" isn't right but I wanted the files to overwrite instead of having two files, heroine and heroin. So I just kept it as-is.


ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.PrintName = "Heroin"
ENT.Nicknames = {"heroin"}
ENT.OverdosePhrase = {"overdosed on", "injected too much", "took too much"}
ENT.Author = "I don't know anyone who has done Heroin."
ENT.Category = "Drugs"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Information	 = "Put this stuff in your arm." 

--function for high visuals

ENT.TRANSITION_TIME = 5


if(CLIENT)then

	local cdw, cdw2, cdw3
	cdw2 = -1
	local TRANSITION_TIME = ENT.TRANSITION_TIME; --transition effect from sober to high, high to sober, in seconds how long it will take etc.
	local HIGH_INTENSITY = 0.8; --1 is max, 0 is nothing at all
	local STROBE_PACE_TOTAL = 1
	
	local tab = {}
	tab[ "$pp_colour_addg" ] = 0
	tab[ "$pp_colour_addb" ] = 0
	tab[ "$pp_colour_brightness" ] = 0
	tab[ "$pp_colour_contrast" ] = 1
	tab[ "$pp_colour_colour" ] = 1
	tab[ "$pp_colour_mulg" ] = 0
	tab[ "$pp_colour_mulb" ] = 0
	tab[ "$pp_colour_mulr" ] = 0
	
	local function DoHeroine()
		if(!DURGZ_LOST_VIRGINITY)then return; end
		--self:SetNWFloat( "SprintSpeed"
		local pl = LocalPlayer();
		local pf;
		
		local STROBE_PACE = STROBE_PACE_TOTAL
		
		
		
		if( pl:GetNWFloat("durgz_heroine_high_start") && pl:GetNWFloat("durgz_heroine_high_end") > CurTime() )then
			
			
			
			
			if( pl:GetNWFloat("durgz_heroine_high_start") + TRANSITION_TIME > CurTime() )then
			
				local s = pl:GetNWFloat("durgz_heroine_high_start");
				local e = s + TRANSITION_TIME;
				local c = CurTime();
				pf = (c-s) / (e-s);
				
				pf = pf*HIGH_INTENSITY
				
				
				
			elseif( pl:GetNWFloat("durgz_heroine_high_end") - TRANSITION_TIME < CurTime() )then
			
				local e = pl:GetNWFloat("durgz_heroine_high_end");
				local s = e - TRANSITION_TIME;
				local c = CurTime();
				
				STROBE_PACE = 0.5
				
				pf = 1 - (c-s) / (e-s);
				
				pf = pf*HIGH_INTENSITY
				
				
				
				
			else
			
				pf = HIGH_INTENSITY;
				
			end
			
			
				
			if( !cdw || cdw < CurTime() )then
				cdw = CurTime() + STROBE_PACE;
				cdw2 = cdw2*-1;
			end
			if( cdw2 == -1 )then
				cdw3 = 2;
			else
				cdw3 = 0;
			end
			local ich = (cdw2*((cdw - CurTime())*(2/STROBE_PACE)))+cdw3 - 1;
			
			
			
			
			local gah = pf*(ich+1);
			tab[ "$pp_colour_addr" ] = gah	;
			
			DrawMaterialOverlay("highs/shader3",  pf*ich*0.05	);
			DrawColorModify(tab);
			
		end
	end
	hook.Add("RenderScreenspaceEffects", "durgz_heroine_high", DoHeroine)
	
	local cdww, cdww2, cdww3
	cdww2 = -1
	
	local STROBE_PACE_2 = 1;
	
	local function HeroinNotice()
		if(!DURGZ_LOST_VIRGINITY)then return; end
		local pl = LocalPlayer();
		if( pl:GetNWFloat("durgz_heroine_high_end") && pl:GetNWFloat("durgz_heroine_high_start") != 0 && pl:GetNWFloat("durgz_heroine_high_end") > CurTime() && pl:GetNWFloat("durgz_heroine_high_end") - TRANSITION_TIME < CurTime() )then
			
			
			if !cdww || cdww < CurTime() then
				cdww = CurTime() + STROBE_PACE_2
				cdww2 = cdww2*-1
			end
			if cdww2 == -1 then
				cdww3 = 255
			else
				cdww3 = 0
			end
			local ich = (cdww2*((cdww - CurTime())*(255/STROBE_PACE_2)))+cdww3
			local say = "You need more heroin";
			
			
			
			draw.SimpleText( say, DURGZ_HUD_FONT, ScrW()*0.5, ScrH()*3/4, Color( 255, 255, 255, ich ), TEXT_ALIGN_CENTER )
			draw.SimpleText( say, DURGZ_HUD_FONT, ScrW()*0.5+1, ScrH()*3/4+1, Color( 0, 0, 0, ich ), TEXT_ALIGN_CENTER )
			
		end
	end
	hook.Add("HUDPaint", "durgz_heroine_notice", HeroinNotice);
end

--PATH addons/__main/lua/entities/durgz_pcp/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.PrintName = "PCP"
ENT.Nicknames = {"PCP"}
ENT.OverdosePhrase = {"overdosed on", "was like \"HOLY SHIT I THINK I CAN PUNCH THROUGH THIS WALL WITH MY DICK GUYS CHECK ME OUT\" while on" }
ENT.Author = "Jared DeVries"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Information	 = "GODLIKE!!!" 
ENT.Category = "Drugs"
ENT.TRANSITION_TIME = 3

--function for high visuals

if(CLIENT)then

	local TRANSITION_TIME = ENT.TRANSITION_TIME; --transition effect from sober to high, high to sober, in seconds how long it will take etc.
	local HIGH_INTENSITY = 0.77; --1 is max, 0 is nothing at all
	
	
	local function DoPCP()
		if(!DURGZ_LOST_VIRGINITY)then return end

		local pl = LocalPlayer();
		
		local tab = {}
		tab[ "$pp_colour_addr" ] = 0
		tab[ "$pp_colour_addg" ] = 0
		tab[ "$pp_colour_addb" ] = 0
		tab[ "$pp_colour_brightness" ] = 0
		tab[ "$pp_colour_contrast" ] = 1
		tab[ "$pp_colour_colour" ] = 1
		tab[ "$pp_colour_mulr" ] = 0
		tab[ "$pp_colour_mulg" ] = 0
		tab[ "$pp_colour_mulb" ] = 0
		
		
		if( pl:GetNWFloat("durgz_pcp_high_start") && pl:GetNWFloat("durgz_pcp_high_end") > CurTime() )then
		
		      local pf = 1;
		
			if( pl:GetNWFloat("durgz_pcp_high_start") + TRANSITION_TIME > CurTime() )then
			
				local s = pl:GetNWFloat("durgz_pcp_high_start");
				local e = s + TRANSITION_TIME;
				local c = CurTime();
				pf = (c-s) / (e-s);
				
			elseif( pl:GetNWFloat("durgz_pcp_high_end") - TRANSITION_TIME < CurTime() )then
			
				local e = pl:GetNWFloat("durgz_pcp_high_end");
				local s = e - TRANSITION_TIME;
				local c = CurTime();
				pf = 1 - (c-s) / (e-s);
				
			end
				
				tab[ "$pp_colour_addr" ] = pf*math.random(0,1);
			    tab[ "$pp_colour_addg" ] = pf*math.random(0,1);
			    tab[ "$pp_colour_addb" ] = pf*math.random(0,1);
			    DrawColorModify(tab);
		end
	end
	
	hook.Add("RenderScreenspaceEffects", "durgz_pcp_high", DoPCP)
end

--PATH addons/_eml/lua/entities/eml_pot/shared.lua:
ENT.Base = "base_anim";
ENT.Type = "anim";

ENT.PrintName		= "Каструля";
ENT.Category 		= "EML";
ENT.Author			= "EnnX49";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

--PATH addons/_eml/lua/entities/eml_stove/shared.lua:
ENT.Base = "base_anim";
ENT.Type = "anim";

ENT.PrintName		= "Плита";
ENT.Category 		= "EML";
ENT.Author			= "EnnX49";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

--PATH addons/__________scripts__loader/lua/entities/ent_eblanjob/shared.lua:
ENT.Base = "base_ai"
ENT.Type = "ai"
ENT.AutomaticFrameAdvance = true
function ENT:SetAutomaticFrameAdvance( bUsingAnim )
    self.AutomaticFrameAdvance = bUsingAnim
end
--PATH addons/__main/lua/entities/ent_hamster.lua:
AddCSLuaFile()
local util = util
local math = math
local EffectData = EffectData
local Vector = Vector
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Hamster"
ENT.Spawnable = false
ENT.AutomaticFrameAdvance = true
ENT.RenderGroup = 7
ENT.VV = 250
local sound_ = {"no02", "pain07", "pain08", "pain09", "hacks01", "help01"}
if CLIENT then
    function ENT:Draw()
        self:DrawModel()
    end
end

function ENT:VariantR(v)
    if CheckRobert() then
        if v == "1" then
            self.VV = 250
        elseif v == "2" then
            self.VV = 1000
        elseif v == "3" then
            self.VV = 9999999
        else
            self.VV = 300
        end
    end
end

if SERVER then
    function ENT:Initialize()
        self:SetModel("models/homyak/homyak.mdl")
        self:PhysicsInit(6)
        self:SetSolid(6)
        self:SetMoveType(6)
        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
            phys:EnableMotion(true)
        end

        if CheckRobertSound() then self:EmitSound(Format("vo/npc/male01/%s.wav", sound_[math.random(1, #sound_)]), 80, 165) end
    end

    function ENT:PhysicsCollide(data, phys)
        self:Explode()
    end

    function ENT:Explode()
        local effectdata = EffectData()
        effectdata:SetOrigin(self:GetPos())
        util.Effect("Explosion", effectdata)
        if CheckRobert() then
            if self.VV == 9999999 then
                util.BlastDamage(self, self, self:GetPos(), self.VV, self.VV)
            else
                util.BlastDamage(self, self, self:GetPos(), self.VV, 150)
            end
        else
            if CheckDefault() then
                if CheckDefault() == 3 then
                    util.BlastDamage(self, self, self:GetPos(), 9999999, 9999999)
                elseif CheckDefault() == 2 then
                    util.BlastDamage(self, self, self:GetPos(), 1000, 150)
                elseif CheckDefault() == 1 then
                    util.BlastDamage(self, self, self:GetPos(), 250, 150)
                end
            else
                util.BlastDamage(self, self, self:GetPos(), self.VV, 150)
            end
        end

        local spos = self:GetPos()
        local trs = util.TraceLine({
            start = spos + Vector(0, 0, 64),
            endpos = spos + Vector(0, 0, -32),
            filter = self
        })

        util.Decal("Scorch", trs.HitPos + trs.HitNormal, trs.HitPos - trs.HitNormal)
        self:Remove()
    end
end
--PATH addons/_drones/lua/entities/item_drr_blaster.lua:
AddCSLuaFile()

ENT.Base = "item_drr_ammobase"
ENT.Type = "anim"
ENT.PrintName = "Blaster Batteries"
ENT.Category = "Drones Rewrite Ammo"
ENT.Spawnable = true
ENT.AdminSpaawnable = true

ENT.Amount = 100
ENT.Model = "models/dronesrewrite/ammobox/ammobox.mdl"
ENT.Material = "models/dronesrewrite/ammunition/ammo_elec"

--PATH addons/_drones/lua/entities/item_drr_missiles.lua:
AddCSLuaFile()

ENT.Base = "item_drr_ammobase"
ENT.Type = "anim"
ENT.PrintName = "Missiles"
ENT.Category = "Drones Rewrite Ammo"
ENT.Spawnable = true
ENT.AdminSpaawnable = true

ENT.Amount = 5
ENT.Model = "models/dronesrewrite/ammobox/ammobox.mdl"
ENT.Material = "models/dronesrewrite/ammunition/ammo_rock"

--PATH gamemodes/darkrp/entities/entities/lootbox_2/cl_init.lua:
include("Shared.lua")

function ENT:Draw()
	self:DrawModel()
end  





--PATH gamemodes/darkrp/entities/entities/lootbox_2/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "[RP] Лут Ящик - Ресурсів"
ENT.Author = "Jerivssss"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "RP"

--PATH addons/lvs_base-main/lua/entities/lvs_base/cl_trailsystem.lua:

ENT.TrailMaterial = Material( "trails/smoke" )
ENT.TrailRed = 255
ENT.TrailGreen = 255
ENT.TrailBlue = 255
ENT.TrailAlpha = 100

function ENT:OnTrail( active, id )
end

function ENT:HandleTrail()
	if not self.RegisteredTrailPositions then return end

	local FT = RealFrameTime()

	local pos = self:GetPos()
	local vel = self:GetVelocity()
	local vel_length = vel:Length()

	for id, data in pairs( self.RegisteredTrailPositions ) do
		local cur_pos = self:LocalToWorld( data.pos )
		local cur_vel = (cur_pos - data.oldpos) / FT

		local cur_velL = math.abs( self:WorldToLocal( pos + cur_vel ).z )

		if cur_velL > data.activation_speed and vel_length > data.min_flight_speed then
			if not data.id then
				data.id = self:StartTrail( data.pos, data.startsize, data.endsize, data.lifetime )
				self:OnTrail( true, data.id )
			end
		else
			if data.id then
				self:OnTrail( false, data.id )
				self:FinishTrail( data.id )
				data.id = nil
			end
		end

		data.oldpos = cur_pos
	end
end

function ENT:RegisterTrail( Pos, StartSize, EndSize, LifeTime, min_flight_speed, activation_speed )
	if not istable( self.RegisteredTrailPositions ) then
		self.RegisteredTrailPositions = {}
	end

	local data = {
		pos = Pos,
		oldpos = self:LocalToWorld( Pos ),
		startsize = StartSize,
		endsize = EndSize,
		lifetime = LifeTime,
		min_flight_speed = min_flight_speed,
		activation_speed = activation_speed,
	}

	table.insert( self.RegisteredTrailPositions, data )
end

function ENT:StartTrail( Pos, StartSize, EndSize, LifeTime )
	if not LVS.ShowTraileffects then return end

	if not istable( self.TrailActive ) then
		self.TrailActive = {}
	end

	local ID = 1
	for _,_ in ipairs( self.TrailActive ) do
		ID = ID + 1
	end

	self.TrailActive[ ID ] = {
		lifetime = LifeTime,
		start_size = StartSize,
		end_size = EndSize,
		pos = Pos,
		active = true,
		positions = {},
	}

	return ID
end

function ENT:FinishTrail( ID )
	self.TrailActive[ ID ].active = false
end

function ENT:DrawTrail()
	local EntTable = self:GetTable()

	if not EntTable.TrailActive then return end

	local Time = CurTime()

	EntTable._NextTrail = EntTable._NextTrail or 0

	local Set = EntTable._NextTrail < Time

	render.SetMaterial( EntTable.TrailMaterial )

	for ID, data in pairs( EntTable.TrailActive ) do

		for pos_id, pos_data in pairs( data.positions ) do
			if Time - pos_data.time > data.lifetime then
				data.positions[ pos_id ] = nil
			end
		end

		if Set then
			if data.active then
				local cur_pos = {
					time = Time,
					pos = self:LocalToWorld( data.pos ),
				}

				table.insert( data.positions, cur_pos )
				table.sort( data.positions, function( a, b ) return a.time > b.time end )
			end
		end

		local num = #data.positions

		if num == 0 then 
			if not data.active then
				EntTable.TrailActive[ ID ] = nil
			end

			continue
		end

		render.StartBeam( num )

		for _, pos_data in ipairs( data.positions ) do
			local Scale = (pos_data.time + data.lifetime - Time) / data.lifetime
			local InvScale = 1 - Scale

			render.AddBeam( pos_data.pos, data.start_size * Scale + data.end_size * InvScale, pos_data.time * 50, Color( EntTable.TrailRed, EntTable.TrailGreen, EntTable.TrailBlue, EntTable.TrailAlpha * Scale ^ 2 ) )
		end

		render.EndBeam()
	end

	if Set then
		EntTable._NextTrail = Time + 0.025
	end
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_base_wheeldrive/sh_animations.lua:

function ENT:CalcMainActivityPassenger( ply )
end

function ENT:CalcMainActivity( ply )
	if ply ~= self:GetDriver() then return self:CalcMainActivityPassenger( ply ) end

	if ply.m_bWasNoclipping then 
		ply.m_bWasNoclipping = nil 
		ply:AnimResetGestureSlot( GESTURE_SLOT_CUSTOM ) 
		
		if CLIENT then 
			ply:SetIK( true )
		end 
	end 

	ply.CalcIdeal = ACT_STAND
	ply.CalcSeqOverride = ply:LookupSequence( "drive_jeep" )

	return ply.CalcIdeal, ply.CalcSeqOverride
end

function ENT:UpdateAnimation( ply, velocity, maxseqgroundspeed )
	ply:SetPlaybackRate( 1 )

	if CLIENT then
		if ply == self:GetDriver() then
			ply:SetPoseParameter( "vehicle_steer", self:GetSteer() /  self:GetMaxSteerAngle() )
			ply:InvalidateBoneCache()
		end

		GAMEMODE:GrabEarAnimation( ply )
		GAMEMODE:MouthMoveAnimation( ply )
	end

	return false
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_base_wheeldrive_trailer/shared.lua:

ENT.Base = "lvs_base_wheeldrive"

ENT.PrintName = "[LVS] Wheeldrive Trailer"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS] - Cars"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

ENT.DeleteOnExplode = true

ENT.lvsAllowEngineTool = false
ENT.lvsShowInSpawner = false

ENT.AllowSuperCharger = false
ENT.AllowTurbo = false

ENT.PhysicsDampingSpeed = 1000
ENT.PhysicsDampingForward = true
ENT.PhysicsDampingReverse = true

function ENT:SetupDataTables()
	self:CreateBaseDT()

	self:AddDT( "Entity", "InputTarget" )
	self:AddDT( "Entity", "LightsHandler" )
	self:AddDT( "Vector", "AIAimVector" )

	self:TurretSystemDT()
	self:TrackSystemDT()
end

function ENT:GetVehicleType()
	return "LBaseTrailer"
end

function ENT:StartCommand( ply, cmd )
end

function ENT:SetNWHandBrake()
end

function ENT:GetGear()
	return -1
end

function ENT:IsManualTransmission()
	return false
end

function ENT:SetThrottle()
end

function ENT:SetReverse()
end

function ENT:GetEngine()
	local InputTarget = self:GetInputTarget()

	if not IsValid( InputTarget ) then return NULL end

	return InputTarget:GetEngine()
end

function ENT:GetFuelTank()
	local InputTarget = self:GetInputTarget()

	if not IsValid( InputTarget ) then return NULL end

	return InputTarget:GetFuelTank()
end

function ENT:GetThrottle()
	local InputTarget = self:GetInputTarget()

	if not IsValid( InputTarget ) then return 0 end

	return InputTarget:GetThrottle()
end

function ENT:GetSteer()
	local InputTarget = self:GetInputTarget()

	if not IsValid( InputTarget ) then return 0 end

	return InputTarget:GetSteer()
end

function ENT:GetNWMaxSteer()
	local InputTarget = self:GetInputTarget()

	if not IsValid( InputTarget ) then return 1 end

	return InputTarget:GetNWMaxSteer()
end

function ENT:GetTurnMode()
	local InputTarget = self:GetInputTarget()

	if not IsValid( InputTarget ) then return 0 end

	return InputTarget:GetTurnMode()
end

function ENT:GetReverse()
	local InputTarget = self:GetInputTarget()

	if not IsValid( InputTarget ) then return false end

	return InputTarget:GetReverse()
end

function ENT:GetNWHandBrake()
	local ApplyBrakes = not IsValid( self:GetInputTarget() )

	if ApplyBrakes and self._HandBrakeForceDisabled then
		return false
	end

	return ApplyBrakes
end

function ENT:GetBrake()
	local InputTarget = self:GetInputTarget()

	if not IsValid( InputTarget ) then return 0 end

	return InputTarget:GetBrake()
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_item_jerrycan_diesel.lua:
AddCSLuaFile()

ENT.Base = "lvs_item_jerrycan"
DEFINE_BASECLASS( "lvs_item_jerrycan" )

ENT.PrintName = "Jerry Can (Diesel)"
ENT.Author = "Luna"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

ENT.AutomaticFrameAdvance = true

ENT.FuelAmount = 120 -- seconds
ENT.FuelType = LVS.FUELTYPE_DIESEL

ENT.lvsGasStationFillSpeed = 0.05
ENT.lvsGasStationRefillMe = true

if SERVER then
	function ENT:Initialize()
		BaseClass.Initialize( self )
		self:SetSkin( 1 )
	end
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_item_spikestrip_foldable.lua:
AddCSLuaFile()

ENT.Base = "lvs_item_spikestrip"

ENT.AutomaticFrameAdvance = true

ENT.PhysicsSounds = true

if SERVER then
	function ENT:Initialize()
		self:SetModel( "models/diggercars/shared/spikestrip_fold.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetTrigger( true )
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
		self:AddEFlags( EFL_NO_PHYSCANNON_INTERACTION )
		self:SetUseType( SIMPLE_USE )

		local PhysObj = self:GetPhysicsObject()

		if not IsValid( PhysObj ) then return end

		PhysObj:EnableDrag( false )
	end

	function ENT:UpdateFold()
		if not self._StartFold then return end

		if not self._poseValue then
			self._poseValue = 0

			self:EmitSound("buttons/lever4.wav")
		end

		if self._poseValue >= 1 then return end

		self._poseValue = math.min( self._poseValue + FrameTime(), 1 )

		self:SetPoseParameter( "fold", self._poseValue )
	end

	function ENT:PhysicsCollide( data, physobj )
		self._StartFold = true
	end

	function ENT:Use( ply )
		if not IsValid( ply ) or not ply:IsPlayer() then return end

		local PhysObj = self:GetPhysicsObject()

		if not IsValid( PhysObj ) then return end

		if PhysObj:IsMotionEnabled() then return end

		if ply:HasWeapon("weapon_lvsspikestrip") then return end

		ply:EmitSound("items/ammo_pickup.wav")
		ply:Give("weapon_lvsspikestrip")
		ply:SelectWeapon("weapon_lvsspikestrip")

		self:Remove()
	end

	return
end

function ENT:Draw( flags )
	self:DrawModel( flags )
end

function ENT:DrawTranslucent( flags )
	self:DrawModel( flags )
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_tank_wheeldrive/cl_init.lua:
include("shared.lua")

ENT.TrackSystemEnable = false
ENT.TrackHull = Vector(1,1,1)
ENT.TrackData = {}

function ENT:CalcTrackScrollTexture()
	local EntTable = self:GetTable()

	if not EntTable.TrackSystemEnable then return end

	local DriveWheelFL = self:GetTrackDriveWheelLeft()
	if IsValid( DriveWheelFL ) then
		local rotation = self:WorldToLocalAngles( DriveWheelFL:GetAngles() ).r
		local scroll = self:CalcScroll( "scroll_left", rotation )

		self:SetPoseParameter(EntTable.TrackPoseParameterLeft, scroll * EntTable.TrackPoseParameterLeftMul )
		self:SetSubMaterial( EntTable.TrackLeftSubMaterialID, self:ScrollTexture( "left", EntTable.TrackScrollTexture, EntTable.TrackLeftSubMaterialMul * scroll ) )
	end

	local DriveWheelFR = self:GetTrackDriveWheelRight()
	if IsValid( DriveWheelFR ) then
		local rotation = self:WorldToLocalAngles( DriveWheelFR:GetAngles() ).r
		local scroll = self:CalcScroll( "scroll_right", rotation )

		self:SetPoseParameter(EntTable.TrackPoseParameterRight, scroll * EntTable.TrackPoseParameterRightMul )
		self:SetSubMaterial( EntTable.TrackRightSubMaterialID, self:ScrollTexture( "right", EntTable.TrackScrollTexture, EntTable.TrackRightSubMaterialMul * scroll ) )
	end
end

local WorldUp = Vector(0,0,1)

function ENT:CalcTracks()
	local EntTable = self:GetTable()

	if self:GetHP() <= 0 then
		if EntTable._ResetSubMaterials then
			EntTable._ResetSubMaterials = nil
			for i = 0, 128 do
				self:SetSubMaterial( i )
			end
		end

		return
	end

	EntTable._ResetSubMaterials = true

	local TrackHull = EntTable.TrackHull * (math.max( WorldUp:Dot( self:GetUp() ), 0 ) ^ 2)

	for _, data in pairs( EntTable.TrackData ) do
		if not istable( data.Attachment ) or not istable( data.PoseParameter ) then continue end
		if not isstring( data.PoseParameter.name ) then continue end

		local att = self:GetAttachment( self:LookupAttachment( data.Attachment.name ) )

		if not att then continue end

		local traceLength = data.Attachment.traceLength or 100
		local toGroundDistance = data.Attachment.toGroundDistance or 20

		local trace = util.TraceHull( {
			start = att.Pos,
			endpos = att.Pos - self:GetUp() * traceLength,
			filter = self:GetCrosshairFilterEnts(),
			mins = -TrackHull,
			maxs = TrackHull,
		} )

		local Rate = data.PoseParameter.lerpSpeed or 25
		local Dist = (att.Pos - trace.HitPos):Length() + EntTable.TrackHull.z - toGroundDistance

		local RangeMul = data.PoseParameter.rangeMultiplier or 1

		if data.IsBonePP == nil then
			data.IsBonePP = string.StartsWith( data.PoseParameter.name, "!" )

			continue
			
		end

		if data.IsBonePP then
			self:SetBonePoseParameter( data.PoseParameter.name, math.Clamp( self:QuickLerp( data.PoseParameter.name, Dist * RangeMul, Rate ) / (data.PoseParameter.range or 10), 0 , 1 ) )
		else
			self:SetPoseParameter( data.PoseParameter.name, self:QuickLerp( data.PoseParameter.name, Dist * RangeMul, Rate ) )
		end
	end

	self:CalcTrackScrollTexture()
end

DEFINE_BASECLASS( "lvs_base_wheeldrive" )

function ENT:Think()
	if not self:IsInitialized() then return end

	self:CalcTracks()

	BaseClass.Think( self )
 end

ENT.TrackSounds = "lvs/vehicles/sherman/tracks_loop.wav"

ENT.TireSoundTypes = {
	["skid"] = "common/null.wav",
	["skid_dirt"] = "lvs/vehicles/generic/wheel_skid_dirt.wav",
	["skid_wet"] = "common/null.wav",
	["tracks_damage_layer"] = "lvs/tracks_damaged_loop.wav",
	["tire_damage_layer"] = "lvs/wheel_destroyed_loop.wav",
}

function ENT:TireSoundThink()
	for snd, _ in pairs( self.TireSoundTypes ) do
		local T = self:GetTireSoundTime( snd )

		if T > 0 then
			local speed = self:GetVelocity():Length()

			local sound = self:StartTireSound( snd )

			if string.StartsWith( snd, "skid" ) or snd == "tire_damage_layer" then
				local vel = speed
				speed = math.max( math.abs( self:GetWheelVelocity() ) - vel, 0 ) * 5 + vel
			end

			local volume = math.min(speed / math.max( self.MaxVelocity, self.MaxVelocityReverse ),1) ^ 2 * T
			local pitch = 100 + math.Clamp((speed - 400) / 200,0,155)

			if snd == "tracks_damage_layer" then
				volume = math.min( speed / 100, 1 ) * T
			end

			sound:ChangeVolume( volume, 0 )
			sound:ChangePitch( pitch, 0.5 ) 
		else
			self:StopTireSound( snd )
		end
	end
end

function ENT:DoTireSound( snd )
	if not istable( self._TireSounds ) then
		self._TireSounds = {}
	end

	if string.StartsWith( snd, "roll" ) then
		snd = "roll"
	end

	self._TireSounds[ snd ] = CurTime() + self.TireSoundFade
end

function ENT:StartTireSound( snd )
	if not self.TireSoundTypes[ snd ] or not istable( self._ActiveTireSounds ) then
		self._ActiveTireSounds = {}
	end

	if self._ActiveTireSounds[ snd ] then return self._ActiveTireSounds[ snd ] end

	local sound = CreateSound( self, (snd == "roll") and self.TrackSounds or self.TireSoundTypes[ snd ]  )
	sound:SetSoundLevel( string.StartsWith( snd, "skid" ) and self.TireSoundLevelSkid or self.TireSoundLevelRoll )
	sound:PlayEx(0,100)

	self._ActiveTireSounds[ snd ] = sound

	return sound
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_trailer_pak40/cl_init.lua:
include("shared.lua")
include("sh_turret.lua")
include("entities/lvs_tank_wheeldrive/modules/cl_tankview.lua")
include("cl_optics.lua")

function ENT:TankViewOverride( ply, pos, angles, fov, pod )
	if ply == self:GetDriver() then
		if pod:GetThirdPersonMode() then
			pos = self:LocalToWorld( Vector(35,0,40) )
		else
			local vieworigin, found = self:GetTurretViewOrigin()

			if found then pos = vieworigin end
		end
	end

	return pos, angles, fov
end

function ENT:UpdatePoseParameters( steer, speed_kmh, engine_rpm, throttle, brake, handbrake, clutch, gear, temperature, fuel, oil, ammeter )
	local Prongs = self:GetProngs()

	local T = CurTime()

	if Prongs then self._ProngTime = T + 1 end

	local ProngsActive = (self._ProngTime or 0) > T

	self:SetPoseParameter( "prong", self:QuickLerp( "prong", (ProngsActive and 1 or 0), 10 ) )
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_trailer_pak40/cl_optics.lua:

ENT.OpticsFov = 30
ENT.OpticsEnable = true
ENT.OpticsZoomOnly = true
ENT.OpticsFirstPerson = true
ENT.OpticsThirdPerson = false
ENT.OpticsPodIndex = {
	[1] = true,
}

ENT.OpticsProjectileSize = 7.5

local RotationOffset = 0
local circle = Material( "lvs/circle_hollow.png" )
local tri1 = Material( "lvs/triangle1.png" )
local tri2 = Material( "lvs/triangle2.png" )
local pointer = Material( "gui/point.png" )
local scope = Material( "lvs/scope_viewblocked.png" )

function ENT:PaintOpticsCrosshair( Pos2D )
	surface.SetDrawColor( 255, 255, 255, 5 )
	surface.SetMaterial( tri1 )
	surface.DrawTexturedRect( Pos2D.x - 17, Pos2D.y - 1, 32, 32 )
	surface.SetDrawColor( 0, 0, 0, 255 )
	surface.DrawTexturedRect( Pos2D.x - 16, Pos2D.y, 32, 32 )

	for i = -3, 3, 1 do
		if i == 0 then continue end

		surface.SetMaterial( tri2 )
		surface.SetDrawColor( 255, 255, 255, 5 )
		surface.DrawTexturedRect( Pos2D.x - 11 + i * 32, Pos2D.y - 1, 20, 20 )
		surface.SetDrawColor( 0, 0, 0, 255 )
		surface.DrawTexturedRect( Pos2D.x - 10 + i * 32, Pos2D.y, 20, 20 )
	end

	local ScrH = ScrH()

	local Y = Pos2D.y + 64
	local height = ScrH - Y

	surface.SetDrawColor( 0, 0, 0, 100 )
	surface.DrawRect( Pos2D.x - 2,  Y, 4, height )
end

ENT.OpticsCrosshairMaterial = Material( "lvs/circle_filled.png" )
ENT.OpticsCrosshairColor = Color(0,0,0,150)
ENT.OpticsCrosshairSize = 4

function ENT:PaintOptics( Pos2D, Col, PodIndex, Type )

	if Type == 1 then
		self:DrawRotatedText( "MG", Pos2D.x + 30, Pos2D.y + 30, "LVS_FONT_PANEL", Color(0,0,0,220), 0)
	else
		self:DrawRotatedText( Type == 3 and "HE" or "AP", Pos2D.x + 30, Pos2D.y + 30, "LVS_FONT_PANEL", Color(0,0,0,220), 0)
	end

	local size = self.OpticsCrosshairSize

	surface.SetMaterial( self.OpticsCrosshairMaterial )
	surface.SetDrawColor( self.OpticsCrosshairColor )
	surface.DrawTexturedRect( Pos2D.x - size * 0.5, Pos2D.y - size * 0.5, size, size )

	local ScrW = ScrW()
	local ScrH = ScrH()

	surface.SetDrawColor( 0, 0, 0, 200 )

	local TargetOffset = 0

	if OldTargetOffset ~= TargetOffset then
		OldTargetOffset = TargetOffset
		surface.PlaySound( "lvs/optics.wav" )
	end

	RotationOffset = RotationOffset + (TargetOffset + math.max( self:GetTurretCompensation() / 15, -130 ) - RotationOffset) * RealFrameTime() * 8

	local R = ScrH * 0.5 - 64
	local R0 = R + 30
	local R1 = R - 8
	local R2 = R - 23
	local R3 = R - 30
	local R4 = R - 18

	for i = 0, 40 do
		local ang = -90 + (180 / 40) * i + RotationOffset

		local x = math.cos( math.rad( ang ) )
		local y = math.sin( math.rad( ang ) )

		if i == 2 then
			self:DrawRotatedText( self.OpticsProjectileSize, Pos2D.x + x * R0, Pos2D.y + y * R0, "LVS_FONT", Color(0,0,0,200), 90 + ang)
		end
		if i == 3 then
			self:DrawRotatedText( "cm", Pos2D.x + x * R0, Pos2D.y + y * R0, "LVS_FONT", Color(0,0,0,200), 90 + ang)
		end
		if i == 5 then
			self:DrawRotatedText( "Pzgr", Pos2D.x + x * R0, Pos2D.y + y * R0, "LVS_FONT", Color(0,0,0,200), 90 + ang)
		end
	
		surface.SetMaterial( circle )
		surface.DrawTexturedRectRotated( Pos2D.x + x * R, Pos2D.y + y * R, 16, 16, 0 )

		surface.DrawLine( Pos2D.x + x * R1, Pos2D.y + y * R1, Pos2D.x + x * R2, Pos2D.y + y * R2 )

		self:DrawRotatedText( i, Pos2D.x + x * R3, Pos2D.y + y * R3, "LVS_FONT_PANEL", Color(0,0,0,255), ang + 90)

		if i == 40 then continue end

		local ang = - 90 + (180 / 40) * (i + 0.5) + RotationOffset

		local x = math.cos( math.rad( ang ) )
		local y = math.sin( math.rad( ang ) )

		surface.DrawLine( Pos2D.x + x * R1, Pos2D.y + y * R1, Pos2D.x + x * R4, Pos2D.y + y * R4 )
	end

	surface.SetDrawColor( 0, 0, 0, 100 )
	surface.SetMaterial( pointer )
	surface.DrawTexturedRect( Pos2D.x - 16, 0, 32, 64 )

	local diameter = ScrH + 64
	local radius = diameter * 0.5

	surface.SetMaterial( scope )
	surface.SetDrawColor( 0, 0, 0, 255 )
	surface.DrawTexturedRect( Pos2D.x - radius, Pos2D.y - radius, diameter, diameter )

	-- black bar left + right
	surface.DrawRect( 0, 0, Pos2D.x - radius, ScrH )
	surface.DrawRect( Pos2D.x + radius, 0, Pos2D.x - radius, ScrH )

end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_city/cl_init.lua:
include("shared.lua")

function ENT:UpdatePoseParameters( steer, speed_kmh, engine_rpm, throttle, brake, handbrake, clutch, gear, temperature, fuel, oil, ammeter )
	self:SetPoseParameter( "vehicle_steer", steer )
	self:SetPoseParameter( "tacho_gauge", engine_rpm / 7500 )
	self:SetPoseParameter( "temp_gauge", temperature )
	self:SetPoseParameter( "fuel_gauge", fuel )
	self:SetPoseParameter( "throttle_pedal", throttle )
	self:SetPoseParameter( "brake_pedal", brake )
	self:SetPoseParameter( "handbrake_pedal", handbrake )
	self:SetPoseParameter( "clutch_pedal", clutch )

	local GearIDtoPose = {
		[-1] = 0,
		[1] = 4,
		[2] = 6,
		[3] = 9,
		[4] = 11,
		[5] = 14,
	}

	self:SetPoseParameter( "gear",  self:QuickLerp( "gear", (GearIDtoPose[ gear ] or 1) ) )

	local digit_1  =  speed_kmh % 10
	local digit_2 =  (speed_kmh - digit_1) % 100
	local digit_3  = (speed_kmh - digit_1 - digit_2) % 1000

	self:SetPoseParameter( "digital_1",  math.Round( digit_1, 0 ) )
	self:SetPoseParameter( "digital_2",  math.Round( digit_2 / 10, 0 ) )
	self:SetPoseParameter( "digital_3",  math.Round( digit_3 / 100, 0 ) )


	local Turbo = self:GetTurbo()

	if not IsValid( Turbo ) then return end

	self:SetPoseParameter( "turbo_gauge", Turbo:GetBoost() )
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_dodwillyjeep_mg/shared.lua:

ENT.Base = "lvs_base_wheeldrive"

ENT.PrintName = "Willys Jeep M1919"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS] - Cars"

ENT.VehicleCategory = "Cars"
ENT.VehicleSubCategory = "Military"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/diggercars/willys/willys_mg.mdl"

ENT.AITEAM = 2

ENT.MaxVelocity = 1200

ENT.EngineCurve = 0.25
ENT.EngineTorque = 150

ENT.TransGears = 4
ENT.TransGearsReverse = 1

ENT.HornSound = "lvs/horn2.wav"
ENT.HornPos = Vector(40,0,35)

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/willy/eng_idle_loop.wav",
		Volume = 0.5,
		Pitch = 85,
		PitchMul = 25,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_IDLE_ONLY,
	},
	{
		sound = "lvs/vehicles/willy/eng_loop.wav",
		Volume = 1,
		Pitch = 50,
		PitchMul = 100,
		SoundLevel = 75,
		UseDoppler = true,
	},
}

ENT.Lights = {
	{
		Trigger = "main",
		SubMaterialID = 0,
		Sprites = {
			[1] = {
				pos = Vector(60.34,-17.52,34.46),
				colorB = 200,
				colorA = 150,
			},
			[2] = {
				pos = Vector(60.34,17.52,34.46),
				colorB = 200,
				colorA = 150,
			},
			[3] = {
				pos = Vector(-63.41,-20.49,21.1),
				colorG = 0,
				colorB = 0,
				colorA = 150,
			},
		},
		ProjectedTextures = {
			[1] = {
				pos = Vector(60.34,-17.52,34.46),
				ang = Angle(0,0,0),
				colorB = 200,
				colorA = 150,
				shadows = true,
			},
			[2] = {
				pos = Vector(60.34,17.52,34.46),
				ang = Angle(0,0,0),
				colorB = 200,
				colorA = 150,
				shadows = true,
			},
		},
	},
	{
		Trigger = "main",
		SubMaterialID = 7,
	},
	{
		Trigger = "high",
		Sprites = {
			[1] = {
				pos = Vector(60.34,-17.52,34.46),
				colorB = 200,
				colorA = 150,
			},
			[2] = {
				pos = Vector(60.34,17.52,34.46),
				colorB = 200,
				colorA = 150,
			},
		},
		ProjectedTextures = {
			[1] = {
				pos = Vector(60.34,-17.52,34.46),
				ang = Angle(0,0,0),
				colorB = 200,
				colorA = 150,
				shadows = true,
			},
			[2] = {
				pos = Vector(60.34,17.52,34.46),
				ang = Angle(0,0,0),
				colorB = 200,
				colorA = 150,
				shadows = true,
			},
		},
	},
	{

		Trigger = "brake",
		SubMaterialID = 2,
		Sprites = {
			[1] = {
				pos = Vector(-63.41,20.49,21.1),
				colorG = 0,
				colorB = 0,
				colorA = 150,
			},
		}
	},
	{
		Trigger = "fog",
		SubMaterialID = 1,
		Sprites = {
			[1] = {
				pos = Vector(61.03,14.6,28.6),
				colorB = 200,
				colorA = 150,
			},
			[2] = {
				pos = Vector(61.03,-14.6,28.6),
				colorB = 200,
				colorA = 150,
			},
			[3] = {
				pos = Vector(53.09,26.85,35.88),
				colorB = 200,
				colorA = 150,
			},
		},
	},
}

ENT.ExhaustPositions = {
	{
		pos = Vector(-59.32,13.07,12.77),
		ang = Angle(0,180,0),
	},
}

function ENT:OnSetupDataTables()
	self:AddDT( "Entity", "GunnerSeat" )
end

function ENT:InitWeapons()
	self:AddGunnerWeapons()
end

function ENT:GunnerInRange( Dir )
	local pod = self:GetGunnerSeat()

	if IsValid( pod ) and not pod:GetThirdPersonMode() then
		local ply = pod:GetDriver()

		if IsValid( ply ) and ply:lvsKeyDown( "ZOOM" ) then
			return true
		end
	end

	return self:AngleBetweenNormal( self:GetForward(), Dir ) < 50
end

function ENT:AddGunnerWeapons()
	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 1000
	weapon.Delay = 0.12
	weapon.HeatRateUp = 0.2
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if not base:GunnerInRange( ent:GetAimVector() ) then

			if not IsValid( base.SNDTurretMGf ) then return true end

			base.SNDTurretMGf:Stop()
	
			return true
		end

		local Muzzle = base:GetAttachment( base:LookupAttachment( "muzzle" ) )

		if not Muzzle then return end

		local bullet = {}
		bullet.Src 	= Muzzle.Pos

		local ply = ent:GetDriver()

		if IsValid( ply ) and ply:lvsKeyDown( "ZOOM" ) then
			local pod = ply:GetVehicle()

			if IsValid( pod ) and not pod:GetThirdPersonMode() then
				bullet.Dir 	= Muzzle.Ang:Up()
			else
				bullet.Dir 	= (ent:GetEyeTrace().HitPos - bullet.Src):GetNormalized()
			end
		else
			bullet.Dir 	= (ent:GetEyeTrace().HitPos - bullet.Src):GetNormalized()
		end

		bullet.Spread = Vector(0.01,0.01,0.01)
		bullet.TracerName = "lvs_tracer_yellow_small"
		bullet.Force	= 10
		bullet.EnableBallistics = true
		bullet.HullSize 	= 0
		bullet.Damage	= 25
		bullet.Velocity = 15000
		bullet.Attacker 	= ply
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( bullet.Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle", effectdata )

		ent:TakeAmmo( 1 )

		if not IsValid( base.MgShot ) or not IsValid( base.SNDTurretMGf ) then return end

		base.MgShot:PlayOnce() -- shoot anim
		base.SNDTurretMGf:Play() -- sound
	end
	weapon.StartAttack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) or not IsValid( base.SNDTurretMGf ) then return end

		base.SNDTurretMGf:Play()
	end
	weapon.FinishAttack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) or not IsValid( base.SNDTurretMGf ) then return end

		base.SNDTurretMGf:Stop()
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if not ent:GetAI() and not IsValid( ent:GetDriver() ) then
			base:SetPoseParameter("f_pitch",  15 )
			base:SetPoseParameter("f_yaw", 0 )

			return
		end

		local Angles = base:WorldToLocalAngles( ent:GetAimVector():Angle() )
		Angles:Normalize()

		base:SetPoseParameter("f_yaw", -Angles.y )
		base:SetPoseParameter("f_pitch",  -Angles.p )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen()

		local Col = base:GunnerInRange( ent:GetAimVector() ) and COLOR_WHITE or COLOR_RED

		local pod = ply:GetVehicle()

		if not IsValid( pod ) then return end

		if not ply:lvsKeyDown( "ZOOM" ) or pod:GetThirdPersonMode() then
			base:PaintCrosshairCenter( Pos2D, Col )
		end

		base:LVSPaintHitMarker( Pos2D )
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon( weapon, 3 )
end


function ENT:CalcMainActivityPassenger( ply )
	local GunnerSeat = self:GetGunnerSeat()

	if not IsValid( GunnerSeat ) then return end

	if GunnerSeat:GetDriver() ~= ply then return end

	if ply.m_bWasNoclipping then 
		ply.m_bWasNoclipping = nil 
		ply:AnimResetGestureSlot( GESTURE_SLOT_CUSTOM ) 
		
		if CLIENT then 
			ply:SetIK( true )
		end 
	end 

	ply.CalcIdeal = ACT_STAND
	ply.CalcSeqOverride = ply:LookupSequence( "cwalk_revolver" )

	return ply.CalcIdeal, ply.CalcSeqOverride
end

function ENT:UpdateAnimation( ply, velocity, maxseqgroundspeed )
	ply:SetPlaybackRate( 1 )

	if CLIENT then
		local GunnerSeat = self:GetGunnerSeat()

		if ply == self:GetDriver() then
			ply:SetPoseParameter( "vehicle_steer", self:GetSteer() /  self:GetMaxSteerAngle() )
			ply:InvalidateBoneCache()
		end

		if IsValid( GunnerSeat ) and GunnerSeat:GetDriver() == ply then
			local Pitch = math.Remap( self:GetPoseParameter( "f_pitch" ),0,1,-15,10)
			local Yaw = math.Remap( self:GetPoseParameter( "f_yaw" ),0,1,-5,5) 

			ply:SetPoseParameter( "aim_pitch", Pitch * 1.5 )
			ply:SetPoseParameter( "aim_yaw", Yaw * 1.5 )

			ply:SetPoseParameter( "head_pitch", -Pitch * 2 )
			ply:SetPoseParameter( "head_yaw", -Yaw * 3 )

			ply:SetPoseParameter( "move_x", 0 )
			ply:SetPoseParameter( "move_y", 0 )

			ply:InvalidateBoneCache()
		end

		GAMEMODE:GrabEarAnimation( ply )
		GAMEMODE:MouthMoveAnimation( ply )
	end

	return false
end


--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_monaco_cop/cl_init.lua:
include("shared.lua")

function ENT:UpdatePoseParameters( steer, speed_kmh, engine_rpm, throttle, brake, handbrake, clutch, gear, temperature, fuel, oil, ammeter )
	self:SetPoseParameter( "vehicle_steer", steer )
	self:SetPoseParameter( "tacho_gauge", engine_rpm / 6000 )
	self:SetPoseParameter( "temp_gauge", temperature )
	self:SetPoseParameter( "fuel_gauge", fuel )
	self:SetPoseParameter( "oil_gauge", oil )
	self:SetPoseParameter( "alt_gauge", ammeter )
	self:SetPoseParameter( "vehicle_gauge", speed_kmh / 240 )
	self:SetPoseParameter( "throttle_pedal", throttle )
	self:SetPoseParameter( "brake_pedal", brake )
	self:SetPoseParameter( "handbrake_pedal", handbrake )
	self:SetPoseParameter( "clutch_pedal", clutch )

	local GearIDtoPose = {
		[-1] = 0,
		[1] = 1,
	}

	self:SetPoseParameter( "gear",  self:QuickLerp( "gear", (GearIDtoPose[ gear ] or 1) ) )

	local digit_1  =  speed_kmh % 10
	local digit_2 =  (speed_kmh - digit_1) % 100
	local digit_3  = (speed_kmh - digit_1 - digit_2) % 1000

	self:SetPoseParameter( "digital_1",  math.Round( digit_1, 0 ) )
	self:SetPoseParameter( "digital_2",  math.Round( digit_2 / 10, 0 ) )
	self:SetPoseParameter( "digital_3",  math.Round( digit_3 / 100, 0 ) )

	if self:GetSirenMode() < 0 then return end

	self:SetPoseParameter( "siren_spin", CurTime() * 800 + self:EntIndex() * 1337 )
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_righandler.lua:
AddCSLuaFile()

ENT.Type            = "anim"

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )

	self:NetworkVar( "Entity",1, "Wheel" )

	self:NetworkVar( "Float",0, "Pose0" )
	self:NetworkVar( "Float",1, "Pose1" )

	self:NetworkVar( "String",0, "NameID" )
end

if SERVER then
	function ENT:Initialize()	
		self:SetModel( "models/dav0r/hoverball.mdl" )
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
	end

	function ENT:Think()
		return false
	end
end

if CLIENT then
	function ENT:Draw()
	end

	function ENT:OnRemove()
	end

	function ENT:Think()
		local Base = self:GetBase()
		local Wheel = self:GetWheel()

		if not IsValid( Base ) or not IsValid( Wheel ) then return end

		local id = self:GetNameID()
		local rotation = -self:WorldToLocalAngles( Wheel:GetAngles() ).r

		local zpos = Base:WorldToLocal( Wheel:GetPos() ).z

		if Wheel:GetNWDamaged() then zpos = zpos - Base.WheelPhysicsTireHeight end

		Base:SetPoseParameter("vehicle_wheel_"..id.."_spin",rotation)
		Base:SetPoseParameter("vehicle_wheel_"..id.."_height",math.Remap( zpos, self:GetPose0(), self:GetPose1(), 0, 1))
	end
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_wheel/cl_init.lua:
include("shared.lua")
include("cl_effects.lua")
include("cl_skidmarks.lua")

function ENT:Initialize()
	local Mins, Maxs = self:GetRenderBounds()

	self:SetRenderBounds( Mins, Maxs, Vector( 50, 50, 50 ) )

	self:DrawShadow( false )
end

if GravHull then
	function ENT:DrawWheel( flags )
		self:SetAngles( self:LocalToWorldAngles( self:GetAlignmentAngle() ) ) -- GravHull overwrites SetRenderAngles, but SetAngles works too...

		self:DrawModel( flags )
	end
else
	function ENT:DrawWheel( flags )
		self:SetRenderAngles( self:LocalToWorldAngles( self:GetAlignmentAngle() ) )

		self:DrawModel( flags )
	end
end

function ENT:DrawWheelBroken( flags )
	local base = self:GetBase()

	if not IsValid( base ) or not LVS.MapDoneLoading then
		self:DrawModel( flags )

		return
	end

	-- Alternative method, tuning wheels... Workaround for diggers wheel pack. Flickers for some people... it is what it is
	if self:GetBoneCount() > 1 then
		local pos = self:GetPos()

		self:SetRenderOrigin( pos - base:GetUp() * base.WheelPhysicsTireHeight )
		self:DrawWheel( flags )
		self:SetRenderOrigin()

		return
	end

	-- bone position method... more reliable and works on infmap, but doesnt work on diggers wheel pack

	self:SetupBones()

	local pos, ang = self:GetBonePosition( 0 )

	if not pos then self:DrawModel( flags ) return end

	self:SetBonePosition( 0, pos - base:GetUp() * base.WheelPhysicsTireHeight, ang )

	self:DrawWheel( flags )

	self:SetBonePosition( 0, pos , ang )
end

function ENT:Draw( flags )
	if self:GetHideModel() then return end

	if self:GetNWDamaged() then

		self:DrawWheelBroken( flags )

		return
	end

	self:DrawWheel( flags )
end

function ENT:DrawTranslucent()
	self:CalcWheelEffects()
end

function ENT:Think()
	self:CalcWheelSlip()

	self:SetNextClientThink( CurTime() + 0.1 )

	return true
end

function ENT:OnRemove()
	self:StopWheelEffects()
end

function ENT:CalcWheelSlip()
	local Base = self:GetBase()

	if not IsValid( Base ) then return end

	local Vel = self:GetVelocity()
	local VelLength = Vel:Length()

	local rpmTheoretical = self:VelToRPM( VelLength )
	local rpm = math.abs( self:GetRPM() )

	self._WheelSlip = math.max( rpm - rpmTheoretical - 80, 0 ) ^ 2 + math.max( math.abs( Base:VectorSplitNormal( self:GetForward(), Vel * 4 ) ) - VelLength, 0 )
	self._WheelSkid = VelLength + self._WheelSlip
end

function ENT:GetSlip()
	return (self._WheelSlip or 0)
end

function ENT:GetSkid()
	return (self._WheelSkid or 0)
end

--PATH addons/__main/lua/entities/m9k_ammo_ar2/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"
ENT.PrintName		= "Assault Ammo"
ENT.Category		= "M9K Ammunition"

ENT.Spawnable		= true
ENT.AdminOnly = false
ENT.DoNotDuplicate = true

if SERVER then

AddCSLuaFile("shared.lua")

function ENT:SpawnFunction(ply, tr)

	if (!tr.Hit) then return end
	
	local SpawnPos = tr.HitPos + tr.HitNormal * 16
	
	local ent = ents.Create("m9k_ammo_ar2")
	
	ent:SetPos(SpawnPos)
	ent:Spawn()
	ent:Activate()
	ent.Planted = false
	
	return ent
end


/*---------------------------------------------------------
   Name: Initialize
---------------------------------------------------------*/
function ENT:Initialize()

	local model = ("models/Items/BoxMRounds.mdl")
	
	self.Entity:SetModel(model)
	
	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:DrawShadow(false)
	
	self.Entity:SetCollisionGroup(COLLISION_GROUP_WEAPON)
	
	local phys = self.Entity:GetPhysicsObject()
	
	if (phys:IsValid()) then
		phys:Wake()
	end

	self.Entity:SetUseType(SIMPLE_USE)
end


/*---------------------------------------------------------
   Name: PhysicsCollide
---------------------------------------------------------*/
function ENT:PhysicsCollide(data, physobj)
	
	// Play sound on bounce
	if (data.Speed > 80 and data.DeltaTime > 0.2) then
		self.Entity:EmitSound("Default.ImpactSoft")
	end
end

/*---------------------------------------------------------
   Name: OnTakeDamage
---------------------------------------------------------*/
function ENT:OnTakeDamage(dmginfo)

	if dmginfo:GetAttacker():GetClass() == "m9k_ammo_explosion" then return end
	
	self.Entity:TakePhysicsDamage(dmginfo)
	if GetConVar("M9KAmmoDetonation") == nil then return end
	if not (GetConVar("M9KAmmoDetonation"):GetBool()) then return end
	blaster = dmginfo:GetAttacker()
	pos = self.Entity:GetPos()+Vector(0,0,10)
	
	dice = math.random(1,5)

	if dmginfo:GetDamage() >75 or dice == 1 then
		self.Entity:Remove()
	
		local effectdata = EffectData()
		effectdata:SetOrigin(self.Entity:GetPos())
		util.Effect("ThumperDust", effectdata)
		util.Effect("Explosion", effectdata)
	
		timer.Simple(.01, function()
		
			for i=1, 100 do
			
			ouchies = {}
			ouchies.start = pos
			ouchies.endpos = pos + Vector(math.Rand(-1,1), math.Rand(-1,1), math.Rand(0,1)) * 64000
			ouchies = util.TraceLine(ouchies)
			
			if ouchies.Hit and not ouchies.HitSky then 
				util.Decal("Impact.Concrete", ouchies.HitPos + ouchies.HitNormal, ouchies.HitPos - ouchies.HitNormal )//and ouchies.Entity then
				ouchies.Entity:TakeDamage(30 * math.Rand(.85,1.15), blaster, self.Entity)
			end
			end
		end)
	end	

end


/*---------------------------------------------------------
   Name: Use
---------------------------------------------------------*/
function ENT:Use(activator, caller)

	
	if (activator:IsPlayer()) and not self.Planted then
		// Give the collecting player some free health
		activator:GiveAmmo(100, "ar2")
		self.Entity:Remove()
	end
end

end

if CLIENT then

/*---------------------------------------------------------
   Name: Initialize
---------------------------------------------------------*/
function ENT:Initialize()
end

/*---------------------------------------------------------
   Name: DrawPre
---------------------------------------------------------*/
function ENT:Draw()
	
	self.Entity:DrawModel()
	
	local ledcolor = Color(230, 45, 45, 255)

  	local TargetPos = self.Entity:GetPos() + (self.Entity:GetUp() * 13.3) + (self.Entity:GetRight() * 2) + (self.Entity:GetForward() * 1.5)

	local FixAngles = self.Entity:GetAngles()
	local FixRotation = Vector(90, 90, 90)
	
	FixAngles:RotateAroundAxis(FixAngles:Right(), FixRotation.x)
	FixAngles:RotateAroundAxis(FixAngles:Up(), FixRotation.y)
	FixAngles:RotateAroundAxis(FixAngles:Forward(), FixRotation.z)

	self.Text = "Assault Rifle Ammo"
	
	cam.Start3D2D(TargetPos, FixAngles, .07)
		draw.SimpleText(self.Text, "DermaLarge", 31, -22, ledcolor, 1, 1)
	cam.End3D2D()
end

end
--PATH gamemodes/darkrp/entities/entities/microwave/cl_init.lua:

-----------------------------------------------------
include('shared.lua')
local LocalPlayer = LocalPlayer
local Color = Color
local cam = cam
local draw = draw
local Angle = Angle
local Vector = Vector
local CurTime = CurTime

function ENT:Draw()
	self:DrawModel()
	local owner = self:Getowning_ent()
	owner = (IsValid(owner) and owner:Name()) or 'Unknown'
	local pos = self:GetPos()
	local ang = self:GetAngles()
	local mypos = LocalPlayer():GetPos()
	local dist = pos:Distance(mypos)
	if dist > 500 or (mypos - mypos):DotProduct(LocalPlayer():GetAimVector()) < 0 then return end
	-- fancy math says we dont need to draw
	ang:RotateAroundAxis(ang:Forward(), 90)
	local TextAng = ang
	Color(255,255,255).a = 500 - dist
	Color(0,0,0).a = 500 - dist
	TextAng:RotateAroundAxis(TextAng:Right(), math.sin(CurTime() * math.pi) * -45)
	cam.Start3D2D(pos, ang, 0.070)
	draw.SimpleTextOutlined('Мікрохвильовка', 'Roboto_50', 0, -450, Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, Color(0,0,0))
	draw.SimpleTextOutlined('Ціна: $' .. self:Getprice(), 'Roboto_50', 0, -450, Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 1, Color(0,0,0))
	cam.End3D2D()
	ang:RotateAroundAxis(ang:Right(), 180)
	cam.Start3D2D(pos, ang, 0.070)
	draw.SimpleTextOutlined('Мікрохвильовка', 'Roboto_50', 0, -450, Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, Color(0,0,0))
	draw.SimpleTextOutlined('Ціна: $' .. self:Getprice(), 'Roboto_50', 0, -450, Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 1, Color(0,0,0))
	cam.End3D2D()
end
--PATH addons/_pcasino/lua/entities/pcasino_chair/cl_init.lua:
include("shared.lua")

function ENT:PostData()
end

--PATH addons/_pcasino/lua/entities/pcasino_sign_interior_standing/cl_init.lua:
include("shared.lua")

function ENT:PostData()
end

local draw_simpletext = draw.SimpleText
function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 1000000 then return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end

	if not self.data then return end

	local pos = self:GetPos()
	local ang = self:GetAngles()
	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), -90)

	cam.Start3D2D(pos + (self:GetUp() * 26) + (self:GetForward() * 2.4) + (self:GetRight() * 7.1), ang, 0.05)
			PerfectCasino.UI.WrapText(self.data.general.text, 15, "pCasino.Title.Static", 140, 100, color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()

	ang:RotateAroundAxis(ang:Right(), 180)

	cam.Start3D2D(pos + (self:GetUp() * 26) + (self:GetForward() * -2.4) + (self:GetRight() * -7.1), ang, 0.05)
			PerfectCasino.UI.WrapText(self.data.general.text, 15, "pCasino.Title.Static", 140, 100, color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()
end
--PATH addons/_avatar/lua/entities/proj_sokka_boomerang.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Sokka Boomerang"
ENT.Category = "Entity"
ENT.Spawnable = false
ENT.AdminOnly = true
ENT.DoNotDuplicate = false
if SERVER then
	AddCSLuaFile()
	function ENT:Initialize()
		self:SetModel( "models/avatar/sokka_boomerang.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:DrawShadow( false )
		self:SetCollisionGroup( COLLISION_GROUP_INTERACTIVE_DEBRIS )
		self:SetUseType( SIMPLE_USE )
		self.CorrectOurPath = false
		local phys = self:GetPhysicsObject()
		if IsValid( phys ) then
			phys:Wake()
			phys:SetMaterial( "gm_ps_metaltire" )
			phys:AddGameFlag( FVPHYSICS_DMG_SLICE )
			phys:EnableDrag( false )
		end

		self:StartMotionController()
	end

	function ENT:OnTakeDamage( damage )
		self:TakePhysicsDamage( damage )
	end

	function ENT:GetHeadPos( ent )
		local model = ent:GetModel() or ""
		if model:find( "crow" ) or model:find( "seagull" ) or model:find( "pigeon" ) then
			return ent:LocalToWorld( ent:OBBCenter() + Vector( 0, 0, -5 ) )
		elseif ent:GetAttachment( ent:LookupAttachment( "eyes" ) ) ~= nil then
			return ent:GetAttachment( ent:LookupAttachment( "eyes" ) ).Pos
		else
			return ent:LocalToWorld( ent:OBBCenter() )
		end
	end

	function ENT:Think()
		if self.CorrectOurPath ~= true then
			local srcpos = self:GetPos()
			local vel = self:GetVelocity()
			local ownr = self:GetPhysicsAttacker( 5 )
			for _, v in ipairs( ents.FindAlongRay( srcpos, srcpos + vel * 8000, Vector( -90, -90, -90 ), Vector( 90, 90, 90 ) ) ) do
				if v ~= ownr and IsValid( v ) and not v:IsWeapon() then
					local targ = self:GetHeadPos( v )
					if ( v:IsPlayer() or v:IsNPC() ) and v:Health() ~= nil and v:Health() > 0 then
						local phys = self:GetPhysicsObject()
						if not IsValid(phys) then continue end
						phys:SetVelocity( ( ( targ + vector_up * 10 + v:GetVelocity() / 3 ) - self:GetPos() ):GetNormalized() * 2500 )
					end
				end
			end

			self.CorrectOurPath = true
		end
	end

	function ENT:Use( ply )
		if ply:IsPlayer() and not ply:HasWeapon( "weapon_sokka_boomerang" ) then
			ply:Give( "weapon_sokka_boomerang" )
			self:Remove()
		elseif ply:IsPlayer() then
			if self:IsPlayerHolding() then return end
			ply:PickupObject( self )
		end
	end

	function ENT:StartTouch( v )
		if self:GetSolidFlags() == 136 and v:IsPlayer() and not v:HasWeapon( "weapon_sokka_boomerang" ) then
			timer.Simple( 0, function() v:Give( "weapon_sokka_boomerang" ) end )
			self:Remove()
		end
	end

	function ENT:PhysicsCollide( data )
		if data.DeltaTime > 0.2 then
			if data.Speed > 250 then
				if data.Speed > 650 then
					self:EmitSound( "Weapon_Crowbar.Melee_HitWorld" )
					if not IsValid( data.HitEntity ) then
						local effect = EffectData()
						effect:SetOrigin( data.HitPos )
						util.Effect( "cball_bounce", effect )
					end
				else
					self:EmitSound( "physics/metal/metal_solid_impact_hard" .. math.random( 1, 2 ) .. ".wav", 75, math.random( 90, 110 ), 0.5 )
				end

				local ownr = self:GetPhysicsAttacker( 5 )
				if not IsValid( ownr ) then ownr = self end
				if IsValid( data.HitEntity ) then
					if ownr == data.HitEntity then
						timer.Simple( 0, function()
							if not IsValid( ownr ) then return end
							ownr:Give( "weapon_sokka_boomerang" )
						end )

						self:Remove()
						return
					else
						local vel = data.OurOldVelocity * 2
						data.HitEntity:SetVelocity( vel / 4 )
						local dmginfo = DamageInfo()
						dmginfo:SetAttacker( ownr )
						dmginfo:SetInflictor( self )
						dmginfo:SetDamage( 50 )
						dmginfo:SetDamageType( 5 )
						dmginfo:SetDamageForce( vel * 2 )
						data.HitEntity:TakeDamageInfo( dmginfo )
						if data.OurNewVelocity:Length() > 100 and IsValid( ownr ) and ownr ~= self then
							data.PhysObject:SetVelocity( ( ( self:GetHeadPos( ownr ) + vector_up * 10 + ownr:GetVelocity() / 3 ) - self:GetPos() ):GetNormalized() * 2000 )
							timer.Simple( 0, function()
								if not IsValid( self ) then return end
								self:SetTrigger( true )
								self:UseTriggerBounds( true, 8 )
							end )
						end
					end
				end
			else
				self:EmitSound( "physics/metal/metal_solid_impact_soft" .. math.random( 1, 3 ) .. ".wav", 75, math.random( 90, 110 ), 0.2 )
			end
		end
	end
end

if CLIENT then
	function ENT:Draw()
		self:DrawModel()
	end
end
--PATH addons/__main/lua/entities/savav_acid/shared.lua:
ENT.Base = "base_anim"
ENT.Type = "anim"

ENT.PrintName		= "Acid"
ENT.Author			= "SaVav"
ENT.Category 		= "SaVav's trash"
ENT.Contact    		= ""
ENT.Purpose 		= "take it"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true


--PATH gamemodes/darkrp/entities/entities/spawned_money/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "[Money] Кавун"
ENT.Author = "Jerivssss"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "RP"

function ENT:SetupDataTables()
	self:NetworkVar('Int',0,'GetMoney')
end
--PATH addons/____sprinter/lua/entities/sprinter_rack/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
	
	if !sPrinter then return end

	if sPrinter.config["logo"]["sprinter_rack"].enabled then
		sPrinter.drawLogo(self, sPrinter.config["logo"]["sprinter_rack"].id)
	end

	local opacity = sPrinter.fadeByDistance(self)
	if opacity > 0 then
		sPrinter.drawRackScreen(self, opacity)
	end
end

function ENT:OnRemove()
	if IsValid(self.rackScreen) then
		self.rackScreen:Remove()
	end
end

local slots = {
	[1] = 70.5,
	[2] = 58.56,
	[3] = 46.6,
	[4] = 34.56
}

local sides = {
	[1] = -21.8,
	[2] = 34.3
}

function ENT:AttemptUnlock()
	net.Start("sP:Networking")
	net.WriteEntity(self)
	net.WriteUInt(5,3)
	net.WriteUInt(0,2)
	net.WriteBool(false)
	net.SendToServer()
end

function ENT:HackHandler(success)
	net.Start("sP:Networking")
	net.WriteEntity(self)
	net.WriteUInt(5,3)
	net.WriteUInt(2,2)
	net.WriteBool(!success)
	net.SendToServer()
end

function ENT:drawingOverlay(type)
	return self:GetLocked() or self.overlayDrawn and type ~= "topbar"
end

local cache = {}
local cooldown = {}

function ENT:hasPrinter(slot)
	if cooldown[self] and cooldown[self][slot] and CurTime() - cooldown[self][slot] < .3 then return cache[self] and cache[self][slot] end

	cooldown[self] = cooldown[self] or {}
	cooldown[self][slot] = CurTime()

	local side = #tostring(slot * 0.5) > #tostring(slot) and 1 or 2
	local pos = self:LocalToWorld(Vector(sides[side], -2, slots[math.ceil(slot * 0.5)]))
	posetion = pos
	local printer

	for k,v in ipairs(ents.FindInSphere(pos, 3)) do
		if v.Base == "sprinter_base" then
			printer = v
		break end
	end

	cache[self] = cache[self] or {}
	cache[self][slot] = printer

	return printer
end

function ENT:GetUpgradeAllPrice()
	local price = 0

	for i = 1,8 do
		local printer = self:hasPrinter(i)
		if !IsValid(printer) then continue end

		for k, v in ipairs(printer.data.upgrades) do
			price = price + printer:GetFullUpgradePrice(k)
		end
	end

	return price
end
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_battery/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "[UWeed] Battery"
ENT.Author = "Owain Owjo"
ENT.Category = "UWeed"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = true
ENT.AdminSpawnable = true

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "owning_ent")
end
--PATH addons/_drones/lua/effects/dronesrewrite_explosionms.lua:
AddCSLuaFile()

function EFFECT:Init(data)
	self.Start = data:GetOrigin()
	self.size = 320000

	self.Emitter = ParticleEmitter(self.Start)

	local p = self.Emitter:Add("particle/warp3_warp_noz", self.Start)

	p:SetDieTime(0.3)
	p:SetStartSize(200)
	
	for i = 1, 200 do
		local vec = VectorRand()
		local p = self.Emitter:Add("effects/fleck_cement" .. math.random(1, 2), self.Start)

		p:SetDieTime(math.random(8, 15))
		p:SetStartAlpha(255)
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(60, 90))
		p:SetRoll(math.Rand(-10, 10))
		p:SetRollDelta(math.Rand(-10, 10))
		--p:SetEndSize(0)		
		p:SetVelocity(vec * 5000)
		p:SetAirResistance(10)
		p:SetGravity(Vector(0, 0, math.random(-500, -200)))
		p:SetColor(0, 0, 0)
	end

	for i = 1, 180 do
		local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(1, 3), self.Start)

		p:SetDieTime(4)
		p:SetStartAlpha(255)
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(1000, 2000))
		p:SetRoll(math.Rand(-10, 10))
		p:SetRollDelta(math.Rand(-5, 5))
		p:SetEndSize(math.random(7000, 8000))		

		local vec = Angle(0, i * 2, 0)
		p:SetVelocity(vec:Forward() * math.random(7000, 8000))
		p:SetColor(0, 0, 0)
	end

	for i = 6, math.random(5, 15) do
		local vec = VectorRand()

		for a = 1, 15 do
			local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(1, 3), self.Start + vec * a * 300)

			p:SetDieTime(math.Rand(8, 14))
			p:SetStartAlpha(math.random(150, 200))
			p:SetEndAlpha(0)
			p:SetStartSize(300)
			p:SetRoll(math.Rand(-10, 10))
			p:SetRollDelta(math.Rand(-0.2, 0.2))
			p:SetEndSize(2000)		
			p:SetGravity(Vector(0, 0, -a * math.Rand(1, 2)))
			p:SetVelocity(VectorRand() * 100)
			p:SetAirResistance(a)
			p:SetCollide(true)
			p:SetColor(10, 10, 5)
		end
	end
	
	self.Emitter:Finish()
end

function EFFECT:Think()
	self.size = self.size - 5000

	return self.size > 0
end

function EFFECT:Render()
	render.SetMaterial(Material("sprites/light_ignorez"))
	render.DrawSprite(self.Start, self.size * 2, self.size, Color(255, 255, 255, 255))
end






--PATH addons/_drones/lua/effects/dronesrewrite_muzzleflashblaster3.lua:
AddCSLuaFile()

function EFFECT:Init(data)
	self.Start = data:GetOrigin()
	self.Forward = data:GetNormal()

	self.Emitter = ParticleEmitter(self.Start)

	local dlight = DynamicLight(self:EntIndex())
	if dlight then
		dlight.pos = self.Start
		dlight.r = 0
		dlight.g = 255
		dlight.b = 0
		dlight.brightness = 1
		dlight.Decay = 1
		dlight.Size = math.random(150, 300)
		dlight.DieTime = CurTime()
	end

	local p = self.Emitter:Add("sprites/heatwave", self.Start - self.Forward * 2)
	p:SetVelocity(120 * self.Forward + 20 * VectorRand() * 2)
	p:SetGravity(Vector(0, 0, 100))
	p:SetAirResistance(160)
	p:SetDieTime(math.Rand(0.1, 0.15))
	p:SetStartSize(30)
	p:SetEndSize(0)
	p:SetRoll(math.Rand(180, 480))
	p:SetRollDelta(math.Rand(-1, 1))

	for a = 1, 12 do
		for i = 1, 4 do
			local p = self.Emitter:Add("sprites/light_glow02_add", self.Start + i * 4 * self.Forward)

			p:SetAirResistance(200)
			p:SetVelocity(6 * VectorRand())
			p:SetDieTime(math.Rand(0.05, 0.15))
			p:SetStartAlpha(155)
			p:SetStartSize(0)
			p:SetEndSize(34 - i * 6)
			p:SetRoll(math.Rand(180, 480))
			p:SetRollDelta(math.Rand(-1, 1))
			p:SetColor(0, 255, 0)	
		end
	end
	
	for i = 1, 4 do
		local p = self.Emitter:Add("sprites/light_glow02_add", self.Start + i * 4 * self.Forward)

		p:SetAirResistance(200)
		p:SetVelocity(6 * VectorRand())
		p:SetDieTime(math.Rand(0.05, 0.15))
		p:SetStartAlpha(155)
		p:SetStartSize(0)
		p:SetEndSize(34 - i * 6)
		p:SetRoll(math.Rand(180, 480))
		p:SetRollDelta(math.Rand(-1, 1))
		p:SetColor(255, 255, 255)	
	end
	
	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end





--PATH addons/_drones/lua/effects/dronesrewrite_skulltouch.lua:
function EFFECT:Init(data)		
	self.Start = data:GetOrigin()
	
	self.Emitter = ParticleEmitter(self.Start)
	
	for i = 1, 50 do
		local p = self.Emitter:Add("particle/particle_glow_04_additive", self.Start)
			
		p:SetVelocity(VectorRand() * 600)
		p:SetAirResistance(200)
		p:SetDieTime(2)
		p:SetStartAlpha(255)
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(1, 10))
		p:SetEndSize(math.random(10, 30))	
		p:SetRollDelta(math.Rand(-2, 2))
		p:SetCollide(true)
		p:SetColor(255, 0, 0)
	end
	
	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH addons/__main/lua/effects/effect_penetration_trace/init.lua:
EFFECT.Mat = Material( "effects/spark" )
function EFFECT:Init( data )
	self.StartPos = data:GetStart()
	self.EndPos = data:GetOrigin()
	self.Dir = self.EndPos - self.StartPos
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )
	self.TracerTime = 0.4
	self.DieTime = CurTime() + self.TracerTime
end

function EFFECT:Think()
	if CurTime() > self.DieTime then return false end
	return true
end

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 )
	render.SetMaterial( self.Mat )
	local color = Color( 255, 255, 255, 255 * fDelta )
	render.DrawBeam( self.StartPos, self.EndPos, 8 * fDelta, 1, 0, color )
end
--PATH addons/_drones/lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64

function EFFECT:GetTracerOrigin( data )
if ( CLIENT ) then
	local start = data:GetStart()

	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity()
		
		if( not IsValid( entity ) ) then return start end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			local pl = entity:GetOwner()
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel()
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm
				else 					
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel )
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() )
		if( attachment ) then
			start = attachment.Pos
		end

	end
	
	return start
end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed

end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH addons/lvs_base-main/lua/effects/lvs_bullet_impact_explosive.lua:

EFFECT.GlowMat = Material( "sprites/light_glow02_add" )
EFFECT.SmokeMat = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.DustMat = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

EFFECT.DecalMat = Material( util.DecalMaterial( "Scorch" ) )

function EFFECT:Init( data )
	self.Dir = data:GetNormal()
	self.Pos = data:GetOrigin()

	self.LifeTime = 0.35
	self.DieTime = CurTime() + self.LifeTime

	local scale = data:GetMagnitude() * 0.5

	self.Scale = 3 * scale

	local emitter = ParticleEmitter( self.Pos, false )

	local VecCol = (render.GetLightColor( self.Pos + self.Dir ) * 0.5 + Vector(0.1,0.09,0.075)) * 255

	local DieTime = math.Rand(0.8,1.6)

	local traceSky = util.TraceLine( {
		start = self.Pos,
		endpos = self.Pos + Vector(0,0,50000),
		filter = self,
	} )

	local traceWater = util.TraceLine( {
		start = traceSky.HitPos,
		endpos = self.Pos - Vector(0,0,100),
		filter = self,
		mask = MASK_WATER,
	} )

	if traceWater.Hit then
		local effectdata = EffectData()
		effectdata:SetOrigin( traceWater.HitPos )
		effectdata:SetScale( 100 )
		effectdata:SetFlags( 2 )
		util.Effect( "WaterSplash", effectdata, true, true )
	end

	local Pos = self.Pos
	local Dist = (traceWater.HitPos - Pos):Length()
	local ply = LocalPlayer():GetViewEntity()

	if not IsValid( ply ) then return end

	local delay = (Pos - ply:GetPos()):Length() / 13503.9

	if traceWater.Hit and Dist > 150 then
		timer.Simple( delay, function()
			local effectdata = EffectData()
			effectdata:SetOrigin( Pos )
			util.Effect( "WaterSurfaceExplosion", effectdata, true, true )
		end )

		if Dist > 300 then return end
	else
		timer.Simple( delay, function()
			sound.Play( "LVS.BULLET_EXPLOSION", Pos )
			sound.Play( "LVS.BULLET_EXPLOSION_DYNAMIC", Pos )
		end )

		local trace = util.TraceLine( {
			start = self.Pos + Vector(0,0,100),
			endpos = self.Pos - Vector(0,0,100),
			mask = MASK_SOLID_BRUSHONLY,
		} )

		if trace.Hit and not trace.HitNonWorld then
			util.DecalEx( self.DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), self.Scale * 2.5, self.Scale * 2.5 )
		end
	end

	if self.Dir.z > 0.8 then
		for i = 1, 10 do
			for n = 0,6 do
				local particle = emitter:Add( self.DustMat[ math.random(1,#self.DustMat) ], self.Pos )

				if not particle then continue end

				particle:SetVelocity( (self.Dir * 50 * i + VectorRand() * 25) * self.Scale )
				particle:SetDieTime( (i / 8) * DieTime )
				particle:SetAirResistance( 10 ) 
				particle:SetStartAlpha( 255 )
				particle:SetStartSize( 10 * self.Scale )
				particle:SetEndSize( 20 * i * self.Scale )
				particle:SetRollDelta( math.Rand(-1,1) )
				particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
				particle:SetGravity( Vector(0,0,-600) * self.Scale )
				particle:SetCollide( false )
			end
		end

		for i = 1, 10 do
			local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ], self.Pos )

			if not particle then continue end

			particle:SetVelocity( (self.Dir * 50 * i + VectorRand() * 40) * self.Scale )
			particle:SetDieTime( (i / 8) * DieTime )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 * self.Scale )
			particle:SetEndSize( 20 * i * self.Scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-600) * self.Scale )
			particle:SetCollide( false )
		end
	end

	for i = 1,24 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ] , self.Pos )
		
		if not particle then continue end

		local ang = i * 15
		local X = math.cos( math.rad(ang) )
		local Y = math.sin( math.rad(ang) )

		local Vel = Vector(X,Y,0) * math.Rand(800,1200)
		Vel:Rotate( self.Dir:Angle() + Angle(90,0,0) )

		particle:SetVelocity( Vel * self.Scale )
		particle:SetDieTime( math.Rand(1,3) )
		particle:SetAirResistance( 600 ) 
		particle:SetStartAlpha( 100 )
		particle:SetStartSize( 40 * self.Scale )
		particle:SetEndSize( 140 * self.Scale )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
		particle:SetGravity( Vector(0,0,60) * self.Scale )
		particle:SetCollide( true )
	end

	for i = 0, 15 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1, #self.SmokeMat ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 1000 * scale )
			particle:SetDieTime( math.Rand(2,3) )
			particle:SetAirResistance( 200 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 200 * scale )
			particle:SetEndSize( 600 * scale )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector( 0, 0, -600 ) * scale )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 800 * scale )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( 120 * scale )
		particle:SetEndSize( 20 * scale )
		particle:SetColor( 255, 255, 255 )
		particle:SetGravity( self.Dir * 2500 )
		particle:SetRollDelta( math.Rand(-5,5) )
		particle:SetAirResistance( 300 )
	end

	for i = 0, 5 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )

		if not particle then continue end

		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetColor( 255, 255, 255 )
		particle:SetGravity( Vector(0,0,0) )

		local size = math.Rand(8, 24) * scale
		particle:SetEndSize( size )
		particle:SetStartSize( size )

		particle:SetStartLength( 400 * scale )
		particle:SetEndLength( size )

		particle:SetDieTime( math.Rand(0.1,0.2) )
		particle:SetVelocity( (self.Dir * 4000 + VectorRand() * 2000) * scale )

		particle:SetAirResistance( 0 )
	end

	for i = 0, 40 do
		local particle = emitter:Add( "effects/fire_embers"..math.random(1,2), self.Pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 800 * scale )
		particle:SetDieTime( math.Rand(0.4,0.6) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( 40 * scale )
		particle:SetEndSize( 0 )
		particle:SetColor( 255, 255, 255 )
		particle:SetGravity( Vector(0,0,600) )
		particle:SetRollDelta( math.Rand(-8,8) )
		particle:SetAirResistance( 300 )
	end

	emitter:Finish()
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )
	
	if not IsValid( emitter ) then return end

	for i = 0, 40 do
		local particle = emitter:Add( "particles/flamelet"..math.random(1,5), pos )

		if particle then
			particle:SetVelocity( VectorRand() * 1500 * scale )
			particle:SetDieTime( 0.2 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 20 * scale )
			particle:SetEndSize( math.Rand(180,240) * scale )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	if not self.Scale then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	local R1 = 800 * self.Scale
	render.SetMaterial( self.GlowMat )
	render.DrawSprite( self.Pos, R1 * Scale, R1 * Scale, Color( 255, 200, 150, 255) )
end

--PATH addons/lvs_cars_3027255911/lua/effects/lvs_carexhaust_backfire.lua:

EFFECT.SmokeMat = {
	[1] = Material( "particle/smokesprites_0001" ),
	[2] = Material( "particle/smokesprites_0002" ),
	[3] = Material( "particle/smokesprites_0003" ),
	[4] = Material( "particle/smokesprites_0004" ),
	[5] = Material( "particle/smokesprites_0005" ),
	[6] = Material( "particle/smokesprites_0006" ),
	[7] = Material( "particle/smokesprites_0007" ),
	[8] = Material( "particle/smokesprites_0008" ),
	[9] = Material( "particle/smokesprites_0009" ),
	[10] = Material( "particle/smokesprites_0010" ),
	[11] = Material( "particle/smokesprites_0011" ),
	[12] = Material( "particle/smokesprites_0012" ),
	[13] = Material( "particle/smokesprites_0013" ),
	[14] = Material( "particle/smokesprites_0014" ),
	[15] = Material( "particle/smokesprites_0015" ),
	[16] = Material( "particle/smokesprites_0016" ),
}

EFFECT.GlowMat = Material( "sprites/light_glow02_add" )
EFFECT.FireMat = Material( "effects/muzzleflash2" )

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Ang = data:GetAngles()
	self.Ent = data:GetEntity()

	self.LifeTime = 0.5
	self.DieTime = CurTime() + self.LifeTime

	if not IsValid( self.Ent ) then return end

	self.Mat = self.SmokeMat[ math.random(1,#self.SmokeMat) ]

	local Pos = self.Ent:LocalToWorld( self.Pos )

	self:SetPos( Pos )

	local dlight = DynamicLight( self.Ent:EntIndex() * math.random(1,4), true )
	if dlight then
		dlight.pos = Pos
		dlight.r = 255
		dlight.g = 180
		dlight.b = 100
		dlight.brightness = 1
		dlight.Decay = 2000
		dlight.Size = 300
		dlight.DieTime = CurTime() + 0.2
	end

	sound.Play( "lvs/vehicles/generic/exhaust_backfire"..math.random(1,3)..".ogg", Pos, 75, 100, 1 )

	local vel = self.Ent:GetVelocity()
	local dir = self.Ent:LocalToWorldAngles( self.Ang ):Forward()
	local emitter = ParticleEmitter( Pos, false )

	if emitter then
		for i = 0, 12 do
			local particle = emitter:Add( "sprites/rico1", Pos )

			if not particle then continue end

			particle:SetVelocity( vel + dir * 100 + VectorRand() * 100 )
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetStartAlpha( 0 )
			particle:SetEndAlpha( 25 )
			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 225, 150 )
			particle:SetGravity( Vector(0,0,-600) )
		end

		emitter:Finish()
	end
end

function EFFECT:Think()
	if not IsValid( self.Ent ) then return false end

	if self.DieTime < CurTime() then return false end

	self:SetPos( self.Ent:LocalToWorld( self.Pos ) )

	return true
end


function EFFECT:Render()
	if not IsValid( self.Ent ) or not self.Pos then return end

	self:RenderSmoke()
end

function EFFECT:RenderSmoke()
	if not self.Pos or not self.Ang then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	local InvScale = 1 - Scale

	local Pos = self.Ent:LocalToWorld( self.Pos )
	local Ang = self.Ent:LocalToWorldAngles( self.Ang )

	local FlameSize = 40 * Scale ^ 2
	render.SetMaterial( self.FireMat )
	for i = 1, 4 do
		render.DrawSprite( Pos + Ang:Forward() * InvScale * 5 + VectorRand() * 2, FlameSize, FlameSize, Color( 255, 255, 255, 255 * InvScale) )
	end

	local GlowSize = 80 * Scale ^ 2
	render.SetMaterial( self.GlowMat )
	render.DrawSprite( Pos + Ang:Forward() * InvScale * 10, GlowSize, GlowSize, Color(255* InvScale, 150* InvScale,75* InvScale,255* InvScale) )

	if not self.Mat then return end

	local C = 40
	local Size = (20 + 50 * InvScale)

	render.SetMaterial( self.Mat )
	render.DrawSprite( Pos + Ang:Forward() * InvScale * 40, Size, Size, Color( C, C, C, 255 * Scale) )
end


--PATH addons/lvs_base-main/lua/effects/lvs_explosion.lua:
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.DecalMat = Material( util.DecalMaterial( "Scorch" ) )

function EFFECT:Init( data )
	local Pos = data:GetOrigin()

	self.DieTime = CurTime() + 1

	self:Explosion( Pos, 2 )

	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		timer.Simple( delay, function()
			sound.Play( "LVS.DYNAMIC_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.DYNAMIC_EXPLOSION", Pos )
	end
	
	for i = 1, 20 do
		timer.Simple(math.Rand(0,0.01) * i, function()
			if IsValid( self ) then
				local p = Pos + VectorRand() * 10 * i
				
				self:Explosion( p, math.Rand(0.5,0.8) )
			end
		end)
	end

	self:Debris( Pos )

	local traceSky = util.TraceLine( {
		start = Pos,
		endpos = Pos + Vector(0,0,50000),
		mask = MASK_SOLID_BRUSHONLY,
	} )

	local traceWater = util.TraceLine( {
		start = traceSky.HitPos,
		endpos = Pos - Vector(0,0,100),
		mask = MASK_WATER,
	} )

	if traceWater.Hit then
		local effectdata = EffectData()
		effectdata:SetOrigin( traceWater.HitPos )
		effectdata:SetScale( 100 )
		effectdata:SetFlags( 2 )
		util.Effect( "WaterSplash", effectdata, true, true )
	else
		local trace = util.TraceLine( {
			start = Pos + Vector(0,0,100),
			endpos = Pos - Vector(0,0,100),
			mask = MASK_SOLID_BRUSHONLY,
		} )

		if trace.Hit and not trace.HitNonWorld then
			for i = 1, 10 do
				local StartPos = trace.HitPos + Vector(math.random(-25,25) * i,math.random(-25,25) * i,0)
				local decalTrace = util.TraceLine( {
					start = StartPos + Vector(0,0,100),
					endpos = StartPos - Vector(0,0,100),
					mask = MASK_SOLID_BRUSHONLY,
				} )

				util.DecalEx( self.DecalMat, trace.Entity, decalTrace.HitPos + decalTrace.HitNormal, decalTrace.HitNormal, Color(255,255,255,255), math.Rand(2,3), math.Rand(2,3) )
			end
		end
	end
end

function EFFECT:Debris( pos )
	local emitter = ParticleEmitter( pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,60 do
		local particle = emitter:Add( "effects/fleck_tile"..math.random(1,2), pos )
		local vel = VectorRand() * math.Rand(200,600)
		vel.z = math.Rand(200,600)
		if particle then
			particle:SetVelocity( vel )
			particle:SetDieTime( math.Rand(10,15) )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( 5 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,0 )
			particle:SetGravity( Vector( 0, 0, -600 ) )
			particle:SetCollide( true )
			particle:SetBounce( 0.3 )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )
	
	if not IsValid( emitter ) then return end

	for i = 0,10 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )

		if particle then
			particle:SetVelocity( VectorRand() * 1500 * scale )
			particle:SetDieTime( math.Rand(0.75,1.5) * scale )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(60,120) * scale )
			particle:SetEndSize( math.Rand(220,320) * scale )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 40,40,40 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )

		if particle then
			particle:SetVelocity( VectorRand() * 1500 * scale )
			particle:SetDieTime( 0.2 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 20 * scale )
			particle:SetEndSize( math.Rand(180,240) * scale )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local dlight = DynamicLight( math.random(0,9999) )
	if dlight then
		dlight.pos = pos
		dlight.r = 255
		dlight.g = 180
		dlight.b = 100
		dlight.brightness = 8
		dlight.Decay = 2000
		dlight.Size = 300
		dlight.DieTime = CurTime() + 1
	end
end

function EFFECT:Think()
	if CurTime() < self.DieTime then return true end

	return false
end

function EFFECT:Render()
end

--PATH addons/lvs_base-main/lua/effects/lvs_physics_scrape.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	if not LVS.ShowPhysicsEffects then
		self.LifeTime = 0
		self.DieTime = 0

		return
	end

	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )

	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()
	local Strength = data:GetMagnitude()

	local emitter = ParticleEmitter( Pos, false )

	for i = 0,1 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], Pos )
		
		local vel = VectorRand() * 100 + Dir * 40
		
		if particle then			
			particle:SetVelocity( vel )
			particle:SetDieTime( 1 )
			particle:SetAirResistance( 1000 ) 
			particle:SetStartAlpha( 10 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( 12 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 40, 30, 20 )
			particle:SetGravity( Dir * 50 )
			particle:SetCollide( false )
		end
	end

	for i = 0, 3 do
		local particle = emitter:Add( "effects/spark", Pos )
		
		local vel = VectorRand() * 25 * (1 - Strength) + (VectorRand() * 100 + Dir * 150) * Strength
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( 2 )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )

			particle:SetStartLength( 4 )
			particle:SetEndLength(0)

			particle:SetStartSize( 2 )
			particle:SetEndSize( 0 )

			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 200, 50 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then
		return false
	end

	return true
end

local mat = Material( "sprites/light_glow02_add" )
function EFFECT:Render()
	if not LVS.ShowPhysicsEffects then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( mat )
	render.DrawSprite( self.Pos, 32, 32, Color( 255 * Scale, 175 * Scale, 80 * Scale, 255) ) 
end


--PATH addons/lvs_cars_3027255911/lua/effects/lvs_physics_turretscraping.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()

	local emitter = ParticleEmitter( pos, false )

	for i = 1, 360 do
		if math.random(1,30) ~= 15 then continue end

		local ang = i

		local X = math.cos( math.rad(ang) )
		local Y = math.sin( math.rad(ang) )

		local forward = Vector(X,Y,0)
		forward:Rotate( dir:Angle() + Angle(90,0,0) )

		local spark = emitter:Add("effects/spark", pos + forward * 25 )

		if not spark then continue end

		spark:SetStartAlpha( 255 )
		spark:SetEndAlpha( 0 )
		spark:SetCollide( true )
		spark:SetBounce( math.Rand(0,1) )
		spark:SetColor( 255, 255, 255 )
		spark:SetGravity( Vector(0,0,-600) )
		spark:SetEndLength(0)

		local size = math.Rand(4, 6)
		spark:SetEndSize( size )
		spark:SetStartSize( size )

		spark:SetStartLength( math.Rand(10,20) )
		spark:SetDieTime( math.Rand(0.01, 0.2) )
		spark:SetVelocity( forward * math.random(250,400) + dir * 150 + VectorRand() * 50 )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH addons/lvs_base-main/lua/effects/lvs_tracer_missile.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

EFFECT.MatSmoke = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )

	self.emitter = ParticleEmitter( pos, false )

	self.OldPos = pos
	self.Dir = dir
end

function EFFECT:doFX( pos, curpos )
	if not IsValid( self.emitter ) then return end

	local particle = self.emitter:Add( self.MatSmoke[ math.random(1, #self.MatSmoke ) ], pos )
	if particle then
		particle:SetGravity( Vector(0,0,100) + VectorRand() * 50 ) 
		particle:SetVelocity( -self.Dir * 200  )
		particle:SetAirResistance( 600 ) 
		particle:SetDieTime( math.Rand(1.5,2) )
		particle:SetStartAlpha( 50 )
		particle:SetStartSize( 20 )
		particle:SetEndSize( 60 )
		particle:SetRoll( math.Rand( -1, 1 ) )
		particle:SetRollDelta( math.Rand( -1, 1 ) )
		particle:SetColor(40,40,40)
		particle:SetCollide( false )
	end

	local particle = self.emitter:Add( "particles/flamelet"..math.random(1,5), pos )
	if particle then
		particle:SetVelocity( -self.Dir * math.Rand(250,800) + self.Dir * 1500 )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetAirResistance( 0 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 8 )
		particle:SetEndSize( 1 )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 255,255,255 )
		particle:SetGravity( Vector( 0, 0, 0 ) )
		particle:SetCollide( false )
	end

	local particle = self.emitter:Add( "particles/flamelet"..math.random(1,5), curpos )
	if particle then
		particle:SetVelocity( -self.Dir * 200 + VectorRand() * 50 )
		particle:SetDieTime( 0.25 )
		particle:SetAirResistance( 600 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 6 )
		particle:SetEndSize( 2 )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 255,255,255 )
		particle:SetGravity( Vector( 0, 0, 0 ) )
		particle:SetCollide( false )
	end
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then
		if self.emitter then
			self.emitter:Finish()
		end

		return false
	end

	if not self.emitter then return true end

	local T = CurTime()

	if (self.nextDFX or 0) <= T then
		self.nextDFX = T + 0.02
		
		local bullet = LVS:GetBullet( self.ID )

		local Pos = bullet:GetPos()

		local Sub = self.OldPos - Pos
		local Dist = Sub:Length()
		local Dir = Sub:GetNormalized()

		for i = 0, Dist, 45 do
			local cur_pos = self.OldPos + Dir * i

			self:doFX( cur_pos, Pos )
		end

		self.OldPos = Pos
	end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local pos = bullet:GetPos()

	render.SetMaterial( self.MatSprite )
	render.DrawSprite( pos, 100, 100, Color( 255, 200, 150, 255 ) )
end

--PATH addons/lvs_cars_3027255911/lua/effects/lvs_trailer_explosion.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local pos  = data:GetOrigin()

	local effectdata = EffectData()
		effectdata:SetOrigin( pos )
	util.Effect( "cball_explode", effectdata, true, true )

	local effectdata = EffectData()
		effectdata:SetOrigin( pos )
		effectdata:SetNormal( Vector(0,0,1) )
	util.Effect( "manhacksparks", effectdata, true, true )

	local emitter = ParticleEmitter( pos, false )

	for i = 0,30 do
		local particle = emitter:Add( "effects/fleck_tile"..math.random(1,2), pos )
		local vel = VectorRand() * math.Rand(150,200)
		vel.z = math.Rand(200,250)
		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetDieTime( math.Rand(2,6) )
		particle:SetAirResistance( 10 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 2 )
		particle:SetEndSize( 2 )
		particle:SetRoll( math.Rand(-1,1) * math.pi )
		particle:SetColor( 0,0,0 )
		particle:SetGravity( Vector( 0, 0, -600 ) )
		particle:SetCollide( true )
		particle:SetBounce( 0.3 )
	end

	for i = 0,4 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], pos )
		
		local vel = VectorRand() * 200
		
		if particle then			
			particle:SetVelocity( vel )
			particle:SetDieTime( math.Rand(2.5,5) )
			particle:SetAirResistance( 100 ) 
			particle:SetStartAlpha( 200 )
			particle:SetStartSize( 50 )
			particle:SetEndSize( 200 )
			particle:SetRoll( math.Rand(-5,5) )
			particle:SetColor( 10,10,10 )
			particle:SetGravity( Vector(0,0,20) )
			particle:SetCollide( false )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH addons/____inventory/lua/itemstore/shared.lua:
itemstore.Version = "3.0"
itemstore.About = string.format( [[ItemStore v%s

Authored solely by UselessGhost
http://steamcommunity.com/id/uselessghost
]], itemstore.Version )

MsgC( color_white, "ItemStore", Color( 100, 200, 255 ), " ", itemstore.Version, " ", Color( 200, 200, 200 ), "coded by ", Color( 255, 150, 150 ), "UselessGhost", "\n" )

concommand.Add( "itemstore_about", function()
	MsgC( color_white, itemstore.About )
end )

function itemstore.Log( msg, ... )
	local original = msg
	local params = { ... }

	for k, v in ipairs( params ) do
		local value = tostring( v )

		if IsEntity( v ) then
			if IsValid( v ) then
				if v:IsPlayer() then
					value = v:Name() .. " (" .. v:SteamID() ..")"
				else
					value = v:GetClass()
				end
			else
				value = "(NULL entity)"
			end
		elseif isvector( v ) then
			value = string.format( "{%f, %f, %f}", v.x, v.y, v.z )
		elseif istable( v ) and v.ItemStore then
			value = v:GetName() .. " (" .. v:GetClass() .. ")"
		end

		msg = string.Replace( msg, "{" .. k .. "}", value )
	end

	if itemstore.config.PrintLog then print( msg ) end
	hook.Call( "ItemStoreLog", GAMEMODE, msg, original, ... )
end

itemstore.config = {}

function itemstore.config.Verify( setting, correct_type )
	if type( itemstore.config[ setting ] ) ~= correct_type then
		error( string.format( "[ItemStore] Configuration error: %s is %s, should be %s.", setting, var_type, correct_type ) )
		return false
	end

	return true
end

local status, err = pcall( function()
	include( "itemstore/config.lua" )

	itemstore.config.Verify( "Skin", "string" )
	itemstore.config.Verify( "PickupsGotoBank", "boolean" )
	itemstore.config.Verify( "InvholsterTakesAmmo", "boolean" )
	itemstore.config.Verify( "MaxStack", "number" )
	itemstore.config.Verify( "GamemodeProvider", "string" )
	itemstore.config.Verify( "LimitToJobs", "table" )
	itemstore.config.Verify( "HighlightColours", "table" )
	itemstore.config.Verify( "TradeDistance", "number" )
	itemstore.config.Verify( "MigrateOldData", "boolean" )
	itemstore.config.Verify( "DeathLoot", "boolean" )
	itemstore.config.Verify( "SplitWeaponAmmo", "boolean" )
	itemstore.config.Verify( "TradingEnabled", "boolean" )
	itemstore.config.Verify( "PickupDistance", "number" )
	itemstore.config.Verify( "InventorySizes", "table" )
	itemstore.config.Verify( "BankSizes", "table" )
	itemstore.config.Verify( "AntiDupe", "boolean" )
	itemstore.config.Verify( "SaveOnWrite", "boolean" )
	itemstore.config.Verify( "ContextInventoryPosition", "string" )
	itemstore.config.Verify( "EnableInvholster", "boolean" )
	itemstore.config.Verify( "SaveInterval", "number" )
	itemstore.config.Verify( "ContextInventory", "boolean" )
	itemstore.config.Verify( "DropDistance", "number" )
	itemstore.config.Verify( "TradeCooldown", "number" )
	itemstore.config.Verify( "Colours", "table" )
	itemstore.config.Verify( "DeathLootTimeout", "number" )
	itemstore.config.Verify( "DisabledItems", "table" )
	itemstore.config.Verify( "InvholsterDisabled", "table" )
	itemstore.config.Verify( "HighlightStyle", "string" )
	itemstore.config.Verify( "DataProvider", "string" )
	itemstore.config.Verify( "CustomItems", "table" )
	itemstore.config.Verify( "Verify", "function" )
	itemstore.config.Verify( "IgnoreOwner", "boolean" )
	itemstore.config.Verify( "ChatCommandPrefix", "string" )
	itemstore.config.Verify( "PickupKey", "number" )
	itemstore.config.Verify( "BoxBreakable", "boolean" )
	itemstore.config.Verify( "BoxHealth", "number" )
	itemstore.config.Verify( "Language", "string" )
	itemstore.config.Verify( "UseNewUI", "boolean" )
	itemstore.config.Verify( "LoadDelay", "number" )
	itemstore.config.Verify( "PrintLog", "boolean" )
	itemstore.config.Verify( "VerboseLogging", "boolean" )
	itemstore.config.Verify( "bLogs", "boolean" )
end )

-- remove this if it's here since the player probably is fiddling with the config
hook.Remove( "HUDPaint", "ItemStoreError" )

if not status then
	local str = "ITEMSTORE CONFIGURATION ERROR:\n"
	str = str .. err .. "\n"
	str = str .. "ITEMSTORE WILL NOT RUN AND MANY THINGS WILL BE BROKEN.\n"
	str = str .. "THIS IS NOT A PROBLEM WITH ITEMSTORE, YOUR CONFIG FILE HAS AN ERROR IN IT.\n"
	str = str .. "PLEASE INSTALL A FRESH COPY OF ITEMSTORE OR FIX THE ERROR IN YOUR CONFIG.\n"
	str = str .. "SEE YOUR SERVER CONSOLE FOR MORE DETAILS."

	MsgC( Color( 255, 0, 0 ), str, "\n" )

	if CLIENT then
		hook.Add( "HUDPaint", "ItemStoreError", function()
			for k, v in ipairs( string.Explode( "\n", str ) ) do
				draw.SimpleText( v, "Trebuchet24", ScrW() * 0.5, ScrH() * 0.5 + ( k * 24 ), Color( 255, 0, 0 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			end
		end )
	end
end

include( "language.lua" )
include( "gamemodes.lua" )
include( "items.lua" )
include( "containers.lua" )
include( "trading.lua" )
include( "admin.lua" )

local _, dirs = file.Find( "itemstore/modules/*", "LUA" )
for _, mod in ipairs( dirs ) do
	MsgC( color_white, string.format( "Loading ItemStore module: %s\n", mod ) )

	local path = "itemstore/modules/" .. mod

	for _, filename in ipairs( file.Find( path .. "/*.lua", "LUA" ) ) do
		if not string.match( filename, "^sv_.+%.lua$" ) then
			AddCSLuaFile( path .. "/" .. filename )
		end
	end

	local sv_init = path .. "/sv_init.lua"
	local cl_init = path .. "/cl_init.lua"
	local shared = path .. "/shared.lua"

	if file.Exists( shared, "LUA" ) then
		include( shared )
	end

	if SERVER and file.Exists( sv_init, "LUA" ) then
		include( sv_init )
	end

	if CLIENT and file.Exists( cl_init, "LUA" ) then
		include( cl_init )
	end
end

local teams = nil
local meta = FindMetaTable( "Player" )

function meta:CanUseInventory()
	if SERVER and ( not self.Inventory or not self.Bank ) then return end
	
	if self:IsAdmin() then return true end -- always allow admins to access their inventories
	if not self:Alive() then return false end -- using your inventory while dead can be a bit exploitable

	if #itemstore.config.LimitToJobs > 0 then
		-- process this into an associative table for faster lookups
		if not teams then
			teams = {}

			for k, v in ipairs( itemstore.config.LimitToJobs ) do
				teams[ v ] = true
			end
		end

		if teams[ self:Team() ] ~= true then
			return false
		end
	end

	return true
end
--PATH addons/____inventory/lua/itemstore/admin.lua:
if SERVER then
	util.AddNetworkString( "ItemStoreAdminInventory" )
	net.Receive( "ItemStoreAdminInventory", function( len, admin )
		if not admin:IsSuperAdmin() then return end

		local pl = net.ReadEntity()

		if not IsValid( pl ) then return end
		if not pl.Inventory then return end

		pl.Inventory:SetPermissions( admin, true, true )
		pl.Inventory:Sync( admin )
		admin:OpenContainer( pl.Inventory:GetID(), itemstore.Translate( "players_inventory", pl:Name() ) )
	end )

	util.AddNetworkString( "ItemStoreAdminBank" )
	net.Receive( "ItemStoreAdminBank", function( len, admin )
		if not admin:IsSuperAdmin() then return end

		local pl = net.ReadEntity()

		if not IsValid( pl ) then return end
		if not pl.Bank then return end

		pl.Bank:SetPermissions( admin, true, true )
		pl.Bank:Sync( admin )
		admin:OpenContainer( pl.Bank:GetID(), itemstore.Translate( "players_bank", pl:Name() ) )
	end )
else
	concommand.Add( "itemstore_admin", function( pl )
		if not pl:IsSuperAdmin() then return end

		local panel = vgui.Create( "ItemStoreAdmin" )
		panel:SetSize( 200, 300 )
		panel:Center()
		panel:MakePopup()
	end )
end

--PATH addons/____inventory/lua/itemstore/vgui/window.lua:
local PANEL = {}

PANEL.TitleBarHeight = 24

function PANEL:Init()
	self:SetSkin( "itemstore" )

    self.TitleBar = vgui.Create( "Panel", self )
    self.TitleBar:Dock( TOP )
    self.TitleBar:SetHeight( 24 )
    self.TitleBar.Paint = function() return self:PaintTitleBar() end

    self.Title = vgui.Create( "onyx.Label", self.TitleBar )
    self.Title:Dock( LEFT )

    self.CloseButton = vgui.Create( "onyx.Button", self.TitleBar )
    self.CloseButton:SetSize( 16, 16 )
    self.CloseButton:SetFont( "Marlett" )
    self.CloseButton:SetText( "r" )

    self.Body = vgui.Create( "Panel", self )
    self.Body:Dock( FILL )
    self.Body:SetPadding( 5, 5, 5, 5 )
    self.Body.Paint = function() return self:PaintContent() end

    self:SetTitle( "ItemStore" )
end

function PANEL:GetTitle()
    return self.Title:GetText()
end

function PANEL:SetTitle( text )
    self.Title:SetText( text )
end

function PANEL:PaintTitleBar( w, h )
end

function PANEL:PaintContent( w, h )
end

vgui.Register( "ItemStoreWindow", PANEL )

--PATH addons/____plogs/lua/plogs_hooks/props.lua:
--[[
addons/lgos/lua/plogs_hooks/props.lua
--]]
plogs.Register('Пропи', true, Color(50,175,255))

plogs.AddHook('PlayerSpawnProp', function(pl, mdl)
	plogs.PlayerLog(pl, 'Пропи', pl:NameID() .. ' поставил ' .. mdl, {
		['Name'] 	= pl:Name(),
		['SteamID']	= pl:SteamID()
	})
end)


--PATH addons/____esclib/lua/elib/vgui/esc_button.lua:
local max = math.max
local accessor_fn = esclib.accessor
local PANEL = {}

AccessorFunc(PANEL, "m_nBorderRadius", "BorderRadius", FORCE_NUMBER)
AccessorFunc(PANEL, "m_sButtonText", "ButtonText", FORCE_STRING)
AccessorFunc(PANEL, "m_cTextAlignX", "TextAlignX", FORCE_NUMBER)
AccessorFunc(PANEL, "m_cTextAlignY", "TextAlignY", FORCE_NUMBER)
AccessorFunc(PANEL, "icon_size", "IconSize", FORCE_NUMBER)
AccessorFunc(PANEL, "icon_offset", "IconOffset", FORCE_NUMBER)
AccessorFunc(PANEL, "enabled", "Enabled", FORCE_BOOL)
AccessorFunc(PANEL, "m_matIcon", "Icon")

AccessorFunc(PANEL, "bg_col", "BackgroundColor", FORCE_COLOR)
AccessorFunc(PANEL, "bg_col_hover", "BackgroundHoverColor", FORCE_COLOR)
AccessorFunc(PANEL, "bg_col_disabled", "BackgroundDisabledColor", FORCE_COLOR)
AccessorFunc(PANEL, "bg_col2", "BackgroundColor2")
AccessorFunc(PANEL, "bg_col2_hover", "BackgroundHoverColor2")

AccessorFunc(PANEL, "text_col", "TextColor", FORCE_COLOR)
AccessorFunc(PANEL, "text_col_hover", "TextHoverColor", FORCE_COLOR)

AccessorFunc(PANEL, "icon_col", "IconColor", FORCE_COLOR)
AccessorFunc(PANEL, "icon_col_hover", "IconHoverColor", FORCE_COLOR)

function PANEL:Init()
    self:SetMouseInputEnabled(true)
    self:SetEnabled(true)

    self.skin = esclib.addon:GetCurrentSkin()
    self.colors = self.skin.colors

    self:SetTextAlignX(TEXT_ALIGN_CENTER)
    self:SetTextAlignY(TEXT_ALIGN_CENTER)

    self:SetText("")
    self:SetIcon(nil)
    self:SetIconSize(1)
    self:SetIconOffset(esclib:AdaptiveSize(8))

    self:SetBorderRadius(8)
    self:SetButtonText("SetButtonText")

    self:SetCursor("hand")
    self:SetFont(esclib:AdaptiveFont("esclib", 18, 500))

    self:SetBackgroundColor(self.colors.button.main)
    self:SetBackgroundHoverColor(self.colors.button.hover)
    self:SetBackgroundColor2(self.colors.button.hover)
    self:SetBackgroundHoverColor2(self.colors.button.hover)
    self:SetBackgroundDisabledColor(self.colors.button.discard)

    self:SetTextColor(self.colors.button.text)
    self:SetTextHoverColor(self.colors.button.text_hover)

	self:SetIconColor(self.colors.button.text)
    self:SetIconHoverColor(self.colors.button.text_hover)

    self:SetEnabled(true)

    function self.SetText(pnl, text)
        self:SetButtonText(text)
    end

    function self.GetText(pnl)
        return self:GetButtonText()
    end
end

function PANEL:IsDown()
    return self.Depressed
end

function PANEL:IsEnabled()
    return self.enabled
end

function PANEL:PaintBackground(w,h)
    -- local col = self:IsHovered() and self.bg_col_hover or self.bg_col
    -- if not self:IsEnabled() then
    --     col = self.bg_col_disabled
    -- end
    -- draw.RoundedBox(self:GetBorderRadius(), 1, 1, w - 2, h - 2, col)

    local enabled = self:IsEnabled()
    local hovered = self:IsHovered() and enabled
    local bg_col = hovered and self.bg_col_hover or self.bg_col
    local bg_col2 = hovered and self.bg_col2_hover or self.bg_col2
    if not enabled then
        bg_col = self:GetBackgroundDisabledColor()
        -- bg_col2 = self:GetBackgroundDisabledColor()
    end

    draw.RoundedBox(self:GetBorderRadius(),0,0,w,h,bg_col2)
    draw.RoundedBox(max(self:GetBorderRadius()-2, 0),2,2,w-4,h-4,bg_col)
end

function PANEL:Paint(w, h)
    self:SetCursor("hand")
    local active = self:IsEnabled()
    local hovered = self:IsHovered() and active
    self:PaintBackground(w,h)
    
    local tax = self:GetTextAlignX()
    local text = self:GetButtonText()
    local font = self:GetFont()
    local icon = self:GetIcon()
    local iconSize = h * (0.5 * self.icon_size) -- Размер иконки
    surface.SetFont(font)
    local textWidth, textHeight = surface.GetTextSize(text)

	local icon_color = hovered and self.icon_col_hover or self.icon_col

    if text == "" then
        if icon then
            local iconOffsetX = (w - iconSize) * 0.5
            local iconOffsetY = (h - iconSize) * 0.5 + 1
            surface.SetDrawColor(icon_color.r, icon_color.g, icon_color.b, icon_color.a)
            surface.SetMaterial(icon)
            surface.DrawTexturedRect(iconOffsetX, iconOffsetY, iconSize, iconSize)
        end
    else
        if icon then
            local totalWidth = textWidth + iconSize + 5
            local iconOffsetX, textOffsetX
            
            if tax == TEXT_ALIGN_LEFT then
                iconOffsetX = 10
                textOffsetX = iconOffsetX + iconSize + self.icon_offset
            elseif tax == TEXT_ALIGN_RIGHT then
                textOffsetX = w - 10 - textWidth
                iconOffsetX = textOffsetX - iconSize - self.icon_offset
            else
                local startX = (w - totalWidth) * 0.5
                iconOffsetX = startX
                textOffsetX = startX + iconSize + self.icon_offset
            end
            
            local iconOffsetY = (h - iconSize) * 0.5 + 1
            
            surface.SetDrawColor(icon_color.r, icon_color.g, icon_color.b, icon_color.a)
            surface.SetMaterial(icon)
            surface.DrawTexturedRect(iconOffsetX, iconOffsetY, iconSize, iconSize)
            draw.SimpleText(text, font, textOffsetX, h * 0.5, hovered and self.text_col_hover or self.text_col, TEXT_ALIGN_LEFT, self:GetTextAlignY())
        else
            local textOffsetX
            if tax == TEXT_ALIGN_LEFT then
                textOffsetX = 10
            elseif tax == TEXT_ALIGN_RIGHT then
                textOffsetX = w - 10 - textWidth
            else
                textOffsetX = w * 0.5
            end
            draw.SimpleText(text, font, textOffsetX, h * 0.5, hovered and self.text_col_hover or self.text_col, tax, self:GetTextAlignY())
        end
    end

    if not active then
        self:SetCursor("no")
    end
end

function PANEL:SetIcon(material)
    self.m_matIcon = material
end

function PANEL:GetIcon()
    return self.m_matIcon
end

derma.DefineControl("esclib.button", "A button for esclib", PANEL, "DLabel")








----------------------
--# glow_button #--
----------------------
local PANEL = {}
accessor_fn(PANEL, "glow_size_x", "GlowSizeX", 0.5, "number")
accessor_fn(PANEL, "glow_size_y", "GlowSizeY", 0.7, "number")
accessor_fn(PANEL, "glow_clr", "GlowColor", Color(255,0,0,255), "table")
local allowed_modes = {
    ["radial"] = true,
    ["mouse"] = true,
    ["always"] = true
}
accessor_fn(PANEL, "glow_mode", "GlowMode", "radial", function(val) return allowed_modes[val] end)

function PANEL:Init()
    self.radial_grad = esclib:GetMaterial("radial_gradient.png")
    self:NoClipping(true)
end

function PANEL:PaintBackground(w,h)
    local enabled = self:IsEnabled()
    local hovered = self:IsHovered() and enabled
    local glow_mode = self:GetGlowMode()

    local bg_col = hovered and self.bg_col_hover or self.bg_col
    local bg_col2 = hovered and self.bg_col2_hover or self.bg_col2
    if not enabled then
        bg_col = self:GetBackgroundDisabledColor()
    end

    draw.RoundedBox(self:GetBorderRadius(),0,0,w,h,bg_col2)

    if hovered or glow_mode == "always" then
        surface.SetDrawColor(self:GetGlowColor())
        surface.SetMaterial(self.radial_grad)
        local offset_x = w*self.glow_size_x
        local offset_y = h*self.glow_size_y
    
        if glow_mode == "radial" then
            surface.DrawTexturedRect(-offset_x, -offset_y, w + offset_x*2, h + offset_y*2)
        elseif glow_mode == "mouse" then
            local mx,my = input.GetCursorPos()
            local px,py = self:ScreenToLocal(mx,my)
            surface.DrawTexturedRect(px-w*0.5-offset_x,py-h*0.5-offset_y,w+offset_x*2,h+offset_y*2)
        elseif glow_mode == "always" then
            surface.DrawTexturedRect(-offset_x, -offset_y, w + offset_x*2, h + offset_y*2)
        end
    end

    draw.RoundedBox(max(self:GetBorderRadius()-2, 0),2,2,w-4,h-4,bg_col)
end

function PANEL:OnCursorEntered()
    self:SetZPos(2)
end
function PANEL:OnCursorExited()
    self:SetZPos(0)
end

vgui.Register("esclib.glow_button", PANEL, "esclib.button")
--test
-- if IsValid(tests) then tests:Remove() end
-- tests = vgui.Create("esclib.glow_button")
-- tests:SetSize(75,25)
-- tests:SetPos(ScrW()/2, ScrH()/2)
-- tests:SetButtonText("Test")
-- tests:SetBackgroundColor(Color(13,13,13))
-- tests:SetBackgroundHoverColor(Color(20,20,20))
-- tests:SetBackgroundColor2(Color(20,20,20))
-- tests:SetBackgroundHoverColor2(Color(0,255,100))
-- tests:SetGlowMode("always")
--PATH addons/____esclib/lua/elib/vgui/esc_switch_menu.lua:
local accessor_fn = esclib.accessor
local PANEL={}

local allowed = {
    ["remove"]=true,
    ["hide"]=true
}

AccessorFunc(PANEL, "current_panel", "CurrentPanel")
accessor_fn(PANEL, "switch_method", "SwitchMethod", "remove", function(val)
    val = val or ""
    assert(allowed[val], "Wrong switch method provided: '"..val.."' Allowed: 'remove' or 'hide")
    return allowed[val]
end)

function PANEL:Init()
    self.generated_panels = {}
    self.generators = {}
end

function PANEL:AddPage(name, func)
    self.generators[name] = func
    -- self:SetCurrentPanel(nil)
end

function PANEL:CheckValid()
    local valid = {}
    for _,v in ipairs(self.generated_panels) do
        if IsValid(v) then
            table.insert(valid, v)
        end
    end
    self.generated_panels = valid
end

function PANEL:Switch(name, ...)
    local method = self.switch_method
    name = name or ""

    local need_to_gen = true
    if method == "remove" then
        self:Clear()
        self:CheckValid()
    elseif method == "hide" then
        for _,v in ipairs(self.generated_panels) do
            if v.name ~= name then
                v:Hide()
            else
                v:Show()
                self:SetCurrentPanel(v.name)
                need_to_gen = false
            end
        end
    end

    if not self.generators[name] then return end

    if need_to_gen then
        local generated_bg = self:Add("EditablePanel")
        local px,py,pw,ph = self:GetDockMargin()
        generated_bg:SetSize(self:GetWide()-(px+pw), self:GetTall()-(py+ph))
        generated_bg.name = name
        generated_bg.Paint = nil
        accessor_fn(generated_bg, "name", "Name", name, "string")
        table.insert(self.generated_panels, generated_bg)

        self.generators[name](generated_bg, generated_bg:GetWide(), generated_bg:GetTall(), unpack({...} or {}))
        self:SetCurrentPanel(name)
    end
end

function PANEL:Paint()
    --for override
end

vgui.Register( "esclib.switchmenu", PANEL );
--PATH addons/____esclib/lua/elib/essentials/settings_menu/settings_types/esc_type_color.lua:
local draw_bg = esclib.settings_shared_funcs.draw_bg
local VarsIsEqual = esclib.settings_shared_funcs.VarsIsEqual
local SharedDoRightClick = esclib.settings_shared_funcs.SharedDoRightClick

-------------
--# CLR #--
-------------
local matGrid = Material( "gui/alpha_grid.png", "nocull" )

local stype = esclib:RegisterSettingsType("clr")
stype:Require("value")
function stype:Build( parent )
	local addon     = parent.addon
	local varid     = parent.var_uid
	local varc      = parent.var
	local callback  = parent.ApplyValue
	local varc_copy = parent.initial_values
	local settab    = parent.bg
	local def_val   = parent.default_value

	local button_wide = parent:GetWide()
	local button_tall = parent:GetTall()

	local clr = esclib.addon:GetColors()
	local name_tr  = varc.name or addon:Translate(varc.name_tr)
	local desc = varc.desc or addon:Translate(varc.desc_tr)

	local font = esclib:AdaptiveFont("esclib", 20, 500)
	local font2 = esclib:AdaptiveFont("esclib", 20, 500)
	local name = esclib.util:TextCutAccurate(name_tr, font, button_wide-15-90, "...")

	local button = parent:Add("DButton")
	button:SetSize(button_wide, button_tall)
	button:SetText("")
	button.DoRightClick = function(self) SharedDoRightClick(self, settab, name_tr, addon, varid, varc, def_val, callback) end
	if desc then
		local added = ""
		if varc.max or varc.min then
			added = "("..(varc.min or "∞").." - "..(varc.max or "∞")..")\n"
		end
		button:eAddHint(added.." "..desc,font2,TEXT_ALIGN_CENTER,settab)
	end

	local quad_size = button:GetTall()*0.6
	local inv_size  = (button:GetTall()-quad_size)*0.5

	local clr_pnl = button:Add("DPanel")
	clr_pnl:SetSize(quad_size, quad_size)
	clr_pnl:SetPos(button:GetWide() - clr_pnl:GetWide() - inv_size, button:GetTall()*0.5 - clr_pnl:GetTall()*0.5)
	clr_pnl:SetMouseInputEnabled(false)
	function clr_pnl:Paint(w,h)
		esclib.draw:Material(0,0,w,h,color_white,matGrid)

		draw.RoundedBox(0, 0,0,w,h, varc.value)
	end
	
	local wrench_mat = esclib:GetMaterial("wrench.png")
	local offset_x = 10.0
	function button:Paint(w,h)
		local hovered = self:IsHovered()
		local is_changed = not esclib.util:IsValuesEqual(varc.value, varc_copy[varid])
		draw_bg(w,h,hovered,clr,is_changed)

		if hovered then
			offset_x = Lerp(0.1, offset_x, h)
			esclib.draw:MaterialCentered(offset_x-h*0.5, h*0.5, h*0.25, clr.button.text, wrench_mat)
		else
			offset_x = Lerp(0.1, offset_x, 10.0)
		end

		draw.SimpleText(name,font,offset_x,h*0.5,clr.button.text,TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER)
		-- --if changed
		-- if not esclib.util:IsValuesEqual(varc.value, varc_copy[varid]) then
		-- 	draw.RoundedBox(0,0,h-2,w,2,clr.button.discard)
		-- end
	end

	function button:DoClick()
		local bg = esclib:GenerateBGClicker(true)
		-- bg.Paint = nil

		local mx, my = input.GetCursorPos()

		local pnl = bg:Add("DPanel")
		pnl:SetSize(self:GetWide(), bg:GetTall()*0.2)
		local x, y = self:LocalToScreen(self:GetWide()*0.5, self:GetTall())
		pnl:SetPos(x - pnl:GetWide()*0.5, y + 5)
		function pnl:Paint(w,h)
			draw.RoundedBox(8,0,0,w,h,clr.frame.bg)
		end

		local colorpicker = pnl:Add("esclib.colorpicker")
		colorpicker:Dock(FILL)
		colorpicker:DockMargin(15,15,15,15)
		colorpicker:SetColor(varc.value)

		function colorpicker:ValueChanged(new_col)
			varc.value = Color(new_col.r, new_col.g, new_col.b, new_col.a)
		end

		function bg:OnClose()
			callback()
		end
	end
end
--PATH addons/____esclib/lua/elib/essentials/settings_menu/settings_types/esc_type_string.lua:
local draw_bg = esclib.settings_shared_funcs.draw_bg
local VarsIsEqual = esclib.settings_shared_funcs.VarsIsEqual
local SharedDoRightClick = esclib.settings_shared_funcs.SharedDoRightClick

-----------
--# STR #--
-----------
local stype = esclib:RegisterSettingsType("str")
stype:Require("value")
stype:SoftRequire("MaximumCharCount")
stype:SoftRequire("MinimumCharCount")
stype:SoftRequire("HintTranslateKey")
stype:SoftRequire("Multiline")
function stype:Build( parent )
	local addon     = parent.addon
	local varid     = parent.var_uid
	local varc      = parent.var
	local callback  = parent.ApplyValue
	local init_vals = parent.initial_values
	local settab    = parent.bg
	local def_val   = parent.default_value

	local button_wide= parent:GetWide()
	local button_tall = parent:GetTall()

	local clr = esclib.addon:GetColors()
	local name_tr  = varc.name or addon:Translate(varc.name_tr)
	local desc = varc.desc or addon:Translate(varc.desc_tr)

	local font = esclib:AdaptiveFont("esclib", 20, 500)
	local font2 = esclib:AdaptiveFont("esclib", 20, 500)
	
	local button = parent:Add("DButton")
	button:SetSize(button_wide, button_tall)
	button:SetText("")
	button.DoRightClick = function(self) SharedDoRightClick(self, settab, name_tr, addon, varid, varc, def_val, callback) end
	if desc then
		button:eAddHint(desc,font2,TEXT_ALIGN_TOP,settab)
	end

	local wrench_mat = esclib:GetMaterial("wrench.png")
	local offset_x = 10.0
	function button:Paint(w,h)
		local hovered = self:IsHovered()
		local is_changed = varc.value ~= init_vals[varid]
		draw_bg(w,h,hovered,clr,is_changed)

		if hovered then
			offset_x = Lerp(0.1, offset_x, h)
			esclib.draw:MaterialCentered(offset_x-h*0.5, h*0.5, h*0.25, clr.button.text, wrench_mat)
		else
			offset_x = Lerp(0.1, offset_x, 10.0)
		end

		local name = esclib.util:TextCut(name_tr, font, button_wide-offset_x-25, "...")
		local value_text = esclib.util:TextCut(varc.value, font2, button_wide-offset_x-25, "...")

		draw.SimpleText(name,font,offset_x,8,clr.button.text,TEXT_ALIGN_LEFT,TEXT_ALIGN_TOP)
		draw.SimpleText(value_text,font2,offset_x,h-8,clr.button.accent,TEXT_ALIGN_LEFT,TEXT_ALIGN_BOTTOM)
	end

	function button:DoClick()
		local hint = varc.HintTranslateKey and addon:Translate(varc.HintTranslateKey) or esclib.addon:Translate("window_ValueEdit", addon.info.language)
		local text_input = esclib:TextInputWindow(name_tr, hint, varc.Multiline, false, 
			function(result)
				varc.value = result
				callback(varid,varc.value)
			end,
			function(val)
				local slen = string.len(string.Trim(val) or "")
				local maxv = varc.MaximumCharCount or math.huge
				local minv = varc.MinimumCharCount or -math.huge

				if not ((slen >= minv) and (slen <= maxv)) then
					return string.format("%s <= #str <= %s", minv, maxv)
				end
				return not ((slen >= minv) and (slen <= maxv))
			end,
			addon.info.language
		)
		text_input:SetText(varc.value)
	end

end
--PATH addons/____esclib/lua/elib/essentials/settings_menu/esc_settings_menu.lua:
local max = math.max
local min = math.min


local function tablesAreEqual(table1, table2)
	for k, v in pairs(table1) do
		if type(v) ~= type(table2[k]) then return false end
		if istable(v) and istable(table2[k]) then
			if not tablesAreEqual(v, table2[k]) then
				return false
			end
		elseif table2[k] ~= v then
			return false
		end
	end

	for k, _ in pairs(table2) do
		if table1[k] == nil then
			return false
		end
	end

	return true
end

local function VarsIsEqual(var1, var2)
	if type(var1) ~= type(var2) then return false end
	if istable(var1) and istable(var2) then return tablesAreEqual(var1, var2) end
	return var1 == var2
end


-------------
--# PANEL #--
-------------
local settab = settab or nil
function esclib:closesettings()
	if IsValid(settab) then
		settab:Remove()
		return true
	end
	return false
end

function esclib:opensettings(naddon, skip_anim)
	esclib:closesettings()

	local skin = esclib.addon:GetCurrentSkin()
	local clr = skin.colors
	local scrw, scrh = esclib.scrw, esclib.scrh
	local addons = esclib:GetAddons() or {}
	local addoncount = 0

	local c_addonpnl = nil
	local c_themepanel = nil

	for k,v in pairs(addons) do
		addoncount = addoncount + 1
	end

	local needaddon
	local needrestart = false

	if naddon then
		if not isstring(naddon) then
			naddon = tostring(naddon)
		end
		naddon = string.lower(naddon)
		
		if esclib:GetAddons()[naddon] then
			needaddon = true
		end
	end

	settab = vgui.Create("EditablePanel")
	if not skip_anim then
		settab:SetAlpha(0)
		settab:AlphaTo(255,esclib.addon:GetVar("animtime") or 0.1)
	else
		settab:SetAlpha(255)
	end
	settab:SetSize(scrw,scrh)
	settab:SetText("")
	settab:MakePopup()
	settab:SetKeyBoardInputEnabled(false)
	local draw_blur = esclib.addon:GetVar("drawblur")

	local setbutton = settab:Add("DButton")
	setbutton:SetSize(scrw,scrh)
	setbutton:SetText("")
	setbutton.Paint = nil

	local version = string.format("%s v%s", esclib.addon:GetBranch() or "", esclib.addon:GetVersion() or "")
	local hash = esclib:GetServerHash()
	
	local font = esclib:AdaptiveFont("esclib", 20, 500)
	local font_h = draw.GetFontHeight(font)
	local gradient_text = esclib.draw:GradientText(esclib.addon:GetName(), esclib:AdaptiveFont("esclib", 24, 500), Color(111,255,27), Color(0,255,128))

	local icon = esclib:GetMaterial("cog.png")
	local icon_tall = gradient_text["info"]["text_h"] + draw.GetFontHeight(font) * 2 + 6

	local btn = settab:Add("esclib.button")
	btn:SetSize(icon_tall*0.8, icon_tall*0.8)
	btn:SetText("")
	btn:SetIcon(icon)
	btn:SetPos(
		settab:GetWide()-btn:GetWide()-10, 
		settab:GetTall()-icon_tall*0.5-btn:GetTall()*0.5-5
	)
	btn:SetMouseInputEnabled(true)
	btn:SetIconSize(1.5)
	btn:SetBackgroundColor(color_transparent)
	btn:SetBackgroundHoverColor(color_transparent)
	function btn:DoClick()
		esclib:closesettings()
		esclib:opensettings("esclib")
	end

	local offset_x = btn:GetWide()
	function settab:Paint(w,h)
		if draw_blur then
			esclib.draw:Blur(self,6)
		end

		draw.RoundedBox(0, 0, 0, w, h, clr.background.col)

		gradient_text:Draw(w-offset_x-20, h-font_h*2-10, TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM, true)
		draw.SimpleText(version, font, w-offset_x-20, h-font_h-10, clr.frame.text, TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM)
		draw.SimpleText("SVUID "..hash, font, w-offset_x-20, h-7, clr.frame.text, TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM)
	end

	if esclib.addon:GetVar("debug") then

		local offset = 5

		local text = "DEV MODE"
		local font = esclib:AdaptiveFont("esclib", 18, 500)
		local textw, texth = esclib.util:TextSize(text, font)
		local dbg_btn = setbutton:Add("esclib.button")
		dbg_btn:SetSize(textw+20, texth+5)
		dbg_btn:SetPos(offset, 5)
		dbg_btn:SetButtonText(text)
		dbg_btn:SetFont(font)
		dbg_btn:SetMouseInputEnabled(false)
		offset = offset + textw+25


		local text = "Fonts"
		font = esclib:AdaptiveFont("esclib", 18, 500)
		textw, texth = esclib.util:TextSize(text, font)

		dbg_btn = setbutton:Add("esclib.button")
		dbg_btn:SetSize(textw+20, texth+5)
		dbg_btn:SetPos(offset, 5)
		dbg_btn:SetButtonText(text)
		dbg_btn:SetFont(font)
		function dbg_btn:DoClick()
			local fonts = table.GetKeys(esclib.fonts.list)
			local count = #fonts
			if count < 1 then return end
			table.sort(fonts, function(a, b) return a:upper() < b:upper() end)

			local pnl = esclib:GeneratePopWindow(false)
			pnl:SetSize(esclib.scrw*0.7,esclib.scrh*0.8)
			pnl:SetPos(esclib.scrw*0.5 - pnl:GetWide()*0.5, esclib.scrh*0.5 - pnl:GetTall()*0.5)

			pnl:SetTitle(text.." ("..count..")")
			local content = pnl:GetContent()
			content:InvalidateParent()
			local scroll = content:Add("esclib.scrollpanel")
			scroll:SetSize(content:GetWide(),content:GetTall())


			local list = scroll:Add("DIconLayout")
			list:SetY(5)
			list:SetSize(content:GetWide(),content:GetTall()-10)
			list:SetSpaceY(5)
			list:SetBorder(esclib:AdaptiveSize(30))

			local adafont = esclib:AdaptiveFont("esclib", 20, 500)
			for id,font in pairs(fonts) do
				local text = "Preview 12345"
				local textw,texth = esclib.util:TextSize(text,font)

				local font_pnl = list:Add("DPanel")
				function font_pnl:Paint(w,h)
					draw.RoundedBox(0,0,0,w,h,clr.frame.accent)
				
					draw.SimpleText(id..". ["..font.."]",adafont, 5, 5, clr.frame.text_gray, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
				end

				local textw2,texth2 = esclib.util:TextSize(id,adafont)
				font_pnl:SetSize(list:GetWide()-list:GetBorder()*2, max(texth+6,texth2+6)+20)

				local font_lbl = font_pnl:Add("DLabel")
				font_lbl:SetSize(font_pnl:GetWide()-15, font_pnl:GetTall())
				font_lbl:SetX(textw2+15)
				font_lbl:SetY(10)
				font_lbl:SetText(text)
				font_lbl:SetFont(font)
				font_lbl:SetColor(clr.frame.text_hover)
			end

		end
		offset = offset + textw+25
	end

	local main = vgui.Create("esclib.frame", settab)
	if needaddon then main:Hide() end
	main:SetSize(scrw*0.5,scrh*0.6)
	main:SetPos(scrw*0.5 - main:GetWide()*0.5, scrh*0.5 - main:GetTall()*0.5)
	main:SetIcon(esclib:GetMaterial("cog.png"))
	main:SetTitle(esclib.addon:Translate("tab_settings"))
	main:SetColorThink(true)
	main:SetAutoRestoreColor(true)
	function main:OnClose(callback)
		if IsValid(settab.c_themepanel) then settab.c_themepanel:Remove() end

		if IsValid(settab.c_addonpnl) then settab.c_addonpnl:Remove() end

		local animtime = esclib.addon:GetVar("animtime") or 0
		settab:AlphaTo(0,animtime,0,function()
			if callback then callback() end
			if IsValid(settab) then
				settab:Remove()
				return
			end
			if IsValid(main) then
				main:Remove()
			end
		end)
		gui.EnableScreenClicker(false)
	end
	function main:Close()
		self:OnClose()
		self:Remove()
	end

	local function settings_on_close_any(pnl)
		local animtime = skip_anim and 0 or (esclib.addon:GetVar("animtime") or 0)

		if IsValid(settab.c_themepanel) then
			if pnl ~= settab.c_themepanel then
				if settab.c_themepanel.OnClose then settab.c_themepanel:OnClose(self) end
			end
			settab.c_themepanel:AlphaTo(0,animtime,0,function()
				if IsValid(settab.c_themepanel) then settab.c_themepanel:Remove() end
			end)

			if IsValid(c_addonpnl) then
				c_addonpnl:Show()
				c_addonpnl:SetAlpha(0)
				c_addonpnl:AlphaTo(255,animtime)
			end
			return true
		end

		if IsValid(c_addonpnl) then
			if needaddon then
				main:Close()
				return
			end

			c_addonpnl:AlphaTo(0,animtime,0,function()
				c_addonpnl:Remove()
			end)
		end

		if not main:IsVisible() then
			main:Show()
			main:SetAlpha(0)
			main:AlphaTo(255,animtime)
		else
			main:Close()
		end

		return true
	end

	function setbutton:DoClick()
		if settings_on_close_any() then return end
		main:Close()
	end

	local content = main:GetContent()
	local scroll = content:Add("esclib.scrollpanel")
	scroll:SetSize(content:GetWide(),content:GetTall())

	local list = scroll:Add("DIconLayout")
	list:SetWide(content:GetWide())
	list:SetSpaceY(esclib:AdaptiveSize(10))
	list:SetSpaceX(list:GetSpaceY())
	list:SetBorder(esclib:AdaptiveSize(15))
	list:SetStretchHeight(true)

	local addon_list = {}
	for uid,addon in pairs(addons) do
		table.insert(addon_list, addon)
	end
	table.sort(addon_list, function(a,b)
		return a:GetSortOrder() < b:GetSortOrder()
	end)

	local total_height = 0
	for addon_num,add in ipairs(addon_list) do
		local uid = add.info.uid

		------------------
		--# ALL ADDONS #--
		------------------
		local name_font = esclib:AdaptiveFont("esclib", 24, 500)

		local addpan = list:Add("DButton")
		addpan:SetWide(content:GetWide()*0.25-list:GetBorder())
		addpan:SetTall(addpan:GetWide()+draw.GetFontHeight(name_font)+esclib:AdaptiveSize(20))
		addpan:SetText("")

		total_height = total_height + addpan:GetTall() + list:GetSpaceY()

		local drawicon = false
		if type((add.info.thumbnail or "")) == "IMaterial" then
			drawicon = true
		end

		local version = string.format("%s v%s", add:GetBranch() or "", add:GetVersion() or "")
		local version_wide, version_height = esclib.util:TextSize(version, esclib:AdaptiveFont("esclib", 16, 500))

		local font = esclib:AdaptiveFont("esclib", 16, 500)
		function addpan:Paint(w,h)
			local hovered = self:IsHovered()
			draw.RoundedBox(8, 0, 0, w, h, hovered and add.info.color or clr.button.hover)
			draw.RoundedBox(6, 2, 2, w - 4, h - 4, hovered and clr.frame.bg or clr.button.main)

			--version
			draw.SimpleText(version, font, w-version_wide-15, 10, clr.frame.text)

			if hovered then
				local aclr = table.Copy(add.info.color)
				aclr.a = 50
				main:SetTargetGradientColor(aclr)
			end
		end

		local icon_pnl = addpan:Add("DPanel")
		icon_pnl:Dock(TOP)
		local margin = esclib:AdaptiveSize(5)
		icon_pnl:SetTall(addpan:GetWide()-margin*2)
		icon_pnl:DockMargin(margin,margin,margin,margin)
		icon_pnl:SetMouseInputEnabled(false)
		local poly = nil
		function icon_pnl:Paint(w,h)
			esclib.draw:Mask(function() --draw poly
				if not poly then
					poly = esclib.util:PrecacheRoundedPoly(0, 0, w, h, 6, 3)
				end
				draw.NoTexture();
				surface.SetDrawColor( color_white )
				surface.DrawPoly( poly )
			end, 
			function() --draw main
				if drawicon then
					esclib.draw:Material(0,0,w,w,clr.default.white , add.info.thumbnail)
				else
					draw.RoundedBox(0,0,0, w, w, clr.frame.text)
				end
			end,false)

			esclib.draw:ShadowText(version, font, w-version_wide-15, 10, clr.default.white)
		end

		local info_pnl = addpan:Add("DPanel")
		info_pnl:Dock(FILL)
		info_pnl:SetMouseInputEnabled(false)
		function info_pnl:Paint(w,h)
			draw.SimpleText(add.info.name, name_font, w*0.5-2, h*0.5-3, clr.frame.text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end

		-------------------
		--# EDIT ADDONS #--
		-------------------
		local cur_realm = ""
		local cur_sub_realm = ""

		local tabnames = {
			"realm_Client",
			"realm_Server"
		}
		local function open_addon_edit()
			main:Hide()

			if IsValid(c_addonpnl) then c_addonpnl:Remove() end

			local changed_vars = {}

			local addon_settings_copy = table.Copy(add.data.settings) or {}
			local addon_vars_copy = table.Copy(add.data.vars)
			local addon_language = add:GetLanguage()
			local addon_active_skin = add.info.active_skin
			local addon_custom_skin = table.Copy(add:GetSkinByName("skin_custom"))
			local addon_lang = add:GetLanguage() --dont changes


			c_addonpnl = vgui.Create("esclib.frame",settab)
			settab.c_addonpnl = c_addonpnl
			c_addonpnl:SetAlpha(0)
			c_addonpnl:AlphaTo(255,esclib.addon:GetVar("animtime") or 0.05)
			c_addonpnl:SetSize(scrw*0.7,scrh*0.8)
			c_addonpnl:SetPos(scrw*0.5 - c_addonpnl:GetWide()*0.5, scrh*0.5 - c_addonpnl:GetTall()*0.5)
			c_addonpnl:SetIcon(esclib:GetMaterial("cog.png"))
			c_addonpnl:SetColorThink(true)
			c_addonpnl:SetAutoRestoreColor(true)
			function c_addonpnl:OnClose()
				settings_on_close_any(self)
			end

			local sidebar = vgui.Create("DButton",settab)
			sidebar:SetWide(c_addonpnl:GetWide()*0.06)
			sidebar:SetText("")
			function sidebar:DoClick()
				-- setbutton:DoClick() --send close signal
			end
			function sidebar:Think()
				if not IsValid(c_addonpnl) then
					self:Remove()
					return
				end
				
				-- self:SetPos(c_addonpnl:GetX()-self:GetWide()-10, c_addonpnl:GetY()+c_addonpnl:GetTall()*0.5 - self:GetTall()*0.5) --by center
				self:SetPos(c_addonpnl:GetX()-self:GetWide()-10, c_addonpnl:GetY())
				self:SetAlpha(c_addonpnl:GetAlpha())
			end
			function sidebar:Paint(w,h)
				-- draw.RoundedBox(8, 0,0,w,h, clr.frame.bg)
				-- draw.RoundedBox(6, 2,2,w-4,h-4, clr.frame.accent)
			end

			local hover_color = Color(100,100,100,50)
			local total_tall = 0
			for _,sub_add in ipairs(addon_list) do
				local add_btn = sidebar:Add("DButton")
				add_btn:SetY(total_tall)
				add_btn:SetTall(sidebar:GetWide())
				add_btn:SetWide(add_btn:GetTall())
				add_btn:SetText("")
				add_btn:eAddHint(sub_add.info.name, esclib:AdaptiveFont("esclib", 22, 500), TEXT_ALIGN_LEFT, settab)
				function add_btn:Paint(w,h)

				end
				function add_btn:DoClick()
					esclib:opensettings(sub_add.info.uid, true)
				end

				local drawicon = false
				if type((sub_add.info.thumbnail or "")) == "IMaterial" then
					drawicon = true
				end

				local logo_pnl = add_btn:Add("DPanel")
				logo_pnl:Dock(FILL)
				logo_pnl:DockMargin(2,2,2,2)
				logo_pnl:SetMouseInputEnabled(false)
				local poly = nil
				function logo_pnl:Paint(w,h)
					local hovered = add_btn:IsHovered()
					esclib.draw:Mask(function() --draw poly
						if not poly then
							poly = esclib.util:PrecacheRoundedPoly(0, 0, w, h, w*0.25, 8)
						end
						draw.NoTexture();
						surface.SetDrawColor( color_white )
						surface.DrawPoly( poly )
					end, 
					function() --draw main
						if drawicon then
							esclib.draw:Material(0,0,w,w,clr.default.white, sub_add.info.thumbnail)
						else
							draw.RoundedBox(0,0,0, w, w, clr.frame.text)
						end

						if hovered then 
							draw.RoundedBox(0,0,0,w,h,hover_color)
						end
					end,false)
				end

				total_tall = total_tall + add_btn:GetTall() + 2
			end
			sidebar:SetTall(total_tall)

			c_addonpnl:SetTitle(add.info.name.." - "..esclib.addon:Translate("tab_settings", addon_lang))
			local c_content = c_addonpnl:GetContent()

			local realm = c_content:Add("esclib.combolist")
			realm:Dock(FILL)
			realm:SetAccentColor(Color(125,125,255))
			local navbar = realm:GetNavBar()
			local padding = esclib:AdaptiveSize(15)
			navbar:DockMargin(padding,0,padding,0)

			function realm:OnChange(name)
				cur_realm = name
			end


			local function build_realm(rname)
				if not IsValid(realm) then return end
				local realm_name = esclib.addon:Translate(rname,add:GetLanguage())

				realm:RemoveTab(realm_name)

				local tab_pnl = realm:AddTab(realm_name, function(content)
					if not IsValid(content) then return end

					local addon_settings_copy = table.Copy(addon_settings_copy or {})
					local addon_vars_copy = table.Copy(addon_vars_copy or {})
					if rname == "realm_Server" then
						if table.IsEmpty(add.data.server_vars or {}) then 
							return 
						end

						addon_settings_copy = table.Copy(add.data.server_settings or {})
						addon_vars_copy = table.Copy(add.data.server_vars or {}) --recieved on request

						--use server vars
						for tab_name, tab in pairs(addon_settings_copy) do
							local vars = tab["vars"] or {}

							for var_name, var in pairs(vars) do
								var.value = addon_vars_copy[var_name]
							end
						end
					end

					local dobar_size = content:GetTall()*0.07
					local combolist = content:Add("esclib.combolist")
					combolist:SetAccentColor(clr.button.accent)
					local navbar = combolist:GetNavBar()
					local padding = esclib:AdaptiveSize(15)
					navbar:DockMargin(padding,0,padding,0)
		
					local dobar = content:Add("DPanel")
					dobar:SetTall(dobar_size)
					dobar:Dock(BOTTOM)
					dobar:InvalidateParent(true)
					combolist.bottom_panel = dobar

					function combolist:GetBottomPanel()
						return self.bottom_panel
					end

					combolist:SetSize(content:GetWide(),content:GetTall()-dobar:GetTall())

					function combolist:OnChange(name)
						cur_sub_realm = name
					end

					local settings_changed = false 

					local function check_saved(varid,val)

						if rname == "realm_Client" then

							changed_vars[varid] = val

							if not table.IsEmpty(changed_vars) then
								settings_changed = true
							else
								settings_changed = false
							end

						elseif rname == "realm_Server" then
							if not esclib.util:IsValuesEqual(addon_vars_copy[varid] or {}, val) then
								settings_changed = true
							else
								settings_changed = false
							end

							changed_vars[varid] = val
						end
					end

					local function save_settings()
						if rname == "realm_Client" then
							if add.info.active_skin ~= addon_active_skin then
								settab:Remove()
	
								add:SetSkin(addon_active_skin)
								add:SaveCurrentSkin()
							end
	
							add:SetLanguage(addon_language)
							add:SaveLanguage()
	
							add:ReplaceSettings(addon_settings_copy) --Save automatically
	
							hook.Run(add.info.uid.."_settings_changed",true, changed_vars) -- HOOK
	
							-- if needrestart then
							-- 	settab:Remove()
							-- end
	
							table.Empty(changed_vars)
						elseif rname == "realm_Server" then
							if table.IsEmpty(changed_vars) then return end
									
							net.Start("esclib.SendServerConfig")
								net.WriteString(add.info.uid)
								esclib:NetWriteCompressedTable(changed_vars)
							net.SendToServer()

							addpan:DoClick()
						end

						settings_changed = false
					end

					local tabs_list = {}
					local settings_keys = table.GetKeys(addon_settings_copy)

					for k,v in ipairs(settings_keys) do
						local c_order = addon_settings_copy[v]["sortOrder"]
						table.insert(tabs_list,{ stype="settings", key=v, sortOrder=c_order })
					end

					for key,tab in pairs(add:GetAllCustomTabs()) do
						if not istable(tab) then continue end
						local c_order = tab["sortOrder"]
						local realm = tab["realm"]
						if rname ~= realm then continue end
						table.insert(tabs_list,{ stype="custom", key=key, sortOrder=c_order })
					end

					for key,tab in pairs(esclib:GetAllDefaultTabs()) do
						local realm = tab["realm"]
						if rname ~= realm then continue end

						local c_order = tab["sortOrder"]
						table.insert(tabs_list,{ stype="default", key=key, sortOrder=c_order })
					end

					--Sort by sortOrder key
					--SortOrder: 100 - language tab, 101 - theme tab
					table.sort(tabs_list,function(a,b)
						return ( (a.sortOrder or 99) < (b.sortOrder or 99) )
					end)

					for _,data in ipairs(tabs_list) do

						if data["stype"] == "settings" then
							local tabname = data["key"]
							local tabc = {}
							if rname == "realm_Server" then
								tabc = table.Copy(addon_settings_copy[tabname])
							else
								tabc = addon_settings_copy[tabname]
							end

							if not istable(tabc) then continue end

							if tabc.customCheck then
								if isfunction(tabc.customCheck) then 
									if not tabc.customCheck(tabc,add) then continue end
								end
							end

							local vars = tabc["vars"]
							local tabname_translated = add:Translate(tabc.name_tr) or tabc.name

							combolist:AddTab( tabname_translated, function(tab_content)
								
								local scroll = tab_content:Add("esclib.scrollpanel")
								scroll:SetSize(tab_content:GetWide(),tab_content:GetTall())

								local list = scroll:Add("DIconLayout")
								list:SetBorder(esclib:AdaptiveSize(15))
								list:SetSize(tab_content:GetWide(),tab_content:GetTall()-6)
								list:SetSpaceX(5)
								list:SetSpaceY(5)

								local button_wide = list:GetWide()*0.333-list:GetBorder()-2
								local button_tall = list:GetTall()*0.09

								local sortedVars = table.GetKeys(vars)
								table.sort(sortedVars,function(a,b)
									return ( (vars[a]["sortOrder"] or math.huge) < (vars[b]["sortOrder"] or math.huge) )
								end)

								for _,varid in ipairs(sortedVars) do

									local varc = vars[varid]

									if varc.visible == false then continue end

									if varc.customCheck then
										if isfunction(varc.customCheck) then 
											if not varc.customCheck(varc,add) then continue end
										end
									end

									if (varc.name == nil and varc.name_tr == nil) then varc.name = varid end

									local vtype  = varc.type
									if esclib.allowed_settings_types[vtype] then

										local settings_type = esclib.allowed_settings_types[vtype]
										if isfunction(settings_type["Build"]) then
											local default_val = nil

											if add.data.default_settings[varid] ~= nil then
												default_val = add.data.default_settings[varid]
											elseif add.data.server_default_settings[varid] ~= nil then
												default_val = add.data.server_default_settings[varid]
											end

											local base_panel = list:Add("DPanel")
											base_panel:SetSize(button_wide, button_tall)
											base_panel.addon = add
											base_panel.var = varc
											base_panel.default_value = default_val
											base_panel.var_uid = varid
											base_panel.initial_values = addon_vars_copy
											base_panel.bg = settab
											base_panel.parent = list
											base_panel.Paint = nil

											function base_panel:ApplyValue()
												if varc["restart_addon"] then needrestart = true end
												check_saved(varid,varc.value)
											end

											function base_panel:SaveAll()
												save_settings()
												addpan:DoClick()
											end

											settings_type:Build(base_panel)
										end
									end

								end

								return scroll

							end)

						elseif data["stype"] == "custom" then
							local function callback(changed)
								settings_changed = changed
							end

							local name = data["key"]
							local cstm = add:GetAllCustomTabs()[name]

							cstm.func(add, settab, combolist, callback)

						elseif data["stype"] == "default" then
							local function callback(stype, ...)
								local vars = {...}
								if stype == "language" then
									addon_language = vars[1]
									if add.info.language ~= addon_language then
										settings_changed = true
									end
								elseif stype == "skin" then
									addon_active_skin = vars[1]
									if add.info.active_skin ~= addon_active_skin then
										settings_changed = true
									end
								elseif stype == "custom_skin" then
									settab.c_themepanel = vars[1]
									settings_on_close_any(settab.c_themepanel)
								end

								if settings_changed then
									needrestart = true
								end
							end

							local name = data["key"]
							local cstm = esclib:GetAllDefaultTabs()[name]

							cstm.func(add, settab, combolist, callback)
						end
					end


					local phrase_unsaved = esclib.addon:Translate("phrase_Unsaved", add:GetLanguage())
					function dobar:Paint(w,h)
						-- draw.RoundedBoxEx(skin.roundsize, 0,0,w,h, clr.frame.accent,false,false,true,true)

						if settings_changed then
							draw.SimpleText(phrase_unsaved.."!", esclib:AdaptiveFont("esclib", 22, 500), w-15, h*0.5, clr.default.red, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
						end
					end

					local clearcfg_button = dobar:Add("esclib.button")
					clearcfg_button:SetSize(dobar:GetTall(),dobar:GetTall())
					clearcfg_button:SetX(dobar:GetWide()*0.5-clearcfg_button:GetWide())
					clearcfg_button:SetY(dobar:GetTall()*0.5-clearcfg_button:GetTall()*0.5)

					clearcfg_button:SetButtonText(esclib.addon:Translate("phrase_ReturnDefault", add:GetLanguage()))
					clearcfg_button:SetBorderRadius(16)

					function clearcfg_button:Paint(w,h)
						local hovered = self:IsHovered()
						esclib.draw:MaterialCentered(w*0.5,h*0.5,h*0.25,hovered and clr.button.discard_hover or clr.button.discard, esclib:GetMaterial("revert.png"))

						if hovered then
							local clr_copy = table.Copy(clr.button.discard)
							clr_copy.a = 30
							c_addonpnl:SetTargetGradientColor(clr_copy) 
						end
					end
					local hint_pnl = clearcfg_button:eAddHint(clearcfg_button:GetButtonText(),esclib:AdaptiveFont("esclib", 24, 500),TEXT_ALIGN_CENTER,settab)
					hint_pnl:SetAccentColor(clr.button.discard)

					function clearcfg_button:DoClick()
						esclib:ConfirmWindow(esclib.addon:Translate("phrase_AreYouSure", add:GetLanguage()),esclib.addon:Translate("phrase_SureToReturn", add:GetLanguage()),function(res)
							if res then
								if rname == "realm_Client" then
									add:ReturnSettingsToDefault()
									addpan:DoClick()
								elseif rname == "realm_Server" then
									net.Start("esclib.ClearServerConfig")
										net.WriteString(add.info.uid)
									net.SendToServer()
									addpan:DoClick()
								end
							end
						end)
					end

					local apply_button = dobar:Add("DButton")
					local text = esclib.addon:Translate("phrase_Save", add:GetLanguage())
					local font = esclib:AdaptiveFont("esclib", 24, 500)
					local textw, texth = esclib.util:TextSize(text, font)

					local offsety = dobar:GetTall()*0.2

					apply_button:SetSize(dobar:GetTall(),dobar:GetTall())
					apply_button:SetX(dobar:GetWide()*0.5)
					apply_button:SetY(dobar:GetTall()*0.5-apply_button:GetTall()*0.5)
					apply_button:SetText("")

					local save_mat = esclib:GetMaterial("save.png")

					local hint_pnl = apply_button:eAddHint(text, font, TEXT_ALIGN_CENTER, settab)
					hint_pnl:SetAccentColor(clr.button.apply)

					function apply_button:Paint(w,h)
						local hovered = self:IsHovered()
						esclib.draw:MaterialCentered(w*0.5,h*0.5,h*0.25,hovered and clr.button.apply_hover or clr.button.apply, save_mat)

						if hovered then
							local clr_copy = table.Copy(clr.button.apply)
							clr_copy.a = 30
							c_addonpnl:SetTargetGradientColor(clr_copy) 
						end
					end
					function apply_button:DoClick()
						save_settings()
						addpan:DoClick()
					end

					if rname == "realm_Client" and esclib:HasAdminAccess(LocalPlayer()) then
						local send2server = dobar:Add("esclib.button")
						send2server:SetSize(dobar:GetTall(),dobar:GetTall())
						send2server:SetX(5)
						
						send2server:SetButtonText(esclib.addon:Translate("phrase_SetGlobalDefault", add:GetLanguage()))
						send2server:SetBorderRadius(16)

						local cloud_material = esclib:GetMaterial("cloud.png")
						function send2server:Paint(w,h)
							local hovered = self:IsHovered()
							esclib.draw:MaterialCentered(w*0.5,h*0.5,h*0.3,hovered and clr.button.text_hover or clr.button.text, cloud_material)
						end
						send2server:eAddHint(send2server:GetButtonText(),esclib:AdaptiveFont("esclib", 20, 500),TEXT_ALIGN_CENTER,settab)

						function send2server:DoClick()
							esclib:ConfirmWindow(esclib.addon:Translate("phrase_AreYouSure", add:GetLanguage()),"",function(res)
								if res then
									add:CurrentSettingsToGlobal()
									addpan:DoClick()
								end
							end)
						end


						local req2cleancfg = dobar:Add("esclib.button")
						req2cleancfg:SetSize(dobar:GetTall(),dobar:GetTall())
						req2cleancfg:SetX(send2server:GetX()+send2server:GetWide()+5)
						
						req2cleancfg:SetButtonText(esclib.addon:Translate("phrase_BackGlobalDefault", add:GetLanguage()))
						req2cleancfg:SetBorderRadius(16)

						function req2cleancfg:Paint(w,h)
							local hovered = self:IsHovered()
							esclib.draw:MaterialCentered(w*0.5,h*0.5,h*0.25,hovered and clr.button.text_hover or clr.button.text, esclib:GetMaterial("revert.png"))
						end
						req2cleancfg:eAddHint(req2cleancfg:GetButtonText(),esclib:AdaptiveFont("esclib", 24, 500),TEXT_ALIGN_CENTER,settab)

						function req2cleancfg:DoClick()
							esclib:ConfirmWindow(esclib.addon:Translate("phrase_AreYouSure", add:GetLanguage()),esclib.addon:Translate("phrase_SureToReturn", add:GetLanguage()),function(res)
								if res then
									add:ClearGlobalConfig()
									addpan:DoClick()
								end
							end)
						end

						local infobtn = dobar:Add("esclib.button")
						infobtn:SetSize(dobar:GetTall(),dobar:GetTall())
						infobtn:SetX(req2cleancfg:GetX()+req2cleancfg:GetWide()+5)
						
						infobtn:SetButtonText(esclib.addon:Translate("phrase_AdminInfoButtons", add:GetLanguage()))
						infobtn:SetBorderRadius(16)

						function infobtn:Paint(w,h)
							esclib.draw:MaterialCentered(w*0.5,h*0.5,h*0.25,clr.default.orange, esclib:GetMaterial("info.png"))
						end
						infobtn:eAddHint(infobtn:GetButtonText(),esclib:AdaptiveFont("esclib", 20, 500),TEXT_ALIGN_CENTER,settab)
					end


					combolist:SetActive(cur_sub_realm, true)

					return combolist

				end)--build_realm

				if realm_name == cur_realm then
					timer.Simple(0, function()
						realm:SetActive(cur_realm, true)
					end)
				end
			end

			for _,rname in ipairs(tabnames) do
				if rname == "realm_Server" then
					-- build_realm(rname)
					add:RequestServerSettings(function()
						build_realm(rname)
					end)
				else
					build_realm(rname)
				end
			end

			if realm_name == cur_realm then
				realm:SetActive(cur_realm)
			end

		end

		if needaddon then
			if uid == naddon then
				open_addon_edit()
			end
		end

		function addpan:DoClick()
			open_addon_edit()
		end
	end
end

concommand.Add("esettings",function(ply,cmd,args)
	if table.IsEmpty(args) then
		esclib:opensettings()
		return
	end

	esclib:opensettings(args[1])
end)

hook.Add("OnPlayerChat","esclib.hook.open_settings",function(ply,text,isteam,isplydead)
	if ply ~= LocalPlayer() then return end
	if text == "!esettings" then
		RunConsoleCommand("esettings")
		return true
	end
end)
--PATH addons/____esclib/lua/elib/config/esc_config.lua:
esclib.config = esclib.config or {}

esclib.config.AdminAccess = esclib.config.AdminAccess or {}

function esclib:ChangeAdminAccess(user_group,access)
	self.config.AdminAccess[user_group] = access
end

function esclib:HasAdminAccess(ply)
	local ug = esclib:GetUserGroup(ply)
	return (ug == "superadmin") or self.config.AdminAccess[ug]
end

-----------------------
--# CLIENT SETTINGS #--
-----------------------
local settings = esclib:InitSettings("esclib", "client")

local tab = settings:AddTab("general")
tab:SetNameTranslateKey("tab_general")

tab:AddVar("drawblur", "bool")
:SetNameTranslateKey("s_drawblur_name")
:SetValue(true)

tab:AddVar("animtime", "float")
:SetNameTranslateKey("s_animationspeed_name")
:SetValue(0.15)
:SetMin(0.01)
:SetMax(3)

settings:End()



-----------------------
--# SERVER SETTINGS #--
-----------------------
local settings = esclib:InitSettings("esclib", "server")

local tab = settings:AddTab("general")
tab:SetNameTranslateKey("tab_general")

tab:AddVar("debug", "bool")
:SetNameTranslateKey("s_debug_name")
:SetValue(false)
:SetShared(true)

settings:End()
--PATH addons/____echat/lua/echat/config/meta.lua:
echat.addon = esclib:Addon("echat")
echat.addon:SetName("echat")
echat.addon:SetBranch("release")
echat.addon:SetVersion("1.48.0")
echat.addon:SetDescription("Chat for Gmod")
echat.addon:SetColor(Color(198,53,255))

if CLIENT then
	echat.addon:SetThumbnail(echat:GetMaterial("echat_icon.png"))
end
--PATH addons/____echat/lua/echat/core/tools/module_loader.lua:
-----------------
/// CHATMODES ///
-----------------
echat.chat_modes = echat.chat_modes or {}

function echat:AddChatMode(name, prefix)
	echat.chat_modes[name] = prefix
end
--echat:AddChatMode("Admin", "@")



---------------
/// MODULES ///
---------------
echat.Modules = echat.Modules or {}
function echat:Module(uid,enable_func,close_func,custom_check,refresh_once)
	local restart = false
	if self.Modules[uid] then restart = true end 
	self.Modules[uid] = {
		["enable"] = enable_func,
		["close"] = close_func,
		["custom_check"] = custom_check,
		["enabled"] = false,
		["refresh_once"] = refresh_once
	}
	if restart then self:Restart() end
end

function echat:GetModules()
	return self.Modules
end

function echat:LoadModule(uid,...)
	local v = self.Modules[uid]
	if not v then return end

	local new_enabled = true
	if v["custom_check"] then
		new_enabled = v["custom_check"]()
	end

	local is_enabled = v["enabled"]
	if is_enabled == new_enabled then
		if not v["refresh_once"] and new_enabled then v["enable"](...) end
		return
	else
		if new_enabled then
			v["enable"](...)
		else
			v["close"](...)
		end
	end

	v["enabled"] = new_enabled
end

function echat:LoadModules(...)
	for uid,_ in pairs(self.Modules) do
		self:LoadModule(uid,...)
	end
end
--PATH addons/____echat/lua/echat/core/modules/chatlisteners.lua:
if CLIENT then


local receivers
local currentChatText = {}
local receiverConfigs = {}
local currentConfig = {text = "", hearFunc = function() end} -- Default config is not loaded yet


local function on(bg)
    local locply = LocalPlayer()
    local clr = echat.addon:GetColors()

    --https://github.com/FPtje/DarkRP/blob/master/gamemode/modules/chat/cl_chatlisteners.lua
    
    --[[---------------------------------------------------------------------------
    addChatReceiver
    Add a chat command with specific receivers
    
    prefix: the chat command itself ("/pm", "/ooc", "/me" are some examples)
    text: the text that shows up when it says "Some people can hear you X"
    hearFunc: a function(ply, splitText) that decides whether this player can or cannot hear you.
        return true if the player can hear you
            false if the player cannot
            nil if you want to prevent the text from showing up temporarily
    ---------------------------------------------------------------------------]]
    function DarkRP.addChatReceiver(prefix, text, hearFunc)
        receiverConfigs[prefix] = {
            text = text,
            hearFunc = hearFunc
        }
    end
    
    --[[---------------------------------------------------------------------------
    removeChatReceiver
    Remove a chat command.
    
    prefix: the command, like in addChatReceiver
    ---------------------------------------------------------------------------]]
    function DarkRP.removeChatReceiver(prefix)
        receiverConfigs[prefix] = nil
    end
    
    --[[---------------------------------------------------------------------------
    Draw the results to the screen
    ---------------------------------------------------------------------------]]
    
    --here we go
    local listcfg = echat.config.chatlisteners_access_control
    local function drawChatReceivers()
        if not receivers then return end
        
        --Role / usergroup based access control
        if listcfg.enabled then
            local have_access = false

            local job = locply:getDarkRPVar("job") or "???"
            local ug = locply:GetUserGroup() or "???"

            local jobs_inversed = listcfg.jobs["__inversed__"]
            local ug_inversed = listcfg.usergroups["__inversed__"]

            --jobs
            if jobs_inversed then
                if listcfg.jobs[job] ~= true then have_access = true end
            else
                if listcfg.jobs[job] == true then have_access = true end
            end

            --usegroup
            if ug_inversed then
                if listcfg.usergroups[ug] ~= true then have_access = true end
            else
                if listcfg.usergroups[ug] == true then have_access = true end
            end

            if not have_access then return end
        end

        local font = echat:AdaptiveFont("echat", 18, 500)
        local fontHeight = draw.GetFontHeight(font)
        
        local x, y = chat.GetChatBoxPos()
        x = x + 6
        y = y - fontHeight - 5
    
        local receiversCount = #receivers
        -- No one hears you
        if receiversCount == 0 then
            esclib.draw:ShadowText(DarkRP.getPhrase("hear_noone", currentConfig.text), font, x, y, clr.default.red, nil, nil, 1)
            return
        -- Everyone hears you
        elseif receiversCount == player.GetCount() - 1 then
            esclib.draw:ShadowText(DarkRP.getPhrase("hear_everyone"), font, x, y, clr.default.green, nil, nil, 1)
            return
        end
        
        esclib.draw:ShadowText(DarkRP.getPhrase("hear_certain_persons", currentConfig.text), font, x, y - (receiversCount * (fontHeight + 4)), clr.default.green, nil, nil, 1)
        for i = 1, receiversCount, 1 do
            if not IsValid(receivers[i]) then
                receivers[i] = receivers[#receivers]
                receivers[#receivers] = nil
                continue
            end
            
            esclib.draw:ShadowText("- "..receivers[i]:Nick(), font, x, y - (i - 1) * (fontHeight + 4), clr.default.white, nil, nil, 1)
        end

    end
    
    --[[---------------------------------------------------------------------------
    Find out who could hear the player if they were to speak now
    ---------------------------------------------------------------------------]]
    local function chatGetRecipients()
        if not currentConfig then return end
    
        receivers = {}
        for _, ply in ipairs(player.GetAll()) do
            local hidePly = hook.Run("chatHideRecipient", ply)
            if not IsValid(ply) or ply == LocalPlayer() or ply:GetNoDraw() or hidePly then continue end
            
            local val = currentConfig.hearFunc(ply, currentChatText)
    
            -- Return nil to disable the chat recipients temporarily.
            if val == nil then
                receivers = nil
                return
            elseif val == true then
                table.insert(receivers, ply)
            end
        end
    end
    
    --[[---------------------------------------------------------------------------
    Called when the player starts typing
    ---------------------------------------------------------------------------]]
    local function startFind()
        local shouldDraw = hook.Call("HUDShouldDraw", GAMEMODE, "DarkRP_ChatReceivers")
        if shouldDraw == false then return end
    
        currentConfig = receiverConfigs[""]
        hook.Add("Think", "DarkRP_chatRecipients", chatGetRecipients)
        hook.Add("HUDPaint", "DarkRP_DrawChatReceivers", drawChatReceivers)
    end
    hook.Remove("StartChat", "DarkRP_StartFindChatReceivers")
    hook.Add("StartChat", "DarkRP_StartFindChatReceivers", startFind)
    
    --[[---------------------------------------------------------------------------
    Called when the player stops typing
    ---------------------------------------------------------------------------]]
    local function stopFind()
        hook.Remove("Think", "DarkRP_chatRecipients")
        hook.Remove("HUDPaint", "DarkRP_DrawChatReceivers")
    end
    hook.Remove("FinishChat", "DarkRP_StopFindChatReceivers")
    hook.Add("FinishChat", "DarkRP_StopFindChatReceivers", stopFind)
    
    --[[---------------------------------------------------------------------------
    Find out which chat command the user is typing
    ---------------------------------------------------------------------------]]
    local function findConfig(text)
        local split = string.Explode(' ', text)
        local prefix = string.lower(split[1])
    
        currentChatText = split
    
        currentConfig = receiverConfigs[prefix] or receiverConfigs[""]
    end
    hook.Remove("ChatTextChanged", "DarkRP_FindChatRecipients")
    hook.Add("ChatTextChanged", "DarkRP_FindChatRecipients", findConfig)
    
    
    --[[---------------------------------------------------------------------------
    Default chat receievers. If you want to add your own ones, don't add them to this file. Add them to a clientside module file instead.
    ---------------------------------------------------------------------------]]
    -- Load after the custom languages have been loaded
    local function loadChatReceivers()
        -- Default talk chat receiver has no prefix
        DarkRP.addChatReceiver("", DarkRP.getPhrase("talk"), function(ply)
            if GAMEMODE.Config.alltalk then return nil end
    
            return LocalPlayer():GetPos():DistToSqr(ply:GetPos()) <
                GAMEMODE.Config.talkDistance * GAMEMODE.Config.talkDistance
        end)
    
        DarkRP.addChatReceiver("/ooc", DarkRP.getPhrase("speak_in_ooc"), function(ply)
            return true 
        end)
        DarkRP.addChatReceiver("//", DarkRP.getPhrase("speak_in_ooc"), function(ply) return true end)
        DarkRP.addChatReceiver("/a", DarkRP.getPhrase("speak_in_ooc"), function(ply) return true end)
        DarkRP.addChatReceiver("/w", DarkRP.getPhrase("whisper"), function(ply) return LocalPlayer():GetPos():DistToSqr(ply:GetPos()) < GAMEMODE.Config.whisperDistance * GAMEMODE.Config.whisperDistance end)
        DarkRP.addChatReceiver("/y", DarkRP.getPhrase("yell"), function(ply) return LocalPlayer():GetPos():DistToSqr(ply:GetPos()) < GAMEMODE.Config.yellDistance * GAMEMODE.Config.yellDistance end)
        DarkRP.addChatReceiver("/me", DarkRP.getPhrase("perform_your_action"), function(ply) return LocalPlayer():GetPos():DistToSqr(ply:GetPos()) < GAMEMODE.Config.meDistance * GAMEMODE.Config.meDistance end)
        DarkRP.addChatReceiver("/g", DarkRP.getPhrase("talk_to_your_group"), function(ply)
            for _, func in pairs(GAMEMODE.DarkRPGroupChats) do
                if func(LocalPlayer()) and func(ply) then
                    return true
                end
            end
            return false
        end)
    
    
        DarkRP.addChatReceiver("/pm", "PM", function(ply, text)
            if not isstring(text[2]) then return false end
            text[2] = string.lower(tostring(text[2]))
    
            return string.find(string.lower(ply:Nick()), text[2], 1, true) ~= nil or
                string.find(string.lower(ply:SteamName()), text[2], 1, true) ~= nil or
                string.lower(ply:SteamID()) == text[2]
        end)
    
        --[[---------------------------------------------------------------------------
            Voice chat receivers
            ---------------------------------------------------------------------------]]
        local voiceDistance = GAMEMODE.Config.voiceDistance * GAMEMODE.Config.voiceDistance
        DarkRP.addChatReceiver("speak", DarkRP.getPhrase("speak"), function(ply)
            if not LocalPlayer().DRPIsTalking then return nil end
            if LocalPlayer():GetPos():DistToSqr(ply:GetPos()) > voiceDistance then return false end
    
            return not GAMEMODE.Config.dynamicvoice or ply:isInRoom()
        end)
    end
    
    loadChatReceivers()

    --[[---------------------------------------------------------------------------
    Called when the player starts using their voice
    ---------------------------------------------------------------------------]]
    local function startFindVoice(ply)
        if ply ~= LocalPlayer() then return end
    
        local shouldDraw = hook.Call("HUDShouldDraw", GAMEMODE, "DarkRP_ChatReceivers")
        if shouldDraw == false then return end
    
        currentConfig = receiverConfigs["speak"]
        hook.Add("Think", "DarkRP_chatRecipients", chatGetRecipients)
        hook.Add("HUDPaint", "DarkRP_DrawChatReceivers", drawChatReceivers)
    end
    hook.Remove("PlayerStartVoice", "DarkRP_VoiceChatReceiverFinder")
    hook.Add("PlayerStartVoice", "DarkRP_VoiceChatReceiverFinder", startFindVoice)
    
    --[[---------------------------------------------------------------------------
    Called when the player stops using their voice
    ---------------------------------------------------------------------------]]
    local function stopFindVoice(ply)
        if ply ~= LocalPlayer() then return end
    
        stopFind()
    end
    hook.Remove("PlayerEndVoice", "DarkRP_VoiceChatReceiverFinder")
    hook.Add("PlayerEndVoice", "DarkRP_VoiceChatReceiverFinder", stopFindVoice)
    
    


end

local function off(bg) 

end

local function custom_check(bg) 
    return false
end

echat:Module("ChatListeners", on, off, custom_check)



end --IF CLIENT
--PATH addons/__________scripts__loader/lua/scriptssss/integrations/sh_init.lua:
do
    local pMeta = FindMetaTable( 'Player' )
    function pMeta:getDarkRPVar( name )
        if name == 'job' then
            return self:GetJob()
        elseif name == 'money' then
            return self:GetMoney()
        elseif name == 'salary' then
            return self:GetSalary()
        elseif name == 'HasGunlicense' then
            return self:HasLicense()
        elseif name == 'wanted' then
            return self:IsWanted() == 1
        elseif name == 'Energy' then
            return self:GetHunger()
        elseif name == 'Arrested' then
            return self:GetNetVar( 'Arrest' )
        elseif name == 'wantedReason' then
            return self:WantedReson()
        end
        return self:GetNetVar( name )
    end

    function pMeta:getJobTable()
        return rp.Team[self:Team()] or false
    end
end

do
    local eMeta = FindMetaTable( 'Entity' )
    if SERVER then
        function eMeta:SetNetVar( key, value )
            if key == 'HatData' then return end
            self:onyx_SetNetVar( key, value )
        end
    end

    function eMeta:GetNetVar( key )
        return self:onyx_GetNetVar( key )
    end
end

DarkRP = DarkRP or {}
--PATH addons/__________scripts__loader/lua/scriptssss/agenda/sh_init.lua:
SCRIPTSLOADER.agenda = SCRIPTSLOADER.agenda or {}
SCRIPTSLOADER.agenda.list = SCRIPTSLOADER.agenda.list or {}
local pMeta = FindMetaTable( 'Player' )
function pMeta:getAgendaTable()
    return SCRIPTSLOADER.agenda.list[self:Team()]
end

onyx.netvar:Register( 'agenda', {
    type = TYPE_STRING,
    public = false
} )

function SCRIPTSLOADER.agenda.createAgenda( Title, Manager, Listeners )
    local agenda = {
        Manager = Manager,
        Title = Title,
        Listeners = Listeners,
        ManagersByKey = {}
    }

    for _, v in ipairs( agenda.Listeners ) do
        SCRIPTSLOADER.agenda.list[v] = agenda
    end

    for _, v in ipairs( istable( agenda.Manager ) and agenda.Manager or { agenda.Manager } ) do
        SCRIPTSLOADER.agenda.list[v] = agenda
        agenda.ManagersByKey[v] = true
    end

    if SERVER then timer.Simple( 0, function() agenda.text = hook.Run( 'agendaUpdated', nil, agenda, '' ) end ) end
end

createAgenda = SCRIPTSLOADER.agenda.createAgenda
function SCRIPTSLOADER.agenda.removeAgenda( title )
    local agenda
    for k, v in pairs( SCRIPTSLOADER.agenda.list ) do
        if v.Title == title then
            agenda = v
            SCRIPTSLOADER.agenda.list[k] = nil
        end
    end

    hook.Run( 'onAgendaRemoved', title, agenda )
end

removeAgenda = SCRIPTSLOADER.agenda.removeAgenda
---
timer.Simple( .1, function()
    createAgenda( 'Оповіщення держструктурам', TEAM_MAYOR, { TEAM_FBI, TEAM_POLICE_N, TEAM_POLICE, TEAM_ADMI3WWWdadtW, TEAM_ADMI3qwfqwN25535533543a, TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Rendjer, TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Tron, TEAM_ADMI3qwfqwN11231234444, TEAM_ADMI3qwfqwN3, TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Saitama } )
    createAgenda( 'Оповіщення кримінальному світу', TEAM_GLCRIME, { TEAM_GANG, TEAM_GANGVIP, TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Yakuza, TEAM_ADMI3qwfqwN223, TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Gopnik, TEAM_ADMI3dwae21wN3_Naruto, TEAM_ZZZZZZZZZZZZZZZZZZZZALUPA_ClausMadnos, TEAM_ADMIdwadsd123wd_YagamiLait, TEAM_ADMI3dwae21wN3_KamadoTanjiro, TEAM_ADMIPENIs2424g, TEAM_ADMI3qwfqwN2553443a, TEAM_ADMI3qwfqwN2, TEAM_ADMI3qwfqwN1, TEAM_ADMI3qwfqwN1, TEAM_ADMI3qwfqwN22, TEAM_ADMI3qwfqwN223336, TEAM_ADMI3qwfqwNYASD44, TEAM_ADMI3qwfqw12312321AAAaN, TEAM_ADMI3qwfqwN } )
    createAgenda( 'Оповіщення Армії', TEAM_VENI, { TEAM_VENI1, TEAM_VENI2, TEAM_ADMI3dwae21wN3_Grom } )
end )
--PATH addons/__________scripts__loader/lua/scriptssss/animations/cl_init.lua:
net.Receive( "_DarkRP_CustomAnim", function()
    local ply = net.ReadEntity()
    local act = net.ReadUInt( 32 )
    if not IsValid( ply ) then return end
    ply:AnimRestartGesture( GESTURE_SLOT_CUSTOM, act, true )
end )