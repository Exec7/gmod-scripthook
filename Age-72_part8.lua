--Stealed clientside server code by exechack.cc
--Hostname: Age of Clones | Clone Wars Roleplay | Eigener Spielmodus - Part 8/12 - 06/04/2025


--PATH lua/autorun/0a_netoverride.lua:
AddCSLuaFile()

print("###############################################")
print("###############################################")
print("LOADING NETOVERRIDE WRAPPER FOR AOCRP")
print("###############################################")
print("###############################################")






if CLIENT then
        
        --[[--------------------------------------------------------------------------
        File name:
            cl_netwrapper.lua
        
        Author:
            Mista-Tea ([IJWTB] Thomas)
        
        License:
            The MIT License (copy/modify/distribute freely!)
            
        Changelog:
            - March 9th,   2014:    Created
            - April 5th,   2014:    Added to GitHub
            - August 15th, 2014:    Added Net Requests
    ----------------------------------------------------------------------------]]

    --[[--------------------------------------------------------------------------
    --		Namespace Tables 
    --------------------------------------------------------------------------]]--

    netwrapper          = netwrapper          or {}
    netwrapper.requests = netwrapper.requests or {}

    --[[--------------------------------------------------------------------------
    -- 	Localized Functions & Variables
    --------------------------------------------------------------------------]]--

    local net  = net
    local hook = hook
    local pairs = pairs
    local CurTime = CurTime
    local FindMetaTable = FindMetaTable
    local GetConVarNumber = GetConVarNumber

    local ENTITY = FindMetaTable( "Entity" )

    --[[--------------------------------------------------------------------------
    --		Namespace Functions
    --------------------------------------------------------------------------]]--

    --[[--------------------------------------------------------------------------
    --	NET VARS
    --------------------------------------------------------------------------]]--

    --[[--------------------------------------------------------------------------
    --
    --	Net - NetWrapperVar( entity, string, uint, * )
    --
    --	Retrieves a networked key/value pair from the server to assign on the entity.
    --	 The value is written on the server using WriteType, so ReadType is used
    --	 on the client to automatically retrieve the value for us without relying
    --	 on multiple functions (like ReadEntity, ReadString, etc).
    --]]--
    net.Receive( "NetWrapperVar", function( len )
        local entid  = net.ReadUInt( 16 )
        local key    = net.ReadString()
        local typeid = net.ReadUInt( 8 )      -- read the prepended type ID that was written automatically by net.WriteType(*)
        local value  = net.ReadType( typeid ) -- read the data using the corresponding type ID

        netwrapper.StoreNetVar( entid, key, value )
    end )

    --[[--------------------------------------------------------------------------
    --
    --	Hook - InitPostEntity
    --
    --	When the client has fully initialized in the server, this will send a
    --	 request to retrieve all currently networked values from the server.
    --]]--
    hook.Add( "InitPostEntity", "NetWrapperSync", function()
        net.Start( "NetWrapperVar" )
        net.SendToServer()
    end )

    --[[--------------------------------------------------------------------------
    --
    --	Hook - OnEntityCreated
    --
    --	This hook is called every time an entity is created. This will automatically
    --	 assign any networked values that are associated with the entity's EntIndex.
    --	 This saves us the trouble of polling the server to retrieve the values.
    --]]--
    hook.Add( "OnEntityCreated", "NetWrapperSync", function( ent )
        local id = ent:EntIndex()
        local values = netwrapper.GetNetVars( id )
        
        for key, value in pairs( values ) do
            ent:SetNetVar( key, value )
        end
    end )



    --[[--------------------------------------------------------------------------
    --	NET REQUESTS
    --------------------------------------------------------------------------]]--

    --[[--------------------------------------------------------------------------
    --
    --	ENTITY:SendNetRequest( key )
    --
    --	Wrapper function for netwrapper.SendNetRequest().
    --
    --]]--
    function ENTITY:SendNetRequest( key )
        netwrapper.SendNetRequest( self:EntIndex(), key )
    end

    --[[--------------------------------------------------------------------------
    --
    --	netwrapper.SendNetRequest( number, string )
    --
    --	Sends a request to the server asking for a value stored on the entity with the given key.
    --
    --	This function allows you to determine exactly when a client asks the server for a networked
    --	 variable, unlike with netwrapper NetVars which are automatically networked when a client connects to
    --	 the server or the value is broadcasted to all connected clients.
    --
    --	You can think of Net Requests as a 'need-to-know' networking scheme, where the client only 
    --	 asks for the networked variable when they need it (i.e., when you use this function).
    --
    --	Two cvars can help limit this function's potential for networking spamming:
    --		- netwrapper_request_delay: the amount of seconds that must elapse in between each request
    --		- netwrapper_max_requests:  the max amount of requests the client can send on a failed value request before stopping
    --
    --	To prevent clients from sending multiple requests for a value before the server has a chance to respond, you can use netwrapper_request_delay to determine
    --	 the amount of time that must elapse before another request can be sent. The default is 5 seconds.
    --
    --	If a request fails because the server hasn't set any data on the entity at the given key, you can send another request for the value. However,
    --	 if the client keeps requesting the same key from an entity that will never have data set on it, you can use netwrapper_max_requests to limit the number
    --	 of allowed requests before the client ultimately stops sending requests for the value altogether. The default is -1 (unlimited retries).
    --]]--
    function netwrapper.SendNetRequest( id, key )
        
        local requests = netwrapper.requests

        if ( !requests[ id ] )                  then requests[ id ] = {} end
        if ( !requests[ id ][ "NumRequests" ] ) then requests[ id ][ "NumRequests" ] = 0 end
        if ( !requests[ id ][ "NextRequest" ] ) then requests[ id ][ "NextRequest" ] = CurTime() end
        
        local maxRetries = netwrapper.MaxRequests:GetInt()
        
        -- if the client tries to send another request when they have already hit the maximum number of requests, just ignore it
        if ( maxRetries >= 0 and requests[ id ][ "NumRequests" ] >= maxRetries ) then return end
        
        -- if the client tries to send another request before the netwrapper_request_delay time has passed, just ignore it
        if ( requests[ id ][ "NextRequest" ] > CurTime() ) then return end
        
        net.Start( "NetWrapperRequest" )
            net.WriteUInt( id, 16 )
            net.WriteString( key )
        net.SendToServer()
        
        requests[ id ][ "NextRequest" ] = CurTime() + netwrapper.Delay:GetInt()
        requests[ id ][ "NumRequests" ] = requests[ id ][ "NumRequests" ] + 1
    end

    --[[--------------------------------------------------------------------------
    --
    --	Net - NetWrapperRequest
    --
    --	Received from the server when a value request has been answered. This 
    --	 will only occur when the client has send a value request and the server 
    --	 actually has a value stored at the given key.
    --]]--
    net.Receive( "NetWrapperRequest", function( bits )
        local id     = net.ReadUInt( 16 )
        local key    = net.ReadString()
        local typeid = net.ReadUInt( 8 )
        local value  = net.ReadType( typeid )
        
        Entity( id ):SetNetRequest( key, value )
    end )


    --[[--------------------------------------------------------------------------
    --
    --	Net - NetWrapperClear
    --
    --	Removes any data stored at the entity index. When a player disconnects or
    --	 an entity is removed, its index in the table will be removed to ensure that
    --	 the next entity to use the same index does not use the first entity's data
    --	 and become corrupted.
    --]]--
    net.Receive( "NetWrapperClear", function( bits )
        local id = net.ReadUInt( 16 )
        netwrapper.ClearData( id )
    end )
end



--[[--------------------------------------------------------------------------
	File name:
		sh_netwrapper.lua
	
	Author:
		Mista-Tea ([IJWTB] Thomas)
	
	License:
		The MIT License (copy/modify/distribute freely!)
		
	Changelog:
		- March 9th,   2014:    Created
		- April 5th,   2014:    Added to GitHub
		- August 15th, 2014:    Added Net Requests
----------------------------------------------------------------------------]]


--[[--------------------------------------------------------------------------
--	Namespace Tables 
--------------------------------------------------------------------------]]--

netwrapper          = netwrapper          or {}
netwrapper.ents     = netwrapper.ents     or {}
netwrapper.requests = netwrapper.requests or {}

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

local ENTITY = FindMetaTable( "Entity" )

-- This is the amount of time (in seconds) to wait before a client will send
-- another request to the server, asking for an non-networked key on an entity.
--
-- For example, if you want prop owners to NOT be networked outright (i.e., with ent:SetNetVar())
-- and instead have the client only ask the server for the owner of the prop they are currently
-- looking at, this convar determines the amount of time that must pass before they
-- can send another request for the prop owner. 
--
-- This is solely to prevent net message spamming until the value has successfully been sent to the client
-- There should be no reason it should take more than at most a few seconds for the value to be sent to the client.
--
-- Examples:
-- Value:  0 :: the client can send successive requests as soon as they want to
-- Value: >0 :: the client can send successive requests only after the specified delay has elapsed
netwrapper.Delay      = CreateConVar( "netwrapper_request_delay", 5, bit.bor( FCVAR_NOTIFY, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE ), "The number of seconds before a client can send a net request to the server"  )

-- This is the total amount of requests a client can send to the server when they are asking for
-- a value at the given key from an entity.
--
-- For example, if the client requests a value on an entity with the key "Owner", but the
-- server has not set a value on the entity at the "Owner" key yet, their number of attempted
-- requests will increment by 1.
--
-- When the max number of allowed requests has been reached, the client will no longer send
-- any more requests for the value at the given key on the entity.
--
-- Examples:
-- Value: -1 :: the client can send an unlimited amount of requests (only limited by the netwrapper_request_delay)
-- Value:  0 :: the client cannot send any requests
-- Value: >0 :: the client can send only the specified amount of requests
netwrapper.MaxRequests = CreateConVar( "netwrapper_max_requests",  -1, bit.bor( FCVAR_NOTIFY, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE ), "The number of requests a client can send when an entity does not have a value stored at the requested key" )

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--	NET VARS
--------------------------------------------------------------------------]]--


function SetGlobalNetVar( key, value, force )


	if ( netwrapper.GetNetVars( 32766 )[ key ] == value and not force ) then return end

	netwrapper.StoreNetVar( 32766, key, value )

	if ( SERVER ) then 
		netwrapper.BroadcastNetVar( 32766, key, value )
	end
end 

function GetGlobalNetVar( key, default )
	local values = netwrapper.GetNetVars( 32766 )
	if ( values[ key ] ~= nil ) then return values[ key ] else return default end
end


--[[--------------------------------------------------------------------------
--
--	ENTITY:SetNetVar( string, *, boolean [optional] )
--
--	Stores the key/value pair of the entity into a table so that we can
--	 retrieve them with ENTITY:GetNetVar( key ), and to network the data with any 
--	 clients that connect after the data has initially been networked.
--
--	Value types can be anything supported by the net library, 
--	 e.g., string, number, table, angle, vector, boolean, entity
--
--	Setting a new value on the entity using the same key will replace the original value.
--	 This allows you to change the value's type without having to use a different function,
--	 unlike the ENTITY:SetNW* library.
--
--	Trying to set the same exact value at a key will result in nothing happening. This is
--	 done to prevent unnecessary networking, since there is generally no reason to network
--	 the same value consecutively. However, if for any reason you need to network the value
--	 again, you can set the 3rd argument, 'force', to true.
--]]--
function ENTITY:SetNetVar( key, value, force )
    timer.Simple(0, function()

        if ( netwrapper.GetNetVars( self:EntIndex() )[ key ] == value and not force ) then return end

        netwrapper.StoreNetVar( self:EntIndex(), key, value )

        if ( SERVER ) then 
            netwrapper.BroadcastNetVar( self:EntIndex(), key, value )
        end
    end)
end

--[[--------------------------------------------------------------------------
--
--	ENTITY:GetNetVar( string, * )
--
--	Returns:
--	    the value of the associated key from the entity,
--	 OR the default value if this key hasn't been set and the default value was provided,
--	 OR nil if no default was provided and this key hasn't been set.
--]]--
function ENTITY:GetNetVar( key, default )
	local values = netwrapper.GetNetVars( self:EntIndex() )
	if ( values[ key ] ~= nil ) then return values[ key ] else return default end
end

--[[--------------------------------------------------------------------------
--
--	netwrapper.StoreNetVar( int, string, * )
--
--	Stores the key/value pair of the entity into a table so that we can
--	 retrieve them with ENTITY:GetNetVar( key ), and to network the data with any 
--	 clients that connect after the data has initially been networked.
--]]--
function netwrapper.StoreNetVar( id, key, value )
	netwrapper.ents[ id ] = netwrapper.ents[ id ] or {}
	netwrapper.ents[ id ][ key ] = value
end

--[[--------------------------------------------------------------------------
--
--	netwrapper.GetNetVars( id )
--
--	Retrieves any networked data on the given entity index, or an empty table if 
--	 nothing has been networked on the entity yet.
--]]--
function netwrapper.GetNetVars( id )
	return netwrapper.ents[ id ] or {}
end



--[[--------------------------------------------------------------------------
--	NET REQUESTS
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
--	ENTITY:SetNetRequest( string, * )
--
--	Stores the key/value pair of the entity into a table so that we can
--	 retrieve them with ENTITY:GetNetRequest( key ).
--
--	**UNLIKE the ENTITY:SetNetVar() function, ENTITY:SetNetRequest() does NOT network
--	 the value to connecting clients or get broadcasted to all connected clients when set.
--	 Instead, this value will be stored separately and will ONLY be networked when a client
--	 sends a request to the server asking for the specified key. For example, instead of
--	 possibly overflowing the client with networked vars from SetNetVar when they join, you can
--	 specify exactly when the client needs retrieve the value from the server.
--
--	Value types can be anything supported by the net library, 
--	 e.g., string, number, table, angle, vector, boolean, entity
--
--	Setting a new value on the entity using the same key will replace the original value.
--	 This allows you to change the value's type without having to use a different function,
--	 unlike the ENTITY:SetNW* library.
--]]--
function ENTITY:SetNetRequest( key, value )
	netwrapper.StoreNetRequest( self:EntIndex(), key, value )
end

--[[--------------------------------------------------------------------------
--
--	ENTITY:GetNetRequest( string, * )
--
--	Returns:
--	    the value of the associated key from the entity,
--	 OR the default value if this key hasn't been set and the default value was provided,
--	 OR nil if no default was provided and this key hasn't been set.
--]]--
function ENTITY:GetNetRequest( key, default )
	local values = netwrapper.GetNetRequests( self:EntIndex() )
	if ( values[ key ] ~= nil ) then return values[ key ] else return default end
end

--[[--------------------------------------------------------------------------
--
--	netwrapper.StoreNetRequest( number, string, * )
--
--	Stores the key/value pair of the entity into a table so that we can
--	 retrieve them with ENTITY:GetNetRequest( key ).
--
--	**See special notes on ENTITY:SetNetRequest()
--]]--
function netwrapper.StoreNetRequest( id, key, value )
	netwrapper.requests[ id ] = netwrapper.requests[ id ] or {}
	netwrapper.requests[ id ][ key ] = value
end

--[[--------------------------------------------------------------------------
--
--	netwrapper.GetNetRequests( number )
--
--	Retrieves any stored requested data on the given entity, or an empty table if 
--	 nothing has been stored on the entity yet.
--]]--
function netwrapper.GetNetRequests( id )
	return netwrapper.requests[ id ] or {}
end

--[[--------------------------------------------------------------------------
--
--	netwrapper.RemoveNetVars( number )
--
--	Removes any data stored at the entity index. When a player disconnects or
--	 an entity is removed, its index in the table will be removed to ensure that
--	 the next entity to use the same index does not use the first entity's data
--	 and become corrupted.
--]]--
function netwrapper.RemoveNetRequests( id )
	netwrapper.requests[ id ] = nil
end



--[[--------------------------------------------------------------------------
--
--	netwrapper.ClearData( id )
--
--	Removes any data stored at the entity index. When a player disconnects or
--	 an entity is removed, its index in the table will be removed to ensure that
--	 the next entity to use the same index does not use the first entity's data
--	 and become corrupted.
--]]--
function netwrapper.ClearData( id )
	netwrapper.ents[ id ]     = nil
	netwrapper.requests[ id ] = nil

	if ( SERVER ) then
		net.Start( "NetWrapperClear" )
			net.WriteUInt( id, 16 )
		net.Broadcast()
	end
end



if SERVER then
    
    --[[--------------------------------------------------------------------------
	File name:
		sv_netwrapper.lua
	
	Author:
		Mista-Tea ([IJWTB] Thomas)
	
	License:
		The MIT License (copy/modify/distribute freely!)
			
	Changelog:
		- March 9th,   2014:    Created
		- April 5th,   2014:    Added to GitHub
		- August 15th, 2014:    Added Net Requests
----------------------------------------------------------------------------]]


--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

netwrapper          = netwrapper          or {}
netwrapper.ents     = netwrapper.ents     or {}
netwrapper.requests = netwrapper.requests or {}

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

local net = net
local util = util
local pairs = pairs
local IsEntity = IsEntity
local CreateConVar = CreateConVar
local FindMetaTable = FindMetaTable

util.AddNetworkString( "NetWrapperVar" )
util.AddNetworkString( "NetWrapperRequest" )
util.AddNetworkString( "NetWrapperClear" )

local ENTITY = FindMetaTable( "Entity" )

--[[--------------------------------------------------------------------------
-- 	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--	NET VARS
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
--	Net - NetWrapperVar
--
--	Received when a player fully initializes with the InitPostEntity hook.
--	 This will sync all currently networked entities to the client.
--]]--
net.Receive( "NetWrapperVar", function( len, ply )
	netwrapper.SyncClient( ply )
end )

--[[--------------------------------------------------------------------------
--
--	netwrapper.SyncClient( player )
--
--	Loops through every entity currently networked and sends the networked
--	 data to the client.
--
--	While looping, any values that are NULL (disconnected players, removed entities) 
--	 will automatically be removed from the table and not synced to the client.
--]]--
function netwrapper.SyncClient( ply )
	for id, values in pairs( netwrapper.ents ) do			
		for key, value in pairs( values ) do
			if ( IsEntity( value ) and !value:IsValid() ) then 
				netwrapper.ents[ id ][ key ] = nil 
				continue; 
			end
			
			netwrapper.SendNetVar( ply, id, key, value )
		end			
	end
end

--[[--------------------------------------------------------------------------
--
--	netwrapper.BroadcastNetVar( int, string, * )
--
--	Sends a net message to all connectect clients containing the
--	 key/value pair to assign on the associated entity.
--]]--
function netwrapper.BroadcastNetVar( id, key, value )
	net.Start( "NetWrapperVar" )
		net.WriteUInt( id, 16 )
		net.WriteString( key )
		net.WriteType( value )
	net.Broadcast()
end

--[[--------------------------------------------------------------------------
--
--	netwrapper.SendNetVar( player, int, string, * )
--
--	Sends a net message to the specified client containing the
--	 key/value pair to assign on the associated entity.
--]]--
function netwrapper.SendNetVar( ply, id, key, value )
	net.Start( "NetWrapperVar" )
		net.WriteUInt( id, 16 )
		net.WriteString( key )
		net.WriteType( value )
	net.Send( ply )
end



--[[--------------------------------------------------------------------------
--	NET REQUESTS
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
--	Net - NetWrapperRequest
--
--	Received from a client when they are requesting a certain key on an entity
--	 that was set using ENTITY:SetNetRequest().
--
--	**UNLIKE the NetVars portion of the netwrapper library, Net Requests are stored
--	 on the server and are ONLY networked when the client sends a request for it.
--	 This can be incredibly helpful in reducing network traffic for connecting clients
--	 when you have data that doesn't need to be networked instantly.
--
--	For example, if you wanted to network the owner's name of a prop to clients, but
--	 fear you may be sending too much network traffic to connecting clients because there
--	 are hundreds or thousands of props out, you can use ENTITY:SetNetRequest() instead.
--	 When the client looks at a prop, you can add a check to see if ENTITY:GetNetRequest()
--	 doesn't return anything and then use ENTITY:SendNetRequest() to request the prop owner's
--	 name from the server.
--]]--
net.Receive( "NetWrapperRequest", function( bits, ply )
	local id  = net.ReadUInt( 16 )
	local ent = Entity( id )
	local key = net.ReadString()
	
	if ( ent:GetNetRequest( key ) ~= nil ) then
		netwrapper.SendNetRequest( ply, id, key, ent:GetNetRequest( key ) )
	end
end )

--[[--------------------------------------------------------------------------
--
--	netwrapper.SendNetRequest( player, number, string, * )
--
--	Called when a client is asking the server to network a stored value on entity
--	 with the given key. In combination with ENTITY:SendNetRequest() on the client,
--	 these functions give you control of when a client asks for entity values to be
--	 networked to them, unlike the netwrapper.SendNetVar() function.
--]]--
function netwrapper.SendNetRequest( ply, id, key, value )
	net.Start( "NetWrapperRequest" )
		net.WriteUInt( id, 16 )
		net.WriteString( key )
		net.WriteType( value )
	net.Send( ply )
end

--[[--------------------------------------------------------------------------
-- 
-- 	Hook - EntityRemoved( entity )
-- 
-- 	Called when an entity has been removed. This will automatically remove the
-- 	 data at the entity's index if any was being networked. This will prevent
-- 	 data corruption where a future entity may be using the data from a previous
--	 entity that used the same EntIndex
--]]--
hook.Add( "EntityRemoved", "NetWrapperClear", function( ent )
	netwrapper.ClearData( ent:EntIndex() )
end )
end

















if AOCRP_NetOverride then return end
AOCRP_NetOverride = AOCRP_NetOverride or {}


local plyMeta = FindMetaTable("Player")
local entMeta = FindMetaTable("Entity")


AOCRP_NetOverride.StatsSet = {}
local function AddStatsSet(ident)
    if !AOCRP_NetOverride.StatsSet[ident] then
        AOCRP_NetOverride.StatsSet[ident] = 1
    else
        AOCRP_NetOverride.StatsSet[ident] = AOCRP_NetOverride.StatsSet[ident] + 1
    end
end

AOCRP_NetOverride.StatsGet = {}
local function AddStatsGet(ident)
    if !AOCRP_NetOverride.StatsGet[ident] then
        AOCRP_NetOverride.StatsGet[ident] = 1
    else
        AOCRP_NetOverride.StatsGet[ident] = AOCRP_NetOverride.StatsGet[ident] + 1
    end
end

--[[ concommand.Add( "netov_showstats", function( ply, cmd, args )
    for k, v in pairs(AOCRP_NetOverride.StatsSet) do
        print("Setter - Ident: "..k .." - Calls: "..v)
    end
    for k, v in pairs(AOCRP_NetOverride.StatsGet) do
        print("Getter - Ident: "..k .." - Calls: "..v)
    end
end ) ]]

local NWOverride = function(self, ident, var)
    --if AOCRP.Config.NetOverrideDebug then AddStatsSet(ident) end
    self:SetNetVar(ident,var)
end



local NWOverrideGet = function(self, ident, var)
    --if AOCRP.Config.NetOverrideDebug then AddStatsGet(ident) end
    return self:GetNetVar(ident,var)
end

print("[!Invasiver Eingriff!] >> SetNW* Override")

--timer.Simple(0, function() 
    print("[!Invasiver Eingriff!] >> SetNW* Override now in progress")
    plyMeta.SetNWString = NWOverride
    plyMeta.SetNW2String = NWOverride
    plyMeta.SetNetworkedString = NWOverride
    plyMeta.SetNetworked2String = NWOverride

    plyMeta.GetNWString = NWOverrideGet
    plyMeta.GetNW2String = NWOverrideGet
    plyMeta.GetNetworkedString = NWOverrideGet
    plyMeta.GetNetworked2String = NWOverrideGet

    plyMeta.SetNWInt = NWOverride
    plyMeta.SetNW2Int = NWOverride
    plyMeta.SetNetworkedInt = NWOverride
    plyMeta.SetNetworked2Int = NWOverride

    plyMeta.GetNWInt = NWOverrideGet
    plyMeta.GetNW2Int = NWOverrideGet
    plyMeta.GetNetworkedInt = NWOverrideGet
    plyMeta.GetNetworked2Int = NWOverrideGet

    plyMeta.SetNWFloat = NWOverride
    plyMeta.SetNW2Float = NWOverride
    plyMeta.SetNetworkedFloat = NWOverride
    plyMeta.SetNetworked2Float = NWOverride

    plyMeta.GetNWFloat = NWOverrideGet
    plyMeta.GetNW2Float = NWOverrideGet
    plyMeta.GetNetworkedFloat = NWOverrideGet
    plyMeta.GetNetworked2Float = NWOverrideGet


    plyMeta.SetNWEntity = NWOverride
    plyMeta.SetNW2Entity = NWOverride
    plyMeta.SetNetworkedEntity = NWOverride
    plyMeta.SetNetworked2Entity = NWOverride


    plyMeta.GetNWEntity = NWOverrideGet
    plyMeta.GetNW2Entity = NWOverrideGet
    plyMeta.GetNetworkedEntity = NWOverrideGet
    plyMeta.GetNetworked2Entity = NWOverrideGet



    plyMeta.SetNWBool = NWOverride
    plyMeta.SetNW2Bool = NWOverride
    plyMeta.SetNetworkedBool = NWOverride
    plyMeta.SetNetworked2Bool = NWOverride


    plyMeta.GetNWBool = NWOverrideGet
    plyMeta.GetNW2Bool = NWOverrideGet
    plyMeta.GetNetworkedBool = NWOverrideGet
    plyMeta.GetNetworked2Bool = NWOverrideGet

    plyMeta.SetNWAngle = NWOverride
    plyMeta.SetNW2Angle = NWOverride
    plyMeta.SetNetworkedAngle = NWOverride
    plyMeta.SetNetworked2Angle = NWOverride

    plyMeta.GetNWAngle = NWOverrideGet
    plyMeta.GetNW2Angle = NWOverrideGet
    plyMeta.GetNetworkedAngle = NWOverrideGet
    plyMeta.GetNetworked2Angle = NWOverrideGet


    plyMeta.SetNWVector = NWOverride
    plyMeta.SetNW2Vector = NWOverride
    plyMeta.SetNetworkedVector = NWOverride
    plyMeta.SetNetworked2Vector = NWOverride

    plyMeta.GetNWVector = NWOverrideGet
    plyMeta.GetNW2Vector = NWOverrideGet
    plyMeta.GetNetworkedVector = NWOverrideGet
    plyMeta.GetNetworked2Vector = NWOverrideGet

    plyMeta.SetNW2Var = NWOverride
    plyMeta.SetNetworked2Var = NWOverride

    plyMeta.GetNW2Var = NWOverrideGet
    plyMeta.GetNetworked2Var = NWOverrideGet


    entMeta.SetNWString = NWOverride
    entMeta.SetNW2String = NWOverride
    entMeta.SetNetworkedString = NWOverride
    entMeta.SetNetworked2String = NWOverride

    entMeta.GetNWString = NWOverrideGet
    entMeta.GetNW2String = NWOverrideGet
    entMeta.GetNetworkedString = NWOverrideGet
    entMeta.GetNetworked2String = NWOverrideGet

    entMeta.SetNWInt = NWOverride
    entMeta.SetNW2Int = NWOverride
    entMeta.SetNetworkedInt = NWOverride
    entMeta.SetNetworked2Int = NWOverride

    entMeta.GetNWInt = NWOverrideGet
    entMeta.GetNW2Int = NWOverrideGet
    entMeta.GetNetworkedInt = NWOverrideGet
    entMeta.GetNetworked2Int = NWOverrideGet

    entMeta.SetNWFloat = NWOverride
    entMeta.SetNW2Float = NWOverride
    entMeta.SetNetworkedFloat = NWOverride
    entMeta.SetNetworked2Float = NWOverride

    entMeta.GetNWFloat = NWOverrideGet
    entMeta.GetNW2Float = NWOverrideGet
    entMeta.GetNetworkedFloat = NWOverrideGet
    entMeta.GetNetworked2Float = NWOverrideGet


    entMeta.SetNWEntity = NWOverride
    entMeta.SetNW2Entity = NWOverride
    entMeta.SetNetworkedEntity = NWOverride
    entMeta.SetNetworked2Entity = NWOverride


    entMeta.GetNWEntity = NWOverrideGet
    entMeta.GetNW2Entity = NWOverrideGet
    entMeta.GetNetworkedEntity = NWOverrideGet
    entMeta.GetNetworked2Entity = NWOverrideGet



    entMeta.SetNWBool = NWOverride
    entMeta.SetNW2Bool = NWOverride
    entMeta.SetNetworkedBool = NWOverride
    entMeta.SetNetworked2Bool = NWOverride


    entMeta.GetNWBool = NWOverrideGet
    entMeta.GetNW2Bool = NWOverrideGet
    entMeta.GetNetworkedBool = NWOverrideGet
    entMeta.GetNetworked2Bool = NWOverrideGet

    entMeta.SetNWAngle = NWOverride
    entMeta.SetNW2Angle = NWOverride
    entMeta.SetNetworkedAngle = NWOverride
    entMeta.SetNetworked2Angle = NWOverride

    entMeta.GetNWAngle = NWOverrideGet
    entMeta.GetNW2Angle = NWOverrideGet
    entMeta.GetNetworkedAngle = NWOverrideGet
    entMeta.GetNetworked2Angle = NWOverrideGet


    entMeta.SetNWVector = NWOverride
    entMeta.SetNW2Vector = NWOverride
    entMeta.SetNetworkedVector = NWOverride
    entMeta.SetNetworked2Vector = NWOverride

    entMeta.GetNWVector = NWOverrideGet
    entMeta.GetNW2Vector = NWOverrideGet
    entMeta.GetNetworkedVector = NWOverrideGet
    entMeta.GetNetworked2Vector = NWOverrideGet

    entMeta.SetNW2Var = NWOverride
    entMeta.SetNetworked2Var = NWOverride

    entMeta.GetNW2Var = NWOverrideGet
    entMeta.GetNetworked2Var = NWOverrideGet
--end)

--addons/arccw_weapons/lua/arccw/shared/attachments/15a_barrel_short.lua:
att.PrintName = "15a Short-barrel"
att.Description = "Short length custom barrel. Improves handling, though offers much worse range and accuracy."
att.SortOrder = 40
att.Icon = Material("interfaz/armas/swrp_att_e11_top1.png")
att.Desc_Pros = {}
att.Desc_Cons = {}

att.AutoStats = true

att.Slot = "15a_barrel"
att.ActivateElements = {"15a_barrel_short"}

att.Mult_Range = 0.75
att.Mult_Recoil = 1.25
att.Mult_SightTime = 0.8
att.Mult_AccuracyMOA = 2

att.Mult_ShootPitch = 1.1
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_gl_bacta.lua:
att.PrintName = "Bacta Grenade Launcher"
att.Icon = Material("interfaz/iconos/kraken/jedi scoun sawbones/1520358450_3114066081.png")
att.Description = "Throwable grenade with healing capacity."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.AutoStats = true
att.Slot = "ammo_rocket"

att.SortOrder = 1738
att.Override_ShootEntity = "tfa_battlefront_ent_nade_heal"
att.Mult_SightTime = 1.25
att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_heatbased.lua:
att.PrintName = "Heat-Based Weapon"
att.Icon = Material("interfaz/armas/sw_powercell1.png")
att.Description = "The weapon has now infinite ammo at the heat cost. You'll do less damage and it will decay more in distance."
att.Override_MuzzleEffect = nil
att.Override_Tracer = nil
att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.NotForNPCs = true
att.AutoStats = true
att.Slot = "ammo"

att.Override_InfiniteAmmo = true
att.Override_BottomlessClip = true
att.Override_Jamming = true
att.Mult_HeatCapacity = 1
att.Mult_FixTime = 1
att.Mult_HeatGain = 2
att.Mult_HeatDissipation = 5
att.Mult_HeatDelayTime = 1
att.Override_HeatLockout = true 

att.Mult_ShootPitch = 1.1
att.Reload = 0.9
att.Mult_DamageMin = 0.74
att.Mult_Recoil = 1.2
att.Mult_SightTime = 1
att.Mult_RPM = 0.8
att.Mult_Damage = 0.85
att.Mult_MuzzleVelocity = 0.9
--addons/arccw_weapons/lua/arccw/shared/attachments/ammo_rocket_he.lua:
att.PrintName = "High Explosive"
att.Icon = Material("entities/acwatt_ammo_rpg7_he.png")
att.Description = "Load high explosive rockets that have a greater splash radius but no HEAT jet, reducing impact damage."
att.Desc_Pros = {
    "Large Splash Radius"
}
att.Desc_Cons = {
    "Reduced Impact Damage",
}
att.AutoStats = true
att.Slot = "ammo_rocket"

att.Mult_SightTime = 0.9
att.Mult_MoveSpeed = 1.15

att.Override_ShootEntity = "arccw_rocket_he"
--addons/arccw_weapons/lua/arccw/shared/attachments/dc17_powerpack.lua:
att.PrintName = "Powerpack"
att.Description = "More magazine capacity at the cost of less damage."

att.Desc_Pros = {
}
att.Desc_Cons = {
}

att.AutoStats = true
att.Slot = "dc17_powerpack"
att.ActivateElements = {"dc17_powerpack"}

att.Mult_MoveSpeed = 0.9
att.Mult_MoveDispersion = 1.01
att.Mult_SightTime = 1.15
att.Mult_AccuracyMOA = 0.8
att.Mult_ShootPitch = 0.95
att.OverrideClipSize = 29
--addons/arccw_weapons/lua/arccw/shared/attachments/dc17m_mag_sniper_ext.lua:
att.PrintName = "DC-17m Sniper Magazine Ext."
att.SortOrder = 100
att.Icon = Material("entities/snipermag_ext.png")
att.Description = "Special magazine designed for the DC-17m Modular."
att.Desc_Pros = {}
att.Desc_Cons = {}

att.Slot = "17m_mag"
att.ActivateElements = {"17m_mag_sniper_ext"}

att.AutoStats = true
att.HideIfBlocked = true
att.Override_ClipSize = 15

att.Mult_Penetration = 5
att.Mult_DamageMin = 1
att.Mult_Damage = 2

att.Mult_SightTime = 1.05
att.Mult_Sway = 1
att.Mult_SpeedMult = 0.85
att.Mult_ShootSpeedMult = 0.90
att.Mult_DrawTime = 1.15
att.Mult_HolsterTime = 1.15
att.Mult_HipDispersion = 2
--addons/arccw_weapons/lua/arccw/shared/attachments/gl_stun.lua:
att.PrintName = "Grenade Launcher (Stun)"
att.Icon = Material("interfaz/armas/sw_stungrenade.png")
att.Description = "Grenade Launcher module. Replaces a charged tibanna cartridge with a grenade launcher one."
att.Desc_Pros = {
    "pro.ubgl",
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "info.toggleubgl"
}
att.AutoStats = true
att.Slot = "ubgl_module"

att.SortOrder = 1738

att.MountPositionOverride = 0

att.UBGL = true
att.UBGL_BaseAnims = false
att.UBGL_PrintName = "Grenade Launcher (Stun)"
att.UBGL_Automatic = false
--att.UBGL_MuzzleEffect = "swrp_muzzleflash_blue"
att.UBGL_ClipSize = 1
att.UBGL_Ammo = "Grenade"
att.UBGL_RPM = 1200
att.UBGL_Recoil = 2
att.UBGL_Capacity = 1

att.AddSuffix = "Grenadier"

att.Hook_ShouldNotSight = function(wep)
    return wep:GetInUBGL()
end

local function Ammo(wep)
    return wep.Owner:GetAmmoCount("Grenade")
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    wep:PlayAnimation("Reload", 1, true, nil, nil, nil, true)

    wep:FireRocket("tfa_battlefront_ent_nade_stun", 1000)

    if wep.MW2_M203isGP25 then
        wep:EmitSound("armas3/gl_fire_1.wav", 100)
    else
        wep:EmitSound("armas3/gl_fire_4.wav", 100)
    end

    wep:SetClip2(wep:Clip2() - 1)

    wep:DoEffects()
end

att.UBGL_Reload = function(wep, ubgl)
    if wep:Clip2() >= 1 then return end

    if Ammo(wep) <= 0 then return end

    wep:PlayAnimation("reload", 1, true, nil, nil, nil, true)
    wep:SetReloading(CurTime() + wep:GetAnimKeyTime("reload"))

    local reserve = Ammo(wep)

    reserve = reserve + wep:Clip2()

    local clip = 1

    local load = math.Clamp(clip, 0, reserve)

    wep.Owner:SetAmmo(reserve - load, "Grenade")

    wep:SetClip2(load)
end

att.Mult_SightTime = 1.25
-- att.Mult_SpeedMult = 0.8
att.Mult_SightedSpeedMult = 0.85
--addons/arccw_weapons/lua/arccw/shared/attachments/perk_masita_commando.lua:
att.PrintName = "The Commando"
att.Icon = Material("interfaz/iconos/kraken/sith snip marksmanship/265384158_3363115073.png")
att.Description = "You're a Commando, an ace when it comes to Blaster Carabines or Rifles. Your reload speed and accuracy will increase when using an assault or carabine blaster along other benefits."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "perk"

att.NotForNPC = true

att.Mult_AccuracyMOA = 0.1
att.Mult_HipDispersion = 0.25
att.Mult_Damage = 1.5
att.Mult_Range = 2
att.Mult_Penetration = 3
att.Mult_ReloadTime = 0.65

att.Hook_Compatible = function(wep)
    if (wep.Primary.Ammo ~= "ar2" and wep.Primary.Ammo ~= "smg1") then return false end
end
--addons/arccw_weapons/lua/arccw/shared/attachments/perk_masita_firebug.lua:
att.PrintName = "Firebug"
att.Icon = Material("interfaz/iconos/kraken/jedi juns sharpshooter/1833947853_761929952.png")
att.Description = "You're a Firebug, fire is everything to you."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "perk"

att.NotForNPC = true

att.Hook_BulletHit = function(wep, data)
    if CLIENT then return end

    local ent = data.tr.Entity

    ent:Ignite(5, 500)
    if ent:IsOnFire() then
        ent:SetHealth(ent:Health() - 2.5)
    end
end
--addons/arccw_weapons/lua/arccw/shared/attachments/sw_stun.lua:
att.PrintName = "[ Starwars ] Stun Rounds"
att.AbbrevName = "Stun round (5 seconds)"
att.SortOrder = -2
att.Icon = Material("")
att.Description = "Stun round."

att.Desc_Pros = {
    "Causes stun for 5 seconds!"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}

att.Slot = {"sw_ammo"}

att.SortOrder = -9001
att.AutoStats = true

att.Override_AmmoPerShot = 5
att.Override_Num_Priority = 9001
att.Override_Tracer = "effect_sw_laser_blue_stun"

att.Hook_BulletHit = function(wep, data)
	GMSERV:AddStatus(data.tr.Entity, data.att, "stun", 5, 5, true) --Entity,Owner,Status Effect Type (Yes, you can add the others),Duration, Damage, ParticleEffect
end

att.Hook_GetShootSound = function(wep, sound)
    return false
end

att.Hook_AddShootSound = function(wep, data)
    wep:MyEmitSound("w/stun_sound.wav", data.volume, data.pitch, 1, CHAN_WEAPON - 1)
end
--addons/arccw_weapons/lua/arccw/shared/attachments/sw_stun30.lua:
att.PrintName = "Betäubung - 30s"
att.AbbrevName = "Betäubung - 30s"
att.Icon = Material("interfaz/iconos/dpsicon3.png")
att.Description = "Replace the main-fire for stun rounds."

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"aocrp_ammo"}

att.AutoStats = true
att.Override_AmmoPerShot = 5
att.Override_Tracer = "effect_sw_laser_blue_stun"
att.Hook_BulletHit = function(wep, data)
	GMSERV:AddStatus(data.tr.Entity, data.att, "stun", 30, 1, true) --Entity,Owner,Status Effect Type (Yes, you can add the others),Duration, Damage, ParticleEffect
end
att.Hook_GetShootSound = function(wep, sound)
    return false
end
att.Hook_AddShootSound = function(wep, data)
    wep:MyEmitSound("everfall/weapons/republic/stun.wav", data.volume, data.pitch, 1, CHAN_WEAPON - 1)
end
--lua/arccw/shared/attachments/uc_40mm_hornetnest.lua:
att.PrintName = "40mm 'Hornet's Nest' Grenades"
att.AbbrevName = "Hornet's Nest"
att.Icon = Material("entities/att/arccw_uc_40mm_generic.png", "mips smooth")
att.Description = "Aftermarket grenades that fit 16 .22 LR cartridges.\nMade to circumvent legal restrictions, these grenades are less lethal but more accurate than an equivalent 40mm buckshot round."
att.Desc_Pros = {
    "uc.40mm.hornet"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_40mm"

att.AutoStats = true

att.Override_ShootEntity = false
att.Override_Num = 16

att.Override_Damage = 12 * 16
att.Override_DamageMin = 5 * 16

att.Override_Range = 60
att.Override_RangeMin = 15
att.Override_HullSize = 0.1

att.Override_AccuracyMOA = 25
att.Mult_Recoil = 0.4

-- att.Mult_AccuracyMOA = 1

att.ActivateElements = {"40mm_hornetnest"}

att.Hook_GetShootSound = function(wep, fsound)
    if fsound == wep.ShootSound then return ")^/arccw_uc/common/gl_fire_hornet.ogg" end
end

att.Hook_GetDistantShootSound = function(wep, distancesound)
    if distancesound == wep.DistantShootSound then
        return ")^/arccw_uc/common/gl_fire_hornet_dist.ogg" end
end

if engine.ActiveGamemode() == "urbanstrife" then
    att.PenetrationAmmoType = "plinking"
end
--lua/arccw/shared/attachments/uc_fg_light.lua:
att.PrintName = "Light Bolt"

att.Icon = Material("entities/att/arccw_uc_lightbolt.png", "mips smooth")
att.Description = "A low weight set of bolt components increase the cyclic speed of the weapon at the cost of recoil absorption."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_fg"
att.AutoStats = true
att.SortOrder = 3

att.Mult_Recoil = 1.25
att.Mult_RPM = 1.1
att.Mult_CycleTime = 0.9

--[[]
att.Hook_Compatible = function(wep)
    if wep:GetIsManualAction() then
        return false
    end
end
]]

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"
--lua/arccw/shared/attachments/uc_fg_longrifling.lua:
att.PrintName = "Long Rifling"

att.Icon = Material("entities/att/arccw_uc_longrifling.png", "mips smooth")
att.Description = "Custom rifling improves muzzle velocity, allowing the weapon to shoot further."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"uc_fg","uc_fg_singleshot"}
att.AutoStats = true
att.SortOrder = 1

att.Hook_Compatible = function(wep)
    if wep:GetIsShotgun() then
        return false
    end
end

att.Mult_Range = 1.1

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"
--lua/arccw/shared/attachments/uc_fg_match_single.lua:
att.PrintName = "Match Trigger"

att.Icon = Material("entities/att/arccw_uc_matchgradetrigger.png", "mips smooth")
att.Description = "Hair trigger for competition shooting allows crisp trigger pulls, improving first shot performance."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"uc_fg_singleshot"}
att.SortOrder = 2
att.AutoStats = true

att.Hook_Compatible = function(wep)
    if wep:GetIsManualAction() or wep:GetIsShotgun() then
        return false
    end
end

att.Mult_Recoil = .75

--[[]
att.M_Hook_Mult_AccuracyMOA = function(wep, data)
    if wep:GetBurstCount() == 0 then
        data.mult = data.mult * 0.5
    end
end
]]

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"

att.Ignore = true
--lua/arccw/shared/attachments/uc_muzzle_supp_giraffe.lua:
att.PrintName = "ATA Giraffe Suppressor" -- fictional
att.AbbrevName = "Giraffe Suppressor"
att.Icon = Material("entities/att/acwatt_uc_muzzle_supp_giraffe.png", "mips smooth")
att.Description = "Traps propellant gas from the muzzle, reducing visual and audible report.\nExtremely long suppressor tube provides excellent noise reduction, but is also very unwieldy."
att.Desc_Neutrals = {"uc.supptail"}

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/weapons/arccw/atts/uc_longass_silencer.mdl"
att.ModelOffset = Vector(2.1, 0, 0.00)
att.ModelScale = Vector(0.9, 1.25, 1.25)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.IsMuzzleDevice = true

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 0.7
att.Mult_Range = 1.2

att.Add_BarrelLength = 10
att.Mult_SightTime = 1.15
att.Mult_SightedSpeedMult = 0.9
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"

att.Hook_GetDistantShootSound = function(wep, distancesound)
    if wep:GetBuff("PhysBulletMuzzleVelocity") < ArcCW.UC.SubsonicThreshold then
        return false
    end
end
--lua/arccw/shared/attachments/uc_muzzle_supp_salvo.lua:
att.PrintName = "Salvo 12 Suppressor"
att.Icon = Material("entities/att/acwatt_uc_muzzle_supp_salvo.png", "mips smooth")
att.Description = "Traps propellant gas from the muzzle, reducing visual and audible report.\nLow profile and relatively lightweight, with no negative ballistic impact."
att.Desc_Neutrals = {"uc.muzzleblocking", "uc.exclusive.shotgun"}

att.AutoStats = true
att.Slot = {"muzzle_shotgun","muzzle"}

att.GivesFlags = {"muzzleblocking"}
att.ExcludeFlags = {"nomuzzleblocking"}

att.SortOrder = 150

att.Model = "models/weapons/arccw/atts/ud_silencer_salvo.mdl"
att.ModelOffset = Vector(-1, 0, -0.12)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.IsMuzzleDevice = true

att.Mult_ShootPitch = 1.05
att.Mult_ShootVol = 0.8

att.Add_BarrelLength = 8
att.Mult_SightTime = 1.1
att.Mult_HipDispersion = 1.1
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() then
        return false
    end
end
--lua/arccw/shared/attachments/uc_optic_elcan.lua:
att.PrintName = "ELCAN C79 (2.5x)"
att.Icon = Material("entities/att/acwatt_uc_optic_elcan.png", "mips smooth")
att.Description = "Durable, dependable, and venerable medium-range combat scope built to stand up to constant heavy fire.\nEquipped with backup iron sights for use in emergencies."

att.SortOrder = 2.5

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Neutrals = {"uc.bus"}

att.AutoStats = true
att.Slot = {"optic", "ud_optic", "ud_acog"}

att.Model = "models/weapons/arccw/atts/uc_gso_elcan.mdl"
att.ModelOffset = Vector(0, 0, 0)
att.ModelScale = Vector(1, 1, 1)
att.OffsetAng = Angle(0, 0, 0)

att.AdditionalSights = {
    {
        Pos = Vector(0, 8, -1.51577),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ViewModelFOV = 38,
        IgnoreExtra = true,
        CrosshairInSights = false,
        HolosightBone = "holosight",
        HolosightData = {
            Holosight = true,
            HolosightReticle = Material("hud/scopes/uc_elcan.png", "smooth"),
            HolosightNoFlare = true,
            HolosightSize = 11.5,
            HolosightPiece = "models/weapons/arccw/atts/uc_gso_elcan_hsp.mdl",
            HolosightBlackbox = true,
            HolosightMagnification = UC_HalfScope( 2.5 ),
            Colorable = true,
        },
    },
    {
        Pos = Vector(0, 11, -2.62),
        Ang = Angle(-0.25, 0, 0),
        Magnification = 1.1,
        IgnoreExtra = true,
        HolosightData = {
            Holosight = false,
        },
    },
}

att.Colorable = true
att.HolosightPiece = "models/weapons/arccw/atts/uc_gso_elcan_hsp.mdl"

att.Mult_SightedSpeedMult = 0.75
--lua/arccw/shared/attachments/uc_tac_tlr2hl.lua:
att.PrintName = "TLR-2 HL Pistol Flashlight"
att.AbbrevName = "TLR-2 HL"
att.Icon = Material("entities/att/acwatt_uc_tac_tlr2hl.png", "mips smooth")
att.Description = "A combined flashlight and laser module for pistols.\nThe laser and flashlight can be toggled individually."
att.Desc_Pros = {
    "uc.light"
}
att.Desc_Cons = {
    "con.light"
}
att.Desc_Neutrals = {}
att.AutoStats = true

att.Slot = {"tac","tac_pistol"}
att.SortOrder = 20+4

att.Model = "models/weapons/arccw/atts/uc_tlr2hl.mdl"
att.ModelOffset = Vector(0.75, 0, -0.1)
att.OffsetAng = Angle(0,0,0)
att.ModelScale = Vector(0.75, 0.75, 0.75)

att.Laser = false
att.LaserStrength = 2 / 5
att.LaserBone = "laser"

att.ColorOptionsTable = {Color(255, 0, 0, 150)}

att.Mult_SightTime = 1.05
att.Mult_SightedSpeedMult = 0.95
att.Mult_MoveSpeed = 1

att.Flashlight = false
att.FlashlightFOV = 50
att.FlashlightFarZ = 1024 -- how far it goes
att.FlashlightNearZ = 1 -- how far away it starts
att.FlashlightAttenuationType = ArcCW.FLASH_ATT_LINEAR -- LINEAR, CONSTANT, QUADRATIC are available
att.FlashlightColor = Color(255, 235, 229)
att.FlashlightTexture = "effects/flashlight001"
att.FlashlightBrightness = 0.5
att.FlashlightBone = "laser"

att.ToggleStats = {
    {
        PrintName = "Laser",
        Laser = true,
        Mult_HipDispersion = 0.8,
        Mult_MoveDispersion = 0.8
    },
    {
        PrintName = "Both",
        Laser = true,
        Flashlight = true,
        Mult_HipDispersion = 0.8,
        Mult_MoveDispersion = 0.8
    },
    {
        PrintName = "Light",
        Flashlight = true,
    },
    {
        PrintName = "Off",
    }
}
--lua/arccw/shared/attachments/uc_tp_technician.lua:
att.PrintName = "Technician"

att.Icon = Material("entities/att/arccw_uc_tp_technician.png", "smooth mips")
att.Description = "Life around this particular firearm has given you a solid understanding of its mechanism. When it malfunctions, you can clear the jam with enough speed to stay in the fight."
att.Desc_Pros = {
    "uc.technician"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_tp"

att.AutoStats = true
att.SortOrder = 1.5

att.Mult_MalfunctionFixTime = .65

att.Ignore = true -- MalfunctionFixTime currently only works visually (8z fix pls)

att.NotForNPCs = true
--lua/arccw/shared/attachments/uc_tp_underload.lua:
att.PrintName = "Underload"

att.Icon = Material("entities/att/arccw_uc_tp_underload.png", "smooth mips")
att.Description = "Just because it fits, does not mean you have to fill it. Partially filled magazines reduces follower stress and improves feeding rate."
att.Desc_Pros = {
}
att.Desc_Cons = {
    "uc.underload"
}
att.Desc_Neutrals = {
}
att.Slot = "uc_tp"

att.AutoStats = true
att.SortOrder = 1

function att.Hook_GetCapacity(wep, cap)
    return math.max(math.floor(cap * (1 - 0.14)), 1)
end

att.Hook_Compatible = function(wep)
    if wep.RejectMagSizeChange or wep:GetCapacity() == 1 then return false end
end


att.Mult_MalfunctionMean = 1.25
att.Mult_HeatCapacity = 1.25
att.Mult_RPM = 1.05
att.Mult_ReloadTime = 0.95

att.GivesFlags = {"ud_underload"}
att.ExcludeFlags = {"ud_loosesprings"}

att.NotForNPCs = true
--lua/arccw/shared/languages/uc_es.lua:
L = {}

L["uc.auto"] = "Conversion a automático"

L["uc.nofs"] = "Difícil saber donde apuntas"
L["uc.jam"] = "Se atascará tras un uso prolongado"
L["uc.homeboy"] = "Vuelve el retroceso diagonal"
L["uc.pointman"] = "+25% Cadencia en pistolas semi-automáticas"
--addons/arccw_base_modified/lua/arccw/shared/sh_physbullet2.lua:
ArcCW.PhysBullets = {
}

-- intentionally not 10 despite there being 10 default profiles.
-- for some reason profile indices are previously referenced as zero-indexed but stored as one-indexed
ArcCW.BulletProfileNum = 9
ArcCW.BulletProfileBits = nil
ArcCW.BulletProfiles = {
    [0] = "default0",
    [1] = "default1",
    [2] = "default2",
    [3] = "default3",
    [4] = "default4",
    [5] = "default5",
    [6] = "default6",
    [7] = "default7",
    [8] = "default8",
    [9] = "default9",
}
ArcCW.BulletProfileDict = {
    ["default0"] = {id = 0, name = "default0", color = Color(255, 225, 200)},
    ["default1"] = {id = 1, name = "default1", color = Color(255, 0, 0)},
    ["default2"] = {id = 2, name = "default2", color = Color(0, 255, 0)},
    ["default3"] = {id = 3, name = "default3", color = Color(0, 0, 255)},
    ["default4"] = {id = 4, name = "default4", color = Color(255, 255, 0)},
    ["default5"] = {id = 5, name = "default5", color = Color(255, 0, 255)},
    ["default6"] = {id = 6, name = "default6", color = Color(0, 255, 255)},
    ["default7"] = {id = 7, name = "default7", color = Color(0, 0, 0)},
    ["default8"] = {id = 8, name = "default8", color = Color(100, 255, 100)},
    ["default9"] = {id = 9, name = "default9", color = Color(100, 0, 255)},
--[[]
    ["profile_name"] = {
        color = Color(255, 255, 255),
        sprite_head = Material("effects/whiteflare"), -- set false to not draw a sprite, set nil to use default
        sprite_tail = Material("effects/smoke_trail"), -- ditto
        size = 1, -- Size growth factor of the physbullet (from distance)
        size_min = 1, -- Base size of the physbullet
        tail_length = 0.02, -- as a fraction of the bullet's velocity
        model = "models/weapons/w_bullet.mdl", -- clientside model is not created without this path
        model_nodraw = false, -- true to not draw model
        particle = "myparticle", -- requires a model path; set to nodraw if you don't wish it to be visible

        ThinkBullet = function(bulinfo, bullet) end, -- set bullet.Dead = true to stop processing and delete bullet.
        DrawBullet = function(bulinfo, bullet) end, -- return true to prevent default drawing behavior
        PhysBulletHit = function(bulinfo, bullet, tr) end,
    }
]]
}

local vector_down = Vector(0, 0, 1)

function ArcCW:AddBulletProfile(name, bulinfo)

    if istable(name) and !bulinfo then
        bulinfo = name
        name = tostring(ArcCW.BulletProfileNum + 1)
    end

    local new = !ArcCW.BulletProfileDict[name]
    if new then
        ArcCW.BulletProfileNum = ArcCW.BulletProfileNum + 1
        ArcCW.BulletProfiles[ArcCW.BulletProfileNum] = name
        ArcCW.BulletProfileBits = nil
    end
    ArcCW.BulletProfileDict[name] = bulinfo
    if new then
        ArcCW.BulletProfileDict[name].name = name
        ArcCW.BulletProfileDict[name].id = ArcCW.BulletProfileNum
    end
end

function ArcCW:BulletProfileBitNecessity()
    if !ArcCW.BulletProfileBits then
        ArcCW.BulletProfileBits = math.min(math.ceil(math.log(ArcCW.BulletProfileNum + 1, 2)), 32)
    end
    return ArcCW.BulletProfileBits
end

function ArcCW:SendBullet(bullet, attacker)
    net.Start("arccw_sendbullet", true)
    net.WriteVector(bullet.Pos)
    net.WriteAngle(bullet.Vel:Angle())
    net.WriteFloat(bullet.Vel:Length())
    net.WriteFloat(bullet.Drag)
    net.WriteFloat(bullet.Gravity)
    net.WriteUInt(bullet.Profile or 0, ArcCW:BulletProfileBitNecessity())
    net.WriteBool(bullet.PhysBulletImpact)
    net.WriteEntity(bullet.Weapon)

    if attacker and attacker:IsValid() and attacker:IsPlayer() and !game.SinglePlayer() then
        net.SendOmit(attacker)
    else
        if game.SinglePlayer() then
            net.WriteEntity(attacker)
        end
        net.Broadcast()
    end
end

function ArcCW:ShootPhysBullet(wep, pos, vel, prof, ovr)
    ovr = ovr or {}
    local pbi = ovr.PhysBulletImpact or wep:GetBuff_Override("Override_PhysBulletImpact")
    local num = ovr.Num or wep:GetBuff("Num")

    if !prof then
        prof = wep:GetBuff_Override("Override_PhysTracerProfile", wep.PhysTracerProfile) or 1
    end
    if isstring(prof) then
        prof = ArcCW.BulletProfileDict[prof].id
    end

    local bullet = {
        DamageMax = wep:GetDamage(0) / num,
        DamageMin = wep:GetDamage(math.huge) / num,
        Range = wep:GetBuff("Range"),
        DamageType = wep:GetBuff_Override("Override_DamageType", wep.DamageType),
        Penleft = wep:GetBuff("Penetration"),
        Penetration = wep:GetBuff("Penetration"),
        ImpactEffect = wep:GetBuff_Override("Override_ImpactEffect", wep.ImpactEffect),
        ImpactDecal = wep:GetBuff_Override("Override_ImpactDecal", wep.ImpactDecal),
        PhysBulletImpact = pbi == nil and true or pbi,
        Gravity = wep:GetBuff("PhysBulletGravity"),
        HullSize = wep:GetBuff("HullSize"),
        Num = num,
        Pos = pos,
        Vel = vel,
        Drag = wep:GetBuff("PhysBulletDrag"),
        Travelled = 0,
        StartTime = CurTime(),
        Imaginary = false,
        Underwater = false,
        WeaponClass = wep:GetClass(),
        Weapon = wep,
        Attacker = wep:GetOwner(),
        Filter = {wep:GetOwner()},
        Damaged = {},
        Burrowing = false,
        Dead = false,
        Profile = prof
    }
    table.Merge(bullet, ovr)

    table.Add(bullet.Filter, wep.Shields or {})

    local owner = wep:GetOwner()

    --[[]
    if owner and owner:IsNPC() then
        bullet.DamageMax = bullet.DamageMax * ArcCW.ConVars["mult_npcdamage"]:GetFloat()
        bullet.DamageMin = bullet.DamageMin * ArcCW.ConVars["mult_npcdamage"]:GetFloat()
    end
    ]]

    if SERVER and owner and owner:IsPlayer() then
        table.Add(bullet.Filter, ArcCW:GetVehicleFilter(owner) or {})
    end

    if bit.band( util.PointContents( pos ), CONTENTS_WATER ) == CONTENTS_WATER then
        bullet.Underwater = true
    end

    table.insert(ArcCW.PhysBullets, bullet)

    -- TODO: This is still bad but unless we can access FLOW_OUTGOING from inside INetChannelInfo I can't think of any better way to do this.
    if owner:IsPlayer() and SERVER then
        --local ping = owner:Ping() / 1000
        --ping = math.Clamp(ping, 0, 0.5)

        -- local latency = util.TimeToTicks((owner:Ping() / 1000) * 0.5)
        local latency = math.floor(engine.TickCount() - owner:GetCurrentCommand():TickCount() - 1) -- FIXME: this math.floor does nothing
        local timestep = engine.TickInterval()

        while latency > 0 do
            ArcCW:ProgressPhysBullet(bullet, timestep)
            latency = latency - 1
        end

        -- while ping > 0 do
        --     ArcCW:ProgressPhysBullet(bullet, timestep)
        --     ping = ping - timestep
        -- end
    end

    if SERVER then
        -- ArcCW:ProgressPhysBullet(bullet, engine.TickInterval())
        ArcCW:SendBullet(bullet, wep:GetOwner())
    end
end

if CLIENT then

net.Receive("arccw_sendbullet", function(len, ply)
    local pos = net.ReadVector()
    local ang = net.ReadAngle()
    local vel = net.ReadFloat()
    local drag = net.ReadFloat()
    local grav = net.ReadFloat()
    local profile = net.ReadUInt(ArcCW:BulletProfileBitNecessity())
    local impact = net.ReadBool()
    local weapon = net.ReadEntity()
    local ent = nil

    if game.SinglePlayer() then
        ent = net.ReadEntity()
    end

    local bullet = {
        Pos = pos,
        Vel = ang:Forward() * vel,
        Travelled = 0,
        StartTime = CurTime(),
        Imaginary = false,
        Underwater = false,
        Dead = false,
        Damaged = {},
        Drag = drag,
        Attacker = ent or weapon:GetOwner(),
        Gravity = grav,
        Profile = profile,
        PhysBulletImpact = impact,
        Weapon = weapon,
        Filter = {weapon:GetOwner()},
    }

    if bit.band( util.PointContents( pos ), CONTENTS_WATER ) == CONTENTS_WATER then
        bullet.Underwater = true
    end

    table.insert(ArcCW.PhysBullets, bullet)
end)

end

function ArcCW:DoPhysBullets()
    local new = {}
    local deltatime = engine.TickInterval()

    for _, i in pairs(ArcCW.PhysBullets) do
        ArcCW:ProgressPhysBullet(i, deltatime)
        -- On the client, bullets must live for at least one tick so we get to render it
        -- This prevents invisible tracers up close
        if !i.Dead or (CLIENT and CurTime() - i.StartTime <= engine.TickInterval()) then
            table.insert(new, i)
        elseif CLIENT and IsValid(i.CSModel) then
            i.CSModel:Remove()
            if i.CSParticle then
                i.CSParticle:StopEmission()
                i.CSParticle = nil
            end
        end
    end

    ArcCW.PhysBullets = new
end

hook.Add("Tick", "ArcCW_DoPhysBullets", ArcCW.DoPhysBullets)

local function indim(vec, maxdim)
    if math.abs(vec.x) > maxdim or math.abs(vec.y) > maxdim or math.abs(vec.z) > maxdim then
        return false
    else
        return true
    end
end

local ArcCW_BulletGravity = ArcCW.ConVars["bullet_gravity"]
local ArcCW_BulletDrag = ArcCW.ConVars["bullet_drag"]
function ArcCW:ProgressPhysBullet(bullet, timestep)
    if bullet.Dead then return end

    local oldpos = bullet.Pos
    local oldvel = bullet.Vel
    local dir = bullet.Vel:GetNormalized()
    local spd = bullet.Vel:Length() * timestep
    local drag = bullet.Drag * spd * spd * (1 / 150000)
    local gravity = timestep * ArcCW_BulletGravity:GetFloat() * (bullet.Gravity or 1)

    local attacker = bullet.Attacker

    if !IsValid(attacker) then
        bullet.Dead = true
        return
    end

    if bullet.Underwater then
        drag = drag * 3
    end

    drag = drag * ArcCW_BulletDrag:GetFloat()

    if spd <= 0.001 then bullet.Dead = true return end

    local bulinfo = ArcCW.BulletProfileDict[ArcCW.BulletProfiles[bullet.Profile or 1] or ""]
    if bulinfo == nil then
        return
    end
    if bulinfo.ThinkBullet then
        bulinfo:ThinkBullet(bullet)
    end

    local newpos = oldpos + (oldvel * timestep)
    local newvel = oldvel - (dir * drag)
    newvel = newvel - (vector_down * gravity)

    if bullet.Imaginary then
        -- the bullet has exited the map, but will continue being visible.
        bullet.Pos = newpos
        bullet.Vel = newvel
        bullet.Travelled = bullet.Travelled + spd

        if CLIENT and !ArcCW.ConVars["bullet_imaginary"]:GetBool() then
            bullet.Dead = true
        end
    else
        if attacker:IsPlayer() then
            attacker:LagCompensation(true)
        end

        local tr
        if bullet.HullSize then
            local bb = Vector(bullet.HullSize / 2, bullet.HullSize / 2, bullet.HullSize / 2)
            tr = util.TraceHull({
                start = oldpos,
                endpos = newpos,
                filter = bullet.Filter,
                mask = MASK_SHOT,
                mins = -bb,
                maxs = bb,
            })
            if ArcCW.ConVars["dev_shootinfo"]:GetInt() > 0 then
                debugoverlay.Line(oldpos, tr.HitPos, 5, SERVER and Color(100,100,255) or Color(255,200,100), true)
                debugoverlay.Box(tr.HitPos, -bb, bb, 5, SERVER and Color(100,100,255,0) or Color(255,200,100,0))
            end
        else
            tr = util.TraceLine({
                start = oldpos,
                endpos = newpos,
                filter = bullet.Filter,
                mask = MASK_SHOT
            })
            if ArcCW.ConVars["dev_shootinfo"]:GetInt() > 0 then
                debugoverlay.Line(oldpos, tr.HitPos, 5, SERVER and Color(100,100,255) or Color(255,200,100), true)
                debugoverlay.Cross(tr.HitPos, 16, 0.05, SERVER and Color(100,100,255) or Color(255,200,100), true)
            end
        end

        if attacker:IsPlayer() then
            attacker:LagCompensation(false)
        end

        if tr.HitSky then
            if CLIENT and ArcCW.ConVars["bullet_imaginary"]:GetBool() then
                bullet.Imaginary = true
            else
                bullet.Dead = true
            end

            bullet.Pos = newpos
            bullet.Vel = newvel
            bullet.Travelled = bullet.Travelled + spd

            if SERVER then
                bullet.Dead = true
            end
        elseif tr.Hit then
            bullet.Travelled = bullet.Travelled + (oldpos - tr.HitPos):Length()
            bullet.Pos = tr.HitPos
            -- if we're the client, we'll get the bullet back when it exits.

            if attacker:IsPlayer() then
                attacker:LagCompensation(true)
            end

            if SERVER then
                debugoverlay.Cross(tr.HitPos, 5, 5, Color(100,100,255), true)
            else
                debugoverlay.Cross(tr.HitPos, 5, 5, Color(255,200,100), true)
            end

            local eid = tr.Entity:EntIndex()

            if CLIENT then
                -- do an impact effect and forget about it
                if !game.SinglePlayer() and bullet.PhysBulletImpact then
                    attacker:FireBullets({
                        Src = oldpos,
                        Dir = dir,
                        Distance = spd + 16,
                        Tracer = 0,
                        Damage = 0,
                        IgnoreEntity = bullet.Attacker
                    })
                end
                bullet.Dead = true
                if IsValid(bullet.Weapon) then
                    bullet.Weapon:GetBuff_Hook("Hook_PhysBulletHit", {bullet = bullet, tr = tr})
                end
                if bullet.PhysBulletHit then
                    bullet:PhysBulletHit(bullet, tr)
                end
                if bulinfo.PhysBulletHit then
                    bulinfo:PhysBulletHit(bullet, tr)
                end
                return
            elseif SERVER then
                local dmgtable
                if IsValid(bullet.Weapon) then
                    bullet.Weapon:GetBuff_Hook("Hook_PhysBulletHit", {bullet = bullet, tr = tr})

                    dmgtable = bullet.Weapon.BodyDamageMults
                    dmgtable = bullet.Weapon:GetBuff_Override("Override_BodyDamageMults") or dmgtable
                end
                if bullet.PhysBulletHit then
                    bullet:PhysBulletHit(bullet, tr)
                end
                if bullet.PhysBulletImpact then

                    local delta = bullet.Travelled / (bullet.Range / ArcCW.HUToM)
                    delta = math.Clamp(delta, 0, 1)
                    -- deal some damage
                    attacker:FireBullets({
                        Src = oldpos,
                        Dir = dir,
                        Distance = spd + 16,
                        Tracer = 0,
                        Damage = 0,
                        IgnoreEntity = bullet.Attacker,
                        Callback = function(catt, ctr, cdmg)
                            ArcCW:BulletCallback(catt, ctr, cdmg, bullet, true)
                        end
                    }, true)
                end
                bullet.Damaged[eid] = true
                bullet.Dead = true
            end

            if attacker:IsPlayer() then
                attacker:LagCompensation(false)
            end
        else
            -- bullet did not impact anything
            bullet.Pos = tr.HitPos
            bullet.Vel = newvel
            bullet.Travelled = bullet.Travelled + spd

            if bullet.Underwater then
                if bit.band( util.PointContents( tr.HitPos ), CONTENTS_WATER ) != CONTENTS_WATER then
                    local utr = util.TraceLine({
                        start = tr.HitPos,
                        endpos = oldpos,
                        filter = bullet.Attacker,
                        mask = MASK_WATER
                    })

                    if utr.Hit then
                        local fx = EffectData()
                        fx:SetOrigin(utr.HitPos)
                        fx:SetScale(10)
                        util.Effect("gunshotsplash", fx)
                    end

                    bullet.Underwater = false
                end
            else
                if bit.band( util.PointContents( tr.HitPos ), CONTENTS_WATER ) == CONTENTS_WATER then
                    local utr = util.TraceLine({
                        start = oldpos,
                        endpos = tr.HitPos,
                        filter = bullet.Attacker,
                        mask = MASK_WATER
                    })

                    if utr.Hit then
                        local fx = EffectData()
                        fx:SetOrigin(utr.HitPos)
                        fx:SetScale(10)
                        util.Effect("gunshotsplash", fx)
                    end

                    bullet.Underwater = true
                end
            end
        end
    end

    bullet.OldPos = oldpos

    local MaxDimensions = 16384 * 4
    local WorldDimensions = 16384

    if bullet.StartTime <= (CurTime() - ArcCW.ConVars["bullet_lifetime"]:GetFloat()) then
        bullet.Dead = true
    elseif !indim(bullet.Pos, MaxDimensions) then
        bullet.Dead = true
    elseif !indim(bullet.Pos, WorldDimensions) then
        bullet.Imaginary = true
    end
end

local head = Material("particle/fire")
local tracer = Material("effects/smoke_trail")

function ArcCW:DrawPhysBullets()
    cam.Start3D()
    for _, i in pairs(ArcCW.PhysBullets) do

        local pro = i.Profile or 1
        if pro == 7 then continue end -- legacy behavior: 7 is the "invisible" tracer
        local bulinfo = ArcCW.BulletProfileDict[ArcCW.BulletProfiles[pro] or ""]

        if bulinfo == nil then
            print("Failed to find bullet info for profile " .. tostring(i) .. "!")
            continue
        end

        -- Draw function override
        if bulinfo.DrawBullet and bulinfo:DrawBullet(i) then
            continue
        end

        i.VelStart = i.VelStart or Vector(i.Vel)
        i.PosStart = i.PosStart or Vector(i.Pos)

        local rpos = i.Pos

        local vel = i.Vel - LocalPlayer():GetVelocity()
        local veldir = vel:GetNormalized()
        local dampfraction = 1

        -- Solve two problems presented by physbullets
        -- 1: they come out of the player's eyes and it looks jarring
        -- 2: they fly too fast and so tracers aren't that noticeable
        if !i.DampenVelocity then i.DampenVelocity = math.Clamp(math.floor(i.VelStart:Length() ^ (bulinfo.dampen_factor or 0.65)), 128, 4096) end
        if !i.Imaginary and i.Travelled <= i.DampenVelocity then
            if IsValid(i.Weapon) and i.Weapon:GetOwner() == LocalPlayer() then
                -- Lerp towards the muzzle position, effectively slowing and dragging the bullet back.
                -- Bullet will appear to accelerate suddenly near the threshold, but it should be too fast to notice.

                if !i.TracerOrigin then
                    i.TracerOrigin = i.Weapon:GetTracerOrigin() or i.StartPos
                end

                dampfraction = (i.Travelled / i.DampenVelocity) ^ 0.5
                rpos = LerpVector(dampfraction, i.TracerOrigin or i.PosStart, i.Pos)

                if GetConVar("developer"):GetInt() >= 2 then
                    debugoverlay.Cross(i.TracerOrigin, 2, 5, Color(255, 0, 0), true)
                    debugoverlay.Cross(rpos, 8, 5, Color(0, 255, 255), true)
                    debugoverlay.Line(rpos, i.Pos, 5, Color(250, 150, 255), true)
                    debugoverlay.Cross(i.Pos, 4, 5, Color(255, 0, 255), true)
                    debugoverlay.Text(rpos, math.Round(dampfraction, 2), 5)
                end
            else
                -- don't draw too close to the firing position if we can't lerp, or it will look ugly
                continue
            end
        end

        local col = bulinfo.color

        -- TODO: Tracer sizes are still kinda wacky
        local sqrdist = EyePos():DistToSqr(rpos)
        local distgrow = math.log(sqrdist) ^ 0.5
        local size = math.max(0, (bulinfo.size_min or 1) * 0.25 + (bulinfo.size or 1) * distgrow)
        local headsize = size * math.Clamp(sqrdist / 4000000, 1, 16)

        -- Head is less visible on the sides; it's mostly useful for the shooter and target as tracers aren't very visible from front and back
        local dot = EyeAngles():Forward():Dot(veldir)
        dot = math.Clamp(((dot * dot) - 0.5) * 2, 0, 1)
        headsize = headsize * dot
        --size = size * math.Clamp(1 - dot, 0.5, 1)

        if bulinfo.sprite_head != false then
            render.SetMaterial(bulinfo.sprite_head or head)
            render.DrawSprite(rpos, headsize, headsize, col)
        end

        if bulinfo.sprite_tracer != false and !ArcCW.ConVars["fasttracers"]:GetBool() then
            render.SetMaterial(bulinfo.sprite_tracer or tracer)
            local len = math.min(vel:Length() * (bulinfo.tail_length or 0.015), 512, (rpos - (i.TracerOrigin or i.PosStart)):Length())
            local pos2 = rpos - veldir * len
            if i.TracerOrigin and CurTime() - i.StartTime <= engine.TickInterval() then
                pos2 = rpos - (rpos - i.TracerOrigin):GetNormalized() * len
            end
            render.DrawBeam(rpos, pos2, size * 0.25, 0, 0.5, col)
            debugoverlay.Line(rpos, pos2, 7, Color(0, 255, 0), true)
        end

        if bulinfo.model then
            if !IsValid(i.CSModel) then
                i.CSModel = ClientsideModel(bulinfo.model)
                i.CSModel:SetNoDraw(bulinfo.model_nodraw)
                if bulinfo.particle then
                    i.CSParticle = CreateParticleSystem(i.CSModel, bulinfo.particle, PATTACH_ABSORIGIN_FOLLOW, 1)
                end
            end
            i.CSModel:SetPos(rpos)
            i.CSModel:SetAngles(i.Vel:Angle())
            i.CSModel:SetVelocity(i.Vel)
            if i.CSParticle then
                i.CSParticle:StartEmission()
                i.CSParticle:SetSortOrigin(IsValid(i.Weapon) and i.Weapon:GetShootSrc() or vector_origin)
            end
        end
    end
    cam.End3D()
end

hook.Add("PreDrawEffects", "ArcCW_DrawPhysBullets", ArcCW.DrawPhysBullets)

hook.Add("PostCleanupMap", "ArcCW_CleanPhysBullets", function()
    ArcCW.PhysBullets = {}
end)

-- Can't run now or files after this in load order cannot add them properly
hook.Add("InitPostEntity", "ArcCW_AddPhysBullets", function()
    hook.Run("ArcCW_InitBulletProfiles")
end)
--addons/arccw_base_modified/lua/arccw/shared/sh_truenames.lua:
hook.Add("CreateTeams", "ArcCW_TrueNames", function()
    if !ArcCW.ConVars["truenames"]:GetBool() then return end

    for _, i in pairs(weapons.GetList()) do
        local wpn = weapons.GetStored(i.ClassName)

        if wpn.TrueName then
            wpn.PrintName = wpn.TrueName
        end
    end
end)
--addons/arccw_base_modified/lua/arccw/client/cl_hud.lua:
local hide = {
    ["CHudHealth"] = true,
    ["CHudBattery"] = true,
    ["CHudAmmo"] = true,
    ["CHudSecondaryAmmo"] = true,
}

CreateClientConVar("arccw_hud_togglestats", "0")

ArcCW.HUDElementConVars = {
    ["CHudHealth"] = CreateClientConVar("arccw_hud_showhealth", "1"),
    ["CHudBattery"] = ArcCW.ConVars["hud_showhealth"],
    ["CHudAmmo"] = CreateClientConVar("arccw_hud_showammo", "1"),
    ["CHudSecondaryAmmo"] = ArcCW.ConVars["hud_showammo"],
}

local grad = Material("arccw/hud/grad.png", "mips smooth")
hook.Add("PreDrawViewModels", "ArcCW_PreDrawViewmodels_Grad", function()
    if ArcCW.InvHUD and !grad:IsError() then
        render.SetViewPort( 0, 0, ScrW(), ScrH() )
        cam.Start2D()
            surface.SetDrawColor(Color(255, 255, 255, Lerp(ArcCW.Inv_Fade-0.01, 0, 255)))
            surface.SetMaterial(grad)
            surface.DrawTexturedRect(0, 0, ScrW(), ScrH())
        cam.End2D()
    end
end)

hook.Add("HUDShouldDraw", "ArcCW_HideHUD", function(name)
    if !hide[name] then return end
    if !LocalPlayer():IsValid() then return end
    if !LocalPlayer():GetActiveWeapon().ArcCW then return end
    if ArcCW.ConVars["override_hud_off"]:GetBool() then return end
    if ArcCW.PollingDefaultHUDElements then return end
    if ArcCW.HUDElementConVars[name] and ArcCW.HUDElementConVars[name]:GetBool() == false then return end
    if engine.ActiveGamemode() == "terrortown" then return end

    return false
end)

hook.Add("RenderScreenspaceEffects", "ArcCW_ToyTown", function()
    if !LocalPlayer():IsValid() then return end
    local wpn = LocalPlayer():GetActiveWeapon()
    if !IsValid(wpn) then return end

    if !wpn.ArcCW then return end

    local delta = wpn:GetSightDelta()

    if delta < 1 then
        wpn:DoToyTown()
    end
end)

ArcCW.PollingDefaultHUDElements = false

function ArcCW:ShouldDrawHUDElement(ele)
    if !GetConVar("cl_drawhud"):GetBool() then return false end
    if ArcCW.ConVars["override_hud_off"]:GetBool() then return false end

    if engine.ActiveGamemode() == "terrortown" and (ele != "CHudAmmo") then return false end

    if ArcCW.HUDElementConVars[ele] and !ArcCW.HUDElementConVars[ele]:GetBool() then
        return false
    end

    ArcCW.PollingDefaultHUDElements = true

    if !ArcCW.ConVars["hud_forceshow"]:GetBool() and hook.Call("HUDShouldDraw", nil, ele) == false then
        ArcCW.PollingDefaultHUDElements = false
        return false
    end

    ArcCW.PollingDefaultHUDElements = false

    return true
end

local function GetFont()
    local font = "Bahnschrift"

    if ArcCW.GetTranslation("default_font") then
        font = ArcCW.GetTranslation("default_font")
    end

    if ArcCW.ConVars["font"]:GetString() != "" then
        font = ArcCW.ConVars["font"]:GetString()
    end

    return font
end

-- Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes. Yes.
-- What is the size of your ass. What is it. Tell me.
local ScreenScale_CacheC2 = {}
ArcCW.AugmentedScreenScale = function(size)
    if ScreenScale_CacheC2[size] then return ScreenScale_CacheC2[size] end

    local scrw, scrh = ScrW(), ScrH()
    if vrmod and vrmod.IsPlayerInVR(LocalPlayer()) then
        -- Other resolutions seem to cause stretching issues
        scrw = 1366
        scrh = 768
    end

    local scrwmult = ArcCW.ConVars["hud_deadzone_x"]:GetFloat() * scrw
    local scrhmult = ArcCW.ConVars["hud_deadzone_y"]:GetFloat() * scrh

    scrw, scrh = scrw - scrwmult, scrh - scrhmult

    local r = size
    r = r * (math.max(scrw, scrh) / 800)
    r = r * ArcCW.ConVars["hud_size"]:GetFloat()
    ScreenScale_CacheC2[size] = r
    return r
end

local sizes_to_make = {
    6,
    8,
    10,
    12,
    14,
    16,
    20,
    24,
    26,
    32
}

local sizes_to_make_cust2 = {
    8,
    10,
    12,
    14,
    16,
    24,
    32
}

local unscaled_sizes_to_make = {
    32,
    24
}

local function generatefonts()

    for _, i in pairs(sizes_to_make) do

        surface.CreateFont( "ArcCW_" .. tostring(i), {
            font = GetFont(),
            size = ScreenScale(i) * ArcCW.ConVars["hud_size"]:GetFloat(),
            weight = 0,
            antialias = true,
            extended = true, -- Required for non-latin fonts
        } )

        surface.CreateFont( "ArcCW_" .. tostring(i) .. "_Glow", {
            font = GetFont(),
            size = ScreenScale(i) * ArcCW.ConVars["hud_size"]:GetFloat(),
            weight = 0,
            antialias = true,
            blursize = 6,
            extended = true,
        } )

    end

    for _, i in pairs(sizes_to_make_cust2) do

        surface.CreateFont( "ArcCWC2_" .. tostring(i), {
            font = GetFont(),
            size = ArcCW.AugmentedScreenScale(i) * ArcCW.ConVars["hud_size"]:GetFloat(),
            weight = 0,
            antialias = true,
            extended = true, -- Required for non-latin fonts
        } )

        surface.CreateFont( "ArcCWC2_" .. tostring(i) .. "_Glow", {
            font = GetFont(),
            size = ArcCW.AugmentedScreenScale(i) * ArcCW.ConVars["hud_size"]:GetFloat(),
            weight = 0,
            antialias = true,
            blursize = 6,
            extended = true,
        } )

    end

    for _, i in pairs(unscaled_sizes_to_make) do

        surface.CreateFont( "ArcCW_" .. tostring(i) .. "_Unscaled", {
            font = GetFont(),
            size = i,
            weight = 0,
            antialias = true,
            extended = true,
        } )

    end

end

local og_ScreenScale = ScreenScale

local ScreenScale_Cache = {}

function ScreenScale(a)
    if ScreenScale_Cache[a] then return ScreenScale_Cache[a] end

    ScreenScale_Cache[a] = og_ScreenScale(a)
    return ScreenScale_Cache[a]
end

language.Add("SniperPenetratedRound_ammo", "Sniper Ammo")

generatefonts()
function ArcCW_Regen(full)
    if full then
        generatefonts()
        ScreenScale_Cache = {}
        ScreenScale_CacheC2 = {}
    end
    if IsValid(ArcCW.InvHUD) then
        ArcCW.InvHUD:Clear()
        ArcCW.InvHUD:Remove()
    end
end

--cvars.AddChangeCallback("arccw_dev_cust2beta",  function() ArcCW_Regen(true) end)
cvars.AddChangeCallback("arccw_hud_deadzone_x", function() ArcCW_Regen(true) end)
cvars.AddChangeCallback("arccw_hud_deadzone_y", function() ArcCW_Regen(true) end)
cvars.AddChangeCallback("arccw_hud_size",       function() ArcCW_Regen(true) end)
cvars.AddChangeCallback("arccw_font",           function() ArcCW_Regen(true) end)
hook.Add( "OnScreenSizeChanged", "ArcCW_Regen", function() ArcCW_Regen(true) end)

-- surface.CreateFont( "ArcCW_12", {
--     font = font,
--     size = ScreenScale(12),
--     weight = 0,
--     antialias = true,
-- } )

-- surface.CreateFont( "ArcCW_12_Glow", {
--     font = font,
--     size = ScreenScale(12),
--     weight = 0,
--     antialias = true,
--     blursize = 8,
-- } )

-- surface.CreateFont( "ArcCW_16", {
--     font = font,
--     size = ScreenScale(16),
--     weight = 0,
--     antialias = true,
-- } )

-- surface.CreateFont( "ArcCW_16_Glow", {
--     font = font,
--     size = ScreenScale(16),
--     weight = 0,
--     antialias = true,
--     blursize = 8,
-- } )

-- surface.CreateFont( "ArcCW_26", {
--     font = font,
--     size = ScreenScale(26),
--     weight = 0,
--     antialias = true,
-- } )

-- surface.CreateFont( "ArcCW_26_Glow", {
--     font = font,
--     size = ScreenScale(26),
--     weight = 0,
--     antialias = true,
--     blursize = 8,
-- } )
--addons/arccw_base_modified/lua/arccw/client/cl_npc.lua:
hook.Add("PopulateMenuBar", "ArcCW_NPCWeaponMenu", function (menubar)
    local menu = menubar:AddOrGetMenu("ArcCW NPC Weapons")

    menu:AddCVar("None", "gmod_npcweapon", "none")
    menu:AddSpacer()

    local weaponlist = weapons.GetList()

    table.SortByMember(weaponlist, "PrintName", true)

    local cats = {}

    for _, k in pairs(weaponlist) do
        if weapons.IsBasedOn(k.ClassName, "arccw_base") and !k.NotForNPCs and !k.PrimaryBash and k.Spawnable then
            local cat = k.Category or "Other"

            if !cats[cat] then cats[cat] = menu:AddSubMenu(cat) end

            cats[cat]:SetDeleteSelf(false)
            cats[cat]:AddCVar(k.PrintName, "gmod_npcweapon", k.ClassName)
        end
    end
end)

net.Receive("arccw_npcgiverequest", function(len, ply)
    local class = GetConVar("gmod_npcweapon"):GetString()

    net.Start("arccw_npcgivereturn")
    net.WriteString(class)
    net.SendToServer()
end)
--addons/arccw_base_modified/lua/arccw/client/cl_ttt.lua:
if engine.ActiveGamemode() != "terrortown" then return end

ArcCW.ConVars["ttt_inforoundstart"] = CreateClientConVar("arccw_ttt_inforoundstart", "1", true, false, "Whether to show ArcCW config every round.")
ArcCW.ConVars["ttt_rolecrosshair"] = CreateClientConVar("arccw_ttt_rolecrosshair", "1", true, false, "Whether to color your crosshair according to your role.")

ArcCW.TTT_AttInfo = ArcCW.TTT_AttInfo or {}

local TTTPanel = {
    { type = "h", text = "#arccw.ttt_serverhelp" },
    { type = "b", text = "#arccw.cvar.ttt_replace", var = "arccw_ttt_replace", sv = true },
    { type = "b", text = "#arccw.cvar.ammo_replace", var = "arccw_ttt_ammo", sv = true },
    { type = "b", text = "#arccw.cvar.ttt_atts", var = "arccw_ttt_atts", sv = true },
    { type = "o", text = "#arccw.cvar.ttt_customizemode", var = "arccw_ttt_customizemode", sv = true,
            choices = {[0] = "#arccw.cvar.ttt_customizemode.0", [1] = "#arccw.cvar.ttt_customizemode.1", [2] = "#arccw.cvar.ttt_customizemode.2", [3] = "#arccw.cvar.ttt_customizemode.3"}},
    { type = "o", text = "#arccw.cvar.ttt_bodyattinfo", var = "arccw_ttt_bodyattinfo", sv = true,
            choices = {[0] = "#arccw.combobox.disabled", [1] = "#arccw.cvar.ttt_bodyattinfo.1", [2] = "#arccw.cvar.ttt_bodyattinfo.2"}},
    { type = "c", text = "#arccw.cvar.ttt_bodyattinfo.help"},
}

net.Receive("arccw_ttt_bodyattinfo", function()
    local rag = net.ReadEntity()
    rag = rag:EntIndex()
    ArcCW.TTT_AttInfo[rag] = {}
    local atts = net.ReadUInt(8)
    for i = 1, atts do
        local id = net.ReadUInt(ArcCW.GetBitNecessity())
        if id != 0 then
            --ArcCW.TTT_AttInfo[rag][i] = ArcCW.AttachmentIDTable[id]
            table.insert(ArcCW.TTT_AttInfo[rag], ArcCW.AttachmentIDTable[id])
        end
    end
end)

hook.Add("TTTBodySearchPopulate", "ArcCW_PopulateHUD", function(processed, raw)

    -- Attachment Info
    local mode = ArcCW.ConVars["ttt_bodyattinfo"]:GetInt()
    local attTbl = ArcCW.TTT_AttInfo[raw.eidx]
    if attTbl and !table.IsEmpty(attTbl) and (mode == 2 or (mode == 1 and raw.detective_search)) then
        local finalTbl = {
            img    = "arccw/ttticons/arccw_dropattinfo.png",
            p = 10.5, -- Right after the murder weapon
            text = ArcCW.GetTranslation(mode == 1 and "ttt.bodyatt.founddet" or "ttt.bodyatt.found")
        }
        local count = table.Count(attTbl)
        if count == 1 then
            if !ArcCW.AttachmentTable[attTbl[1]] then return end
            local printName = ArcCW.GetTranslation("name." .. attTbl[1]) or ArcCW.AttachmentTable[attTbl[1]].PrintName
            finalTbl.text = finalTbl.text .. ArcCW.GetTranslation("ttt.bodyatt.att1", {att = printName})
        elseif count == 2 then
            if !ArcCW.AttachmentTable[attTbl[1]] or !ArcCW.AttachmentTable[attTbl[2]] then return end
            local printName1 = ArcCW.GetTranslation("name." .. attTbl[1]) or ArcCW.AttachmentTable[attTbl[1]].PrintName
            local printName2 = ArcCW.GetTranslation("name." .. attTbl[2]) or ArcCW.AttachmentTable[attTbl[2]].PrintName
            finalTbl.text = finalTbl.text .. ArcCW.GetTranslation("ttt.bodyatt.att2", {att1 = printName1, att2 = printName2})
        else
            finalTbl.text = finalTbl.text .. ArcCW.GetTranslation("ttt.bodyatt.att3")
            local comma = false
            for i, v in pairs(attTbl) do
                if v and ArcCW.AttachmentTable[v] then
                    local printName = ArcCW.GetTranslation("name." .. v) or ArcCW.AttachmentTable[v].PrintName
                    finalTbl.text = finalTbl.text .. (comma and ", " or "") .. printName
                    comma = true
                end
            end
            finalTbl.text = finalTbl.text .. "."
        end
        processed.arccw_atts = finalTbl
    end

    -- kill info
    if bit.band(raw.dmg, DMG_BUCKSHOT) == DMG_BUCKSHOT then
        processed.dmg.text = LANG.GetTranslation("search_dmg_buckshot")
        processed.dmg.img = "arccw/ttticons/kill_buckshot.png"
    elseif bit.band(raw.dmg, DMG_NERVEGAS) == DMG_NERVEGAS then
        processed.dmg.text = LANG.GetTranslation("search_dmg_nervegas")
        processed.dmg.img = "arccw/ttticons/kill_nervegas.png"
    end
end)

local function AddLine(parent, str)
    local pw, ph = parent:GetSize()
    local label = vgui.Create("DLabel", parent)
    label:SetSize(pw, ScreenScale(8))
    label:Dock(TOP)
    label:DockMargin(ScreenScale(4), ScreenScale(1), ScreenScale(4), ScreenScale(1))
    label:SetFont("ArcCW_8")
    label:SetTextColor(Color(255,255,255,255))
    label:SetText(str)
    return label
end

local infoBox = nil
local function CreateInfoBox(t)
    if infoBox then
        infoBox:Remove()
        timer.Remove("ArcCW_TTT_InfoBox")
    end

    local totalw, totalh = ScrW() * 0.25, ScrH() * 0.2
    infoBox = vgui.Create("DPanel")
    infoBox:SetSize(totalw, totalh)
    infoBox:SetPos(ScreenScale(2), ScrH() * 0.5)
    infoBox.Paint = function(span, w, h)
        surface.SetDrawColor(Color(0, 0, 0, 150))
        surface.DrawRect(0, 0, w, h)
    end

    local label = vgui.Create("DLabel", infoBox)
    label:SetSize(totalw, ScreenScale(12))
    label:Dock(TOP)
    label:DockMargin(ScreenScale(4), ScreenScale(2), ScreenScale(4), ScreenScale(2))
    label:SetTextColor(Color(255,255,255,255))
    label:SetFont("ArcCW_12")
    label:SetText(ArcCW.GetTranslation("ttt.roundinfo"))

    if ArcCW.ConVars["ttt_replace"]:GetBool() then
        AddLine(infoBox, ArcCW.GetTranslation("ttt.roundinfo.replace"))
    end

    local cmode_str = "ttt.roundinfo.cmode" .. ArcCW.ConVars["ttt_customizemode"]:GetInt()
    AddLine(infoBox, ArcCW.GetTranslation("ttt.roundinfo.cmode") .. " " .. ArcCW.GetTranslation(cmode_str))

    local att_str = ""
    local att_cvar = ArcCW.ConVars["attinv_free"]:GetBool()
    local att_cvar2 = ArcCW.ConVars["attinv_lockmode"]:GetBool()
    local att_cvar3 = ArcCW.ConVars["attinv_loseondie"]:GetBool()
    if att_cvar then
        att_str = "ttt.roundinfo.free"
    elseif att_cvar2 then
        att_str = "ttt.roundinfo.locking"
    else
        att_str = "ttt.roundinfo.inv"
    end
    att_str = ArcCW.GetTranslation(att_str)
    if att_cvar3 == 0 then
        att_str = att_str .. ", " .. ArcCW.GetTranslation("ttt.roundinfo.persist")
    elseif !att_cvar and !att_cvar2 and att_cvar3 == 2 then
        att_str = att_str .. ", " .. ArcCW.GetTranslation("ttt.roundinfo.drop")
    end
    if ArcCW.ConVars["atts_pickx"]:GetInt() > 0 then
        att_str = att_str .. ", " .. ArcCW.GetTranslation("ttt.roundinfo.pickx") .. " " .. ArcCW.ConVars["atts_pickx"]:GetInt()
    end
    AddLine(infoBox, ArcCW.GetTranslation("ttt.roundinfo.attmode") .. " " .. att_str)

    local binfo_cvar = ArcCW.ConVars["ttt_bodyattinfo"]:GetInt()
    AddLine(infoBox, ArcCW.GetTranslation("ttt.roundinfo.bmode") .. " " .. ArcCW.GetTranslation("ttt.roundinfo.bmode" .. binfo_cvar))

    if ArcCW.ConVars["ammo_replace"]:GetBool() and ArcCW.ConVars["mult_ammohealth"]:GetFloat() > 0 then
        local ainfo_cvar = ArcCW.ConVars["ammo_detonationmode"]:GetInt()
        local ainfo_str = ArcCW.GetTranslation("ttt.roundinfo.amode" .. ainfo_cvar)
        if ArcCW.ConVars["ammo_chaindet"]:GetBool() then
            ainfo_str = ainfo_str .. ", " .. ArcCW.GetTranslation("ttt.roundinfo.achain")
        end
        AddLine(infoBox, ArcCW.GetTranslation("ttt.roundinfo.amode") .. " " .. ainfo_str)
    end


    timer.Create("ArcCW_TTT_InfoBox", t, 1, function()
        if infoBox then infoBox:Remove() end
    end)
end
concommand.Add("arccw_ttt_info", function()
    CreateInfoBox(20)
end, nil, "Shows a panel detailing current ArcCW settings.")

local turnoff = true
hook.Add("TTTPrepareRound", "ArcCW_TTT_Info", function()
    if ArcCW.ConVars["ttt_inforoundstart"]:GetBool() then
        CreateInfoBox(15)
        if turnoff then
            turnoff = false
            chat.AddText(Color(255,255,255), "To turn off ArcCW config info, type 'arccw_ttt_inforoundstart 0' in console.")
        end
    end
    ArcCW.TTT_AttInfo = {}
end)

if !TTT2 then
    hook.Add("TTTSettingsTabs", "ArcCW_TTT", function(dtabs)

        local padding = dtabs:GetPadding() * 2

        local panellist = vgui.Create("DPanelList", dtabs)
        panellist:StretchToParent(0,0,padding,0)
        panellist:EnableVerticalScrollbar(true)
        panellist:SetPadding(10)
        panellist:SetSpacing(10)

        local dgui = vgui.Create("DForm", panellist)
        dgui:SetName("#arccw.menus.ttt_client")
        dgui:Help("#arccw.ttt_clienthelp")
        dgui:CheckBox("#arccw.cvar.ttt_inforoundstart", "arccw_ttt_inforoundstart")
        dgui:CheckBox("#arccw.cvar.ttt_rolecrosshair", "arccw_ttt_rolecrosshair")
        panellist:AddItem(dgui)

        local dgui2 = vgui.Create("DForm", panellist)
        dgui2:SetName("#arccw.menus.ttt_server")
        ArcCW.GeneratePanelElements(dgui2, TTTPanel)
        panellist:AddItem(dgui2)

        for menu, data in SortedPairs(ArcCW.ClientMenus) do
            local form = vgui.Create("DForm", panellist)
            form:SetName(data.text)
            data.func(form, true)
            form:SetExpanded(false)
            panellist:AddItem(form)
        end

        dtabs:AddSheet("ArcCW", panellist, "icon16/gun.png", false, false, "ArcCW")
    end)
end

-----------------------------
-- TTT2-specific support
-----------------------------

hook.Add("TTTRenderEntityInfo", "ArcCW_TTT2_Weapons", function(tData)
    local client = LocalPlayer()
    local ent = tData:GetEntity()


    if !IsValid(client) or !client:IsTerror() or !client:Alive()
    or !IsValid(ent) or tData:GetEntityDistance() > 100 or !ent:IsWeapon()
    or !ent.ArcCW or ent.Throwing then
        return
    end

    if tData:GetAmountDescriptionLines() > 0 then
        tData:AddDescriptionLine()
    end

    local pickx = ArcCW.ConVars["atts_pickx"]:GetInt()

    if !ent.CertainAboutAtts then
        tData:AddDescriptionLine("??? Attachments")
    elseif ent.Attachments and ent:CountAttachments() > 0 then
        tData:AddDescriptionLine(tostring(ent:CountAttachments()) .. (pickx > 0 and ("/" .. pickx) or "") .. ArcCW.GetTranslation("ttt.attachments"), nil)
        for i, v in pairs(ent.Attachments) do
            local attName = v.Installed
            if !attName and !v.MergeSlots then
                continue
            elseif v.MergeSlots and !attName then
                for _, s in pairs(v.MergeSlots) do
                    if ent.Attachments[s] and ent.Attachments[s].Installed then
                        attName = ent.Attachments[s].Installed
                        break
                    end
                end
                if !attName then continue end
            end
            local attTbl = ArcCW.AttachmentTable[attName]
            if attTbl and v.PrintName and attTbl.PrintName then
                local printName = ArcCW.GetTranslation("name." .. attName) or attTbl.PrintName
                tData:AddDescriptionLine(ArcCW.TryTranslation(v.PrintName) .. ": " .. printName, nil, {attTbl.Icon})
            end
        end
    end
end)

hook.Add("TTTRenderEntityInfo", "ArcCW_TTT2_Ammo", function(tData)
    local client = LocalPlayer()
    local ent = tData:GetEntity()

    if !IsValid(client) or !client:IsTerror() or !client:Alive()
    or !IsValid(ent) or tData:GetEntityDistance() > 100 or !scripted_ents.IsBasedOn(ent:GetClass(), "arccw_ammo") then
        return
    end

    -- enable targetID rendering
    tData:EnableText()
    tData:EnableOutline()
    tData:SetOutlineColor(client:GetRoleColor())

    tData:SetTitle(ent.PrintName)
    tData:SetSubtitle(ArcCW.GetTranslation("ttt.ammo") .. ent:GetNWInt("truecount", ent.AmmoCount))
end)

function ArcCW.TTT2_PopulateSettings(parent, title, tbl)

    local form = vgui.CreateTTT2Form(parent, title)

    for _, data in pairs(tbl) do

        local name = data.text
        if string.Left(name, 1) == "#" then name = string.sub(name, 2) end

        if data.type == "h" or data.type == "c" then
            form:MakeHelp({
                label = name
            })
        end

        local cvar = GetConVar(data.var or "")
        if !cvar then continue end
        local option

        if data.type == "b" then
            option = form:MakeCheckBox({
                label = name,
                default = tobool(cvar:GetDefault()),
                initial = cvar:GetBool(),
                OnChange = function(self, value)
                    ArcCW.NetworkConvar(data.var, value, self)
                end,
            })
            option.TickCreated = UnPredictedCurTime()
        elseif data.type == "i" or data.type == "f" then
               option = form:MakeSlider({
                    label = name,
                    min = data.min,
                    max = data.max,
                    decimal = data.type == "i" and 0 or 2,
                    default = tonumber(cvar:GetDefault()),
                    initial = data.type == "i" and cvar:GetInt() or cvar:GetFloat(),
                    OnChange = function(self, value)
                        ArcCW.NetworkConvar(data.var, value, self)
                    end,
                })
                option.TickCreated = UnPredictedCurTime()
        elseif data.type == "o" then
            option = form:MakeComboBox({
                label = name,
                default = tonumber(cvar:GetDefault()),
                initial = cvar:GetInt(),
                --choices = data.choices,
                OnChange = function(self, _, _, value)
                    ArcCW.NetworkConvar(data.var, value, self)
                end,
            })
            option.TickCreated = UnPredictedCurTime()
            for k, v in pairs(data.choices) do
                option:AddChoice(v, k)
            end
        end
    end
end

-- In almost all cases TTT2 lang names are identical to ISO 639-1; except for simplified / traditional Chinese
local ttt_langtranslate = {
    ["zh-cn"] = "zh_hans", -- i find it funny the original ttt's lang name for this is "simpchinese". haha simp
    ["zh-tw"] = "zh_tw",
}

-- This is only necessary in TTT2, where we use its interface for convars
function ArcCW.TTT2_LoadClientLangs()
    if !TTT2 then return end
    local files = file.Find("arccw/client/cl_languages/*", "LUA")
    for _, v in pairs(files) do
        local exp = string.Explode("_", string.lower(string.Replace(v, ".lua", "")))

        local lang = exp[#exp]
        lang = ttt_langtranslate[lang] or LANG.GetNameFromAlias(lang)

        -- cannot add to languages that do not exist
        if !LANG.IsLanguage(lang) then
            continue
        end

        include("arccw/client/cl_languages/" .. v)
        for phrase, str in pairs(L) do
            LANG.AddToLanguage(lang, phrase, str)
        end
        print("Loaded ArcCW cl_language file " .. v .. " with " .. table.Count(L) .. " strings for TTT2.")
        L = nil
    end
end
hook.Add("PostGamemodeLoaded", "ArcCW_TTT2_Localization", ArcCW.TTT2_LoadClientLangs)
--addons/sh_lounge_chatbox/lua/chatbox/cl_options.lua:
local options = {
	{
		catname = "general",
		ops = {
			{type = TYPE_NUMBER, name = "chat_x", cvar = "lounge_chat_x", min = 0, max = 1},
			{type = TYPE_NUMBER, name = "chat_y", cvar = "lounge_chat_y", min = 0, max = 1},
			{type = TYPE_NUMBER, name = "chat_width", cvar = "lounge_chat_w", min = 0.1, max = 1},
			{type = TYPE_NUMBER, name = "chat_height", cvar = "lounge_chat_h", min = 0.1, max = 1},
			{type = TYPE_NUMBER, name = "time_before_messages_hide", cvar = "lounge_chat_hidetime", min = 1, max = 300},
			{type = TYPE_BOOL, name = "show_timestamps", cvar = "lounge_chat_timestamps"},
			{type = TYPE_BOOL, name = "dont_scroll_chat_while_open", cvar = "lounge_chat_no_openscroll"},
			{
				type = "action",
				name = function()
					local siz = 0

					local pa = LOUNGE_CHAT.ImageDownloadFolder .. "/"
					local fil = file.Find(pa .. "*.png", "DATA")
					for _, f in pairs (fil) do
						siz = siz + file.Size(pa .. f, "DATA")
					end

					return LOUNGE_CHAT.Lang("clear_downloaded_images", string.NiceSize(siz))
				end
			},
		}
	},
	{
		catname = "display",
		ops = {
			{type = TYPE_BOOL, name = "hide_images", cvar = "lounge_chat_hide_images"},
			{type = TYPE_BOOL, name = "hide_avatars", cvar = "lounge_chat_hide_avatars"},
			{type = TYPE_BOOL, name = "use_rounded_avatars", cvar = "lounge_chat_roundavatars"},
			{type = TYPE_BOOL, name = "disable_flashes", cvar = "lounge_chat_disable_flashes"},
			{type = TYPE_BOOL, name = "no_url_parsing", cvar = "lounge_chat_no_url_parsing"},
			{type = TYPE_BOOL, name = "autoload_external_images", cvar = "lounge_chat_imgurl_autoload"},
			{type = TYPE_BOOL, name = "hide_options_button", cvar = "lounge_chat_hide_options"},
		}
	},
}

local matClose = Material("shenesis/chat/close.png", "noclamp smooth")

function LOUNGE_CHAT:ShowOptions()
	if (IsValid(_LOUNGE_CHAT_OPTIONS)) then
		_LOUNGE_CHAT_OPTIONS:Remove()
	end

	local scale = math.Clamp(ScrH() / 1080, 0.7, 1)
	local wi, he = 600 * scale, 700 * scale

	local pnl = vgui.Create("EditablePanel")
	pnl:SetSize(wi, he)
	pnl:Center()
	pnl:MakePopup()
	pnl.m_bF4Down = true
	pnl.Think = function(me)
		if (input.IsKeyDown(KEY_ESCAPE)) then
			me:Close()

			gui.HideGameUI()
			timer.Simple(0, gui.HideGameUI)
		end
	end
	pnl.Paint = function(me, w, h)
		draw.RoundedBox(4, 0, 0, w, h, self.Color("bg"))
	end
	pnl.Close = function(me)
		if (me.m_bClosing) then
			return end

		me.m_bClosing = true
		me:AlphaTo(0, self.Anims.FadeOutTime, 0, function()
			me:Remove()
		end)
	end
	_LOUNGE_CHAT_OPTIONS = pnl

		local th = 48 * scale
		local m = th * 0.25
		local m5 = m * 0.5

		local header = vgui.Create("DPanel", pnl)
		header:SetTall(th)
		header:Dock(TOP)
		header.Paint = function(me, w, h)
			draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("header"), true, true, false, false)
		end

			local title = self.Lang("chat_options")

			local titlelbl = self.Label(title, "LOUNGE_CHAT_24", self.Color("text"), header)
			titlelbl:Dock(LEFT)
			titlelbl:DockMargin(m, 0, 0, 0)

			local close = vgui.Create("DButton", header)
			close:SetText("")
			close:SetWide(th)
			close:Dock(RIGHT)
			close.Paint = function(me, w, h)
				if (me.Hovered) then
					draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("close_hover"), false, true, false, false)
				end

				if (me:IsDown()) then
					draw.RoundedBoxEx(4, 0, 0, w, h, self.Color("hover"), false, true, false, false)
				end

				surface.SetDrawColor(me:IsDown() and self.Color("text_down") or self.Color("text"))
				surface.SetMaterial(matClose)
				surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, 16 * scale, 16 * scale, 0)
			end
			close.DoClick = function(me)
				pnl:Close()
			end

		local body = vgui.Create("DScrollPanel", pnl)
		self.PaintScroll(body)
		body:SetDrawBackground(false)
		body:DockMargin(m, m, m, m)
		body:GetCanvas():DockPadding(m5, m5, m5, m5)
		body:Dock(FILL)
		body.Paint = function(me, w, h)
			draw.RoundedBox(4, 0, 0, w, h, self.Color("inbg"))
		end

		for _, cat in ipairs (options) do
			local lbl = self.Label(self.Lang(cat.catname), "LOUNGE_CHAT_24", self.Color("text"), body)
			lbl:Dock(TOP)
			lbl:DockMargin(0, 0, 0, m5)

			for i, op in ipairs (cat.ops) do
				local name = isfunction(op.name) and op.name() or op.name
				local mu, md = 0, 0

				local el
				if (op.type == TYPE_NUMBER) then
					local lbl = self.Label(self.Lang(name), "LOUNGE_CHAT_20", self.Color("text"), body)
					lbl:Dock(TOP)

					el = self.NumSlider(body)
					el.TextArea:SetWide(35)
					el:SetMinMax(op.min or 0, op.max or 1)
					el:SetValue(GetConVar(op.cvar):GetFloat())
					el:SetConVar(op.cvar)
				elseif (op.type == TYPE_BOOL) then
					el = self.Checkbox(name, op.cvar, body)
					mu = m5 * 0.25
					md = m5 * 0.25
				elseif (op.type == "action") then
					el = self.Button(name, body, function(me)
						local pa = LOUNGE_CHAT.ImageDownloadFolder .. "/"
						local fil = file.Find(pa .. "*.png", "DATA")
						for _, f in pairs (fil) do
							file.Delete(pa .. f)
							me:SetText(self.Lang("clear_downloaded_images", string.NiceSize(0)))
						end
					end)
					mu = m5
					el.m_bAlternateBG = true
				end

				if (IsValid(el)) then
					if (i == #cat.ops) then
						md = m5
					end

					el:Dock(TOP)
					el:DockMargin(0, mu, 0, md)
				end
			end
		end

	pnl:SetAlpha(0)
	pnl:AlphaTo(255, self.Anims.FadeInTime)
end

concommand.Add("lounge_chat_options", function()
	LOUNGE_CHAT:ShowOptions()
end)
--lua/autorun/cis_leaders.lua:
--Add Playermodel
player_manager.AddValidModel( "Poggle the Lesser", "models/player/nsn/poggle.mdl" ) 
list.Set( "PlayerOptionsModel",  "Poggle the Lesser", "models/player/nsn/poggle.mdl" ) 
player_manager.AddValidModel( "Nute Gunray", "models/player/nsn/gunray.mdl" ) 
list.Set( "PlayerOptionsModel",  "Nute Gunray", "models/player/nsn/gunray.mdl" ) 
player_manager.AddValidModel( "Wat Tambor", "models/player/nsn/wattambor_noanim.mdl" ) 
list.Set( "PlayerOptionsModel",  "Wat Tambor", "models/player/nsn/wattambor_noanim.mdl" ) 
--addons/gm_climbswep/lua/autorun/cl_falleffect.lua:
// Falling & Roll Effect for Climb SWEP2
CreateClientConVar("climbswep2_windsound", 1, true, false)
CreateClientConVar("climbswep2_falleffect_allweps", 0, true, false)
local PrevCurT = 0
local CurAngles = nil
local Rot = 0
local Random
local Snd
local Snd2
hook.Add("CreateMove", "ClimbFall", function(cmd)

    local Ply = LocalPlayer()
	if !Snd then

        Snd = CreateSound(Ply, Sound("player/heartbeat1.wav"))
        Snd:Play()
        Snd:ChangeVolume(0, 0)
        Snd:ChangePitch(100, 0)

        Snd2 = CreateSound(Ply, Sound("ambient/ambience/Wind_Light02_loop.wav"))
        Snd2:Play()
        Snd2:ChangeVolume(0, 0)

    end
    if !IsValid(Ply) or !IsValid(Ply:GetActiveWeapon()) then return
    elseif Ply:GetVelocity().z > -900 or (GetConVarNumber("climbswep2_falleffect_allweps") == 0 and Ply:GetActiveWeapon():GetClass() != "climb_swep2") or !Ply:Alive() or Ply:GetMoveType() != MOVETYPE_WALK then

        if PrevCurT > 0 then

            cmd:SetViewAngles(Angle(CurAngles.p, CurAngles.y, 0))
            CurAngles = nil
            Snd:ChangeVolume(0, 0)
            Snd:ChangePitch(100, 0)
            Snd2:ChangeVolume(0, 0)
			hook.Remove("RenderScreenspaceEffects", "ClimbFallBlur")
			PrevCurT = 0

        end		
        return

    end
    if PrevCurT == 0 then

        PrevCurT = CurTime()
        local function DrawEffect()
            --DrawMotionBlur(0.1, Time/5, 0.01)
            local Time = CurTime() - PrevCurT
            local Colour = {}
            Colour[ "$pp_colour_addr" ] = 0
            Colour[ "$pp_colour_addg" ] = 0
            Colour[ "$pp_colour_addb" ] = 0
            Colour[ "$pp_colour_brightness" ] = 0
            Colour[ "$pp_colour_contrast" ] = (1 - Time/7.5)
            Colour[ "$pp_colour_colour" ] = (1 - Time/7.5)
            Colour[ "$pp_colour_mulr" ] = 0
            Colour[ "$pp_colour_mulg" ] = 0
            Colour[ "$pp_colour_mulb" ] = 0
            DrawColorModify(Colour)
            DrawMotionBlur(math.Clamp(0.75-Time/100, 0.25, 1), math.Clamp(Time/10, 0, 0.75), 0.05)

        end
        hook.Add("RenderScreenspaceEffects", "ClimbFallBlur", DrawEffect)

    end

    if !IsValid(CurAngles) then CurAngles = cmd:GetViewAngles(); end
	

	
    local Time = (CurTime() - PrevCurT) * (8 + (CurTime() - PrevCurT) * 2)
    if Time/25 < 1 then Snd:ChangeVolume(math.Clamp(Time/25, 0, 1), 0) end
    if Time < 101 then Snd:ChangePitch(100 + Time, 0); if GetConVarNumber("climbswep2_windsound") == 1 then Snd2:ChangeVolume(Time/100, 0) else Snd2:ChangeVolume(0, 0) end end

    CurAngles.p = math.Round(CurAngles.p) < 75 and math.Round(CurAngles.p) + 0.5 or math.Round(CurAngles.p) - 0.5

    cmd:SetViewAngles(Angle(CurAngles.p, CurAngles.y + math.sin(Time) * 1.25, 0))

end)
--addons/fspectate/lua/autorun/fspectate.lua:
include("sh_cami.lua")
include("fspectate/sh_init.lua")

if SERVER then
    AddCSLuaFile("sh_cami.lua")
    AddCSLuaFile("fspectate/cl_init.lua")
    AddCSLuaFile("fspectate/sh_init.lua")

    include("fspectate/sv_init.lua")
elseif CLIENT then
    include("fspectate/cl_init.lua")
end

--addons/gm_express/lua/autorun/gm_express_init.lua:
express = {}
function express.Receive()
    error( "express.Receive called before Express has loaded! Try using the ExpressLoaded hook to know when it's safe" )
end

AddCSLuaFile( "includes/modules/sfs.lua" )
include( "gm_express/sh_init.lua" )

--addons/aocrp_map/lua/gmaps/cl_dpoieditor.lua:

local PNL = {}

function PNL:Init()
	
	self.POI = {}
	
	self:SetSize(gmaps.Config.POIInfoWidth,gmaps.Config.POIInfoWidth/1.6)
	
	InstallBlur(self)
	
	self:DockPadding(10,5,10,10)
	
	self:MoveToBack()
	
	self.Back = vgui.Create("DButton",self)
	self.Back:Dock(BOTTOM)
	self.Back:DockMargin(0,5,0,0)
	
	self.Forward = vgui.Create("DButton",self)
	self.Forward:Dock(BOTTOM)
	self.Forward:DockMargin(0,5,0,0)
	
	self:CreateElements()
	
	self:ShowNameDesc()
	
end


function PNL:CreateElements()
	
	self.Cant = vgui.Create("DListView",self)
	self.Cant:AddColumn("Can't see:")
	self.Cant:Dock(LEFT)
	self.Cant:DockMargin(0,5,0,0)
	self.Cant:SetVisible(false)
	if nut then
		for k,v in pairs(nut.faction.teams)do
			self.Cant:AddLine("Faction: "..v.name).val=v.index
		end
	else
		for k,v in pairs(team.GetAllTeams())do
			if k == TEAM_UNASSIGNED or k == TEAM_CONNECTING or k == TEAM_SPECTATOR then continue end
			self.Cant:AddLine("Team: "..v.Name).val=k
		end
	end
	for k,v in ipairs(player.GetAll()) do
		if v==LocalPlayer() then continue end
		if not IsValid(v) then continue end
		self.Cant:AddLine(" "..v:Nick()).val = v
	end
	self.Cant:SortByColumn(1)
	
	self.Can = vgui.Create("DListView",self)
	self.Can:AddColumn("Can See:")
	self.Can:Dock(RIGHT)
	self.Can:DockMargin(0,5,0,0)
	self.Can:SetVisible(false)
	self.Can:AddLine(LocalPlayer():Nick()).val=LocalPlayer()
	
	self.Right = vgui.Create("DButton",self)
	self.Right:SetSize(25,25)
	self.Right:SetFont("Marlett")
	self.Right:SetText("4")
	self.Right:SetVisible(false)
	function self.Right.DoClick()
		for k,v in pairs(self.Cant:GetSelected()) do
			local line = self.Can:AddLine(v:GetValue(1))
			line.val=v.val
			line:SetSelected(true)
			self.Cant:RemoveLine(v:GetID())
		end
		self.Can:ClearSelection()
		self.Cant:ClearSelection()
		self.Can:SortByColumn(1)
		self.Cant:SortByColumn(1)
	end
	self.RAll = vgui.Create("DButton",self)
	self.RAll:SetSize(25,25)
	self.RAll:SetText("")
	self.RAll:SetImage("gmaps/skip.png")
	self.RAll:SetVisible(false)
	function self.RAll.DoClick()
		for k,v in pairs(self.Cant:GetLines()) do
			local line = self.Can:AddLine(v:GetValue(1))
			line.val=v.val
			line:SetSelected(true)
			self.Cant:RemoveLine(v:GetID())
		end
		self.Can:ClearSelection()
		self.Cant:ClearSelection()
		self.Can:SortByColumn(1)
		self.Cant:SortByColumn(1)
	end
	
	self.Left = vgui.Create("DButton",self)
	self.Left:SetSize(25,25)
	self.Left:SetFont("Marlett")
	self.Left:SetText("3")
	self.Left:SetVisible(false)
	function self.Left.DoClick()
		for k,v in pairs(self.Can:GetSelected()) do
			if v.val==LocalPlayer() then continue end
			local line = self.Cant:AddLine(v:GetValue(1))
			line.val=v.val
			line:SetSelected(true)
			self.Can:RemoveLine(v:GetID())
		end
		self.Can:ClearSelection()
		self.Can:SortByColumn(1)
		self.Cant:SortByColumn(1)
	end
	self.LAll = vgui.Create("DButton",self)
	self.LAll:SetSize(25,25)
	self.LAll:SetText("")
	self.LAll:SetImage("gmaps/reverse.png")
	self.LAll:SetVisible(false)
	function self.LAll.DoClick()
		for k,v in pairs(self.Can:GetLines()) do
			if v.val==LocalPlayer() then continue end
			local line = self.Cant:AddLine(v:GetValue(1))
			line.val=v.val
			line:SetSelected(true)
			self.Can:RemoveLine(v:GetID())
		end
		self.Can:ClearSelection()
		self.Can:SortByColumn(1)
		self.Cant:SortByColumn(1)
	end
	
	
	self.Col = vgui.Create("DColorMixer",self)
	self.Col:SetPalette(false)
	self.Col:SetAlphaBar(false)
	self.Col:SetColor(gmaps.POIRed)
	self.Col:DockMargin(0,5,0,0)
	self.Col:Dock(FILL)
	self.Col:SetVisible(false)
	function self.Col.ValueChanged(this,new)
		self.Waypoint:SetImageColor(new)
	end
	
	self.Icons = vgui.Create("DGMapsIcons",self)
	self.Icons:SetColor(self.Col:GetColor())
	self.Icons:SetIconSize(gmaps.Config.POISize)
	self.Icons:DockMargin(0,5,0,0)
	self.Icons:Dock(FILL)
	self.Icons:SetVisible(false)
	local icons = table.Copy(gmaps.Config.Icons.Free)
	if LocalPlayer():GMapsPermission("MakeVIPIconPOI") then
		icons = table.Add(icons,gmaps.Config.Icons.VIP)
	end
	self.Icons:SetIcons(icons)
	self.Icons:Fill()
	self.Icons:SelectIcon(icons[1])--"materials/gmaps/poi/poi.png"
	function self.Icons.OnChange(this,new)
		self.Waypoint:SetMaterial(Material(new,"unlitgeneric smooth"))
	end
	
	self.Title = vgui.Create("DLabel",self)
	self.Title:Dock(TOP)
	self.Title:SetFont("gmaps_FrameTitle")
	self.Title:SetExpensiveShadow(2,Color(0,0,0,210))
	self.Title:SetContentAlignment(8)
	self.Title:SetText("Click to Edit Name")
	self.Title:SetTextColor(self.Col:GetColor())
	self.Title:SizeToContentsY()
	self.Title:SetMouseInputEnabled(true)
	self.Title:SetVisible(false)
	function self.Title.DoClick()
		self.TitleEdit:SetText(self.Title:GetText())
		self.TitleEdit:SetVisible(true)
		hook.Run( "OnTextEntryGetFocus", self.TitleEdit )	
		self.TitleEdit:SelectAll()
		self.TitleEdit:SetCaretPos(self.TitleEdit:GetValue():len())
		self.TitleEdit:RequestFocus()
		self.Title:SetVisible(false)
	end
	
	self.TitleEdit = vgui.Create("DTextEntry",self)
	self.TitleEdit:Dock(TOP)
	self.TitleEdit:SetFont("gmaps_FrameTitle")
	self.TitleEdit:SetText("Click to Edit Name")
	self.TitleEdit:ApplySchemeSettings()
	self.TitleEdit:SetTall(30)
	self.TitleEdit:SetVisible(false)
	function self.TitleEdit.OnKeyCodeTyped(this,k)
		if k == KEY_TAB then
			TextEntryLoseFocus()
			-- self.Descr:SelectAllOnFocus()
			timer.Simple(FrameTime()*3,function()
				self.Descr:DoClick()
			end)
			return true
		end
	end
	function self.TitleEdit.OnLoseFocus()
		self.TitleEdit:SetText(self.TitleEdit:GetValue():Trim())
		if !self.TitleEdit:GetValue():find("%a") then
			self.TitleEdit:SetText("Click to Edit Title")
		end
		self.TitleEdit:SetVisible(false)
		self.Title:SetVisible(true)
		self.Title:SetText(self.TitleEdit:GetValue())
		self.Title:SizeToContentsY()
	end
	
	self.Descr = vgui.Create("DLabel",self)
	self.Descr:Dock(FILL)
	self.Descr:SetFont("gmaps_Details")
	self.Descr:SetExpensiveShadow(1,Color(0,0,0,210))
	self.Descr:SetText("Click to Edit Description")
	self.Descr:SetContentAlignment(7)
	self.Descr:SizeToContentsY()
	self.Descr:SetMouseInputEnabled(true)
	self.Descr:SetVisible(false)
	function self.Descr.DoClick()
		-- self.DescrEdit:SetText(self.Descr:GetText())
		self.DescrEdit:SetVisible(true)
		hook.Run( "OnTextEntryGetFocus", self.DescrEdit )	
		self.DescrEdit:SelectAll()
		self.DescrEdit:SetCaretPos(self.DescrEdit:GetValue():len())
		self.DescrEdit:RequestFocus()
		self.Descr:SetVisible(false)
	end
	
	self.DescrEdit = vgui.Create("DTextEntry",self)
	self.DescrEdit:Dock(FILL)
	self.DescrEdit:SetFont("gmaps_Details")
	self.DescrEdit:SetText("Click to Edit Description")
	self.DescrEdit:SetMultiline(true)
	self.DescrEdit:SetContentAlignment(7)
	self.DescrEdit:ApplySchemeSettings()
	self.DescrEdit:SetVisible(false)
	function self.DescrEdit.OnLoseFocus()
		self.DescrEdit:SetText(self.DescrEdit:GetValue():Trim())
		if !self.DescrEdit:GetValue():find("%a") then
			self.DescrEdit:SetText("Click to Edit Description")
		end
		
		
		self.DescrEdit:SetVisible(false)
		self.Descr:SetVisible(true)
		self.Descr:SetText(self.DescrEdit:GetValue():Wrap(self.Descr:GetFont(),self.Descr:GetWide()))
		self.Descr:SizeToContentsY()
	end
	
	
	self.Admin = vgui.Create("DPanel",self)
	self.Admin:Dock(FILL)
	self.Admin:DockMargin(0,5,0,0)
	self.Admin:DockPadding(5,5,5,5)
	self.Admin:SetVisible(false)
	
	self.Perma = vgui.Create("DCheckBoxLabel",self.Admin)
	self.Perma:Dock(TOP)
	self.Perma:DockMargin(0,0,0,5)
	self.Perma:SetText("Make POI Permanent?")
	self.Perma:SetDark(true)
	self.Perma:SetValue(0)
	self.Perma:SizeToContents()
	self.Perma:SetVisible(LocalPlayer():GMapsPermission("MakePermanentPOI"))
	
	local container = vgui.Create("DPanel",self.Admin)
	container:DockPadding(5,5,5,5)
	container:Dock(FILL)
	container:SetVisible(LocalPlayer():GMapsPermission("MakeCustomIconPOI"))
	function container:Paint(w,h)
		surface.SetDrawColor(Color(200,200,200))
		self:DrawFilledRect()
		surface.SetDrawColor(Color(0,0,0))
		self:DrawOutlinedRect()
	end
	
	self.MatCheck = vgui.Create("DCheckBoxLabel",container)
	self.MatCheck:Dock(TOP)
	self.MatCheck:DockMargin(0,0,0,5)
	self.MatCheck:SetText("Use custom material:")
	self.MatCheck:SetDark(true)
	self.MatCheck:SetValue(false)
	self.MatCheck:SizeToContents()
	function self.MatCheck.OnChange(this,new)
		self.MatText:SetDisabled(not tobool(new))
		self.MatText:SetEditable(tobool(new))
		
		if tobool(new) then
			self.Waypoint:SetMaterial(Material(self.MatText:GetValue(),"unlitgeneric smooth"))
		else
			self.Waypoint:SetMaterial(Material(self.Icons:GetSelectedIcon(),"unlitgeneric smooth"))
		end
	end
	
	self.MatText = vgui.Create("DTextEntry",container)
	self.MatText:Dock(TOP)
	self.MatText:DockMargin(0,0,0,5)
	self.MatText:SetValue("materials/gmaps/poi/poi.png")
	self.MatText:SetEditable(false)
	self.MatText:SetDisabled(true)
	self.MatText:SetUpdateOnType(true)
	function self.MatText.OnValueChange(this,new)
		self.Waypoint:SetMaterial(Material(this:GetValue(),"unlitgeneric smooth"))
		-- self.MatPre:SetMaterial(Material(this:GetValue(),"unlitgeneric smooth"))
	end
	
	--[[self.MatPre = vgui.Create("DImage",container)
	self.MatPre:Dock(TOP)
	self.MatPre:DockMargin(0,0,0,5)
	self.MatPre:SetTall(gmaps.Config.POISize)
	self.MatPre:SetKeepAspect(true)
	self.MatPre:SetImageColor(self.Col:GetColor())
	self.MatPre:SetMaterial(Material(self.MatText:GetValue(),"unlitgeneric smooth"))
	function self.MatPre.Paint(this,w,h)
		this:PaintAt(0,0,h,h)
	end]]
	
	self.ResultIcon = vgui.Create("DImage",self)
	self.ResultIcon:DockMargin(0,8,0,0)
	self.ResultIcon:Dock(TOP)
	self.ResultIcon:SetTall(66)
	self.ResultIcon:SetVisible(false)
	function self.ResultIcon.Paint(this,w,h)
		h = h-2
		local col = this:GetImageColor()
		this:SetImageColor(Color(0,0,0,200))
		this:PaintAt(w/2-h/2+2,0+2,h,h)
		this:SetImageColor(col)
		this:PaintAt(w/2-h/2,0,h,h)
	end
	self.ResultIcon.Icons = {
		[NOTIFY_GENERIC] = Material("materials/gmaps/success.png","unlitgeneric smooth"),
		[NOTIFY_ERROR] = Material("materials/gmaps/error.png","unlitgeneric smooth"),
		[NOTIFY_HINT] = Material("materials/gmaps/warn.png","unlitgeneric smooth"),
	}
	
	
	local container = vgui.Create("DPanel",self)
	container:DockPadding(7,5,7,5)
	container:DockMargin(0,12,0,0)
	container:Dock(FILL)
	function container.Paint(this,w,h)
		surface.SetDrawColor(Color(200,200,200))
		this:DrawFilledRect()
		surface.SetDrawColor(Color(0,0,0))
		-- surface.SetDrawColor(self.ResultIcon:GetImageColor())
		this:DrawOutlinedRect()
	end
	container:SetVisible(false)
	
	self.Result = vgui.Create("DLabel",container)
	self.Result:Dock(FILL)
	self.Result:SetWrap(true)
	self.Result:SetDark(true)
	self.Result:SetFont("gmaps_Details")
	-- self.Result:SetFont("Trebuchet24")
	self.Result:SetContentAlignment(7)
	self.Result:InvalidateLayout(true)
	-- self.Result:SetVisible(false)
	-- self.Result:SetTextColor(Color(55,206,0))
	
	self.WaitingBar = vgui.Create("DProgress",self)
	self.WaitingBar:Dock(BOTTOM)
	self.WaitingBar:DockMargin(0,5,0,0)
	self.WaitingBar:SetFraction(0)
	self.WaitingBar:SetVisible(false)
	-- self.WaitingBar:SetColor(self.Col:GetColor())
	
end

function PNL:ShowNameDesc()
	self:SizeTo(gmaps.Config.POIInfoWidth,gmaps.Config.POIInfoWidth/1.6,.5)
	self.Forward:SetText("Next")
	self.Back:SetText("Cancel")
	
	self.Descr:SetVisible(true)
	self.Title:SetVisible(true)
	self.Title:SetTextColor(self.Col:GetColor())
	
	function self.Back.DoClick(this)
		self:Remove()
	end
	function self.Forward.DoClick(this)
		self:SizeTo(400,400/1.6,.5)
		self.Descr:SetVisible(false)
		self.Title:SetVisible(false)
		self.TitleEdit:SetVisible(false)
		self.DescrEdit:SetVisible(false)
		self:ShowIcons()
	end
	
end

function PNL:ShowIcons()
	self.Forward:SetText("Next")
	self.Back:SetText("Back")
	
	self.Icons:SetVisible(true)
	self.Icons:SetColor(self.Col:GetColor())
	
	function self.Back.DoClick(this)
		self.Icons:SetVisible(false)
		self:ShowNameDesc()
	end
	function self.Forward.DoClick(this)
		self.Icons:SetVisible(false)
		self:ShowColor()
	end
	
end

function PNL:ShowColor()

	self.Forward:SetText("Next")
	self.Back:SetText("Back")
	
	self.Col:SetVisible(true)
	
	function self.Back.DoClick(this)
		self.Col:SetVisible(false)
		self:ShowIcons()
	end
	function self.Forward.DoClick(this)
		self.Col:SetVisible(false)
		self:ShowPrivacy()
	end
	
end

function PNL:ShowPrivacy()
	if LocalPlayer():GMapsPermission("MakeCustomIconPOI") or LocalPlayer():GMapsPermission("MakePermanentPOI") then
		self.Forward:SetText("Next")
	else
		self.Forward:SetText("Finish")
	end
	self.Back:SetText("Back")
	
	self.Cant:SetVisible(true)
	self.Can:SetVisible(true)
	self.Right:SetVisible(true)
	self.Left:SetVisible(true)
	self.LAll:SetVisible(true)
	self.RAll:SetVisible(true)
	
	local w,h = self:GetSize()
	self.Can:SetWide(w/2-28)
	self.Cant:SetWide(w/2-28)
	
	local o = 63
	self.RAll:AlignTop(o+9-5-25)
	self.RAll:CenterHorizontal()
	
	self.Right:AlignTop(o+9)
	self.Right:CenterHorizontal()
	
	self.Left:CenterHorizontal()
	self.Left:AlignTop(o+25+5+9)
	
	self.LAll:CenterHorizontal()
	self.LAll:AlignTop(o+25+5+25+5+9)
	
	
	function self.Back.DoClick(this)
		
		self.Cant:SetVisible(false)
		self.Can:SetVisible(false)
		self.Right:SetVisible(false)
		self.Left:SetVisible(false)
		self.LAll:SetVisible(false)
		self.RAll:SetVisible(false)
		self:ShowColor()
	end
	function self.Forward.DoClick(this)
		self.Cant:SetVisible(false)
		self.Can:SetVisible(false)
		self.Right:SetVisible(false)
		self.Left:SetVisible(false)
		self.LAll:SetVisible(false)
		self.RAll:SetVisible(false)
		if LocalPlayer():IsAdmin() then
			self:ShowAdmin()
		else
			self:Finish()
		end
	end
end

function PNL:ShowAdmin()
	self.Forward:SetText("Finish")
	self.Back:SetText("Back")
	
	self.Admin:SetVisible(true)
	
	function self.Back.DoClick(this)
		self.Admin:SetVisible(false)
		self:ShowPrivacy()
	end
	function self.Forward.DoClick(this)
		self.Admin:SetVisible(false)
		self:Finish()
	end
end

function PNL:Finish()
	local poi = {}
	--[[
		poi.pos = v.pos
		poi.icon = v.icon
		poi.name = k
		poi.desc = v.desc or v.description
		poi.owner = game.GetWorld()
		poi.privacy = v.privacy
		poi.color = v.color
		poi.id = table.insert(gmaps.POI,poi)
	]]
	
	poi.pos = self.Pos
	
	poi.name = self.Title:GetValue()
	poi.desc = self.Descr:GetValue()
	
	poi.icon = self.MatCheck:GetChecked() and self.MatText:GetValue() or self.Icons:GetSelectedIcon()
	
	poi.color = self.Col:GetColor()
	
	if self.Perma:GetChecked() then
		poi.owner = game.GetWorld()
	else
		poi.owner = LocalPlayer()
	end
	
	if #self.Cant:GetLines() == 0 then
		poi.privacy = false
	else
		poi.privacy = {}
		for k,v in pairs(self.Can:GetLines())do
			if !self.Perma:GetChecked() or isnumber(v.val) then
				table.insert(poi.privacy,v.val)
			end
		end
	end
	
	
	net.Start("GMaps_POI")
		net.WriteTable(poi)
	net.SendToServer()
	
	//Now we wait for a response.
	self.POI = poi
	self.Waiting = true
	self.WaitingBar:SetVisible(true)
	self.Back:SetVisible(false)
	self.Forward:SetVisible(false)
	
	-- self:Remove()
	-- PrintTable(poi)
	
end

function PNL:OnRemove()
	self.Waypoint:Remove()
end

function PNL:ReceiveResult(msg,type)
	self.WaitingBar:SetVisible(false)
	-- self.WaitingBar:SetFraction(1)
	self.Result:GetParent():SetVisible(true)
	self.ResultIcon:SetVisible(true)
	
	self.Back:SetVisible(true)
	self.Forward:SetVisible(true)
	
	-- self.WaitingBar:SetColor(self.Col:GetColor())
	
	-- msg = msg:Wrap(self.Result:GetFont(),self.Result:GetWide())
	
	if type == NOTIFY_ERROR then
		self.ResultIcon:SetImageColor(Color(200,40,40))
		
		self.Back:SetText("Quit")
		self.Forward:SetText("Start Over")
		
		function self.Back.DoClick()
			self:Remove() 
		end
		function self.Forward.DoClick()
			self.ResultIcon:SetVisible(false)
			self.Result:GetParent():SetVisible(false)
			self:ShowNameDesc()
		end
	
	else
		self.Waypoint:SetVisible(false)
		
		if type == NOTIFY_HINT then
			self.ResultIcon:SetImageColor(Color(228,228,0))
			msg = msg.."\n\nYour POI has been added!"
		else
			self.ResultIcon:SetImageColor(Color(55,206,0))
		end
		
		self.Back:SetVisible(false)
		self.Forward:SetText("View")
		function self.Back.DoClick() end
		function self.Forward.DoClick()
			local pnl = self:GetParent()
			local x,y = self:GetPos()
			local poi = pnl:FindPOI(x+self:GetWide()/2,y-gmaps.Config.POISize/2)
			if poi then
				pnl:POIClicked(poi) //show result.
			end
			self:Remove() //close ourselves.
		end
	end
	
	self.Result:SetText(msg)
	self.ResultIcon:SetMaterial(self.ResultIcon.Icons[type])
end

function PNL:Think()
	
	local x,y = self:GetParent():WorldToXY(self.Pos)
	self:SetPos(x-self:GetWide()/2,y+2)
	self.Waypoint:SetPos(x-gmaps.Config.POISize/2, y-gmaps.Config.POISize)
	
	if self.Waiting then
		if gmaps.POIResult then
			self:ReceiveResult(unpack(gmaps.POIResult))
			gmaps.POIResult = nil
		end
		self.WaitingBar:SetFraction(self.WaitingBar:GetFraction() + FrameTime()*2)
	end
	-- self:SetPos(math.Clamp(x-self:GetWide()/2,0,self:GetParent():GetWide()-self:GetWide()),math.Clamp(y+2,0,self:GetParent():GetTall()-self:GetTall()))
end


function PNL:SetVector(p)
	self.Pos = p
	
	self.Waypoint = vgui.Create("DImage",self:GetParent())
	self.Waypoint:SetSize(gmaps.Config.POISize,gmaps.Config.POISize)
	local x,y = self:GetPos()
	self.Waypoint:SetPos(x+self:GetWide()/2-gmaps.Config.POISize/2, y-gmaps.Config.POISize)
	self.Waypoint:SetMaterial(Material("materials/gmaps/poi/poi.png","unlitgeneric smooth"))
	self.Waypoint:SetImageColor(gmaps.POIRed)
	function self.Waypoint.Paint(this,w,h)
		local col = this:GetImageColor()
		this:SetImageColor(color_black)
		this:PaintAt(w/2-h/2+1,0+1,h,h)
		this:SetImageColor(col)
		this:PaintAt(w/2-h/2,0,h,h)
	end
	
end

vgui.Register("DPOIEditor",PNL,"DPanel")
--addons/billy_gas/lua/gmodadminsuite/lang/chinese.lua:
return {
    Name = "Chinese",
    Flag = "flags16/cn.png",
    Phrases = function()
        return {
            open_menu = "打开菜单",
            menu_nopermission = "对不起，您没有权限访问GmodAdminSuite菜单。",
            menu_unknown_module = "对不起，该名称的模块未安装或不存在。",
            menu_disabled_module = "对不起，该模块已禁用。",
            menu_module_nopermission = "对不起，您没有权限访问此模块。",
            open_gas = "打开GmodAdminSuite",
            module_shortcut = "模块快捷方式",
            module_reset_data = "重置模块位置/大小",
            module_shortcut_info = [[
                您可以通过控制台和聊天命令快速访问此GmodAdminSuite模块。

                通过控制台访问模块，请输入：%s
                通过聊天访问模块，请输入：%s

                此外，您可以将键盘上的键绑定到特定模块。
                要做到这一点，请在控制台中输入：%s

                请确保将KEY替换为您选择的键盘上的键。
            %s]],
            close = "关闭",
            wiki = "维基",
            licensee = "许可证持有者",
            support = "支持",
            module_shop = "模块商店",
            welcome = "欢迎",
            operator = "操作员",
            script_page = "脚本页面",
            no_modules_available = "没有可用的模块！",
            no_modules_available_info = [[
                对不起，没有可供您使用的GmodAdminSuite模块。
		        您可能没有足够的权限使用任何模块，或者没有启用任何模块。
            ]],
            custom_ellipsis = "自定义...",
            usergroup_ellipsis = "用户组...",
            steamid_ellipsis = "SteamID...",
            enter_steamid_ellipsis = "输入SteamID...",
            by_distance = "按距离",
            by_usergroup = "按用户组",
            by_team = "按团队",
            by_name = "按名称",
            right_click_to_focus = "右键点击聚焦",
            unknown = "未知",
            utilities = "实用工具",
            player_management = "玩家管理",
            administration = "管理",
            s_second = "1秒",
            s_seconds = "%d秒",
            s_minute = "1分钟",
            s_minutes = "%d分钟",
            s_hour = "1小时",
            s_hours = "%d小时",
            second_ago = "1秒前",
            seconds_ago = "%d秒前",
            minute_ago = "1分钟前",
            minutes_ago = "%d分钟前",
            hour_ago = "1小时前",
            hours_ago = "%d小时前",
            just_now = "刚刚",
            click_to_focus = "点击聚焦",
            add_steamid = "自定义SteamID",
            copied = "已复制！",
            settings = "设置",
            add_steamid_help = [[
                输入SteamID或SteamID64。例如：
                SteamID：%s
                SteamID64：%s
            ]],

            setting_default_module = "默认模块",
            setting_default_module_tip = "打开GmodAdminSuite主菜单时应打开哪个模块？",
            none = "无",
            general = "通用",
            localization = "本地化",
            setting_menu_voicechat = "打开GAS菜单时允许语音聊天",
            setting_menu_voicechat_tip = "GmodAdminSuite的菜单不会阻止您的语音聊天键。如果此选项开启，只需按下您的语音聊天键即可在菜单中进行交谈。",
            use_gas_language = "使用GmodAdminSuite语言",
            default_format = "默认格式",
            short_date_format = "短日期格式",
            long_date_format = "长日期格式",
            short_date_format_tip = "用于较短日期格式的日期格式\n\n默认格式会自动匹配您所在地区的日期格式（北美、欧洲等）",
            long_date_format_tip = "用于较长日期格式的日期格式",
            permissions = "权限",
            module_enable_switch_tip = "此更改只会在服务器重启/地图更改后应用",
            enabled = "已启用",
            modules = "模块",
            permissions_help = [[
                GmodAdminSuite使用了一个名为OpenPermissions的开源权限库，由Billy为GAS开发。它为任何大小的服务器上运行的高级系统提供了优化的权限处理。
		
                OpenPermissions是您将控制哪些组可以访问哪些模块以及他们可以对这些模块做什么的地方。
                您可以随时通过在聊天中输入"!openpermissions"或在控制台中输入"openpermissions"来打开它。

                需要帮助和信息，请点击OpenPermissions菜单中的"帮助"标签。
            ]],
            website = "网站",
            fun = "权限",

            bvgui_copied = "已复制！",
            bvgui_open_context_menu = "打开上下文菜单",
            bvgui_open_steam_profile = "打开Steam个人资料",
            bvgui_right_click_to_focus = "右键点击聚焦",
            bvgui_click_to_focus = "点击聚焦",
            bvgui_unknown = "未知",
            bvgui_no_data = "无数据",
            bvgui_no_results_found = "未找到结果",
            bvgui_done = "完成",
            bvgui_enter_text_ellipsis = "输入文本...",
            bvgui_loading_ellipsis = "加载中...",
            bvgui_pin_tip = "按ESC再次点击菜单",
            bvgui_click_to_render = "点击渲染",
            bvgui_teleport = "传送",
            bvgui_inspecting = "检查中",
            bvgui_inspect = "检查",
            bvgui_screenshot = "截图",
            bvgui_ok = "确定",
            bvgui_screenshot_saved = "截图已保存",
            bvgui_screenshot_saved_to = "截图已保存到您的电脑上的%s",
            bvgui_reset = "重置",
            bvgui_right_click_to_stop_rendering = "右键点击停止渲染",

            settings_player_popup_close = "当\n他们失去焦点时关闭玩家弹窗",
            settings_player_popup_close_tip = "当您点击不同菜单时，玩家弹窗是否应该关闭？"
        }
    end
}

--addons/billy_gas/lua/gmodadminsuite/modules/secondaryusergroups/lang/french.lua:
return {
	Name = "French",
	Flag = "flags16/fr.png",
	Phrases = function() return {

		module_name = "Secondary Usergroups",

		open_menu          = "Ouvrir Menu",
		custom_ellipsis    = "Custom...",
		usergroup_ellipsis = "Groupes d'Utilisateurs...",
		players            = "Joueurs",
		settings           = "Paramètres",
		players            = "Joueurs",
		give_usergroup     = "Définir Groupe",
		usergroup_ellipsis = "Groupe d'Utilisateurs...",
		usergroup_is_main  = "C'est le groupe principal des utilisateurs, il ne peut pas être donné ou retiré.",
		help               = "Aide",
		offline_btn        = "Nouveau Joueur...",
		loading_ellipsis   = "Chargement...",
		unknown            = "Inconnu",

} end }
--addons/billy_gas/lua/gmodadminsuite/sh_afk.lua:
GAS.AFK = {}
GAS.AFK.AFKTime = GAS.Config.AFKTime

if (SERVER) then

	GAS_AFK_PlayerPositions = GAS_AFK_PlayerPositions or {}
	GAS_AFK_PlayerLastMoved = GAS_AFK_PlayerLastMoved or {}

	function GAS.AFK:SetAFK(ply, is_afk, pos_signature)
		if (is_afk) then
			if (not ply.GAS_PlayerAFK) then
				ply.GAS_PlayerAFK = true
				ply:SetNWBool("GAS_PlayerAFK", true)
				hook.Run("GAS:AFK", ply)
			end
		else
			GAS_AFK_PlayerLastMoved[ply] = os.time()
			GAS_AFK_PlayerPositions[ply] = pos_signature
			if (ply.GAS_PlayerAFK) then
				ply.GAS_PlayerAFK = false
				ply:SetNWBool("GAS_PlayerAFK", false)
				hook.Run("GAS:UnAFK", ply)
			end
		end
	end

	GAS:timer("afk:update_player_positions", 5, 0, function()
		for _,ply in ipairs(player.GetHumans()) do
			local pos = ply:GetPos()
			local pos_signature = math.Round(pos.x) + math.Round(pos.y) + math.Round(pos.z)
			if (GAS_AFK_PlayerLastMoved[ply]) then
				if (pos_signature ~= GAS_AFK_PlayerPositions[ply]) then
					GAS.AFK:SetAFK(ply, false, pos_signature)
				elseif (os.time() - GAS_AFK_PlayerLastMoved[ply] >= GAS.AFK.AFKTime) then
					GAS.AFK:SetAFK(ply, true)
				end
			end
		end
	end)

	GAS:hook("PlayerInitialSpawn", "afk:PlayerInitialSpawn", function(ply)
		if (ply:IsBot()) then return end
		ply.GAS_PlayerAFK = true

		ply:SetNWBool("GAS_PlayerAFK", true)
	end)

	GAS:hook("PlayerDisconnected", "afk:GC", function(ply)
		GAS_AFK_PlayerLastMoved[ply] = nil
		GAS_AFK_PlayerPositions[ply] = nil
	end)

	GAS:netInit("afk:InitPostEntity")
	GAS:netReceive("afk:InitPostEntity", function(ply)
		local pos = ply:GetPos()
		local pos_signature = math.Round(pos.x) + math.Round(pos.y) + math.Round(pos.z)
		GAS_AFK_PlayerLastMoved[ply] = os.time()
		GAS_AFK_PlayerPositions[ply] = pos_signature
	end)

else

	GAS:InitPostEntity(function()
		GAS:netStart("afk:InitPostEntity")
		net.SendToServer()
	end)

end

function GAS.AFK:IsAFK(ply)
	return ply.GAS_PlayerAFK or ply:GetNWBool("GAS_PlayerAFK", true)
end
--addons/billy_gas/lua/gmodadminsuite/sh_modules.lua:
GAS.Modules = {}
GAS.Modules.Info = {}

GAS.MODULE_CATEGORY_ADMINISTRATION    = 0
GAS.MODULE_CATEGORY_PLAYER_MANAGEMENT = 1
GAS.MODULE_CATEGORY_UTILITIES         = 2
GAS.MODULE_CATEGORY_FUN               = 3

GAS.Modules.Organised = {}

function GAS.Modules:GetFriendlyName(module_name)
	return GAS:Phrase("module_name", module_name) or GAS.Modules.Info[module_name].Name or module_name
end

if (SERVER) then

	GAS.Modules.Config = GAS:GetConfig("modules", {
		Enabled = {}
	})

	GAS:netInit("SetModuleEnabled")
	GAS:netReceive("SetModuleEnabled", function(ply)
		if (not OpenPermissions:IsOperator(ply)) then return end

		local module_name, enabled = net.ReadString(), net.ReadBool()

		GAS.Modules.Config.Enabled[module_name] = enabled or nil
		GAS:SaveConfig("modules", GAS.Modules.Config)

		GAS:netStart("SetModuleEnabled")
			net.WriteString(module_name)
			net.WriteBool(enabled)
		net.SendOmit(ply)
	end)

else

	GAS:netReceive("SetModuleEnabled", function()
		local module_name, enabled = net.ReadString(), net.ReadBool()
		GAS.Modules.Config.Enabled[module_name] = enabled or nil
	end)

end

GAS.Modules.LoadedModules = {}
function GAS.Modules:IsModuleLoaded(module_name)
	return GAS.Modules.LoadedModules[module_name] == true
end

GAS.Modules.MODULE_ENABLED  = 0
GAS.Modules.MODULE_DISABLED = 1
GAS.Modules.MODULE_UNKNOWN  = 2
function GAS.Modules:IsModuleEnabled(module_name)
	if (GAS.Modules.Info[module_name]) then
		if (GAS.Modules.Config.Enabled[module_name]) then
			return GAS.Modules.MODULE_ENABLED
		else
			return GAS.Modules.MODULE_DISABLED
		end
	else
		return GAS.Modules.MODULE_UNKNOWN
	end
end

function GAS.Modules:LoadModule(module_name, suppress_print)
	GAS.Modules.LoadedModules[module_name] = true
	hook.Run("gmodadminsuite:LoadModule:" .. module_name, GAS.Modules.Info[module_name])
end

GAS:StartHeader("Modules")

local save_config = false
local _,d = file.Find("gmodadminsuite/modules/*", "LUA")
for _,module_name in ipairs(d) do
	if (not file.Exists("gmodadminsuite/modules/" .. module_name .. "/_gas_info.lua", "LUA")) then continue end

	if (SERVER) then
		AddCSLuaFile("gmodadminsuite/modules/" .. module_name .. "/_gas_info.lua")
	end
	GAS.Modules.Info[module_name] = include("gmodadminsuite/modules/" .. module_name .. "/_gas_info.lua")

	local category = GAS.Modules.Info[module_name].Category
	GAS.Modules.Organised[category] = GAS.Modules.Organised[category] or {}
	GAS.Modules.Organised[category][module_name] = GAS.Modules.Info[module_name]

	local init = false
	if (file.Exists("gmodadminsuite/modules/" .. module_name .. "/sh_init.lua", "LUA")) then
		if (SERVER) then AddCSLuaFile("gmodadminsuite/modules/" .. module_name .. "/sh_init.lua") end
		include("gmodadminsuite/modules/" .. module_name .. "/sh_init.lua")
		init = true
	end
	if (file.Exists("gmodadminsuite/modules/" .. module_name .. "/cl_init.lua", "LUA")) then
		if (SERVER) then AddCSLuaFile("gmodadminsuite/modules/" .. module_name .. "/cl_init.lua") end
		if (CLIENT) then include("gmodadminsuite/modules/" .. module_name .. "/cl_init.lua") end
		init = true
	end
	if (SERVER and file.Exists("gmodadminsuite/modules/" .. module_name .. "/sv_init.lua", "LUA")) then
		include("gmodadminsuite/modules/" .. module_name .. "/sv_init.lua")
		init = true
	end

	local friendly_name
	if (SERVER) then
		friendly_name = GAS.Modules.Info[module_name].Name
	else
		friendly_name = GAS:Phrase("module_name", module_name)
	end
	if (SERVER) then
		if (GAS.Modules.Config.Enabled[module_name] == nil and GAS.Modules.Info[module_name].DefaultEnabled == true) then
			GAS.Modules.Config.Enabled[module_name] = true
			save_config = true
		end
		if (GAS.Modules.Config.Enabled[module_name]) then
			GAS:HeaderPrint("= " .. friendly_name, GAS_PRINT_COLOR_GOOD)
		else
			GAS:HeaderPrint("X " .. friendly_name, GAS_PRINT_COLOR_BAD)
		end
	elseif (init) then
		GAS:HeaderPrint("✓ " .. friendly_name, GAS_PRINT_COLOR_GOOD)
	end
end

GAS:EndHeader()

if (save_config) then
	GAS:SaveConfig("modules", GAS.Modules.Config)
end

if (CLIENT) then
	GAS:InitPostEntity(function()
		GAS:GetConfig("modules", function(config)
			GAS.Modules.Config = config
			for module_name, enabled in pairs(GAS.Modules.Config.Enabled) do
				if (not enabled) then continue end
				GAS.Modules:LoadModule(module_name, true)
			end
		end)
	end)
else
	for module_name, enabled in pairs(GAS.Modules.Config.Enabled) do
		if (not enabled) then continue end
		GAS.Modules:LoadModule(module_name, true)
	end
end
--addons/billy_gas/lua/gmodadminsuite/modules/commands/_gas_info.lua:
return {
	DefaultEnabled = true,
	Name = "Command Manager",
	Category = GAS.MODULE_CATEGORY_UTILITIES,
	OperatorOnly = true,
	Wiki = "https://gmodsto.re/gmodadminsuite-commands-wiki",
	Icon = "icon16/script_gear.png",
}
--addons/billy_gas/lua/gmodadminsuite/modules/fpsbooster/_gas_info.lua:
return {
	Name = "FPS Booster",
	Category = GAS.MODULE_CATEGORY_UTILITIES,
	Hidden = true,
	Wiki = "https://gmodsto.re/gmodadminsuite-fpsbooster-wiki",
	Icon = "icon16/lightning.png",
	Public = true
}
--lua/autorun/grievous_pm.lua:
list.Set( "PlayerOptionsModel", "General Grievous", "models/aussisengels/grievous/general_grievous.mdl" )
player_manager.AddValidModel( "General Grievous", "models/aussisengels/grievous/general_grievous.mdl" )
player_manager.AddValidHands( "General Grievous", "models/aussisengels/grievous/general_grievous_hands.mdl",0,"10000000" )

--addons/joes_stuff/lua/bomb_system/cl_colorblind.lua:
local path = "bomb/preset.txt"
BombSystem.preset = BombSystem.preset or false

function BombSystem:CreatePresetFiles()
    if not file.Exists("bomb/", "DATA") or not file.Exists(path, "DATA") then
        file.CreateDir("bomb/")
        file.Write(path, "")
    end
    local sel = file.Read(path, "DATA")
    if not sel or not BombSystem.presets[name] then return end
    BombSystem.preset = sel
end

function BombSystem:ReadPresetFile()
    if not file.Exists(path, "DATA") then return end
    local sel = file.Read(path, "DATA")
    if not sel or not BombSystem.presets[name] then return end
    BombSystem.preset = sel
end

function BombSystem:DoesBombFileExist()
    if file.Exists(path, "DATA") then 
        return true
    else
        return false
    end
end

function BombSystem:GetPreset()
    return BombSystem.preset
end

function BombSystem:SetPreset(name)
    if not BombSystem.presets[name] then return end
    file.Write(path, name)
    BombSystem.preset = name
end

function BombSystem:DeletePreset()
    file.Write(path, "")
    BombSystem.preset = false
end

BombSystem.presets = {
    ["Deuteronopia"] = {
		Yellow = Color(255,246,58),
		Blue = Color(56,96,179),
		Green = Color(159,146,40),
		Red = Color(98,91,73),
		Orange = Color(193,176,18),
		Black = Color(0,0,0),
		White = Color(100,100,100),
	},
    ["Protanopia"] = {
		Yellow = Color(255,248,56),
		Blue = Color(60,98,179),
		Green = Color(175,159,31),
		Red = Color(104,95,22),
		Orange = Color(176,160,33),
		Black = Color(0,0,0),
		White = Color(100,100,100),
	},
    ["Tritanopia"] = {
        Yellow = Color(252,227,233),
        Blue = Color(17,164,197),
        Green = Color(97,210,250),
        Red = Color(254,41,107),
        Orange = Color(251,106,147),
        Black = Color(0,0,0),
        White = Color(100,100,100),
    },
}


local frame
local background = Color(30,30,30)
local outline = Color(144,0,255)
local text = Color(255,255,255)
local selected = Color(100,100,100)
local notselected = Color(40,40,40)
local clsbtnclr = Color(255,0,0)
function BombSystem:OpenColorBlindMenu()
    if IsValid(frame) then frame:Remove() end
    local scrw,scrh = ScrW(),ScrH()

    frame = vgui.Create("DFrame")
    frame:SetSize(scrw * 0.25,scrh * 0.35)
    frame:Center()
    frame:SetTitle("")
    frame:MakePopup()
    frame:ShowCloseButton(false)
    frame.Paint = function(s,w,h)
        surface.SetDrawColor(background)
        surface.DrawRect(0,0,w,h)
        surface.SetDrawColor(outline)
        surface.DrawOutlinedRect(0,0,w,h,scrw * 0.002)
        draw.SimpleText("TheJoe's Bomb - Colorblind Presets", "DermaLarge", w * 0.5, h * 0.05, tetx, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
    end

    local clsbtn = vgui.Create("DButton", frame)
    clsbtn:SetPos(scrw * 0.225,scrh * 0.006)
    clsbtn:SetText("X")
    clsbtn:SetColor(clsbtnclr)
    clsbtn:SetFont("DermaLarge")
    clsbtn.DoClick = function()
        frame:Remove()
    end
    clsbtn.Paint = function() end

    local addlist = vgui.Create("DScrollPanel",frame)
    addlist:SetPos(0,scrh * 0.05)
    addlist:SetSize(scrw * 0.25,scrh * 0.25)
    addlist:GetVBar():SetSize(0)

    for name,_ in pairs(BombSystem.presets) do
        local selectbtn = vgui.Create("DButton", addlist)
        selectbtn:SetSize(scrw * 0.2,scrh * 0.05)
        selectbtn:SetText("")
        selectbtn:Dock(TOP)
        selectbtn:DockMargin(scrw * 0.01, scrw * 0.0125, scrw * 0.01, 0)
        selectbtn.Paint = function(s,w,h)
            if BombSystem.preset and BombSystem.preset == name then
                surface.SetDrawColor(selected)
            else
                surface.SetDrawColor(notselected)
            end
            surface.DrawRect(0,0,w,h)
            surface.SetDrawColor(outline)
            surface.DrawOutlinedRect(0,0,w,h,scrw * 0.002)

            draw.SimpleText(name, "DermaLarge", w * 0.5, h * 0.5, text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
        selectbtn.DoClick = function()
            if BombSystem.preset and BombSystem.preset == name then
                BombSystem:DeletePreset()
            else
                BombSystem:SetPreset(name)
            end
            frame:Remove()
        end
    end
end

hook.Add("InitPostEntity", "BombSystem:OpenColorblindMenu", function()
--[[     if BombSystem:DoesBombFileExist() then
        BombSystem:ReadPresetFile()
    else
        BombSystem:CreatePresetFiles()
        BombSystem:OpenColorBlindMenu()
    end ]]
end)

concommand.Add("bomb_colorblind", function()
    BombSystem:CreatePresetFiles()
    BombSystem:OpenColorBlindMenu()
end)
--lua/autorun/krsn_ds2_forlorn_pm.lua:
player_manager.AddValidModel( "Dark Souls 2 - Forlorn", "models/kerosenn/dark_souls_2/enemies/forlorn/ds2_forlorn_pm.mdl" )
player_manager.AddValidHands( "Dark Souls 2 - Forlorn", "models/kerosenn/dark_souls_2/enemies/forlorn/ds2_forlorn_vm.mdl", 0, "00000000" )


--addons/weapon_jedi/lua/lscs/combos/niman.lua:
COMBO.id = "niman"
COMBO.PrintName = "Form VI | Niman"
COMBO.Author = "Deltaa"
COMBO.Description = "Weg des Rancors"

COMBO.DeflectBullets = true
COMBO.AutoBlock = true

COMBO.LeftSaberActive = false

COMBO.HoldType = "lscs_niman"

COMBO.DamageMultiplier = 1
COMBO.MaxBlockPoints = 125

COMBO.Attacks = {
	["BACKFLIP"] = {
		AttackAnim = "rollback",
		BeginAttack = function( weapon, ply )  
			weapon:SetDMGActive( false )

			ply:SetVelocity( Vector(0,0,250) - Angle(0,ply:EyeAngles().y,0):Forward() * 100 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 0.5,
	},
	["ROLL_RIGHT"] = {
		AttackAnim = "rollright",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) + Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["ROLL_LEFT"] = {
		AttackAnim = "rollleft",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:SetVelocity( Vector(0,0,50) - Angle(0,ply:EyeAngles().y,0):Right() * 600 )
			ply:lscsSuppressFalldamage( CurTime() + 5 )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.0,
		Duration = 1,
	},
	["____"] = {
		AttackAnim = "pure_h_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove(1, CurTime(), 0.5, Vector(100, 0, 0))
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0,
		Duration = 0.6,
	},
	["-45-"] = {
		AttackAnim = "pure_b_s3_t3",
		BeginAttack = function( weapon, ply ) 
			weapon:DoAttackSound()

			ply:lscsSetTimedMove(1, CurTime(), 0.5, Vector(100, 0, 0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.3,
	},
	["+45+"] = {
		AttackAnim = "pure_h_right_t3",
		BeginAttack = function(weapon, ply) 
			weapon:DoAttackSound()

			ply:lscsSetTimedMove(1, CurTime(), 0.6, Vector(250, 0, 0) )
		end,
		FinishAttack = function(weapon, ply) end,
		Delay = 0.1,
		Duration = 1.3,
	},
	["__S_"] = {
		AttackAnim = "pure_b_s2_t3",
		BeginAttack = function(weapon, ply) 
			weapon:DoAttackSound()
			ply:lscsSetTimedMove(1, CurTime(), 0.5, Vector(-20, 0, 0))
		end,
		FinishAttack = function(weapon, ply) end,
		Delay = 0.1,
		Duration = 0.9,
	},
	["_A__"] = {
		AttackAnim = "pure_h_left_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(0,-100,0) )
			ply:lscsSetTimedMove( 2, CurTime() + 0.3, 0.3, Vector(0,0,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["___D"] = {
		AttackAnim = "pure_h_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()
			ply:lscsSetTimedMove(1, CurTime(), 0.3, Vector(0, 100, 0))
			ply:lscsSetTimedMove(2, CurTime() + 0.3, 0.3, Vector(0, 0, 0))
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.25,
		Duration = 0.5,
	},
	["W__D"] = {
		AttackAnim = "pure_b_right_t1",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:lscsSetTimedMove( 1, CurTime(), 0.4, Vector(1,1,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.9,
	},
	["WA__"] = {
		AttackAnim = "pure_b_left_t3",
		BeginAttack = function( weapon, ply )  
			weapon:DoAttackSound()

			ply:lscsSetTimedMove( 1, CurTime(), 0.3, Vector(25,-25,0) )
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.3,
		Duration = 0.7,
	},
	["__SD"] = {
		AttackAnim = "judge_b_s2_t1",
		BeginAttack = function(weapon, ply)  
			weapon:DoAttackSound()

			ply:lscsSetTimedMove(1, CurTime(), 0.3, Vector(-1, 1, 0))
		end,
		FinishAttack = function(weapon, ply) end,
		Delay = 0.2,
		Duration = 0.5,
	},
	["_AS_"] = {
		AttackAnim = "vanguard_b_left_t3",
		BeginAttack = function(weapon, ply)  
			weapon:DoAttackSound()

			ply:lscsSetTimedMove(1, CurTime(), 0.3, Vector(-1,-1,0))
		end,
		FinishAttack = function(weapon, ply) end,
		Delay = 0.3,
		Duration = 0.6,
	},
	["W___"] = {
		AttackAnim = "judge_b_s3_t1",
		BeginAttack = function(weapon, ply)  
			weapon:DoAttackSound()

			if ply:OnGround() then
				ply:SetVelocity(Angle(0, ply:EyeAngles().y, 0):Forward() * 1000)
			end

			ply:lscsSetTimedMove(1, CurTime(), 0.9, Vector(0,0,0))
		end,
		FinishAttack = function( weapon, ply ) end,
		Delay = 0.1,
		Duration = 1.75,
	},
}
--lua/autorun/pommes_patrol_seat.lua:
local Category = "Vehicle Utilities"

local function StandAnimation( vehicle, player )
	return player:SelectWeightedSequence( ACT_HL2MP_IDLE_PASSIVE )
end

local V = {
	Name = "Patrol Transport Passenger Seat",
	Model = "models/nova/airboat_seat.mdl",
	Class = "prop_vehicle_prisoner_pod",
	Category = Category,

	Author = "Syphadias, Oninoni, KingPommes",
	Information = "Seat with custom animation",
	Offset = 0,

	KeyValues = {
		vehiclescript = "scripts/vehicles/prisoner_pod.txt",
		limitview = "0"
	},
	Members = {
		HandleAnimation = StandAnimation
	}
}
list.Set( "Vehicles", "pommes_patrol_seat", V )
--addons/tools/lua/autorun/rb655_make_animatable.lua:

AddCSLuaFile()

properties.Add( "rb655_make_animatable", {
	MenuLabel = "#tool.rb655_easy_animation.property",
	Order = 654,
	MenuIcon = "icon16/tick.png",
	Filter = function( self, ent, ply )
		if ( !IsValid( ent ) or !gamemode.Call( "CanProperty", ply, "rb655_make_animatable", ent ) ) then return false end
		if ( ent:GetClass() == "prop_animatable" ) then return false end
		if ( ent:IsPlayer() or !ent:GetModel() or ent:GetModel():StartWith( "*" ) ) then return false end
		--if ( string.find( ent:GetClass(), "prop_physics" ) or string.find( ent:GetClass(), "prop_ragdoll" ) ) then return true end
		return true
	end,
	Action = function( self, ent )
		self:MsgStart()
		net.WriteEntity( ent )
		self:MsgEnd()
	end,
	Receive = function( self, len, ply )
		local ent = net.ReadEntity()

		if ( !IsValid( ply ) or !IsValid( ent ) or !self:Filter( ent, ply ) ) then return false end

		local entActual = ent
		if ( IsValid( ent.AttachedEntity ) ) then
			ent = ent.AttachedEntity
		end

		local ragPos = ent:GetPos()

		-- Try to not make entity fly
		if ( ent:IsRagdoll() ) then
			for i = 0, ent:GetPhysicsObjectCount() - 1 do
				local bone = ent:GetPhysicsObjectNum( i )
				if ( IsValid( bone ) ) then
					local pos = bone:GetPos()

					-- Yes I like my pyramids
					if ( pos.z < ragPos.z ) then
						ragPos.z = pos.z
					end
				end
			end
		end

		local prop_animatable = ents.Create( "prop_animatable" )
		prop_animatable:SetModel( ent:GetModel() )
		prop_animatable:SetPos( ragPos )
		prop_animatable:SetAngles( ent:GetAngles() )
		prop_animatable:SetSequence( ent:GetSequence() )
		prop_animatable:SetCycle( ent:GetCycle() )
		--prop_animatable:SetPlaybackRate( ent:GetPlaybackRate() )

		prop_animatable:SetSkin( ent:GetSkin() or 0 )
		prop_animatable:SetFlexScale( ent:GetFlexScale() )
		for i = 0, ent:GetFlexNum() - 1 do prop_animatable:SetFlexWeight( i, ent:GetFlexWeight( i ) ) end
		for i = 0, ( ent:GetNumBodyGroups() or 0 ) - 1 do prop_animatable:SetBodygroup( i, ent:GetBodygroup( i ) ) end
		for i = 0, ent:GetNumPoseParameters() - 1 do prop_animatable:SetPoseParameter( ent:GetPoseParameterName( i ) , ent:GetPoseParameter( i ) ) end
		for i = 0, ent:GetBoneCount() do
			prop_animatable:ManipulateBoneScale( i, ent:GetManipulateBoneScale( i ) )
			prop_animatable:ManipulateBoneAngles( i, ent:GetManipulateBoneAngles( i ) )
			prop_animatable:ManipulateBonePosition( i, ent:GetManipulateBonePosition( i ) )
			prop_animatable:ManipulateBoneJiggle( i, ent:GetManipulateBoneJiggle( i ) )
		end
		-- prop_animatable:InvalidateBoneCache()

		prop_animatable:Spawn()
		prop_animatable:Activate()

		prop_animatable.EntityMods = ent.EntityMods
		prop_animatable.BoneMods = ent.BoneMods
		duplicator.ApplyEntityModifiers( nil, prop_animatable )
		duplicator.ApplyBoneModifiers( nil, prop_animatable )

		-- We use string find because there are might be subclasses, like prop_ragdoll_multiplayer or something
		if ( string.find( entActual:GetClass(), "prop_ragdoll" ) or entActual:IsNPC() ) then
			prop_animatable:FixRagdoll() -- This WILL have false-positives, but it will have to do for now
		end

		undo.ReplaceEntity( entActual, prop_animatable )
		cleanup.ReplaceEntity( entActual, prop_animatable )

		constraint.RemoveAll( entActual ) -- Remove all constraints ( this stops ropes from hanging around )
		entActual:Remove()
	end
} )

properties.Add( "rb655_make_ragdoll", {
	MenuLabel = "#tool.rb655_easy_animation.property_ragdoll",
	Order = 653,
	MenuIcon = "icon16/tick.png",
	Filter = function( self, ent, ply )
		if ( !IsValid( ent ) or !gamemode.Call( "CanProperty", ply, "rb655_make_ragdoll", ent ) ) then return false end
		if ( ent:GetClass() != "prop_animatable" ) then return false end
		if ( !ent.GetIsRagdoll or !ent:GetIsRagdoll() ) then return false end
		return true
	end,
	Action = function( self, ent )
		self:MsgStart()
		net.WriteEntity( ent )
		self:MsgEnd()
	end,
	Receive = function( self, len, ply )
		local ent = net.ReadEntity()

		if ( !IsValid( ply ) or !IsValid( ent ) or !self:Filter( ent, ply ) ) then return false end

		ent:BecomeRagdollLua()
	end
} )

local function MakeDTVarToggleProperty( class, tab )

	local origTab = {
		Type = "toggle",

		Filter = function( self, ent, ply )

			if ( !IsValid( ent ) ) then return false end
			if ( !gamemode.Call( "CanProperty", ply, class, ent ) ) then return false end

			if ( self.ClassRestrict && ent:GetClass() != self.ClassRestrict ) then return false end

			return true

		end,

		Checked = function( self, ent, ply )

			-- This should never happen
			if ( !isfunction( ent[ "Get" .. self.DTVariable ] ) ) then return false end

			return ent[ "Get" .. self.DTVariable ]( ent )

		end,

		Action = function( self, ent )

			self:MsgStart()
				net.WriteEntity( ent )
			self:MsgEnd()

		end,

		Receive = function( self, length, ply )

			local ent = net.ReadEntity()
			if ( !properties.CanBeTargeted( ent, ply ) ) then return end
			if ( !self:Filter( ent, ply ) ) then return end

			if ( !isfunction( ent[ "Get" .. self.DTVariable ] ) ) then return end
			if ( !isfunction( ent[ "Set" .. self.DTVariable ] ) ) then return end
		
			ent[ "Set" .. self.DTVariable ]( ent, !ent[ "Get" .. self.DTVariable ]( ent ) )

		end

	}

	properties.Add( class, table.Merge( origTab, tab ) )

end

MakeDTVarToggleProperty( "rb655_animatable_body_xy", {
	MenuLabel = "#tool.rb655_easy_animation.property_bodyxy",
	Order = 600,

	ClassRestrict = "prop_animatable",
	DTVariable = "AnimateBodyXY"
} )

MakeDTVarToggleProperty( "rb655_animatable_ragdoll_on_dmg", {
	MenuLabel = "#tool.rb655_easy_animation.property_damageragdoll",
	Order = 601,

	ClassRestrict = "prop_animatable",
	DTVariable = "BecomeRagdoll"
} )

--addons/weapons_other/lua/autorun/reconcamera.lua:
if SERVER then

hook.Add( "SetupPlayerVisibility", "MakeVisible_droid_pov", function( pPlayer, pViewEntity )
	-- Adds any view entity
	if IsValid( pPlayer:GetNWEntity("droid") ) && pPlayer:GetNWBool("CameraPOV") && pPlayer:GetNWBool("deployed") then
		AddOriginToPVS( pPlayer:GetNWEntity("droid"):GetPos() )
	end
end )

end


if not CLIENT then return end

hook.Add("CalcView", "ReconDroid.CalcView",function(ply, pos, angles, fov, znear, zfar)
	
	
	if  IsValid(ply:GetNWEntity("droid")) && ply:GetNWBool("CameraPOV") && ply:GetNWBool("deployed") then
		local view = {}

		view.origin = ply:GetNWEntity("droid"):GetPos()-( ply:GetNWEntity("droid"):GetForward()*-5 )
		view.angles = ply:GetNWEntity("droid"):GetAngles()
		view.fov = fov
		view.drawviewer = true

		return view
	end
end)
--addons/admin_sam/lua/sam/sh_permissions.lua:
if SAM_LOADED then return end

local permissions = {}

local give_permission
if SERVER then
	local permissions_to_add = {}

	give_permission = function(name, permission)
		if sam.ranks.ranks_loaded() then
			local rank = sam.ranks.get_rank(name)
			if rank and rank.data.permissions[permission] == nil then
				sam.ranks.give_permission(name, permission)
			end
		else
			table.insert(permissions_to_add, {name, permission})
		end
	end

	hook.Add("SAM.LoadedRanks", "SAM.Command.GivePermissions", function()
		for k, v in ipairs(permissions_to_add) do
			give_permission(v[1], v[2])
		end
	end)
end

local get_next_Other = function()
	for i, v in ipairs(permissions) do
		if v.category == "Other" then
			return i
		end
	end
	return #permissions + 1
end

function sam.permissions.add(permission, category, rank)
	if not sam.isstring(category) then
		category = "Other"
	end

	local permission_data = {
		name = permission,
		category = category,
		rank = rank,
		value = value
	}

	local index = sam.permissions.get_index(permission)
	if not index then
		if category ~= "Other" then
			table.insert(permissions, get_next_Other(), permission_data)
		else
			table.insert(permissions, permission_data)
		end
		hook.Call("SAM.AddedPermission", nil, permission, category, rank, value)
	else
		permissions[index] = permission_data
		hook.Call("SAM.PermissionModified", nil, permission, category, rank, value)
	end

	if SERVER and rank then
		give_permission(rank, permission)
	end
end

function sam.permissions.get_index(permission)
	for i, v in ipairs(permissions) do
		if v.name == permission then
			return i
		end
	end
end

function sam.permissions.remove(permission)
	local index = sam.permissions.get_index(permission)
	if index then
		table.remove(permissions, index)
		hook.Call("SAM.RemovedPermission", nil, permission)
	end
end

function sam.permissions.exists(permission)
	return sam.permissions.get_index(permission) and true or false
end

function sam.permissions.get()
	return permissions
end
--addons/admin_sam/lua/sam/ranks/sh_ranks.lua:
if SAM_LOADED then return end

SAM_IMMUNITY_SUPERADMIN = 100
SAM_IMMUNITY_ADMIN = 50
SAM_IMMUNITY_USER = 1

function sam.ranks.get_ranks()
	return sam.get_global("Ranks", {})
end

function sam.ranks.get_rank(rank)
	local ranks = sam.ranks.get_ranks()
	return ranks[rank]
end

function sam.ranks.is_rank(rank)
	if sam.ranks.get_rank(rank) then
		return true
	else
		return false
	end
end

function sam.ranks.is_default_rank(rank)
	return rank == "superadmin" or rank == "admin" or rank == "user"
end

function sam.ranks.inherits_from(rank, rank_2)
	if rank == rank_2 then
		return true
	end

	while true do
		rank = sam.ranks.get_rank(rank)

		if rank then
			local inherits_from = rank.inherit
			if inherits_from == rank_2 then
				return true
			end

			rank = rank.inherit
		else
			return false
		end
	end
end

function sam.ranks.has_permission(rank, permission)
	while true do
		if rank == "superadmin" then
			return true
		end

		rank = sam.ranks.get_rank(rank)

		if rank then
			local rank_permission = rank.data.permissions[permission]
			if rank_permission ~= nil then
				return rank_permission
			end

			rank = rank.inherit
		else
			return false
		end
	end
end

function sam.ranks.get_limit(rank, limit_type)
	while true do
		if rank == "superadmin" then return -1 end

		rank = sam.ranks.get_rank(rank)

		if rank then
			local limit = rank.data.limits[limit_type]
			if limit ~= nil then
				return limit
			end

			rank = rank.inherit
		else
			return cvars.Number("sbox_max" .. limit_type, 0)
		end
	end
end

function sam.ranks.get_immunity(rank)
	rank = sam.ranks.get_rank(rank)
	return rank and rank.immunity or false
end

function sam.ranks.can_target(rank_1, rank_2)
	rank_1, rank_2 = sam.ranks.get_rank(rank_1), sam.ranks.get_rank(rank_2)
	if not rank_1 or not rank_2 then
		return false
	end
	return rank_1.immunity >= rank_2.immunity
end

function sam.ranks.get_ban_limit(rank)
	rank = sam.ranks.get_rank(rank)
	return rank and rank.ban_limit or false
end

if CLIENT then
	hook.Add("SAM.ChangedGlobalVar", "SAM.Ranks.CheckLoadedRanks", function(key, value)
		if key == "Ranks" then
			hook.Call("SAM.LoadedRanks", nil, value)
			hook.Remove("SAM.ChangedGlobalVar", "SAM.Ranks.CheckLoadedRanks")
		end
	end)
end

--addons/admin_sam/lua/sam/command/arguments/map.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

command.new_argument("map")
	:OnExecute(function(argument, input, ply, _, result)
		local map_name = sam.is_valid_map(input)
		if not map_name and not (argument.optional and input == "None") then
			ply:sam_send_message("invalid", {
				S = "map", S_2 = input
			})
			return false
		end

		table.insert(result, map_name)
	end)

	:Menu(function(set_result, _, buttons, argument)
		local maps = buttons:Add("SAM.ComboBox")
		maps:SetTall(25)

		if argument.optional then
			maps:AddChoice("None", nil, true)
		end

		for _, map_name in ipairs(sam.get_global("Maps", {})) do
			if not (argument.exclude_current and map_name == game.GetMap()) then
				maps:AddChoice(map_name)
			end
		end

		function maps:OnSelect(_, value)
			set_result(value)
		end

		local value = argument.optional and "None" or maps:GetOptionText(1)
		maps:SetValue(value)
		maps:OnSelect(nil, value)

		return maps
	end)

	:AutoComplete(function(_, result, name)
		for _, map_name in ipairs(sam.get_global("Maps", {})) do
			if map_name:lower():find(name, 1, true) then
				table.insert(result, map_name)
			end
		end
	end)
:End()

--addons/admin_sam_sui/lua/sui/libs/bshadows.lua:
local ScrW = ScrW
local ScrH = ScrH

local sin = math.sin
local cos = math.cos
local rad = math.rad
local ceil = math.ceil

local Start2D = cam.Start2D
local End2D = cam.End2D

local PushRenderTarget = render.PushRenderTarget
local OverrideAlphaWriteEnable = render.OverrideAlphaWriteEnable
local Clear = render.Clear
local CopyRenderTargetToTexture = render.CopyRenderTargetToTexture
local BlurRenderTarget = render.BlurRenderTarget
local PopRenderTarget = render.PopRenderTarget
local SetMaterial = render.SetMaterial
local DrawScreenQuadEx = render.DrawScreenQuadEx
local DrawScreenQuad = render.DrawScreenQuad

local RenderTarget, RenderTarget2
local load_render_targets = function()
	local w, h = ScrW(), ScrH()
	RenderTarget = GetRenderTarget("sui_bshadows_original" .. w .. h, w, h)
	RenderTarget2 = GetRenderTarget("sui_bshadows_shadow" .. w .. h,  w, h)
end
load_render_targets()
hook.Add("OnScreenSizeChanged", "SUI.BShadows", load_render_targets)

local ShadowMaterial = CreateMaterial("sui_bshadows", "UnlitGeneric", {
	["$translucent"] = 1,
	["$vertexalpha"] = 1,
	["alpha"] = 1
})

local ShadowMaterialGrayscale = CreateMaterial("sui_bshadows_grayscale", "UnlitGeneric", {
	["$translucent"] = 1,
	["$vertexalpha"] = 1,
	["$alpha"] = 1,
	["$color"] = "0 0 0",
	["$color2"] = "0 0 0"
})

local SetTexture = ShadowMaterial.SetTexture

local BSHADOWS = {}

BSHADOWS.BeginShadow = function()
	PushRenderTarget(RenderTarget)

	OverrideAlphaWriteEnable(true, true)
	Clear(0, 0, 0, 0)
	OverrideAlphaWriteEnable(false, false)

	Start2D()
end

BSHADOWS.EndShadow = function(intensity, spread, blur, opacity, direction, distance, _shadowOnly)
	opacity = opacity or 255
	direction = direction or 0
	distance = distance or 0

	CopyRenderTargetToTexture(RenderTarget2)

	if blur > 0 then
		OverrideAlphaWriteEnable(true, true)
		BlurRenderTarget(RenderTarget2, spread, spread, blur)
		OverrideAlphaWriteEnable(false, false)
	end

	PopRenderTarget()

	SetTexture(ShadowMaterial, "$basetexture", RenderTarget)
	SetTexture(ShadowMaterialGrayscale, "$basetexture", RenderTarget2)

	local xOffset = sin(rad(direction)) * distance
	local yOffset = cos(rad(direction)) * distance

	SetMaterial(ShadowMaterialGrayscale)
	for i = 1, ceil(intensity) do
		DrawScreenQuadEx(xOffset, yOffset, ScrW(), ScrH())
	end

	if not _shadowOnly then
		SetTexture(ShadowMaterial, "$basetexture", RenderTarget)
		SetMaterial(ShadowMaterial)
		DrawScreenQuad()
	end

	End2D()
end

sui.BSHADOWS = BSHADOWS
--addons/admin_sam_sui/lua/sui/vgui/sui_number_slider.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local NUMBER_SLIDER_FONT = SUI.CreateFont("NumberSlider", "Roboto Regular", 14)

local PANEL = {}

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()

	local slider = vgui.Create(NAME .. ".Slider", self, "NumberSlider")
	slider:Dock(FILL)

	self.slider = slider

	local label = self:Add(NAME .. ".Label")
	label:Dock(RIGHT)
	label:DockMargin(3, 0, 0, 0)
	label:SetFont(NUMBER_SLIDER_FONT)
	self.label = label

	function label:Think()
		self:SetText(slider:GetValue())

		self:SizeToContents()
	end

	self:SetSize(100, 12)
	self:InvalidateLayout(true)
end

sui.register("NumberSlider", PANEL, "Panel")

--addons/admin_sam_sui/lua/sui/vgui/sui_threegrid.lua:
local math = math
local table = table
local ipairs = ipairs

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local Panel = {}

AccessorFunc(Panel, "horizontalMargin", "HorizontalMargin", FORCE_NUMBER)
AccessorFunc(Panel, "verticalMargin", "VerticalMargin", FORCE_NUMBER)
AccessorFunc(Panel, "columns", "Columns", FORCE_NUMBER)
AccessorFunc(Panel, "Wide2", "Wide2", FORCE_NUMBER)

function Panel:Init()
	self:SetHorizontalMargin(0)
	self:SetVerticalMargin(0)
	self.Rows = {}
	self.Cells = {}
end

function Panel:AddCell(pnl)
	local cols = self:GetColumns()
	local idx = math.floor(#self.Cells / cols) + 1

	local rows = self.Rows[idx]
	if not rows then
		rows = self:CreateRow()
		self.Rows[idx] = rows
	end

	local margin = self:GetHorizontalMargin()

	local dockl, dockt, _, dockb = pnl:GetDockMargin()
	pnl:SetParent(rows)
	pnl:Dock(LEFT)
	pnl:DockMargin(dockl, dockt, #rows.Items + 1 < cols and self:GetHorizontalMargin() or 0, dockb)
	pnl:SetWide(((self:GetWide2() or self:GetWide()) - margin * (cols - 1)) / cols)

	table.insert(rows.Items, pnl)
	table.insert(self.Cells, pnl)

	self:CalculateRowHeight(rows)
end

function Panel:CreateRow()
	local row = self:Add("Panel")
	row:Dock(TOP)
	row:DockMargin(0, 0, 0, self:GetVerticalMargin())
	row.Items = {}

	return row
end

function Panel:CalculateRowHeight(row)
	local height = 0

	for k, v in ipairs(row.Items) do
		local _, t, _, b = v:GetDockMargin()
		height = math.max(height, v:GetTall() + t + b)
	end

	row:SetTall(height)
end

function Panel:Skip()
	local cell = vgui.Create("Panel")
	self:AddCell(cell)
end

function Panel:CalculateRowHeights()
	for _, row in ipairs(self.Rows) do
		self:CalculateRowHeight(row)
	end
end

function Panel:Clear()
	for _, row in ipairs(self.Rows) do
		for _, cell in ipairs(row.Items) do
			cell:Remove()
		end

		row:Remove()
	end

	self.Cells, self.Rows = {}, {}
end

Panel.OnRemove = Panel.Clear
sui.register("ThreeGrid", Panel, NAME .. ".ScrollPanel")
--addons/admin_sam_modules/lua/sam/modules/aocrp_commands2.lua:
sam.command.new_argument("subunitauswahl")
    :OnExecute(function(arg, input, ply, _, result)
        table.insert(result, input)
    end)
    :Menu(function(set_result, body, buttons, arg)
        local default = arg.hint or "select"

        local cbo = buttons:Add("SAM.ComboBox")
        cbo:SetValue(default)
		cbo:SetTall(25)

        function cbo:OnSelect(_, value, data)
            print("SetResult to "..data)
            set_result(data)
            default = data
        end

        function cbo:DoClick()
            if self:IsMenuOpen() then
                return self:CloseMenu()
            end

            self:Clear()
            self:SetValue(default)

            for k, v in pairs(AOCRP.Config.SubUnits) do
                self:AddChoice(v.name, k)
            end

            self:OpenMenu()
        end

        return cbo
    end)
:End()



sam.command.set_category("AOCRP")


sam.command.new("subunit")
    :SetPermission("subunit") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Setzte das Platoon eines Spielers")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :AddArg("subunitauswahl", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = 0,
    })   

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, gear)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]

            AOCRP.CharSys:UpdateCharacter(target:GetCloneID(), "subunit", gear, function()
                target:SetSubUnitID(gear)
            end)
            --target:ChatPrint("Du wurdest befördert zum "..AOCRP.Ranks[tonumber(rang)].name )
        end


        sam.player.send_message(nil, "AOCRP | {A} hat {T} in das Platoon {V} gesetzt.", {
            A = calling_ply, T = targets, V = AOCRP.Config.SubUnits[tonumber(gear)].name
        })
    end)
:End()


sam.command.new("tempsubunit")
    :SetPermission("tempsubunit") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Setzte das Platoon eines Spielers temporär")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :AddArg("subunitauswahl", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = 0,
    })   

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, gear)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]

            target:SetSubUnitID(gear)
        end


        sam.player.send_message(nil, "AOCRP | {A} hat {T} in das Platoon {V} gesetzt.", {
            A = calling_ply, T = targets, V = AOCRP.Config.SubUnits[tonumber(gear)].name
        })
    end)
:End()


sam.command.new("qn")
    :SetPermission("qn") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Quickname. Setzt name und hided id temporär")
   
    :AddArg("text", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = "Anzuzeigender Text"
    })


    :OnExecute(function(calling_ply, text)

        calling_ply:SetCloneName(text)
        calling_ply:SetHideCloneID(true)

        sam.player.send_message(nil, "AOCRP | {A} hat QN angewendet", {
            A = calling_ply
        })
    


    end)
:End()




sam.command.new("vip")
    :SetPermission("vip") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Gebe dem Spieler VIP")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = false, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :AddArg("number", {
        optional = false,
        min = 0,
        max = 1
    })

    :OnExecute(function(calling_ply, targets, amount)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]
            target:SetAOCVIP(tobool(amount))
        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat {T} VIP-Status temporär zu {V} geändert.", {
            A = calling_ply, T = targets, V = amount
        })
    end)
:End()


sam.command.new("deletetermin")
    :SetPermission("deletetermin") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   

    :AddArg("number", {
        optional = false,
    })

    :OnExecute(function(calling_ply, amount)

        local insertObj = mysql:Delete("events");
        insertObj:Where("id", amount);
        insertObj:Callback(function(result, status, lastID)
            AOCRP:ReloadEvents()

            sam.player.send_message(nil, "AOCRP | {A} hat Termin mit ID {V} gelöscht.", {
                A = calling_ply, V = amount
            })
        end);

        insertObj:Execute();

    end)
:End()






sam.command.new("modmsg")
    :SetPermission("modmsg") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Schreibe eine ModNachricht")
   
    :AddArg("text", {
        optional = false,
        hint = "Nachricht"
    })

    :OnExecute(function(calling_ply, msg)
        AOCRP.Chat:GlobalPrint(Color(0, 255, 0), "[Moderativer Hinweis] ", Color(255, 255, 255), msg)
    end)
:End()




sam.command.new("hugeboom")
    :SetPermission("hugeboom") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Bombenexplosion ohne Schaden")
   

    :OnExecute(function(calling_ply)

        local eyeTrace = calling_ply:GetEyeTrace()
        
        local pos1 = eyeTrace.HitPos
        ParticleEffect( "explosion_huge", pos1, Angle( 0, 0, 0 ) )
        util.ScreenShake( pos1, 50, 50, 2, BombSystem.radius * 4 )

        BombSystem:MakeBombSound(pos1)

        sam.player.send_message(nil, "AOCRP | {A} hat Hugeboom benutzt", {
            A = calling_ply
        })

    end)
:End()


sam.command.new("ausbilder")
    :SetPermission("ausbilder") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Mache jemand zum Ausbilder oder nich")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })


    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]

            local hide = !target:GetAusbilder()

            local num = 0
            if hide then
                num = 1
            end

            AOCRP.Player:UpdatePlayerVar(target:SteamID64(), "ausbilder", num, function()
                target:SetAusbilder(hide)
            end)
            --target:ChatPrint("Du wurdest befördert zum "..AOCRP.Ranks[tonumber(rang)].name )
        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat den Wert 'Ausbilder' bei {T} umgeschaltet.", {
            A = calling_ply, T = targets
        })
    end)
:End()



sam.command.new_argument("ribbonauswahl")
    :OnExecute(function(arg, input, ply, _, result)
        table.insert(result, input)
    end)
    :Menu(function(set_result, body, buttons, arg)
        local default = arg.hint or "select"

        local cbo = buttons:Add("SAM.ComboBox")
        cbo:SetValue(default)
		cbo:SetTall(25)

        function cbo:OnSelect(_, value, data)
            print("SetResult to "..data)
            set_result(data)
            default = data
        end

        function cbo:DoClick()
            if self:IsMenuOpen() then
                return self:CloseMenu()
            end

            self:Clear()
            self:SetValue(default)

            for k, v in pairs(AOCRP.Ribbons.Data) do
                self:AddChoice(v.name, v.ribbonid)
            end

            self:OpenMenu()
        end

        return cbo
    end)
:End()



sam.command.new("ribbon")
    :SetPermission("ribbon") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Gebe jemanden ein Ribbon auf Char Basis")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = false, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :AddArg("ribbonauswahl", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        hint = "Ribbon",
    })   

      
    :AddArg("text", {
        optional = false,
        hint = "Vergeben von"
    })

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, targets, ribbon, from)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]

            AOCRP.Ribbons:CharGiveRibbon(target, ribbon, from)
        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat {T} das Ribbon {V} gegeben. (char)", {
            A = calling_ply, T = targets, V = ribbon
        })
    end)
:End()



sam.command.new("createribbon")
    :SetPermission("createribbon") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Bruder ohne Einweisung hast du hier nix verloren. Machts du was kaputt fick ich dich")
   

    :AddArg("text", {
        optional = false,
        hint = "Name"
    })
    :AddArg("text", {
        optional = false,
        hint = "Beschreibung"
    })
    :AddArg("text", {
        optional = false,
        hint = "ImggurID"
    })

    -- arrays https://www.lua.org/pil/11.1.html
    :OnExecute(function(calling_ply, name, desc, url)
        
        AOCRP.Ribbons:CreateRibbon(name, desc, url)
 

        sam.player.send_message(nil, "AOCRP | {A} hat das Ribbon {V} erstellt.", {
            A = calling_ply, V = name
        })
    end)
:End()





sam.command.new("globalcutscene")
    :SetPermission("globalcutscene")
    :Help("Play a cutscene to all players on the server.")

    :AddArg("text", {
        hint = "Youtube-Video ID (https://www.youtube.com/watch?v=ViwOPrYEgDA => ViwOPrYEgDA)"
    })
    :AddArg("number", {
        min = 0,
        max = 100,
        round = true,
        hint = "Volume",
        optional = true
    })
    :AddArg("number", {
        min = 0,
        max = 2147483647,
        round = true,
        hint = "Start Seconds",
        optional = true
    })
    :AddArg("number", {
        min = -1,
        max = 2147483647,
        round = true,
        hint = "End Seconds",
        optional = true
    })
    :OnExecute(function(calling_ply, text, volume, startSec, endSec)

        volume = volume or 100
        startSec = startSeconds or 0
        endSec = endSeconds or -1

        net.Start("AOCRP.HUD.CutSceneNew")
            net.WriteString(text)
            net.WriteInt(volume, 8)
            net.WriteInt(startSec, 32)
            net.WriteInt(endSec, 32)
        net.Broadcast()

        sam.player.send_message(nil, "{A} plays a cutscene to all players.", {
            A = calling_ply
        })
    end)
:End()

sam.command.new("cutscene")
    :SetPermission("cutscene")
    :Help("Plays a cutscene to a player. Use globalcutscene to play for all players!")
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })
    :AddArg("text", {
        hint = "Youtube-Video ID (https://www.youtube.com/watch?v=ViwOPrYEgDA => ViwOPrYEgDA)"
    })
    :AddArg("number", {
        min = 0,
        max = 100,
        round = true,
        hint = "Volume",
        optional = true
    })
    :AddArg("number", {
        min = 0,
        max = 2147483647,
        round = true,
        hint = "Start Seconds",
        optional = true
    })
    :AddArg("number", {
        min = -1,
        max = 2147483647,
        round = true,
        hint = "End Seconds",
        optional = true
    })

    :OnExecute(function(calling_ply, targets, text, volume, startSec, endSec)

        volume = volume or 100
        startSec = startSeconds or 0
        endSec = endSeconds or -1
        
        net.Start("AOCRP.HUD.CutSceneNew")
            net.WriteString(text)
            net.WriteInt(volume, 8)
            net.WriteInt(startSec, 32)
            net.WriteInt(endSec, 32)
        net.Send(targets)

        sam.player.send_message(nil, "{A} plays a cutscene for {T}.", {
            A = calling_ply, T = targets
        })
    end)
:End()


sam.command.new("openevent")
    :SetPermission("openevent") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!

    :Help("Öffne den Eventserver (1min Wartezeit).")

    :OnExecute(function(calling_ply)

        --AOCRP:SetEventServerOpenStatus(true)

        RunConsoleCommand("aocrp_eventserver_open", 1)
        AOCRP.Socket.Function["EVENTOPEN"].send(true)

        calling_ply:ChatPrint("Eventserver geöffnet.")

        AOCRP.Discord:Send("Eventserver geöffnet", "Durch: "..calling_ply:Nick() .. " "..calling_ply:SteamID64(), Color(0,255,0), "teamchat")

        sam.player.send_message(nil, "AOCRP | {A} hat den Eventserver geöffnet.", {
            A = calling_ply
        })
    end)
:End()


sam.command.new("closeevent")
    :SetPermission("closeevent") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!

    :Help("Schließe den Eventserver (1min Wartezeit).")

    :OnExecute(function(calling_ply)


        --AOCRP:SetEventServerOpenStatus(false)

        RunConsoleCommand("aocrp_eventserver_open", 0)
        AOCRP.Socket.Function["EVENTOPEN"].send(false)


        calling_ply:ChatPrint("Eventserver geschlossen.")

        AOCRP.Discord:Send("Eventserver geschlossen", "Durch: " .. calling_ply:Nick() .. " " .. calling_ply:SteamID64(), Color(255,0,0), "teamchat")


        sam.player.send_message(nil, "AOCRP | {A} hat den Eventserver geschlossen.", {
            A = calling_ply
        })
    end)
:End()


sam.command.new("heal")
    :SetPermission("heal") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Heile Spieler zu ihren normlane Werten Hoch.")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = false, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })


    :OnExecute(function(calling_ply, targets)

        for i = 1, #targets do
            local target = targets[i]

            target:SetHealth(target:GetMaxHealth())
            target:SetArmor(target:GetMaxArmor())
        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat {T} geheilt.", {
            A = calling_ply, T = targets
        })
    end)
:End()






sam.command.new("restartserver")
    :SetPermission("restartserver") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Restarte den gesamten Server.")
   


    :OnExecute(function(calling_ply)

        AOCRP.HUD:Notification(player.GetHumans(), {text="Der Server startet in zwei Minuten neu!",title="SERVERNEUSTART", titlecolor=Color(255,0,0), barcolor=Color(255,0,0),delay=30,sound="ambient/alarms/klaxon1.wav"}) 

        timer.Simple(30, function() 
            AOCRP.HUD:Notification(player.GetHumans(), {text="Der Server startet in einer Minute und 30 Sekunden neu!",title="SERVERNEUSTART", titlecolor=Color(255,0,0), barcolor=Color(255,0,0),delay=30,sound="ambient/alarms/klaxon1.wav"}) 
        end)
        timer.Simple(60, function() 
            AOCRP.HUD:Notification(player.GetHumans(), {text="Der Server startet in einer Minute neu!",title="SERVERNEUSTART", titlecolor=Color(255,0,0), barcolor=Color(255,0,0),delay=30,sound="ambient/alarms/klaxon1.wav"}) 
        end)
        timer.Simple(90, function() 
            AOCRP.HUD:Notification(player.GetHumans(), {text="Der Server startet in 30 Sekunden neu!",title="SERVERNEUSTART", titlecolor=Color(255,0,0), barcolor=Color(255,0,0),delay=20,sound="ambient/alarms/klaxon1.wav"}) 
        end)
        timer.Simple(110, function() 
            AOCRP.HUD:Notification(player.GetHumans(), {text="Der Server startet in 10 Sekunden neu!",title="SERVERNEUSTART", titlecolor=Color(255,0,0), barcolor=Color(255,0,0),delay=10,sound="ambient/alarms/apc_alarm_pass1.wav"}) 
        end)
        timer.Simple(120, function() 

            local name = calling_ply:Nick() or "Konsole"
            AOCRP.Discord:Send("Age of Clones wird neugestartet", "Durch: "..name, Color(255,0,0), "aocrplog")
    
            AOCRP.PterodactylAPI:RestartServer()
        end)

 

        sam.player.send_message(nil, "AOCRP | {A} führt einen Serverneustart durch", {
            A = calling_ply
        })
    end)
:End()

sam.command.new("enableautolist")
    :SetPermission("enableautolist") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("")
   


    :OnExecute(function(calling_ply)

        RunConsoleCommand("aocrp_autolist",1)

        sam.player.send_message(nil, "AOCRP | {A} hat das Autolist-Gear-Feature aktiviert", {
            A = calling_ply
        })
    end)
:End()



sam.command.new("funkaus")
    :SetPermission("funkaus") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("")
   


    :OnExecute(function(calling_ply)

        SetGlobalNetVar("AOCRP_FUNKAUS", true)
        AOCRP.HUD:Notification(player.GetHumans(), {text="Der Comlink ist ausgefallen..",barcolor=Color(255,0,0),titlecolor=Color(255,0,0),title="Schwerwiegender Fehler",sound="aoc/nextbot/wookie/wookie5.wav",delay=15}) 

   
        sam.player.send_message(nil, "AOCRP | {A} hat den Funk deaktiviert", {
            A = calling_ply
        })
    end)
:End()


sam.command.new("funkan")
    :SetPermission("funkan") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("")
   


    :OnExecute(function(calling_ply)

        SetGlobalNetVar("AOCRP_FUNKAUS", false)

        AOCRP.HUD:Notification(player.GetHumans(), {text="Der Comlink ist wieder funktionsbereit.",barcolor=Color(0,255,0),titlecolor=Color(0,255,0),title="Comlink",sound="aoc/nextbot/b1/kill/yeah.wav",delay=15}) 


        sam.player.send_message(nil, "AOCRP | {A} hat den Funk aktiviert", {
            A = calling_ply
        })
    end)
:End()


sam.command.new("disableautolist")
    :SetPermission("disableautolist") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("")
   


    :OnExecute(function(calling_ply)

        RunConsoleCommand("aocrp_autolist",0)

        sam.player.send_message(nil, "AOCRP | {A} hat das Autolist-Gear-Feature deaktiviert", {
            A = calling_ply
        })
    end)
:End()

sam.command.new("reloadallgears")
    :SetPermission("reloadallgears") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Alle Spieler erneut in ihr Gear laden lassen")
   


    :OnExecute(function(calling_ply)

        for k, v in pairs(player.GetHumans()) do
            AOCRP.Gear:ApplyGear(v, v:GetGearID())
            v:ChatPrint("*** Deine Ausrüstung wurde durch ein Administrator neu geladen.")
        end

        sam.player.send_message(nil, "AOCRP | {A} hat alle Spieler erneut in ihr Gear laden lassen.", {
            A = calling_ply
        })
    end)
:End()


sam.command.new("reloadgear")
    :SetPermission("reloadgear") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Setze Spieler neu in ihr Gear")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = false, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })


    :OnExecute(function(calling_ply, targets)

        for i = 1, #targets do
            local target = targets[i]

            AOCRP.Gear:ApplyGear(target, target:GetGearID())
        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat {T} Gear neugeladen.", {
            A = calling_ply, T = targets
        })
    end)
:End()



sam.command.new("clearnextbots")
    :SetPermission("clearnextbots") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Alle Nextbots löschen")
   


    :OnExecute(function(calling_ply)

        for k, v in pairs(ents.GetAll()) do
            if v:IsNextBot() then
                v:Remove()
            end
        end

        sam.player.send_message(nil, "AOCRP | {A} hat alle Nextbots gelöscht.", {
            A = calling_ply
        })
    end)
:End()





sam.command.new("setfp")
    :SetPermission("fp") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Setze dem Spieler Fähigkeitspunkte.")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = false, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :AddArg("number", {
        optional = false,
    })

    :OnExecute(function(calling_ply, targets, amount)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]

            AOCRP.Ability:SetFP(target, amount)

        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat {T} {V} Fähigkeitspunkte gegeben.", {
            A = calling_ply, T = targets, V = amount
        })
    end)
:End()


sam.command.new("addxp")
    :SetPermission("addxp") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Gebe dem Spieler Erfahrungspunkte.")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = false, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :AddArg("number", {
        optional = false,
    })

    :OnExecute(function(calling_ply, targets, amount)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]

            AOCRP.Ability:AddXP(target, amount,"Administrativ gesetzt")

        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat {T} {V} Erfahrungspunkte gegeben.", {
            A = calling_ply, T = targets, V = amount
        })
    end)
:End()



sam.command.new("rc")
    :SetPermission("rc") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Entfernt den Fähigkeitencooldown.")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = false, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })



    :OnExecute(function(calling_ply, targets)
        local enable_disable

        for i = 1, #targets do
            local target = targets[i]

            
            target:SetNetVar("AOCRP_AbilityDelay", CurTime())

        end
 

        sam.player.send_message(nil, "AOCRP | {A} hat bei {T} den Fähigkeitencooldown entfernt", {
            A = calling_ply, T = targets
        })
    end)
:End()


sam.command.new("olympia")
    :SetPermission("olympia") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Setze die neue Zeit für den Spieler")
   
    :AddArg("player", {
        optional = false, -- makes it target the player who is calling if there is no input, like !god (MAKE SURE TO MAKE IT THE ONLY ARGUMENT)
        single_target = true, -- only targets one player
        cant_target_self = false, -- disallow the player who is calling to target himself
        allow_higher_target = true, -- allow the player who is calling to target anyone, admin -> superadmin, useful for commands like !goto
    })

    :AddArg("dropdown", {
        optional = false,
        hint = "Disziplin",
        options = {"parkour","schnelligkeit","speeder","cqb","sniper"}
    })

    :AddArg("number", {
        optional = false,
        hint = "Zeit"
    })

    :OnExecute(function(calling_ply, targets, diszi, time)
  
        for i = 1, #targets do
            local target = targets[i]

            AOCRP.CharSys:UpdateCharacter(target:GetCloneID(), diszi, time, function()
            end)
        end

      

        sam.player.send_message(nil, "AOCRP | {A} hat {T} in der Disziplin {V} die Zeit von "..time.."s eingetragen.", {
            A = calling_ply, T = targets, V = diszi
        })
    end)
:End()



sam.command.new("stopfire")
    :SetPermission("stopfire") -- OR "superadmin" OR "user" OR remove the second argument for no default access OR just remove that line to make it for everyone!
   
    :Help("Stoppt alles Feuer.")



    :OnExecute(function(calling_ply )

        for k, v in ipairs(ents.GetAll()) do
            if v:IsOnFire() then
                v:Extinguish()
            end
            if v:GetClass() == "fire" then
                v:Remove()
            end
        end

        sam.player.send_message(nil, "AOCRP | {A} hat alle Feuer gelöscht", {
            A = calling_ply
        })
    end)
:End()



sam.command.new("jailban")
	:SetPermission("jailban", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("length", {optional = true, default = 0})
	:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})


	:OnExecute(function(ply, targets, length, reason)
		local target = targets[1]


        AOCRP.Jail:JailBan(target, length, reason, ply)
        VyHub.Ban:createInactive(target:SteamID64(), length, reason, ply:SteamID64())


		sam.player.send_message(nil, "{A} hat {T} für {V} wegen {V_2} ins Gejailbannt.", {
			A = ply, T = target:Name(), V = sam.format_length(length), V_2 = reason
		})
	end)
:End()

sam.command.new("jailbansteamid")
	:SetPermission("jailbansteamid", "admin")

	:AddArg("text", {hint = "steamid"} )
	:AddArg("length", {optional = true, default = 0})
	:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

    :OnExecute(function(ply, steamid, length, reason)
	


                AOCRP.Player:UpdatePlayerVar(steamid, "jailtime", time)
                AOCRP.Player:UpdatePlayerVar(steamid, "jailreason", "JailBan | " .. reason .. " - Durch: "..ply:Name())

                VyHub.Ban:createInactive(steamid, length, reason, ply:SteamID64())
        
        
                sam.player.send_message(nil, "{A} hat {T} für {V} wegen {V_2} ins Gejailbannt.", {
                    A = a_name, T = steamid, V = sam.format_length(length), V_2 = reason
                })
	
	end)
:End()


sam.command.new("removejailban")
	:SetPermission("removejailban", "admin")

	:AddArg("player", {single_target = true})


	:OnExecute(function(ply, targets, length, reason)
		local target = targets[1]



 
        AOCRP.Player:UpdatePlayerVar(target:SteamID64(), "jailtime", 0)
        AOCRP.Player:UpdatePlayerVar(target:SteamID64(), "jailreason", "")
        target.AOCRP_JailBanTime = 0
        target.AOCRP_JailBanReason = ""

        target:SetCloneID(0)
    
        target:KillSilent()
        target:Spawn()

		sam.player.send_message(nil, "{A} hat {T} aus dem Jailban freigelassen.", {
			A = ply, T = target:Name()
		})
	end)
:End()



sam.command.new("trooper")
	:SetPermission("trooper", "admin")

	:AddArg("player", {single_target = true})


	:OnExecute(function(ply, targets, length, reason)
		local target = targets[1]


        AOCRP.CharSys:UpdateCharacter(target:GetCloneID(), "gearid", 166, function()
            target:SetGearID(166)
            target:KillSilent()
            target:Spawn()
    
        end)
        AOCRP.CharSys:UpdateCharacter(target:GetCloneID(), "rankid", 2, function()
            target:SetRankID(2)
        end)
        AOCRP.CharSys:UpdateCharacter(target:GetCloneID(), "unitid", 2, function()
            target:SetUnitID(2)
        end)
        

		sam.player.send_message(nil, "{A} hat {T} zum CT-Trooper ernannt.", {
			A = ply, T = target:Name()
		})
	end)
:End()



sam.command.new("playmusic")
	:SetPermission("playmusic", "admin")

	:AddArg("text", {hint = "Url"} )

    :OnExecute(function(ply, url)
	

        net.Start("AOCRP.Music.Play")
            net.WriteString(url)
        net.Broadcast()
        
                sam.player.send_message(nil, "{A} spielt Musik für alle ab.", {
                    A = ply
                })
	
	end)
:End()


sam.command.new("stopmusic")
	:SetPermission("stopmusic", "admin")



    :OnExecute(function(ply)
	

        net.Start("AOCRP.Music.Stop")
        net.Broadcast()
        
                sam.player.send_message(nil, "{A} stoppt für alle die Musik.", {
                    A = ply
                })
	
	end)
:End()

sam.command.new("evchlimit")
    :SetPermission("evchlimit")
    :Help("Setze das Limit für kaufbare Eventdroiden!")

    :AddArg("number", {
        min = 0,
        max = 25,
        round = true,
        hint = "Anzahl",
        optional = false
    })


    :OnExecute(function(calling_ply, amount)

        SetGlobalNetVar( "AOCRP_EvchrDroid", amount )

        sam.player.send_message(nil, "{A} setzt das Eventcharlimit auf {V}.", {
            A = calling_ply, V = amount
        })
    end)
:End()


sam.command.new("evchbefehl")
    :SetPermission("evchbefehl")
    :Help("Setze ein Befehl an Eventchars")

    :AddArg("text", {hint = "Befehl"} )


    :OnExecute(function(calling_ply, order)

        SetGlobalNetVar( "AOCRP_EvchrOrder", order )

        sam.player.send_message(nil, "{A} hat den Eventchars einen Befehl erteilt.", {
            A = calling_ply
        })
    end)
:End()
sam.command.new("clearevchbefehl")
    :SetPermission("clearevchbefehl")
    :Help("Setze ein Befehl an Eventchars")



    :OnExecute(function(calling_ply, order)

        SetGlobalNetVar( "AOCRP_EvchrOrder", "" )

        sam.player.send_message(nil, "{A} hat den Eventchars einen Befehl erteilt.", {
            A = calling_ply
        })
    end)
:End()

sam.command.new("evchmode")
    :SetPermission("evchmode")
    :Help("Setze den Modus")

    :AddArg("number", {
        min = 1,
        max = 3,
        round = true,
        hint = "1 = Droiden, 2 = Zivilisten, 3 = Humanoide Feinde",
        optional = false
    })


    :OnExecute(function(calling_ply, amount)

        SetGlobalNetVar( "AOCRP_EvchrMode", amount )

        sam.player.send_message(nil, "{A} setzt das Eventchar-Modus auf {V}.", {
            A = calling_ply, V = amount
        })
    end)
:End()


sam.command.new("evchank")
    :SetPermission("evchank")
    :Help("Kündige an das Eventchars kaufbar sind!")



    :OnExecute(function(calling_ply)
        local currentCount = 0
        for k,v in ipairs(player.GetAll()) do 
            if v:GetNetVar("AOCRP_DroidEvchr", false) then
                currentCount = currentCount + 1
            end
        end 
        
        local free = GetGlobalNetVar( "AOCRP_EvchrDroid", 0 ) - currentCount

        AOCRP.HUD:Notification(player.GetHumans(), {text=free.." von ".. GetGlobalNetVar( "AOCRP_EvchrDroid", 0 ) .. " Eventchars-Slots jetzt noch im GTM verfügbar!",title="Eventcharaktere im GTM kaufbar!", titlecolor=Color(180,0,141), barcolor=Color(180,0,141),delay=30,sound="everfall/miscellaneous/ux/rankup/rankup_prestige_01.mp3"}) 


        sam.player.send_message(nil, "{A} hat Angekündigt das Eventcharaketere kaufbar sind.", {
            A = calling_ply
        })
    end)
:End()


--addons/admin_sam/lua/sam/modules/fun.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("Fun")

do
	local sounds = {}
	for i = 1, 6 do
		sounds[i] = "physics/body/body_medium_impact_hard" .. i .. ".wav"
	end

	local slap = function(ply, damage, admin)
		if not ply:Alive() or ply:sam_get_nwvar("frozen") then return end
		ply:ExitVehicle()

		ply:SetVelocity(Vector(math.random(-100, 100), math.random(-100, 100), math.random(200, 400)))
		ply:EmitSound(sounds[math.random(1, 6)], 60, math.random(80, 120))

		if damage > 0 then
			ply:TakeDamage(damage, admin, DMG_GENERIC)
		end
	end

	command.new("slap")
		:SetPermission("slap", "admin")

		:AddArg("player")
		:AddArg("number", {hint = "damage", round = true, optional = true, min = 0, default = 0})

		:Help("slap_help")

		:OnExecute(function(ply, targets, damage)
			for i = 1, #targets do
				slap(targets[i], damage, ply)
			end

			if damage > 0 then
				sam.player.send_message(nil, "slap_damage", {
					A = ply, T = targets, V = damage
				})
			else
				sam.player.send_message(nil, "slap", {
					A = ply, T = targets
				})
			end
		end)
	:End()
end

command.new("slay")
	:SetPermission("slay", "admin")

	:AddArg("player")

	:Help("slay_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			local v = targets[i]
			if not v:sam_get_exclusive(ply) then
				v:Kill()
			end
		end

		sam.player.send_message(nil, "slay", {
			A = ply, T = targets
		})
	end)
:End()

command.new("hp")
	:Aliases("sethp", "health", "sethealth")

	:SetPermission("hp", "admin")

	:AddArg("player")
	:AddArg("number", {hint = "amount", min = 1, max = 2147483647, round = true, optional = true, default = 100})

	:Help("hp_help")

	:OnExecute(function(ply, targets, amount)
		for i = 1, #targets do
			targets[i]:SetHealth(amount)
		end

		sam.player.send_message(nil, "set_hp", {
			A = ply, T = targets, V = amount
		})
	end)
:End()

command.new("armor")
	:Aliases("setarmor")

	:SetPermission("armor", "admin")

	:AddArg("player")
	:AddArg("number", {hint = "amount", min = 1, max = 2147483647, round = true, optional = true, default = 100})

	:Help("armor_help")

	:OnExecute(function(ply, targets, amount)
		for i = 1, #targets do
			targets[i]:SetArmor(amount)
		end

		sam.player.send_message(nil, "set_armor", {
			A = ply, T = targets, V = amount
		})
	end)
:End()

command.new("ignite")
	:SetPermission("ignite", "admin")

	:AddArg("player")
	:AddArg("number", {hint = "seconds", optional = true, default = 60, round = true})

	:Help("ignite_help")

	:OnExecute(function(ply, targets, length)
		for i = 1, #targets do
			local target = targets[i]

			if target:IsOnFire() then
				target:Extinguish()
			end

			target:Ignite(length)
		end

		sam.player.send_message(nil, "ignite", {
			A = ply, T = targets, V = length
		})
	end)
:End()

command.new("unignite")
	:Aliases("extinguish")

	:SetPermission("ignite", "admin")

	:AddArg("player", {optional = true})

	:Help("unignite_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:Extinguish()
		end

		sam.player.send_message(nil, "unignite", {
			A = ply, T = targets
		})
	end)
:End()

command.new("god")
	:Aliases("invincible")

	:SetPermission("god", "admin")

	:AddArg("player", {optional = true})

	:Help("god_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			local target = targets[i]
			target:GodEnable()
			target.sam_has_god_mode = true
		end

		sam.player.send_message(nil, "god", {
			A = ply, T = targets
		})
	end)
:End()

command.new("ungod")
	:Aliases("uninvincible")

	:SetPermission("ungod", "admin")

	:AddArg("player", {optional = true})

	:Help("ungod_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			local target = targets[i]
			target:GodDisable()
			target.sam_has_god_mode = nil
		end

		sam.player.send_message(nil, "ungod", {
			A = ply, T = targets
		})
	end)
:End()

do
	command.new("freeze")
		:SetPermission("freeze", "admin")

		:AddArg("player")

		:Help("freeze_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				local v = targets[i]
				v:ExitVehicle()
				if v:sam_get_nwvar("frozen") then
					v:UnLock()
				end
				v:Lock()
				v:sam_set_nwvar("frozen", true)
				v:sam_set_exclusive("frozen")
			end

			sam.player.send_message(nil, "freeze", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("unfreeze")
		:SetPermission("unfreeze", "admin")

		:AddArg("player", {optional = true})

		:Help("unfreeze_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				local v = targets[i]
				v:UnLock()
				v:sam_set_nwvar("frozen", false)
				v:sam_set_exclusive(nil)
			end

			sam.player.send_message(nil, "unfreeze", {
				A = ply, T = targets
			})
		end)
	:End()

	local disallow = function(ply)
		if ply:sam_get_nwvar("frozen") then
			return false
		end
	end

	for _, v in ipairs({"SAM.CanPlayerSpawn", "CanPlayerSuicide", "CanTool"}) do
		hook.Add(v, "SAM.FreezePlayer." .. v, disallow)
	end
end

command.new("cloak")
	:SetPermission("cloak", "admin")

	:AddArg("player", {optional = true})

	:Help("cloak_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:sam_cloak()
		end

		sam.player.send_message(nil, "cloak", {
			A = ply, T = targets
		})
	end)
:End()

command.new("uncloak")
	:SetPermission("uncloak", "admin")

	:AddArg("player", {optional = true})

	:Help("uncloak_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:sam_uncloak()
		end

		sam.player.send_message(nil, "uncloak", {
			A = ply, T = targets
		})
	end)
:End()

do
	local jail_props = {
		Vector(0, 0, -5), Angle(90, 0, 0);
		Vector(0, 0, 97), Angle(90, 0, 0);

		Vector(21, 31, 46), Angle(0, 90, 0);
		Vector(21, -31, 46), Angle(0, 90, 0);
		Vector(-21, 31, 46), Angle(0, 90, 0);
		Vector(-21, -31, 46), Angle(0, 90, 0);

		Vector(-52, 0, 46), Angle(0, 0, 0);
		Vector(52, 0, 46), Angle(0, 0, 0)
	}

	local remove_jail = function(ply_jail_props)
		for _, jail_prop in ipairs(ply_jail_props) do
			if IsValid(jail_prop) then
				jail_prop:Remove()
			end
		end
	end

	local unjail = function(ply)
		if not IsValid(ply) then return end
		if not ply:sam_get_nwvar("jailed") then return end

		remove_jail(ply.sam_jail_props)

		ply.sam_jail_props = nil
		ply.sam_jail_pos = nil

		ply:sam_set_nwvar("jailed", nil)
		ply:sam_set_exclusive(nil)

		timer.Remove("SAM.Unjail." .. ply:SteamID())
		timer.Remove("SAM.Jail.Watch." .. ply:SteamID())
	end

	local return_false = function()
		return false
	end

	local function jail(ply, time)
		if not IsValid(ply) then return end
		if not isnumber(time) or time < 0 then
			time = 0
		end

		if ply:sam_get_nwvar("frozen") then
			RunConsoleCommand("sam", "unfreeze", "#" .. ply:EntIndex())
		end

		if not ply:sam_get_nwvar("jailed") or (not ply.sam_jail_props or not IsValid(ply.sam_jail_props[1])) then
			ply:ExitVehicle()
			ply:SetMoveType(MOVETYPE_WALK)

			ply.sam_jail_pos = ply:GetPos()

			ply:sam_set_nwvar("jailed", true)
			ply:sam_set_exclusive("in jail")

			if ply.sam_jail_props then
				for k, v in ipairs(ply.sam_jail_props) do
					if IsValid(v) then
						v:Remove()
					end
				end
			end

			local ply_jail_props = {}
			for i = 1, #jail_props, 2 do
				local jail_prop = ents.Create("prop_physics")
				jail_prop:SetModel("models/props_building_details/Storefront_Template001a_Bars.mdl")
				jail_prop:SetPos(ply.sam_jail_pos + jail_props[i])
				jail_prop:SetAngles(jail_props[i + 1])
				jail_prop:SetMoveType(MOVETYPE_NONE)
				jail_prop:Spawn()
				jail_prop:GetPhysicsObject():EnableMotion(false)
				jail_prop.CanTool = return_false
				jail_prop.PhysgunPickup = return_false
				jail_prop.jailWall = true
				table.insert(ply_jail_props, jail_prop)
			end
			ply.sam_jail_props = ply_jail_props
		end

		local steamid = ply:SteamID()

		if time == 0 then
			timer.Remove("SAM.Unjail." .. steamid)
		else
			timer.Create("SAM.Unjail." .. steamid, time, 1, function()
				if IsValid(ply) then
					unjail(ply)
				end
			end)
		end

		timer.Create("SAM.Jail.Watch." .. steamid, 0.5, 0, function()
			if not IsValid(ply) then
				return timer.Remove("SAM.Jail.Watch." .. steamid)
			end

			if ply:GetPos():DistToSqr(ply.sam_jail_pos) > 4900 then
				ply:SetPos(ply.sam_jail_pos)
			end

			if not IsValid(ply.sam_jail_props[1]) then
				jail(ply, timer.TimeLeft("SAM.Unjail." .. steamid) or 0)
			end
		end)
	end

	command.new("jail")
		:SetPermission("jail", "admin")

		:AddArg("player")
		:AddArg("length", {optional = true, default = 0, min = 0})
		:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

		:GetRestArgs()

		:Help("jail_help")

		:OnExecute(function(ply, targets, length, reason)
			for i = 1, #targets do
				jail(targets[i], length * 60)
			end

			sam.player.send_message(nil, "jail", {
				A = ply, T = targets, V = sam.format_length(length), V_2 = reason
			})
		end)
	:End()

	command.new("unjail")
		:SetPermission("unjail", "admin")

		:AddArg("player", {optional = true})

		:Help("unjail_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				unjail(targets[i])
			end

			sam.player.send_message(nil, "unjail", {
				A = ply, T = targets
			})
		end)
	:End()

	sam.hook_first("CanProperty", "SAM.Jail", function(_, property, ent)
		if ent.jailWall and property == "remover" then
			return false
		end
	end)

	if SERVER then
		hook.Add("PlayerSpawn", "SAM.Jail", function(ply)
			if ply:sam_get_nwvar("jailed") or ply:sam_get_pdata("jailed") then
				if ply.sam_jail_pos then
					ply:SetPos(ply.sam_jail_pos)
				else
					ply:SetPos(ply:sam_get_pdata("jail_pos"))
					jail(ply, ply:sam_get_pdata("jail_time_left"))

					ply:sam_set_pdata("jailed", nil)
					ply:sam_set_pdata("jail_pos", nil)
					ply:sam_set_pdata("jail_time_left", nil)
				end
			end
		end)

		hook.Add("PlayerEnteredVehicle", "SAM.Jail", function(ply)
			if ply:sam_get_nwvar("jailed") then
				ply:ExitVehicle()
			end
		end)

		hook.Add("PlayerDisconnected", "SAM.Jail", function(ply)
			if ply:sam_get_nwvar("jailed") then
				remove_jail(ply.sam_jail_props)

				ply:sam_set_pdata("jailed", true)
				ply:sam_set_pdata("jail_pos", ply.sam_jail_pos)
				ply:sam_set_pdata("jail_time_left", timer.TimeLeft("SAM.Unjail." .. ply:SteamID()) or 0)

				timer.Remove("SAM.Unjail." .. ply:SteamID())
				timer.Remove("SAM.Jail.Watch." .. ply:SteamID())
			end
		end)
	end

	local disallow = function(ply)
		if ply:sam_get_nwvar("jailed") then
			return false
		end
	end

	for _, v in ipairs({"PlayerNoClip", "SAM.CanPlayerSpawn", "CanPlayerEnterVehicle", "CanPlayerSuicide", "CanTool"}) do
		hook.Add(v, "SAM.Jail", disallow)
	end
end

command.new("strip")
	:SetPermission("strip", "admin")

	:AddArg("player")

	:Help("strip_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:StripWeapons()
		end

		sam.player.send_message(nil, "strip", {
			A = ply, T = targets
		})
	end)
:End()

command.new("respawn")
	:SetPermission("respawn", "admin")

	:AddArg("player", {optional = true})

	:Help("respawn_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:Spawn()
		end

		sam.player.send_message(nil, "respawn", {
			A = ply, T = targets
		})
	end)
:End()

command.new("setmodel")
	:SetPermission("setmodel", "superadmin")

	:AddArg("player")
	:AddArg("text", {hint = "model"})

	:Help("setmodel_help")

	:OnExecute(function(ply, targets, model)
		for i = 1, #targets do
			targets[i]:SetModel(model)
		end

		sam.player.send_message(nil, "setmodel", {
			A = ply, T = targets, V = model
		})
	end)
:End()

command.new("giveammo")
	:Aliases("ammo")

	:SetPermission("giveammo", "superadmin")

	:AddArg("player")
	:AddArg("number", {hint = "amount", min = 0, max = 99999})

	:Help("giveammo_help")

	:OnExecute(function(ply, targets, amount)
		if amount == 0 then
			amount = 99999
		end

		for i = 1, #targets do
			local target = targets[i]
			for _, wep in ipairs(target:GetWeapons()) do
				if wep:GetPrimaryAmmoType() ~= -1 then
					target:GiveAmmo(amount, wep:GetPrimaryAmmoType(), true)
				end

				if wep:GetSecondaryAmmoType() ~= -1 then
					target:GiveAmmo(amount, wep:GetSecondaryAmmoType(), true)
				end
			end
		end

		sam.player.send_message(nil, "giveammo", {
			A = ply, T = targets, V = amount
		})
	end)
:End()

do
	command.new("scale")
		:SetPermission("scale", "superadmin")

		:AddArg("player")
		:AddArg("number", {hint = "amount", optional = true, min = 0, max = 2.5, default = 1})

		:Help("scale_help")

		:OnExecute(function(ply, targets, amount)
			for i = 1, #targets do
				local v = targets[i]
				v:SetModelScale(amount)

				-- https://github.com/carz1175/More-ULX-Commands/blob/9b142ee4247a84f16e2dc2ec71c879ab76e145d4/lua/ulx/modules/sh/extended.lua#L313
				v:SetViewOffset(Vector(0, 0, 64 * amount))
				v:SetViewOffsetDucked(Vector(0, 0, 28 * amount))

				v.sam_scaled = true
			end

			sam.player.send_message(nil, "scale", {
				A = ply, T = targets, V = amount
			})
		end)
	:End()

	hook.Add("PlayerSpawn", "SAM.Scale", function(ply)
		if ply.sam_scaled then
			ply.sam_scaled = nil
			ply:SetViewOffset(Vector(0, 0, 64))
			ply:SetViewOffsetDucked(Vector(0, 0, 28))
		end
	end)
end

sam.command.new("freezeprops")
	:SetPermission("freezeprops", "admin")
	:Help("freezeprops_help")

	:OnExecute(function(ply)
		for _, prop in ipairs(ents.FindByClass("prop_physics")) do
			local physics_obj = prop:GetPhysicsObject()
			if IsValid(physics_obj) then
				physics_obj:EnableMotion(false)
			end
		end

		sam.player.send_message(nil, "freezeprops", {
			A = ply
		})
	end)
:End()
--addons/joes_stuff/lua/joe_base/cl_adminmenu.lua:
local frame
local addlist
local data = {}
local background = Color(30,30,30)
local outline = Color(144,0,255)
local text = Color(255,255,255)

local uptodate = Color(0,255,0,180)
local outofdate = Color(255,0,0,180)
local clsbtnclr = Color(255,0,0)
local missing = Color(255,150,0,180)


local function DrawAddons()
    if not IsValid(addlist) then print(1) return end
    addlist:Clear()
    if not data or table.Count(data) < 1 then print(2) return end
    local scrw,scrh = ScrW(),ScrH()
    for name,versioninfo in pairs(data) do
        local info = vgui.Create("DPanel", addlist)
        info:SetSize(scrw * 0.2,scrh * 0.05)
        info:Dock(TOP)
        if versioninfo == true then
            info.state = "Installed"
        elseif versioninfo != false then
            info.state = "Update needed!"
        else
            info.state = "Not Installed"
        end
        info:DockMargin(scrw * 0.01, scrw * 0.0125, scrw * 0.01, 0)
        info.Paint = function(s,w,h)
            if versioninfo == true then
                surface.SetDrawColor(uptodate)
            elseif versioninfo != false then
                surface.SetDrawColor(outofdate)
            else
                surface.SetDrawColor(missing)
            end
            surface.DrawRect(0,0,w,h)
            surface.SetDrawColor(outline)
            surface.DrawOutlinedRect(0,0,w,h,scrw * 0.002)

            draw.SimpleText(name..":", "DermaLarge", w * 0.03, h * 0.5, text, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
            draw.SimpleText(s.state, "DermaLarge", w * 0.96, h * 0.5, text, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
        end
    end
end

function JoeBase:OpenMenu()
    if IsValid(frame) then frame:Remove() end
    local scrw,scrh = ScrW(),ScrH()

    frame = vgui.Create("DFrame")
    frame:SetSize(scrw * 0.25,scrh * 0.775)
    frame:Center()
    frame:SetTitle("")
    frame:MakePopup()
    frame:ShowCloseButton(false)
    frame.Paint = function(s,w,h)
        surface.SetDrawColor(background)
        surface.DrawRect(0,0,w,h)
        surface.SetDrawColor(outline)
        surface.DrawOutlinedRect(0,0,w,h,scrw * 0.002)
    end

    local clsbtn = vgui.Create("DButton", frame)
    clsbtn:SetPos(scrw * 0.225,scrh * 0.006)
    clsbtn:SetText("X")
    clsbtn:SetColor(clsbtnclr)
    clsbtn:SetFont("DermaLarge")
    clsbtn.DoClick = function()
        frame:Remove()
    end
    clsbtn.Paint = function() end

    addlist = vgui.Create("DScrollPanel",frame)
    addlist:SetPos(0,scrh * 0.025)
    addlist:SetSize(scrw * 0.25,scrh * 0.75)
    addlist:GetVBar():SetSize(0)

    DrawAddons()
end

net.Receive("JoeBase_AdminMenu", function()
    data = net.ReadTable()
    JoeBase:OpenMenu()
end)

net.Receive("JoeBase_Refreshdata", function()
    if not IsValid(frame) then return end
    data = net.ReadTable()
    DrawAddons()
end)

hook.Add("InitPostEntity", "JoeBase:OpenMenu", function()
    local ply = LocalPlayer()
    if not ply:IsAdmin() and not ply:IsSuperAdmin() then return end
--[[     net.Start("JoeBase_AdminMenu")
    net.SendToServer() ]]
end)

concommand.Add("joescripts", function()
    net.Start("JoeBase_AdminMenu")
    net.SendToServer()
end)
--addons/joes_stuff/lua/autorun/sh_joe_shield_autoload.lua:
SWRPShield = SWRPShield or {}
SWRPShield.ents = {}
SWRPShield.Version = "2.3"

if SERVER then
    if JoeBase then
        JoeBase:RegisterProduct("Shield Generator", SWRPShield.Version)
    else
        hook.Add("JoeBase:FinishedLoading", "SWRPShield:Register", function()
            JoeBase:RegisterProduct("Shield Generator", SWRPShield.Version)
        end)
    end
end

local mainfolder = "shieldsystem/"
-- sh files
for k,v in pairs(file.Find(mainfolder .. "sh_*", "LUA")) do
    include(mainfolder .. tostring(v))
    if SERVER then AddCSLuaFile(mainfolder .. tostring(v)) end
end

-- sv files
if SERVER then
    for k,v in pairs(file.Find(mainfolder .. "sv_*", "LUA")) do
        include(mainfolder .. tostring(v))
    end
end
-- cl files
for k,v in pairs(file.Find(mainfolder .. "cl_*", "LUA")) do
    if SERVER then AddCSLuaFile(mainfolder ..  tostring(v))
    else include(mainfolder .. tostring(v))
    end
end
--addons/aocrp_pixelui/lua/pixelui/drawing/cl_misc.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

function PIXEL.DrawRoundedTextBox(text, font, x, y, xAlign, textCol, boxRounding, boxPadding, boxCol)
    local boxW, boxH = PIXEL.GetTextSize(text, font)

    local dblPadding = boxPadding * 2
    if xAlign == TEXT_ALIGN_CENTER then
        PIXEL.DrawRoundedBox(boxRounding, x - boxW / 2 - boxPadding, y - boxPadding, boxW + dblPadding, boxH + dblPadding, boxCol)
    elseif xAlign == TEXT_ALIGN_RIGHT then
        PIXEL.DrawRoundedBox(boxRounding, x - boxW - boxPadding, y - boxPadding, boxW + dblPadding, boxH + dblPadding, boxCol)
    else
        PIXEL.DrawRoundedBox(boxRounding, x - boxPadding, y - boxPadding, boxW + dblPadding, boxH + dblPadding, boxCol)
    end

    PIXEL.DrawText(text, font, x, y, textCol, xAlign)
end

function PIXEL.DrawFixedRoundedTextBox(text, font, x, y, xAlign, textCol, boxRounding, w, h, boxCol, textPadding)
    PIXEL.DrawRoundedBox(boxRounding, x, y, w, h, boxCol)

    if xAlign == TEXT_ALIGN_CENTER then
        PIXEL.DrawSimpleText(text, font, x + w / 2, y + h / 2, textCol, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        return
    end

    if xAlign == TEXT_ALIGN_RIGHT then
        PIXEL.DrawSimpleText(text, font, x + w - textPadding, y + h / 2, textCol, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
        return
    end

    PIXEL.DrawSimpleText(text, font, x + textPadding, y + h / 2, textCol, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
end

local blurPassesCvar = CreateClientConVar("pixel_ui_blur_passes", "4", true, false, "Amount of passes to draw blur with. 0 to disable blur entirely.", 0, 15)
local blurPassesNum = blurPassesCvar:GetInt()

cvars.AddChangeCallback("pixel_ui_blur_passes", function(_, _, passes)
    blurPassesNum = math.floor(tonumber(passes) + 0.05)
end )

local blurMat = Material("pp/blurscreen")
local scrW, scrH = ScrW, ScrH
function PIXEL.DrawBlur(panel, localX, localY, w, h)
    if blurPassesNum == 0 then return end
    local x, y = panel:LocalToScreen(localX, localY)
    local scrw, scrh = scrW(), scrH()

    surface.SetMaterial(blurMat)
    surface.SetDrawColor(255, 255, 255)

    for i = 0, blurPassesNum do
        blurMat:SetFloat("$blur", i * .33)
        blurMat:Recompute()
    end
    render.UpdateScreenEffectTexture()
    surface.DrawTexturedRect(x * -1, y * -1, scrw, scrh)
end
--addons/aocrp_pixelui/lua/pixelui/elements/cl_check_box.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

function PANEL:Init()
    self:SetIsToggle(true)

    local boxSize = PIXEL.Scale(20)
    self:SetSize(boxSize, boxSize)

    self:SetImgurID("YvG7VI6")

    self:SetNormalColor(PIXEL.Colors.Transparent)
    self:SetHoverColor(PIXEL.Colors.PrimaryText)
    self:SetClickColor(PIXEL.Colors.PrimaryText)
    self:SetDisabledColor(PIXEL.Colors.Transparent)

    self:SetImageSize(.8)

    self.BackgroundCol = PIXEL.CopyColor(PIXEL.Colors.Primary)
end

function PANEL:PaintBackground(w, h)
    if not self:IsEnabled() then
        PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, PIXEL.Colors.Disabled)
        self:PaintExtra(w, h)
        return
    end

    local bgCol = PIXEL.Colors.Primary

    if self:IsDown() or self:GetToggle() then
        bgCol = PIXEL.Colors.Positive
    end

    local animTime = FrameTime() * 12
    self.BackgroundCol = PIXEL.LerpColor(animTime, self.BackgroundCol, bgCol)

    PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, self.BackgroundCol)
end

vgui.Register("PIXEL.Checkbox", PANEL, "PIXEL.ImgurButton")
--addons/aocrp_pixelui/lua/pixelui/elements/cl_label.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

AccessorFunc(PANEL, "Text", "Text", FORCE_STRING)
AccessorFunc(PANEL, "Font", "Font", FORCE_STRING)
AccessorFunc(PANEL, "TextAlign", "TextAlign", FORCE_NUMBER)
AccessorFunc(PANEL, "TextColor", "TextColor")
AccessorFunc(PANEL, "Ellipses", "Ellipses", FORCE_BOOL)
AccessorFunc(PANEL, "AutoHeight", "AutoHeight", FORCE_BOOL)
AccessorFunc(PANEL, "AutoWidth", "AutoWidth", FORCE_BOOL)
AccessorFunc(PANEL, "AutoWrap", "AutoWrap", FORCE_BOOL)

PIXEL.RegisterFont("UI.Label", "Open Sans SemiBold", 14)

function PANEL:Init()
    self:SetText("Label")
    self:SetFont("UI.Label")
    self:SetTextAlign(TEXT_ALIGN_LEFT)
    self:SetTextColor(PIXEL.Colors.SecondaryText)
end

function PANEL:SetText(text)
    self.Text = text
    self.OriginalText = text
end

function PANEL:CalculateSize()
    PIXEL.SetFont(self:GetFont())
    return PIXEL.GetTextSize(self:GetText())
end

function PANEL:PerformLayout(w, h)
    local desiredW, desiredH = self:CalculateSize()

    if self:GetAutoWidth() then
        self:SetWide(desiredW)
    end

    if self:GetAutoHeight() then
        self:SetTall(desiredH)
    end

    if self:GetAutoWrap() then
        self.Text = PIXEL.WrapText(self.OriginalText, w, self:GetFont())
    end
end

function PANEL:Paint(w, h)
    local align = self:GetTextAlign()
    local text = self:GetEllipses() and PIXEL.EllipsesText(self:GetText(), w, self:GetFont()) or self:GetText()

    if align == TEXT_ALIGN_CENTER then
        PIXEL.DrawText(text, self:GetFont(), w / 2, 0, self:GetTextColor(), TEXT_ALIGN_CENTER)
        return
    elseif align == TEXT_ALIGN_RIGHT then
        PIXEL.DrawText(text, self:GetFont(), w, 0, self:GetTextColor(), TEXT_ALIGN_RIGHT)
        return
    end

    PIXEL.DrawText(text, self:GetFont(), 0, 0, self:GetTextColor())
end

vgui.Register("PIXEL.Label", PANEL, "Panel")
--addons/aocrp_pixelui/lua/pixelui/elements/cl_menu.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

AccessorFunc(PANEL, "m_bBorder", "DrawBorder")
AccessorFunc(PANEL, "m_bDeleteSelf", "DeleteSelf")
AccessorFunc(PANEL, "m_iMinimumWidth", "MinimumWidth")
AccessorFunc(PANEL, "m_bDrawColumn", "DrawColumn")
AccessorFunc(PANEL, "m_iMaxHeight", "MaxHeight")
AccessorFunc(PANEL, "m_pOpenSubMenu", "OpenSubMenu")

function PANEL:Init()
    self:SetIsMenu(true)
    self:SetDrawBorder(true)
    self:SetPaintBackground(true)
    self:SetMinimumWidth(PIXEL.Scale(100))
    self:SetDrawOnTop(true)
    self:SetMaxHeight(ScrH() * 0.3)
    self:SetDeleteSelf(true)
    self:SetBarDockShouldOffset(true)

    self:SetPadding(0)

    self.BackgroundCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 10)

    RegisterDermaMenuForClose(self)
end

function PANEL:AddPanel(pnl)
    self:AddItem(pnl)
    pnl.ParentMenu = self
end

function PANEL:AddOption(strText, funcFunction)
    local pnl = vgui.Create("PIXEL.MenuOption", self)
    pnl:SetMenu(self)
    pnl:SetText(strText)
    if funcFunction then pnl.DoClick = funcFunction end

    self:AddPanel(pnl)

    return pnl
end

function PANEL:AddCVar(strText, convar, on, off, funcFunction)
    local pnl = vgui.Create("PIXEL.MenuOptionCVar", self)
    pnl:SetMenu(self)
    pnl:SetText(strText)
    if funcFunction then pnl.DoClick = funcFunction end

    pnl:SetConVar(convar)
    pnl:SetValueOn(on)
    pnl:SetValueOff(off)

    self:AddPanel(pnl)

    return pnl
end

function PANEL:AddSpacer(text, func)
    local pnl = vgui.Create("Panel", self)

    local spacerCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 6)
    pnl.Paint = function(p, w, h)
        surface.SetDrawColor(spacerCol)
        surface.DrawRect(0, 0, w, h)
    end

    pnl:SetTall(PIXEL.Scale(3))
    self:AddPanel(pnl)

    return pnl
end

function PANEL:AddSubMenu(strText, funcFunction)
    local pnl = vgui.Create("PIXEL.MenuOption", self)
    local subMenu = pnl:AddSubMenu(strText, funcFunction)

    pnl:SetText(strText)
    if funcFunction then pnl.DoClick = funcFunction end

    self:AddPanel(pnl)

    return subMenu, pnl
end

function PANEL:Hide()
    local openmenu = self:GetOpenSubMenu()
    if openmenu then
        openmenu:Hide()
    end

    self:SetVisible(false)
    self:SetOpenSubMenu(nil)
end

function PANEL:OpenSubMenu(item, menu)
    local openmenu = self:GetOpenSubMenu()
    if IsValid(openmenu) and openmenu:IsVisible() then
        if menu and openmenu == menu then return end

        self:CloseSubMenu(openmenu)
    end

    if not IsValid(menu) then return end

    local x, y = item:LocalToScreen(self:GetWide(), 0)
    menu:Open(x, y, false, item)

    self:SetOpenSubMenu(menu)
end

function PANEL:CloseSubMenu(menu)
    menu:Hide()
    self:SetOpenSubMenu(nil)
end

function PANEL:Paint(w, h)
    PIXEL.DrawRoundedBox(PIXEL.Scale(4), 0, 0, w, h, self.BackgroundCol)
end

function PANEL:ChildCount()
    return #self:GetCanvas():GetChildren()
end

function PANEL:GetChild(num)
    return self:GetCanvas():GetChildren()[num]
end

function PANEL:LayoutContent(w, h)
    w = self:GetMinimumWidth()

    local children = self:GetCanvas():GetChildren()
    for k, pnl in pairs(children) do
        pnl:InvalidateLayout(true)
        w = math.max(w, pnl:GetWide())
    end

    self:SetWide(w)

    local y = 0
    for k, pnl in pairs(children) do
        pnl:SetWide(w)
        pnl:SetPos(0, y)
        pnl:InvalidateLayout(true)

        y = y + pnl:GetTall()
    end

    y = math.min(y, self:GetMaxHeight())

    self:SetTall(y)

    local overlap = select(2, self:LocalToScreen(0, y)) - ScrH()
    if overlap > 0 then
        self:SetPos(self:GetPos(), select(2, self:GetPos()) - overlap)
    end
end

function PANEL:Open(x, y, skipanimation, ownerpanel)
    RegisterDermaMenuForClose(self)

    local maunal = x and y
    x = x or gui.MouseX()
    y = y or gui.MouseY()

    local ownerHeight = 0
    if ownerpanel then ownerHeight = ownerpanel:GetTall() end

    self:InvalidateLayout(true)

    local w, h = self:GetWide(), self:GetTall()

    self:SetSize(w, h)

    if y + h > ScrH() then y = ((maunal and ScrH()) or (y + ownerHeight)) - h end
    if x + w > ScrW() then x = ((maunal and ScrW()) or x) - w end
    if y < 1 then y = 1 end
    if x < 1 then x = 1 end

    self:SetPos(x, y)

    self:MakePopup()
    self:SetVisible(true)
    self:SetKeyboardInputEnabled(false)
end

function PANEL:OptionSelectedInternal(option)
    self:OptionSelected(option, option:GetText())
end

function PANEL:OptionSelected(option, text) end

function PANEL:ClearHighlights()
    for k, pnl in pairs(self:GetCanvas():GetChildren()) do
        pnl.Highlight = nil
    end
end

function PANEL:HighlightItem(item)
    for k, pnl in pairs(self:GetCanvas():GetChildren()) do
        if pnl == item then
            pnl.Highlight = true
        end
    end
end

vgui.Register("PIXEL.Menu", PANEL, "PIXEL.ScrollPanel")
--addons/aocrp_pixelui/lua/pixelui/elements/cl_menu_option.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

AccessorFunc(PANEL, "m_pMenu", "Menu")
AccessorFunc(PANEL, "m_bChecked", "Checked")
AccessorFunc(PANEL, "m_bCheckable", "IsCheckable")

AccessorFunc(PANEL, "Text", "Text", FORCE_STRING)
AccessorFunc(PANEL, "TextAlign", "TextAlign", FORCE_NUMBER)
AccessorFunc(PANEL, "Font", "Font", FORCE_STRING)

PIXEL.RegisterFont("UI.MenuOption", "Open Sans SemiBold", 18)

function PANEL:Init()
    self:SetTextAlign(TEXT_ALIGN_LEFT)
    self:SetFont("UI.MenuOption")
    self:SetChecked(false)

    self.NormalCol = PIXEL.Colors.Transparent
    self.HoverCol = PIXEL.Colors.Scroller

    self.BackgroundCol = PIXEL.CopyColor(self.NormalCol)
end

function PANEL:SetIcon() end

function PANEL:SetSubMenu(menu)
    self.SubMenu = menu
end

function PANEL:AddSubMenu()
    local subMenu = vgui.Create("PIXEL.Menu", self)
    subMenu:SetVisible(false)
    subMenu:SetParent(self)

    self:SetSubMenu(subMenu)

    return subMenu
end

function PANEL:OnCursorEntered()
    local parent = self.ParentMenu
    if not IsValid(parent) then parent = self:GetParent() end
    if not IsValid(parent) then return end

    if not parent.OpenSubMenu then return end
    parent:OpenSubMenu(self, self.SubMenu)
end

function PANEL:OnCursorExited() end

function PANEL:Paint(w, h)
    self.BackgroundCol = PIXEL.LerpColor(FrameTime() * 12, self.BackgroundCol, self:IsHovered() and self.HoverCol or self.NormalCol)

    surface.SetDrawColor(self.BackgroundCol)
    surface.DrawRect(0, 0, w, h)

    PIXEL.DrawSimpleText(self:GetText(), self:GetFont(), PIXEL.Scale(14), h / 2, PIXEL.Colors.PrimaryText, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

    if not self.SubMenu then return end
    local dropBtnSize = PIXEL.Scale(8)
    PIXEL.DrawImgur(w - dropBtnSize - PIXEL.Scale(6), h / 2 - dropBtnSize / 2, dropBtnSize, dropBtnSize, "gXg3U6X", PIXEL.Colors.PrimaryText)
end

function PANEL:OnPressed(mousecode)
    self.m_MenuClicking = true
end

function PANEL:OnReleased(mousecode)
    if not self.m_MenuClicking and mousecode == MOUSE_LEFT then return end
    self.m_MenuClicking = false
    CloseDermaMenus()
end

function PANEL:DoRightClick()
    if self:GetIsCheckable() then
        self:ToggleCheck()
    end
end

function PANEL:DoClickInternal()
    if self:GetIsCheckable() then
        self:ToggleCheck()
    end

    if not self.m_pMenu then return end
    self.m_pMenu:OptionSelectedInternal(self)
end

function PANEL:ToggleCheck()
    self:SetChecked(not self:GetChecked())
    self:OnChecked(self:GetChecked())
end

function PANEL:OnChecked(enabled) end

function PANEL:CalculateWidth()
    PIXEL.SetFont(self:GetFont())
    return PIXEL.GetTextSize(self:GetText()) + PIXEL.Scale(34)
end

function PANEL:PerformLayout(w, h)
    self:SetSize(math.max(self:CalculateWidth(), self:GetWide()), PIXEL.Scale(32))
end

vgui.Register("PIXEL.MenuOption", PANEL, "PIXEL.Button")

PANEL = {}

AccessorFunc(PANEL, "ConVar", "ConVar")
AccessorFunc(PANEL, "ValueOn", "ValueOn")
AccessorFunc(PANEL, "ValueOff", "ValueOff")

function PANEL:Init()
    self:SetChecked(false)
    self:SetIsCheckable(true)
    self:SetValueOn("1")
    self:SetValueOff("0")
end

function PANEL:Think()
    if not self.ConVar then return end
    self:SetChecked(GetConVar(self.ConVar):GetString() == self.ValueOn)
end

function PANEL:OnChecked(checked)
    if not self.ConVar then return end
    RunConsoleCommand(self.ConVar, checked and self.ValueOn or self.ValueOff)
end

vgui.Register("PIXEL.MenuOptionCVar", PANEL, "PIXEL.MenuOption")
--addons/aocrp_pixelui/lua/pixelui/elements/cl_scrollbar.lua:

--[[
PIXEL UI
Copyright (C) 2021 Tom O'Sullivan (Tom.bat)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
]]

local PANEL = {}

function PANEL:Init()
    self.NormalCol = PIXEL.Colors.Scroller
    self.HoverCol = PIXEL.OffsetColor(self.NormalCol, 15)

    self.Colour = PIXEL.CopyColor(self.NormalCol)
end

function PANEL:OnMousePressed()
    self:GetParent():Grip(1)
end

function PANEL:Paint(w, h)
    self.Colour = PIXEL.LerpColor(FrameTime() * 12, self.Colour,
        (self:IsHovered() or self:GetParent().Dragging) and self.HoverCol or self.NormalCol
    )

    PIXEL.DrawRoundedBox(w / 2, 0, 0, w, h, self.Colour)
end

vgui.Register("PIXEL.ScrollbarGrip", PANEL, "Panel")

PANEL = {}

AccessorFunc(PANEL, "m_bVisibleFullHeight", "VisibleFullHeight", FORCE_BOOL)

function PANEL:Init()
    self.Offset = 0
    self.Scroll = 0
    self.CanvasSize = 1
    self.BarSize = 1

    self.BackgroundCol = PIXEL.OffsetColor(PIXEL.Colors.Background, 5)

    self.Scrollbar = vgui.Create("PIXEL.ScrollbarGrip", self)
    self:SetVisibleFullHeight(false)
end

function PANEL:SetEnabled(b)
    if not b then
        self.Offset = 0
        self:SetScroll(0)
        self.HasChanged = true
    end

    self:SetMouseInputEnabled(b)

    if not self:GetVisibleFullHeight() then
        self:SetVisible(b)
    end

    if self.Enabled != b then
        self:GetParent():InvalidateLayout()

        if self:GetParent().OnScrollbarAppear then
            self:GetParent():OnScrollbarAppear()
        end
    end

    self.Enabled = b
end

function PANEL:GetEnabled()
    return self.Enabled
end

function PANEL:Value()
    return self.Pos
end

function PANEL:BarScale()
    if self.BarSize == 0 then return 1 end
    return self.BarSize / (self.CanvasSize + self.BarSize)
end

function PANEL:SetUp(barSize, canvasSize)
    self.BarSize = barSize
    self.CanvasSize = math.max(canvasSize - barSize, 1)

    self:SetEnabled(canvasSize > barSize)

    self:InvalidateLayout()
end

function PANEL:OnMouseWheeled(dlta)
    if not self:IsVisible() then return false end
    return self:AddScroll(dlta * -2)
end

function PANEL:AddScroll(dlta)
    local oldScroll = self:GetScroll()

    dlta = dlta * 25
    self:SetScroll(oldScroll + dlta)

    return oldScroll != self:GetScroll()
end

function PANEL:SetScroll(scrll)
    if not self.Enabled then self.Scroll = 0 return end

    self.Scroll = math.Clamp(scrll, 0, self.CanvasSize + 75)

    self:InvalidateLayout()

    local func = self:GetParent().OnVScroll
    if func then
        func(self:GetParent(), self:GetOffset())
    else
        self:GetParent():InvalidateLayout()
    end
end

function PANEL:LimitScroll()
    if self.Scroll < 0 or self.Scroll > self.CanvasSize then
        self.Scroll = math.Clamp(self.Scroll, -75, self.CanvasSize + 75)
    end
end

function PANEL:AnimateTo(scrll, length, delay, ease)
    local anim = self:NewAnimation(length, delay, ease)
    anim.StartPos = self.Scroll
    anim.TargetPos = scrll
    anim.Think = function(an, pnl, fraction)
        pnl:SetScroll(Lerp(fraction, an.StartPos, an.TargetPos))
    end
end

function PANEL:GetScroll()
    if not self.Enabled then self.Scroll = 0 end
    return self.Scroll
end

function PANEL:GetOffset()
    if not self.Enabled then return 0 end
    return self.Scroll * -1
end

function PANEL:Think() end

function PANEL:OnMousePressed()
    if select(2, self:CursorPos()) > self.Scrollbar.y then
        self:SetScroll(self:GetScroll() + self.BarSize)
    else
        self:SetScroll(self:GetScroll() - self.BarSize)
    end
end

function PANEL:OnMouseReleased()
    self.Dragging = false
    self.DraggingCanvas = nil
    self:MouseCapture(false)

    self.Scrollbar.Depressed = false
end

function PANEL:OnCursorMoved(x, y)
    if not self.Enabled or not self.Dragging then return end

    y = select(2, self:ScreenToLocal(0, gui.MouseY())) - self.HoldPos

    local trackSize = self:GetTall() - self.Scrollbar:GetTall()
    y = y / trackSize

    self:SetScroll(math.Clamp(y * self.CanvasSize, 0, self.CanvasSize))
end

function PANEL:Grip()
    if not self.Enabled or self.BarSize == 0 then return end

    self:MouseCapture(true)
    self.Dragging = true

    self.HoldPos = select(2, self.Scrollbar:ScreenToLocal(x, gui.MouseY()))

    self.Scrollbar.Depressed = true
end

function PANEL:PerformLayout(w, h)
    self:LimitScroll()

    local scroll = self:GetScroll() / self.CanvasSize
    local barSize = math.max(self:BarScale() * self:GetTall(), 10)
    local track = self:GetTall() - barSize
    track = track + 1

    scroll = scroll * track

    local barStart = math.max(scroll, 0)
    local barEnd = math.min(scroll + barSize, self:GetTall())

    self.Scrollbar:SetPos(0, barStart)
    self.Scrollbar:SetSize(w, barEnd - barStart)
end

function PANEL:Paint(w, h)
    PIXEL.DrawRoundedBox(w / 2, 0, 0, w, h, self.BackgroundCol)
end

vgui.Register("PIXEL.Scrollbar", PANEL, "Panel")
--addons/aocrp_pixelui/lua/pixelui/libraries/cl_arc.lua:
--https://gist.github.com/theawesomecoder61/d2c3a3d42bbce809ca446a85b4dda754

-- Draws an arc on your screen.
-- startang and endang are in degrees, 
-- radius is the total radius of the outside edge to the center.
-- cx, cy are the x,y coordinates of the center of the arc.
-- roughness determines how many triangles are drawn. Number between 1-360; 2 or 3 is a good number.
function PIXEL.DrawUncachedArc(cx, cy, radius, thickness, startang, endang, roughness, color)
    surface.SetDrawColor(color)
    PIXEL.DrawArc(PIXEL.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness))
end

function PIXEL.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    local triarc = {}
    -- local deg2rad = math.pi / 180
    -- Define step
    roughness = math.max(roughness or 1, 1)
    local step = roughness
    -- Correct start/end ang
    startang, endang = startang or 0, endang or 0

    if startang > endang then
        step = math.abs(step) * -1
    end

    -- Create the inner circle's points.
    local inner = {}
    local r = radius - thickness

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        -- local rad = deg2rad * deg
        local ox, oy = cx + (math.cos(rad) * r), cy + (-math.sin(rad) * r)

        table.insert(inner, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5
        })
    end

    -- Create the outer circle's points.
    local outer = {}

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        -- local rad = deg2rad * deg
        local ox, oy = cx + (math.cos(rad) * radius), cy + (-math.sin(rad) * radius)

        table.insert(outer, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5
        })
    end

    -- Triangulize the points.
    -- twice as many triangles as there are degrees.
    for tri = 1, #inner * 2 do
        local p1, p2, p3
        p1 = outer[math.floor(tri / 2) + 1]
        p3 = inner[math.floor((tri + 1) / 2) + 1]

        --if the number is even use outer.
        if tri % 2 == 0 then
            p2 = outer[math.floor((tri + 1) / 2)]
        else
            p2 = inner[math.floor((tri + 1) / 2)]
        end

        table.insert(triarc, {p1, p2, p3})
    end
    -- Return a table of triangles to draw.

    return triarc
end

--Draw a premade arc.
function PIXEL.DrawArc(arc)
    for k, v in ipairs(arc) do
        surface.DrawPoly(v)
    end
end

--addons/joes_stuff/lua/autorun/sh_shielddlc_autoload.lua:
SWRPShieldDLC = SWRPShieldDLC or {}
SWRPShieldDLC.Version = "1.1"

if SERVER then
    if JoeBase then
        JoeBase:RegisterProduct("Shield DLC", SWRPShieldDLC.Version)
    else
        hook.Add("JoeBase:FinishedLoading", "SWRPShieldDLC:Register", function()
            JoeBase:RegisterProduct("Shield DLC", SWRPShieldDLC.Version)
        end)
    end
end

local mainfolder = "shielddlc/"
-- sh files
for k,v in pairs(file.Find(mainfolder .. "sh_*", "LUA")) do
    include(mainfolder .. tostring(v))
    if SERVER then AddCSLuaFile(mainfolder .. tostring(v)) end
end

-- sv files
if SERVER then
    for k,v in pairs(file.Find(mainfolder .. "sv_*", "LUA")) do
        include(mainfolder .. tostring(v))
    end
end
-- cl files
for k,v in pairs(file.Find(mainfolder .. "cl_*", "LUA")) do
    if SERVER then AddCSLuaFile(mainfolder ..  tostring(v))
    else include(mainfolder .. tostring(v))
    end
end
--addons/sse_101/lua/sse/sh_sse_config.lua:
SSE.Config.FrameTitleFont = "!Agency FB@50#1000"
SSE.Config.ButtonFont = "!Agency FB@40#1"

SSE.Config.HUDDistance = 300
SSE.Config.HUDInteractLang = "Drücke [%s] zum interagieren"
SSE.Config.AntiSpamTime = 0.5
SSE.Config.AntiSpamText = "Du bist zu schnell, warte einen Moment."


SSE.Config["Boards"] = {} -- Dont Touch this unless you know what you're doing!
-- This is the config for the boards. You can add as many boards as you want.

SSE.Config["Boards"]["Default"] = {
    model = "models/hunter/plates/plate3x5.mdl",
    background = Color(50, 50, 50),
    width = 2372,
    height = 1420,
    pages = {
        [1] = {
            --material = "path/to/material.png",
            --imgur = "ri2f55g",
        },
    } 
}
SSE.Config["Boards"]["Example"] = {
    model = "models/hunter/plates/plate2x2.mdl",
    background = Color(50, 50, 50),
    width = 960,
    height = 960,
    pages = {
        [1] = {
            --material = "shared/RPGRUNDLAGEN.png",
            imgur = "ri2f55g",
        },
        [2] = {
            imgur = "kFOCa5N"
        },
        [3] = {
            imgur = "D3x3hiD"
        }
    } 
}
-- END OF BOARD CONFIGURATION



SSE.Config["AmmoBox"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["AmmoBox"]["Model"] = "models/reizer_props/srsp/sci_fi/crate_01/crate_01.mdl"
SSE.Config["AmmoBox"]["Amount"] = 100
SSE.Config["AmmoBox"]["HUDName"] = "Munitionskiste"



SSE.Config["Trainingsbox"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["Trainingsbox"]["Model"] = "models/reizer_props/srsp/sci_fi/crate_04/crate_04.mdl"
SSE.Config["Trainingsbox"]["HUDName"] = "Trainingsbox"
SSE.Config["Trainingsbox"]["Amount"] = 100

SSE.Config["Healbox"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["Healbox"]["Model"] = "models/reizer_props/srsp/sci_fi/crate_03/crate_03.mdl"
SSE.Config["Healbox"]["HUDName"] = "Sanitätsmaterial"


SSE.Config["TempWepStorage"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["TempWepStorage"]["Model"] = "models/reizer_props/srsp/sci_fi/armory_01/armory_01.mdl"
SSE.Config["TempWepStorage"]["KeepWeapons"] = {"weapon_fists"}
SSE.Config["TempWepStorage"]["HUDName"] = "Waffenlager"


SSE.Config["WeaponDrop"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["WeaponDrop"]["Model"] = "models/reizer_props/srsp/sci_fi/crate_04/crate_04.mdl"
SSE.Config["WeaponDrop"]["HUDName"] = "Waffenkiste"




-- Turbolaser Access Console Config
SSE.Config["TurbolaserConsole"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["TurbolaserConsole"]["Model"] = "models/reizer_props/srsp/sci_fi/console_02_1/console_02_1.mdl"
SSE.Config["TurbolaserConsole"]["TurbolaserClass"] = {
    ["lvs_turbo_laser"] = true,
}
SSE.Config["TurbolaserConsole"]["TurbolaserName"] = "Turbolaser"
SSE.Config["TurbolaserConsole"]["FrameTitle"] = "Waffenkonsole"
SSE.Config["TurbolaserConsole"]["HUDName"] = "Waffenkonsole"



SSE.Config.EventSpawnAlternative = false -- Only change this if the event spawn is not working properly. If it's not working properly, set this to true. Restart Server/Map after changing.




SSE.Config["VehicleRequisition"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["VehicleRequisition"]["Model"] = "models/reizer_props/srsp/sci_fi/console_02_2/console_02_2.mdl"
SSE.Config["VehicleRequisition"]["HUDName"] = "Fahrzeugterminal"
SSE.Config["VehicleRequisition"]["Title"] = "Fahrzeugterminal"
SSE.Config["VehicleRequisition"]["ChooseSpawn"] = "Ausparkpunkte"
SSE.Config["VehicleRequisition"]["VehStored"] = "Fahrzeug im Hangar gelagert"
SSE.Config["VehicleRequisition"]["NoAccess"] = "Du hast kein Zugriff auf Fahrzeuge"
SSE.Config["VehicleRequisition"]["NoAccessVeh"] = "Du hast kein Zugriff auf dieses Fahrzeug"
SSE.Config["VehicleRequisition"]["VehDestroyed"] = "Dein Fahrzeug wurde zerstört und befindet sich jetzt im Hangar für die Reparatur"
SSE.Config["VehicleRequisition"]["SpawnBlocked"] = "Spawnpunkt ist blockiert"
SSE.Config["VehicleRequisition"]["GetVehicles"] = function(ply) -- Example for DARKRP
    if !DarkRP then return {"lvs_arc"} end
    local jobTable = ply:getJobTable()
    return jobTable.vehicles or {}
end


SSE.Config["WeaponBox"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["WeaponBox"]["Model"] = "models/reizer_props/srsp/sci_fi/crate_02/crate_02.mdl"
SSE.Config["WeaponBox"]["FrameTitle"] = "Waffenkiste"
SSE.Config["WeaponBox"]["NoWeps"] = "Hier sind keine Waffen für dich in dieser Kiste"
SSE.Config["WeaponBox"]["GetWeapons"] = function(ply) -- Example for DARKRP
    if !DarkRP then return {"weapon_crowbar"} end
    local jobTable = ply:getJobTable()
    return jobTable.weaponbox or {}
end
SSE.Config["WeaponBox"]["HUDName"] = "Waffenkiste"



SSE.Config["Broadcast"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["Broadcast"]["Model"] = "models/reizer_props/srsp/sci_fi/console_02_2/console_02_2.mdl"
SSE.Config["Broadcast"]["Enabled"] = "Broadcasting enabled, everyone can hear you now!"
SSE.Config["Broadcast"]["Disabled"] = "Broadcasting disabled"
SSE.Config["Broadcast"]["Sound"] = "ambient/alarms/klaxon1.wav"
SSE.Config["Broadcast"]["HUDName"] = "Ankündigungskonsole"


SSE.Config["GalaxyMap"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["GalaxyMap"]["Model"] = "models/lt_c/holograms/console_hr.mdl"
SSE.Config["GalaxyMap"]["HUDName"] = "Galaxiskarte"


SSE.Config["URLConsole"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["URLConsole"]["Model"] = "models/reizer_props/srsp/sci_fi/console_02_2/console_02_2.mdl"
SSE.Config["URLConsole"]["HUDName"] = "Holonet-Konsole"

SSE.Config["Closet"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["Closet"]["Model"] = "models/reizer_props/srsp/sci_fi/armory_02_1/armory_02_1.mdl"
SSE.Config["Closet"]["HUDName"] = "Schrank"
SSE.Config["Closet"]["FrameTitle"] = "Schrank"
SSE.Config["Closet"]["Save"] = "Speichern"
SSE.Config["Closet"]["Load"] = "Laden"
SSE.Config["Closet"]["GetModels"] = function(ply) -- Example for DARKRP
    if !DarkRP then return {} end
    return ply:getJobTable().model
end



SSE.Config["Holotable"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["Holotable"]["Model"] = "models/reizer_props/srsp/sci_fi/command_table_02/command_table_02.mdl"
SSE.Config["Holotable"]["Material"] = "ace/sw/hologram"

SSE.Config["RadarConsole"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["RadarConsole"]["Model"] = "models/reizer_props/srsp/sci_fi/console_02_2/console_02_2.mdl"
SSE.Config["RadarConsole"]["FrameTitle"] = "Radarkonsole"
SSE.Config["RadarConsole"]["IgnoreClasses"] = {"lvs_turbo_laser"}
SSE.Config["RadarConsole"]["Rescan"] = "Erneut scannen"
SSE.Config["RadarConsole"]["HUDName"] = "Air Traffic Control"



SSE.Config["Scanner"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["Scanner"]["Model"] = "models/hunter/plates/plate2x2.mdl"
SSE.Config["Scanner"]["Vehicles"] = "Fahrzeuge"
SSE.Config["Scanner"]["Lifeforms"] = "Lebensformen"
SSE.Config["Scanner"]["Droids"] = "Droiden"
SSE.Config["Scanner"]["Sound"] = "buttons/button19.wav"
SSE.Config["Scanner"]["Size"] = 480 

SSE.Config["Scanner"]["BackgroundColor"] = Color(0, 0, 200, 200)
SSE.Config["Scanner"]["SelfColor"] = Color(0, 255, 0, 200)
SSE.Config["Scanner"]["Target"] = Color(255, 0, 0, 200)



SSE.Config["LiveScanner"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["LiveScanner"]["Model"] = "models/hunter/plates/plate1x1.mdl"
SSE.Config["LiveScanner"]["Size"] = 245

SSE.Config["LiveScanner"]["BackgroundColor"] = Color(0, 0, 200, 200)
SSE.Config["LiveScanner"]["SelfColor"] = Color(0, 255, 0, 200)
SSE.Config["LiveScanner"]["Target"] = Color(255, 0, 0, 200)
SSE.Config["LiveScanner"]["ShowNames"] = false



SSE.Config["Datapad"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["Datapad"]["Model"] = "models/lt_c/sci_fi/computers/crystal_hdd.mdl"
SSE.Config["Datapad"]["FrameTitle"] = "Datapad"
SSE.Config["Datapad"]["Save"] = "Speichern"
SSE.Config["Datapad"]["Font"] = "!Agency FB@40#1"



SSE.Config["RestrictedSign"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["RestrictedSign"]["Model"] = "models/reizer_props/srsp/sci_fi/barrel_04/barrel_04.mdl"

SSE.Config["RestrictedSign"]["Text1"] = "ACHTUNG"
SSE.Config["RestrictedSign"]["Font1"] = "!Agency FB@100#1000"
SSE.Config["RestrictedSign"]["Color1"] = Color(255,0,0)

SSE.Config["RestrictedSign"]["Text2"] = "MILITÄRISCHES SPERRGEBIET"
SSE.Config["RestrictedSign"]["Font2"] = "!Agency FB@75#1000"
SSE.Config["RestrictedSign"]["Color2"] = Color(255,0,0)

SSE.Config["RestrictedSign"]["Text3"] = "EINSATZ TÖDLICHER GEWALT AUTORISIERT"
SSE.Config["RestrictedSign"]["Font3"] = "!Agency FB@40#1000"
SSE.Config["RestrictedSign"]["Color3"] = Color(255,255,255)


SSE.Config["RestrictedSign"]["Text4"] = "BETRETEN VERBOTEN"
SSE.Config["RestrictedSign"]["Font4"] = "!Agency FB@40#1000"
SSE.Config["RestrictedSign"]["Color4"] = Color(255,255,255)



SSE.Config["Battlepad"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["Battlepad"]["Model"] = "models/reizer_props/srsp/sci_fi/command_table_02/command_table_02.mdl"
SSE.Config["Battlepad"]["Size"] = 400
SSE.Config["Battlepad"]["EnemyEntities"] = {"lvs_fakehover_aat", "lvs_walker_hsd"}
SSE.Config["Battlepad"]["FriendlyEntities"] = {"lvs_fakehover_iftx"}
SSE.Config["Battlepad"]["BackgroundColor"] = Color(0, 0, 200, 200)



SSE.Config["Foodbox"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["Foodbox"]["Model"] = "models/reizer_props/srsp/sci_fi/crate_05/crate_05.mdl"
SSE.Config["Foodbox"]["HUDName"] = "Essensvorräte"
SSE.Config["Foodbox"]["MaxFood"] = 100
SSE.Config["Foodbox"]["AddFood"] = 10


SSE.Config["HealCanister"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["HealCanister"]["Model"] = "models/reizer_props/alysseum_project/medicine_obj/med_canister_01/med_canister_01.mdl"
SSE.Config["HealCanister"]["HUDName"] = "Bacta Kanister"
SSE.Config["HealCanister"]["AddHealth"] = 10
SSE.Config["HealCanister"]["DefaultHealth"] = 500
SSE.Config["HealCanister"]["Delay"] = 2 -- Delay in seconds
SSE.Config["HealCanister"]["Sound"] = "items/medshot4.wav"



SSE.Config["ArmorCanister"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["ArmorCanister"]["Model"] = "models/reizer_props/srsp/sci_fi/barrel_03/barrel_03.mdl"
SSE.Config["ArmorCanister"]["HUDName"] = "Plastoid Kanister"
SSE.Config["ArmorCanister"]["AddHealth"] = 10
SSE.Config["ArmorCanister"]["DefaultHealth"] = 500
SSE.Config["ArmorCanister"]["Delay"] = 2 -- Delay in seconds
SSE.Config["ArmorCanister"]["Sound"] = "ambient/energy/spark1.wav"

SSE.Config["Lightswitch"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["Lightswitch"]["Model"] = "models/reizer_props/alysseum_project/misc_stuff/electrical_splitter_01/electrical_splitter_01.mdl"
SSE.Config["Lightswitch"]["Sound"] = "buttons/lever1.wav"
SSE.Config["Lightswitch"]["HUDName"] = "Hauptschalter"
SSE.Config["Lightswitch"]["Delay"] = 120 -- In Seconds
SSE.Config["Lightswitch"]["EngineLightstyle"] = {"rp_venator_extensive_v1_4"} -- Add more if you have more


SSE.Config["TrainingRoomBoard"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["TrainingRoomBoard"]["Model"] = "models/lt_c/holo_wall_unit.mdl"
SSE.Config["TrainingRoomBoard"]["BackgroundColor"] = Color(27, 27, 194, 200)

SSE.Config["TrainingRoomBoard"]["EditLine1"] = "Edit Line 1"
SSE.Config["TrainingRoomBoard"]["EditLine2"] = "Edit Line 2"
SSE.Config["TrainingRoomBoard"]["EditLine3"] = "Edit Line 3"
SSE.Config["TrainingRoomBoard"]["Save"] = "Speichern"
SSE.Config["TrainingRoomBoard"]["GiveUp"] = "Raum aufgeben"
SSE.Config["TrainingRoomBoard"]["RoomOccupied"] = "Raum besetzt druch"
SSE.Config["TrainingRoomBoard"]["RoomAvailable"] = "Raum verfügbar"
SSE.Config["TrainingRoomBoard"]["Contact"] = "Bei der Navy anfrangen"


SSE.Config["TrainingRoomControlPanel"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["TrainingRoomControlPanel"]["Model"] = "models/reizer_props/srsp/sci_fi/console_02_1/console_02_1.mdl"
SSE.Config["TrainingRoomControlPanel"]["HUDName"] = "Trainingsraumkonsole"
SSE.Config["TrainingRoomControlPanel"]["FrameTitle"] = "Trainingsraumkonsole"
SSE.Config["TrainingRoomControlPanel"]["NewOwner"] = "*** Dir wurde ein Trainingsraum zugewiesen: "
SSE.Config["TrainingRoomControlPanel"]["SelectOwner"] = "Besitzer auswählen"
SSE.Config["TrainingRoomControlPanel"]["SetToFree"] = "Raum frei machen"
SSE.Config["TrainingRoomControlPanel"]["Free"] = "Frei"
SSE.Config["TrainingRoomControlPanel"]["SelfRoom"] = "Du darfst dir nicht selber einen Raum zuweisen."

SSE.Config["Sink"] = {} -- Dont Touch this unless you know what you're doing!
SSE.Config["Sink"]["Model"] = "models/lt_c/sci_fi/counter_sinks.mdl"
SSE.Config["Sink"]["HUDName"] = "Waschbecken"
SSE.Config["Sink"]["Sound"] = "ambient/water/water_spray1.wav"


-- Coming soon
SSE.Config["Teleporter"] = {}
SSE.Config["Teleporter"]["Model"] = "models/reizer_props/srsp/sci_fi/console_02_2/console_02_2.mdl"
SSE.Config["Teleporter"]["HUDName"] = "Taxi Terminal"
SSE.Config["Teleporter"]["PoorAsFuck"] = "Du hast nicht genug Geld um ein Taxi zu benspruchen !"
SSE.Config["Teleporter"]["Sound"] = "lvs/vehicles/laat/flyby4.wav"
SSE.Config["Teleporter"]["BlackscreenTime"] = 4
SSE.Config["Teleporter"]["FrameTitle"] = "Taxi Terminal"
SSE.Config["Teleporter"]["Rescan"] = "Erneut scannen"
--addons/vyhub-gmod/lua/vyhub/shared/sh_lang.lua:
local f = string.format
local json = VyHub.Lib.json

VyHub.Lang = VyHub.Lang or {}
VyHub.lang = VyHub.lang or nil

if SERVER then
    util.AddNetworkString("vyhub_lang")

    VyHub.Lang.compressed = VyHub.Lang.compressed or nil 

    function VyHub.Lang:load()
        local f_en = file.Open("vyhub/lang/en.json", "r", "LUA")

        if f_en == nil then
            VyHub:msg("Missing language file en.json!!! PLEASE MAKE SURE TO DOWNLOAD VYHUB-GMOD ON THE GITHUB RELESES PAGE! https://github.com/matbyte-com/vyhub-gmod/releases", "error")
            return
        end

        local en = json.decode(f_en:Read())
        f_en:Close()

        if not istable(en) then
            VyHub:msg("Could not load language file en.json!", "error")
            return
        end

        VyHub.lang = en

        VyHub:msg("Loaded language en.")

        if VyHub.Config.lang != 'en' then
            local f_custom = file.Open(f("vyhub/lang/%s.json", VyHub.Config.lang), "r", "LUA")

            if f_custom != nil then 
                local custom = json.decode(f_custom:Read())
                f_custom:Close()

                if istable(custom) then
                    table.Merge(VyHub.lang, custom)
                    VyHub:msg(f("Loaded language %s.", VyHub.Config.lang))
                else
                    VyHub:msg(f("Could not load language file %s.json!", VyHub.Config.lang), "warning")
                end
            else
                VyHub:msg(f("Missing language file %s.json.", VyHub.Config.lang), "warning")
            end
        end     
        
        VyHub.Lang.compressed = util.Compress(json.encode(VyHub.lang))
    end

    if VyHub.lang == nil then
        VyHub.Lang:load()
    end

    net.Receive("vyhub_lang", function(_, ply)
        if not IsValid(ply) then return end
        if not VyHub.Lang.compressed then return end

        local len = #VyHub.Lang.compressed

        net.Start("vyhub_lang")
            net.WriteUInt(len, 16)
            net.WriteData(VyHub.Lang.compressed, len)
        net.Send(ply)
    end)
end

if CLIENT then
    function VyHub.Lang:load()
        net.Start("vyhub_lang")
        net.SendToServer()
    end

    net.Receive("vyhub_lang", function()
        timer.Remove("vyhub_lang_load")

        local len = net.ReadUInt(16)
        local lang_compr = net.ReadData(len)

        VyHub.lang = json.decode(util.Decompress(lang_compr))

        VyHub:msg("Loaded language.")
        
        hook.Run("vyhub_lang_loaded")
    end)

    hook.Add("Initialize", "vyhub_lang_Initialize", function ()
        VyHub.Lang:load()

        timer.Create("vyhub_lang_load", 5, 5, function ()
            if VyHub.lang == nil then
                VyHub.Lang:load()
            else
                timer.Remove("vyhub_lang_load")
            end
        end)
    end)
end

--lua/wos/anim_extension/extensions/wos_base.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Base" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted wiltOS Animation Base\n" )
--addons/z_anticrash_v1.4.6/lua/z_anticrash/panels/p_stats_overlay.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER]]

local PANEL = {}
local scrW,scrH = ScrW(),ScrH()

local menuW, menuH = 500,600
local menuAnimSpeed = 0.2

function PANEL:Init()
	
	self:SetTitle("")
	self:ShowCloseButton(false)
	self:SetDraggable(true)
	self:SetSize(menuW,menuH)
	self:SetPos(10,10)
	self.Paint = function() end
	
	-- animate alpha
	self:SetAlpha(0)
	self:AlphaTo(240, menuAnimSpeed)
	
	self:MoveToFront()
	
	// Stats
	local statsP = vgui.Create("p_anticrash_stats", self)
	statsP:SetPos(0,0)
	statsP:SetSize(menuW,menuH)
	statsP:Init(true, true)
	
end
vgui.Register("p_anticrash_overlay", PANEL, "DFrame")
--addons/weapons_other/lua/autorun/client/jetted.lua:
surface.CreateFont('Jetted',{font='Trebuchet MS',size=48,weight=400})

local function DrawRect(col,x,y,w,h)
	x, y = math.Round(x), math.Round(y)
	w, h = math.Round(w), math.Round(h)
	surface.SetDrawColor(col.r,col.g,col.b,col.a)
	surface.DrawRect(x,y,w,h)
end

local function DrawText(...)
	local aye = {...}
	surface.SetFont(aye[1])
	local oldx, oldy = 0, 0
	for i = 4, #aye do
		if istable(aye[i]) then
			surface.SetTextColor(aye[i])
		else
			surface.SetTextPos(aye[2]+oldx,aye[3])
			surface.DrawText(tostring(aye[i]))
			local _ox, _oy = surface.GetTextSize(tostring(aye[i]))
			oldx, oldy = oldx+_ox, oldy+_oy
		end
	end
end

local function GetTextSize(...)
	local aye = {...}
	surface.SetFont(aye[1])
	local legx, legy = 0, 0
	for i = 2, #aye do
		if isstring(aye[i]) then
			local xd, yd = surface.GetTextSize(tostring(aye[i]))
			legx = legx + xd
			legy = legy > yd and legy or yd
		end
	end
	return legx, legy
end

--[[ local MSW, MSH = ScrW(), ScrH()
local fuelbarwidth, fuelbarheigth = 256, 15
local col_bg = Color(0,0,0,192)
local col_fuel = Color(255,128,0,255)
local col_txt = Color(255,255,255)
local jet, cf, mf = NULL, 100, 100

hook.Add('Tick','Jetted',function()
	jet = LocalPlayer():GetNWEntity('Jetted')
	if !IsValid(jet) then return end
	cf, mf = jet:GetFuel(), jet:GetMaxFuel()
end)

hook.Add('HUDPaint','jetted',function()
	if !IsValid(jet) then return end
	local percent = math.floor(cf/mf*100)
	DrawRect(col_bg,MSW/2-fuelbarwidth/2,MSH*0.867,fuelbarwidth,fuelbarheigth)
	DrawRect(col_fuel,MSW/2-fuelbarwidth/2+4,MSH*0.87,(fuelbarwidth-8)*percent/100,fuelbarheigth-8)
	--DrawText('Jetted',MSW/2-fuelbarwidth/2+12,MSH-fuelbarheigth*1.4,col_txt,'Fuel: '..percent..'%')
end)



 ]]













--addons/wos-passiveevent-ageo/lua/wos/pes/config/general/sh_config.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


wOS = wOS or {}
wOS.PES = wOS.PES or {}
wOS.PES.Config = wOS.PES.Config or {}

// What user groups can create new events?
wOS.PES.Config.CreateEventUsersgroup = {
	["superadmin"] = true,
}

// How often should we roll for a random event to happen, if there are any on the server? ( IN SECONDS )
wOS.PES.Config.RandomInterval = 3

// What is the maximum amount of random events that can run at the same time?
// 0 = NO LIMIT!
wOS.PES.Config.MaxRandoms = 1

// How long in advance should we wait to allow someone to snooze a randomly selected event? ( IN SECONDS )
// To prevent potentially weird overlap, this should always be less than the random interval
wOS.PES.Config.SnoozeDelay = 5

// This can be a table or a single value
wOS.PES.Config.SnoozeText = "The event \"[[name]]\" is about to start randomly in [[time]]. \n\nDo you want to snooze it?"

// The minimum amount of players required for a random event to execute. Set this to false if you do not want this to be considered
wOS.PES.Config.RandomMinimumPlayers = false
--addons/wos-passiveevent-ageo/lua/wos/pes/config/general/sh_permissions.lua:
wOS = wOS or {}
wOS.PES = wOS.PES or {}
wOS.PES.Config = wOS.PES.Config or {}

// What user groups can do every action?
wOS.PES.Config.FullPermissionUsergroup = {
    ["superadmin"] = true,
	["admin"] = true,
    ["Senior-Moderator"] = true,
    ["Moderator"] = true,
    ["Junior-Moderator"] = true
}

// What user groups can create new events?
wOS.PES.Config.CreateEventUsersgroup = {
    ["superadmin"] = true,
	["admin"] = true,
    ["Senior-Moderator"] = true,
    ["Moderator"] = true,
    ["Junior-Moderator"] = true
}

// What user groups can stop an event
wOS.PES.Config.StopUsergroup = {
	["superadmin"] = true,
    ["admin"] = true,
    ["Senior-Moderator"] = true,
    ["Moderator"] = true,
    ["Junior-Moderator"] = true
}

wOS.PES.Config.StartUsergroup = {
	["superadmin"] = true,
    ["admin"] = true,
    ["Senior-Moderator"] = true,
    ["Moderator"] = true,
    ["Junior-Moderator"] = true
}

wOS.PES.Config.StartTimeUsergroup = {
	["superadmin"] = true,
    ["admin"] = true,
    ["Senior-Moderator"] = true,
    ["Moderator"] = true,
    ["Junior-Moderator"] = true
}

wOS.PES.Config.StartRandomUsergroup = {
	["superadmin"] = true,
    ["admin"] = true,
    ["Senior-Moderator"] = true,
    ["Moderator"] = true,
    ["Junior-Moderator"] = true
}

wOS.PES.Config.CanSnoozeUsergroup = {
	["superadmin"] = true,
    ["admin"] = true,
    ["Senior-Moderator"] = true,
    ["Moderator"] = true,
    ["Junior-Moderator"] = true
}
--addons/wos-passiveevent-ageo/lua/wos/pes/core/cl_net.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































wOS = wOS || {}
wOS.PES = wOS.PES || {}
wOS.PES.Triggers = wOS.PES.Triggers || {}
wOS.PES.Triggers.Data = wOS.PES.Triggers.Data || {}
wOS.PES.Nodes = wOS.PES.Nodes || {}
wOS.PES.Nodes.Data = wOS.PES.Nodes.Data || {}

local function QuickSort( a, b )
    return a[2] < b[2]
end

net.Receive("wOS.PES.Triggers.Sync",function()
    local size = net.ReadUInt( 32 )
    wOS.PES.Triggers.Data = wOS.SFS_EXTERN:Decompress( net.ReadData( size ) )
end)

net.Receive("wOS.PES.Nodes.Sync",function()

    local size = net.ReadUInt( 32 )
    wOS.PES.Nodes.Data = wOS.SFS_EXTERN:Decompress( net.ReadData( size ) )

	// We're gonna do the sorting clientside because really it only effects the client
	for name, data in pairs( wOS.PES.Nodes.Data ) do
		if not data.Vars then continue end

		local sort_tbl = {}

		for name, dat in pairs( data.Vars ) do
			table.insert( sort_tbl, { name, dat.ID } )
		end

		table.sort( sort_tbl, QuickSort )

		data.SortedVars = {}
        for _, dat in ipairs( sort_tbl ) do
            table.insert( data.SortedVars, dat[1] )
        end
	end

end)

/*
	Name: wOS.PES.NetworkEvent(event)
	Description: Networks an event in a header and body packets to the server
	Args: EventData event
	Returns: None
*/
function wOS.PES.NetworkEvent(event)
    if not event then return end

    event.Compressed = nil

    net.Start("wOS.PES.EventHeader")
        net.WriteString(event.Name)
        net.WriteString(event.oldname)
        net.WriteDouble(#event.Nodes)
		net.WriteString(event.Description)
        net.WriteBool(event.Importable)
        net.WriteBool(event.Export)
        net.WriteDouble(event.random or -1)
    net.SendToServer()

    local nodestring = wOS.SFS_EXTERN:Compress( event.Nodes )

    local NET_CAP = 55000
    if #nodestring < NET_CAP then
        net.Start( "wOS.PES.Node" )
            net.WriteString( event.Name )
            net.WriteUInt( 1, 32 )
            net.WriteUInt( 1, 32 )
            net.WriteUInt( #nodestring, 32 )
            net.WriteData( nodestring )
        net.SendToServer()
        return
    end

    local total_segments = math.ceil( #nodestring / NET_CAP )

    for i=1, total_segments do
        local lim
        if i != total_segments then
            lim = i*NET_CAP
        end
        local str = string.sub( nodestring, ( (i - 1)*NET_CAP ) + 1, lim )
        timer.Simple( (i-1)*0.5, function()
            net.Start( "wOS.PES.Node" )
                net.WriteString( event.Name )
                net.WriteUInt( total_segments, 32 )
                net.WriteUInt( i, 32 )
                net.WriteUInt( #str, 32 )
                net.WriteData( str )    
            net.SendToServer()
        end )    
    end

    -- net.Start("wOS.PES.Node")
    --     net.WriteString( event.Name )
    --     net.WriteUInt( #nodestring, 32 )
    --     net.WriteData( nodestring )
    -- net.SendToServer()

end

function wOS.PES.NetworkSimulation(event)
    if not event then return end

    event.Compressed = nil

    net.Start("wOS.CSS.SimulationHeader")
        net.WriteString(event.Name)
        net.WriteString(event.oldname)
        net.WriteDouble(#event.Nodes)
		net.WriteString(event.Description)
        net.WriteBool(event.Importable)
        net.WriteBool(event.Export)
		net.WriteTable(event.Settings)
    net.SendToServer()

    local nodestring = wOS.SFS_EXTERN:Compress( event.Nodes )

    local NET_CAP = 55000
    if #nodestring < NET_CAP then
        net.Start( "wOS.CSS.Node" )
            net.WriteString( event.Name )
            net.WriteUInt( 1, 32 )
            net.WriteUInt( 1, 32 )
            net.WriteUInt( #nodestring, 32 )
            net.WriteData( nodestring )
        net.SendToServer()
        return
    end

    local total_segments = math.ceil( #nodestring / NET_CAP )

    for i=1, total_segments do
        local lim
        if i != total_segments then
            lim = i*NET_CAP
        end
        local str = string.sub( nodestring, ( (i - 1)*NET_CAP ) + 1, lim )
        timer.Simple( (i-1)*0.5, function()
            net.Start( "wOS.CSS.Node" )
                net.WriteString( event.Name )
                net.WriteUInt( total_segments, 32 )
                net.WriteUInt( i, 32 )
                net.WriteUInt( #str, 32 )
                net.WriteData( str )    
            net.SendToServer()    
        end )
    end

    -- net.Start("wOS.CSS.Node")
    --     net.WriteString( event.Name )
    --     net.WriteUInt( #nodestring, 32 )
    --     net.WriteData( nodestring )
    -- net.SendToServer()

end

/*
	Name: wOS.PES.RequestEventList(callback)
	Description: Requests the event list from the server and calls the callback function
	Args: function callback
	Returns: None
*/
function wOS.PES.RequestEventList(callback)

    callback = callback or function() end

    net.Start("wOS.PES.EventList")
        net.WriteString("")
    net.SendToServer()

    net.Receive("wOS.PES.EventList",function()
        local missionNames = net.ReadTable()
        callback(missionNames)
    end)
end

function wOS.PES.RequestAdminSync(id, callback)
	net.Start("wOS.PES.Admin.Sync")
		net.WriteUInt( id, 32 )
	net.SendToServer()

	net.Receive("wOS.PES.Admin.Sync", callback)
end

function wOS.PES.RequestOpenAdminPreMenu()

	net.Start("wOS.PES.RequestPreAdminMenu")
	net.SendToServer()

	net.Receive("wOS.PES.RequestPreAdminMenu", function()
		local events = net.ReadTable()
		wOS.PES:OpenAdminActiveList( events )
	end)
end

function wOS.PES.RequestOpenAdminViewer( id )

	net.Start("wOS.PES.RequestAdminMenu")
		net.WriteUInt( id, 32 )
	net.SendToServer()

	net.Receive("wOS.PES.RequestAdminMenu", function()
		local nodes = net.ReadActivePESEvent()
		wOS.PES:OpenAdminEventViewer(id, nodes)
	end)
end

function wOS.PES.RequestSchedule(callback)
	net.Start("wOS.PES.RequestSchedule")
	net.SendToServer()

	net.Receive("wOS.PES.RequestSchedule", function()
		local eventCount = net.ReadUInt(16)

		local eventList = {}

		for x = 1, eventCount do
			local name = net.ReadString()
			local map = net.ReadString()
			local time = net.ReadUInt(32)

			eventList[x] = {
				Name = name,
				Time = time,
				Map = map,
			}
		end

		callback(eventList)
	end)
end

function wOS.PES.RequestStop( id )
	net.Start("wOS.PES.RequestStop")
		net.WriteUInt( id, 32 )
	net.SendToServer()
end

function wOS.PES.RequestEventData(name, callback)
    if not name then return end

    callback = callback or function() end

    local checksum = CurTime()

    net.Start("wOS.PES.RequestEventData")
        net.WriteString(name)
        net.WriteDouble(checksum)
    net.SendToServer()

    local event = {}

    local segments = {}

    net.Receive( "wOS.PES.EventDataNodes", function()

        if event.Processed then return end
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end

        local total_segments = net.ReadUInt( 32 )
        local current_segment = net.ReadUInt( 32 )

        local size = net.ReadUInt( 32 )
        local compressed = net.ReadData( size )
        segments[ current_segment ] = compressed

        if table.Count( segments ) < total_segments then return end

        local fcompressed = table.concat( segments )
        event, err = wOS.SFS_EXTERN:Decompress( fcompressed )

        event.Processed = true
        event.BackupNodeCount = nil

		callback(event)

    end )

    -- net.Receive("wOS.PES.EventDataPrepare",function()
    --     if event.Processed then return end
    --     local dChecksum = net.ReadDouble()
    --     if dChecksum != checksum then return end

    --     local header = net.ReadPESEventHeader()
    --     table.Merge( event, header )

    --     if not event.BackupNodeCount then return end
    --     if event.BackupNodeCount < event.NodeCount then return end
    --     event.Processed = true
    --     event.BackupNodeCount = nil
	-- 	callback(event)
    -- end)

end

function wOS.PES.GetImportableEvents(callback, full)

    local checksum = CurTime()
    net.Start( "wOS.PES.GetImportableEvents" )
        net.WriteBool( full or false )
        net.WriteDouble( checksum )
    net.SendToServer()

    net.Receive("wOS.PES.GetImportableEvents",function()
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end
        
		local events = net.ReadTable()
		callback(events)
    end)
end

function wOS.PES.GetImportableSimulations(callback)

    local checksum = CurTime()
    net.Start( "wOS.PES.GetImportableSimulations" )
        net.WriteDouble( checksum )
    net.SendToServer()

    net.Receive("wOS.PES.GetImportableSimulations",function()
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end
        
		local events = net.ReadTable()
		callback(events)
    end)
end

function wOS.PES.RequestSimulationData(name, callback, sim)
    if not name then return end

    callback = callback or function() end

    local checksum = CurTime()

    net.Start("wOS.CSS.RequestSimulationData")
        net.WriteUInt( sim or 0, 32 )
        net.WriteString(name)
        net.WriteDouble(checksum)
    net.SendToServer()

    local simdata = {
		Settings = {},
        Event = {},
    }

    local segments = {}
    
    net.Receive("wOS.CSS.SimDataNodes",function()
        if simdata.Processed then return end
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end

        local total_segments = net.ReadUInt( 32 )
        local current_segment = net.ReadUInt( 32 )

        local size = net.ReadUInt( 32 )
        local compressed = net.ReadData( size )
        segments[ current_segment ] = compressed

        if table.Count( segments ) < total_segments then return end

        local fcompressed = table.concat( segments )
        local eventz = wOS.SFS_EXTERN:Decompress( fcompressed )
        simdata.Event = eventz

        if table.Count( simdata.Settings ) < 1 then return end
        simdata.Processed = true
		callback(simdata)
    end)

    net.Receive( "wOS.CSS.SimDataPrepare", function()
        if simdata.Processed then return end
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end

        local header = net.ReadCSSSimulationHeader()
        table.Merge( simdata, header )

        if table.Count( simdata.Event ) < 1 then return end
        simdata.Processed = true
		callback(simdata)
    end )
    
end

function wOS.PES.RequestEventStart(eventName)
    if not eventName then return end
    net.Start("wOS.PES.RequestStart")
        net.WriteString(eventName)
    net.SendToServer()
end

function wOS.PES.RequestEventStartTime(eventName, time)
	net.Start("wOS.PES.RequestStartTime")
		net.WriteString(eventName)
		net.WriteDouble(time)
	net.SendToServer()
end

function wOS.PES.RequestTriggerStart(eventid, nodeid, triggerName)
	net.Start("wOS.PES.RequestTriggerStart")
		net.WriteUInt( eventid, 32 )
		net.WriteDouble(nodeid)
		net.WriteString(triggerName)
	net.SendToServer()
end

function wOS.PES.RequestURLImport(url, callback)
    if not url then return end

    callback = callback or function() end

    local checksum = CurTime()

    net.Start("wOS.PES.Import.RequestURLEvent")
        net.WriteString(url)
        net.WriteDouble(checksum)
    net.SendToServer()

    local event = {}
    local simdata = {
        Name = name,
		Description = "",
        Nodes = {},
		Settings = {},
        Count = 0,
    }

    local segments = {}

    net.Receive( "wOS.PES.EventDataNodes", function()

        if event.Processed then return end
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end

        local total_segments = net.ReadUInt( 32 )
        local current_segment = net.ReadUInt( 32 )

        local size = net.ReadUInt( 32 )
        local compressed = net.ReadData( size )
        segments[ current_segment ] = compressed

        if table.Count( segments ) < total_segments then return end

        local fcompressed = table.concat( segments )

        event = wOS.SFS_EXTERN:Decompress( fcompressed )
        event.Processed = true
        event.BackupNodeCount = nil

		callback(event)

    end )

    net.Receive("wOS.CSS.SimDataNodes",function()
        if simdata.Processed then return end
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end

        local total_segments = net.ReadUInt( 32 )
        local current_segment = net.ReadUInt( 32 )

        local size = net.ReadUInt( 32 )
        local compressed = net.ReadData( size )
        segments[ current_segment ] = compressed

        if table.Count( segments ) < total_segments then return end

        local fcompressed = table.concat( segments )
        local eventz = wOS.SFS_EXTERN:Decompress( fcompressed )
        simdata.Event = eventz

        if table.Count( simdata.Settings ) < 1 then return end
        simdata.Processed = true
		callback(simdata)
    end)

    net.Receive( "wOS.CSS.SimDataPrepare", function()
        if simdata.Processed then return end
        local dChecksum = net.ReadDouble()
        if dChecksum != checksum then return end

        local header = net.ReadCSSSimulationHeader()
        table.Merge( simdata, header )

        if table.Count( simdata.Event ) < 1 then return end
        simdata.Processed = true
		callback(simdata)
    end )

end

net.Receive( "wOS.PES.Import.URLError", function() 
    local msg = net.ReadString()
    surface.PlaySound( "buttons/button10.wav" )
    notification.AddLegacy( msg, NOTIFY_ERROR, 6 )
end )

net.Receive( "wOS.PES.Export.SendLink", function() 
    local msg = net.ReadString()
    surface.PlaySound( "buttons/button14.wav" )
    notification.AddLegacy( "[wOS-PES] Event was successfully exported to a URL! Check your chat for the link.", NOTIFY_GENERIC, 6 )
    chat.AddText( color_white, "[wOS-PES] Your event has been successfully exported to the following link: ", Color( 66, 117, 176 ), msg )
end )

net.Receive( "wOS.PES.Export.SendError", function() 
    local msg = net.ReadString()
    surface.PlaySound( "buttons/button10.wav" )
    notification.AddLegacy( "[wOS-PES] Event failed to be exported to URL. Check your chat for the error.", NOTIFY_ERROR, 6 )
    chat.AddText( color_white, "[wOS-PES] Your event failed to upload with the following error: ", Color( 255, 0, 0 ), msg )
end )



--addons/wos-passiveevent-ageo/lua/wos/css/entities/wos_simulation_tool/sh_wos_simulation_tool.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


--addons/billy_gas/lua/vgui/bvgui/combobox.lua:
local PANEL = {}

function PANEL:Init()
	self.ChoiceIcons = {}
	self.Spacers = {}
end

function PANEL:Clear()
	
	self:SetText( "" )
	self.Choices = {}
	self.Data = {}
	self.ChoiceIcons = {}
	self.Spacers = {}
	self.selected = nil

	if ( self.Menu ) then
		self.Menu:Remove()
		self.Menu = nil
	end

end

function PANEL:AddChoice( value, data, select, icon )

	local i = table.insert( self.Choices, value )

	if ( data ) then
		self.Data[ i ] = data
	end

	if (icon) then
		self.ChoiceIcons[ i ] = icon
	end

	if ( select ) then

		self:ChooseOption( value, i )

	end

	return i

end

function PANEL:AddSpacer()

	self.Spacers[ #self.Choices ] = true

end

function PANEL:OpenMenu( pControlOpener )

	if ( pControlOpener && pControlOpener == self.TextEntry ) then
		return
	end

	-- Don't do anything if there aren't any options..
	if ( #self.Choices == 0 ) then return end

	-- If the menu still exists and hasn't been deleted
	-- then just close it and don't open a new one.
	if ( IsValid( self.Menu ) ) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self.Menu = DermaMenu( false, self )

	if ( self:GetSortItems() ) then
		local sorted = {}
		for k, v in pairs( self.Choices ) do
			local val = tostring( v ) --tonumber( v ) || v -- This would make nicer number sorting, but SortedPairsByMemberValue doesn't seem to like number-string mixing
			if ( string.len( val ) > 1 && !tonumber( val ) && val:StartWith( "#" ) ) then val = language.GetPhrase( val:sub( 2 ) ) end
			table.insert( sorted, { id = k, data = v, label = val } )
		end
		for k, v in SortedPairsByMemberValue( sorted, "label" ) do
			local option = self.Menu:AddOption( v.data, function() self:ChooseOption( v.data, v.id ) end )
			if ( self.ChoiceIcons[ v.id ] ) then
				option:SetIcon( self.ChoiceIcons[ v.id ] )
			end
			if ( self.Spacers[ v.id ] ) then
				self.Menu:AddSpacer()
			end
		end
	else
		for k, v in pairs( self.Choices ) do
			local option = self.Menu:AddOption( v, function() self:ChooseOption( v, k ) end )
			if ( self.ChoiceIcons[ k ] ) then
				option:SetIcon( self.ChoiceIcons[ k ] )
			end
			if ( self.Spacers[ k ] ) then
				self.Menu:AddSpacer()
			end
		end
	end

	local x, y = self:LocalToScreen( 0, self:GetTall() )

	self.Menu:SetMinimumWidth( self:GetWide() )
	self.Menu:Open( x, y, false, self )

end

derma.DefineControl("bVGUI.ComboBox", nil, PANEL, "DComboBox")
--addons/billy_gas/lua/vgui/bvgui/table.lua:
bVGUI.TABLE_COLUMN_GROW   = 0
bVGUI.TABLE_COLUMN_SHRINK = 1

--/// bVGUI.Table ///--

local PANEL = {}

function PANEL:Init()
	self.Columns = {}
	self.Rows = {}
	self.ColumnWidths = {}

	self.ColumnContainer = vgui.Create("DPanel", self)
	self.ColumnContainer:Dock(TOP)
	self.ColumnContainer.Paint = nil

	self.RowContainer = vgui.Create("bVGUI.ScrollPanel", self)
	self.RowContainer:Dock(FILL)
	self.RowContainer.Paint = nil

	self.TextSize = 14
	self.RowContainer.OnMouseWheeled_Old = self.RowContainer.OnMouseWheeled
	function self.RowContainer:OnMouseWheeled(delta)
		if (input.IsKeyDown(KEY_LCONTROL)) then
			local tbl = self:GetParent()
			if (delta > 0) then
				tbl.TextSize = math.min(tbl.TextSize + 1, 18)
			else
				tbl.TextSize = math.max(tbl.TextSize - 1, 10)
			end
			for _,row in ipairs(tbl.Rows) do
				row.Font = bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", tbl.TextSize)
			end
			tbl:InvalidateLayout(true)
			tbl:InvalidateChildren(true)
		else
			self:OnMouseWheeled_Old(delta)
		end
	end

	self.NoData = vgui.Create("DLabel", self)
	self.NoData:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	self.NoData:SetTextColor(bVGUI.COLOR_WHITE)
	self.NoData:SetText(bVGUI.L("no_data"))
	self.NoData:SizeToContents()

	self.NoResultsFound = vgui.Create("DLabel", self)
	self.NoResultsFound:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 16))
	self.NoResultsFound:SetTextColor(bVGUI.COLOR_WHITE)
	self.NoResultsFound:SetText(bVGUI.L("no_results_found"))
	self.NoResultsFound:SizeToContents()
	self.NoResultsFound:SetVisible(false)
end

function PANEL:SetRowCursor(cursor)
	self.RowCursor = cursor
end
function PANEL:GetRowCursor()
	return self.RowCursor
end

function PANEL:Clear()
	for _,v in ipairs(self.Rows) do
		v:Remove()
	end
	self.Rows = {}
	self:InvalidateLayout(true)
end

function PANEL:AddColumn(name, sizing, alignment, color)
	local column = vgui.Create("bVGUI.Table_Column", self.ColumnContainer)
	column:SetText(name)
	column:SetColor(color or Color(51, 80, 114))
	column:SetSizing(sizing or bVGUI.TABLE_COLUMN_GROW)
	column:SetAlignment(alignment or TEXT_ALIGN_LEFT)
	column:SetDrawBorder(false)

	table.insert(self.Columns, column)

	return column
end

function PANEL:AddRow(...)
	local row = vgui.Create("bVGUI.Table_Row", self.RowContainer)
	row.RowIndex = table.insert(self.Rows, row)
	row.LabelsData = {...}
	row:InvalidateLayout(true)
	if (self.RowCursor) then
		row:SetCursor(self.RowCursor)
	end
	self:InvalidateLayout(true)

	return row
end

function PANEL:RemoveRow(index_or_row)
	local row
	if (type(index_or_row) == "number") then
		row = self.Rows[index_or_row]
	elseif (IsValid(index_or_row)) then
		row = index_or_row
	else
		return
	end
	self.Rows[row.RowIndex] = nil
	row:Remove()
	local new_rows = {}
	local i = 0
	for _,v in pairs(self.Rows) do
		i = i + 1
		table.insert(new_rows, v)
		v.RowIndex = i
	end
	self.Rows = new_rows
	self:InvalidateLayout(true)
end

function PANEL:RerenderMarkups()
	for _,row in pairs(self.Rows) do
		row.LabelsMarkup = nil
	end
end

function PANEL:PerformLayout()
	self.ColumnWidths = {}

	local cur_space = self:GetWide()
	if (self.IconLayout) then cur_space = cur_space - 16 - 10 end
	local grow_count = 0
	for i,v in pairs(self.Columns) do
		if (v.Sizing == bVGUI.TABLE_COLUMN_SHRINK) then
			v:SizeToContents()
			v.Label:SizeToContents()
			local width = v.Label:GetWide() + 26
			for _,row in ipairs(self.Rows) do
				if (row.LabelsMarkup) then
					width = math.max(width, row.LabelsMarkup[i]:GetWidth() + 14)
				end
			end
			v:SetWide(width)
			v:InvalidateLayout(true)
			cur_space = cur_space - width
			self.ColumnWidths[i] = width
		else
			grow_count = grow_count + 1
		end
	end

	local grow_width = cur_space / grow_count
	for i,v in pairs(self.Columns) do
		if (v.Sizing == bVGUI.TABLE_COLUMN_GROW) then
			v:SetWide(grow_width)
			self.ColumnWidths[i] = grow_width
			for _,row in ipairs(self.Rows) do
				if (row.LabelsMarkup) then
					row.LabelsMarkup[i] = markup.Parse("<colour=225,225,225><font=" .. row.Font .. ">" .. row.LabelsData[i] .. "</font></colour>", grow_width - 14)
				end
			end
		end
	end

	self.NoData:Center()
	self.NoResultsFound:Center()
end

function PANEL:SortRows()
	local size_y = 0
	local no_rows = true
	for i,v in pairs(self.Rows) do
		if (not v:IsVisible()) then continue end
		v:AlignTop(size_y)
		size_y = size_y + v:GetTall()
		no_rows = false
	end
	self.NoResultsFound.Visible = no_rows
end

function PANEL:Paint(w,h)
	self:LoadingPaint(w,h)
	if (not self.LoadingState or self.LoadingState ~= self:GetLoading()) then
		self.LoadingState = self:GetLoading()
		self.NoData:SetVisible(self:GetLoading() == false and #self.Rows == 0)
	end
	self.NoResultsFound:SetVisible(not self.NoData:IsVisible() and self:GetLoading() ~= true and self.NoResultsFound.Visible)

	surface.SetDrawColor(51, 80, 114)
	surface.DrawRect(0,0,w,23)

	surface.SetDrawColor(31, 48, 68)
	surface.DrawLine(0,23,w,23)
end

derma.DefineControl("bVGUI.Table", nil, PANEL, "bVGUI.LoadingPanel")

--/// bVGUI.Table_Column ///--

local PANEL = {}

function PANEL:Init()
	self:SetCursor("arrow")
	self:Dock(LEFT)
	self:SetDrawBorder(false)
	self.ColumnBorderColor = bVGUI.DarkenColor(self.OriginalBarColor, 0.4)
	self.ColumnSideColor = bVGUI.DarkenColor(self.OriginalBarColor, 0.4)
end

function PANEL:GetSizing()
	return self.Sizing
end
function PANEL:SetSizing(size_enum)
	self.Sizing = size_enum
end

function PANEL:SetAlignment(alignment)
	self.Alignment = alignment
end
function PANEL:GetAlignment(alignment)
	return self.Alignment
end

function PANEL:Paint(w,h)
	surface.SetDrawColor(self.ColumnBorderColor)
	surface.DrawLine(-1,h - 1,w + 1,h - 1)

	surface.SetDrawColor(self.ColumnSideColor)
	surface.DrawLine(w - 1, 0, w - 1, h - 1)

end

derma.DefineControl("bVGUI.Table_Column", nil, PANEL, "bVGUI.Button")

--/// bVGUI.Table_Row ///--

local PANEL = {}

function PANEL:Init()
	self.Table = self:GetParent():GetParent():GetParent()
	self:Dock(TOP)

	self.Font = bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", self.Table.TextSize)
	self.CurrentFont = self.Font
end

local row_1 = Color(39,44,53)
local row_2 = Color(35,40,48)
function PANEL:Paint(w,h)
	if (self.RowIndex % 2 == 0) then
		surface.SetDrawColor(31, 35, 43)
	else
		surface.SetDrawColor(33, 37, 45)
	end
	surface.DrawRect(0,0,w,h)
	if (self.Highlight) then
		surface.SetDrawColor(255,255,0,4)
		surface.DrawRect(0,0,w,h)
	elseif (self:IsHovered()) then
		surface.SetDrawColor(255,255,255,4)
		surface.DrawRect(0,0,w,h)
	end
	if (not self.LabelsMarkup or self.CurrentFont ~= self.Font) then
		self.CurrentFont = self.Font
		self.LabelsMarkup = {}
		for i,v in pairs(self.LabelsData) do
			if (self.Table.Columns[i]:GetSizing() ~= bVGUI.TABLE_COLUMN_SHRINK) then
				self.LabelsMarkup[i] = markup.Parse("<colour=225,225,225><font=" .. self.Font .. ">" .. v .. "</font></colour>", self.Table.ColumnWidths[i] - 14)
			else
				self.LabelsMarkup[i] = markup.Parse("<colour=225,225,225><font=" .. self.Font .. ">" .. v .. "</font></colour>")
			end
		end
	end
	local cumulative = 0
	local tall = self:GetTall()
	local max_height = 0
	for i,v in pairs(self.LabelsMarkup) do
		local l_padding = 0
		if (self.Table.IconLayout) then
			l_padding = 16 + 10
			if (i == 1) then
				l_padding = l_padding - 5
			end
		end
		if (v:GetWidth() > self.Table.ColumnWidths[i]) then
			self.Table:InvalidateLayout(true)
		end
		local alignment = self.Table.Columns[i]:GetAlignment()
		if (alignment == TEXT_ALIGN_CENTER) then
			v:Draw(l_padding + cumulative + (self.Table.ColumnWidths[i] / 2), tall / 2 - v:GetHeight() / 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		elseif (alignment == TEXT_ALIGN_RIGHT) then
			v:Draw(l_padding + cumulative + self.Table.ColumnWidths[i] - 7, tall / 2 - v:GetHeight() / 2, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		else
			v:Draw(l_padding + 7 + cumulative, tall / 2 - v:GetHeight() / 2, self.Table.Columns[i]:GetAlignment(), TEXT_ALIGN_TOP)
		end
		if (v:GetHeight() + 10 > max_height) then
			max_height = v:GetHeight() + 10
		end
		cumulative = cumulative + self.Table.ColumnWidths[i]
	end
	if (h ~= max_height) then
		self:SetTall(max_height)
	end
end

function PANEL:OnMouseReleased(key_code)
	if (key_code == MOUSE_LEFT) then
		self.Table.SelectedRow = self.RowIndex
		if (self.Table.OnRowClicked) then
			self.Table:OnRowClicked(self, self.CurrentHoveredColumn)
		end
	elseif (key_code == MOUSE_RIGHT) then
		if (self.Table.OnRowRightClicked) then
			self.Table:OnRowRightClicked(self, self.CurrentHoveredColumn)
		end
	end
end

function PANEL:OnCursorMoved(x)
	if (not self.Table.OnColumnHovered) then return end
	local cumulative_width = 0
	local hovered_column = nil
	for i,v in pairs(self.Table.ColumnWidths) do
		if (x >= cumulative_width) then
			hovered_column = i
		else
			break
		end
		cumulative_width = cumulative_width + v
	end
	if (self.CurrentHoveredColumn ~= hovered_column) then
		self.CurrentHoveredColumn = hovered_column
		self.Table:OnColumnHovered(self, hovered_column)
	end
end
function PANEL:OnCursorExited()
	if (not self.Table.OnColumnHovered) then return end
	self.CurrentHoveredColumn = nil
	self.Table:OnColumnHovered(self, nil)
end

function PANEL:SetIcon(path)
	self:SetMaterial(Material(path))
end
function PANEL:SetMaterial(mat)
	self.Table.IconLayout = true
	self.Table.ColumnContainer:DockPadding(16 + 10,0,0,0)
	self.Table.RowContainer:DockPadding(16 + 10,0,0,0)
	if (not IsValid(self.Icon)) then
		self.Icon = vgui.Create("DImage", self)
		self.Icon:SetSize(16,16)
		self.Icon:AlignLeft(5)
		self.Icon:CenterVertical()
	end
	self.Icon:SetMaterial(mat)
end

derma.DefineControl("bVGUI.Table_Row", nil, PANEL, "DPanel")
--addons/billy_gas/lua/vgui/bvgui/vertical_option_selector.lua:
local PANEL = {}

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")

	self.Buttons = {}
	self.Color = bVGUI.BUTTON_COLOR_BLUE
	self.BorderColor = bVGUI.DarkenColor(self.Color, 0.4)

	self.SelectedButton = 1
end

function PANEL:SetColor(col)
	self.Color = col
	self.BorderColor = bVGUI.DarkenColor(self.Color, 0.4)
end

function PANEL:SelectButton(index)
	self.SelectedButton = index
end

function PANEL:AddButton(text, color)
	local label = vgui.Create("DLabel", self)
	label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	label:SetContentAlignment(5)
	label:SetTextColor(bVGUI.COLOR_WHITE)
	label:SetText(text)
	label.BtnColor = color
	label.BtnBorderColor = bVGUI.DarkenColor(color, 0.4)
	table.insert(self.Buttons, label)

	self:SizeButtons()
end

local grey_col = Color(150,150,150)
local dark_grey_col = bVGUI.DarkenColor(grey_col, 0.4)
function PANEL:Paint(w,h)
	draw.RoundedBox(4, 0, 0, w, h, dark_grey_col)
	draw.RoundedBoxEx(4, 0, 0, w, h - 4, grey_col, true, true)

	for i,v in ipairs(self.Buttons) do
		draw.RoundedBox(4, 0, (i * (h / #self.Buttons)) - 4, w, 4, dark_grey_col)
	end

	if (IsValid(self.Buttons[self.SelectedButton])) then
		local btn = self.Buttons[self.SelectedButton]

		if (self.LerpY == nil) then
			self.LerpY = (self.SelectedButton - 1) * (h / #self.Buttons)
		else
			self.LerpY = Lerp(FrameTime() * 10, self.LerpY, (self.SelectedButton - 1) * (h / #self.Buttons))
		end

		if (self.LerpBorderColor == nil) then
			self.LerpBorderColor = Color(btn.BtnBorderColor.r, btn.BtnBorderColor.g, btn.BtnBorderColor.b)
		else
			self.LerpBorderColor.r = Lerp(FrameTime() * 10, self.LerpBorderColor.r, btn.BtnBorderColor.r)
			self.LerpBorderColor.g = Lerp(FrameTime() * 10, self.LerpBorderColor.g, btn.BtnBorderColor.g)
			self.LerpBorderColor.b = Lerp(FrameTime() * 10, self.LerpBorderColor.b, btn.BtnBorderColor.b)
		end

		if (self.LerpColor == nil) then
			self.LerpColor = Color(btn.BtnColor.r, btn.BtnColor.g, btn.BtnColor.b)
		else
			self.LerpColor.r = Lerp(FrameTime() * 10, self.LerpColor.r, btn.BtnColor.r)
			self.LerpColor.g = Lerp(FrameTime() * 10, self.LerpColor.g, btn.BtnColor.g)
			self.LerpColor.b = Lerp(FrameTime() * 10, self.LerpColor.b, btn.BtnColor.b)
		end

		draw.RoundedBoxEx(4, 0, self.LerpY, w, h / #self.Buttons, self.LerpBorderColor, true, true, self.SelectedButton == #self.Buttons, self.SelectedButton == #self.Buttons)
		draw.RoundedBoxEx(4, 0, self.LerpY, w, (h / #self.Buttons) - 4, self.LerpColor, self.SelectedButton == 1, self.SelectedButton == 1)
	end
end

function PANEL:SizeButtons()
	local w = 0
	for _,v in ipairs(self.Buttons) do
		v:SizeToContents()
		if (v:GetWide() > w) then
			w = v:GetWide()
		end
	end
	self:SetWide(w + 20)
	for i,v in ipairs(self.Buttons) do
		v:SetWide(w)
	end
end

function PANEL:PerformLayout(w,h)
	for i,v in ipairs(self.Buttons) do
		v:SetSize(w,h / #self.Buttons)
		v:AlignTop((i - 1) * (h / #self.Buttons) - 2)
	end
end

function PANEL:OnMousePressed(m)
	self.MousePressed = m
end
function PANEL:OnMouseReleased(m)
	if (self.MousePressed == m) then
		if (m == MOUSE_LEFT) then
			local x,y = self:ScreenToLocal(gui.MousePos())
			self.SelectedButton = 1 + math.floor((y / self:GetTall()) * #self.Buttons)
			local btn = self.Buttons[self.SelectedButton]
			if (IsValid(btn)) then
				if (self.OptionChanged) then
					self:OptionChanged(btn:GetText())
				end
			end
		end
	end
end

derma.DefineControl("bVGUI.VerticalOptionSelector", nil, PANEL, "bVGUI.BlankPanel")
--gamemodes/starwarsrp/gamemode/modules/player/cl_player.lua:

net.Receive( "AOCRP.API.RecieveSharedKey", function( len, ply )

    AOCRP.API.SharedKey = net.ReadString()

    AOCRP:DoInitalClientLoad()
end)


--gamemodes/starwarsrp/gamemode/modules/gui/cl_scoreboard.lua:
AOCRP.ScoreBoard = AOCRP.ScoreBoard or {}






function AOCRP.ScoreBoard:GetDefcon()
    return GetGlobalNetVar("AOCRP.DEFCON",0)
    --return 5
end


function AOCRP.ScoreBoard:GetDefconColor(defcon) 
    return AOCRP.Config.Defcon[defcon].color
end


function AOCRP.ScoreBoard:GetAveragePing()

  -- Get a table of all connected players
  local players = player.GetAll()

  -- Initialize a sum variable to keep track of the total ping
  local pingSum = 0

  -- Iterate through the table of players and add their ping to the sum
  for _, ply in pairs(players) do
    pingSum = pingSum + ply:Ping()
  end

  -- Calculate the average ping by dividing the sum by the number of players
  local averagePing = pingSum / #players

  return math.Round(averagePing)

end

function AOCRP.ScoreBoard:GetMapTimeString()
    local mapTime = CurTime() - GetGlobalInt("MapStartTime")
    local hours = math.floor(mapTime / 3600)
    local minutes = math.floor((mapTime - (hours * 3600)) / 60)
    local seconds = math.floor(mapTime - (hours * 3600) - (minutes * 60))
    return string.format("%02d:%02d:%02d", hours, minutes, seconds)
end


local function getUnitOnlineCount(unit)
    local i = 0
    for k, v in pairs(player.GetAll()) do
        if v:GetUnitID() == unit then
            i = i + 1
        end
    end
    return i
end





function GM:ScoreboardShow()

    AOCRP.ScoreBoard:ShowNewScoreboard()

    return true 

end

function GM:ScoreboardHide()
    if AOCRP.ScoreBoard.FRAME then AOCRP.ScoreBoard.FRAME:Remove() end
end


local function drawRibbon(parent, width, ribbon)
    local ribbonData = AOCRP.Ribbons:GetRibbon(ribbon)
    local heigth = (350 / 1000) * width

    local image = vgui.Create("DButton", parent)
    --image:SetSize(AOCW(width), AOCH(heigth) )
    image:SetText("")
    image:Dock(RIGHT)
    image:SetWide(AOCW(70))



    function image:Paint(w,h)
        PIXEL.DrawImgur(0,0, w, h, ribbonData.url, Color(255,255,255))
    end
    function image:DoClick()
        AOCRP.Ribbons:DisplayRibbon(ribbon)
    end


    return image
end

local function displayRibbons(panel, ply, wide)

    local ribbons = AOCRP.Ribbons:PlayerGetActiveRibbons(ply)




    for k, v in pairs(ribbons) do
        local ribb = drawRibbon(panel, 90, v)

        local siz = AOCH(25)
        ribb:DockMargin(AOCW(5),siz/2,AOCW(5),siz/2)

        if k == 1 then
            ribb:DockMargin(AOCW(5),siz/2,AOCW(15),siz/2)
        end
    end       

end





local function panelLabelDesc(parent,text,wide)
    local name = vgui.Create("DLabel", parent)
    name:SetFont(AOCDerma:DF("l", 25))
    name:SetText(text)
    name:SetTextColor(Color(255,255,255))
    name:Dock(LEFT)
    name:DockMargin(5,0,0,0)
    name:SetWide(wide)
    name:SetContentAlignment(5)
 
end 

local function panelLabel(parent,text,wide,ca)
    local name = vgui.Create("DLabel", parent)
    name:SetFont(AOCDerma:DF("m", 30))
    name:SetText(text)
    name:SetTextColor(Color(255,255,255))
    name:Dock(LEFT)
    name:DockMargin(5,0,0,0)
    name:SetWide(wide)
    name:SetContentAlignment(ca)
end 


function AOCRP.ScoreBoard:ShowNewScoreboard()

    if self.FRAME then self.FRAME:Remove() end

    self.FRAME = vgui.Create("DFrame") -- The name of the panel we don't have to parent it.
    self.FRAME:SetSize(ScrW(), ScrH()) -- Set the size to 300x by 200y.
    self.FRAME:Center()
    self.FRAME:SetTitle("") -- Set the title in the top left to "Derma Frame".
    self.FRAME:MakePopup() -- Makes your mouse be able to move around.
    self.FRAME:SetDraggable(false)
    self.FRAME:SetSizable(false)
    self.FRAME:ShowCloseButton(false)

    local blackColor = Color(0,0,0,240)

    function self.FRAME:OnRemove()
        if AOCRP.ScoreBoard.Menu then
            AOCRP.ScoreBoard.Menu:Remove()
        end
    end
    function self.FRAME:Paint(w,h)

        PIXEL.DrawBlur(self, 0, 0, w, h)
        PIXEL.DrawBlur(self, 0, 0, w, h)
        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))

        PIXEL.DrawImgur(w/2-AOCW(350)/2, AOCH(25), AOCW(350), AOCH(148.93083), AOCRP.Config.LogoCropped, Color(255,255,255) )



    end

    self.PlayerList = vgui.Create("DPanel", self.FRAME)



    self.PlayerList:SetSize(AOCW(860), AOCH(850))
    self.PlayerList:SetPos(ScrW()/2 - self.PlayerList:GetWide()/2, AOCH(200))

    function self.PlayerList:Paint(w,h)
  
    end

    self.PlayerListScroll = AOCDerma:ScrollBar(self.PlayerList)
    self.PlayerListScroll:Dock(FILL)
    self.PlayerListScroll:DockMargin(15,15,15,15)

    local function SubUnitMatchUnit(subunit, unit) 
        if !AOCRP.Config.SubUnits[subunit] then return false end 
        if AOCRP.Config.SubUnits[subunit].unitid == unit then
            return true
        end
        return false
    end

    local members = {}
    local playerCount = 0
    local ping = 0
    local teamCount = 0
    local unitOnlineCount = {}
    local subUnitOnlineCount = {}
    for k, v in pairs(player.GetAll()) do
        members[k] = { ply = v, rang = v:GetRankID()}



        ping = ping + v:Ping()
        playerCount = playerCount + 1

        if AOCRP.Admin:IsTeamMember(v) then
            teamCount = teamCount + 1
        end

        if !unitOnlineCount[v:GetUnitID()] then
            unitOnlineCount[v:GetUnitID()] = 0
        end

        if !subUnitOnlineCount[v:GetSubUnitID()] then
            subUnitOnlineCount[v:GetSubUnitID()] = 0
        end

        if SubUnitMatchUnit(v:GetSubUnitID(), v:GetUnitID()) then
            subUnitOnlineCount[v:GetSubUnitID()] = subUnitOnlineCount[v:GetSubUnitID()] + 1
        end

        unitOnlineCount[v:GetUnitID()] = unitOnlineCount[v:GetUnitID()] + 1
    end


    local averagePing = math.Round(ping / playerCount)

    local function playerPanelCreate(panel, v)
        local playerPanel = vgui.Create("DPanel", panel)
        playerPanel:SetTall(AOCH(50))
        
        playerPanel:Dock(TOP)
        playerPanel:DockMargin(0,0,0,AOCH(5))


        playerPanel:SetMouseInputEnabled(true)
        function playerPanel:OnMousePressed()
            -- Open DMenu with player options
            AOCRP.ScoreBoard.Menu = AOCDerma:Menu()
 

                --AddMenuOption(menu, "Steamprofil öffnen", function() AOCDerma:OpenWebPage("Steam Profile", "https://steamcommunity.com/profiles/" .. v:SteamID64()) end)

                if v.ply != LocalPlayer() then 
                    AOCRP.ScoreBoard.Menu:AddOption( "Anrufen", function()
                        net.Start("AOCRP.Comlink.Calling.RequestCall")
                        net.WriteEntity(v.ply)
                        net.SendToServer() 
                        AOCRP.ScoreBoard.FRAME:Remove()
                    end)

                    AOCRP.ScoreBoard.Menu:AddOption( "Funknachricht senden", function()
                        local request = AOCDerma:SmallStringRequest( "Funknachricht an "..v.ply:Nick(), function(text) 
    
                            RunConsoleCommand("say", "/funk "..v.ply:GetCloneID().." "..text)
                        end, "", "" )
                        AOCRP.ScoreBoard.FRAME:Remove()
                    end)

        
                end
                AOCRP.ScoreBoard.Menu:AddOption( "Klon-ID kopieren", function() SetClipboardText(v.ply:GetCloneID()) end)
                AOCRP.ScoreBoard.Menu:AddOption( "S-ID kopieren", function() SetClipboardText(v.ply:SteamID64()) end)
                AOCRP.ScoreBoard.Menu:AddOption( "Akte anzeigen", function() gui.OpenURL("https://api.ageofclones.de/portal.php?portal="..v.ply:SteamID64()) end)

                if AOCRP.Admin:IsTeamMember(LocalPlayer()) then
                    AOCRP.ScoreBoard.Menu:AddOption( "Goto", function() RunConsoleCommand("sam", "goto", v.ply:Nick()) end)
                end
                AOCRP.ScoreBoard.Menu:Open()
          
        end

        function playerPanel:Paint(w,h)

            draw.RoundedBox(0,0,0,w,h,blackColor)

            local gear = "..."
            if IsValid(v.ply) then 
       --[[          if AOCRP.Gears[v.ply:GetGearID()] then
                    gear = AOCRP.Gears[v.ply:GetGearID()].name
                end
 ]]
                gear = AOCRP.Unit:GetRankName(v.ply:GetRankID(), v.ply:GetUnitID())
            end

            
      

            local sizW, sizH = AOCDerma:GetTextSize(gear, AOCDerma:DF("m", 30))
            draw.DrawText(gear, AOCDerma:DF("m", 30), w/2, h/2-sizH/2, Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end 


        local Avatar = vgui.Create( "DPanel", playerPanel )
        Avatar:Dock(LEFT)
        Avatar:SetWide(AOCW(42))
        Avatar:DockMargin(5,5,10,5)
        function Avatar:Paint(w,h)
            if !IsValid(v.ply) then return end
                PIXEL.DrawImgur(0,0,w,h, AOCRP.Ranks[v.ply:GetRankID()].icon, Color(255,255,255))

        end

        function Avatar:OnMousePressed()
            AOCRP.ScoreBoard.Menu = AOCDerma:Menu()

            AOCRP.ScoreBoard.Menu:AddOption( AOCRP.Unit:GetRankName(v.ply:GetRankID(), v.ply:GetUnitID()), function() end)
            AOCRP.ScoreBoard.Menu:Open()
        end
 

        local namePanel = vgui.Create("DPanel", playerPanel)
        namePanel:Dock(LEFT)
        namePanel:SetWide(AOCW(225))
        namePanel:DockMargin(5,0,0,0)
        function namePanel:Paint(w,h)

            if !IsValid(v.ply) then return end
            local sizW, sizH = AOCDerma:GetTextSize(v.ply:Nick(), AOCDerma:DF("m", 30))

            draw.DrawText(v.ply:Nick(), AOCDerma:DF("m", 30), 5, h/2 - sizH/2, Color(255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

        end

        displayRibbons(playerPanel, v.ply, AOCW(100))
    end



    local UnitCategorys = {}
    for k, v in SortedPairs(AOCRP.Units, true) do
        local count = unitOnlineCount[k] or 0
        if count > 0 then
            local DCollapsible = vgui.Create( "DCollapsibleCategory", self.PlayerListScroll )	-- Create a collapsible category
            DCollapsible:SetLabel("")						-- Set the name ( label )
            DCollapsible.NewLabel = v.name .. " ("..count..")"
            DCollapsible:SetExpanded( true )	-- Start collapsed
                DCollapsible.Header:SetTall(AOCH(40))
            DCollapsible:Dock(TOP)
    
            DCollapsible.Paint = function() end
            DCollapsible.Header.Paint = function(self, w,h)
            draw.SimpleText( DCollapsible.NewLabel, AOCDerma:DF("l",30), w/2, h/2, AOCDerma:HexToColor(v.colorhex), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                surface.SetDrawColor(Color(255,255,255,10))
                surface.DrawRect(0, h-1, w, 1)
            end

            if tobool(v.sh) and !AOCRP.Admin:IsTeamMember(LocalPlayer()) then
                DCollapsible:Hide()
            end
            UnitCategorys[k] = DCollapsible
        end
    end


    
    for k, v in SortedPairsByMemberValue(members, "rang", true) do
        if !IsValid(v.ply) then continue end


        if v.ply:GetSubUnitID() > 1 and SubUnitMatchUnit(v.ply:GetSubUnitID(), v.ply:GetUnitID()) then continue end


        playerPanelCreate(UnitCategorys[v.ply:GetUnitID()], v)

    end


    local SubUnitCategorys = {}
    for k, v in SortedPairs(AOCRP.Config.SubUnits) do

        if k == 1 then continue end

        local count = subUnitOnlineCount[k] or 0
        if count > 0 then

            local unitpanel = self.PlayerListScroll 
            if  UnitCategorys[v.unitid] then
                unitpanel = UnitCategorys[v.unitid]
            end
            local DCollapsible = vgui.Create( "DCollapsibleCategory", unitpanel  )	-- Create a collapsible category
            DCollapsible:SetLabel("")						-- Set the name ( label )
            DCollapsible.NewLabel = v.name .. " ("..count..")"
            DCollapsible:SetExpanded( true )	-- Start collapsed
            DCollapsible.Header:SetTall(AOCH(30))
            DCollapsible:Dock(TOP)
            DCollapsible:DockMargin(AOCW(10),0,AOCW(10),0)
    
            DCollapsible.Paint = function() end
            DCollapsible.Header.Paint = function(self, w,h)
                draw.SimpleText( DCollapsible.NewLabel, AOCDerma:DF("l",25), w/2, h/2, AOCDerma:HexToColor(AOCRP.Units[v.unitid].colorhex), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                surface.SetDrawColor(Color(255,255,255,10))
                surface.DrawRect(0, h-1, w, 1)
            end

            SubUnitCategorys[k] = DCollapsible
        end
    end



    for k, v in SortedPairsByMemberValue(members, "rang", true) do
        if !IsValid(v.ply) then continue end


        if v.ply:GetSubUnitID() < 2 or !SubUnitMatchUnit(v.ply:GetSubUnitID(), v.ply:GetUnitID()) then continue end


        playerPanelCreate(SubUnitCategorys[v.ply:GetSubUnitID()], v)

    end





    self.Info = vgui.Create("DPanel", self.FRAME)



    self.Info:SetSize(AOCW(300), AOCH(850))
    self.Info:SetPos(ScrW()/2 + self.PlayerList:GetWide()/2 + AOCW(50), AOCH(200))

    function self.Info:Paint(w,h)
        --draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
    end


    self.Info2 = vgui.Create("DPanel", self.FRAME)



    self.Info2:SetSize(AOCW(300), AOCH(850))
    self.Info2:SetPos(ScrW()/2 - self.PlayerList:GetWide()/2 - AOCW(300) - AOCW(50), AOCH(200))

    function self.Info2:Paint(w,h)
        --draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
    end

    local defcon2 = vgui.Create("DPanel", self.Info2)
    defcon2:Dock(TOP)
    defcon2:SetTall(AOCH(30))
    defcon2:DockMargin(0,15,0,5)
   
    function defcon2:Paint(w,h)
        draw.RoundedBox(0,0,h-2,w,2,Color(255,255,255,255))
    end

    local defcon = vgui.Create("DPanel", self.Info)
    defcon:Dock(TOP)
    defcon:SetTall(AOCH(30))
    defcon:DockMargin(0,15,0,10)
   
    function defcon:Paint(w,h)
        draw.RoundedBox(0,0,h-2,w,2,Color(255,255,255,255))
    end

    panelLabelDesc(defcon,"Informationen",self.Info:GetWide())

    panelLabelDesc(defcon2,"Kommandostruktur",self.Info2:GetWide())





    local function fancyCommandoName(id)

        local ent = GetGlobalNetVar( "AOCRP."..id, nil)
        if IsValid( ent ) then
            local prefix = AOCRP.Unit:GetRankPrefix(ent:GetRankID(), ent:GetUnitID())
            return prefix.." ".. ent:Nick()
        end
        return "- / -"
    end

    local commando = {
        ["COMMANDINGOFFICER"] = "Commanding Officer",
        ["EXECUTIVEOFFICER"] = "Executive Officer",
        ["NO"] = "Naval Officer",
        ["TO"] = "Technical Officer",
        ["MO"] = "Medical Officer",
        ["SO"] = "Security Officer"
    }

    local defNumber = vgui.Create("DPanel", self.Info)
    defNumber:Dock(TOP)
    defNumber:SetTall(AOCH(50))
    function defNumber:Paint(w,h)
        draw.RoundedBox(0,0,0,w,h,blackColor)

        draw.DrawText("DEFCON "..AOCRP.ScoreBoard:GetDefcon(), AOCDerma:DF("l", 45), w/2, 0, AOCRP.ScoreBoard:GetDefconColor(AOCRP.ScoreBoard:GetDefcon()), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.DrawText(AOCRP.Config.Defcon[AOCRP.ScoreBoard:GetDefcon()].title, AOCDerma:DF("s", 20), w/2, AOCH(30), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

    end


    local function defaultInfoPanel(panel, big,small)
        local defNumber = vgui.Create("DPanel", panel)
        defNumber:Dock(TOP)
        defNumber:SetTall(AOCH(50))
        defNumber:DockMargin(0,AOCH(5),0,0)
        function defNumber:Paint(w,h)
            draw.RoundedBox(0,0,0,w,h,blackColor)
                draw.DrawText(big, AOCDerma:DF("m", 30), w/2, AOCH(10), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                draw.DrawText(small, AOCDerma:DF("s", 20), w/2, AOCH(30), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end

    for k, v in SortedPairs(commando) do
        defaultInfoPanel(self.Info2, fancyCommandoName(k),v)
    end

        -- highest rank
        local highname = "- / -"
        local highest = AOCRP.Unit:GetOverallHighestRanking()
        if IsValid(highest) then 
            highname = highest:Nick()
        end
        defaultInfoPanel(self.Info,highname,"Höchstrangigster")

        
    defaultInfoPanel(self.Info,playerCount,"Truppenstärke")
    defaultInfoPanel(self.Info,teamCount,"Sicherheitssoldaten")
    defaultInfoPanel(self.Info,AOCRP.ScoreBoard:GetMapTimeString(),"Einsatzzeit")
 
    defaultInfoPanel(self.Info,averagePing,"Comlinklatenz")



end

if AOCRP.ScoreBoard.FRAME then AOCRP.ScoreBoard.FRAME:Remove() end
--gamemodes/starwarsrp/gamemode/modules/event/sh_eventserver.lua:


if CLIENT then

    net.Receive("AOCRP.EventServerConnect", function( len, ply )  
        permissions.AskToConnect( AOCRP.Config.EventServerIP )
    end)

    net.Receive("AOCRP.HauptServerConnect", function( len, ply )  
        permissions.AskToConnect( AOCRP.Config.HauptServerIP )
    end)
end





if CLIENT then
    
    

        spawnmenu.GetCreationTabs()["Particles"] = nil
        spawnmenu.GetCreationTabs()["#spawnmenu.category.saves"] = nil
        spawnmenu.GetCreationTabs()["#spawnmenu.category.postprocess"] = nil
        spawnmenu.GetCreationTabs()["#spawnmenu.category.dupes"] = nil


        g_MusicStation = g_MusicStation or nil

        function AOCRP:PlayMusic(path)

    
            local soundStation = nil
        
            -- Dont play this sounds to the instructors
            if LocalPlayer():GetUnitID() and LocalPlayer():GetUnitID() == 1 then return end
        
            local vol = 1
            local dur = 0
       
            local function playSound(startPos)
           
                    local soundObject = sound.PlayURL(path, "noblock", function(station) 
                        if (IsValid(station)) then
                            station:SetVolume(math.min(vol, cookie.GetNumber("AOCRP_MusicVolume", 1)))
                            station:Play()
                            station:SetTime(startPos)
        
                            if dur < 1 then
                                dur = station:GetLength()
                            end
                            
                            g_MusicStation = station
                        end
                    end)
     
            end
        
            local function checkSound()
                if g_MusicStation and IsValid(g_MusicStation) then
                    if g_MusicStation:GetState() == GMOD_CHANNEL_STOPPED then
                        currentPos = g_MusicStation:GetTime()
                        playSound(currentPos)
                    end
                end
            end
        
            playSound(0)
        
      
                local rep = 0
                timer.Create("AOCRP.Sound_" .. path, 1, dur, function()
                    rep = rep + 1
        
                    if rep >= dur then
                        timer.Remove("AOCRP.Sound_" .. path)
                        return
                    end
        
                    checkSound()
                end)

        end

        function AOCRP:StopMusic()
            if IsValid(g_MusicStation) then 
                if g_MusicStation:IsValid() then
                    g_MusicStation:Stop()
                    RunConsoleCommand("stopsound")
                    g_MusicStation = nil
                end
            end
        end

        
        spawnmenu.AddCreationTab( "Eventmusik", function()

            HTML = vgui.Create("DPanel")
    
            function HTML:Paint(w,h)
                draw.RoundedBox(0,0,0,w,h,Color(0,0,0))
            end
    
            local entry = AOCDerma:TextEntry(HTML,"Suche nach geeigneter Musik")
            entry:SetTall(AOCH(50))
            entry:Dock(TOP)
            entry:DockMargin(10,10,10,10)
            entry:SetUpdateOnType(true)

            HTML.scroll = AOCDerma:ScrollBar(HTML)
            HTML.scroll:Dock(FILL)
     
    
            local url = "https://api.ageofclones.de/aoc3/music/"
            
            HTML.files = {}
            HTML.buttons = {}
            function entry:OnValueChange(value)
                for k, v in pairs(HTML.buttons) do 
                    if string.find(string.lower(v.name), string.lower(value)) then 
                        v.button:Show()
                    else 
                        v.button:Hide()
                    end
                end
                HTML.scroll:PerformLayoutInternal()
            end 


            local Button =  AOCDerma:Button(HTML.scroll, "Stoppe lokale Musik", function() 
                AOCRP:StopMusic()   
            end, "b")
            Button:Dock(TOP)

            local Button =  AOCDerma:Button(HTML.scroll, "Stoppe Musik für ALLE", function() 
                RunConsoleCommand("sam", "stopmusic")
            end, "b")
            Button:Dock(TOP)

            
            http.Fetch(
                url,
                function(body, len, headers, code)
                    if code == 200 then
                        local files = {}
                        -- Find all MP3 file entries in the HTML directory listing.
                        for file in string.gmatch(body, 'href="(.-%.mp3)"') do
                            local decodedName = string.gsub(file, "%%20", " ")
                            decodedName = string.gsub(decodedName, "%.mp3$", "")
        
                            table.insert(files, {
                                name = decodedName,
                                url = url .. file
                            })
                        end
        
                        for k, v in pairs(files) do
                            if k == 1 then continue end
                            local Button =  AOCDerma:Button(HTML.scroll, v.name, function() 

                                AOCRP:PlayMusic(v.url)   


                            end, "b")
                            Button:Dock(TOP)

                            function Button:DoRightClick()
                                RunConsoleCommand("sam", "playmusic", v.url)
                            end

                            HTML.buttons[k] = {
                                name = v.name,
                                button = Button
                            } 
                        end
        
                        -- Use the `files` table as needed in your code.
                    else
                        print("HTTP Fetch failed with code: " .. code)
                    end
                end,
                function(error)
                    print("HTTP Fetch failed: " .. error)
                end
            )
    
            return HTML
        
        end, "icon16/music.png", 200 )



end

if SERVER then 

    util.AddNetworkString("AOCRP.Music.Play")

end 

if CLIENT then
    


    
    net.Receive("AOCRP.Music.Play", function()
        local url = net.ReadString()
        AOCRP:PlayMusic(url) 
    end)

end



if SERVER then 

    util.AddNetworkString("AOCRP.Music.Stop")

end 

if CLIENT then
    
    
    net.Receive("AOCRP.Music.Stop", function()
        AOCRP:StopMusic() 
    end)

end




if SERVER then 

    util.AddNetworkString("AOCRP.Music.ChangeVolume")

end 

if CLIENT then

    local function NormalizeNumber(num)
        local base = 100 -- Basis für die Umwandlung
        return num / base
    end
    
    function AOCRP:ChangeMusicVolume(vol)

        local newVol = NormalizeNumber(vol)
        if newVol < 0 then newVol = 0 end 

        cookie.Set("AOCRP_MusicVolume", newVol )
        if IsValid(g_MusicStation) then 
            if g_MusicStation:IsValid() then
                g_MusicStation:SetVolume(newVol)
            end
        end
    end

    net.Receive("AOCRP.Music.ChangeVolume", function()
        local vol = net.ReadInt(10)
        AOCRP:ChangeMusicVolume(vol) 
    end)

end
--gamemodes/starwarsrp/gamemode/modules/comlink/cl_comlink.lua:
AOCRP.Comlink = AOCRP.Comlink or {}


local function activeInactiveColorSwitch(active,alt)
    active.akzent = Color(26,155,0)
    active.akzenthover = Color(0,255,0)

    alt.akzent = Color(200,200,200,255)
    alt.akzenthover = Color(255,255,255,255)
end


local function idToPlayer(id)
    for k, v in pairs(player.GetHumans()) do
       if tonumber(v:GetCloneID()) == tonumber(id) then
            return v
       end 
    end
    return nil 
    
end

local function callWindow(panel)
    local searchbar = AOCDerma:TextEntry(panel,"ID eingeben ...")
    searchbar:SetNumeric(true)
    searchbar:DockMargin(10,10,10,10)
    searchbar:Dock(TOP)
    searchbar:SetTall(AOCH(60))


    local callbutton =  AOCDerma:Button(panel, "Verbindung aufbauen", function() 
        local eingabe = searchbar:GetInt()
        print(eingabe)

        if AOCRP.CharSys:IsCorrectID(eingabe) then
            if AOCRP.CharSys:IdToPlayer(eingabe) then
                local target = AOCRP.CharSys:IdToPlayer(eingabe)
                
                if target == LocalPlayer() then 
                    local warnung1 = AOCDerma:Derma_Message( "Du kannst dich nicht selber anrufen.", "Fehler", "Schließen" )
                    warnung1:SetSize(AOCW(500), AOCH(200))
                    warnung1:Center()
                    return
                end

                -- Initiate Call
                net.Start("AOCRP.Comlink.Calling.RequestCall")
                net.WriteEntity(target)
                net.SendToServer()
                

                if ValidPanel(AOCRP.Comlink.FRAME) then AOCRP.Comlink.FRAME:Remove() end

            else
                local warnung1 = AOCDerma:Derma_Message( "Einheit nicht im Dienst", "Fehler", "Schließen" )
                warnung1:SetSize(AOCW(500), AOCH(200))
                warnung1:Center()
            end
            
        else
            local warnung = AOCDerma:Derma_Message( "Die ID ist nicht korrekt", "Fehler", "Schließen" )
            warnung:SetSize(AOCW(500), AOCH(200))
            warnung:Center()


        end
        
    end, "bc")
    callbutton:Dock(TOP)
        callbutton:DockMargin(10,10,10,10)
    callbutton.akzent = Color(26,155,0)
    callbutton.akzenthover = Color(0,255,0)
end





function AOCRP.Comlink:OpenMenu()

    if ValidPanel(self.FRAME) then self.FRAME:Remove() end
    self.FRAME = AOCDerma:DefaultFrame()
    self.FRAME:SetSize(AOCW(680),AOCH(1000))
    self.FRAME:Center()
    self.FRAME:SetNewTitle("Comlink")
    self.FRAME:SetSizable(false)
    self.FRAME:SetDraggable(false)


    local btnMenu = vgui.Create("DPanel", self.FRAME)
    btnMenu:Dock(TOP)
    btnMenu:SetTall(AOCH(50))
    btnMenu:SetPaintBackground(false)
    
    local content = AOCDerma:ScrollBar(self.FRAME) 
    content:Dock(FILL)
    content:DockMargin(0,AOCH(10),0,0)
    content:SetPaintBackground(false)

    channels = AOCDerma:Button(btnMenu, "Funkkanäle", function() 
    
        content:Clear()
        activeInactiveColorSwitch(channels,direct)
        AOCRP.Comlink:ChannelsContent(content)


    end, "lb")
    channels:Dock(LEFT)


    direct = AOCDerma:Button(btnMenu, "Direktkommunikation", function() 
      content:Clear()
        activeInactiveColorSwitch(direct,channels)
        callWindow(content)
    end, "br")
    direct:Dock(RIGHT)
    direct:DockMargin(AOCW(20),0,0,0)

        activeInactiveColorSwitch(channels,direct)
        AOCRP.Comlink:ChannelsContent(content)

end

AOCRP_Comlink_F1 = AOCRP_Comlink_F1 or ""
AOCRP_Comlink_F2 = AOCRP_Comlink_F2 or ""
AOCRP_Comlink_F3 = AOCRP_Comlink_F3 or ""

PIXEL.RegisterFont("AOCRP.Comlink.ChannelName", "Agency FB", 35, 1000)
PIXEL.RegisterFont("AOCRP.Comlink.ButtonsChannel", "Agency FB", 25, 1000)



local function FToVar(f)
    if f == "f1" then
        return AOCRP_Comlink_F1
    end
    if f == "f2" then
        return AOCRP_Comlink_F2
    end
    if f == "f3" then
        return AOCRP_Comlink_F3
    end    
end

local function FSwitch(f,cid)
    if f == "f1" then
        if AOCRP_Comlink_F1 == cid then AOCRP_Comlink_F1 = "" return end
       AOCRP_Comlink_F1 = cid 
    end
    if f == "f2" then
        if AOCRP_Comlink_F2 == cid then AOCRP_Comlink_F2 = "" return end
        AOCRP_Comlink_F2 = cid
    end
    if f == "f3" then
        if AOCRP_Comlink_F3 == cid then AOCRP_Comlink_F3 = "" return end
        AOCRP_Comlink_F3 = cid
    end   
end


local function FButton(panel,f,cid)

    f1 = AOCDerma:Button(panel, string.upper(input.GetKeyName(AOCRP_Binds:FindBindByID("comlink"..f))), function()

        FSwitch(f,cid)

        if f == "f1" then
            if LocalPlayer():GetSquad() == cid then
                net.Start("AOCRP.Squad.SetSquad")
                net.WriteString("0")
                net.SendToServer()
            else 
                net.Start("AOCRP.Squad.SetSquad")
                net.WriteString(cid)
                net.SendToServer()
            end

        end
    end, "tbclr")
    f1:Dock(RIGHT)
     f1.akzentsize = 1
     f1:DockMargin(0,AOCH(5),AOCW(5),AOCH(5))
    f1.textfont = PIXEL.UI.RegisteredFonts["AOCRP.Comlink.ButtonsChannel"]
    function f1:Think()
        if FToVar(f) == cid then
            self.akzent = Color(26,155,0)
            self.akzenthover = Color(0,255,0)  
        else 
            self.akzent = Color(200,200,200)
            self.akzenthover = Color(255,255,255)  
        end
    end
end


function AOCRP.Comlink:TextContent(content)
    local chatLog = vgui.Create("DPanel", content)
    chatLog:Dock(TOP)
    chatLog:SetTall(AOCH(500))
    

        local sendChat = vgui.Create("DPanel", content)
    sendChat:Dock(TOP)
    sendChat:SetTall(AOCH(300))
    sendChat:DockMargin(0,AOCH(30),0,0)
end

local function BuildChannelPanel(panel,channel,cid)

    if !AOCRP.Comlink:ChannelCanHear(LocalPlayer(), cid) then return end

    local channelPnl = vgui.Create("DPanel", panel)
    channelPnl:Dock(TOP)
    channelPnl:SetTall(AOCH(80))
    channelPnl:DockMargin(0,10,0,0)

    function channelPnl:Paint(w,h)

        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
        surface.SetDrawColor( 255, 255, 255, 128 )
        surface.DrawOutlinedRect( 0, 0, w, h, 1)

        draw.DrawText(channel.name,PIXEL.UI.RegisteredFonts["AOCRP.Comlink.ChannelName"], AOCW(20), AOCH(20), Color(255, 255, 255),TEXT_ALIGN_LEFT)

    end

--[[ 
                 f3 = AOCDerma:Button(channelPnl, "STUMM", function()
    end, "tblr")
    f3:Dock(RIGHT)
    f3:DockMargin(0,25,25,20)
     f3.akzentsize = 1
 ]]

    local btnPanel = vgui.Create("DPanel", channelPnl)
    btnPanel:Dock(RIGHT)
    btnPanel:SetWide(AOCW(179))
    btnPanel:SetPaintBackground(false)
 
    local btnPanelTop = vgui.Create("DPanel", btnPanel)
    btnPanelTop:Dock(TOP)
    btnPanelTop:SetTall(AOCH(40))
    btnPanelTop:SetWide(AOCW(179))
    btnPanelTop:SetPaintBackground(false)

    if !AOCRP.Comlink:ChannelCanSpeak(LocalPlayer(), cid) then btnPanel:SetVisible(false) end


     FButton(btnPanelTop,"f3",cid)
        FButton(btnPanelTop,"f2",cid)
    FButton(btnPanelTop,"f1",cid)
    
    active = AOCDerma:Button(btnPanel, "AKTIV", function()

        if LocalPlayer():ComlinkGetActiveChannel() == cid then
            LocalPlayer():ComlinkSetInactive()
        else
            LocalPlayer():ComlinkSetActiveChannel(cid)
        end
    end, "tbclr")
    active:Dock(FILL)
  active:DockMargin(AOCW(5),0,AOCW(5),AOCH(5))
     active.akzentsize = 1
    active.textfont = PIXEL.UI.RegisteredFonts["AOCRP.Comlink.ButtonsChannel"]
    function active:Think()
        if LocalPlayer():ComlinkGetActiveChannel() == cid then
            self.akzent = Color(26,155,0)
            self.akzenthover = Color(0,255,0)  
            self.printtext = "Aktiv"
        else 

            
            self.akzent = Color(155,0,0)
            self.akzenthover = Color(255,0,0)  
            self.printtext = "Inaktiv"
        end
    end
    active.akzent = activeColor
    active.akzenthover = activeColorHover



                  mute = AOCDerma:Button(channelPnl, "M", function()

                    LocalPlayer():ComlinkMuteChannel(cid)
    end, "tbclr")
    mute:Dock(RIGHT)
  mute:DockMargin(AOCW(5),AOCH(20),AOCW(10),AOCH(20))
     mute.akzentsize = 1
    mute.textfont = PIXEL.UI.RegisteredFonts["AOCRP.Comlink.ButtonsChannel"]
    function mute:Think()
        if LocalPlayer():IsComlinkChannelMuted(cid) then
            self.akzent = Color(155,0,0)
            self.akzenthover = Color(255,0,0)  
        else 
            self.akzent = Color(200,200,200)
            self.akzenthover = Color(255,255,255)  
        end
    end

    if !channel.canMute then
        mute:SetVisible(false)
    end

 
    if string.match(channel.name, "Einheit") then 
        sendsquad = AOCDerma:Button(channelPnl, "SF", function()

            LocalPlayer():ConCommand("say /squadfunk "..cid)
        end, "tbclr")
        sendsquad:Dock(RIGHT)
        sendsquad:DockMargin(AOCW(5),AOCH(20),AOCW(10),AOCH(20))
        sendsquad.akzentsize = 1
        sendsquad.textfont = PIXEL.UI.RegisteredFonts["AOCRP.Comlink.ButtonsChannel"]
    end

    if string.match(channel.name, "Einheit") then 
        sendsquad = AOCDerma:Button(channelPnl, "TF", function()

            LocalPlayer():ConCommand("say /truppfunk "..cid)
        end, "tbclr")
        sendsquad:Dock(RIGHT)
        sendsquad:DockMargin(AOCW(5),AOCH(20),AOCW(10),AOCH(20))
        sendsquad.akzentsize = 1
        sendsquad.textfont = PIXEL.UI.RegisteredFonts["AOCRP.Comlink.ButtonsChannel"]
    end
--[[ 
             f3 = AOCDerma:Button(channelPnl, "F3", function()
    end, "tblr")
    f3:Dock(RIGHT)
     f3.akzentsize = 1
     f3:DockMargin(20,20,20,20)

             f2 = AOCDerma:Button(channelPnl, "F2", function()
    end, "tblr")
    f2:Dock(RIGHT)
     f2.akzentsize = 1
    f2.akzent = Color(26,155,0)
    f2.akzenthover = Color(0,255,0)
    f2:DockMargin(2,2,2,2)
    f1 = AOCDerma:Button(channelPnl, "F1", function()
    end, "tblr")
    f1:Dock(RIGHT)
     f1.akzentsize = 1
 f1:DockMargin(2,2,2,2) ]]
     
--[[ 
             f3 = AOCDerma:Button(channelPnl, "AKTIV", function()
    end, "tblr")
    f3:Dock(RIGHT)
    f3:DockMargin(0,25,25,20)
     f3.akzentsize = 1 ]]
end

function AOCRP.Comlink:ChannelsContent(content)
    for k, v in SortedPairs(AOCRP.Comlink.Channels) do
        BuildChannelPanel(content,v,k)
    end
end

--- Comlink Calling


PIXEL.RegisterFont("AOCRP.Comlink.CallRequestName", "Agency FB", 30, 10)
PIXEL.RegisterFont("AOCRP.Comlink.CallRequestInfo", "Agency FB", 25, 10)

function AOCRP.Comlink:CallRequest(partner)


    if ValidPanel(self.CALLREQUEST) then self.CALLREQUEST:Remove() end

    self.CALLREQUEST = vgui.Create("DFrame")
    local sizW, sizH = AOCW(300),AOCH(95)
        self.CALLREQUEST:SetSize(sizW,sizH)
    self.CALLREQUEST:SetPos(ScrW()/2 - sizW/2,AOCH(100))
    self.CALLREQUEST:SetTitle("")
        self.CALLREQUEST:SetSizable(false)
    self.CALLREQUEST:SetDraggable(false)
    self.CALLREQUEST:ShowCloseButton(false)

    local start = 0
    local color = Color(109,0,0,200)
    local state = true
    function self.CALLREQUEST:Paint(w,h)

        if !IsValid(partner) then
            net.Start("AOCRP.Comlink.Calling.EndCallForcefully")
            net.SendToServer()
            self:Remove()
            return
        end

        if CurTime() > start then
            start = CurTime() + 1
            if state then
                color = Color(255,255,255)   
                state = false 
            else
                color = Color(139,139,139,200)
                state = true
            end
        end
        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))

        draw.RoundedBox(0,5,5,w-10,2,color)
        draw.RoundedBox(0,5,h-7,w-10,2,color)

        draw.DrawText("Eingehender Sprachanruf",PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestInfo"], w/2, 10, Color(255, 255, 255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)

        draw.DrawText(string.upper(partner:Nick()),PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestName"], w/2, 35, Color(255, 255, 255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)

        
    end

    function self.CALLREQUEST:OnRemove()
        if AOCRP.Comlink.SoundStation then
            AOCRP.Comlink.SoundStation:Stop()
            AOCRP.Comlink.SoundStation = nil
        end
    end
    

    
    sound.PlayURL ("https://ageofclones.de/aoc_content/gtm/ringtones/cantina.mp3", "mono", function( station, err, errstring )
		if ( IsValid( station ) ) then
			station:Play()
			station:SetVolume(0.1)
            self.SoundStation = station
		else
			LocalPlayer():ChatPrint( "Error " .. err.. " - ".. errstring )
		end
	end )

    local btnPanel = vgui.Create("DPanel", self.CALLREQUEST)
    btnPanel:Dock(FILL)
    btnPanel:DockMargin(20,25,20,10)
    btnPanel:SetPaintBackground(false)

    local accept = AOCDerma:Button(btnPanel, "", function() 


                if ValidPanel(self.CALLREQUEST) then self.CALLREQUEST:Remove() end

                net.Start("AOCRP.Comlink.Calling.AcceptCall")
                net.WriteEntity(partner)
                net.SendToServer()
    end, "lb")
    accept:Dock(LEFT)
    accept:SetWide(110)
        accept.akzent = Color(5,155,0)
    accept.akzenthover = Color(0,255,0,255)

        local deny = AOCDerma:Button(btnPanel, "", function() 

                if ValidPanel(self.CALLREQUEST) then self.CALLREQUEST:Remove() end
                net.Start("AOCRP.Comlink.Calling.DenyCall")
                net.WriteEntity(partner)
                net.SendToServer()
        end, "rb")
    deny:Dock(RIGHT)
        deny:SetWide(110)
                deny.akzent = Color(155,0,0)
    deny.akzenthover = Color(255,0,0)



end


function AOCRP.Comlink:Ping(partner)


    if ValidPanel(self.PING) then self.PING:Remove() end

    self.PING = vgui.Create("DFrame")
    local sizW, sizH = AOCW(300),AOCH(95)
        self.PING:SetSize(sizW,sizH)
    self.PING:SetPos(ScrW()/2 - sizW/2,AOCH(100))
    self.PING:SetTitle("")
        self.PING:SetSizable(false)
    self.PING:SetDraggable(false)
    self.PING:ShowCloseButton(false)

    local start = 0
    local color = Color(109,0,0,200)
    local state = true
    function self.PING:Paint(w,h)


        if CurTime() > start then
            start = CurTime() + 1
            if state then
                color = Color(255,255,255)   
                state = false 
            else
                color = Color(139,139,139,200)
                state = true
            end
        end
        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))

        draw.RoundedBox(0,5,5,w-10,2,color)
        draw.RoundedBox(0,5,h-7,w-10,2,color)

        draw.DrawText("PING",PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestInfo"], w/2, 10, Color(255, 255, 255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)

        draw.DrawText(string.upper(partner:Nick()),PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestName"], w/2, 35, Color(255, 255, 255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)

        
    end


    local btnPanel = vgui.Create("DPanel", self.PING)
    btnPanel:Dock(FILL)
    btnPanel:DockMargin(20,25,20,10)
    btnPanel:SetPaintBackground(false)



        local deny = AOCDerma:Button(btnPanel, "", function() 

                if ValidPanel(self.PING) then self.PING:Remove() end
                net.Start("AOCRP.Comlink.Calling.DenyCall")
                net.WriteEntity(partner)
                net.SendToServer()
        end, "b")
    deny:Dock(BOTTOM)
        deny:SetWide(110)
                deny.akzent = Color(155,0,0)
    deny.akzenthover = Color(255,0,0)



end




function AOCRP.Comlink:CallDial(partner)

    if ValidPanel(self.CALLDIAL) then self.CALLDIAL:Remove() end

    self.CALLDIAL = vgui.Create("DFrame")
    local sizW, sizH = AOCW(300),AOCH(95)
        self.CALLDIAL:SetSize(sizW,sizH)
    self.CALLDIAL:SetPos(ScrW()/2 - sizW/2,AOCH(100))
    self.CALLDIAL:SetTitle("")
        self.CALLDIAL:SetSizable(false)
    self.CALLDIAL:SetDraggable(false)
    self.CALLDIAL:ShowCloseButton(false)


    local color = Color(255,255,255)   

    function self.CALLDIAL:Paint(w,h)
        if !IsValid(partner) then
            net.Start("AOCRP.Comlink.Calling.EndCallForcefully")
            net.SendToServer()
            self:Remove()
            return
        end

        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))

        draw.RoundedBox(0,5,5,w-10,2,color)
        draw.RoundedBox(0,5,h-7,w-10,2,color)

        draw.DrawText("Du rufst an",PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestInfo"], w/2, 10, Color(255, 255, 255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)

        draw.DrawText(string.upper(partner:Nick()),PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestName"], w/2, 35, Color(255, 255, 255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)


    end

    function self.CALLDIAL:OnRemove()
        if AOCRP.Comlink.SoundStation then
            AOCRP.Comlink.SoundStation:Stop()
            AOCRP.Comlink.SoundStation = nil
        end
    end
    

    
--[[     sound.PlayURL ("https://ageofclones.de/cwrp/gtm/ringtones/cantina.mp3", "mono", function( station, err, errstring )
		if ( IsValid( station ) ) then
			station:Play()
			station:SetVolume(0.1)
            self.SoundStation = station
		else
			LocalPlayer():ChatPrint( "Error " .. err.. " - ".. errstring )
		end
	end ) ]]

    local btnPanel = vgui.Create("DPanel", self.CALLDIAL)
    btnPanel:Dock(FILL)
    btnPanel:DockMargin(20,25,20,10)
    btnPanel:SetPaintBackground(false)


        local deny = AOCDerma:Button(btnPanel, "", function() 

                if ValidPanel(self.CALLDIAL) then self.CALLDIAL:Remove() end
                net.Start("AOCRP.Comlink.Calling.AbortDial")
                net.WriteEntity(partner)
                net.SendToServer()
        end, "b")
    deny:Dock(BOTTOM)
        deny:SetWide(110)
                deny.akzent = Color(155,0,0)
    deny.akzenthover = Color(255,0,0)


    timer.Simple(AOCRP.Config.ComlinkDialTime, function() 
    
        if ValidPanel(AOCRP.Comlink.CALLDIAL) then 
            
            AOCRP.Comlink.CALLDIAL:Remove() 
        
                
            net.Start("AOCRP.Comlink.Calling.AbortDial")
            net.WriteEntity(partner)
            net.SendToServer()
        end

    end)


end

function AOCRP.Comlink:InACall(partner)

    if ValidPanel(self.INACALL) then self.INACALL:Remove() end

    self.INACALL = vgui.Create("DFrame")
    local sizW, sizH = AOCW(300),AOCH(95)
        self.INACALL:SetSize(sizW,sizH)
    self.INACALL:SetPos(ScrW()/2 - sizW/2,AOCH(100))
    self.INACALL:SetTitle("")
        self.INACALL:SetSizable(false)
    self.INACALL:SetDraggable(false)
    self.INACALL:ShowCloseButton(false)


    local color = Color(255,255,255)   

    function self.INACALL:Paint(w,h)
        if !IsValid(partner) then
            net.Start("AOCRP.Comlink.Calling.EndCallForcefully")
            net.SendToServer()
            self:Remove()
            return 
        end

        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))

        draw.RoundedBox(0,5,5,w-10,2,color)
        draw.RoundedBox(0,5,h-7,w-10,2,color)

        draw.DrawText("Du telefonierst mit",PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestInfo"], w/2, 10, Color(255, 255, 255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)

        draw.DrawText(string.upper(partner:Nick()),PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestName"], w/2, 35, Color(255, 255, 255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)


    end

    function self.INACALL:OnRemove()
        if AOCRP.Comlink.SoundStation then
            AOCRP.Comlink.SoundStation:Stop()
            AOCRP.Comlink.SoundStation = nil
        end
    end
    

    
--[[     sound.PlayURL ("https://ageofclones.de/cwrp/gtm/ringtones/cantina.mp3", "mono", function( station, err, errstring )
		if ( IsValid( station ) ) then
			station:Play()
			station:SetVolume(0.1)
            self.SoundStation = station
		else
			LocalPlayer():ChatPrint( "Error " .. err.. " - ".. errstring )
		end
	end ) ]]

    local btnPanel = vgui.Create("DPanel", self.INACALL)
    btnPanel:Dock(FILL)
    btnPanel:DockMargin(20,25,20,10)
    btnPanel:SetPaintBackground(false)


        local deny = AOCDerma:Button(btnPanel, "", function() 

                if ValidPanel(self.INACALL) then self.INACALL:Remove() end
                net.Start("AOCRP.Comlink.Calling.Hangup")
                net.WriteEntity(partner)
                net.SendToServer()
        end, "b")
    deny:Dock(BOTTOM)
        deny:SetWide(110)
                deny.akzent = Color(155,0,0)
    deny.akzenthover = Color(255,0,0)



end



net.Receive( "AOCRP.Comlink.Calling.InACall", function( len, ply )
    local partner = net.ReadEntity()

    if ValidPanel(AOCRP.Comlink.CALLDIAL) then AOCRP.Comlink.CALLDIAL:Remove() end
    if ValidPanel(AOCRP.Comlink.CALLREQUEST) then AOCRP.Comlink.CALLREQUEST:Remove() end

    AOCRP.Comlink:InACall(partner)
end)

net.Receive( "AOCRP.Comlink.Calling.SetPartner", function( len, ply )
    local partner = net.ReadEntity()
    AOCRP_Comlink_Calling = partner 
end)

net.Receive( "AOCRP.Comlink.Calling.Dial", function( len, ply )
    local partner = net.ReadEntity()

    AOCRP.Comlink:CallRequest(partner)
        
end)

net.Receive( "AOCRP.Comlink.Calling.ShowDial", function( len, ply )
    local partner = net.ReadEntity()

    AOCRP.Comlink:CallDial(partner)
end)

net.Receive( "AOCRP.Comlink.Calling.RemoveWindows", function( len, ply )

    if ValidPanel(AOCRP.Comlink.CALLDIAL) then AOCRP.Comlink.CALLDIAL:Remove() end
    if ValidPanel(AOCRP.Comlink.CALLREQUEST) then AOCRP.Comlink.CALLREQUEST:Remove() end
    if ValidPanel(AOCRP.Comlink.INACALL) then AOCRP.Comlink.INACALL:Remove() end
end)



















function AOCRP.Comlink:Ring(partner)

    if ValidPanel(self.CALLREQUEST) then self.CALLREQUEST:Remove() end

    self.CALLREQUEST = vgui.Create("DFrame")
    local sizW, sizH = AOCW(330),AOCH(110)
        self.CALLREQUEST:SetSize(sizW,sizH)
    self.CALLREQUEST:SetPos(ScrW()/2 - sizW/2,AOCH(150))
    self.CALLREQUEST:SetTitle("")
        self.CALLREQUEST:SetSizable(false)
    self.CALLREQUEST:SetDraggable(false)
    self.CALLREQUEST:ShowCloseButton(false)

    local start = 0
    local color = Color(109,0,0,200)
    local state = true

    local acceptKey = string.upper(input.GetKeyName( AOCRP_Binds:FindBindByID("callaccept") ))
    local denyKey = string.upper(input.GetKeyName( AOCRP_Binds:FindBindByID("calldeny") ))

    local seconds = AOCRP.Config.CallTimeOut

    function self.CALLREQUEST:Paint(w,h)

        if !IsValid(partner) then
            net.Start("AOCRP.Comlink.Calling.EndCallForcefully")
            net.SendToServer()
            self:Remove()
            return
        end

        if CurTime() > start then
            start = CurTime() + 1

            seconds = seconds - 1
            if state then
                color = Color(255,255,255)   
                state = false 
            else
                color = Color(139,139,139,200)
                state = true
            end
        end
        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))

        draw.RoundedBox(0,AOCW(5),AOCH(5),w-AOCW(10),2,color)
        draw.RoundedBox(0,AOCW(5),h-AOCH(7),w-AOCW(10),2,color)

        draw.DrawText("Eingehende Sprachanfrage",PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestInfo"], w/2, AOCH(10), Color(255, 255, 255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)

        draw.DrawText(string.upper(partner:Nick()),PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestName"], w/2, AOCH(35), Color(255, 255, 255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)


        draw.DrawText("[ ".. acceptKey.." ] Annehmen",PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestInfo"], AOCW(20), AOCH(70), Color(0, 255, 0),TEXT_ALIGN_LEFT)
        draw.DrawText("Ablehnen [ ".. denyKey.." ]",PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestInfo"], w-AOCW(20), AOCH(70), Color(255, 0, 0),TEXT_ALIGN_RIGHT)


        draw.DrawText("- "..seconds.. " -",PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestInfo"], w/2, AOCH(70), Color(255, 255, 255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)

    end

end


function AOCRP.Comlink:Active(partner)

    if ValidPanel(self.CALLREQUEST) then self.CALLREQUEST:Remove() end

    self.CALLREQUEST = vgui.Create("DFrame")
    local sizW, sizH = AOCW(330),AOCH(110)
        self.CALLREQUEST:SetSize(sizW,sizH)
    self.CALLREQUEST:SetPos(ScrW()/2 - sizW/2,AOCH(150))
    self.CALLREQUEST:SetTitle("")
        self.CALLREQUEST:SetSizable(false)
    self.CALLREQUEST:SetDraggable(false)
    self.CALLREQUEST:ShowCloseButton(false)

    local start = 0
    local color = Color(255,255,255,200)
    local state = true

    local acceptKey = string.upper(input.GetKeyName( AOCRP_Binds:FindBindByID("callaccept") ))
    local denyKey = string.upper(input.GetKeyName( AOCRP_Binds:FindBindByID("calldeny") ))

    local seconds = 0

    function self.CALLREQUEST:Paint(w,h)

        if !IsValid(partner) then
            net.Start("AOCRP.Comlink.Calling.EndCallForcefully")
            net.SendToServer()
            self:Remove()
            return
        end

        if CurTime() > start then
            start = CurTime() + 1
            seconds = seconds + 1
        end
        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))

        draw.RoundedBox(0,AOCW(5),AOCH(5),w-AOCW(10),2,color)
        draw.RoundedBox(0,AOCW(5),h-AOCH(7),w-AOCW(10),2,color)

        draw.DrawText("Verbunden mit",PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestInfo"], w/2, AOCH(10), Color(255, 255, 255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)

        draw.DrawText(string.upper(partner:Nick()),PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestName"], w/2, AOCH(35), Color(255, 255, 255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)


       -- draw.DrawText("[ ".. acceptKey.." ] Annehmen",PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestInfo"], AOCW(20), AOCH(70), Color(0, 255, 0),TEXT_ALIGN_LEFT)
        draw.DrawText("Auflegen [ ".. denyKey.." ]",PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestInfo"], w-AOCW(20), AOCH(70), Color(255, 0, 0),TEXT_ALIGN_RIGHT)


        if seconds < 60 then
            draw.DrawText("Gesprächsdauer: ".. seconds ..  "s",PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestInfo"], AOCW(20), AOCH(70), Color(255, 255, 255),TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER)
        else
            draw.DrawText("Gesprächsdauer: ".. math.Round(seconds/60) .. "m",PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestInfo"], AOCW(20), AOCH(70), Color(255, 255, 255),TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER)
        end
    end

end


function AOCRP.Comlink:Calling(partner)

    if ValidPanel(self.CALLREQUEST) then self.CALLREQUEST:Remove() end

    self.CALLREQUEST = vgui.Create("DFrame")
    local sizW, sizH = AOCW(330),AOCH(110)
        self.CALLREQUEST:SetSize(sizW,sizH)
    self.CALLREQUEST:SetPos(ScrW()/2 - sizW/2,AOCH(150))
    self.CALLREQUEST:SetTitle("")
        self.CALLREQUEST:SetSizable(false)
    self.CALLREQUEST:SetDraggable(false)
    self.CALLREQUEST:ShowCloseButton(false)

    local start = 0
    local color = Color(109,0,0,200)
    local state = true

    local acceptKey = string.upper(input.GetKeyName( AOCRP_Binds:FindBindByID("callaccept") ))
    local denyKey = string.upper(input.GetKeyName( AOCRP_Binds:FindBindByID("calldeny") ))

    local seconds = AOCRP.Config.CallTimeOut

    function self.CALLREQUEST:Paint(w,h)

        if !IsValid(partner) then
            net.Start("AOCRP.Comlink.Calling.EndCallForcefully")
            net.SendToServer()
            self:Remove()
            return
        end

        if CurTime() > start then
            start = CurTime() + 1

            seconds = seconds - 1
            if state then
                color = Color(255,255,255)   
                state = false 
            else
                color = Color(139,139,139,200)
                state = true
            end
        end
        draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))

        draw.RoundedBox(0,AOCW(5),AOCH(5),w-AOCW(10),2,color)
        draw.RoundedBox(0,AOCW(5),h-AOCH(7),w-AOCW(10),2,color)

        draw.DrawText("Du rufst an",PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestInfo"], w/2, AOCH(10), Color(255, 255, 255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)

        draw.DrawText(string.upper(partner:Nick()),PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestName"], w/2, AOCH(35), Color(255, 255, 255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)


        --draw.DrawText("[ ".. acceptKey.." ] Annehmen",PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestInfo"], AOCW(20), AOCH(70), Color(0, 255, 0),TEXT_ALIGN_LEFT)
        draw.DrawText("Abbrechen [ ".. denyKey.." ]",PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestInfo"], w-AOCW(20), AOCH(70), Color(255, 0, 0),TEXT_ALIGN_RIGHT)


        draw.DrawText("- "..seconds.. " -",PIXEL.UI.RegisteredFonts["AOCRP.Comlink.CallRequestInfo"], w/2, AOCH(70), Color(255, 255, 255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)

    end

end



concommand.Add( "aoc_comlink_sf", function( ply, cmd, args )
    
    local cid = args[1]


    if LocalPlayer():IsComlinkChannelMuted(tonumber(cid)) then
        LocalPlayer():ComlinkMuteChannel(tonumber(cid))
    end

    AOCRP_Comlink_F2 = tonumber(cid)
end )


concommand.Add( "aoc_comlink_tf", function( ply, cmd, args )
    
    local cid = args[1]

    if LocalPlayer():IsComlinkChannelMuted(tonumber(cid)) then
        LocalPlayer():ComlinkMuteChannel(tonumber(cid))
    end

    AOCRP_Comlink_F3 = tonumber(cid)
end )


--addons/wos-passiveevent-ageo/lua/wos/pes/core/sh_mod_mount.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--
























































































































































wOS = wOS or {}
wOS.PES = wOS.PES or {}
wOS.PES.Modules = wOS.PES.Modules or {}
wOS.PES.Modules.Data = wOS.PES.Modules.Data or {}

function wOS.PES.Modules:Autoloader()
	local _, folders = file.Find( "wos/pes/addons/*", "LUA")

    for _, folder in pairs( folders, true ) do

        local n_folder = "wos/pes/addons/" .. folder
        for __, source in pairs( file.Find( n_folder .. "/*", "LUA" ), true ) do   

            local realm = string.lower(string.Left(source, 3) )
            local ext = string.lower(string.Right(source, 3) )
            local lua =  n_folder .. "/" .. source

            if SERVER and realm == "sv_" then
                if ext == "wos" then
                    wOS.PES:ServerInclude( lua )
                else
                    include( lua )
                end
            elseif realm == "cl_" then
                if SERVER then
                    AddCSLuaFile( lua )
                else
                    include( lua )
                end
            elseif realm == "sh_" then
                if SERVER then
                    AddCSLuaFile( lua )
                end
                include( lua )
            end
            
        end

    end
end

function wOS.PES.Modules:RegisterAddon( name, varData )
    if not name then return end
    if not varData then return end
    self.Data[name] = varData
end

function wOS.PES.Modules:Get( mod )
    if not mod then return {} end
    if not wOS.PES.Modules.Data[mod] then return {} end

    return wOS.PES.Modules.Data[mod]
end

wOS.PES.Modules:Autoloader()

-- local function KevCISNPCFix( ent, entdata )
--     if not ent then return end
--     if not IsValid( ent.originalReference ) then return end
--     return ent.originalReference
-- end

-- hook.Add( "wOS.PES.PrePartialReadEntity", "wOS.PES.KevCISNPCDupeFixes", KevCISNPCFix )
-- hook.Add( "wOS.PES.PreReadEntity", "wOS.PES.KevCISNPCDupeFixes", KevCISNPCFix )

hook.Add( "wOS.PES.PostSpawnEntity", "wOS.PES.KevCISNPCDupeFixes", function( ent )
    if not ent then return end
    if not IsValid( ent.npc ) then return end
    return ent.npc
end )

if SERVER then
    hook.Add( "PreRegisterSENT", "wOS.PES.CISNPCSARETHEWORST", function( ent, class )
        if class != "seperatist_alliance_npc_base" and class != "seperatist_alliance_special_npc_base" then return end

        local init = ent.Initialize
        ent.Initialize = function( self )
            init( self )
            if not IsValid( self.npc ) then return end

            self.npc.OnEntityCopyTableFinish = function( npc, dat )
                if npc.WOS_StopCopy then return end
                dat.Class = npc.originalReference:GetClass()
                npc.WOS_StopCopy = true
                    dat.NPCSettings = duplicator.CopyEntTable( npc )
                    dat.NPCSettings.Angle = nil
                    dat.NPCSettings.Pos = nil
                npc.WOS_StopCopy = false
                dat.CurrentWeapon = npc:GetInternalVariable( "additionalequipment" )
            end
        end

        ent.PostEntityPaste = function( self, ply, ett, enttbl )
            if not IsValid( self.npc ) then return end
            
            if self.NPCSettings then
                duplicator.DoGeneric( self.npc, self.NPCSettings )
            end
            
            if not self.CurrentWeapon then return end
            self.npc:SetKeyValue( "additionalequipment", self.CurrentWeapon )
            self.npc:Give( self.CurrentWeapon )
        end
    end )
end
--addons/wos-passiveevent-ageo/lua/wos/css/config/sh_config.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.CombatSim = wOS.CombatSim or {}

-- wOS.CombatSim.Difficulties = {}
-- 
-- wOS.CombatSim.Difficulties[ 1 ] = { 
-- 	Name = "Practice",
-- 	Icon = "wos/halo/css/normal.png",
-- }
-- 
-- wOS.CombatSim.Difficulties[ 2 ] = { 
-- 	Name = "Normal",
-- 	Icon = "wos/halo/css/normal.png",
-- }
-- 
-- wOS.CombatSim.Difficulties[ 3 ] = { 
-- 	Name = "Heroic",
-- 	Icon = "wos/halo/css/heroic.png",
-- }
-- 
-- wOS.CombatSim.Difficulties[ 4 ] = { 
-- 	Name = "Legendary",
-- 	Icon = "wos/halo/css/legend.png",
-- }
-- 

wOS.CombatSim.FrameColor = Color( 0, 0, 0, 155 )
wOS.CombatSim.BackgroundColor = Color( 0, 0, 0, 200 )
wOS.CombatSim.TextColor = Color( 155, 155, 155, 255 )
--addons/wos-passiveevent-ageo/lua/wos/css/core/cl_admin_menu.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.CombatSim = wOS.CombatSim or {}
wOS.CombatSim.GameTypes = wOS.CombatSim.GameTypes or {}

local w,h = ScrW(), ScrH()
local blur = Material("pp/blurscreen")

local function DrawBlur(panel, amount)
	local x, y = panel:LocalToScreen(0, 0)
	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(blur)
	for i = 1, 3 do
		blur:SetFloat("$blur", (i / 3) * (amount or 6))
		blur:Recompute()
		render.UpdateScreenEffectTexture()
		surface.DrawTexturedRect(x * -1, y * -1, w, h)
	end
end

local createChallengeIcon = Material( "wos/css/wiltos.png", "unlitgeneric" )
local joinGameIcon = Material( "wos/css/wiltos.png", "unlitgeneric" )

function wOS.CombatSim:OpenSimulatorNameMenu(borderPoints, selectedHeight)
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end

	self.SimulatorMenu.SizeT = { w = w*0.25, h = h*0.2 }
	self.SimulatorMenu.Title = "SET SIMULATOR NAME"
	self.SimulatorMenu:Clear()

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	local nameField = vgui.Create("DPanel", self.SimulatorMenu)
	nameField:SetSize( rw*0.9, rh*0.2 )
	nameField:SetPos( rw*0.05, rh*0.25 )
	nameField.Paint = function( pan, ww, hh )
		draw.SimpleText("Simulator Name:", "wOS.CombatSim.LeaderFont", 0, hh * 0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end
	
	local nameEntryField = vgui.Create("DTextEntry", self.SimulatorMenu)
	nameEntryField:SetSize( rw*0.9, rh*0.15 )
	nameEntryField:SetPos( rw*0.05, rh*0.45 )
	nameEntryField:SetFont( "wOS.CombatSim.MediumFont" )
	nameEntryField:SetValue( istable(simulator) and simulator:GetSimulatorName() or "" )

	local saveButton = vgui.Create("DButton", self.SimulatorMenu)
	saveButton:SetSize( rw*0.8, rh*0.2 )
	saveButton:SetPos( rw*0.1, rh*0.7 )
	saveButton:SetFont( "wOS.CombatSim.LeaderFont" )
	saveButton:SetText( "Set Simulator Name" )
	saveButton.DoClick = function( pan )
		local name = nameEntryField:GetValue()
		
		net.Start("wOS.CombatSim.SetBorderPoints")
			net.WriteTable(borderPoints)
			net.WriteInt(selectedHeight, 32)
			net.WriteString(name)
		net.SendToServer()
	end
end

function wOS.CombatSim:OpenToolMenu( simulator )
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	if not simulator then
		local wep = LocalPlayer():GetActiveWeapon()
		if wep and wep:GetClass() == "wos_simulation_tool" then
			simulator = wep:GetSelectedSimulator()
		end
	end

	self.SimulatorMenu.SizeT = { w = w*0.66, h = h*0.33 }
	self.SimulatorMenu.Title = simulator:GetSimulatorName()
	self.SimulatorMenu:Clear()
	timer.Simple(0, function() self:AddExitButton() end)
	
	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	local innerframe = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	innerframe:SetSize( rw*0.98, rh*0.8 )
	innerframe:SetPos( rw*0.01, rh*0.15 )
	innerframe:SetPanelSize(rh * 0.7, rh * 0.7)
	innerframe:SetPanelSpacing(rh * 0.05)
	innerframe.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
	end

	local createChallengeButton = innerframe:CreatePanel("DButton")
	createChallengeButton:SetText("")
	createChallengeButton.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			surface.SetDrawColor(255, 255, 255, 255)
		else
			surface.SetDrawColor(63, 63, 63, 255)
		end
		
		surface.SetMaterial(createChallengeIcon)
		surface.DrawTexturedRect(0, 0, ww, hh)

		draw.SimpleText( "Add", "wOS.CombatSim.LeaderFont", ww/2, hh/2 - hh/12, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
		draw.SimpleText( "Simulation", "wOS.CombatSim.LeaderFont", ww/2, hh/2 + hh/12, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
	end
	createChallengeButton.DoClick = function( pan )
		self:OpenToolCreateSimulationMenu(simulator)
	end

	local editChallengesButton = innerframe:CreatePanel("DButton")
	editChallengesButton:SetText("")
	editChallengesButton.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			surface.SetDrawColor(255, 255, 255, 255)
		else
			surface.SetDrawColor(63, 63, 63, 255)
		end
		
		surface.SetMaterial(createChallengeIcon)
		surface.DrawTexturedRect(0, 0, ww, hh)

		draw.SimpleText( "Edit", "wOS.CombatSim.LeaderFont", ww/2, hh/2 - hh/12, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
		draw.SimpleText( "Simulation", "wOS.CombatSim.LeaderFont", ww/2, hh/2 + hh/12, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
	end
	editChallengesButton.DoClick = function( pan )
		net.Start( "wOS.CSS.GetEditableChallenges" )
		net.SendToServer()
	end

	local removeSimulatorButton = innerframe:CreatePanel("DButton")
	removeSimulatorButton:SetText("")
	removeSimulatorButton.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			surface.SetDrawColor(255, 255, 255, 255)
		else
			surface.SetDrawColor(63, 63, 63, 255)
		end
		
		surface.SetMaterial(createChallengeIcon)
		surface.DrawTexturedRect(0, 0, ww, hh)

		draw.SimpleText( "Remove", "wOS.CombatSim.LeaderFont", ww/2, hh/2 - hh/12, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
		draw.SimpleText( "Simulator", "wOS.CombatSim.LeaderFont", ww/2, hh/2 + hh/12, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
	end
	removeSimulatorButton.DoClick = function( pan )
		wOS.CombatSim:OpenRemoveSimulatorDerma(simulator)
	end
end

function wOS.CombatSim:OpenToolSettingsMenu( base_settings, settings )
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end

	self.SimulatorMenu.SizeT = { w = w*0.33, h = h*0.66 }
	self.SimulatorMenu.Title = "SETTINGS"
	self.SimulatorMenu:Clear()

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h

	local innerframe = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	innerframe.XScroll = false
	innerframe:SetSize( rw*0.95, rh*0.8 )
	innerframe:SetPos( rw*0.025, rh*0.1 )
	innerframe:SetPanelSize(rw * 0.85, rh * 0.1)
	innerframe:SetPanelSpacing(rw * 0.05)
	innerframe.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
	end

	innerframe.ObjectPanels = {}

	self:CreateSettingsList(innerframe, base_settings, settings, rw, rh)

	local saveButton = vgui.Create("DButton", self.SimulatorMenu)
	saveButton:SetSize( rw*0.6, rh*0.075 )
	saveButton:SetPos( rw*0.2, rh*0.9125 )
	saveButton:SetFont( "wOS.CombatSim.LeaderFont" )
	saveButton:SetText( "Save" )
	saveButton.DoClick = function( pan )
		local settings2 = {}
		for _, objectPanel in pairs(innerframe.ObjectPanels) do
			settings2[objectPanel.SettingName] = objectPanel.Value
		end
		local nMenu = wOS.PES:GetNodeMenu()
		if not nMenu then return end
		if not nMenu.menu then return end
		nMenu.menu:SaveGameSettings( settings2 )
		wOS.CombatSim:OpenMenu()
	end

	return self.SimulatorMenu
end

function wOS.CombatSim:OpenToolPreChallengeMenu( challenges )
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end

	self.SimulatorMenu.SizeT = { w = w*0.43, h = h*0.66 }
	self.SimulatorMenu.Title = "CHALLENGES"
	self.SimulatorMenu:Clear()

	timer.Simple( 0, function() self:AddExitButton( function() wOS.CombatSim:OpenToolMenu() end ) end )

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h

	local innerframe = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	innerframe.XScroll = false
	innerframe:SetSize( rw*0.95, rh*0.8 )
	innerframe:SetPos( rw*0.025, rh*0.1 )
	innerframe:SetPanelSize(rw * 0.85, rh * 0.1)
	innerframe:SetPanelSpacing(rw * 0.05)
	innerframe.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
	end

	innerframe.ObjectPanels = {}

	for name, data in pairs( challenges ) do
		local objectPanel = innerframe:CreatePanel("DPanel")
		objectPanel.Data = data
		objectPanel.Paint = function( pan, ww, hh )
			draw.RoundedBox( hh*0.1, 0, 0, ww, hh, wOS.CombatSim.FrameColor )
			DrawBlur( pan, 1 )

			draw.SimpleText(pan.Data.Name, "wOS.CombatSim.MediumFont", ww*0.01, hh*0.005, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			draw.SimpleText("MAX PLAYERS: " .. pan.Data.Settings[ "Maximum Players" ], "wOS.CombatSim.SmallFont",  ww*0.99, hh*0.005, white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)
			
			local word = wOS.PES.WrapText( pan.Data.Description, "wOS.CombatSim.DescFont", ww*0.8 )
			draw.DrawText( word, "wOS.CombatSim.DescFont", ww*0.01, hh*0.37, color_white, TEXT_ALIGN_LEFT ) 		
		end

		table.insert(innerframe.ObjectPanels, objectPanel)

		local ow, oh = objectPanel:GetSize()
		local button = vgui.Create("DButton", objectPanel)
		button:SetSize( ow*0.15, oh*0.45 )
		button:SetPos( ow*0.85, oh*0.55 )
		button.Data = data
		button:SetFont( "wOS.CombatSim.LeaderFont" )
		button:SetText( "Select" )
		button.DoClick = function(pan)
			wOS.CombatSim:OpenMenu()
			wOS.PES.RequestSimulationData(pan.Data.Name, function( simdata )
				wOS.CombatSim:OpenSimulationEditor( simdata )
			end )
		end
		
	end

	return self.SimulatorMenu
end

// Build editor menu
function wOS.CombatSim:OpenSimulationCreator(simulator)
	local nMenu = wOS.PES:GetNodeMenu()
    if IsValid(nMenu) then
		if nMenu.menu then
			if not nMenu.menu.CreationType or nMenu.menu.CreationType == WOS_PES.CREATOR.SIMULATION then 
				nMenu:Show()
				return
			end
		end
        nMenu:Remove()
    end

	local base = vgui.Create("DFrame")
	base:SetSize(ScrW(), ScrH())
	base:Center()
	base:MakePopup()
	base:SetDraggable(false)
	base:SetTitle("")
	base:ShowCloseButton(false)
	base.Paint = function(self, w, h)
		surface.SetDrawColor(35.5,35.5,35.5)
		surface.DrawRect(0,0, w, h)
	end

	local close = vgui.Create("DButton", base)
	close:SetSize(20,20)
	close:SetPos(ScrW()-20, 0)
	close:SetText("")
	close.Paint = function(self, w, h)
		local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

		surface.SetDrawColor(col)
		surface.DrawLine(0,0, w, h)
		surface.DrawLine(w,0, 0, h)
	end
	close.DoClick = function()
		net.Start("wOS.CombatSim.ResetTool")
		net.SendToServer()	
		hook.Call(  "wOS.PES.OnCreatorClose", nil, WOS_PES.CREATOR.SIMULATION )	
		base:Remove()  
	end

	local mini = vgui.Create("DButton", base)
	mini:SetSize(20,20)
	mini:SetPos(ScrW()-45, 0)
	mini:SetText("")
	mini.Paint = function(self, w, h)
		local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

		surface.SetDrawColor(col)
		surface.DrawLine(0,h/2, w, h/2)
	end
	mini.DoClick = function() base:Hide() end

	if IsValid(base.menu) then
		base.menu:Remove()
	end

	local menu = vgui.Create("WOS_CSS_NodeBG", base)
	menu:Dock(FILL)
	menu:DockMargin(0,0,0,0)
	base.menu = menu

	local start = menu:CreateStartNode()

	wOS.PES:SetNodeMenu( base )
	wOS.PES:SetActiveMenu( base )
end

function wOS.CombatSim:OpenSimulationEditor( simdata, dirty, imported )
	if IsValid( self.SimulatorMenu ) then wOS.CombatSim:OpenMenu() end
	local nMenu = wOS.PES:GetNodeMenu()
    if IsValid(nMenu) then
		if nMenu.menu then
			if not nMenu.menu.CreationType or nMenu.menu.CreationType == WOS_PES.CREATOR.SIMULATION then 
				nMenu:Show()
				return
			end
		end
        nMenu:Remove()
    end

	local event = simdata.Event or simdata
	local settings = simdata.Settings

	if imported and event then
		event.OldName = nil
	end

	local base = vgui.Create("DFrame")
	base:SetSize(ScrW(), ScrH())
	base:Center()
	base:MakePopup()
	base:SetDraggable(false)
	base:SetTitle("")
	base:ShowCloseButton(false)
	base.Paint = function(self, w, h)
		surface.SetDrawColor(35.5,35.5,35.5)
		surface.DrawRect(0,0, w, h)
	end

	local close = vgui.Create("DButton", base)
	close:SetSize(20,20)
	close:SetPos(ScrW()-20, 0)
	close:SetText("")
	close.Paint = function(self, w, h)
		local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

		surface.SetDrawColor(col)
		surface.DrawLine(0,0, w, h)
		surface.DrawLine(w,0, 0, h)
	end
	close.DoClick = function()
		net.Start("wOS.CombatSim.ResetTool")
		net.SendToServer()	
		hook.Call( "wOS.PES.OnCreatorClose", nil, WOS_PES.CREATOR.SIMULATION )	
		base:Remove()  
	end

	local mini = vgui.Create("DButton", base)
	mini:SetSize(20,20)
	mini:SetPos(ScrW()-45, 0)
	mini:SetText("")
	mini.Paint = function(self, w, h)
		local col = Color(255, 255, 255, (self.Hovered and 255) or 150)

		surface.SetDrawColor(col)
		surface.DrawLine(0,h/2, w, h/2)
	end
	mini.DoClick = function() base:Hide() end

	if IsValid(base.menu) then
		base.menu:Remove()
	end

	local menu = vgui.Create("WOS_CSS_NodeBG", base)
	menu:Dock(FILL)
	menu:DockMargin(0,0,0,0)
	menu.Importable = simdata.Importable
	base.menu = menu

	menu:SaveGameSettings( settings )

	menu.Name = event.Name
	menu.DirtyNodes = dirty
	menu.Imported = imported
	menu.Description = event.Description
	menu.Importable = simdata.Importable

	for index, node in pairs(event.Nodes) do
		
		local pNode
		if index == 1 then
			pNode = menu:CreateStartNode()
		else
			pNode = menu:AddNode()
			pNode.Type = node.Type
		end

		pNode:SetPos(node.Pos.x, node.Pos.y )
		
		if pNode.Type != node.Type then continue end
		pNode:SetVars(node._vars, dirty)
		pNode:SetDisableVars(node._toggles, dirty)
	end

	for index, node in pairs(event.Nodes) do
		if node.Triggers then
			for triggerName, panelTable in pairs(node.Triggers) do
				for _, otherID in pairs(panelTable) do
					local pnl, oPnl = menu.Nodes[index], menu.Nodes[otherID]
					menu:MakeLink(pnl, oPnl, triggerName)
				end
			end
		end
	end

	for _, node in pairs(menu.Nodes) do
		node:CreateLinks()
	end

	local delin = vgui.Create("DButton", base )
	delin:SetText("Delete Simulation")
	delin:SetPos( 20, 3.5 )
	delin:SetWide( 100 )
	delin.DoClick = function( p )
		menu:OpenEventDeleter()
    end 

	wOS.PES:SetNodeMenu( base )
	wOS.PES:SetActiveMenu( base )
end

function wOS.CombatSim:CleanupAdminMenu()
	local node = wOS.PES:GetNodeMenu()
	if IsValid( node ) then node:Remove() end
	
	local cur_pan = wOS.PES:GetActiveMenu()
	if IsValid( cur_pan ) then cur_pan:Remove() end
end

//OLD CSS STUFF

function wOS.CombatSim:OpenRemoveSimulatorDerma(simulator)
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	self.SimulatorMenu.SizeT = { w = w*0.3, h = h*0.3 }
	self.SimulatorMenu.Title = "REMOVE SIMULATOR"
	self.SimulatorMenu:Clear()

	timer.Simple( 0, function() self:AddExitButton() end )

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	local innerframe = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	innerframe:SetSize( rw*0.9, rh*0.75 )
	innerframe:SetPos( rw*0.05, rh*0.2 )
	innerframe:SetPanelSize(rh * 0.7, rh * 0.7)
	innerframe:SetPanelSpacing(rh * 0.05)
	innerframe.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
	end

	local removeButton = innerframe:CreatePanel("DButton")
	removeButton:SetText("")
	removeButton.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			surface.SetDrawColor(255, 255, 255, 255)
		else
			surface.SetDrawColor(63, 63, 63, 255)
		end
		
		surface.SetMaterial(createChallengeIcon)
		surface.DrawTexturedRect(0, 0, ww, hh)

		draw.SimpleText( "YES", "wOS.CombatSim.LeaderFont", ww/2, hh/2, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
	end
	removeButton.DoClick = function( pan )
		if self.SimulatorMenu.Clicked then return end

		self.SimulatorMenu.Clicked = true
		self.SimulatorMenu:ToggleClose()
		
		net.Start("wOS.CombatSim.RemoveSelectedSimulator")
		net.SendToServer()
	end
	
	local abortButton = innerframe:CreatePanel("DButton")
	abortButton:SetText("")
	abortButton.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			surface.SetDrawColor(255, 255, 255, 255)
		else
			surface.SetDrawColor(63, 63, 63, 255)
		end
		
		surface.SetMaterial(createChallengeIcon)
		surface.DrawTexturedRect(0, 0, ww, hh)

		draw.SimpleText( "NO", "wOS.CombatSim.LeaderFont", ww/2, hh/2, ( pan:IsHovered() and color_white ) or wOS.CombatSim.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 0 )
	end
	abortButton.DoClick = function( pan )
		wOS.CombatSim:OpenToolMenu()
	end
end

function wOS.CombatSim:OpenToolCreateSimulationMenu()
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	self.SimulatorMenu.SizeT = { w = w*0.25, h = h*0.15 }
	self.SimulatorMenu.Title = "ADD SIMULATION"
	self.SimulatorMenu:Clear()

	timer.Simple( 0, function() self:AddExitButton( function() wOS.CombatSim:OpenToolMenu() end ) end )

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	-- local nameField = vgui.Create("DPanel", self.SimulatorMenu)
	-- nameField:SetSize( rw*0.4, rh*0.1 )
	-- nameField:SetPos( rw*0.05, rh*0.2 )
	-- nameField.Paint = function( pan, ww, hh )
	-- 	draw.SimpleText("Challenge Name:", "wOS.CombatSim.LeaderFont", 0, hh * 0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	-- end
	
	-- local nameEntryField = vgui.Create("DTextEntry", self.SimulatorMenu)
	-- nameEntryField:SetSize( rw*0.4, rh*0.1 )
	-- nameEntryField:SetPos( rw*0.05, rh*0.3 )
	-- nameEntryField:SetFont( "wOS.CombatSim.MediumFont" )

	local newbutt = vgui.Create("DButton", self.SimulatorMenu)
	newbutt:SetSize( rw*0.8, rh*0.22 )
	newbutt:SetPos( rw*0.1, rh*0.35 )
	newbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	newbutt:SetText( "Create New" )
	newbutt.DoClick = function( pan )
		net.Start( "wOS.CSS.CreateNewSimulation")
		net.SendToServer()		
		self.SimulatorMenu:ToggleClose()
	end

	local impbutt = vgui.Create("DButton", self.SimulatorMenu)
	impbutt:SetSize( rw*0.8, rh*0.22 )
	impbutt:SetPos( rw*0.1, rh*0.67 )
	impbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	impbutt:SetText( "Import From Existing" )
	impbutt.DoClick = function( pan )
		wOS.CombatSim:OpenToolImportSimulationMenu()
	end
end

function wOS.CombatSim:OpenToolImportSimulationMenu()
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	self.SimulatorMenu.SizeT = { w = w*0.25, h = h*0.2 }
	self.SimulatorMenu.Title = "IMPORT SIMULATION"
	self.SimulatorMenu:Clear()

	timer.Simple( 0, function() self:AddExitButton( function() wOS.CombatSim:OpenToolCreateSimulationMenu() end ) end )

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	-- local nameField = vgui.Create("DPanel", self.SimulatorMenu)
	-- nameField:SetSize( rw*0.4, rh*0.1 )
	-- nameField:SetPos( rw*0.05, rh*0.2 )
	-- nameField.Paint = function( pan, ww, hh )
	-- 	draw.SimpleText("Challenge Name:", "wOS.CombatSim.LeaderFont", 0, hh * 0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	-- end
	
	-- local nameEntryField = vgui.Create("DTextEntry", self.SimulatorMenu)
	-- nameEntryField:SetSize( rw*0.4, rh*0.1 )
	-- nameEntryField:SetPos( rw*0.05, rh*0.3 )
	-- nameEntryField:SetFont( "wOS.CombatSim.MediumFont" )

	local evbutt = vgui.Create("DButton", self.SimulatorMenu)
	evbutt:SetSize( rw*0.8, rh*0.15 )
	evbutt:SetPos( rw*0.1, rh*0.26 )
	evbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	evbutt:SetText( "Import From Event" )
	evbutt.DoClick = function( pan )
		wOS.PES.GetImportableEvents( function( events )
			wOS.CombatSim:OpenToolPreImportMenu( events, false )
		end )
	end

	local newbutt = vgui.Create("DButton", self.SimulatorMenu)
	newbutt:SetSize( rw*0.8, rh*0.15 )
	newbutt:SetPos( rw*0.1, rh*0.5 )
	newbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	newbutt:SetText( "Import From Simulator" )
	newbutt.DoClick = function( pan )
		wOS.PES.GetImportableSimulations( function( events )
			wOS.CombatSim:OpenToolPreImportMenu( events, true, true )
		end )
	end

	local impbutt = vgui.Create("DButton", self.SimulatorMenu)
	impbutt:SetSize( rw*0.8, rh*0.15 )
	impbutt:SetPos( rw*0.1, rh*0.74 )
	impbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	impbutt:SetText( "Import From URL" )
	impbutt.DoClick = function( pan )
		wOS.CombatSim:OpenToolURLImportMenu()
	end

end

function wOS.CombatSim:OpenToolURLImportMenu()
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end
	
	self.SimulatorMenu.SizeT = { w = w*0.25, h = h*0.4 }
	self.SimulatorMenu.Title = "IMPORT FROM URL"
	self.SimulatorMenu:Clear()

	timer.Simple( 0, function() self:AddExitButton( function() wOS.CombatSim:OpenToolImportSimulationMenu() end ) end )

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h
	
	-- local nameField = vgui.Create("DPanel", self.SimulatorMenu)
	-- nameField:SetSize( rw*0.4, rh*0.1 )
	-- nameField:SetPos( rw*0.05, rh*0.2 )
	-- nameField.Paint = function( pan, ww, hh )
	-- 	draw.SimpleText("Challenge Name:", "wOS.CombatSim.LeaderFont", 0, hh * 0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	-- end
	
	-- local nameEntryField = vgui.Create("DTextEntry", self.SimulatorMenu)
	-- nameEntryField:SetSize( rw*0.4, rh*0.1 )
	-- nameEntryField:SetPos( rw*0.05, rh*0.3 )
	-- nameEntryField:SetFont( "wOS.CombatSim.MediumFont" )

	local evbutt = vgui.Create("DPanel", self.SimulatorMenu)
	evbutt:SetSize( rw*0.8, rh*0.75 )
	evbutt:SetPos( rw*0.1, rh*0.13 )
	evbutt.Paint = function( pan, ww, hh )
		local text = "Input a URL below that leads DIRECTLY to the exported event text\n\n----------WARNING---------- \nVERIFY THAT ALL SOURCES ARE COMPLETELY TRUSTED BEFORE IMPORTING AN EVENT!"
		text = wOS.PES.WrapText( text, "wOS.CombatSim.LeaderFont", ww*0.95 )
		draw.DrawText(text, "wOS.CombatSim.LeaderFont", ww/2, 0, color_white, TEXT_ALIGN_CENTER )
	end

	local newbutt = vgui.Create("DTextEntry", self.SimulatorMenu)
	newbutt:SetSize( rw*0.8, rh*0.075 )
	newbutt:SetPos( rw*0.1, rh*0.8 )
	newbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	newbutt:SetText( "INPUT URL HERE" )

	local impbutt = vgui.Create("DButton", self.SimulatorMenu)
	impbutt:SetSize( rw*0.8, rh*0.075 )
	impbutt:SetPos( rw*0.1, rh*0.9 )
	impbutt:SetFont( "wOS.CombatSim.LeaderFont" )
	impbutt:SetText( "IMPORT" )
	impbutt.DoClick = function( pan )
		local text = newbutt:GetText()
		if #text < 1 then return end
		wOS.PES.RequestURLImport(text, function( data ) 
			wOS.CombatSim:OpenSimulationImported( data )
		end )
	end

end

function wOS.CombatSim:OpenSimulationImported( simdata )
	local sim_struct = {}

	if not simdata.Event then
		if simdata.Nodes then
			sim_struct.Event = table.Copy( simdata )
		end
	else
		sim_struct = simdata
	end

	wOS.CombatSim:OpenSimulationEditor( sim_struct, true ) //Second argument is dirty which is always true for imports
end

function wOS.CombatSim:CreateSettingsList(innerframe, customSettings, settings, rw, rh)
	for name, setting in pairs(customSettings) do
		local objectPanel = innerframe:CreatePanel("DPanel")
		objectPanel.Paint = function( pan, ww, hh )
			local background = {
				{ x = 0           , y = hh*0.05 },
				{ x = 0  + hh*0.05, y = 0       },
				{ x = ww - hh*0.05, y = 0       },
				{ x = ww          , y = hh*0.05 },
				{ x = ww          , y = hh*0.95 },
				{ x = ww - hh*0.05, y = hh      },
				{ x = 0  + hh*0.05, y = hh      },
				{ x = 0           , y = hh*0.95 },		
			}
			draw.NoTexture()
			surface.SetDrawColor( wOS.CombatSim.FrameColor )
			surface.DrawPoly( background )		
			DrawBlur( pan, 1 )

			draw.SimpleText(name, "wOS.CombatSim.MediumFont", rw*0.01, rh*0.005, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		end

		table.insert(innerframe.ObjectPanels, objectPanel)

		local settingType = setting
		local minCount
		local maxCount
		local values = {}
		local default

		if istable(setting) then
			settingType = setting.Type
			minCount = setting.MinCount
			maxCount = setting.MaxCount
			values = setting.Values
			default = setting.Default
			if isfunction(values) then
				values = values()
			end
		end

		objectPanel.SettingName = name
		local value = settings[name]

		if settingType == WOS_CSS.CONFIG.BOOL then
			objectPanel.Value = value
			if objectPanel.Value == nil then
				objectPanel.Value = default or false
			end

			local button = vgui.Create("DButton", objectPanel)
			button:SetSize( rw*0.3, rh*0.05 )
			button:SetPos( rw*0.55, rh*0.05 )
			button:SetFont( "wOS.CombatSim.LeaderFont" )
			button:SetText( objectPanel.Value and "Yes" or "No" )
			button.DoClick = function(pan)
				objectPanel.Value = not objectPanel.Value
				pan:SetText( objectPanel.Value and "Yes" or "No" )
			end
		elseif settingType == WOS_CSS.CONFIG.NUMBER then
			objectPanel.Value = value or default or 0

			local wang = vgui.Create("DNumberWang", objectPanel)
			wang:SetSize( rw*0.3, rh*0.05 )
			wang:SetPos( rw*0.55, rh*0.05 )
			wang:SetFont( "wOS.CombatSim.LeaderFont" )
			wang:SetMin( minCount or 0 )
			wang:SetMax( maxCount or math.huge )
			wang:SetValue( objectPanel.Value )
			wang.Think = function( pan )
				objectPanel.Value = pan:GetValue()
			end
		elseif settingType == WOS_CSS.CONFIG.NSLIDER then
			objectPanel.Value = value or default or 0

			local panel = vgui.Create("DPanel", objectPanel)
			panel:SetSize( rw*0.3, rh*0.05 )
			panel:SetPos( rw*0.55, rh*0.05 )

			local slider = vgui.Create("DNumSlider", objectPanel)
			slider:SetSize( rw*0.45, rh*0.05 )
			slider:SetPos( rw*0.4, rh*0.05 )
			slider:SetMin( minCount or 0)
			slider:SetMax( maxCount or 10)
			slider:SetDecimals(0)
			slider:SetValue( objectPanel.Value )
			slider.Think = function( pan )
				pan:SetValue(math.Round(pan:GetValue()))
				objectPanel.Value = pan:GetValue()
			end
		elseif settingType == WOS_CSS.CONFIG.NSLIDERTOGGLE then
			if isbool( value ) && value == false then
				objectPanel.Value = false
			else
				objectPanel.Value = value or default or false
			end

			local panel = vgui.Create("DPanel", objectPanel)
			panel:SetSize( rw*0.3, rh*0.05 )
			panel:SetPos( rw*0.55, rh*0.05 )

			local slider = vgui.Create("DNumSlider", objectPanel)
			slider:SetSize( rw*0.45, rh*0.05 )
			slider:SetPos( rw*0.4, rh*0.05 )
			slider:SetMin( minCount or 0)
			slider:SetMax( maxCount or 10)
			slider:SetDecimals(0)

			local checkBox = vgui.Create("DCheckBox", objectPanel)
			checkBox:SetSize( rh*0.05, rh*0.05 )
			checkBox:SetPos( rw*0.55 - rh*0.1, rh*0.05 )

			if isbool(objectPanel.Value) and objectPanel.Value == false then
				checkBox:SetChecked(false)
				slider:SetValue( minCount )
				slider:SetMouseInputEnabled(false)
			else
				checkBox:SetChecked(true)
				slider:SetValue( objectPanel.Value )
			end
			
			function panel:Paint(ww, hh)
				if checkBox:GetChecked() then
					draw.RoundedBox(0, 0, 0, ww, hh, Color(255, 255, 255, 255))
				else
					draw.RoundedBox(0, 0, 0, ww, hh, Color(127, 127, 127, 127))
				end
			end
			
			slider.Think = function( pan )
				if checkBox:GetChecked() then
					pan:SetValue(math.Round(pan:GetValue()))
					objectPanel.Value = pan:GetValue()
					pan:SetMouseInputEnabled(true)
				else
					objectPanel.Value = false
					pan:SetMouseInputEnabled(false)
				end
			end
		elseif settingType == WOS_CSS.CONFIG.STRING then
			objectPanel.Value = value or default or ""

			local entry = vgui.Create("DTextEntry", objectPanel)
			entry:SetSize( rw*0.6, rh*0.05 )
			entry:SetPos( rw*0.25, rh*0.05 )
			entry:SetFont( "wOS.CombatSim.SmallFont" )
			entry:SetValue( objectPanel.Value )
			entry.Think = function( pan )
				objectPanel.Value = pan:GetValue()
			end
		elseif settingType == WOS_CSS.CONFIG.SDROPDOWN then
			objectPanel.Value = value or default or ""

			local comboBox = vgui.Create("DComboBox", objectPanel)
			comboBox:SetSize( rw*0.3, rh*0.05 )
			comboBox:SetPos( rw*0.55, rh*0.05 )
			comboBox:SetFont( "wOS.CombatSim.LeaderFont" )
			comboBox:SetValue( objectPanel.Value )
			for _, choice in pairs(values) do
				comboBox:AddChoice(choice)
			end
			comboBox.OnSelect = function( pan, index, value )
				objectPanel.Value = value
			end
		elseif settingType == WOS_CSS.CONFIG.COLOR then
			-- TODO: Implement Color Selector UI (Problem: Height)
		elseif settingType == WOS_CSS.CONFIG.MTABLE then
			objectPanel.Value = value or default or {}

			local listView = vgui.Create("DListView", objectPanel)
			listView:SetSize( rw*0.45, rh*0.1 )
			listView:SetPos( rw*0.4, 0 )
			listView:SetHeaderHeight(rh*0.02)
			listView:SetDataHeight(rh * 0.02)
			listView:AddColumn("Weapons")
			listView:SetMultiSelect(true)
			for _, weapon in pairs(weapons.GetList()) do
				if weapon.Spawnable then
					local line = listView:AddLine(weapon.ClassName)
					line:SetSelected(table.HasValue(objectPanel.Value, weapon.ClassName))
				end
			end
			function listView:OnRowRightClick(index, line)
                line:SetSelected(false)

				table.RemoveByValue(objectPanel.Value, line:GetValue(1))
			end
			function listView:OnRowSelected(index, line)
				line:SetSelected(true)

				table.insert(objectPanel.Value, line:GetValue(1))
				
				for k, line in pairs(self:GetLines()) do
					line:SetSelected(table.HasValue(objectPanel.Value, line:GetValue(1)))
				end
			end
		end
	end
end


function wOS.CombatSim:OpenToolPreImportMenu( events, is_sim, imported )
	if not IsValid(self.SimulatorMenu) then self:OpenMenu() end

	self.SimulatorMenu.SizeT = { w = w*0.43, h = h*0.66 }
	self.SimulatorMenu.Title = "IMPORT SELECTION"
	self.SimulatorMenu:Clear()

	timer.Simple( 0, function() self:AddExitButton( function() wOS.CombatSim:OpenToolImportSimulationMenu() end ) end )

	local rw, rh = self.SimulatorMenu.SizeT.w, self.SimulatorMenu.SizeT.h

	local innerframe = vgui.Create( "WOS_CSS_ScrollPanel", self.SimulatorMenu )
	innerframe.XScroll = false
	innerframe:SetSize( rw*0.95, rh*0.8 )
	innerframe:SetPos( rw*0.025, rh*0.1 )
	innerframe:SetPanelSize(rw * 0.85, rh * 0.1)
	innerframe:SetPanelSpacing(rw * 0.05)
	innerframe.Paint = function( pan, ww, hh )
		local background = {
			{ x = 0           , y = hh*0.05 },
			{ x = 0  + hh*0.05, y = 0       },
			{ x = ww - hh*0.05, y = 0       },
			{ x = ww          , y = hh*0.05 },
			{ x = ww          , y = hh*0.95 },
			{ x = ww - hh*0.05, y = hh      },
			{ x = 0  + hh*0.05, y = hh      },
			{ x = 0           , y = hh*0.95 },		
		}
		draw.NoTexture()
		surface.SetDrawColor( wOS.CombatSim.BackgroundColor )
		surface.DrawPoly( background )		
		DrawBlur( pan, 1 )
	end

	innerframe.ObjectPanels = {}

	for _, data in pairs( events ) do
		local objectPanel = innerframe:CreatePanel("DPanel")
		objectPanel.Data = data
		objectPanel.Paint = function( pan, ww, hh )
			draw.RoundedBox( hh*0.1, 0, 0, ww, hh, wOS.CombatSim.FrameColor )
			DrawBlur( pan, 1 )

			draw.SimpleText(pan.Data.Name, "wOS.CombatSim.MediumFont", ww*0.01, hh*0.005, white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			
			if pan.Data.Simulator then
				draw.SimpleText( pan.Data.Simulator, "wOS.CombatSim.SmallFont",  ww*0.99, hh*0.005, white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)
			end

			local word = wOS.PES.WrapText( pan.Data.Description, "wOS.CombatSim.DescFont", ww*0.8 )
			draw.DrawText( word, "wOS.CombatSim.DescFont", ww*0.01, hh*0.37, color_white, TEXT_ALIGN_LEFT ) 		
		
		end

		table.insert(innerframe.ObjectPanels, objectPanel)

		local ow, oh = objectPanel:GetSize()
		local button = vgui.Create("DButton", objectPanel)
		button:SetSize( ow*0.15, oh*0.45 )
		button:SetPos( ow*0.85, oh*0.55 )
		button.Data = data
		button:SetFont( "wOS.CombatSim.LeaderFont" )
		button:SetText( "Select" )
		button.DoClick = function(pan)
			wOS.CombatSim:OpenMenu()
			if is_sim then
				wOS.PES.RequestSimulationData(pan.Data.Name, function( simdata )
					wOS.CombatSim:OpenSimulationEditor( simdata, true, imported )
				end, pan.Data.ID )
			else
				wOS.PES.RequestEventData(pan.Data.Name, function( simdata )
					wOS.CombatSim:OpenSimulationEditor( simdata, true, imported )
				end )
			end
		end
		
	end

	return self.SimulatorMenu
end






















local white = Color(255, 255, 255)
local green = Color(0, 255, 0)
local cyan = Color(0, 255, 255)

local function DrawBorders(points, height, color)
	local prev = nil
	local prevtop = nil
	local first = nil
	local firsttop = nil

	for _, vec in pairs(points) do
		if not first then first = vec end

		local top = Vector(vec.x, vec.y, first.z + height)
		vec.z = first.z
		if not firsttop then firsttop = top end

		render.DrawLine(vec, top, color, false)

		if prev then
			render.DrawLine(vec, prev, color, false)
		end
		
		if prevtop then
			render.DrawLine(top, prevtop, color, false)
		end

		prevtop = top
		prev = vec
	end

	if prev and first then 
		render.DrawLine(prev, first, color, false)
	end
	if prevtop and firsttop then
		render.DrawLine(prevtop, firsttop, color, false)
	end
end

local function DrawPoints(points)
	local ply = LocalPlayer()
	local plyPos = ply:GetPos()
	
	local dx = ply:GetUp()
	local dy = ply:GetRight()

	local closest
	local disT = math.huge
	local hPos = ply:GetEyeTrace().HitPos
	for i, point in pairs(points or {}) do
		local dis = point.Position:Distance(hPos)
		if dis < disT then
			closest = i
			disT = dis
		end
	end

	local angle = dx:AngleEx(dx:Cross(-dy))
	angle:RotateAroundAxis(ply:GetForward(), 90)

	for i, point in pairs(points or {}) do
		local pos = point.Position
		local name = point.Name

		local textPos = pos + Vector(0, 0, 100)

		local color = white
		if i == closest then
			color = green
		end

		render.DrawLine(pos, textPos, color, false)

		cam.Start3D2D(textPos, angle, 1)
			draw.SimpleText(name or "Missing", "DermaDefault", 0, 0, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
		cam.End3D2D()   
	end
end

hook.Add( "PostDrawOpaqueRenderables", "wOS.CombatSim.ToolVisualization", function()
	local ply = LocalPlayer()

	local weapon = ply:GetActiveWeapon()
	if not (IsValid(weapon) and weapon:GetClass() == "wos_simulation_tool") then return end
	
	local simulator = weapon:GetSelectedSimulator()
	if simulator == weapon then return end
	
	if IsValid(simulator) then
		-- Draw Current Operation Overlay
		local mode = weapon:GetToolMode()
		local step = weapon:GetToolStep()

		if mode == WOS_CSS.MODE.AREASELECT then
			local corners = table.Copy(weapon.SelectedBorderPoints)
			local height = weapon.SelectedHeight
			
			if step == WOS_CSS.AREASELECT.BORDER then
				table.insert(corners, ply:GetEyeTrace().HitPos)
			elseif step == WOS_CSS.AREASELECT.HEIGHT then
				height = ply:GetEyeTrace().HitPos.z - corners[1].z
				DrawBorders(corners, height, green)
			end
			
			DrawBorders(corners, weapon.SelectedHeight, white)
		else
			local borderPointCount = simulator:GetBorderPointCount()

			if borderPointCount and borderPointCount > 0 then
				local corners = {}
				for i=1, borderPointCount do
					local v = simulator:GetNW2Vector("BorderPoint" .. i)
					table.insert(corners, v)
				end

				local inside
				if mode == WOS_CSS.MODE.POINTSELECT then
					inside = simulator:CheckInBorders(ply:GetEyeTrace().HitPos + Vector(0, 0, 10)) -- Offset because the floor isn't 100% inside.
				else
					inside = simulator:CheckInBorders(EyePos())
				end

				DrawBorders(corners, simulator:GetBorderHeight(), inside and green or cyan)
			end
		end
	end
	

end)

hook.Add("PreDrawHalos", "wOS.CombatSim.PreDrawHalos", function()
	local ply = LocalPlayer()

	local weapon = ply:GetActiveWeapon()
	if not (IsValid(weapon) and weapon:GetClass() == "wos_simulation_tool") then return end

	local simulator = weapon:GetSelectedSimulator()
	if simulator == weapon then return end
	
	if IsValid(simulator) then
		halo.Add({simulator}, cyan, 5)
	end
end)
--addons/arccw_weapons/lua/weapons/aocrp_dc15se_2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "REP"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "ZP-1"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc15s.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.NoHideLeftHandInCustomization = true
SWEP.HideViewmodel = true

SWEP.ViewModel = "models/servius/starwars/c_dc15s.mdl"
SWEP.WorldModel = "models/servius/starwars/w_dc15s.mdl"
SWEP.ViewModelFOV = 50
SWEP.WorldModelOffset = {
    pos = Vector(-9, 3.5, -4.5),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
}

-- Damage & Tracer
SWEP.Damage = 30
SWEP.RangeMin = 500
SWEP.DamageMin = 20
SWEP.Range = 1344
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.67
SWEP.RecoilSide = 0.34
SWEP.RecoilRise = 0.53
SWEP.Delay = 60 / 325

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5 
SWEP.HipDispersion = 490
SWEP.MoveDispersion = 60

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "weapons/bf3/dc15a.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-2.3, 0.19, .56),
    Ang = Angle(0, 0.4, 1.2),
     Magnification = 1.3,
     SwitchToSound = "armasclasicas/wpn_cis_medequip.wav",
     ViewModelFOV = 55,
}


SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1

SWEP.ActivePos = Vector(0, 2, 0.5)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, 0)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(10, -5, 1)
SWEP.CustomizeAng = Angle(15, 40, 30)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.Attachments = {
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    {
        PrintName = "Sight", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.17, -1.06, 0.1),
            vang = Angle(90, 0, -90),
        },
    },   
    {
        PrintName = "Grip",
        DefaultAttName = "None",
        Slot = "foregrip",
        Bone = "DC15",
        Offset = {
            vpos = Vector(-0.101, 2.378, 6.164),
            vang = Angle(90, 0, -90),
        },
        SlideAmount = {
        vmin = Vector(-0.2, 0, 5.100),
        vmax = Vector(-0.2, 0, 9),
        },          
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "DC15", 
        Offset = {
            vpos = Vector(0.8, -0.5, 10),
            vang = Angle(90, 0, 0),
        },
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC15",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0.9, -0.7, 5.7),
            vang = Angle(90, 0, -90),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC15",
        Offset = {
            vpos = Vector(0.8, -0.2, -5),
            vang = Angle(90, 0, -90),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = false,
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.4,
        SoundTable = {
            {
                s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3",
                p = 100, 
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "dc15s_1", t = 1.68 / 60},
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_manualcooling_var_02.mp3", t = 0.1},
        },
    },

sound.Add({
    name =          "dc15s_1",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armasclasicas/wpn_empire_medreload.wav"
    }),

}

--addons/arccw_weapons/lua/weapons/aocrp_flamethrower.lua:
AddCSLuaFile()

SWEP.Base = "arccw_base"

SWEP.PrintName				= "Flammenwerfer"
SWEP.Category 				= "AOCRP - Eingestellte Waffen"
SWEP.Trivia_Class 			= "Flamethrower"
SWEP.Trivia_Desc 			= "The D-72w Oppressor flame projector was a flamethrower used by Incinerator troopers part of Moff Gideon's Imperial remnant."
SWEP.Author				= "Meeks & Venator"
SWEP.Purpose				= ""

SWEP.Spawnable				= true
SWEP.UseHands				= true
SWEP.DrawAmmo				= true

SWEP.ViewModel				= "models/ven/sw_battlefront/weapons/bf2017/v_e11_flame.mdl"
SWEP.WorldModel				= "models/models/weapon/ven/custom/smg/ggn/flame/imperial_incinerator_world.mdl"
SWEP.HideViewmodel = true

SWEP.IconOverride = "materials/entities/imperial_incinerator.png"


SWEP.ViewModelFOV			= 75
SWEP.Slot				= 4
SWEP.SlotPos				= 5

SWEP.ChamberSize 			= 0
SWEP.Primary.ClipSize			= 100
SWEP.Primary.DefaultClip		= 100
SWEP.ExtendedClipSize			= 600
SWEP.Primary.Automatic			= true
SWEP.Primary.Ammo			= "ar2"
SWEP.Secondary.ClipSize			= -1
SWEP.Secondary.DefaultClip		= -1
SWEP.Secondary.Automatic		= false
SWEP.Secondary.Ammo			= "none"
SWEP.FireLoopSound			= "nil"
SWEP.LastShoot				= nil
SWEP.IsShooting				= false
SWEP.Reloading				= false


SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "ar2"
SWEP.ActivePos = Vector(3, -5, 0)
SWEP.ActiveAng = Angle(-5, -4, 5)

SWEP.CustomizePos = Vector(9.824, 0, -4.897)
SWEP.CustomizeAng = Angle(12.149, 10.547, 0)


SWEP.DefaultElements = {"flamethrower"}

SWEP.AttachmentElements = {
    ["flamethrower"] = {
        VMElements = {
            {
                Model = "models/models/weapon/ven/custom/smg/ggn/flame/imperial_incinerator.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.05, 1.05, 1.05),
                Offset = {
                    pos = Vector(7.791, 3.635, -1.558),
                    ang = Angle(-5.844, -113.377, -176.495)
                }
            }
        }
	},
}

WMOverride = "models/models/weapon/ven/custom/smg/ggn/flame/imperial_incinerator_world.mdl"

SWEP.Attachments = {
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "ValveBiped.Bip01_R_Hand",
        Offset = {
            vpos = Vector(12, 5.25, -4.8),
            vang = Angle(0, -22, 0),
            wpos = Vector(22, 3.25, -8.55),
            wang = Angle(-10, -0.556, 175)
        },
		CorrectiveAng = Angle(180, 0, 0),			
    },
    {
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        Bone = "ValveBiped.Bip01_R_Hand",
        Offset = {
            vpos = Vector(10, 6, -3.55),
            vang = Angle(-1, -20, 190),
            wpos = Vector(14.5, 2.5, -7.55),
            wang = Angle(-10, -0.556, 175)
        },
		CorrectiveAng = Angle(180, 0, 0),			
    },
}

SWEP.Firemodes = {
    {
        PrintName = "BRENNSTOFF",
        Mode = 1,
    },
    {
        Mode = 0
    }
}


if CLIENT then
	game.AddParticles( 'particles/alien_isolation.pcf' )
end

if SERVER then
	util.AddNetworkString( 'AI_FLAMETHROWER_SHOOT' )
else
	net.Receive( 'AI_FLAMETHROWER_SHOOT', function()
		local self = net.ReadEntity()
		self.LastShoot = CurTime() + 0.15
	end )
end


function SWEP:Initialize()
	self.FireLoopSound = CreateSound( self, 'weapons/flamethrower_loop.wav' )
	self.NextAllowedFire = CurTime()
	timer.Simple( 0, function() if !IsValid( self ) then return end self:SetMoveType( MOVETYPE_NONE ) end )
end

function SWEP:Reload( i )
	if self.Owner:GetAmmoCount( 'ar2' ) <= 0 then return end -- no ammo to reload!
	if self:Clip1() >= self.Primary.ClipSize then return end -- we're already full!
	if self.Reloading then return end
	if self.FireLoopSound then self.FireLoopSound:FadeOut( 0.5 ) timer.Simple( 0.5, function() self.FireLoopSound:Stop() end ) end
	self:SendWeaponAnim( ACT_VM_RELOAD )
	self.Reloading = true
	self:DefaultReload( self.Primary.ClipSize )
	timer.Simple( 3.5, function() if !IsValid( self ) then return end self.Reloading = false end )
end

function SWEP:Think()
	if self.LastShoot and self.LastShoot > CurTime() and CLIENT then
		local dlight = DynamicLight( LocalPlayer():EntIndex() )
		if ( dlight ) then
			dlight.pos = self.Owner:GetShootPos() + self.Owner:EyeAngles():Forward() * 40 + self.Owner:EyeAngles():Right() * 4 - self.Owner:EyeAngles():Up() * 5
			dlight.r = 255
			dlight.g = 200
			dlight.b = 0
			dlight.brightness = 2
			dlight.Decay = 2000
			dlight.Size = 800
			dlight.DieTime = CurTime() + 0.6
		end
	end
	
	if self.LastShoot and self.LastShoot > CurTime() and self.IsShooting then
		if SERVER then net.Start( 'AI_FLAMETHROWER_SHOOT' ) net.WriteEntity( self ) net.Send( self.Owner ) end
		if SERVER then
			local tr = {}
			tr.start = self.Owner:GetShootPos()
			tr.endpos = self.Owner:GetShootPos() + ( self.Owner:GetAimVector() * 200 )
			tr.filter = self.Owner
			tr.mins = Vector( -10, -10, -10 )
			tr.maxs = Vector( 10, 10, 10 )
			tr.mask = MASK_SHOT_HULL
			local _tr = util.TraceHull( tr )
			local v = _tr.Entity
			if IsValid( v ) then 
				if v:IsPlayer() and v != self.Owner or v:IsNPC() or v:IsNextBot() or v:GetClass() == 'prop_physics' or v:GetClass() == 'prop_ragdoll' then
                    if v:IsNextBot() then
                        v:TakeDamage( 25, self.Owner, self )
                        return
                    end

					if v:GetClass() == 'npc_' and self.NextAllowedXenoScare < CurTime() then
						self.NextAllowedXenoScare = CurTime() + 1
						v:ReactToFire( self:GetPos() )
					elseif v:GetClass() != 'npc_' then
						v:Ignite( 3 )
						v:TakeDamage( math.random( 15, 30 ), self.Owner, self )
					end

				end
			end

			if self.NextAllowedFire < CurTime() then
				self.NextAllowedFire = CurTime() + 2

				-- hitpos
				local hitpos = self.Owner:GetEyeTrace().HitPos

				-- Distance Check

		

			end
		end
	end

	if self.LastShoot and self.LastShoot < CurTime() and self.IsShooting then
		if self.FireLoopSound then self.FireLoopSound:FadeOut( 0.5 ) timer.Simple( 0.5, function() self.FireLoopSound:Stop() end ) end
		self.IsShooting = false
		self:EmitSound( 'weapons/flamethrower_end.wav' )
	end
end

function SWEP:PrimaryAttack()
		if self:Clip1() <= 0 then return end -- we're already full!
		if self.Owner:WaterLevel() >= 3 then return end
		ParticleEffect( 'alien_flamethrower_fire_start', self.Owner:GetShootPos() + self.Owner:EyeAngles():Forward() * 30 + self.Owner:EyeAngles():Right() * 10 - self.Owner:EyeAngles():Up() * 23, self.Owner:EyeAngles(), self )
		if !self.IsShooting then
			self:EmitSound( 'weapons/flamethrower_start.wav' )
			self.FireLoopSound:Play()
		end
		self.IsShooting = true
		self.LastShoot = CurTime() + 0.15
		self:TakePrimaryAmmo( 1 )
		self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
		self:SetNextPrimaryFire( CurTime() + 0.05 )
	end


	function SWEP:Deploy()
		if not IsValid(self.Owner) then return false end
	
		-- Ensure valid view model
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			-- Set playback rate to 1.0 (normal speed)
			vm:SetPlaybackRate(1.0)
			
			-- Try forcing a safe animation sequence instead of ACT_VM_DRAW
			local seq = vm:LookupSequence("draw")  -- Replace "draw" with the correct sequence if needed
			if seq > 0 then
				vm:SendViewModelMatchingSequence(seq)
			else
				self:SendWeaponAnim(ACT_VM_DRAW)  -- Fallback
			end
		end
	
		return self.BaseClass.Deploy(self)
	end
	
--addons/arccw_weapons/lua/weapons/aocrp_z6.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Z-6"
SWEP.Trivia_Class = "Rotary Blaster Cannon"
SWEP.Trivia_Desc = "A powerful chain gun."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Heavy Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/starwars/grady/props/weapons/z6-rotatory-blaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_t21.mdl"
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_z6.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 20
SWEP.RangeMin = 120
SWEP.DamageMin = 11
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 500

SWEP.Recoil = 0.28
SWEP.RecoilSide = 0.25
SWEP.RecoilPunch = 2
SWEP.VisualRecoilMult = 0
SWEP.RecoilRise = 0.34

SWEP.Hook_ModifyRPM = function(wep, delay)
    return delay / Lerp(wep:GetBurstCount() / 15, 1, 3)
end

SWEP.Delay = 60 / 330
SWEP.Num = 1

SWEP.BobMult = 1

SWEP.TriggerDelay = true

SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 0
    }
}

SWEP.AccuracyMOA = 0.55 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 330 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.Bipod_Integral = true -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 0.8 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 0.5 -- Bipod recoil for Integral bipods

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(0, 0, 255)

SWEP.SpeedMult = 0.8
SWEP.SightedSpeedMult = 0.8
SWEP.SightTime = 1

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.02

SWEP.ShootSound = "weapons/z6/SW02_Blasters_Z6RotaryBlaster_Laser_Close_VAR_01.wav"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.IronSightStruct = {
    Pos = Vector(0, -12, -4),
    Ang = Angle(0, 0, 0),
    Magnification = 1,
    SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_05.mp3",
    CrosshairInSights = true
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "crossbow"
SWEP.HoldtypeSights = "smg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN

SWEP.ActivePos = Vector(0, -0, -3)
SWEP.ActiveAng = Angle(0, 2, 0)

SWEP.SprintPos = Vector(5, -30, -20)
SWEP.SprintAng = Angle(40, 0, -10)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -4, -4.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)


SWEP.DefaultElements = {"nil"}
SWEP.AttachmentElements = {
    ["nil"] = {
         VMElements = {},
        WMElements = {
            {
                Model = "models/starwars/grady/props/weapons/z6-rotatory-blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-2000, 1000, -800),
                    ang = Angle(-10, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(4500, 0, -900),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },            
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    }
}

WMOverride = "models/starwars/grady/props/weapons/z6-rotatory-blaster.mdl"

SWEP.Jamming = true
SWEP.HeatGain = 0.95 -- heat gained per shot
SWEP.HeatCapacity = 75 -- rounds that can be fired non-stop before the gun jams, playing the "fix" animation
SWEP.HeatDissipation = 10 -- rounds' worth of heat lost per second
SWEP.HeatLockout = false -- overheating means you cannot fire until heat has been fully depleted
SWEP.HeatDelayTime = 0.5

--SWEP.Attachments 
SWEP.Attachments = {                 
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },       
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = {"fire_1","fire_2", "fire_3"},
        Time = 0.4
    },
    ["draw"] = {
        Source = "draw",
        Time = 1.6,
        SoundTable = {
            {
                s = "draw/blasters_deathray_foley_undeploy_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 200, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/blasters_deathray_foley_undeploy_var_02.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["trigger"] = {
        Source = {"fire_2"},
        SoundTable = {
        {s = "weapons/z6/SW02_Blasters_Z6RotaryBlaster_Start_Short_VAR_01.ogg", v = 75,t = 0 / 30, c = CHAN_ITEM},
        },
        Time = 0.9,
    },
    ["reload"] = {
        Source = "reload", 
        Time = 5,
        SoundTable = {
            {s = "weapons/z6/blasters_deathray_foley_undeploy_var_03.mp3", t = 0},
            {s = "weapons/z6/overheat_overheated_var_01.mp3", t = 1} --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_z6.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),


sound.Add({
    name =          "ArcCW_z6.reload1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/z6/SW02_Blasters_Z6RotaryBlaster_Stop_03.wav"
    }),
}

-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 20
SWEP.DamageMin = 11
SWEP.RangeMin = 120
SWEP.Range = 350
SWEP.Delay = 60 / 650
SWEP.Primary.ClipSize = 500
SWEP.Category = 'REP'
--addons/arccw_base_modified/lua/weapons/arccw_base/shared.lua:
AddCSLuaFile()

-- For those who may find it useful...
-- use WEAPONENTITY:SetNWBool("ArcCW_DisableAutosave", true) to tell the client to not load their autosaves.

SWEP.Spawnable = false -- this obviously has to be set to true
SWEP.AutoSpawnable = nil -- TTT weapon autospawn. ArcCW weapons automatically spawn in TTT as long as SWEP.Spawnable is set to true
SWEP.Category = "ArcCW - Firearms" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "ArcCW Base"
SWEP.Trivia_Class = nil -- "Submachine Gun"
SWEP.Trivia_Desc = nil -- "Ubiquitous 9mm SMG. Created as a response to the need for a faster-firing and more reliable submachine gun than existing options at the time."
SWEP.Trivia_Manufacturer = nil -- "Auschen Waffenfabrik"
SWEP.Trivia_Calibre = nil -- "9x21mm Jager"
SWEP.Trivia_Mechanism = nil -- "Roller-Delayed Blowback"
SWEP.Trivia_Country = nil -- "Austria"
SWEP.Trivia_Year = nil -- 1968

SWEP.UseHands = true

SWEP.ViewModel = "" -- I mean, you probably have to edit these too
SWEP.WorldModel = ""

SWEP.MirrorVMWM = nil -- Copy the viewmodel, along with all its attachments, to the worldmodel. Super convenient!
SWEP.MirrorWorldModel = nil -- Use this to set the mirrored viewmodel to a different model, without any floating speedloaders or cartridges you may have. Needs MirrorVMWM
SWEP.HideViewmodel = nil
--[[SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}]]

SWEP.PresetBase = nil -- make this weapon share saves with this one.

SWEP.KillIconAlias = nil -- set to other weapon class to share select and kill icons

SWEP.DefaultBodygroups = "00000000"
SWEP.DefaultWMBodygroups = "00000000"
SWEP.DefaultSkin = 0
SWEP.DefaultWMSkin = 0

SWEP.WorldModelOffset = nil
-- {
--     pos = Vector(0, 0, 0),
--     ang = Angle(0, 0, 0)
-- }

SWEP.NoHideLeftHandInCustomization = false

SWEP.Damage = 26
SWEP.DamageMin = 10 -- damage done at maximum range
SWEP.DamageRand = 0 -- damage will vary randomly each shot by this fraction
SWEP.RangeMin = 0 -- how far bullets will retain their maximum damage for
SWEP.Range = 200 -- in METRES
SWEP.Penetration = 4
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false -- set to true to have the base not do anything with damage types
-- this includes: igniting if type has DMG_BURN; adding DMG_AIRBOAT when hitting helicopter; adding DMG_BULLET to DMG_BUCKSHOT

SWEP.Distance = nil -- Maximum distance of the bullet (does not affect physbullets)

SWEP.Force = nil -- bullet force. set nil to autocalculate

SWEP.ShootEntity = nil -- entity to fire, if any
SWEP.MuzzleVelocity = 400 -- projectile muzzle velocity in m/s
SWEP.PhysBulletMuzzleVelocity = nil -- override phys bullet muzzle velocity
SWEP.PhysBulletDrag = 1
SWEP.PhysBulletGravity = 1
SWEP.PhysBulletDontInheritPlayerVelocity = true

SWEP.BodyDamageMults = nil
-- if a limb is not set the damage multiplier will default to 1
-- that means gmod's stupid default limb mults will **NOT** apply
-- {
--     [HITGROUP_HEAD] = 1.25,
--     [HITGROUP_CHEST] = 1,
--     [HITGROUP_LEFTARM] = 0.9,
--     [HITGROUP_RIGHTARM] = 0.9,
-- }

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 0 -- color for phys tracer. can be a number or a string (see sh_physbullet2.lua)
-- there are 8 default options:
-- 0 = normal
-- 1 = red
-- 2 = green
-- 3 = blue
-- 4 = yellow
-- 5 = violet
-- 6 = cyan
-- 7 = black/invisible

SWEP.TracerNum = 1 -- tracer every X
SWEP.TracerFinalMag = 0 -- the last X bullets in a magazine are all tracers
SWEP.Tracer = "arccw_tracer" -- override tracer (hitscan) effect
SWEP.TracerCol = Color(255, 255, 255)
SWEP.HullSize = 0 -- HullSize used by FireBullets

SWEP.ChamberSize = 1 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 25 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 50
SWEP.ReducedClipSize = 10

-- But if you insist...
SWEP.ForceDefaultClip = nil
SWEP.ForceDefaultAmmo = nil

-- The amount of rounds to load in the chamber when the gun is non-empty or empty
-- Defaults to ChamberSize and 0. Don't change unless you have a good reason
SWEP.ChamberLoadNonEmpty = nil
SWEP.ChamberLoadEmpty = nil

SWEP.AmmoPerShot = 1
SWEP.InfiniteAmmo = false -- weapon can reload for free
SWEP.BottomlessClip = false -- weapon never has to reload

SWEP.DoNotEquipmentAmmo = false -- do not automatically give this weapon unique ammo when arccw_equipmentammo is used

SWEP.ShotgunReload = false -- reloads like shotgun instead of magazines
SWEP.HybridReload = false -- reload normally when empty, reload like shotgun when part full

SWEP.ManualAction = false -- pump/bolt action
SWEP.NoLastCycle = false -- do not cycle on last shot

SWEP.RevolverReload = false -- cases all eject on reload

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.LockSightsInPriorityAnim = false

SWEP.CanFireUnderwater = false

SWEP.Disposable = false -- when all ammo is expended, the gun will remove itself when holstered

SWEP.AutoReload = false -- when weapon is drawn, the gun will reload itself.

SWEP.IsShotgun = false -- weapon receives shotgun ammo types

SWEP.TriggerDelay = false -- Set to true to play the "trigger" animation before firing. Delay time is dependent on animation time.
SWEP.TriggerCharge = false -- If TriggerDelay is set, holding trigger will charge and releasing it fires. Also allows premature release of trigger.
SWEP.TriggerPullWhenEmpty = true -- If true, can pull the trigger even if no ammo is left.

SWEP.Recoil = 2
SWEP.RecoilSide = 1
SWEP.RecoilRise = 1
SWEP.MaxRecoilBlowback = -1
SWEP.VisualRecoilMult = 1.25
SWEP.RecoilPunch = 1.5
SWEP.RecoilPunchBackMax = 1
SWEP.RecoilPunchBackMaxSights = nil -- may clip with scopes
SWEP.RecoilVMShake = 1 -- random viewmodel offset when shooty

SWEP.Sway = 0

SWEP.ShotgunSpreadDispersion = false -- dispersion will cause pattern to increase instead of shifting
SWEP.ShotgunSpreadPattern = nil
SWEP.ShotgunSpreadPatternOverrun = nil
-- {Angle(1, 1, 0), Angle(1, 0, 0) ..}
-- list of how far each pellet should veer
-- if only one pellet then it'll use the first index
-- if two then the first two
-- in case of overrun pellets will start looping, preferably with the second one, so use that for the loopables
-- precision will still be applied
SWEP.NoRandSpread = false

SWEP.RecoilDirection = Angle(1, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1, 0)

SWEP.Delay = 60 / 750 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 1 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
    -- {
    --     Mode = 1,
    --     CustomBars = "---_#!",
--[[
                Custom bar setup
        Colored variants        Classic
        'a' Filled              '-' Filled
        'b' Outline             '_' Outline
        'd' CLR w Outline       '!' Red w Outline
                    '#' Empty
]]
    --     PrintName = "PUMP",
    --     RunAwayBurst = false,
    --     AutoBurst = false, -- hold fire to continue firing bursts
    --     PostBurstDelay = 0,
    --     ActivateElements = {}
    --     RestoreAmmo = false -- switching to this firemode will call RestoreAmmo(). intended to be used alongside firemode changing animations
    -- }
}

SWEP.ShotRecoilTable = nil -- {[1] = 0.25, [2] = 2} etc.

SWEP.NotForNPCS = false
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace
-- if nil, this will be based on holdtype
SWEP.NPCWeight = 0 -- relative likeliness for an NPC to have this weapon
SWEP.TTTWeaponType = nil -- string or table, like NPCWeaponType but specifically for TTT weapons (takes precdence over NPCWeaponType)
SWEP.TTTWeight = 0 -- like NPCWeight but for TTT gamemode

SWEP.AccuracyMOA = 15 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 150 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 0 -- dispersion that remains even in sights
SWEP.JumpDispersion = 300 -- dispersion penalty when in the air

SWEP.Bipod_Integral = false -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 1 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 1 -- Bipod recoil for Integral bipods

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "pistol" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 125 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = nil
SWEP.ShootSound = ""
SWEP.ShootSoundLooping = nil
SWEP.FirstShootSoundSilenced = nil
SWEP.ShootDrySound = nil -- Add an attachment hook for Hook_GetShootDrySound please!
SWEP.DistantShootSound = nil
SWEP.ShootSoundSilenced = "weapons/arccw/m4a1/m4a1-1.wav"
SWEP.ShootSoundSilencedLooping = nil
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"
SWEP.EnterBipodSound = "weapons/arccw/bipod_down.wav"
SWEP.ExitBipodSound = "weapons/arccw/bipod_up.wav"
SWEP.SelectUBGLSound =  "weapons/arccw/ubgl_select.wav"
SWEP.ExitUBGLSound = "weapons/arccw/ubgl_exit.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects
SWEP.ImpactEffect = nil
SWEP.ImpactDecal = nil

SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellMaterial = nil
SWEP.ShellEffect = nil
SWEP.ShellEjectPosCorrection = nil
SWEP.ShellScale = 1
SWEP.ShellPhysScale = 1
SWEP.ShellPitch = 100
SWEP.ShellSounds = "autocheck"--ArcCW.ShellSoundsTable
SWEP.ShellRotate = 0
SWEP.ShellTime = 0.5

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on
SWEP.ProceduralViewBobAttachment = nil -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.CamAttachment = nil -- if set, this attachment will control camera movement
SWEP.MuzzleFlashColor = Color(244, 209, 66)

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}
SWEP.CaseBones = {}
-- Unlike BulletBones, these bones are determined by the missing bullet amount when reloading
SWEP.StripperClipBones = {}

-- the same as the bone versions but works via bodygroups.
-- bodygroups work the same as in attachmentelements.
-- [0] = {ind = 0, bg = 1}
SWEP.BulletBGs = {}
SWEP.CaseBGs = {}
SWEP.StripperClipBGs = {}

SWEP.KeepBaseIrons = false -- do not override iron sights when scope installed
SWEP.BaseIronsFirst = false -- If a sight keeps base irons, irons comes first

SWEP.IronSightStruct = {
    Pos = Vector(-8.728, -13.702, 4.014),
    Ang = Angle(-1.397, -0.341, -2.602),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 15, -4),
        Ang = Angle(0, 0, -45),
    },
    Magnification = 1,
    BlackBox = false,
    ScopeTexture = nil,
    SwitchToSound = "", -- sound that plays when switching to this sight
    SwitchFromSound = "",
    ScrollFunc = ArcCW.SCROLL_NONE,
    CrosshairInSights = false,
}

SWEP.LaserOffsetAngle = nil -- adjusts the offset angle of lasers
SWEP.LaserIronsAngle = nil -- additional offset when using ironsights only

-- Works identically to AdditionalSights in attachments
-- KeepBaseIrons and BaseIronsFirst also affect this
SWEP.ExtraIrons = nil

-- add lasers to your weapon without attachments
SWEP.Lasers = nil
-- {
--     {
--         LaserStrength = 1,
--         LaserBone = "laser",
--         Color = Color(255, 0, 0)
--     }
-- }

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false
SWEP.SightTime = 0.33
SWEP.SprintTime = 0

-- Override free aim convar and variable
SWEP.FreeAimAngle = nil -- defaults to HipDispersion / 80. overwrite here
SWEP.NeverFreeAim = nil
SWEP.AlwaysFreeAim = nil

-- If Jamming is enabled, a heat meter will gradually build up until it reaches HeatCapacity.
-- Once that happens, the gun will overheat, playing an animation. If HeatLockout is true, it cannot be fired until heat is 0 again.
SWEP.Jamming = false
SWEP.HeatGain = 1 -- heat gained per shot
SWEP.HeatCapacity = 200 -- rounds that can be fired non-stop before the gun jams, playing the "fix" animation
SWEP.HeatDissipation = 2 -- rounds' worth of heat lost per second
SWEP.HeatLockout = false -- overheating means you cannot fire until heat has been fully depleted
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = false -- when the "fix" animation is played, all heat is restored.
SWEP.HeatOverflow = nil -- if true, heat is allowed to exceed capacity (this only applies when the default overheat handling is overridden)

-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "unjam" animation
-- if no "unjam", "fix", or "cycle" animations exist, the weapon will reload instead
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.
SWEP.MalfunctionTakeRound = true -- When malfunctioning, a bullet is consumed.
SWEP.MalfunctionPostFire = false -- If set, jam will occur after firing the round successfully.
SWEP.MalfunctionWait = 0.5 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMean = nil -- The mean number of shots between malfunctions, will be autocalculated if nil
SWEP.MalfunctionVariance = 0.25 -- The fraction of mean for variance. e.g. 0.2 means 20% variance
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "shotgun"
SWEP.HoldtypeSights = "smg"
SWEP.HoldtypeCustomize = "slam"
SWEP.HoldtypeSprintShoot = nil
SWEP.HoldtypeNPC = nil

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.GuaranteeLaser = false -- GUARANTEE that the laser position will be accurate, so don't bother with sighted correction

SWEP.ShieldProps = nil
-- {
--     {
--         Model = "",
--         Pos = Vector(0, 0, 0),
--         Ang = Angle(0, 0, 0),
--         Bone = "", -- leave blank for valvebiped right hand
--         Resistance = 5, -- one unit of this object counts for how much penetration amount
--     }
-- }

SWEP.CanBash = true
SWEP.PrimaryBash = false -- primary attack triggers melee attack

SWEP.Lunge = nil -- Whether to allow the bash/melee to lunge a short distance
SWEP.LungeLength = 64 -- Maximum distance for lunging

SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.Melee2 = false
SWEP.Melee2Damage = 25
SWEP.Melee2Range = 16
SWEP.Melee2Time = 0.5
SWEP.Melee2Gesture = nil
SWEP.Melee2AttackTime = 0.2

SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.ReloadPos = nil
SWEP.ReloadAng = nil

SWEP.CrouchPos = nil
SWEP.CrouchAng = nil

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

-- When using custom sprint animations, set this to the same as ActivePos and ActiveAng
SWEP.SprintPos = nil
SWEP.SprintAng = nil

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.CustomizePos = Vector(9.824, 0, -4.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.BarrelLength = 24

SWEP.SightPlusOffset = nil

SWEP.DefaultPoseParams = {} -- {["pose"] = 0.5}
SWEP.DefaultWMPoseParams = {}

SWEP.DefaultElements = {} -- {"ele1", "ele2"}

SWEP.AttachmentElements = {
    -- ["name"] = {
    --     RequireFlags = {}, -- same as attachments
    --     ExcludeFlags = {},
    --     NamePriority = 0, -- higher = more likely to be chosen
    --     NameChange = "",
    --     TrueNameChange = "",
    --     AddPrefix = "",
    --     AddSuffix = "",
    --     VMPoseParams = {}, -- {["pose"] = 0.5}
    --     VMColor = Color(),
    --     VMMaterial = "",
    --     VMBodygroups = {{ind = 1, bg = 1}},
    --     VMElements = {
    --         {
    --             Model = "",
    --             Bone = "",
    --             Offset = {
    --                 pos = Vector(),
    --                 ang = Angle(),
    --             },
    --             ModelSkin = 0,
    --             ModelBodygroups = "",
    --             Scale = Vector(1, 1, 1),
    --             IsMuzzleDevice = false -- this element is a muzzle device, and the muzzle flash should come from here.
    --         }
    --     },
    --     VMOverride = "", -- change the view model to something else. Please make sure it's compatible with the last one.
    --     VMBoneMods = {
    --         ["bone"] = Vector(0, 0, 0)
    --     },
    --     WMPoseParams = {}, -- {["pose"] = 0.5}
    --     WMColor = Color(),
    --     WMMaterial = "",
    --     WMBodygroups = {},
    --     WMElements = {
    --         {
    --             Model = "",
    --             Offset = {
    --                 pos = Vector(),
    --                 ang = Angle(),
    --             },
    --             IsMuzzleDevice = false -- this element is a muzzle device, and the muzzle flash should come from here.
    --         }
    --     },
    --     WMOverride = "", -- change the world model to something else. Please make sure it's compatible with the last one.
    --     WMBoneMods = {
    --         ["bone"] = Vector(0, 0, 0)
    --     },
    --     AttPosMods = {
    --         [1] = {
    --             bone = "", -- optional
    --             vpos = Vector(0, 0, 0),
    --             vang = Angle(0, 0, 0),
    --             wpos = Vector(0, 0, 0),
    --             wang = Angle(0, 0, 0),
    --             SlideAmount = { -- only if base att has slideable
    --                 vmin = Vector(0, 0, 0),
    --                 vmax = Vector(0, 0, 0),
    --                 wmin = Vector(0, 0, 0),
    --                 wmax = Vector(0, 0, 0)
    --             }
    --         }
    --     }
    -- }
}

SWEP.RejectAttachments = {
    -- ["optic_docter"] = true -- stop this attachment from being usable on this gun
}

SWEP.TTT_DoNotAttachOnBuy = false -- don't give all attachments when bought

SWEP.Attachments = {}
-- [1] = {
--     PrintName = "Optic", -- print name
--     DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
--     DefaultAttIcon = Material(),
--     Slot = "pic_sight", -- what kind of attachments can fit here
--     MergeSlots = {}, -- these other slots will be merged into this one.
--     Bone = "sight", -- relevant bone any attachments will be mostly referring to
--     WMBone = "ValveBiped.Bip01_L_Hand", -- set it to change parent bone of attachment WM
--     KeepBaseIrons = false,
--     ExtraSightDist = 0,
--     Offset = {
--         vpos = Vector(0, 0, 0), -- offset that the attachment will be relative to the bone
--         vang = Angle(0, 0, 0),
--         wpos = Vector(0, 0, 0), -- same, for the worldmodels
--         wang = Angle(0, 0, 0)
--     },
--     RejectAttachments = {}, -- specific blacklist of attachments this slot cannot accept. Needs to be like {"optic_mrs" = true}
--     VMScale = Vector(1, 1, 1),
--     WMScale = Vector(1, 1, 1),
--     SlideAmount = { -- how far this attachment can slide in both directions.
--         -- overrides Offset.
--         vmin = Vector(0, 0, 0),
--         vmax = Vector(0, 0, 0),
--         wmin = Vector(0, 0, 0),
--         wmax = Vector(0, 0, 0),
--     },
--     CorrectiveAng = Vector(1, 1, 1), -- okay, I know I said sights were pain-free.
--     CorrectivePos = Vector(0, 0, 0), -- that won't always be the case. Use these to fix it. Issues mainly crop up in case of sights parented to bones that are not a root bone.
--     InstalledEles = {"toprail"}, -- activate these AttachmentElements if something is installed
--     DefaultEles = {""} -- activeate these AttachmentElements *unless* something is installed
--     Hidden = false, -- attachment cannot be seen in customize menu
--     Integral = false, -- attachment is assumed never to change
--     RandomChance = 1, -- multiplies chance this slot will get a random attachment
--     DoNotRandomize = false,
--     NoWM = false, -- do not make this show up on worldmodel
--     NoVM = false, -- what do *you* think this one does?
--     FreeSlot = false, -- slot does not count towards attachment capacity
--     -- ABOUT THE FLAG SYSTEM:
--     -- Attachments and slots can give flags
--     -- All attachments automatically give themselves as a flag, e.g. "optic_mrs"
--     -- If requirements are not satisfied, the slot or attachment will not be attachable
--     ExcludeFlags = {}, -- if the weapon has this flag, hide this slot
--     RequireFlags = {}, -- if the weapon does not have all these flags, hide this slot
--     GivesFlags = {} -- give these slots if something is installed here
--     DefaultFlags = {} -- give these slots UNLESS something is installed here
--     HideIfBlocked = false, -- If flag requirements are not met, do not show the attachment at all
-- }

-- ready: deploy first time
-- draw
-- holster
-- reload
-- fire
-- cycle (for bolt/pump actions)
-- bash
-- fix
-- enter_bipod
-- exit_bipod
-- enter_sight
-- exit_sight
-- a_to_b: switch from firemode a to firemode b. e.g.: 1_to_2
-- idle
-- idle_sights
-- idle_sprint
-- idle_bipod
-- enter_inspect
-- idle_inspect
-- exit_inspect
-- enter_ubgl
-- exit_ubgl
-- idle_ubgl

-- you can append suffixes for different states
-- append list:

-- _iron, _sights, or _sight     for sighted variation
-- _sprint                       for sprinting variation
-- _bipod                        for bipod variation
-- _empty                        for empty variation
-- _jammed                       for jammed variation

-- this does not apply to reload animations.

-- !! they MUST be in the order of this list.
-- example: fire_iron_bipod_empty

-- use SWEP/wep.Hook_TranslateAnimation, same as in attachment, to do even more behaviours
-- use SWEP/wep.Hook_SelectReloadAnimation to change the reload animation
-- use SWEP/wep.Hook_SelectInsertAnimation to change the shotgun reload insert animation
-- use SWEP/wep.Hook_SelectFireAnimation to change the fire animation
-- use SWEP/wep.Hook_SelectCycleAnimation to change the cycle/pump animation
-- use SWEP/wep.Hook_SelectBashAnim to change the bash animation
-- use SWEP/wep.Hook_SelectJamAnim to change the jam animation

-- which sequence to derive the sight autosolver from.
SWEP.AutosolveSourceSeq = "idle"

-- Disclaimer: LHIK is *actually* a type of forward kinematics.
-- If you prefer, LHIK can stand for "Left Hand Individual Kinematics" or some shit

SWEP.Animations = {
    -- ["idle"] = {
    --     Source = "idle",
    --     Time = 10
    -- },
    -- ["draw"] = {
    --     RestoreAmmo = 1, -- only used by shotgun empty insert reload
    --     Source = "deploy",
    --     RareSource = "", -- 1/RareSourceChance of playing this animation instead
    --     RareSourceChance = 100, -- Chance the rapper
    --     Time = 0.5, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    --     Mult = 1, -- Multiplies the rate of animation.
    --     TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, -- third person animation to play when this animation is played
    --     TPAnimStartTime = 0, -- when to start it from
    --     Checkpoints = {}, -- time checkpoints. If weapon is unequipped, the animation will continue to play from these checkpoints when reequipped.
    --     ShellEjectAt = 0, -- animation includes a shell eject at these times
    --     LHIKIn = 0.25, -- In/Out controls how long it takes to switch to regular animation.
    --     LHIKOut = 0.25, -- (not actually inverse kinematics)
    --     LHIKEaseIn = 0.1, -- how long LHIK eases in.
    --     LHIKEaseOut = 0.1, -- if no value is specified then ease = lhikin
    --     LHIKTimeline = { -- allows arbitrary LHIK values to be interpolated between
    --         {
    --             t = 0.1,
    --             lhik = 0,
    --         },
    --         {
    --             t = 0.25,
    --             lhik = 1
    --         }
    --     },
    --     LHIK = true, -- basically disable foregrips on this anim
    --     SoundTable = {
    --         {
    --             s = "", -- sound; can be string or table
    --             p = 100, -- pitch
    --             v = 75, -- volume
    --             t = 1, -- time at which to play relative to Animations.Time
    --             c = CHAN_ITEM, -- channel to play the sound

    --             -- Can also play an effect at the same time
    --             e = "", -- effect name
    --             att = nil, -- attachment, defaults to shell attachment
    --             mag = 100, -- magnitude
    --             -- also capable of modifying bodygroups
    --             ind = 0,
    --             bg = 0,
    --             -- and poseparams
    --             pp = "pose",
    --             ppv = 0.25,
    --         }
    --     },
    --     ViewPunchTable = {
    --         {
    --             p = Vector(0, 0, 0),
    --             t = 1
    --         }
    --     },
    --     ProcDraw = false, -- for draw/deploy animations, always procedurally draw in addition to playing animation
    --     ProcHolster = false, -- procedural holster weapon, THEN play animation
    --     LastClip1OutTime = 0, -- when should the belt visually replenish on a belt fed
    --     MinProgress = 0, -- how much time in seconds must pass before the animation can be cancelled
    --     ForceEmpty = false, -- Used by empty shotgun reloads that load rounds to force consider the weapon to still be empty.
    --     ForceCamReset = false, -- Use the first frame of the sequence as starting angles for the cambone.
    -- }
}

-- don't change any of this stuff

SWEP.Primary.Automatic = true
SWEP.Primary.DefaultClip = -1
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.DrawCrosshair = true
SWEP.m_WeaponDeploySpeed = 80.08135 -- 8008135 boobies is funny but it'll bitch in console :(
        -- We don't do that here

SWEP.ArcCW = true
SWEP.BurstCount = 0
SWEP.AnimQueue = {}
SWEP.FiremodeIndex = 1
SWEP.UnReady = true
SWEP.EventTable = {
    [1] = {} -- for every overlapping one, a new one is made -- checked to be removed afterwards, except 1
}

SWEP.ProneMod_DisableTransitions = true

SWEP.DrawWeaponInfoBox = false
SWEP.BounceWeaponIcon = false

if CLIENT or game.SinglePlayer() then

SWEP.RecoilAmount = 0
SWEP.RecoilAmountSide = 0
SWEP.RecoilPunchBack = 0
SWEP.RecoilPunchUp = 0
SWEP.RecoilPunchSide = 0
SWEP.HammerDown = false

SWEP.LHIKTimeline = nil
SWEP.LHIKStartTime = 0
-- {number starttime, number intime, number outtime, number finishouttime}
end

SWEP.Bodygroups = {} -- [0] = 1, [1] = 0...
-- SWEP.RegularClipSize = 0

local searchdir = "weapons/arccw_base"

local function autoinclude(dir)
    local files, dirs = file.Find(searchdir .. "/*.lua", "LUA")

    for _, filename in pairs(files) do
        if filename == "shared.lua" then continue end
        local luatype = string.sub(filename, 1, 2)

        if luatype == "sv" then
            if SERVER then
                include(dir .. "/" .. filename)
            end
        elseif luatype == "cl" then
            AddCSLuaFile(dir .. "/" .. filename)
            if CLIENT then
                include(dir .. "/" .. filename)
            end
        else
            AddCSLuaFile(dir .. "/" .. filename)
            include(dir .. "/" .. filename)
        end
    end

    for _, path in pairs(dirs) do
        autoinclude(dir .. "/" .. path)
    end
end

autoinclude(searchdir)

function SWEP:SetupDataTables()
    self:NetworkVar("Int", 0, "NWState")
    self:NetworkVar("Int", 1, "FireMode")
    self:NetworkVar("Int", 2, "BurstCountUM")
    self:NetworkVar("Int", 3, "LastLoad")
    self:NetworkVar("Int", 4, "NthReload")
    self:NetworkVar("Int", 5, "NthShot")

    -- 2 = insert
    -- 3 = cancelling
    -- 4 = insert empty
    -- 5 = cancelling empty
    self:NetworkVar("Int", 6, "ShotgunReloading")
    self:NetworkVar("Int", 7, "MagUpCount")

    self:NetworkVar("Bool", 0, "HeatLocked")
    self:NetworkVar("Bool", 1, "NeedCycle")
    self:NetworkVar("Bool", 2, "InBipod")
    self:NetworkVar("Bool", 3, "InUBGL")
    self:NetworkVar("Bool", 4, "InCustomize")
    self:NetworkVar("Bool", 5, "GrenadePrimed")
    self:NetworkVar("Bool", 6, "NWMalfunctionJam")
    self:NetworkVar("Bool", 7, "UBGLDebounce")

    self:NetworkVar("Float", 0, "Heat")
    self:NetworkVar("Float", 1, "WeaponOpDelay")
    self:NetworkVar("Float", 2, "ReloadingREAL")
    self:NetworkVar("Float", 3, "MagUpIn")
    self:NetworkVar("Float", 4, "NextPrimaryFireSlowdown")
    self:NetworkVar("Float", 5, "NextIdle")
    self:NetworkVar("Float", 6, "Holster_Time")
    self:NetworkVar("Float", 7, "NWSightDelta")
    self:NetworkVar("Float", 8, "NWSprintDelta")
    self:NetworkVar("Float", 9, "NWPriorityAnim")

    self:NetworkVar("Vector", 0, "BipodPos")

    self:NetworkVar("Angle", 0, "BipodAngle")
    self:NetworkVar("Angle", 1, "FreeAimAngle")
    self:NetworkVar("Angle", 2, "LastAimAngle")

    self:NetworkVar("Entity", 0, "Holster_Entity")

    self:SetNWSightDelta(1)
end

function SWEP:OnRestore()
    self:SetNthReload(0)
    self:SetNthShot(0)
    self:SetBurstCountUM(0)
    self:SetReloadingREAL(0)
    self:SetWeaponOpDelay(0)
    self:SetMagUpIn(0)
    self:SetNWPriorityAnim(0)

    self:KillTimers()
    self:Initialize()

    self.UnReady = false
end


function SWEP:SetReloading(v)
    if isbool(v) then
        if v then
            self:SetReloadingREAL(math.huge)
        else
            self:SetReloadingREAL(-math.huge)
        end
    elseif isnumber(v) and v > self:GetReloadingREAL() then
        self:SetReloadingREAL( v )
    end
end

function SWEP:GetReloading()
    local decide

    if self:GetReloadingREAL() > CurTime() then
        decide = true
    else
        decide = false
    end

    self:GetBuff_Hook("Hook_GetReloading", decide)

    return decide
end

function SWEP:SetBurstCount(b)
    self:SetBurstCountUM(b)
end

function SWEP:GetBurstCount()
    return self:GetBuff_Hook("Hook_GetBurstCount", self:GetBurstCountUM()) or self:GetBurstCountUM() or 0
end

function SWEP:SetState(v)
    self:SetNWState(v)
    if !game.SinglePlayer() and CLIENT then self.State = v end
end

function SWEP:GetState(v)
    if !game.SinglePlayer() and CLIENT and self.State then return self.State end
    return self:GetNWState(v)
end

function SWEP:IsProne()
    if PRONE_INPRONE then
        return self:GetOwner().IsProne and self:GetOwner():IsProne()
    else
        return false
    end
end

-- BarrelHitWall is known to cause viewmodel flickering on certain playermodels if called during VM position function (a270cc9)
local hitwallcache
function SWEP:BarrelHitWall()

    local len = self:GetBuff("BarrelLength")
    if len == 0 or !ArcCW.ConVars["override_nearwall"]:GetBool()
            or (vrmod and vrmod.IsPlayerInVR(self:GetOwner()))
            or (self:GetOwner():IsPlayer() and self:GetOwner():InVehicle()) then
        hitwallcache = {0, CurTime()}
    end

    if !hitwallcache or hitwallcache[2] ~= CurTime() then

        local offset = self:GetBuff("BarrelOffsetHip")

        if self:GetState() == ArcCW.STATE_SIGHTS then
            offset = LerpVector(self:GetSightDelta(), self:GetBuff("BarrelOffsetSighted"), offset)
        end

        local dir = self:GetOwner():EyeAngles()
        local src = self:GetOwner():EyePos()
        local r, f, u = dir:Right(), dir:Forward(), dir:Up()

        for i = 1, 3 do
            src[i] = src[i]
                    + r[i] * offset[1]
                    + f[i] * offset[2]
                    + u[i] * offset[3]
        end

        local filter = {self:GetOwner()}

        table.Add(filter, self.Shields)

        local tr = util.TraceLine({
            start = src,
            endpos = src + (f * len),
            filter = filter,
            mask = MASK_SOLID
        })

        if tr.Hit and !tr.Entity.ArcCWProjectile then
            --local l = (tr.HitPos - src):Length()
            --hitwallcache = {math.Clamp(1 - l / len, 0, 1), CurTime()}
            hitwallcache = {1 - tr.Fraction, CurTime()}
        else
            hitwallcache = {0, CurTime()}
        end
    end

    return hitwallcache[1] or 0
end

function SWEP:GetBarrelNearWall()
    return hitwallcache and hitwallcache[1] or 0
end

SWEP.CL_SightDelta = 1
function SWEP:SetSightDelta(d)
    if !game.SinglePlayer() and CLIENT then self.CL_SightDelta = d end
    self:SetNWSightDelta(d)
end

function SWEP:GetSightDelta()
    if !game.SinglePlayer() and CLIENT then return self.CL_SightDelta end
    return self:GetNWSightDelta()
end

SWEP.CL_SprintDelta = 0
function SWEP:SetSprintDelta(d)
    if !game.SinglePlayer() and CLIENT then self.CL_SprintDelta = d end
    self:SetNWSprintDelta(d)
end

function SWEP:GetSprintDelta()
    if !game.SinglePlayer() and CLIENT then return self.CL_SprintDelta end
    return self:GetNWSprintDelta()
end

SWEP.CL_MalfunctionJam = false
function SWEP:SetMalfunctionJam(d)
    if !game.SinglePlayer() and CLIENT then self.CL_MalfunctionJam = tobool(d) end
    self:SetNWMalfunctionJam(d)
end

function SWEP:GetMalfunctionJam()
    if !game.SinglePlayer() and CLIENT then return self.CL_MalfunctionJam end
    return self:GetNWMalfunctionJam()
end

-- DIRTY OPTIMIZATION TRICK: NeedCycle is reused for grenades!
function SWEP:SetGrenadeAlt(d)
    if !self.Throwing then return end
    self:SetNeedCycle(d)
end

function SWEP:GetGrenadeAlt()
    if !self.Throwing then return false end
    return self:GetNeedCycle()
end

function SWEP:SetPriorityAnim(v)
    if isbool(v) then
        if v then
            self:SetNWPriorityAnim(math.huge)
        else
            self:SetNWPriorityAnim(-math.huge)
        end
    elseif isnumber(v) and v > self:GetNWPriorityAnim() then
        self:SetNWPriorityAnim(v)
    end
end

function SWEP:GetPriorityAnim()
    local decide = self:GetNWPriorityAnim() > CurTime()

    -- Reloading is always a priority animation
    if !decide then decide = self:GetReloading() end

    self:GetBuff_Hook("Hook_GetPriorityAnim", decide)

    return decide
end
--addons/arccw_base_modified/lua/weapons/arccw_base/cl_blur.lua:
local dofmat = Material("pp/dof")

function SWEP:BlurWeapon()
    if !ArcCW.ConVars["blur"]:GetBool() then return end
    local delta = self:GetSightDelta()
    if delta >= 1 then return end
    local vm = self:GetOwner():GetViewModel()
    render.UpdateScreenEffectTexture()
    render.ClearStencil()
    render.SetStencilEnable(true)
    render.SetStencilCompareFunction(STENCIL_ALWAYS)
    render.SetStencilPassOperation(STENCIL_REPLACE)
    render.SetStencilFailOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_REPLACE)
    render.SetStencilWriteMask(0xFF)
    render.SetStencilTestMask(0xFF)
    render.SetBlend(1)
    render.SetStencilReferenceValue(55)
    ArcCW.Overdraw = true
    vm:DrawModel()
    ArcCW.Overdraw = false
    render.SetBlend(0)
    render.SetStencilPassOperation(STENCIL_REPLACE)
    render.SetStencilCompareFunction(STENCIL_EQUAL)
    -- render.SetColorMaterial()
    dofmat:SetFloat("bluramount", 0.1 * (1 - delta))
    render.SetMaterial(dofmat)
    render.DrawScreenQuad()
    render.SetStencilEnable(false)
end

function SWEP:BlurNotWeapon()
    if !ArcCW.ConVars["blur"]:GetBool() then return end
    render.UpdateRefractTexture()
    DrawToyTown(3, ScrH())
end

function SWEP:DoToyTown()
    if !ArcCW.ConVars["blur_toytown"]:GetBool() then return end
    render.UpdateRefractTexture()
    DrawToyTown(3, ScrH() * 0.4 * (1 - self:GetSightDelta()))
end
--addons/arccw_base_modified/lua/weapons/arccw_base/sh_anim.lua:
SWEP.Cam_Offset_Ang = nil --Angle(0, 0, 0)

function SWEP:SelectAnimation(anim)
    if self:GetNWState() == ArcCW.STATE_SIGHTS and self.Animations[anim .. "_iron"] then
        anim = anim .. "_iron"
    end

    if self:GetNWState() == ArcCW.STATE_SIGHTS and self.Animations[anim .. "_sights"] then
        anim = anim .. "_sights"
    end

    if self:GetNWState() == ArcCW.STATE_SIGHTS and self.Animations[anim .. "_sight"] then
        anim = anim .. "_sight"
    end

    if self:GetNWState() == ArcCW.STATE_SPRINT and self.Animations[anim .. "_sprint"] and !self:CanShootWhileSprint() then
        anim = anim .. "_sprint"
    end

    if self:InBipod() and self.Animations[anim .. "_bipod"] then
        anim = anim .. "_bipod"
    end

    if self:GetState() == ArcCW.STATE_CUSTOMIZE and self.Animations[anim .. "_inspect"] and ((CLIENT and !ArcCW.ConVars["noinspect"]:GetBool()) or (SERVER and self:GetOwner():GetInfoNum("arccw_noinspect", 0))) then
        anim = anim .. "_inspect"
    end

    if (self:Clip1() == 0 or (self:HasBottomlessClip() and self:Ammo1() == 0)) and self.Animations[anim .. "_empty"] then
        anim = anim .. "_empty"
    end

    if self:GetMalfunctionJam() and self.Animations[anim .. "_jammed"] then
        anim = anim .. "_jammed"
    end

    if self:GetBuff_Override("Override_TriggerDelay", self.TriggerDelay) and self:IsTriggerHeld() and self.Animations[anim .. "_trigger"] then
        anim = anim .. "_trigger"
    end

    if !self.Animations[anim] then return end

    return anim
end

SWEP.LastAnimStartTime = 0
SWEP.LastAnimFinishTime = 0

function SWEP:PlayAnimationEZ(key, mult, priority)
    return self:PlayAnimation(key, mult, true, 0, false, false, priority, false)
end

function SWEP:PlayAnimation(key, mult, pred, startfrom, tt, skipholster, priority, absolute)
    mult = mult or 1
    pred = pred or false
    startfrom = startfrom or 0
    tt = tt or false
    --skipholster = skipholster or false Unused
    priority = priority or false
    absolute = absolute or false
    if !key then return end

    local ct = CurTime()

    if self:GetPriorityAnim() and !priority then return end

    if game.SinglePlayer() and SERVER and pred then
        net.Start("arccw_sp_anim")
        net.WriteString(key)
        net.WriteFloat(mult)
        net.WriteFloat(startfrom)
        net.WriteBool(tt)
        --net.WriteBool(skipholster) Unused
        net.WriteBool(priority)
        net.Send(self:GetOwner())
    end

    local anim = self.Animations[key]
    if !anim then return end
    local tranim = self:GetBuff_Hook("Hook_TranslateAnimation", key)
    if self.Animations[tranim] then
        key = tranim
        anim = self.Animations[tranim]
    --[[elseif self.Animations[key] then -- Can't do due to backwards compatibility... unless you have a better idea?
        anim = self.Animations[key]
    else
        return]]
    end

    if anim.ViewPunchTable and CLIENT then
        for k, v in pairs(anim.ViewPunchTable) do

            if !v.t then continue end

            local st = (v.t * mult) - startfrom

            if isnumber(v.t) and st >= 0 and self:GetOwner():IsPlayer() and (game.SinglePlayer() or IsFirstTimePredicted()) then
                self:SetTimer(st, function() self:OurViewPunch(v.p or Vector(0, 0, 0)) end, id)
            end
        end
    end

    if isnumber(anim.ShellEjectAt) then
        self:SetTimer(anim.ShellEjectAt * mult, function()
            local num = 1
            if self.RevolverReload then
                num = self.Primary.ClipSize - self:Clip1()
            end
            for i = 1,num do
                self:DoShellEject()
            end
        end)
    end

    if !self:GetOwner() then return end
    if !self:GetOwner().GetViewModel then return end
    local vm = self:GetOwner():GetViewModel()

    if !vm then return end
    if !IsValid(vm) then return end

    local seq = anim.Source
    if anim.RareSource and util.SharedRandom("raresource", 0, 1, CurTime()) < (1 / (anim.RareSourceChance or 100)) then
        seq = anim.RareSource
    end
    seq = self:GetBuff_Hook("Hook_TranslateSequence", seq)

    if istable(seq) then
        seq["BaseClass"] = nil
        seq = seq[math.Round(util.SharedRandom("randomseq" .. CurTime(), 1, #seq))]
    end

    if isstring(seq) then
        seq = vm:LookupSequence(seq)
    end

    local time = absolute and 1 or self:GetAnimKeyTime(key)
    --if time == 0 then return end

    local ttime = (time * mult) - startfrom
    if startfrom > (time * mult) then return end

    if tt then
        self:SetNextPrimaryFire(ct + ((anim.MinProgress or time) * mult) - startfrom)
    end

    if anim.LHIK then
        self.LHIKStartTime = ct
        self.LHIKEndTime = ct + ttime

        if anim.LHIKTimeline then
            self.LHIKTimeline = {}

            for i, k in pairs(anim.LHIKTimeline) do
                table.Add(self.LHIKTimeline, {t = (k.t or 0) * mult, lhik = k.lhik or 1})
            end
        else
            self.LHIKTimeline = {
                {t = -math.huge, lhik = 1},
                {t = ((anim.LHIKIn or 0.1) - (anim.LHIKEaseIn or anim.LHIKIn or 0.1)) * mult, lhik = 1},
                {t = (anim.LHIKIn or 0.1) * mult, lhik = 0},
                {t = ttime - ((anim.LHIKOut or 0.1) * mult), lhik = 0},
                {t = ttime - (((anim.LHIKOut or 0.1) - (anim.LHIKEaseOut or anim.LHIKOut or 0.1)) * mult), lhik = 1},
                {t = math.huge, lhik = 1}
            }

            if anim.LHIKIn == 0 then
                self.LHIKTimeline[1].lhik = -math.huge
                self.LHIKTimeline[2].lhik = -math.huge
            end

            if anim.LHIKOut == 0 then
                self.LHIKTimeline[#self.LHIKTimeline - 1].lhik = math.huge
                self.LHIKTimeline[#self.LHIKTimeline].lhik = math.huge
            end
        end
    else
        self.LHIKTimeline = nil
    end

    if anim.LastClip1OutTime then
        self.LastClipOutTime = ct + ((anim.LastClip1OutTime * mult) - startfrom)
    end

    if anim.TPAnim then
        local aseq = self:GetOwner():SelectWeightedSequence(anim.TPAnim)
        if aseq then
            self:GetOwner():AddVCDSequenceToGestureSlot( GESTURE_SLOT_ATTACK_AND_RELOAD, aseq, anim.TPAnimStartTime or 0, true )
            if !game.SinglePlayer() and SERVER then
                net.Start("arccw_networktpanim")
                    net.WriteEntity(self:GetOwner())
                    net.WriteUInt(aseq, 16)
                    net.WriteFloat(anim.TPAnimStartTime or 0)
                net.SendPVS(self:GetOwner():GetPos())
            end
        end
    end

    if !(game.SinglePlayer() and CLIENT) and (game.SinglePlayer() or IsFirstTimePredicted() or self.ReadySoundTableHack) then
        self:PlaySoundTable(anim.SoundTable or {}, 1 / mult, startfrom, key)
        self.ReadySoundTableHack = nil
    end

    if seq then
        vm:SendViewModelMatchingSequence(seq)
        local dur = vm:SequenceDuration()
        vm:SetPlaybackRate(math.Clamp(dur / (ttime + startfrom), -4, 12))
        self.LastAnimStartTime = ct
        self.LastAnimFinishTime = ct + dur
        self.LastAnimKey = key
    end

    -- Grabs the current angle of the cam attachment bone and use it as the common offset for all cambone changes.
    -- Problem: If this animation interrupted a previous animation with cambone movement,
    -- it will start with an incorrect offset and snap at the end.
    -- Therefore this now only ever sets it once.
    local att = self:GetBuff_Override("Override_CamAttachment", self.CamAttachment)
    if att and vm:GetAttachment(att) and (anim.ForceCamReset or self.Cam_Offset_Ang == nil) then
        local ang = vm:GetAttachment(att).Ang
        ang = vm:WorldToLocalAngles(ang)
        self.Cam_Offset_Ang = Angle(ang)
    end

    self:SetNextIdle(CurTime() + ttime)

    return true
end

function SWEP:PlayIdleAnimation(pred)
    local ianim = self:SelectAnimation("idle")
    if self:GetGrenadePrimed() then
        ianim = self:GetGrenadeAlt() and self:SelectAnimation("pre_throw_hold_alt") or self:SelectAnimation("pre_throw_hold")
    end

    -- (key, mult, pred, startfrom, tt, skipholster, ignorereload)
    if self:GetBuff_Override("UBGL_BaseAnims") and self:GetInUBGL()
            and self.Animations.idle_ubgl_empty and self:Clip2() <= 0 then
        ianim = "idle_ubgl_empty"
    elseif self:GetBuff_Override("UBGL_BaseAnims") and self:GetInUBGL() and self.Animations.idle_ubgl then
        ianim = "idle_ubgl"
    end

    if self.LastAnimKey ~= ianim then
        ianim = self:GetBuff_Hook("Hook_IdleReset", ianim) or ianim
    end

    self:PlayAnimation(ianim, 1, pred, nil, nil, nil, true)
end

function SWEP:GetAnimKeyTime(key, min)
    if !self:GetOwner() then return 1 end

    local anim = self.Animations[key]

    if !anim then return 1 end

    if self:GetOwner():IsNPC() then return anim.Time or 1 end

    local vm = self:GetOwner():GetViewModel()

    if !vm or !IsValid(vm) then return 1 end

    local t = anim.Time
    if !t then
        local tseq = anim.Source

        if istable(tseq) then
            tseq["BaseClass"] = nil -- god I hate Lua inheritance
            tseq = tseq[1]
        end

        if !tseq then return 1 end
        tseq = vm:LookupSequence(tseq)

        -- to hell with it, just spits wrong on draw sometimes
        t = vm:SequenceDuration(tseq) or 1
    end

    if min and anim.MinProgress then
        t = anim.MinProgress
    end

    if anim.Mult then
        t = t * anim.Mult
    end

    return t
end

if CLIENT then
    net.Receive("arccw_networktpanim", function()
        local ent = net.ReadEntity()
        local aseq = net.ReadUInt(16)
        local starttime = net.ReadFloat()
        if IsValid(ent) and ent ~= LocalPlayer() and ent:IsPlayer() then
            ent:AddVCDSequenceToGestureSlot( GESTURE_SLOT_ATTACK_AND_RELOAD, aseq, starttime, true )
        end
    end)
end

function SWEP:QueueAnimation() end
function SWEP:NextAnimation() end

--addons/arccw_weapons/lua/weapons/arccw_blaster_dt12.lua:
AddCSLuaFile()
SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "DT-12"
SWEP.Trivia_Class = "Modular Blaster"
SWEP.Trivia_Desc = "High tech verstile modular blaster base, suited for allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"

SWEP.ViewModel = "models/arccw/ser/starwars/v_dt12.mdl"
SWEP.WorldModel = "models/arccw/ser/starwars/w_dt12.mdl"
SWEP.IconOverride = ""
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "111"
SWEP.DefaultWMBodygroups = "111"
SWEP.DefaultSkin = 0
SWEP.DefaultWMSkin = 0

SWEP.NoHideLeftHandInCustomization = false

SWEP.Damage = 21
SWEP.DamageMin = 14 -- damage done at maximum range
SWEP.DamageRand = 0 -- damage will vary randomly each shot by this fraction
SWEP.RangeMin = 55 -- how far bullets will retain their maximum damage for
SWEP.Range = 200 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false -- set to true to have the base not do anything with damage types
-- this includes: igniting if type has DMG_BURN; adding DMG_AIRBOAT when hitting helicopter; adding DMG_BULLET to DMG_BUCKSHOT

SWEP.MuzzleVelocity = 400 -- projectile muzzle velocity in m/s

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 3 -- color for phys tracer.

SWEP.TracerNum = 1 -- tracer every X
SWEP.TracerFinalMag = 0 -- the last X bullets in a magazine are all tracers
SWEP.Tracer = "tfa_tracer_red" -- override tracer (hitscan) effect
SWEP.TracerCol = Color(255, 0, 0)
SWEP.HullSize = 2 -- HullSize used by FireBullets

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 15 -- DefaultClip is automatically set.

SWEP.AmmoPerShot = 1

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.Recoil = 0.2
SWEP.RecoilSide = 0.15
SWEP.RecoilRise = 0.2
SWEP.VisualRecoilMult = 2
SWEP.RecoilPunch = 1.4
SWEP.RecoilPunchBackMax = 0.9

SWEP.RecoilDirection = Angle(1.1, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1.1, 0)

SWEP.Delay = 60 / 330 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 2 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace

SWEP.AccuracyMOA = 2 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 330 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 65 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 85 -- dispersion that remains even in sights
SWEP.JumpDispersion = 200 -- dispersion penalty when in the air

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "ar2" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 50 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "w/dt12/dt12shoot2.wav"
SWEP.ShootSoundSilenced = "w/dc19.wav"
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"


SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(255, 0, 0)

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1

SWEP.IronSightStruct = {
    Pos = Vector(-1.85, -0, .85),
    Ang = Angle(0, 0, 3),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1,
    SwitchToSound = "zoom_in/gunfoley_zoomin_blasterpistol_04.mp3",
    CrosshairInSights = false,
}


SWEP.SightTime = 0.13
SWEP.SprintTime = 0
-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "unjam" animation
-- if no "unjam", "fix", or "cycle" animations exist, the weapon will reload instead
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.
SWEP.MalfunctionTakeRound = true -- When malfunctioning, a bullet is consumed.
SWEP.MalfunctionWait = 0.5 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMean = nil -- The mean number of shots between malfunctions, will be autocalculated if nil
SWEP.MalfunctionVariance = 0.25 -- The fraction of mean for variance. e.g. 0.2 means 20% variance
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.CanBash = true
SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.SprintPos = Vector(5, -10,-10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.ActivePos = Vector(0, 0, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.CustomizePos = Vector(15.824, -10, 5.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.BarrelLength = 24

SWEP.SightPlusOffset = true

SWEP.DefaultElements = {}

SWEP.AttachmentElements = {
    ["nil"] = {
        VMElements = {
            {
                Model = "models/arccw/props/e11r_scope/e11r_scope.mdl",
                Bone = "weapon",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0.05, -2.85, 0.8),
                    ang = Angle(-0.3, 0, -90)
                }
            }
        },
        WMElements = { -- Purely handles muzzle effect on the world model
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(20, 0.5, -8),
                    ang = Angle(0, 0, 0)
                },
                IsMuzzleDevice = true
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}


SWEP.Attachments = {
	[1] = {
		PrintName = "Optic", -- print name
		DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
		Slot = "optic_lp",
        DefaultEles = {"ironsight"},
		Bone = "optic", -- relevant bone any attachments will be mostly referring to
		Offset = {
            vpos = Vector(0, -0.45, 1),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1.25, -4.8),
            wang = Angle(-10, 2, 180)
        },
        NoWM = false
	},
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical", "tac_pistol"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.4, 0, 5.6),
            vang = Angle(90, 00, 180),
            wpos = Vector(8, 0.7, -4.5),
            wang = Angle(-10, 2, 90)
        },
        NoWM = false
    },
    [3] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.65, 1.2, 1.2),
            vang = Angle(90, 0, -90),
            wpos = Vector(3.5, 1.8, -2.5),
            wang = Angle(0, 0, 180)
        },
    },
    [4] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        Bone = "optic", -- relevant bone any attachments wwill be mostly referring to /
        Offset = {
            vpos = Vector(-0, 0.4, 5.2),
            vang = Angle(90, 0, -90),         
        },
        NoWM = true,        -- Set this to false if you want the foregrips to display on ViewModels.          
    },
    [5] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = {"ammo", "sw_ammo"},
    },
    [6] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [7] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0, -.05, 7.1),
            vang = Angle(90, 0, -90),
            wpos = Vector(10.5, 1.1, -5.1),
            wang = Angle(-12, 2.4, 180) 
        },
    },                              
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sights"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },
    ["enter_sight"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },
    ["exit_sight"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },  
	["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
		SoundTable = {
	        {
				s = "w/dc15s/overheat_manualcooling_resetfoley_generic_var_03.mp3", -- sound; can be string or table
				p = 100, -- pitch
				v = 100, -- volume
				t = 0.1, -- time at which to play relative to Animations.Time
				c = CHAN_ITEM, -- channel to play the sound
			},
			{
				s = "w/dt12/sw01_characters_gunfoley_draw_blaster_var11.mp3", -- "everfall/weapons/miscellaneous/charge/blasters_deathray_charge_start_var_04.mp3"sound; can be string or table
				p = 100, -- pitch
				v = 100, -- volume
				t = 1.1, -- time at which to play relative to Animations.Time
				c = CHAN_ITEM, -- channel to play the sound
			},
		}
    },
	["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "w/dt12/gunfoley_pistol_draw_var_11.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
	["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dt12/gunfoley_pistol_sheathe_var_01.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}
--addons/arccw_weapons/lua/weapons/arccw_dc15s_stun_v2.lua:
AddCSLuaFile()
SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "DC-15s (Stun)"
SWEP.Trivia_Class = "Modular Blaster"
SWEP.Trivia_Desc = "High tech verstile modular blaster base, suited for allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"

SWEP.ViewModel = "models/meeks/c_dc15s_meek.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_dc15s_v2.mdl"
SWEP.IconOverride = "materials/entities/rw_sw_stun_dc15s.png"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "111"
SWEP.DefaultWMBodygroups = "111"
SWEP.DefaultSkin = 0
SWEP.DefaultWMSkin = 0

SWEP.NoHideLeftHandInCustomization = false

SWEP.Damage = 27
SWEP.DamageMin = 14 -- damage done at maximum range
SWEP.DamageRand = 0 -- damage will vary randomly each shot by this fraction
SWEP.RangeMin = 100 -- how far bullets will retain their maximum damage for
SWEP.Range = 300 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false -- set to true to have the base not do anything with damage types
-- this includes: igniting if type has DMG_BURN; adding DMG_AIRBOAT when hitting helicopter; adding DMG_BULLET to DMG_BUCKSHOT

SWEP.MuzzleVelocity = 400 -- projectile muzzle velocity in m/s

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 3 -- color for phys tracer.

SWEP.TracerNum = 1 -- tracer every X
SWEP.TracerFinalMag = 0 -- the last X bullets in a magazine are all tracers
SWEP.Tracer = "tfa_tracer_blue" -- override tracer (hitscan) effect
SWEP.TracerCol = Color(0, 47, 255)
SWEP.HullSize = 2 -- HullSize used by FireBullets

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 20 -- DefaultClip is automatically set.

SWEP.AmmoPerShot = 1

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.15
SWEP.RecoilRise = 0.53
SWEP.VisualRecoilMult = 2
SWEP.RecoilPunch = 1.4
SWEP.RecoilPunchBackMax = 0.9

SWEP.RecoilDirection = Angle(1.1, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1.1, 0)

SWEP.Delay = 60 / 330 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 2 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
	{
		Mode = 2,
   	},
    {
		Mode = 1,
    },
	{
		Mode = 0,
   	}
}

SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace

SWEP.AccuracyMOA = 5 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 410 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 65 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 130 -- dispersion that remains even in sights
SWEP.JumpDispersion = 200 -- dispersion penalty when in the air

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "ar2" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 50 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "dc15s/blasters_dc15_laser_close_var_02.mp3"
SWEP.ShootSoundSilenced = "w/dc19.wav"
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"


SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 102, 255)

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1

SWEP.IronSightStruct = {
    Pos = Vector(-2.85, -2, 2.25),
    Ang = Angle(0, 0, -0.5),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 0, 0),
        Ang = Angle(0, 0, 0),
    },
    Magnification = 1,
    CrosshairInSights = false,
}


SWEP.SightTime = 0.13
SWEP.SprintTime = 0
-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "unjam" animation
-- if no "unjam", "fix", or "cycle" animations exist, the weapon will reload instead
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.
SWEP.MalfunctionTakeRound = true -- When malfunctioning, a bullet is consumed.
SWEP.MalfunctionWait = 0.5 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMean = nil -- The mean number of shots between malfunctions, will be autocalculated if nil
SWEP.MalfunctionVariance = 0.25 -- The fraction of mean for variance. e.g. 0.2 means 20% variance
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.CanBash = true
SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.SprintPos = Vector(6, -4, 0)
SWEP.SprintAng = Angle(-16.524, 60, -11.046)

SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.CustomizePos = Vector(10.824, -7, 4.897)
SWEP.CustomizeAng = Angle(12.149, 45.547, 45)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.BarrelLength = 24

SWEP.SightPlusOffset = true

SWEP.DefaultElements = {}

SWEP.AttachmentElements = {
    ["nil"] = {
        VMElements = {
            {
                Model = "models/arccw/props/e11r_scope/e11r_scope.mdl",
                Bone = "weapon",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(0.05, -2.85, 0.8),
                    ang = Angle(-0.3, 0, -90)
                }
            }
        },
        WMElements = { -- Purely handles muzzle effect on the world model
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(20, 0.5, -8),
                    ang = Angle(0, 0, 0)
                },
                IsMuzzleDevice = true
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}


SWEP.Attachments = {
	[1] = {
		PrintName = "Optic", -- print name
		DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
		Slot = "optic",
        DefaultEles = {"ironsight"},
		Bone = "DC15", -- relevant bone any attachments will be mostly referring to
		Offset = {
            vpos = Vector(0.02, -1.5, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1.5, -5),
            wang = Angle(-10, 2, 180)
        },
        NoWM = false
	},
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical", "tac_pistol"},
        Bone = "DC15", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(.9, -0.5, 6),
            vang = Angle(90, 0, -0),
            wpos = Vector(14, 2, -5.5),
            wang = Angle(-10, 5, -90)
        },
        NoWM = false
    },
    [3] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "DC15", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.9, 0, -3.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(6, 1.8, -4.5),
            wang = Angle(0, 0, 180)
        },
    },
    [4] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        Bone = "DC15", -- relevant bone any attachments wwill be mostly referring to /
        Offset = {
            vpos = Vector(-0, 0.2, 2.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(9, .5, 2),
            wang = Angle(0, 0, 180)            
        },
        SlideAmount = {
        vmin = Vector(-0, 0.2, 2),
        vmax = Vector(-0, 0.2, 6),
        wmin = Vector(14, 1, -4.5), 
        wmax = Vector(14, 1, -4.5) -- how far this attachment can slide in both directions.
        },          -- Set this to false if you want the foregrips to display on ViewModels.          
    },
    [5] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = {"ammo", "sw_ammo"},
    },
    [6] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [7] = {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"dc15a_magazine_75"},
        Bone = "Magazine", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(2, 0.7, -1.6),
            vang = Angle(180, 0, 0),
            wpos = Vector(9.5, 1.5, -3.8),
            wang = Angle(80, 90, 0) 
        },
    },
    [8] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle"},
        Bone = "DC15", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, -0.5, 11.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(20, 1, -6.5),
            wang = Angle(-12, 0.5, 180) 
        },
    },                              
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sights"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },
    ["enter_sight"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },
    ["exit_sight"] = {
        Source = "neutral",
        Time = 0, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    },  
	["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
		SoundTable = {
	        {
				s = "dc15s/overheat_manualcooling_resetfoley_generic_var_03.mp3", -- sound; can be string or table
				p = 100, -- pitch
				v = 100, -- volume
				t = 0.1, -- time at which to play relative to Animations.Time
				c = CHAN_ITEM, -- channel to play the sound
			},
			{
				s = "dc15s/overheat_reset_var_02.mp3", -- "everfall/weapons/miscellaneous/charge/blasters_deathray_charge_start_var_04.mp3"sound; can be string or table
				p = 100, -- pitch
				v = 100, -- volume
				t = 1.1, -- time at which to play relative to Animations.Time
				c = CHAN_ITEM, -- channel to play the sound
			},
		}
    },
	["draw"] = {
        Source = "draw",
        Mult = 1.5,
        SoundTable = {
            {
                s = "dc15s/overheat_manualcooling_resetfoley_generic_var_01.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
	["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}
--addons/arccw_weapons/lua/weapons/arccw_dc17m_sniper_v2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "DC-17m Sniper"
SWEP.Trivia_Class = "Blaster Rifle"
SWEP.Trivia_Desc = "High tech DC-17m Blaster Rifle, preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/meeks/viewmodels/c_dc17m_sniper.mdl"
SWEP.WorldModel = "models/meeks/worldmodels/w_DC-17m_sniper.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(-26, 11, -4),
    ang = Angle(170, 180, 0),
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.IconOverride = "materials/entities/rw_sw_dc17m_sniper.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "0120000000"

SWEP.Damage = 150
SWEP.RangeMin = 200
SWEP.DamageMin = 63
SWEP.Range = 950
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 5

SWEP.Recoil = 0.5
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.18

SWEP.Delay = 60 / 210
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.52 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50
----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100


SWEP.DistantShootSound = "shared/snipers/Shared_Corebass_Close_Sniper_VAR_03 0 1 0.ogg"
SWEP.ShootSound = "dc17m/dc17msniper.wav"
SWEP.ShootSoundSilenced = "w/dc19.wav"

SWEP.NoFlash = nil -- disable light flash
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects

SWEP.MuzzleEffectAttachment = "1" -- which attachment to put the muzzle on
SWEP.ProceduralViewBobAttachment = 1 -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-6.53, -8, 0.9),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterheavy_01.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(2.5, -2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"", ""}

SWEP.AttachmentElements = {
    ["dc17m_sniper_ext_v2"] = {
        VMBodygroups = {{ind = 2, bg = 3}},
    },
}

--SWEP.Attachments 
SWEP.Attachments = {
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        Bone = "optic", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(0.05, -0, 7.65),
            vang = Angle(90, 0, -90),
            wpos = Vector(7, 1.5, -7),
            wang = Angle(-10, 0, 180)
        },
        -- CorrectiveAng = Angle(-2.4, -0, 0)
    },
    {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"foregrip"},
        Bone = "optic", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.2, 4.8, 6.5),
            vang = Angle(90, 0, -90),
            wpos = Vector(10, 1.5, -3),
            wang = Angle(170, 180, 0),
        },
    },          
    {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol","tac"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.5, 0.75, 12),
            vang = Angle(90, 0, 30),
            wpos = Vector(16, 3, -8),
            wang = Angle(-10, 0, -60)
        },
    },
    {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.05, 1.15, 19.45),
            vang = Angle(90, 0, -90),
        },
    },    
    {
        PrintName = "Magazine", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"dc17m_sniper_ext_v2"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, 2.3, -3),
            vang = Angle(0, 0, 0),
        },
    },         
    {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1.4, 1.6, 2),
            vang = Angle(90, 0, -70),
            wpos = Vector(6, 3, -5),
            wang = Angle(-10 , 0, 180)
        },
    },    
    {
        PrintName = "Killcounter", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = {"killcounter"},
        WMScale = Vector(111, 111, 111),
        Bone = "optic", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(1, 2, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(675, 90, -400),
            wang = Angle(-15 , 0, 180)
        },
    },   
    {
        PrintName = "Grip", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "grip",
    },     
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "Fire"
    },
    ["draw"] = {
        Source = "Draw",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "Holster",
        SoundTable = {
            {
                s = "draw/gunfoley_blaster_draw_var_08.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "Reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        SoundTable = {
            --{s = "viper/weapons/sierra552/wfoly_ar_sierra552_reload_xmag_fast_empty_end.ogg", t = 20 / 60},
            {s = "dc17m/reload/SW02_Weapons_Overheat_ManualCooling_VAR_04 0 0 0.ogg", v = 10 , t = 23 / 60},
            {s = "dc17m/reload/magin.ogg", t = 115 / 60},
            {s = "dc17m/reload/maghit.ogg", t = 132 / 60},
            {s = "dc17m/reload/SCIMisc_Ammo Replenish_01.ogg", t = 139 / 60} --s sound file
        },
    },
}


-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 200
SWEP.DamageMin = 100
SWEP.RangeMin = 600
SWEP.Range = 1544
SWEP.Delay = 60 / 120
SWEP.Primary.ClipSize = 15
SWEP.Category = 'REP'
--addons/arccw_weapons/lua/weapons/arccw_defender_sporting.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Zivilisten"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "[P] Defender Sporting"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "A Blaster pistol for shooting enviroments"
SWEP.Trivia_Manufacturer = "Drearian Defense Conglomerate"
SWEP.Trivia_Calibre = "Low Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_defender.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 80
SWEP.DamageMin = 14
SWEP.Range = 300
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_yellow"
SWEP.TracerCol = Color(255, 165, 18)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.34
SWEP.RecoilPunch = 0.4
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17

SWEP.Delay = 60 / 300
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.22 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 530 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(255, 165, 18)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/defender.wav"
SWEP.IronSightStruct = {
    Pos = Vector(-3.945, -8, 2.1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "zoom_in/gunfoley_zoomin_blasterpistol_04.mp3",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -4, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -10,-20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(20.824, -16, 4.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"defendersporting"}

SWEP.AttachmentElements = {
    ["defendersporting"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/defender_sporting_pistol.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(0, 0, 0),
                    ang = Angle(0, 90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/defender_sporting_pistol.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(40, 20, -15.3),
                    ang = Angle(-15, 0, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/sw_battlefront/weapons/defender_sporting_pistol.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "swoptic_module",
        VMScale = Vector(0.8, 0.8, 0.8),
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0, -2, 2),
            vang = Angle(0, 180, 0),
            wpos = Vector(70, 20, -40),
            wang = Angle(-15, 90, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment",
        VMScale = Vector(0.8, 0.8, 0.8), -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(9, 9, 9),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, -5, 1.3),
            vang = Angle(0, 90, 0),
            wpos = Vector(80, 20, -38),
            wang = Angle(-15, 0, 180)
        },
    },    
    [5] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(8, 8, 8),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.35, 0.9, 1),
            vang = Angle(90, 0, -90),
            wpos = Vector(60, 22, -35),
            wang = Angle(-10, 0, 180)
        },
    },          
}    



SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 1 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_flash_grenade.lua:
SWEP.Base = "arccw_grenade_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "Flash Grenade"
SWEP.Trivia_Class = "Hand Grenade"
SWEP.Trivia_Desc = "Standard explosive ordnance with a timed fuse and a large blast radius."

SWEP.Slot = 4

SWEP.CamAttachment = 3

SWEP.NotForNPCs = true

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/nade_frag.mdl"
SWEP.WorldModel = "models/weapons/w_nade_frag.mdl"
SWEP.HideViewmodel = true
SWEP.MirrorVMWM = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/flash_grenade_meeks.png"


SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "fcg.nade",
    },
}

SWEP.FuseTime = 1.5

SWEP.Primary.Ammo = "grenade"

SWEP.Primary.ClipSize = 1

SWEP.MuzzleVelocity = 1300
SWEP.MuzzleVelocityAlt = 500
SWEP.ShootEntity = "arccw_thr_flash"

SWEP.PullPinTime = 0.5

SWEP.ViewModelFOV = 70

SWEP.DefaultElements = {"flash_grenade"}

SWEP.AttachmentElements = {
    ["flash_grenade"] = {
        VMElements = {
            {
                Model = "models/arccw/meeks/flash_grenade.mdl",
                Bone = "def_c_base",
                Scale = Vector(.9, .9, .9),
                Offset = {
                    pos = Vector(-0.4, -.4, 0.2),
                    ang = Angle(-0, 0, -90)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/meeks/flash_grenade.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.8, 0.8, 0.8),
                Offset = {
                    pos = Vector(35, 25, 0),
                    ang = Angle(0, 0, 0)
                }
            }
        },
    },
}

WMOverride = "models/arccw/meeks/flash_grenade.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {Source = "sprint", Mult = 0.9},
    ["enter_sprint"] = {Source = "sprint_in", Mult = 0.1},
    ["exit_sprint"] = {Source = "sprint_out", Mult = 0.1},
    ["ready"] = {
        Source = "draw",
        SoundTable = {
           {s = "ArcCW_ThermalDet.firstdeploy1", t = 0 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = "misc/gunfoley_blaster_sheathe_var_03.mp3", t = 0 / 30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = "ArcCW_ThermalDet.holster1", t = 0 / 30}
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_primer.button", t = 0 / 30},
        },
        MinProgress = 0.5,
    },
    ["fire"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_primer.button", t = 0 / 30},
        },
    },
    ["throw"] = {
        Source = {"toss_overhead"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
    },
    ["throw_alt"] = {
        Source = {"underhand"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
    },
    ["enter_inspect"] = {
        Source = "inspect_in",
        LHIK = true,
    },
    ["exit_inspect"] = {
        Source = "inspect_out",
        LHIK = true,
    },
    ["idle_inspect"] = {
        Source = "inspect",
        LHIK = true,
    },

sound.Add({
    name =          "ArcCW_ThermalDet.holster1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/sw01_characters_gunfoley_draw_blaster_var21.mp3"
    }),
    
sound.Add({
    name =          "ArcCW_ThermalDet.deploy1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/gunfoley_blaster_sheathe_var_03.mp3"
    }),
       
sound.Add({
    name =          "ArcCW_ThermalDet.firstdeploy1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/sw01_characters_gunfoley_draw_blaster_var19.mp3"
    }),
        
sound.Add({
    name =          "ArcCW_Flash1.explosion1",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "misc/BEEPTimer_Anticipation Beeps_01.wav"
    }),

sound.Add({
    name =          "ArcCW_primer.button",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/buttonpress.mp3"
    }),

sound.Add({
    name =          "ArcCW_Underhand.explosion2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "w/underhand.mp3"
    }),
}
--addons/arccw_weapons/lua/weapons/arccw_kraken_dc17m.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "DC-17m"
SWEP.Trivia_Class = "Interchangeable Weapon System"
SWEP.Trivia_Desc = "The DC-17m Interchangeable Weapon System, also known as the DC-17m Repeating Blaster Rifle, or DC-17M ICWS, was a type of repeating blaster rifle used by Republic clone commandos during the Clone Wars. It could change between a repeating blaster rifle and grenade launcher by switching the weapon's barrel module. The weapon was also used by pirates from Hondo Ohnaka's gang."
SWEP.Trivia_Manufacturer = "BlastTech Industries"
SWEP.Trivia_Calibre = "Laser Bolt"
SWEP.Trivia_Mechanism = "Tibanna Gas"
SWEP.Trivia_Country = "Galactic Republic, Galactic Empire"
SWEP.Trivia_Year = 2024
SWEP.IconOverride = "entities/dc17m.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.MirrorVMWM = true
SWEP.ViewModel = "models/arccw/kraken/v_dc17m_modular.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(-13.4, 7, -3.6),
    ang = Angle(-15, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Damage and things

SWEP.Damage = 39
SWEP.DamageMin = 23
SWEP.RangeMin = 0
SWEP.Range = 400
SWEP.Penetration = 2
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800

SWEP.BodyDamageMults = {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.15,
    [HITGROUP_STOMACH] = 1.1,
    [HITGROUP_LEFTARM] = 1,
    [HITGROUP_RIGHTARM] = 1,
    [HITGROUP_LEFTLEG] = 0.75,
    [HITGROUP_RIGHTLEG] = 0.75,
}

SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.ChamberSize = 0
SWEP.HullSize = 1
SWEP.Primary.ClipSize = 100

SWEP.Recoil = 0.75
SWEP.RecoilSide = 0.3
SWEP.RecoilRise = 1

SWEP.Delay = 60 / 480
SWEP.Num = 1
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 2 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 300 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 150

-- Speed Mult
SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.80
SWEP.SightTime = 0.3

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "arccw/kraken/dc17m/normal.mp3"
SWEP.ShootSound = "arccw/kraken/dc17m/normal.mp3"
SWEP.ShootSoundSilenced = "arccw/kraken/dc17m/silenced.wav"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-6.512, -8.598, -1),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "weapon_hand/ads/0242-00001a48.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a47.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {}
SWEP.AttachmentElements = {
    ["17m_module_sniper"] = {
        NameChange = "Sniper DC-17m",
        VMBodygroups = {{ind = 1, bg = 3}},
        AttPosMods = {
            [4] = {
                vpos = Vector(0.1, -42, -0.8),
            },
            [5] = {
                vpos = Vector(2.4, -14, -0.3),
            },
        }
    },
--    ["17m_module_antitank"] = { -- coming soon
--       NameChange = "Anti-Tank DC-17m",
--        VMBodygroups = {{ind = 1, bg = 1}},
--        AttPosMods = {
--            [2] = {
--                vpos = Vector(00, -1.3, 31.7),
--            },
--        }
--    },
    ["17m_module_shotgun"] = {
        NameChange = "Shotgun DC-17m",
        VMBodygroups = {{ind = 1, bg = 2}},
        AttPosMods = {
            [3] = {
                vpos = Vector(0.06, -12, -3.4),
            },
            [4] = {
                vpos = Vector(0.1, -21, -1.6),
            },
        }
    },
    ["17m_mag_drum"] = {
        VMBodygroups = {{ind = 2, bg = 2}},
        AttPosMods = {
            [2] = {
                vpos = Vector(00, -1.3, 31.7),
            },
        }
    },
    ["17m_mag_extended"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
        AttPosMods = {
            [2] = {
                vpos = Vector(00, -1.3, 31.7),
            },
        }
    },
    ["17m_mag_sniper"] = {
        VMBodygroups = {{ind = 2, bg = 3}},
        AttPosMods = {
            [2] = {
                vpos = Vector(00, -1.3, 31.7),
            },
        }
    },
    ["17m_mag_sniper_ext"] = {
        VMBodygroups = {{ind = 2, bg = 4}},
        AttPosMods = {
            [2] = {
                vpos = Vector(00, -1.3, 31.7),
            },
        }
    },
}

SWEP.Attachments = {
    {
        PrintName = "Energiemodus",
        DefaultAttName = "Standard",
        Slot = "aocrp_ammo",
    },  
    {
        PrintName = "Module",
        DefaultAttName = "Standard",
        Slot = {"17m_module"},
    }, 
    {
        PrintName = "Magazine",
        DefaultAttName = "Standard",
        Slot = {"17m_mag"},
    }, 
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        Bone = "DC-17M",
        Offset = {
            vpos = Vector(0.06, -5, -1.6),
            vang = Angle(0, 90, 180),
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, 0)
    }, 
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "DC-17M", 
        Offset = {
            vpos = Vector(0.1, -20, -0.9),
            vang = Angle(0, 90, -90),
        },
    },      
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.8, 0.8, 0.8),
        Bone = "DC-17M", 
        Offset = {
            vpos = Vector(1.7, -13, 0.1),
            vang = Angle(0, 90, -90),
        },
    },
    {
        PrintName = "Internal Compression",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
    },    
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "DC-17M",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(1.3, -1, -0.2),
            vang = Angle(0, 90, 200),
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "DC-17M",
        Offset = {
            vpos = Vector(1.45, -3.7, -0.2),
            vang = Angle(0, 90, 200),
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "arccw/kraken/dc17m/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "arccw/kraken/dc17m/holster.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "weapon_hand/reload_heavy/mag_eject/023d-00000080.mp3", t = 10 / 60},
            {s = "weapon_hand/reload_gentle/mag_load/023d-00000648.mp3", t = 90 / 60},
            {s = "weapon_hand/reload_gentle/mag_load/023d-00000668.mp3", t = 110 / 60},
        },
    },
}


-- AOCRP WAFFENSTATS 02.06.2024
SWEP.Damage = 39
SWEP.DamageMin = 23
SWEP.RangeMin = 0
SWEP.Range = 400
SWEP.Delay = 60 / 480
SWEP.Primary.ClipSize = 100
SWEP.Category = 'REP'
--addons/arccw_weapons/lua/weapons/arccw_meeks_sw_base.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = false -- this obviously has to be set to true

// names and stuff
SWEP.PrintName = "Meek's SW ArcCW Base"
SWEP.Category = "[ Meeks ] ArcCW Blasters"

SWEP.Description = ""

SWEP.ViewModel = ""
SWEP.WorldModel = ""

SWEP.ViewModelFOV = 60

SWEP.MirrorVMWM = nil -- Copy the viewmodel, along with all its attachments, to the worldmodel. Super convenient!
SWEP.MirrorWorldModel = nil -- Use this to set the mirrored viewmodel to a different model, without any floating speedloaders or cartridges you may have. Needs MirrorVMWM

--[[SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1
}]]

SWEP.PresetBase = nil -- make this weapon share saves with this one.

SWEP.KillIconAlias = nil -- set to other weapon class to share select and kill icons

SWEP.DefaultBodygroups = "00000000"
SWEP.DefaultWMBodygroups = "00000000"
SWEP.DefaultSkin = 0
SWEP.DefaultWMSkin = 0

SWEP.WorldModelOffset = nil
-- {
--     pos = Vector(0, 0, 0),
--     ang = Angle(0, 0, 0)
-- }

SWEP.NoHideLeftHandInCustomization = false

SWEP.Damage = 26
SWEP.DamageMin = 10 -- damage done at maximum range
SWEP.DamageRand = 0 -- damage will vary randomly each shot by this fraction
SWEP.RangeMin = 0 -- how far bullets will retain their maximum damage for
SWEP.Range = 200 -- in METRES
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.DamageTypeHandled = false -- set to true to have the base not do anything with damage types
-- this includes: igniting if type has DMG_BURN; adding DMG_AIRBOAT when hitting helicopter; adding DMG_BULLET to DMG_BUCKSHOT

SWEP.ShootEntity = nil -- entity to fire, if any
SWEP.MuzzleVelocity = 400 -- projectile muzzle velocity in m/s
SWEP.PhysBulletMuzzleVelocity = nil -- override phys bullet muzzle velocity
SWEP.PhysBulletDrag = 1
SWEP.PhysBulletGravity = 1
SWEP.PhysBulletDontInheritPlayerVelocity = true

SWEP.BodyDamageMults = nil
-- if a limb is not set the damage multiplier will default to 1
-- that means gmod's stupid default limb mults will **NOT** apply
-- {
--     [HITGROUP_HEAD] = 1.25,
--     [HITGROUP_CHEST] = 1,
--     [HITGROUP_LEFTARM] = 0.9,
--     [HITGROUP_RIGHTARM] = 0.9,
-- }

SWEP.AlwaysPhysBullet = false
SWEP.NeverPhysBullet = false
SWEP.PhysTracerProfile = 0 -- color for phys tracer.
-- there are 8 options:
-- 0 = normal
-- 1 = red
-- 2 = green
-- 3 = blue
-- 4 = yellow
-- 5 = violet
-- 6 = cyan
-- 7 = black/invisible
SWEP.HullSize = 1.5 -- HullSize used by FireBullets

function SWEP:DoImpactEffect(tr, dmgtype)
    if tr.HitSky then return true end

    util.Decal("fadingscorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal);
    if( game.SinglePlayer() or SERVER or not self:IsCarriedByLocalPlayer() or IsFirstTimePredicted() ) then
        local soundToPlay = "impacts/sw752_hit_1.wav"
        local randomSound = math.random(1,14)
        if randomSound == 1 then
            soundToPlay = "impacts/sw752_hit_4.wav"
        elseif randomSound == 2 then
            soundToPlay = "impacts/sw752_hit_5.wav"
        elseif randomSound == 3 then
            soundToPlay = "impacts/.wav"
        elseif randomSound == 4 then
            soundToPlay = "impacts/sw752_hit_9.wav"
        elseif randomSound == 5 then
            soundToPlay = "impacts/sw752_hit_10.wav"
        elseif randomSound == 6 then
            soundToPlay = "impacts/sw752_hit_12.wav"
        elseif randomSound == 7 then
            soundToPlay = "impacts/sw752_hit_13.wav"
        elseif randomSound == 8 then
            soundToPlay = "impacts/sw752_hit_14.wav"
        elseif randomSound == 9 then
            soundToPlay = "impacts/sw752_hit_19.wav"
        elseif randomSound == 10 then
            soundToPlay = "impacts/sw752_hit_27.wav"
        elseif randomSound == 11 then
            soundToPlay = "impacts/sw752_hit_28.wav"
        elseif randomSound == 12 then
            soundToPlay = "impacts/sw752_hit_30.wav"
        elseif randomSound == 13 then
            soundToPlay = "impacts/sw752_hit_31.wav"
        elseif randomSound == 14 then
            soundToPlay = "impacts/sw752_hit_17.wav"
        end

    
        local effect = EffectData()
        effect:SetOrigin(tr.HitPos)
        effect:SetNormal(tr.HitNormal)

        -- util.Effect( "effect_astw2_swbf_impact", effect );
        sound.Play( soundToPlay, tr.HitPos, 75, 100, 1 );

        local effect = EffectData()
        effect:SetOrigin(tr.HitPos)
        effect:SetStart(tr.StartPos)
        effect:SetDamageType(dmgtype)

        util.Effect("RagdollImpact", effect)
    end

    return true;
end

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 25 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 50
SWEP.ReducedClipSize = 10

-- But if you insist...
SWEP.ForceDefaultClip = nil
SWEP.ForceDefaultAmmo = nil

-- The amount of rounds to load in the chamber when the gun is non-empty or empty
-- Defaults to ChamberSize and 0. Don't change unless you have a good reason
SWEP.ChamberLoadNonEmpty = nil
SWEP.ChamberLoadEmpty = nil

SWEP.AmmoPerShot = 1
SWEP.InfiniteAmmo = false -- weapon can reload for free
SWEP.BottomlessClip = false -- weapon never has to reload

SWEP.DoNotEquipmentAmmo = false -- do not automatically give this weapon unique ammo when arccw_equipmentammo is used

SWEP.ShotgunReload = false -- reloads like shotgun instead of magazines
SWEP.HybridReload = false -- reload normally when empty, reload like shotgun when part full

SWEP.ManualAction = false -- pump/bolt action
SWEP.NoLastCycle = false -- do not cycle on last shot

SWEP.RevolverReload = false -- cases all eject on reload

SWEP.ReloadInSights = false
SWEP.ReloadInSights_CloseIn = 0.25
SWEP.ReloadInSights_FOVMult = 0.875
SWEP.LockSightsInReload = false

SWEP.CanFireUnderwater = false

SWEP.Disposable = false -- when all ammo is expended, the gun will remove itself when holstered

SWEP.AutoReload = false -- when weapon is drawn, the gun will reload itself.

SWEP.IsShotgun = false -- weapon receives shotgun ammo types

SWEP.TriggerDelay = false -- Set to true to play the "trigger" animation before firing. Delay time is dependent on animation time.

SWEP.Recoil = 2
SWEP.RecoilSide = 1
SWEP.RecoilRise = 1
SWEP.MaxRecoilBlowback = -1
SWEP.VisualRecoilMult = 1.25
SWEP.RecoilPunch = 1.5
SWEP.RecoilPunchBackMax = 1
SWEP.RecoilPunchBackMaxSights = nil -- may clip with scopes
SWEP.RecoilVMShake = 1 -- random viewmodel offset when shooty

SWEP.Sway = 0

SWEP.ShotgunSpreadDispersion = false -- dispersion will cause pattern to increase instead of shifting
SWEP.ShotgunSpreadPattern = nil
SWEP.ShotgunSpreadPatternOverrun = nil
-- {Angle(1, 1, 0), Angle(1, 0, 0) ..}
-- list of how far each pellet should veer
-- if only one pellet then it'll use the first index
-- if two then the first two
-- in case of overrun pellets will start looping, preferably with the second one, so use that for the loopables
-- precision will still be applied

SWEP.RecoilDirection = Angle(1, 0, 0)
SWEP.RecoilDirectionSide = Angle(0, 1, 0)

SWEP.Delay = 60 / 750 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemode = 1 -- 0: safe, 1: semi, 2: auto, negative: burst
SWEP.Firemodes = {
    -- {
    --     Mode = 1,
    --     CustomBars = "---_!",
    -- }
}

--[[
	Custom bar setup
	Colored variants        Classic
	'a' Filled              '-' Filled
	'b' Outline             '_' Outline
	'd' CLR w Outline       '!' Red w Outline
	'#' Empty
]]
--     PrintName = "PUMP",
--     RunAwayBurst = false,
--     AutoBurst = false, -- hold fire to continue firing bursts
--     PostBurstDelay = 0,
--     ActivateElements = {}

SWEP.ShotRecoilTable = nil -- {[1] = 0.25, [2] = 2} etc.

SWEP.NotForNPCS = true
SWEP.NPCWeaponType = nil -- string or table, the NPC weapons for this gun to replace
-- if nil, this will be based on holdtype
SWEP.NPCWeight = 100 -- relative likeliness for an NPC to have this weapon
SWEP.TTTWeaponType = nil -- string or table, like NPCWeaponType but specifically for TTT weapons (takes precdence over NPCWeaponType)
SWEP.TTTWeight = 100 -- like NPCWeight but for TTT gamemode

SWEP.AccuracyMOA = 15 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 150 -- inaccuracy added by moving. Applies in sights as well! Walking speed is considered as "maximum".
SWEP.SightsDispersion = 0 -- dispersion that remains even in sights
SWEP.JumpDispersion = 300 -- dispersion penalty when in the air

SWEP.Bipod_Integral = false -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 1 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 1 -- Bipod recoil for Integral bipods

SWEP.ShootWhileSprint = false

SWEP.Primary.Ammo = "pistol" -- what ammo type the gun uses
SWEP.MagID = "mpk1" -- the magazine pool this gun draws from

SWEP.ShootVol = 50 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = nil
SWEP.ShootSound = ""
SWEP.ShootSoundLooping = nil
SWEP.FirstShootSoundSilenced = nil
SWEP.ShootDrySound = nil -- Add an attachment hook for Hook_GetShootDrySound please!
SWEP.DistantShootSound = nil
SWEP.ShootSoundSilenced = "w/dc19.wav"
SWEP.ShootSoundSilencedLooping = nil
SWEP.FiremodeSound = "weapons/arccw/firemode.wav"
SWEP.MeleeSwingSound = "weapons/arccw/melee_lift.wav"
SWEP.MeleeMissSound = "weapons/arccw/melee_miss.wav"
SWEP.MeleeHitSound = "weapons/arccw/melee_hitworld.wav"
SWEP.MeleeHitNPCSound = "weapons/arccw/melee_hitbody.wav"
SWEP.EnterBipodSound = "weapons/arccw/bipod_down.wav"
SWEP.ExitBipodSound = "weapons/arccw/bipod_up.wav"
SWEP.SelectUBGLSound =  "weapons/arccw/ubgl_select.wav"
SWEP.ExitUBGLSound = "weapons/arccw/ubgl_exit.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false -- Use Gmod muzzle effects rather than particle effects
SWEP.ImpactEffect = nil
SWEP.ImpactDecal = nil

SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellMaterial = nil
SWEP.ShellEffect = nil
SWEP.ShellEjectPosCorrection = nil
SWEP.ShellScale = 1
SWEP.ShellPhysScale = 1
SWEP.ShellPitch = 100
SWEP.ShellSounds = "autocheck"--ArcCW.ShellSoundsTable
SWEP.ShellRotate = 0
SWEP.ShellTime = 0.5

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on
SWEP.ProceduralViewBobAttachment = nil -- attachment on which coolview is affected by, default is muzzleeffect
SWEP.CamAttachment = nil -- if set, this attachment will control camera movement
SWEP.MuzzleFlashColor = Color(0, 110, 255)

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.ShootSpeedMult = 1

SWEP.KeepBaseIrons = false -- do not override iron sights when scope installed
SWEP.BaseIronsFirst = false -- If a sight keeps base irons, irons comes first

SWEP.IronSightStruct = {
    Pos = Vector(-8.728, -13.702, 4.014),
    Ang = Angle(-1.397, -0.341, -2.602),
    Midpoint = { -- Where the gun should be at the middle of it's irons
        Pos = Vector(0, 15, -4),
        Ang = Angle(0, 0, -45),
    },
    Magnification = 1,
    BlackBox = false,
    ScopeTexture = nil,
    SwitchToSound = "", -- sound that plays when switching to this sight
    SwitchFromSound = "",
    ScrollFunc = ArcCW.SCROLL_NONE,
    CrosshairInSights = false,
}

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

-- Override free aim convar and variable
SWEP.FreeAimAngle = nil -- defaults to HipDispersion / 80. overwrite here
SWEP.NeverFreeAim = nil
SWEP.AlwaysFreeAim = nil

-- If Jamming is enabled, a heat meter will gradually build up until it reaches HeatCapacity.
-- Once that happens, the gun will overheat, playing an animation. If HeatLockout is true, it cannot be fired until heat is 0 again.
SWEP.Jamming = false
SWEP.HeatCapacity = 200 -- rounds that can be fired non-stop before the gun jams, playing the "fix" animation
SWEP.HeatDissipation = 2 -- rounds' worth of heat lost per second
SWEP.HeatLockout = false -- overheating means you cannot fire until heat has been fully depleted
SWEP.HeatDelayTime = 0.5
SWEP.HeatFix = false -- when the "fix" animation is played, all heat is restored.
SWEP.HeatOverflow = nil -- if true, heat is allowed to exceed capacity (this only applies when the default overheat handling is overridden)

-- If Malfunction is enabled, the gun has a random chance to be jammed
-- after the gun is jammed, it won't fire unless reload is pressed, which plays the "unjam" animation
-- if no "unjam", "fix", or "cycle" animations exist, the weapon will reload instead
SWEP.Malfunction = false
SWEP.MalfunctionJam = true -- After a malfunction happens, the gun will dryfire until reload is pressed. If unset, instead plays animation right after.
SWEP.MalfunctionTakeRound = true -- When malfunctioning, a bullet is consumed.
SWEP.MalfunctionWait = 0.5 -- The amount of time to wait before playing malfunction animation (or can reload)
SWEP.MalfunctionMean = nil -- The mean number of shots between malfunctions, will be autocalculated if nil
SWEP.MalfunctionVariance = 0.25 -- The fraction of mean for variance. e.g. 0.2 means 20% variance
SWEP.MalfunctionSound = "weapons/arccw/malfunction.wav"

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "smg"
SWEP.HoldtypeCustomize = "slam"
SWEP.HoldtypeNPC = nil

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.GuaranteeLaser = false -- GUARANTEE that the laser position will be accurate, so don't bother with sighted correction

SWEP.ShieldProps = nil
-- {
--     {
--         Model = "",
--         Pos = Vector(0, 0, 0),
--         Ang = Angle(0, 0, 0),
--         Bone = "", -- leave blank for valvebiped right hand
--         Resistance = 5, -- one unit of this object counts for how much penetration amount
--     }
-- }

SWEP.CanBash = true
SWEP.PrimaryBash = false -- primary attack triggers melee attack

SWEP.MeleeDamage = 25
SWEP.MeleeRange = 16
SWEP.MeleeDamageType = DMG_CLUB
SWEP.MeleeTime = 0.5
SWEP.MeleeGesture = nil
SWEP.MeleeAttackTime = 0.2

SWEP.BashPreparePos = Vector(2.187, -4.117, -7.14)
SWEP.BashPrepareAng = Angle(32.182, -3.652, -19.039)

SWEP.BashPos = Vector(8.876, 0, 0)
SWEP.BashAng = Angle(-16.524, 70, -11.046)

SWEP.ActivePos = Vector(0, 0, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.ReloadPos = nil
SWEP.ReloadAng = nil

SWEP.CrouchPos = nil
SWEP.CrouchAng = nil

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

-- When using custom sprint animations, set this to the same as ActivePos and ActiveAng
SWEP.SprintPos = nil
SWEP.SprintAng = nil

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetCrouch = nil
SWEP.BarrelOffsetHip = Vector(3, 0, -3)

SWEP.CustomizePos = Vector(9.824, 0, -4.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.BarrelLength = 24

SWEP.SightPlusOffset = nil

SWEP.DefaultPoseParams = {} -- {["pose"] = 0.5}
SWEP.DefaultWMPoseParams = {}

SWEP.DefaultElements = {} -- {"ele1", "ele2"}

SWEP.AttachmentElements = {
    -- ["name"] = {
    --     RequireFlags = {}, -- same as attachments
    --     ExcludeFlags = {},
    --     NamePriority = 0, -- higher = more likely to be chosen
    --     NameChange = "",
    --     TrueNameChange = "",
    --     AddPrefix = "",
    --     AddSuffix = "",
    --     VMPoseParams = {}, -- {["pose"] = 0.5}
    --     VMColor = Color(),
    --     VMMaterial = "",
    --     VMBodygroups = {{ind = 1, bg = 1}},
    --     VMElements = {
    --         {
    --             Model = "",
    --             Bone = "",
    --             Offset = {
    --                 pos = Vector(),
    --                 ang = Angle(),
    --             },
    --             ModelSkin = 0,
    --             ModelBodygroups = "",
    --             Scale = Vector(1, 1, 1),
    --             IsMuzzleDevice = false -- this element is a muzzle device, and the muzzle flash should come from here.
    --         }
    --     },
    --     VMOverride = "", -- change the view model to something else. Please make sure it's compatible with the last one.
    --     VMBoneMods = {
    --         ["bone"] = Vector(0, 0, 0)
    --     },
    --     WMPoseParams = {}, -- {["pose"] = 0.5}
    --     WMColor = Color(),
    --     WMMaterial = "",
    --     WMBodygroups = {},
    --     WMElements = {
    --         {
    --             Model = "",
    --             Offset = {
    --                 pos = Vector(),
    --                 ang = Angle(),
    --             },
    --             IsMuzzleDevice = false -- this element is a muzzle device, and the muzzle flash should come from here.
    --         }
    --     },
    --     WMOverride = "", -- change the world model to something else. Please make sure it's compatible with the last one.
    --     WMBoneMods = {
    --         ["bone"] = Vector(0, 0, 0)
    --     },
    --     AttPosMods = {
    --         [1] = {
    --             bone = "", -- optional
    --             vpos = Vector(0, 0, 0),
    --             vang = Angle(0, 0, 0),
    --             wpos = Vector(0, 0, 0),
    --             wang = Angle(0, 0, 0),
    --             SlideAmount = { -- only if base att has slideable
    --                 vmin = Vector(0, 0, 0),
    --                 vmax = Vector(0, 0, 0),
    --                 wmin = Vector(0, 0, 0),
    --                 wmax = Vector(0, 0, 0)
    --             }
    --         }
    --     }
    -- }
}

SWEP.RejectAttachments = {
    -- ["optic_docter"] = true -- stop this attachment from being usable on this gun
}

SWEP.AttachmentOverrides = {
    -- ["optic_docter"] = {} -- allows you to overwrite atttbl values
}

SWEP.TTT_DoNotAttachOnBuy = false -- don't give all attachments when bought

SWEP.Attachments = {}
-- [1] = {
--     PrintName = "Optic", -- print name
--     DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
--     DefaultAttIcon = Material(),
--     Slot = "pic_sight", -- what kind of attachments can fit here
--     MergeSlots = {}, -- these other slots will be merged into this one.
--     Bone = "sight", -- relevant bone any attachments will be mostly referring to
--     WMBone = "ValveBiped.Bip01_L_Hand", -- set it to change parent bone of attachment WM
--     KeepBaseIrons = false,
--     ExtraSightDist = 0,
--     Offset = {
--         vpos = Vector(0, 0, 0), -- offset that the attachment will be relative to the bone
--         vang = Angle(0, 0, 0),
--         wpos = Vector(0, 0, 0), -- same, for the worldmodels
--         wang = Angle(0, 0, 0)
--     },
--     RejectAttachments = {}, -- specific blacklist of attachments this slot cannot accept. Needs to be like {"optic_mrs" = true}
--     VMScale = Vector(1, 1, 1),
--     WMScale = Vector(1, 1, 1),
--     SlideAmount = { -- how far this attachment can slide in both directions.
--         -- overrides Offset.
--         vmin = Vector(0, 0, 0),
--         vmax = Vector(0, 0, 0),
--         wmin = Vector(0, 0, 0),
--         wmax = Vector(0, 0, 0),
--     },
--     CorrectiveAng = Vector(1, 1, 1), -- okay, I know I said sights were pain-free.
--     CorrectivePos = Vector(0, 0, 0), -- that won't always be the case. Use these to fix it. Issues mainly crop up in case of sights parented to bones that are not a root bone.
--     InstalledEles = {"toprail"}, -- activate these AttachmentElements if something is installed
--     DefaultEles = {""} -- activeate these AttachmentElements *unless* something is installed
--     Hidden = false, -- attachment cannot be seen in customize menu
--     Integral = false, -- attachment is assumed never to change
--     RandomChance = 1, -- multiplies chance this slot will get a random attachment
--     DoNotRandomize = false,
--     NoWM = false, -- do not make this show up on worldmodel
--     NoVM = false, -- what do *you* think this one does?
--     FreeSlot = false, -- slot does not count towards attachment capacity
--     -- ABOUT THE FLAG SYSTEM:
--     -- Attachments and slots can give flags
--     -- All attachments automatically give themselves as a flag, e.g. "optic_mrs"
--     -- If requirements are not satisfied, the slot or attachment will not be attachable
--     ExcludeFlags = {}, -- if the weapon has this flag, hide this slot
--     RequireFlags = {}, -- if the weapon does not have all these flags, hide this slot
--     GivesFlags = {} -- give these slots if something is installed here
--     HideIfBlocked = false, -- If flag requirements are not met, do not show the attachment at all
-- }

-- ready: deploy first time
-- draw
-- holster
-- reload
-- fire
-- cycle (for bolt/pump actions)
-- bash
-- fix
-- enter_bipod
-- exit_bipod
-- enter_sight
-- exit_sight
-- a_to_b: switch from firemode a to firemode b. e.g.: 1_to_2
-- idle
-- idle_sights
-- idle_sprint
-- idle_bipod
-- enter_inspect
-- idle_inspect
-- exit_inspect
-- enter_ubgl
-- exit_ubgl
-- idle_ubgl

-- you can append suffixes for different states
-- append list:

-- _iron, _sights, or _sight     for sighted variation
-- _sprint                       for sprinting variation
-- _bipod                        for bipod variation
-- _empty                        for empty variation
-- _jammed                       for jammed variation

-- this does not apply to reload animations.

-- !! they MUST be in the order of this list.
-- example: fire_iron_bipod_empty

-- use SWEP/wep.Hook_TranslateAnimation, same as in attachment, to do even more behaviours
-- use SWEP/wep.Hook_SelectReloadAnimation to change the reload animation
-- use SWEP/wep.Hook_SelectInsertAnimation to change the shotgun reload insert animation
-- use SWEP/wep.Hook_SelectFireAnimation to change the fire animation
-- use SWEP/wep.Hook_SelectCycleAnimation to change the cycle/pump animation
-- use SWEP/wep.Hook_SelectBashAnimation to change the bash animation

-- which sequence to derive the sight autosolver from.
SWEP.AutosolveSourceSeq = "idle"

-- Disclaimer: LHIK is *actually* a type of forward kinematics.
-- If you prefer, LHIK can stand for "Left Hand Individual Kinematics" or some shit

SWEP.Animations = {
    -- ["idle"] = {
    --     Source = "idle",
    --     Time = 10
    -- },
    -- ["draw"] = {
    --     RestoreAmmo = 1, -- only used by shotgun empty insert reload
    --     Source = "deploy",
    --     RareSource = "", -- 1/RareSourceChance of playing this animation instead
    --     RareSourceChance = 100, -- Chance the rapper
    --     Time = 0.5, -- Overwrites the duration of the animation (changes speed). Don't set to use sequence length
    --     Mult = 1, -- Multiplies the rate of animation.
    --     TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, -- third person animation to play when this animation is played
    --     TPAnimStartTime = 0, -- when to start it from
    --     Checkpoints = {}, -- time checkpoints. If weapon is unequipped, the animation will continue to play from these checkpoints when reequipped.
    --     ShellEjectAt = 0, -- animation includes a shell eject at these times
    --     LHIKIn = 0.25, -- In/Out controls how long it takes to switch to regular animation.
    --     LHIKOut = 0.25, -- (not actually inverse kinematics)
    --     LHIKEaseIn = 0.1, -- how long LHIK eases in.
    --     LHIKEaseOut = 0.1, -- if no value is specified then ease = lhikin
    --     LHIKTimeline = { -- allows arbitrary LHIK values to be interpolated between
    --         {
    --             t = 0.1,
    --             lhik = 0,
    --         },
    --         {
    --             t = 0.25,
    --             lhik = 1
    --         }
    --     },
    --     LHIK = true, -- basically disable foregrips on this anim
    --     SoundTable = {
    --         {
    --             s = "", -- sound; can be string or table
    --             p = 100, -- pitch
    --             v = 75, -- volume
    --             t = 1, -- time at which to play relative to Animations.Time
    --             c = CHAN_ITEM, -- channel to play the sound

    --             -- Can also play an effect at the same time
    --             e = "", -- effect name
    --             att = nil, -- attachment, defaults to shell attachment
    --             mag = 100, -- magnitude
    --             -- also capable of modifying bodygroups
    --             ind = 0,
    --             bg = 0,
    --             -- and poseparams
    --             pp = "pose",
    --             ppv = 0.25,
    --         }
    --     },
    --     ViewPunchTable = {
    --         {
    --             p = Vector(0, 0, 0),
    --             t = 1
    --         }
    --     },
    --     ProcDraw = false, -- for draw/deploy animations, always procedurally draw in addition to playing animation
    --     ProcHolster = false, -- procedural holster weapon, THEN play animation
    --     LastClip1OutTime = 0, -- when should the belt visually replenish on a belt fed
    --     MinProgress = 0, -- how much time in seconds must pass before the animation can be cancelled
    --     ForceEmpty = false, -- Used by empty shotgun reloads that load rounds to force consider the weapon to still be empty.
    -- }
}

--[[
for k, v in ipairs(ents.FindByClass("sb*")) do
	if v.Droid then
		v:Give("arccw_ef_blaster_dc15s")
	end
end
]]

DEFINE_BASECLASS( SWEP.Base )
--addons/arccw_weapons/lua/weapons/arccw_rg4d.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Droidenwaffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "RG-4D"
SWEP.Trivia_Class = "CIS Blaster Pistol"
SWEP.Trivia_Desc = "High tech CIS RG-4D Blaster Pistol"
SWEP.Trivia_Manufacturer = "Baktoid Combat Automata"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 1

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/rw_sw_rg4d.png"

SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 30
SWEP.RangeMin = 100
SWEP.DamageMin = 17
SWEP.Range = 350
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400


SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 15

SWEP.Recoil = 0.7
SWEP.RecoilPunch = 1.4
SWEP.RecoilSide = 0.25
SWEP.RecoilRise = 0.31

SWEP.Delay = 60 / 260
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 0
    },
}

SWEP.AccuracyMOA = 0.75 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 800 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(255, 0, 0)


----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/rg4d.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-3.95, -10, 1.6),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(3, -4, -1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(5, -10,-20)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Vector(-15, 0, 0)

SWEP.CustomizePos = Vector(12.824, -8, -3.897)
SWEP.CustomizeAng = Angle(10.149, 34.547, 0)


SWEP.DefaultElements = {"rg4d"}

SWEP.AttachmentElements = {
    ["rg4d"] = {
        VMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/rg4d_blaster.mdl",
                Bone = "v_scoutblaster_reference001",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(0, -4, -2.951),
                    ang = Angle(0, 90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/kuro/sw_battlefront/weapons/rg4d_blaster.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(80, 20, 15.3),
                    ang = Angle(-15, 0, 180)
                }
            }
        },
    },
}
WMOverride = "models/arccw/kuro/sw_battlefront/weapons/rg4d_blaster.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = {"optic_lp", "optic"},
        WMScale = Vector(11, 11, 11),
        Bone = "scoutblaster_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.04, -0.8, 3),
            vang = Angle(90, 0, -90),
            wpos = Vector(50, 20, -40),
            wang = Angle(-15, 90, 180)
        },
    },
    [2] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(11, 11, 11),
        Bone = "v_scoutblaster_reference001", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, -6, 1),
            vang = Angle(0, 90, 0),
            wpos = Vector(90 , 20, -40),
            wang = Angle(-15, 0, 180)
        },
    },    
    [3] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        WMScale = Vector(11, 11, 11),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.2, -0.3, 15),
            vang = Angle(90, 0, -90),
            wpos = Vector(170, 20, -67.5),
            wang = Angle(-15, 0, 180)
        },
    },        
    [4] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [5] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [6] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(11, 11, 11),
        Bone = "scoutblaster_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.7, -0.6, 2),
            vang = Angle(90, 0, -90),
            wpos = Vector(50, 25, -35),
            wang = Angle(-10, 0, 180)
        },
    },          
}


SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/gunfoley_pistol_draw_var_06.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "holster/gunfoley_pistol_sheathe_var_09.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL,
 --       Time = 3.35,
        SoundTable = {
            {s = "ArcCW_dc17.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc17.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/pistols.wav"
    }),
}

-- AOCRP WAFFENSTATS arccw_rg4d - 02.06.2024
SWEP.Damage = 36
SWEP.DamageMin = 23
SWEP.RangeMin = 102
SWEP.Range = 306
SWEP.Delay = 60 / 302
SWEP.Primary.ClipSize = 20
SWEP.Category = 'KUS'
--addons/arccw_weapons/lua/weapons/arccw_sops_a180.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 2

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "A-180"
SWEP.Trivia_Class = "Blaster Pistol"
SWEP.Trivia_Desc = "The A-180 blaster, also known as the A180 pistol, was a modular blaster manufactured by BlasTech Industries. It was a highly versatile design with multiple configurations that could be easily reconfigured from a blaster pistol to a blaster rifle, a sniper rifle/longblaster, or an portable ion launcher depending on the situation."
SWEP.IconOverride = "entities/sopsmisc/a180.png"

-- Viewmodel properties
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops-v2/c_a180.mdl"
SWEP.WorldModel = "models/arccw/kraken/sops-v2/w_a180.mdl"
SWEP.ViewModelFOV = 58
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-15, 7.5, -5),
    ang = Angle(-10, 0, 180)
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1.3,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 36
SWEP.RangeMin = 102
SWEP.DamageMin = 23
SWEP.Range = 306
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20

SWEP.Recoil = 0.64
SWEP.RecoilSide = 0.12
SWEP.RecoilRise = 0.65
SWEP.Delay = 60 / 302

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 150
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/a180.wav"
SWEP.ShootSound = "sops-v2/weapons/a180.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-6.126, -4.178, 3.4),
    Ang = Angle(0, 0, 0),
     Magnification = 1.3,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.SprintPos = Vector(1, -6, -5)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.ActivePos = Vector(-2, 3, 3)
SWEP.ActiveAng = Angle(1, 0, 0)

SWEP.HolsterPos = Vector(0.532, -6, 0)
SWEP.HolsterAng = Angle(-4.633, 36.881, 0)

SWEP.CustomizePos = Vector(8, 0, 3)
SWEP.CustomizeAng = Angle(5, 30, 30)

-- Attachments
SWEP.AttachmentElements = {
    ["a180_barrele"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        AttPosMods = {
            [2] = {
                vpos = Vector(0.3, -0.5, 11),
            },
        }
    },
    ["a180_grip"] = {
        VMBodygroups = {
            {ind = 2, bg = 1},
        },
    },
}
SWEP.Attachments = {   
    {
        PrintName = "Optic",
        DefaultAttName = "None",
        Slot = "optic",
        Bone = "a180",
        Offset = {
            vpos = Vector(0.3, -1, 0),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, -0.025),
    },  
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "a180",
        Offset = {
            vpos = Vector(0.3, -0.5, 9),
            vang = Angle(90, 0, 0),

        },
    },  
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.8, 0.8, 0.8),
        Bone = "a180",
        Offset = {
            vpos = Vector(0.5, -0.5, 5),
            vang = Angle(90, 0, 0),
        },
    },  
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },
    {
        PrintName = "Barrel",
        DefaultAttName = "None",
        Slot = "a180_barrele",
    },    
    {
        PrintName = "Grip",
        DefaultAttName = "None",
        Slot = "a180_grip",

    },  
    {
        PrintName = "Ammunition", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "ammo_masita", "ammo_stun"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = {"perk", "mw3_pro"},
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },  
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "a180",
        VMScale = Vector(0.6, 0.6, 0.6),
        Offset = {
            vpos = Vector(1, -0.9, -1.4),
            vang = Angle(90, 0, -90),
        },
    },       
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "a180",
        Offset = {
            vpos = Vector(0.9, -0.5, 1),
            vang = Angle(90, 0, -90),
        },
    },     
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "shoot",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_manualcooling_var_02.mp3", t = 0.1/30},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_04.mp3", t = 1.20},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_dca4.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "DC-A4"
SWEP.Trivia_Class = "Blaster-Experimental Rifle"
SWEP.Trivia_Desc = "An ancient instrument of war, renewed and enhanced by BlasTech Industries."
SWEP.IconOverride = "entities/sopsmisc/dc16a4.png"

SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops-v2/c_khvostov7g0x.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_e11.mdl"
SWEP.ViewModelFOV = 58
SWEP.MirrorVMWM = false
SWEP.NoHideLeftHandInCustomization = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

-- Special properties
SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellPitch = 95
SWEP.ShellScale = 1.4

-- Damage & Entity Options
SWEP.Damage = 45
SWEP.DamageMin = 25
SWEP.RangeMin = 239
SWEP.Range = 540
SWEP.DamageType = DMG_BULLET
SWEP.Penetration = 1
SWEP.MuzzleVelocity = 800

SWEP.TracerNum = 1
SWEP.TracerCol = Color(25, 125, 255)
SWEP.TracerWidth = 10
SWEP.PhysTracerProfile = "apex_bullet_energy"
SWEP.Tracer = "arccw_apex_tracer_energy_sniper"
SWEP.HullSize = 0.5
SWEP.Num = 1 

SWEP.AmmoPerShot = 1
SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 40
SWEP.ExtendedClipSize = 60
SWEP.ReducedClipSize = 30

SWEP.Recoil = 0.68
SWEP.RecoilRise = 0.73
SWEP.RecoilSide = 0.32

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 250
SWEP.MoveDispersion = 100

SWEP.Delay = 60 / 402
SWEP.Firemode = 1
SWEP.Firemodes = {
    {
		Mode = 1,
    },
    {
		Mode = 2,
    },
	{
		Mode = 0,
   	}
}

SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.40

SWEP.Primary.Ammo = "ar2" 
SWEP.ShootVol = 50
SWEP.ShootPitch = 90
SWEP.ShootPitchVariation = 0.2
SWEP.FirstShootSound = "sops-v2/weapons/dca4/kvfire1.wav"
SWEP.ShootSound = "sops-v2/weapons/dca4/kvfire2.wav", "sops-v2/weapons/dca4/kvfire3.wav", "sops-v2/weapons/dca4/kvfire4.wav", "sops-v2/weapons/dca4/kvfire5.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false 

SWEP.CaseEffectAttachment = 2
SWEP.MuzzleEffectAttachment = 1 
SWEP.MuzzleFlashColor = Color(0, 0, 250)

SWEP.IronSightStruct = {
    Pos = Vector(-6.244, -9.494, 1.947),
    Ang = Angle(0, 0, 0),
     Magnification = 1.5,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.HoldtypeCustomize = "slam"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-2, 0, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.DefaultElements = {"dca4"}
SWEP.AttachmentElements = {
    ["dca4"] = {
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/c_khvostov7g0x.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                ModelSkin = 1,
                Offset = {
                    pos = Vector(-1650, 800, -450),
                    ang = Angle(-10, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(3200, 200, -800),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },            
        }, 
    }
}WMOverride = "models/arccw/kraken/sops-v2/c_khvostov7g0x.mdl"


SWEP.Attachments = {    
    {
        PrintName = "Sight",
        DefaultAttName = "None",
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "WeaponBone",
        Offset = {
            vpos = Vector(0, -6, 1.8),
            vang = Angle(0, 90, 180),
            wpos = Vector(600, 100, -535),
            wang = Angle(-10, -0.50, 180)
        },
        CorrectiveAng = Angle(0, -180, 0),
        CorrectivePos = Vector(0, 0, -0),
    },    
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "WeaponBone",
        WMScale = Vector(111, 111, 111),
        VMScale = Vector(1.3,1.3,1.3),
        Offset = {
            vpos = Vector(0.1, -30, 3),
            vang = Angle(0, 90, 180),
            wpos = Vector(3520, 100, -908),
            wang = Angle(-10, -1, 180)
        },
    },    
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "ammo_masita"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = {"perk", "mw3_pro"},
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },      
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(111, 111, 111),
        Bone = "WeaponBone",
        Offset = {
            vpos = Vector(0.5, -4, 4.5),
            vang = Angle(90, 90, -90),
            wpos = Vector(500, 145, -200),
            wang = Angle(-10, 0, 180)
        },
    },     
    {
        PrintName = "Charms",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "WeaponBone",
        WMScale = Vector(111, 111, 111),
        Offset = {
            vpos = Vector(0.9, -7.5, 7.5),
            vang = Angle(90, 90, -90),
            wpos = Vector(1100, 210, -0),
            wang = Angle(-10, 0, 180)
        },
    },   
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "shoot1",
        ShellEjectAt = 0.1,
    },
    ["fire_iron"] = {
        Source = "shoot1",
        ShellEjectAt = 0.1,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip1.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        LHIK = true,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "sops-v2/weapons/dca4/kvreload.wav", t = 0.1 },
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_galaar15.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 4

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "ZP-1"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "The GALAAR-15 blaster carbine was a popular blaster carbine manufactured by the Mandalorian arms giant Concordian Crescent Technologies. It was named after the galaar, a common bird of prey that was native to the planet Mandalore. It was a sleek, short-barreled rifle constructed from high-quality materials and was covered in shock-resistant polycarbonate. And while relatively rare, the GALAAR-15 was a frequent item that appeared on the black market. Due to its high-quality design, the rifle became a popular weapon among bounty hunters and other professional killers. Its popularity allowed arms dealers to charge a premium for the GALAAR-15, with even used weapons going above their standard value.[1] Similar in appearance to the smaller WESTAR-35 blaster pistol, the GALAAR-15 featured a angular design that made it blocky and squarish. It was mainly light grey with additional darker grey pieces and was known to fire yellow, blue or red blaster bolts, seeming dependent on the political allegiance of the user."
SWEP.IconOverride = "entities/sopsmisc/galaar15.png"

-- Viewmodel & Entity Properties
SWEP.ViewModel = "models/arccw/masita/viewmodels/base_rifle_animations.mdl"
SWEP.WorldModel = "models/weapons/synbf3/w_t21.mdl"
SWEP.ViewModelFOV = 66
SWEP.UseHands = true
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 34
SWEP.RangeMin = 175
SWEP.DamageMin = 21
SWEP.Range = 405
SWEP.Penetration = 2
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_orange"
SWEP.TracerCol = Color(250, 140, 0)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 34

SWEP.Recoil = 0.98
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.78
SWEP.Delay = 60 / 305

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.2
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/galaar.mp3"
SWEP.ShootSound = "sops-v2/weapons/galaar.mp3"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_orange"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 140, 0)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.3, 0, 2.4),
    Ang = Angle(1, -0.5, -3),
     Magnification = 2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 2, 2)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/galaar-15.mdl",
                Bone = "E11S_CONTR",
                ModelBodygroups = "00000",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-0.2, -1.7, -3.2),
                    ang = Angle(0, 0, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-3, 26, -8),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/galaar-15.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.2, 1.2, 1.2),
                ModelBodygroups = "00000",
                Offset = {
                    pos = Vector(70, 10, -10),
                    ang = Angle(-15, -90, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(280, 15, -90),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/galaar-15.mdl"


SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.1, -1, 0.4),
            vang = Angle(0, -90, 0),
            wpos = Vector(60, 10, -57),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.07)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(8, 8, 8),
        Bone = "E11S_CONTR", 
        Offset = {
            vpos = Vector(0.5, 12, -0.3),
            vang = Angle(40, -90, 90),
            wpos = Vector(220, 20, -89),
            wang = Angle(-15, 0, -40)
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.1, 4, -3),
            vang = Angle(0, -90, 0),
            wpos = Vector(140, 10, -30),
            wang = Angle(-15, 0, 180)
        },          
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.5, 16, -0.35),
            vang = Angle(0, -90, 0),
            wpos = Vector(290, 12, -104),
            wang = Angle(-15, 0, 180)
        },     
    },    
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(9, 9, 9),
        Offset = {
            vpos = Vector(0.4, -5.2, -0.3),
            vang = Angle(30, -90, 0),
            wpos = Vector(12, 18, -35),
            wang = Angle(-15, 0, 205)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        VMScale = Vector(1, 1, 1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.5, 2.2, -0.2),
            vang = Angle(30, -90, 0),
            wpos = Vector(100, 21, -59),
            wang = Angle(-15, 0, 205)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_rx21.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "RX-21 'Dawnbreaker'"
SWEP.Trivia_Class = "Blaster-Experimental Rifle"
SWEP.Trivia_Desc = "The RX-21 Rifle, also known as RX-21 blaster, was a experimental blaster rifle wielded by the Task-Force 99 Clone Troopers of the Grand Army of the Galactic Republic during the Clone Wars."
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/sopsmisc/r21x.png"

-- Viewmodel & Entity Properties
SWEP.ViewModel = "models/arccw/masita/viewmodels/base_rifle_animations.mdl"
SWEP.WorldModel = "models/weapons/synbf3/w_t21.mdl"
SWEP.ViewModelFOV = 66
SWEP.UseHands = true
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.3,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 38
SWEP.RangeMin = 187
SWEP.DamageMin = 22
SWEP.Range = 428
SWEP.Penetration = 2
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TraceNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 250)
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 50

SWEP.Recoil = 0.65
SWEP.RecoilSide = 0.23
SWEP.RecoilRise = 0.56
SWEP.Delay = 60 / 365

SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 2
    },
    {
        Mode = 0
    },         
}

SWEP.AccuracyMOA = 0.2
SWEP.HipDispersion = 300
SWEP.MoveDispersion = 100

-- Sounds & Muzzleflash
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 50
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.FirstShootSound = "sops-v2/weapons/rx21.wav"
SWEP.ShootSound = "sops-v2/weapons/rx21.wav"
SWEP.ShootSoundSilenced = "sops-v2/weapons/silenced.mp3"

SWEP.NoFlash = nil
-- SWEP.MuzzleEffect = "wpn_muzzleflash_dc17"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 250)

-- Ironsight & Holdtype
SWEP.IronSightStruct = {
    Pos = Vector(-3.8, 0, -1),
    Ang = Angle(1, -0.9, -3),
     Magnification = 2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 5, -2)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments 
SWEP.DefaultElements = {"blaster", "muzzle"}
SWEP.AttachmentElements = {
    ["blaster"] = {
        VMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/holo_r21x.mdl",
                Bone = "E11S_CONTR",
                ModelBodygroups = "00000",
                Scale = Vector(0.9, 0.9, 0.9),
                Offset = {
                    pos = Vector(-0.2, -11, -0.4),
                    ang = Angle(0, -90, 0)
                }
            }
        },
    },
    ["muzzle"] = {
        VMElements = {
           {
               Model = "models/hunter/plates/plate.mdl",
               Bone = "E11S_CONTR",
               Scale = Vector(0, 0, 0),                
               Offset = {
                   pos = Vector(-3, 26, -8),
                   ang = Angle(-90, 180, 0)
               },
               IsMuzzleDevice = true
           }
        },
        WMElements = {
            {
                Model = "models/arccw/kraken/sops-v2/holo_r21x.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.9, 0.9, 0.9),
                ModelBodygroups = "00000",
                Offset = {
                    pos = Vector(-35, 10, -20),
                    ang = Angle(-15, 0, 180)
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(290, 15, -100),
                    ang = Angle(-15, 0, 180)
                },
                IsMuzzleDevice = true
            },              
        },
    }
}WMOverride = "models/arccw/kraken/sops-v2/holo_r21x.mdl"


SWEP.Attachments = {
    {
        PrintName = "Optic", 
        DefaultAttName = "Standard", 
        Slot = "optic",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.4, -7.4, 3.5),
            vang = Angle(0, -90, 0),
            wpos = Vector(74, 7, -96),
            wang = Angle(-15, 0, 180)
        },
        CorrectiveAng = Angle(0, 180, 0),
        CorrectivePos = Vector(0, 0, -0.07)
    },    
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(1, 1, 1),
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR", 
        Offset = {
            vpos = Vector(0.8, 18, 1.7),
            vang = Angle(0, -90, 90),
            wpos = Vector(260, 21, -130),
            wang = Angle(-15, 0, -90)
        },
    },
    {
        PrintName = "Foregrip",
        DefaultAttName = "None",
        Slot = "foregrip",
        WMScale = Vector(11, 11, 11),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.4, 3, -2.65),
            vang = Angle(0, -90, 0),
            wpos = Vector(120, 10, -33),
            wang = Angle(-15, 0, 180)
        },          
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        WMScale = Vector(13, 13, 13),
        VMScale = Vector(2, 2, 2),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(-0.5, 22, 1.2),
            vang = Angle(0, -90, 0),
            wpos = Vector(300, 10, -127),
            wang = Angle(-15, 0, 180)
        },     
    },    
    {
        PrintName = "Ammunition",
        DefaultAttName = "Standard",
        Slot = {"ammo"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "E11S_CONTR",
        VMScale = Vector(0.7, 0.7, 0.7),
        WMScale = Vector(11, 11, 11),
        Offset = {
            vpos = Vector(1, -5.9, 0.8),
            vang = Angle(0, -90, 0),
            wpos = Vector(12, 24, -45),
            wang = Angle(-15, 0, 180)
        },
    },     
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        WMScale = Vector(11, 11, 11),
        VMScale = Vector(1, 1, 1),
        Bone = "E11S_CONTR",
        Offset = {
            vpos = Vector(0.8, -2, -0.3),
            vang = Angle(0, -90, 0),
            wpos = Vector(70, 20, -50),
            wang = Angle(-15, 0, 180)
        },
    },      
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["fire"] = {
        Source = {"shoot"},
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1,
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100, 
                v = 75, 
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        LHIK = true,
        Mult = 1,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_02.mp3", t = 10 / 60},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheat_reset_var_04.mp3", t = 120 / 60},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sops_stw48.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken"
SWEP.PrintName = "ST-W48"
SWEP.Trivia_Class = "Blaster Carabine"
SWEP.Trivia_Desc = "This is the ST-W48. The weapon could be used in a blaster rifle configuration or a blaster carbine configuration where the stock was removed for use in confined spaces. Each ST-W48 had a quarrel-bolt launcher installed below its barrel that used enhanced bowcaster technology for a powerful explosive attack. The rifle's power cell cartridge was located around the mid-point of the weapon's length, above the trigger. The weapon had an auto fire mode that provided a high rate of fire."
SWEP.IconOverride = "entities/sopsmisc/stw48.png"

-- Viewmodel & Entity Properties
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/sops-v2/c_stw48.mdl"
SWEP.WorldModel = "models/arccw/kraken/sops-v2/w_stw48.mdl"
SWEP.ViewModelFOV = 58
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-11, 4, -3.3),
    ang = Angle(-10, 0, -180),
    scale = 1.2,
}

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 31
SWEP.DamageMin = 22
SWEP.Range = 382
SWEP.RangeMin = 202
SWEP.Penetration = 1

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 45
SWEP.ExtendedClipSize = 50
SWEP.ReducedClipSize = 25

SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 800
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_red"
SWEP.TracerCol = Color(250, 0, 0)
SWEP.HullSize = 0.5

SWEP.Recoil = 0.68
SWEP.RecoilSide = 0.3
SWEP.RecoilRise = 0.62

SWEP.Delay = 60 / 387
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.AccuracyMOA = 0.5
SWEP.HipDispersion = 200
SWEP.MoveDispersion = 150

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 110 
SWEP.ShootPitch = 120 
SWEP.ShootPitchVariation = 0.2

SWEP.FirstShootSound = "sops-v2/weapons/stw48.wav"
SWEP.ShootSound = "sops-v2/weapons/stw48.wav"
SWEP.ShootSoundSilenced = "weapon/venator/dc17_badbatch.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_red"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(250, 0, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-3.227, -1.923, 1),
    Ang = Angle(0,-0.7, 5),
     Magnification = 1.2,
     SwitchToSound = "sops-v2/interaction/zoom_start.mp3",
     SwitchFromSound = "sops-v2/interaction/zoom_end.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 2, 0)
SWEP.ActiveAng = Angle(1, -0.5, -5)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(9.824, 2, -2.897)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "None", 
        Slot = "optic", 
        Bone = "stw48",
        VMScale = Vector(0.8, 0.8, 0.8),
        Offset = {
            vpos = Vector(-0.250, -2, 2),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },      
    {
        PrintName = "Muzzle", 
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle"},
        Bone = "stw48",
        VMScale = Vector(1, 1, 1),
        Offset = {
            vpos = Vector(-0.250, -1, 10.3),
            vang = Angle(90, 0, -90),
        },
    },   
    {
        PrintName = "Tactical", 
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol", "tac"},
        VMScale = Vector(0.8, 0.8, 0.8),
        Bone = "stw48",
        Offset = {
            vpos = Vector(0.8, -1, 6),
            vang = Angle(90, 0, 0),
        },
    },        
    {
        PrintName = "Energization", 
        DefaultAttName = "Standard",
        Slot = {"ammo", "ammo_masita", "ammo_stun", "stw48_nade"},
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = {"perk", "mw3_pro"},
    },
    {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = {"uc_fg"},
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    }, 
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "stw48",
        Offset = {
            vpos = Vector(0.6, -1.0, -0.425),
            vang = Angle(90, 0, -90),
        },
    },       
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "stw48",
        Offset = {
            vpos = Vector(0.3, -2, -2),
            vang = Angle(90, 0, -70),
        },
    },        
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "neutral"
    },
    ["fire"] = {
        Source = "fire",
    },
    ["fire_iron"] = {
        Source = false,
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "sops-v2/interaction/equip2.wav",
                p = 100,
                v = 75,
                t = 0.1,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_manualcooling_var_02.mp3", t = 5 / 30},
            {s = "weapon_hand/reload_gentle/mag_eject/023d-00001014.mp3", t = 5 / 30},
            {s = "weapon_hand/reload_gentle/mag_load/023d-00000dda.mp3", t = 30 / 30},
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_04.mp3", t = 35 / 30},
        },
    },
}
--addons/arccw_weapons/lua/weapons/arccw_sw_rocket_rps6.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "RPS-6"
SWEP.TrueName = "RPS-6 Launcher"
SWEP.Trivia_Class = "Rocket Launcher"
SWEP.Trivia_Desc = "A rocket launcher with 4 different payload options; HE, HEAT, Tandem, and Smoke. HE rockets have high splash but low immediate damage. HEAT rounds have good damage and splash. Tandem rounds have very little splash, but massive damage. Smoke rounds do no damage, but create an obscuring smokescreen."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Rocket"
SWEP.Trivia_Mechanism = "Single-Action"
SWEP.Trivia_Country = "Russia"
SWEP.Trivia_Year = 1961

SWEP.Slot = 4
SWEP.UseHands = true

SWEP.ViewModel = "models/holdtypes/c_rpg7.mdl"
SWEP.WorldModel = "models/holdtypes/w_rpg7.mdl"
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.09
}
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = true

SWEP.IconOverride = "materials/entities/rps6_meeks.png"

SWEP.ShootEntity = "arccw_rocket_heat" -- entity to fire, if any
SWEP.MuzzleVelocity = 100000 -- projectile or phys bullet muzzle velocity
-- IN M/S

SWEP.ChamberSize = 0 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 1 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 1
SWEP.ReducedClipSize = 1

SWEP.Recoil = 2
SWEP.RecoilSide = 0.175
SWEP.RecoilRise = 2

SWEP.Delay = 60 / 600 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.NPCWeaponType = "weapon_rpg"
SWEP.NPCWeight = 150

SWEP.AccuracyMOA = 10 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 500

SWEP.Primary.Ammo = "RPG_Round" -- what ammo type the gun uses
SWEP.MagID = "rpg7" -- the magazine pool this gun draws from

SWEP.ShootVol = 130 -- volume of shoot sound
SWEP.ShootPitch = 100 -- pitch of shoot sound

SWEP.ShootSound = "weapons/rocket launcher/explosive_rocketlauncher_corebass_close_var_03.mp3"
SWEP.DistantShootSound = "weapons/arccw/rpg7/rpg7_dist.wav"

SWEP.MuzzleEffect = "muzzleflash_m79"

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on

SWEP.SightTime = 0.35

SWEP.SpeedMult = 0.875
SWEP.SightedSpeedMult = 0.75

SWEP.BarrelLength = 24

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.CaseBones = {}

SWEP.IronSightStruct = {
    Pos = Vector(-2, -12, 2),
    Ang = Angle(1.5, 0, 0),
    Magnification = 1.5,
    SwitchToSound = "", -- sound that plays when switching to this sight
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "smg"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(1, 2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(0, 0, 5)
SWEP.SprintAng = Angle(-30, 0, 0)

SWEP.HolsterPos = Vector(1, 4, -14)
SWEP.HolsterAng = Angle(40, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.CustomizePos = Vector(13.824, 2, 0.897)
SWEP.CustomizeAng = Angle(12.149, 40.547, 45)

SWEP.ExtraSightDist = 15

SWEP.DefaultElements = {"rocketlauncher"}

SWEP.AttachmentElements = {
    ["rocketlauncher"] = {
        VMElements = {
            {
                Model = "models/weapons/rocket3/rocket_launcher3.mdl",
                Bone = "Weapon_Main",
                Scale = Vector(0.8, 0.8, 0.8),
                Offset = {
                    pos = Vector(0.2, -2, -6),
                    ang = Angle(0, 0, -90)
                }
            }
        },
        WMElements = {
            {
                Model = "models/weapons/rocket3/rocket_launcher3.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                Offset = {
                    pos = Vector(-50, 10, -55),
                    ang = Angle(0, -90, 180)
                }
            }
        },
    },
}

SWEP.Attachments = {
    {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights",
        WMScale = Vector(11, 11, 11),
        Slot = {"optic", "optic_lp"}, -- what kind of attachments can fit here, can be string or table
        Bone = "Weapon_Main", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.3, -5.9, 4), -- offset that the attachment will be relative to the bone
            vang = Angle(90, 0, -90),
            wpos = Vector(90.36, 10, -110.301),
            wang = Angle(0, 0, 180)
        },
        InstalledEles = {"nors"},
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip", "bipod"},
        WMScale = Vector(11, 11, 11),
        Bone = "Weapon_Main",
        Offset = {
            vpos = Vector(0, -2, 6),
            vang = Angle(90, 0, -90),
            wpos = Vector(140, 10, -55.453),
            wang = Angle(-180.216, 0, 0)
        },
        InstalledEles = {"nogrip"},
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "Weapon_Main",
        WMScale = Vector(11, 11, 11),
        Offset = {
            vpos = Vector(1.6, -3.5, 10),
            vang = Angle(90, 0, 0),
            wpos = Vector(140.625, 30.253, -80.298),
            wang = Angle(0, 0, -90)
        },
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "Default",
        Slot = "ammo_rocket"
    },
    {
        PrintName = "Perk",
        Slot = "perk"
    },
    {
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        NoWM = true,
        Bone = "Weapon_Main",
        Offset = {
            vpos = Vector(1.7, -3, 1), -- offset that the attachment will be relative to the bone
            vang = Angle(90, 0, -90),
            wpos = Vector(11, 1.25, -4.5),
            wang = Angle(0, -4.211, 180)
        },
    },
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 1,
    },
    ["idle_empty"] = {
        Source = "idle_empty",
        Time = 1,
    },
    ["draw_empty"] = {
        Source = "draw_empty",
        Time = 1.5,
    },
    ["draw"] = {
        Source = "draw",
        Time = 1.5,
    },
    ["fire"] = {
        Source = "fire",
        Time = 0.5,
    },
    ["reload"] = {
        Source = "reload",
        Time = 4,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Checkpoints = {20, 26, 40},
        FrameRate = 30,
        LHIK = false,
        SoundTable = {
            {
                s = "insertrocket", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 74 / 60, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
            {
                s = "insertrocket2", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 115 / 60, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
            {
                s = "rocketclick", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 174 / 60, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
}

local path = "weapons/rocket launcher/"

sound.Add({
	name = "insertrocket",
	channel = CHAN_ITEM,
	volume = 1,
	soundlevel = 100,
	pitch = 100,
	sound = path .. "insert.wav"
	})

sound.Add({
	name = "insertrocket2",
	channel = CHAN_ITEM,
	volume = 1,
	soundlevel = 100,
	pitch = 100,
	sound = path .. "insert2.wav"
	})


sound.Add({
	name = 			"rocketclick",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = path ..	"click.wav"
})

--addons/arccw_weapons/lua/weapons/arccw_thermal_grenade.lua:
SWEP.Base = "arccw_grenade_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "Thermal Detonator"
SWEP.Trivia_Class = "Hand Grenade"
SWEP.Trivia_Desc = "Standard explosive ordnance with a timed fuse and a large blast radius."

SWEP.Slot = 4

SWEP.CamAttachment = 3

SWEP.NotForNPCs = true

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/nade_frag.mdl"
SWEP.WorldModel = "models/weapons/w_nade_frag.mdl"
SWEP.HideViewmodel = true
SWEP.MirrorVMWM = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    scale = 0.09
}

SWEP.IconOverride = "materials/entities/thermal_det_meek.png"


SWEP.Firemodes = {
    {
        Mode = 1,
        PrintName = "fcg.nade",
    },
}

SWEP.FuseTime = 2.1

SWEP.Primary.Ammo = "grenade"

SWEP.Primary.ClipSize = 1

SWEP.MuzzleVelocity = 1300
SWEP.MuzzleVelocityAlt = 500
SWEP.ShootEntity = "arccw_thr_frag"

SWEP.PullPinTime = 0.5

SWEP.ViewModelFOV = 70

SWEP.DefaultElements = {"thermal_grenade"}

SWEP.AttachmentElements = {
    ["thermal_grenade"] = {
        VMElements = {
            {
                Model = "models/arccw/thermal_detonator.mdl",
                Bone = "def_c_base",
                Scale = Vector(0.75, 0.75, 0.75),
                Offset = {
                    pos = Vector(-0.2, -0.8, -0.15),
                    ang = Angle(-60, 180, 15)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/thermal_detonator.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0.8, 0.8, 0.8),
                Offset = {
                    pos = Vector(35, 25, 0),
                    ang = Angle(0, 0, 0)
                }
            }
        },
    },
}

WMOverride = "models/arccw/thermal_detonator.mdl" -- change the world model to something else. Please make sure it's compatible with the last one.

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    ["idle_sprint"] = {Source = "sprint", Mult = 0.9},
    ["enter_sprint"] = {Source = "sprint_in", Mult = 0.1},
    ["exit_sprint"] = {Source = "sprint_out", Mult = 0.1},
    ["ready"] = {
        Source = "draw",
        SoundTable = {
           {s = "ArcCW_ThermalDet.firstdeploy1", t = 0 / 30},
        },
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {s = "misc/gunfoley_blaster_sheathe_var_03.mp3", t = 0 / 30},
        },
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {s = "ArcCW_ThermalDet.holster1", t = 0 / 30}
        },
    },
    ["pre_throw"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "ArcCW_primer.button", t = 0 / 30},
        },
        MinProgress = 0.5,
    },
    ["fire"] = {
        Source = "pullpin",
        SoundTable = {
            {s = "w/buttonpress.wav", t = 0 / 30},
        },
    },
    ["throw"] = {
        Source = {"toss_overhead"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
        SoundTable = {
            {s = "w/thermaldet.wav", t = 0 / 30}
        },
    },
    ["throw_alt"] = {
        Source = {"underhand"},
        TPAnim = ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
        SoundTable = {
            {s = "ArcCW_Underhand.explosion2", t = 0 / 30}
        },
    },
    ["enter_inspect"] = {
        Source = "inspect_in",
        LHIK = true,
    },
    ["exit_inspect"] = {
        Source = "inspect_out",
        LHIK = true,
    },
    ["idle_inspect"] = {
        Source = "inspect",
        LHIK = true,
    },
}
--addons/arccw_weapons/lua/weapons/arccw_tusken_cycler.lua:
AddCSLuaFile()

SWEP.Base = "arccw_meeks_sw_base"
SWEP.Spawnable = true
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = { Author1 = "cat"}
SWEP.PrintName = "Cycler Rifle"
SWEP.Trivia_Class = "Tusken Raider Cycler Rifle"
SWEP.Trivia_Desc = "preffered for long-range combat and general allround usage."
SWEP.Trivia_Manufacturer = "Handmade"
SWEP.Trivia_Calibre = "Medium Density Bolt"
SWEP.Trivia_Mechanism = "Energized Compressed Tibanna"
SWEP.Trivia_Country = "GAR"
SWEP.Trivia_Year = 2020

SWEP.Slot = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/arccw/bf2017/c_dlt19.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_dlt19.mdl"
SWEP.ViewModelFOV = 70
SWEP.HideViewmodel = true
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.IconOverride = "materials/entities/rw_sw_tusken_cycler.png"
SWEP.NoHideLeftHandInCustomization = false
SWEP.DefaultBodygroups = "000000000000"

SWEP.Damage = 195
SWEP.RangeMin = 453
SWEP.DamageMin = 73
SWEP.Range = 863
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400

SWEP.PhysTracerProfile = 1

SWEP.TracerNum = 1
SWEP.Tracer = "tfa_tracer_yellow"
SWEP.TracerCol = Color(255, 165, 18)
SWEP.HullSize = 1.5

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 6

SWEP.Recoil = 0.54
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.22

SWEP.Delay = 60 / 90
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    }, 
    {
        Mode = 0
    },     
}

SWEP.AccuracyMOA = 0.52 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 500 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 50
SWEP.SightsDispersion = 0

----AMMO / stuff----

SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 100
SWEP.ShootPitch = 100

SWEP.ShootSound = "w/tcr.wav"

SWEP.NoFlash = nil -- disable light flash
SWEP.MuzzleEffect = nil
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false

SWEP.MuzzleFlashColor = Color(255, 165, 18)

SWEP.IronSightStruct = {
    Pos = Vector(-3.64, -8, 2.3),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 60,
}
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "ar2"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(1, 0, -2)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(3, 0, 0)
SWEP.SprintAng = Angle(-10, 40, -40)

SWEP.HolsterPos = Vector(0.2, -1, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(20.824, -10, 3.897)
SWEP.CustomizeAng = Angle(12.149, 50.547, 45)

SWEP.DefaultElements = {"tcr"}

SWEP.AttachmentElements = {
    ["tcr"] = {
        VMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/tusken_cycler_rifle.mdl", -- using the model-edit i made in like 2 mins lol
                Bone = "v_dlt19_reference001",
                Scale = Vector(1.2, 1.1, 1.2),
                Offset = {
                    pos = Vector(0, -1, 1),
                    ang = Angle(0,-90, 0)
                }
            }
        },
        WMElements = {
            {
                Model = "models/arccw/sw_battlefront/weapons/tusken_cycler_rifle.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1.1, 1.1, 1.1),
                Offset = {
                    pos = Vector(3.75, 50.5, -1.5),
                    ang = Angle(-15, 0, 180)
                }
            }
        }, -- change the world model to something else. Please make sure it's compatible with the last one.
    },
}
WMOverride = "models/arccw/sw_battlefront/weapons/tusken_cycler_rifle.mdl"
--SWEP.Attachments 
SWEP.Attachments = {
    [1] = {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights", -- used to display the "no attachment" text
        Slot = "optic",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.4, 1.15, 9),
            vang = Angle(90, 0, -90),
            wpos = Vector(1000, 40, -490),
            wang = Angle(-15, 0, 180)
        },
    },
    [2] = {
        PrintName = "Foregrip", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = "foregrip",
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments wwill be mostly referring to
        Offset = {
            vpos = Vector(-0.3, 3.5, 9),
            vang = Angle(90, 0, -90),
            wang = Angle(170, 180, 0),
        },
        SlideAmount = {
        vmin = Vector(-0.3, 3.5, 2),
        vmax = Vector(-0.3, 3.5, 10),
        wmin = Vector(1600, 60, -440), 
        wmax = Vector(1600, 60, -440) -- how far this attachment can slide in both directions.
        },         
    },          
    [3] = {
        PrintName = "Tactical", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {"tactical","tac_pistol"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0, 3.1, 14),
            vang = Angle(90, 0, -90),
            wpos = Vector(2300, 40, -600),
            wang = Angle(-15, 0, -180)
        },
    },     
    [4] = {
        PrintName = "Muzzle", -- print name
        DefaultAttName = "No Attachment", -- used to display the "no attachment" text
        Slot = {},
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-0.3, 2.05, 12),
            vang = Angle(90, 0, -90),
        },
    },             
    [5] = {
        PrintName = "Energization", -- print name
        DefaultAttName = "Standard Energization", -- used to display the "no attachment" text
        Slot = "ammo",
    },
    [6] = {
        PrintName = "Training/Perk", -- print name
        DefaultAttName = "None", -- used to display the "no attachment" text
        Slot = "perk",
    },
    [7] = {
        PrintName = "Charms", -- print name
        DefaultAttName = "No Charm", -- used to display the "no attachment" text
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "dlt19_sight", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(0.4, 2.1, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(900, 120, -300),
            wang = Angle(-10 , 0, 180)
        },
    },          
}
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["fire"] = {
        Source = "fire"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "draw/overheat_manualcooling_resetfoley_generic_var_04.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "w/dc15s/gunfoley_blaster_sheathe_var_03.mp3", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "ArcCW_dc15a.reload2", t = 4 / 30}, --s sound file
        },
    },


sound.Add({
    name =          "ArcCW_dc15a.reload2",
    channel =       CHAN_ITEM,
    volume =        1.0,
    sound =             "weapons/bf3/heavy.wav"
    }),
}
--addons/weapons_other/lua/weapons/astromech_swep.lua:
AddCSLuaFile()

SWEP.PrintName			= "Astromech SWEP"
SWEP.Author				= "Rino" 
SWEP.Instructions		= [[
R - /
LMB - Random Sound
RMB - Schrei Sound
	]]
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Category	= "AOCRP - Soundsweps"

SWEP.AnimPrefix = "rpg"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo		= "none"
SWEP.Primary.Distance		= 100
SWEP.Primary.Delay			= 4
SWEP.Primary.Damage			= 40

--SWEP.stunTime = 2.5;
 
SWEP.HoldType			= "normal"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		= "none"
SWEP.Secondary.Delay	= 10

SWEP.Weight			= 5
SWEP.AutoSwitchTo		= false
SWEP.AutoSwitchFrom		= false
SWEP.Slot			= 1
SWEP.SlotPos			= 1
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= true
SWEP.ViewModel			= "models/weapons/c_medkit.mdl"
SWEP.WorldModel	= ""



soundsastro = {
    [1] = "astromech/beep1.mp3",
    [2] = "astromech/beep2.mp3",
    [3] = "astromech/beep3.mp3",
    [4] = "astromech/beep4.mp3",
    [5] = "astromech/beep5.mp3",
    [6] = "astromech/beep6.mp3",
    [7] = "astromech/beep7.mp3",
    [8] = "astromech/beep8.mp3",
    [9] = "astromech/beep9.mp3",
    [10] = "astromech/beep10.mp3",
    
    }



function SWEP:Initialize()
	self:SetWeaponHoldType( self.HoldType )
end

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	local rand = math.random(1,10)
          nrw = soundsastro[rand]
		  timer.Simple( 0.5, function() self:EmitSound(nrw) end )
          --EmitSound(nrw)
end


function SWEP:Reload()
end

function SWEP:SecondaryAttack()
	self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
	timer.Simple( 0.5, function() self:EmitSound("astromech/scream.mp3") end )
end

function SWEP:PreDrawViewModel( vm, pl, wep )
	return true
end
--lua/weapons/battle_axe/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = " Battle axe"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Simple"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType 		= "melee2"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_weapon.Knife_Handle"] = { scale = Vector(0.093, 0.093, 0.093), pos = Vector(0, 0, 0), angle = Angle(-7.778, 0, 0) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_Spine4"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, -12.778), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-0.556, 0, 2.407), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_L_Clavicle"] = { scale = Vector(1, 1, 1), pos = Vector(-2.3, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0.925), angle = Angle(-56.667, 0, 0) }
}
SWEP.VElements = {
	["hils+++++++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.699), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/indenttiles_1-2", skin = 0, bodygroup = {} },
	["hils++++++"] = { type = "Model", model = "models/hunter/blocks/cube025x025x025.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 33), angle = Angle(90, 0, 90), size = Vector(0.107, 0.301, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/concrete3", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/indenttiles_1-2", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/hunter/tubes/circle2x2c.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(1.5, 0, 33), angle = Angle(0, 180, 90), size = Vector(0.107, 0.107, 0.107), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/cube", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, 31.399), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.05, 0.107), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(20, 0.8, 10), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils++++"] = { type = "Model", model = "models/hunter/tubes/circle2x2c.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(-1.5, 0, 33), angle = Angle(0, 0.8, 90), size = Vector(0.107, 0.107, 0.107), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/cube", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils++++"] = { type = "Model", model = "models/hunter/tubes/circle2x2c.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(-1.5, 0, 33), angle = Angle(0, 0.8, 90), size = Vector(0.107, 0.107, 0.107), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/cube", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/indenttiles_1-2", skin = 0, bodygroup = {} },
	["hils+++++++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 4.675), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.699), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/indenttiles_1-2", skin = 0, bodygroup = {} },
	["hils+++++"] = { type = "Model", model = "models/hunter/tubes/circle2x2c.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(1.5, 0, 33), angle = Angle(0, 180, 90), size = Vector(0.107, 0.107, 0.107), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/cube", skin = 0, bodygroup = {} },
	["hils+++"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 31.399), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.05, 0.107), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/dome", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 4.675), angle = Angle(-170, -29.222, 0), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/fender_wood", skin = 0, bodygroup = {} },
	["hils++++++"] = { type = "Model", model = "models/hunter/blocks/cube025x025x025.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 33), angle = Angle(90, 0, 90), size = Vector(0.107, 0.301, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/concrete3", skin = 0, bodygroup = {} }
}



SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 50
SWEP.Primary.DelayMiss	 = 2
SWEP.Primary.DelayHit 	 = 1.2
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 22

SWEP.Secondary.Life        = false
SWEP.Secondary.Damage 	   = 70
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 18

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--lua/weapons/demonic_dagger/shared.lua:
SWEP.Author       = "Segaretka"
SWEP.PrintName    = "Demonic dagger"
SWEP.Category     = "Gluk Melee"
SWEP.Contact      = "Type:Melee Class:Demonic"
SWEP.Purpose      = ""
SWEP.Instructions = "LMB to attack, RBM to special attack, Special +damage"
 
SWEP.AdminSpawnable = true
SWEP.AutoSwitchTo   = false
SWEP.Spawnable      = true
SWEP.AutoSwitchFrom = false
SWEP.FiresUnderwater= false
SWEP.Weight         = 5
SWEP.DrawCrosshair  = true
SWEP.Slot           = 0
SWEP.SlotPos        = 1
SWEP.DrawAmmo		= false
SWEP.base           = "weapon_base"
SWEP.HoldType       = "knife"

SWEP.UseHands = true
SWEP.ViewModelFOV   = 40
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = "models/weapons/w_knife_t.mdl"
SWEP.ViewModelFlip  = false
SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
["v_weapon.Knife_Handle"] = { scale = Vector(0.37, 0.37, 0.37), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "ValveBiped.Bip01_Spine4", rel = "hils", pos = Vector(0, 0, 8.831), angle = Angle(0, 90, 0), size = Vector(0.041, 0.009, 0.172), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/smallwheel_side", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/blocks/cube025x125x025.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0.3, -1, 4.675), angle = Angle(0, 0.8, 1.169), size = Vector(0.05, 0.059, 0.05), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/car_tire", skin = 0, bodygroup = {} },
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 0, -0.7), angle = Angle(0, 0.8, 0), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/car_tire", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "v_weapon.Knife_Handle", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/car_tire", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["hils"] = { type = "Model", model = "models/props_c17/oildrum001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 1, 2.5), angle = Angle(-170, 5, 0), size = Vector(0.05, 0.039, 0.108), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/car_tire", skin = 0, bodygroup = {} },
	["hils++"] = { type = "Model", model = "models/hunter/blocks/cube025x125x025.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0.3, -1, 4.675), angle = Angle(0, 0.8, 1.169), size = Vector(0.05, 0.059, 0.05), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/car_tire", skin = 0, bodygroup = {} },
	["blade"] = { type = "Model", model = "models/hunter/misc/squarecap1x1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, 8.831), angle = Angle(0, 90, 0), size = Vector(0.041, 0.009, 0.172), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/smallwheel_side", skin = 0, bodygroup = {} },
	["hils+"] = { type = "Model", model = "models/hunter/misc/sphere1x1.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "hils", pos = Vector(0, 0, -0.102), angle = Angle(0, 90, 0), size = Vector(0.028, 0.039, 0.028), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/car_tire", skin = 0, bodygroup = {} }
}

SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize 	 = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic   = true
SWEP.Primary.Ammo 		 = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.Primary.Damage 	 = 12
SWEP.Primary.DelayMiss	 = 1
SWEP.Primary.DelayHit 	 = 0.26
SWEP.Primary.Force 		 = 1
SWEP.Primary.ImpactDecal = "ManhackCut"
SWEP.Primary.Range       = 10

SWEP.Secondary.Damage 	   = 36
SWEP.Secondary.DelayMiss   = 1.5
SWEP.Secondary.DelayHit	   = 0.7
SWEP.Secondary.Force	   = 5
SWEP.Secondary.ImpactDecal = "Impact.Metal"
SWEP.Secondary.Range       = 12

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.ImpactHard" )
local HitSoundBody = Sound( "Flesh_Bloody.ImpactHard" )
local HitSoundProp = Sound( "" )
local indec = 0

SWEP.indec = 0

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
self.indec = 0
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Primary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Primary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Primary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Primary.Range*4,
filter = self.Owner,
mins = Vector( -1* self.Primary.Range, -1*self.Primary.Range, 0 ),
maxs = Vector(  1* self.Primary.Range,  1*self.Primary.Range, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Primary.Damage = self.Primary.Damage + 5
		self.Secondary.Damage = self.Secondary.Damage + 5
		self.indec = self.indec + 1
		
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end


function SWEP:SecondaryAttack()
self:SetHoldType( self.HoldType )
self:EmitSound( SwingSound )
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = self.Secondary.Distance
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = self.Secondary.Force
bullet.Damage = 0
bullet.AmmoType = "none"

local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if ( tr.Hit ) then
util.Decal(self.Secondary.ImpactDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)  
end
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Secondary.Range*4,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Secondary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Secondary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if ( tr.Hit ) then
		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
		if string.find(tr.Entity:GetClass(),"prop_physics") then
		self:EmitSound( HitSoundProp )
		else
		self:EmitSound( HitSoundBody )
		if self.indec < 11 then
		self.Primary.Damage = self.Primary.Damage + 5
		self.Secondary.Damage = self.Secondary.Damage + 5
		self.indec = self.indec + 1
		end
		end
		self.Owner:FireBullets(bullet)	
		else
		self:EmitSound( HitSoundWorld )
		end
		end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
self:SetNextPrimaryFire( CurTime() + self.Secondary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Secondary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end


--addons/weapon_jedi/lua/weapons/electrostaff.lua:
AddCSLuaFile()

SWEP.Base = "weapon_lscs"
DEFINE_BASECLASS("weapon_lscs")

SWEP.Category = "[LSCS]"
SWEP.PrintName = "Elektrostab"
SWEP.Author = "Deltaa"

SWEP.Slot = 0
SWEP.SlotPos = 3

SWEP.Spawnable = false
SWEP.AdminOnly = false

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables(self)

	if SERVER then
		self:SetHiltR("staffel")
		self:SetBladeR("electrostaff_mg")
		self:SetStance("electrostaff")
	end
end

if CLIENT then
    function SWEP:DrawBlade( HandID, BladeID, PosData, bladeObject, Mul, HiltAngles )
        local length = bladeObject.length * (PosData.length_multiplier or 1)
    
        local width = bladeObject.width * (PosData.width_multiplier or 1)
        local actual_width = width + math.Rand(0,bladeObject.widthWiggle)
    
        local pos = PosData.pos
        local dir = PosData.dir
    
        local w12 = width * 6
        local w32 = width * 16
    
        local color_blur = bladeObject.color_blur
        local color_core = bladeObject.color_core
    
        local Frac = self:DoBladeTrace( HandID, BladeID, pos, dir, length * Mul, width ).Fraction
    
        local MulxFrac = Mul * Frac
    
        if bladeObject.mdl then
            self:DrawBladeModel( HandID, BladeID, PosData, bladeObject, MulxFrac, HiltAngles )
    
            return
        end
    
        render.SetMaterial( bladeObject.material_glow )
        render.DrawSprite( pos, width, w32, color_blur )
    
        -- inefficient pls replace
        for i = 0, math.Round( (length - 1) * MulxFrac, 0 ) do
            render.DrawSprite( pos + dir * i, w12, w12, color_blur ) 
        end
    
        local EndPos = pos + dir * math.max(length - 0.9,0) * MulxFrac
    
        render.SetMaterial( bladeObject.material_core )
        render.DrawBeam( pos, EndPos, actual_width , 1, 1, color_core )
    
        render.SetMaterial( bladeObject.material_core_tip )
        render.DrawBeam( EndPos, EndPos + dir, actual_width , 0.9, 0.1, color_core )
    end
end
--addons/tools/lua/weapons/gmod_tool/stools/gparticles.lua:
TOOL.Category = "Render"
TOOL.Name = "Particles"
TOOL.ClientConVar["key"] = "37"
TOOL.ClientConVar["particle"] = "medicgun_beam_red_invun"
TOOL.ClientConVar["cps"] = "0"
TOOL.ClientConVar["att"] = "0"
TOOL.ClientConVar["autokill"] = "0"
TOOL.Information = {
	{ name = "left", stage = 0 },
	{ name = "right", stage = 0 },
	{ name = "right_1", stage = 1 },
}

if CLIENT then
	language.Add("tool.gparticles.name", "Particle Spawner")
	language.Add("tool.gparticles.desc", "Spawn silly particles")
	language.Add("tool.gparticles.left", "Click to spawn a particle you moron")
	language.Add("tool.gparticles.right", "Select a particle controller to attach to")
	language.Add("tool.gparticles.right_1", "Select on what entity do you want to attach to")
end

cleanup.Register("particles")
CreateConVar("sbox_maxparticles", "5", FCVAR_ARCHIVE)
local function CheckLimit(ply, key)
	-- TODO: Clientside prediction
	if CLIENT then return true end
	local found = false
	for id, particle in ipairs(ents.FindByClass("sent_particle_def")) do
		if not particle.controlkey or particle.controlkey ~= key then continue end
		if IsValid(particle:GetPlayer()) and ply ~= particle:GetPlayer() then continue end
		found = true
		break
	end

	if not found and not ply:CheckLimit("particles") then return false end

	return true
end

local function MakeParticle(ply, key, particle, cps, autokill, Data)
	if IsValid(ply) and not CheckLimit(ply, key) then return false end
	local ent = ents.Create("sent_particle_def")
	if not IsValid(ent) then return false end
	duplicator.DoGeneric(ent, {
		particle = particle,
		cps = cps,
		autokill = autokill,
		Data = Data
	})

	ent.particle = particle
	ent.cps = cps
	ent.autokill = autokill

	ent:SetPlayer(ply)
	ent:SetPos(ply:GetEyeTrace().HitPos)
	ent:Spawn()
	ent:SetControlPoints(cps or 0)
	ent:SetAutoKill((autokill or 0) == 1)
	ent:SetParticleName(particle)

	timer.Simple(.1, function()
		net.Start("GPart.Restart")
		net.WriteEntity(ent)
		net.SendPVS(ent:GetPos())
	end)

	DoPropSpawnedEffect(ent)
	numpad.OnDown(ply, key, "Particle_Toggle", ent)
	if IsValid(ply) then
		ply:AddCleanup("particles", ent)
		ply:AddCount("particles", ent)
	end

	return ent
end

duplicator.RegisterEntityClass("sent_particle_def", function(ply, data)
	local ent = MakeParticle(ply, data.controlkey, data.particle, data.cps, data.autokill, data.Data)
	return ent
end, "Data")

function TOOL:LeftClick(trace)
	local ply = self:GetOwner()
	local key = self:GetClientNumber("key")
	if key == -1 then return false end
	if not CheckLimit(ply, key) then return false end
	if CLIENT then return true end

	if self:GetStage() == 1 then
		self:RightClick(trace)
		self:SetStage(0)
		return true
	end
	local autokill = self:GetClientNumber("autokill")
	local cps = self:GetClientNumber("cps")
	local particle = self:GetClientInfo("particle")
	local ent = MakeParticle(
		ply,
		key,
		particle,
		cps,
		autokill,
		{
			Pos = trace.StartPos,
			Angle = ply:EyeAngles()
		}
	)

	if not IsValid(ent) then return false end
	undo.Create("Particle")
	undo.AddEntity(ent)
	undo.SetPlayer(ply)
	undo.Finish()

	return true, ent
end

function TOOL:RightClick(trace)
	local ent = trace.Entity

	if self:GetStage() == 1 then
		if not IsValid(ent) then return end

		local obj = self:GetEnt(1)
		if IsValid(obj) then
			obj.lastPlace = obj:GetPos()
			obj:SetMoveType(MOVETYPE_NONE)
			obj:SetParent(ent, self:GetClientNumber("att"))
			obj:SetLocalPos(Vector(0, 0, 0))
			obj:SetAttachmentSelected(self:GetClientNumber("att"))

			if SERVER then
				undo.Create("Particle Attach")
				undo.AddFunction(function()
					if IsValid(obj) then
						obj:SetParent(nil)
						obj:SetMoveType(MOVETYPE_VPHYSICS)
						obj:SetPos(obj.lastPlace)
						obj:GetPhysicsObject():EnableGravity(false)
					end
				end)
				undo.SetPlayer(self:GetOwner())
				undo.Finish("Removed Particle Attachment")
			end
		end

		self:SetStage(0)
		return true
	end
	if ent:GetClass() != "sent_particle_def" then
		return false
	end

	self:SetObject(1, ent, trace.HitPos, ent:GetPhysicsObject(), 0, trace.HitNormal)
	self:SetStage(1)
	return true
end

local ConVarsDefault = TOOL:BuildConVarList()
function TOOL.BuildCPanel(CPanel)
	CPanel:AddControl(
		"ComboBox",
		{
			MenuButton = 1,
			Folder = "camera",
			Options = {
				["#preset.default"] = ConVarsDefault
			},
			CVars = table.GetKeys(ConVarsDefault)
		}
	)

	CPanel:AddControl(
		"Numpad",
		{
			Label = "Particle Enable Key",
			Command = "gparticles_key"
		}
	)

	CPanel:AddControl(
		"textbox",
		{
			Label = "Particle Name",
			Command = "gparticles_particle"
		}
	)

	CPanel:AddControl(
		"CheckBox",
		{
			Label = "Destroy particle after done",
			Command = "gparticles_autokill"
		}
	)

	CPanel:AddControl(
		"slider",
		{
			Label = "Control Points",
			Command = "gparticles_cps",
			Min = 0,
			Max = 32
		}
	)

	CPanel:AddControl(
		"slider",
		{
			Label = "Attachment",
			Command = "gparticles_att",
			Min = 0,
			Max = 16
		}
	)
end
--gamemodes/starwarsrp/entities/weapons/gmod_tool/stools/keypad.lua:
TOOL.Category = "Age of Clones"
TOOL.Name = "Keypad"

TOOL.ClientConVar[ "clearance" ] = "0"

if CLIENT then
    language.Add("tool.keypad.name", "AOCRP Keypad")
    language.Add("tool.keypad.desc", "Für Zugriffsbeschränkte Dinge")
    language.Add("tool.keypad.0", "Linksklick - > Tür oder Knopf hinzufügen, Rechtsklick -> Nächster Schritt, Reload -> Alles löschen")

	local ConVarsDefault = TOOL:BuildConVarList()

    function TOOL:DrawToolScreen(width, height)

        if SERVER then return end
    
        surface.SetDrawColor(143, 81, 0)
        surface.DrawRect(0, 0, 256, 256)
    
        surface.SetFont("PermaPropsToolScreenFont")
        local w, h = surface.GetTextSize(" ")
        surface.SetFont("PermaPropsToolScreenSubFont")
        local w2, h2 = surface.GetTextSize(" ")
    
        draw.SimpleText("AOCRP", "PermaPropsToolScreenFont", 128, 100, Color(224, 224, 224, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, Color(17, 148, 240, 255), 4)
        draw.SimpleText("Keypad", "PermaPropsToolScreenSubFont", 128, 128 + (h + h2) / 2 - 4, Color(224, 224, 224, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, Color(17, 148, 240, 255), 4)
    
    end
    
	function TOOL.BuildCPanel(CPanel)
		CPanel:SetName("AOCRP Keypad")

		CPanel:Help("Wenn du nicht weißt wie es geht, solltest du es auch nicht nutzen.")

		CPanel:AddControl( "ComboBox", { 
			MenuButton = 1, 
			Folder = "keypad",
			Command = "keypad_clearance",
		} )

		local eType = CPanel:ComboBox("Sicherheitslevel", "keypad_clearance")
		eType:SetTextColor(Color(0,0,0))

		for k, v in pairs(AOCRP.Config.Sicherheitslevel) do
			eType:AddChoice(v.name, k)
		end
	end

	function TOOL:LeftClick(tr)
		return true
	end

	function TOOL:RightClick(tr)
		return true
	end
else
	local COL_GRN = Color(46, 204, 113, 150)

    function TOOL:Think()
		if ( self.currentStep == 2 ) then
			if not IsValid(self:GetOwner().NCS_buttonHologram) then
				self:GetOwner().NCS_buttonHologram = ents.Create("prop_physics")

				if IsValid(self:GetOwner().NCS_buttonHologram) then
					self:GetOwner().NCS_buttonHologram:SetColor(COL_GRN)
					self:GetOwner().NCS_buttonHologram:SetModel("models/kingpommes/starwars/misc/imp_wallpanel.mdl")
					self:GetOwner().NCS_buttonHologram:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
					self:GetOwner().NCS_buttonHologram:SetRenderMode(RENDERMODE_TRANSALPHA)

					self:GetOwner().NCS_buttonHologram:Spawn()
				end
			else
				local tr = self:GetOwner():GetEyeTrace()

				self:GetOwner().NCS_buttonHologram:SetAngles(Angle(0, self:GetOwner():GetAngles().y + 180, 0))
				self:GetOwner().NCS_buttonHologram:SetPos(tr.HitPos)
			end			
		else
			if IsValid(self:GetOwner().NCS_buttonHologram) then self:GetOwner().NCS_buttonHologram:Remove() end
		end
    end

	function TOOL:Holster()
		if IsValid(self:GetOwner().NCS_buttonHologram) then
			self:GetOwner().NCS_buttonHologram:Remove()
		end 

        self.Doors = nil
	end

    local doorClasses = {
        ["func_door"] = true,
        ["func_door_rotating"] = true,
        ["func_movelinear"] = true,
        ["prop_dynamic"] = true,
    }

	function TOOL:LeftClick(tr)
		
		if !self.currentStep then
			self.currentStep = 1
			self.selectedDoors = {}
			self.addedButtons = {}
		end
	
	
	
		if ( self.currentStep == 1 ) then
			
			if !IsValid(tr.Entity) then return end

            if tr.Entity:GetClass() == "prop_dynamic" then
                if tr.Entity.PermaProps_ID then  
                    if tr.Entity.PermaProps_ID > 1 then 
                        table.insert(self.selectedDoors, tr.Entity)
                        self:GetOwner():ChatPrint("*** Dingsbums erfasst: PP".. tr.Entity.PermaProps_ID  .. " - "..tr.Entity:GetClass())
                        return
                    end
                    return
                end 
                return
            end 
			
			if doorClasses[tr.Entity:GetClass()] then
				table.insert(self.selectedDoors, tr.Entity)
                self:GetOwner():ChatPrint("*** Dingsbums erfasst: "..tr.Entity:MapCreationID() .. " - "..tr.Entity:GetClass())
			elseif IsValid(tr.Entity:GetParent()) and doorClasses[tr.Entity:GetParent():GetClass()] then
				table.insert(self.selectedDoors, tr.Entity:GetParent())
                self:GetOwner():ChatPrint("*** Dingsbums erfasst: "..tr.Entity:GetParent():MapCreationID())
			end
		elseif ( self.currentStep == 2 ) then
			table.insert(self.addedButtons, {
				POS = tr.HitPos,
				ANG = Angle(0, self:GetOwner():GetAngles().y + 180, 0)
			})

            self:GetOwner():ChatPrint("*** Neuer Knopf erfasst")
		end
	
		
		return true
	end
	
	local randomTesting = {}
	
	function TOOL:RightClick(tr)
		if ( self.currentStep == 1 ) and #self.selectedDoors >= 1 then
			self.currentStep = 2
		elseif ( self.currentStep == 2 ) and #self.addedButtons >= 1 then
			local uniqueID = os.time()
	
			local tabNew = {}
			
			for k, v in ipairs(self.selectedDoors) do
				if !IsValid(v) then continue end
	
				v:Fire("close")
				v:Fire("lock")
	
				v.uniqueConnectionID = uniqueID

                if v:GetClass() == "prop_dynamic" then
                    if v.PermaProps_ID then  
                        if v.PermaProps_ID > 1 then 
                            table.insert(tabNew, "PP"..v.PermaProps_ID )
                        end
                    end 
                    continue
                end 
     
				table.insert(tabNew, v:MapCreationID())
       
			end
			
			for k, v in ipairs(self.addedButtons) do
				local button = ents.Create("aoc_keypad")
				button:Spawn()
				button:SetAngles(v.ANG)
				button:SetPos(v.POS)
				button:SetSicherheitslevel(self:GetClientInfo("clearance"))
				
				button.uniqueConnectionID = uniqueID
				
				button.selectedDoors = tabNew

                undo.Create("Keypad")
                undo.AddEntity(button)
                undo.SetPlayer(self:GetOwner())
                undo.Finish()
	
				self.currentStep = 1
				self.selectedDoors = {}
				self.addedButtons = {}
                
			end
	
			--NCS_KEYCARDS_SaveKeypads()
		end
	
		return true
	end
	
	function TOOL:Reload(tr)
	
        self.currentStep = 1
        self.selectedDoors = {}
        self.addedButtons = {}

        self:GetOwner():ChatPrint("*** Alles zurückgesetzt.")

	end
end
--addons/tools/lua/weapons/gmod_tool/stools/nocollide_world.lua:
TOOL.Category		= "Construction"
TOOL.Name			= "#No Collide World"
TOOL.Command		= nil
TOOL.ConfigName		= nil

TOOL.ClientConVar["options"] = "1"
TOOL.ClientConVar["distance"] = "10"
TOOL.ClientConVar["ignore"] = "1"
TOOL.ClientConVar["effect"] = "0"
TOOL.ClientConVar["remove"] = "0"

if SERVER then
	resource.AddFile("materials/effects/render_vector.vtf")
	resource.AddFile("materials/effects/render_vector.vmt")
	util.AddNetworkString("DrawNoCollide")
end

if CLIENT then
	language.Add("Tool.nocollide_world.name", "No collide world")
	language.Add("Tool.nocollide_world.desc", "To let an objects ignore collisions")
	language.Add("Tool.nocollide_world.0", "Click on 2 objects or world to make them not collide or right click to make an object not collide with anything.")
	language.Add("Tool.nocollide_world.1", "Now click on something else.")
	language.Add("Tool.nocollide_world.2", "Click on an object to prevent it from colliding with the world or right click to make an object not collide with anything.")
	language.Add("Tool.nocollide_world.3", "Click on 2 objects with or without connected objects to make them not collide including connected objects or right click to make an object not collide with anything.")
	language.Add("Tool.nocollide_world.4", "Now click on something else.")
	language.Add("Tool.nocollide_world.5", "Click on an object with connected objects to prevent it from colliding with each other or right click to make an object not collide with anything.")
	language.Add("Tool.nocollide_world.6", "Prevent an object from colliding with players or right click to make an object not collide with anything.")
	language.Add("Tool.nocollide_world.7", "Prevent an object from colliding with objects within box or right click to make an object not collide with anything.")
	language.Add("Tool.nocollide_world.8", "Prevent an object from colliding with objects within sphere or right click to make an object not collide with anything.")
	language.Add("Tool.nocollide_world.9", "Click on an object to select. Right click to apply no collide between all selected objects.")
	
	local EFFECT = {}
	EFFECT.Draw = {}
	EFFECT.Register = {}
	EFFECT.Ents = {}
	--[[
		EFFECT.Ents[Index][1] = Entity
		EFFECT.Ents[Index][2] = Color
		EFFECT.Ents[Index][3] = Rendermode
		EFFECT.Ents[Index][4][Type] = Eff_Count
		or
		EFFECT.Ents[Index][4][Type][Count] = Eff_Count
		
		EFFECT.Register[Type][Eff_Count][Ent_Count] = Index
		EFFECT.Register[Type][Eff_Count][3] = DrawCount
	]]
	
	local function RegisterEffect(Type,Index,Ent,Count)
		if !EFFECT.Ents[Index] then EFFECT.Ents[Index] = {} end
		if !EFFECT.Ents[Index][1] then EFFECT.Ents[Index][1] = Ent end
		if !EFFECT.Ents[Index][2] then EFFECT.Ents[Index][2] = Ent:GetColor() end
		if !EFFECT.Ents[Index][3] then EFFECT.Ents[Index][3] = Ent:GetRenderMode() end
		
		if !EFFECT.Register[Type] then EFFECT.Register[Type] = {} end
		Count = Count or #EFFECT.Register[Type]+1
		if !EFFECT.Register[Type][Count] then EFFECT.Register[Type][Count] = {} end
		if EFFECT.Register[Type][Count][1] then EFFECT.Register[Type][Count][2] = Index else EFFECT.Register[Type][Count][1] = Index end
		
		if !EFFECT.Ents[Index][4] then EFFECT.Ents[Index][4] = {} end
		if Type == 1 or Type == 2 or Type == 3 or Type == 4 or Type == 15 or Type == 16 or Type == 17 then
			if !EFFECT.Ents[Index][4][Type] then EFFECT.Ents[Index][4][Type] = {} end
			EFFECT.Ents[Index][4][Type][#EFFECT.Ents[Index][4][Type]+1] = Count
		else
			EFFECT.Ents[Index][4][Type] = Count
		end
		return Count
	end
	
	local function CleanupTables()
		local DrawPositions = {}
		local NewDraw = {}
		local Count = 0
		for i=1,#EFFECT.Draw do
			if EFFECT.Draw[i] then
				Count = Count+1
				DrawPositions[i] = Count
				NewDraw[Count] = EFFECT.Draw[i]
			end
		end
		EFFECT.Draw = NewDraw
		
		local RegisterPositions = {}
		local NewRegister = {}
		Count = {}
		
		for Type,v in pairs(EFFECT.Register) do
			RegisterPositions[Type] = {}
			NewRegister[Type] = {}
			Count[Type] = 0
			for EffectCount=1,#EFFECT.Register[Type] do
				if EFFECT.Register[Type][EffectCount] then
					Count[Type] = Count[Type]+1
					RegisterPositions[Type][EffectCount] = Count[Type]
					NewRegister[Type][Count[Type]] = EFFECT.Register[Type][EffectCount]
					if EFFECT.Register[Type][EffectCount][3] then NewRegister[Type][Count[Type]][3] = DrawPositions[EFFECT.Register[Type][EffectCount][3]] end
				end
			end
		end
		
		local Continue
		for k,v in pairs(Count) do
			if v > 0 then
				Continue = true
				break
			end
		end
		
		if Continue then
			EFFECT.Register = NewRegister
			
			for Index,v1 in pairs(EFFECT.Ents) do if EFFECT.Ents[Index] and EFFECT.Ents[Index][4] then for Type,v2 in pairs(EFFECT.Ents[Index][4]) do if RegisterPositions[Type] then if Type == 1 or Type == 2 or Type == 3 or Type == 4 or Type == 15 or Type == 16 or Type == 17 then for k3,v3 in pairs(v2) do EFFECT.Ents[Index][4][Type][k3] = RegisterPositions[Type][v3] end else EFFECT.Ents[Index][4][Type] = RegisterPositions[Type][v2] end else EFFECT.Ents[Index][4][Type] = nil end end end end
			
			local EntFound
			for k,v in pairs(EFFECT.Ents) do
				if v then
					EntFound = true
					break
				end
			end
			if !EntFound then
				EFFECT.Draw = {}
				EFFECT.Register = {}
				EFFECT.Ents = {}
				if EFFECT.Remove == false then EFFECT.Remove = true end
			end
		else
			for k,v in pairs(EFFECT.Ents) do
				if v then
					local Ent = v[1]
					if IsValid(Ent) then
						Ent:SetColor(v[2])
						Ent:SetRenderMode(v[3])
					end
				end
			end
			EFFECT.Draw = {}
			EFFECT.Register = {}
			EFFECT.Ents = {}
			if EFFECT.Remove == false then EFFECT.Remove = true end
		end
	end
	
	local function RemoveEntFromEffect(Ent,Index,Type,EffectCount)
		if IsValid(Ent) and type(Index) == "number" and EFFECT.Ents[Index] then
			local Found
			local Removed
			for k1,v1 in pairs(EFFECT.Ents[Index][4]) do
				if k1 == Type then
					if type(v1) == "table" then
						for k2,v2 in pairs(v1) do
							if v2 == EffectCount then
								EFFECT.Ents[Index][4][k1][k2] = nil
								if Found then return end
								Removed = true
							else
								if Removed then return end
								Found = true
							end
						end
					else
						EFFECT.Ents[Index][4][k1] = nil
						if Found then return end
						Removed = true
					end
				else
					if type(v1) == "table" then
						for k2,v2 in pairs(v1) do
							if Removed then return end
							Found = true
							break
						end
					else
						if Removed then return end
						Found = true
					end
				end
			end
			if !Found then
				Ent:SetColor(EFFECT.Ents[Index][2])
				Ent:SetRenderMode(EFFECT.Ents[Index][3])
				EFFECT.Ents[Index] = false
			end
		elseif Index then
			EFFECT.Ents[Index] = false
		end
	end
	
	net.Receive("DrawNoCollide",function()
		local String = net.ReadString()
		if String == "0" then
			EFFECT.Draw = {}
			EFFECT.Register = {}
			for k,v in pairs(EFFECT.Ents) do
				if v then
					local Ent = v[1]
					if IsValid(Ent) then
						Ent:SetColor(v[2])
						Ent:SetRenderMode(v[3])
					end
				end
			end
			EFFECT.Ents = {}
			if EFFECT.Remove == false then EFFECT.Remove = true end
		elseif String == "0a" then
			for Type,v1 in pairs(EFFECT.Register) do
				if Type == 1 or Type == 2 or Type == 3 or Type == 4 then
					for EffectCount=1,#EFFECT.Register[Type] do
						if EFFECT.Register[Type][EffectCount] then
							local Ent1Index,Ent2Index = EFFECT.Register[Type][EffectCount][1],EFFECT.Register[Type][EffectCount][2]
							local Ent1
							local Ent2
							if Ent1Index and EFFECT.Ents[Ent1Index] then Ent1 = EFFECT.Ents[Ent1Index][1] end
							if Ent2Index and EFFECT.Ents[Ent2Index] then Ent2 = EFFECT.Ents[Ent2Index][1] end
							if EFFECT.Register[Type][EffectCount][3] and EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] then EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] = false end
							RemoveEntFromEffect(Ent1,Ent1Index,Type,EffectCount)
							RemoveEntFromEffect(Ent2,Ent2Index,Type,EffectCount)
							EFFECT.Register[Type][EffectCount] = false
						end
					end
				elseif Type == 5 or Type == 6 or Type == 7 or Type == 8 or Type == 9 or Type == 10 or Type == 11 then
					for EffectCount=1,#EFFECT.Register[Type] do
						if EFFECT.Register[Type][EffectCount] then
							local Ent1Index = EFFECT.Register[Type][EffectCount][1]
							local Ent1
							if Ent1Index and EFFECT.Ents[Ent1Index] then Ent1 = EFFECT.Ents[Ent1Index][1] end
							if EFFECT.Register[Type][EffectCount][3] and EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] then EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] = false end
							RemoveEntFromEffect(Ent1,Ent1Index,Type,EffectCount)
							EFFECT.Register[Type][EffectCount] = false
						end
					end
				end
			end
			CleanupTables()
		elseif String == "0b" then
			for Type,v1 in pairs(EFFECT.Register) do
				if Type == 15 or Type == 16 or Type == 17 then
					for EffectCount=1,#EFFECT.Register[Type] do
						if EFFECT.Register[Type][EffectCount] then
							local Ent1Index,Ent2Index = EFFECT.Register[Type][EffectCount][1],EFFECT.Register[Type][EffectCount][2]
							local Ent1
							local Ent2
							if Ent1Index and EFFECT.Ents[Ent1Index] then Ent1 = EFFECT.Ents[Ent1Index][1] end
							if Ent2Index and EFFECT.Ents[Ent2Index] then Ent2 = EFFECT.Ents[Ent2Index][1] end
							if EFFECT.Register[Type][EffectCount][3] and EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] then EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] = false end
							RemoveEntFromEffect(Ent1,Ent1Index,Type,EffectCount)
							RemoveEntFromEffect(Ent2,Ent2Index,Type,EffectCount)
							EFFECT.Register[Type][EffectCount] = false
						end
					end
				elseif Type == 12 or Type == 13 or Type == 14 then
					for EffectCount=1,#EFFECT.Register[Type] do
						if EFFECT.Register[Type][EffectCount] then
							local Ent1Index = EFFECT.Register[Type][EffectCount][1]
							local Ent1
							if Ent1Index and EFFECT.Ents[Ent1Index] then Ent1 = EFFECT.Ents[Ent1Index][1] end
							if EFFECT.Register[Type][EffectCount][3] and EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] then EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] = false end
							RemoveEntFromEffect(Ent1,Ent1Index,Type,EffectCount)
							EFFECT.Register[Type][EffectCount] = false
						end
					end
				end
			end
			CleanupTables()
		else
			if EFFECT.Remove == nil then util.Effect("render_no_collide", EffectData()) end
			EFFECT.Remove = false
			local Table = string.Explode("_",String)
			if #Table == 2 then
				local Index = tonumber(Table[1])
				if Table[2][1] == "-" then
					local Type = tonumber(string.sub(Table[2],2,string.len(Table[2])))
					if EFFECT.Ents[Index] and EFFECT.Ents[Index][4] and EFFECT.Ents[Index][4][Type] then
						local EffectCount = EFFECT.Ents[Index][4][Type]
						local Ent1
						if Index and EFFECT.Ents[Index] then Ent1 = EFFECT.Ents[Index][1] end
						if EFFECT.Register[Type][EffectCount][3] and EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] then EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] = false end
						RemoveEntFromEffect(Ent1,Index,Type,EffectCount)
						EFFECT.Register[Type][EffectCount] = false
						CleanupTables()
					end
				else
					local Type = tonumber(Table[2])
					if !(EFFECT.Ents[Index] and EFFECT.Ents[Index][4] and EFFECT.Ents[Index][4][Type]) then
						local Ent = ents.GetByIndex(Index)
						if IsValid(Ent) then RegisterEffect(Type,Index,Ent) end
					end
				end
			else
				local Ent1Index = math.min(tonumber(Table[1]),tonumber(Table[2]))
				local Ent2Index = math.max(tonumber(Table[1]),tonumber(Table[2]))
				if Table[3][1] == "-" then
					local Type = tonumber(string.sub(Table[3],2,string.len(Table[3])))
					if EFFECT.Ents[Ent1Index] and EFFECT.Ents[Ent2Index] and EFFECT.Ents[Ent1Index][4] and EFFECT.Ents[Ent2Index][4] and EFFECT.Ents[Ent1Index][4][Type] and EFFECT.Ents[Ent2Index][4][Type] then
						local EffectCount
						for k,v in pairs(EFFECT.Ents[Ent1Index][4][Type]) do
							if EFFECT.Register[Type] and EFFECT.Register[Type][v] and EFFECT.Register[Type][v][1] == Ent1Index and EFFECT.Register[Type][v][2] == Ent2Index then
								EffectCount = v
								break
							end
						end
						if !EffectCount then
							for k,v in pairs(EFFECT.Ents[Ent2Index][4][Type]) do
								if EFFECT.Register[Type] and EFFECT.Register[Type][v] and EFFECT.Register[Type][v][1] == Ent1Index and EFFECT.Register[Type][v][2] == Ent2Index then
									EffectCount = v
									break
								end
							end
						end
						if EffectCount then
							local Ent1
							local Ent2
							if Ent1Index and EFFECT.Ents[Ent1Index] then Ent1 = EFFECT.Ents[Ent1Index][1] end
							if Ent2Index and EFFECT.Ents[Ent2Index] then Ent2 = EFFECT.Ents[Ent2Index][1] end
							if EFFECT.Register[Type][EffectCount][3] and EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] then EFFECT.Draw[EFFECT.Register[Type][EffectCount][3]] = false end
							RemoveEntFromEffect(Ent1,Ent1Index,Type,EffectCount)
							RemoveEntFromEffect(Ent2,Ent2Index,Type,EffectCount)
							EFFECT.Register[Type][EffectCount] = false
							CleanupTables()
						end
					end
				else
					local Type = tonumber(Table[3])
					local NotRegister
					if EFFECT.Ents[Ent1Index] and EFFECT.Ents[Ent2Index] and EFFECT.Ents[Ent1Index][4] and EFFECT.Ents[Ent2Index][4] and EFFECT.Ents[Ent1Index][4][Type] and EFFECT.Ents[Ent2Index][4][Type] then
						for k,v in pairs(EFFECT.Ents[Ent1Index][4][Type]) do
							if EFFECT.Register[Type] and EFFECT.Register[Type][v] and EFFECT.Register[Type][v][1] == Ent1Index and EFFECT.Register[Type][v][2] == Ent2Index then
								NotRegister = true
								break
							end
						end
						if !NotRegister then
							for k,v in pairs(EFFECT.Ents[Ent2Index][4][Type]) do
								if EFFECT.Register[Type] and EFFECT.Register[Type][v] and EFFECT.Register[Type][v][1] == Ent1Index and EFFECT.Register[Type][v][2] == Ent2Index then
									NotRegister = true
									break
								end
							end
						end
					end
					if !NotRegister then
						local Ent1 = ents.GetByIndex(Ent1Index)
						local Ent2 = ents.GetByIndex(Ent2Index)
						if IsValid(Ent1) and IsValid(Ent2) then RegisterEffect(Type,Ent2Index,Ent2,RegisterEffect(Type,Ent1Index,Ent1)) end
					end
				end
			end
		end
	end)
	
	function EFFECT:Init(data) end

	function EFFECT:Think()
		-- This makes the effect always visible.
		local pl = LocalPlayer()
		if IsValid(pl) then
			local Pos = pl:EyePos()
			local Trace = {}
			Trace.start = Pos
			Trace.endpos = Pos+(pl:GetAimVector()*10)
			Trace.filter = {pl}
			local TR = util.TraceLine(Trace)
			self:SetPos(TR.HitPos)
		end
		
		-- Update positions.
		for Type,v in pairs(EFFECT.Register) do
			if EFFECT.Register[Type] then
				if Type == 1 or Type == 2 or Type == 3 or Type == 4 or Type == 15 or Type == 16 or Type == 17 then
					for EffectCount=1,#v do
						if EFFECT.Register[Type] and EFFECT.Register[Type][EffectCount] then
							local Ent1,Ent2
							if v[EffectCount][1] and EFFECT.Ents[v[EffectCount][1]] then Ent1 = EFFECT.Ents[v[EffectCount][1]][1] end
							if v[EffectCount][2] and EFFECT.Ents[v[EffectCount][2]] then Ent2 = EFFECT.Ents[v[EffectCount][2]][1] end
							if IsValid(Ent1) and IsValid(Ent2) then
								if !v[EffectCount][3] then EFFECT.Register[Type][EffectCount][3] = #EFFECT.Draw+1 end
								local DrawID = v[EffectCount][3]
								if !EFFECT.Draw[DrawID] then EFFECT.Draw[DrawID] = {} end
								EFFECT.Draw[DrawID][1] = Ent1:LocalToWorld(Ent1:OBBCenter())
								EFFECT.Draw[DrawID][2] = Ent2:LocalToWorld(Ent2:OBBCenter())
								if !EFFECT.Draw[DrawID][3] then
									if Type == 15 then Type = 1 end
									if Type == 16 then Type = 3 end
									if Type == 17 then Type = 4 end
									EFFECT.Draw[DrawID][3] = Type
								end
							else
								if v[EffectCount][3] and EFFECT.Draw[v[EffectCount][3]] then EFFECT.Draw[v[EffectCount][3]] = false end
								local Ent1Index,Ent2Index = v[EffectCount][1],v[EffectCount][2]
								RemoveEntFromEffect(Ent1,Ent1Index,Type,EffectCount)
								RemoveEntFromEffect(Ent2,Ent2Index,Type,EffectCount)
								EFFECT.Register[Type][EffectCount] = false
								CleanupTables()
							end
						end
					end
				elseif Type == 5 or Type == 6 or Type == 7 or Type == 8 or Type == 12 or Type == 13 or Type == 14 then
					for EffectCount=1,#v do
						if EFFECT.Register[Type] and EFFECT.Register[Type][EffectCount] then
							local Ent1
							if v[EffectCount][1] and EFFECT.Ents[v[EffectCount][1]] then Ent1 = EFFECT.Ents[v[EffectCount][1]][1] end
							if IsValid(Ent1) then
								if !v[EffectCount][3] then EFFECT.Register[Type][EffectCount][3] = #EFFECT.Draw+1 end
								local DrawID = v[EffectCount][3]
								if !EFFECT.Draw[DrawID] then EFFECT.Draw[DrawID] = {} end
								EFFECT.Draw[DrawID][1] = Ent1:LocalToWorld(Ent1:OBBCenter())
								if !EFFECT.Draw[DrawID][3] then
									if Type == 12 then Type = 5 end
									if Type == 13 then Type = 7 end
									if Type == 14 then Type = 8 end
									EFFECT.Draw[DrawID][3] = Type
								end
							else
								if v[EffectCount][3] and EFFECT.Draw[v[EffectCount][3]] then EFFECT.Draw[v[EffectCount][3]] = false end
								if v[EffectCount][1] then EFFECT.Ents[v[EffectCount][1]] = false end
								EFFECT.Register[Type][EffectCount] = false
								CleanupTables()
							end
						end
					end
				else
					for EffectCount=1,#v do
						if EFFECT.Register[Type] and EFFECT.Register[Type][EffectCount] then
							local Ent1
							if v[EffectCount][1] and EFFECT.Ents[v[EffectCount][1]] then Ent1 = EFFECT.Ents[v[EffectCount][1]][1] end
							if IsValid(Ent1) then
								if !v[EffectCount][3] then EFFECT.Register[Type][EffectCount][3] = #EFFECT.Draw+1 end
								local DrawID = v[EffectCount][3]
								if !EFFECT.Draw[DrawID] then EFFECT.Draw[DrawID] = {} end
								EFFECT.Draw[DrawID][3] = Type
								EFFECT.Draw[DrawID][4] = Ent1
							else
								if v[EffectCount][3] and EFFECT.Draw[v[EffectCount][3]] then EFFECT.Draw[v[EffectCount][3]] = false end
								if v[EffectCount][1] then EFFECT.Ents[v[EffectCount][1]] = false end
								EFFECT.Register[Type][EffectCount] = false
								CleanupTables()
							end
						end
					end
				end
			end
		end
		
		-- Set alpha to 100.
		for k,v in pairs(EFFECT.Ents) do
			if v then
				local Ent = v[1]
				if IsValid(Ent) then
					local Col = Ent:GetColor()
					Col["a"] = 100
					Ent:SetRenderMode(1)
					Ent:SetColor(Col)
				end
			end
		end
		
		return true
	end

	local DrawLine = Material("effects/render_vector")
	
	function EFFECT:Render()
		render.SetMaterial(DrawLine)
		for i=1,#EFFECT.Draw do
			if EFFECT.Draw[i] then
				if EFFECT.Draw[i][3] == 1 then
					render.DrawBeam(EFFECT.Draw[i][1], EFFECT.Draw[i][2], 16, 0.2, 0.8, Color(255, 255, 255, 255))
				elseif EFFECT.Draw[i][3] == 2 then
					render.DrawBeam(EFFECT.Draw[i][1], EFFECT.Draw[i][2], 16, 0.2, 0.8, Color(100, 255, 100, 255))
				elseif EFFECT.Draw[i][3] == 3 then
					render.DrawBeam(EFFECT.Draw[i][1], EFFECT.Draw[i][2], 16, 0.2, 0.8, Color(255, 50, 50, 255))
				elseif EFFECT.Draw[i][3] == 4 then
					render.DrawBeam(EFFECT.Draw[i][1], EFFECT.Draw[i][2], 16, 0.2, 0.8, Color(50, 50, 255, 255))
				elseif EFFECT.Draw[i][3] == 5 then
					render.DrawBeam(EFFECT.Draw[i][1], EFFECT.Draw[i][1]+Vector(0,0,-100), 32, 0.2, 0.8, Color(255, 255, 255, 255))
				elseif EFFECT.Draw[i][3] == 6 then
					render.DrawBeam(EFFECT.Draw[i][1], EFFECT.Draw[i][1]+Vector(0,0,-100), 32, 0.2, 0.8, Color(255, 150, 50, 255))
				elseif EFFECT.Draw[i][3] == 7 then
					render.DrawBeam(EFFECT.Draw[i][1], EFFECT.Draw[i][1]+Vector(0,0,-100), 32, 0.2, 0.8, Color(255, 50, 50, 255))
				elseif EFFECT.Draw[i][3] == 8 then
					render.DrawBeam(EFFECT.Draw[i][1], EFFECT.Draw[i][1]+Vector(0,0,-100), 32, 0.2, 0.8, Color(50, 50, 255, 255))
				elseif EFFECT.Draw[i][3] == 9 then
					halo.Add({EFFECT.Draw[i][4]}, Color(255, 255, 255, 255), 10, 10, 1, true, false)
				elseif EFFECT.Draw[i][3] == 10 then
					halo.Add({EFFECT.Draw[i][4]}, Color(255, 150, 50, 255), 10, 10, 1, true, false)
				elseif EFFECT.Draw[i][3] == 11 then
					halo.Add({EFFECT.Draw[i][4]}, Color(100, 255, 100, 255), 10, 10, 1, true, false)
				end
			end
		end
	end

	effects.Register(EFFECT,"render_no_collide",true)
end

local function ExtractEntities(Entity, Entities, Constraints, Ignore)
	Constraints = Constraints or {}
	Entities = Entities or {}
	if !Entity:IsValid() and Entity != game.GetWorld() then return Entities, Constraints end
	local Index = Entity:EntIndex()
	Entities[Index] = Entity
	if !constraint.HasConstraints(Entity) then return Entities, Constraints end
	
	for k1, v1 in pairs(constraint.GetTable(Entity)) do
		if !(Ignore and v1["Type"] and (v1["Type"] == "NoCollideWorld" or v1["Type"] == "NoCollide")) then
			local Index = v1.Constraint
			if !Constraints[Index] then
				Constraints[Index] = v1.Constraint
				for k2, v2 in pairs(v1.Entity) do
					local Ents, Cons = ExtractEntities(v2.Entity, Entities, Constraints, Ignore)
					table.Merge(Entities, Ents)
					table.Merge(Constraints, Cons)
				end
			end
		end
	end
	
	return Entities, Constraints
end

local SendToClient2 = {}
local SendDone2 = {}

function TOOL:LeftClick(trace)
	local pl = self:GetOwner()
	if !IsValid(pl) then return end
	if !trace.Entity then return end
	if trace.Entity:IsPlayer() then return end
	
	if SERVER then
		if self.Hold then self.Hold[pl] = false end
		if self.AimEnt then self.AimEnt[pl] = nil end
	end
	
	local Option = self:GetClientNumber("options")
	
	if Option == 1 then	--	Like default no collide
		if SERVER and !trace.Entity:IsValid() and trace.Entity != game.GetWorld() then return end
		local iNum = self:NumObjects()
		local Phys = trace.Entity:GetPhysicsObjectNum(trace.PhysicsBone)
		self:SetObject(iNum+1, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal)
		if CLIENT then
			if iNum > 0 then self:ClearObjects() end
			return true
		end
		if iNum > 0 then
			local Ent1,  Ent2  = self:GetEnt(1), self:GetEnt(2)
			local Bone1, Bone2 = self:GetBone(1), self:GetBone(2)
			
			if Ent1 == game.GetWorld() then
				Ent1 = Ent2
				Ent2 = game.GetWorld()
			end
			if Ent1:GetTable().Constraints then
				for k, v in pairs(Ent1:GetTable().Constraints) do
					if v:IsValid() then
						local CTab = v:GetTable()
						if CTab.Type == "NoCollideWorld" and ((CTab.Ent1 == Ent1 and CTab.Ent2 == Ent2) or (CTab.Ent2 == Ent1 and CTab.Ent1 == Ent2)) then
							self:ClearObjects()
							v:Remove()
							return true
						end
					end	
				end
			end
			
			local Const = constraint.NoCollideWorld(Ent1, Ent2, Bone1, Bone2)
			
			if IsValid(Const) then
				undo.Create("No Collide World, Default")
				undo.AddEntity(Const)
				undo.AddFunction(function(Undo, Tool, pl)
					if Tool and pl and pl:IsValid() then
						if Tool.Hold then Tool.Hold[pl] = false end
						if Tool.AimEnt then Tool.AimEnt[pl] = nil end
					end
				end, self,pl)
				undo.SetPlayer(pl)
				undo.SetCustomUndoText("Undone No Collide World, Default")
				undo.Finish()
				self:ClearObjects()
				return true
			end
			self:ClearObjects()
		else
			self:SetStage(iNum+1)
			return true
		end
	elseif Option == 2 then	--	No collide world only
		if !trace.Entity:IsValid() then return end
		if CLIENT then return true end
		
		if trace.Entity:GetTable().Constraints then
			for k, v in pairs(trace.Entity:GetTable().Constraints) do
				if v:IsValid() then
					local CTab = v:GetTable()
					if CTab.Type == "NoCollideWorld" and CTab.Ent1 == trace.Entity and CTab.Ent2 == game.GetWorld() then
						v:Remove()
						return true
					end
				end	
			end
		end
		
		local Const = constraint.NoCollideWorld(trace.Entity, game.GetWorld(), trace.PhysicsBone, 0)
		if IsValid(Const) then
			undo.Create("No Collide World, World Only")
			undo.AddEntity(Const)
			undo.AddFunction(function(Undo, Tool, pl)
				if Tool and pl and pl:IsValid() then
					if Tool.Hold then Tool.Hold[pl] = false end
					if Tool.AimEnt then Tool.AimEnt[pl] = nil end
				end
			end, self,pl)
			undo.SetPlayer(pl)
			undo.SetCustomUndoText("Undone No Collide World, World Only")
			undo.Finish()
			return true
		end
	elseif Option == 3 then	--	Select all constrained
		if SERVER and !trace.Entity:IsValid() and trace.Entity != game.GetWorld() then return end
		if CLIENT then return true end
		local iNum = self:GetStage()
		local Entities = ExtractEntities(trace.Entity,nil,nil,tobool(self:GetClientNumber("ignore")))
		if self.Ents1 and Entities and iNum == 4 then
			local UndoTable = {}
			for k1, Ent1 in pairs(self.Ents1) do
				if Ent1:IsValid() or Ent1 == game.GetWorld() then
					for k2, Ent2 in pairs(Entities) do
						if (Ent2:IsValid() or Ent2 == game.GetWorld()) and Ent1 != Ent2 then
							local Const = constraint.NoCollideWorld(Ent1, Ent2, 0, 0)
							if IsValid(Const) then UndoTable[#UndoTable+1] = Const end
						end
					end
				end
			end
			if #UndoTable == 0 then
				self.Ents1 = nil
				self:SetStage(3)
				return
			end
			undo.Create("No Collide World, Select all constrained")
			for i=1,#UndoTable do undo.AddEntity(UndoTable[i]) end
			undo.AddFunction(function(Undo, Tool, pl)
				if Tool and pl and pl:IsValid() then
					if Tool.Hold then Tool.Hold[pl] = false end
					if Tool.AimEnt then Tool.AimEnt[pl] = nil end
				end
			end, self,pl)
			undo.SetPlayer(pl)
			undo.SetCustomUndoText("Undone No Collide World, Select all constrained")
			undo.Finish()
			self.Ents1 = nil
			self:SetStage(3)
			return true 
		else
			self.Ents1 = Entities
			self:SetStage(4)
			return true 
		end
	elseif Option == 4 then	--	To all constrained
		if !trace.Entity:IsValid() then return end
		if CLIENT then return true end
		local Entities = ExtractEntities(trace.Entity,nil,nil,tobool(self:GetClientNumber("ignore")))
		if Entities then
			local UndoTable = {}
			for k1, Ent1 in pairs(Entities) do
				for k2, Ent2 in pairs(Entities) do
					if Ent1:IsValid() and Ent2:IsValid() and Ent1 != Ent2 then
						local Const = constraint.NoCollideWorld(Ent1, Ent2, 0, 0)
						if IsValid(Const) then UndoTable[#UndoTable+1] = Const end
					end
				end
			end
			if #UndoTable == 0 then return end
			undo.Create("No Collide World, To All Constrained")
			for i=1,#UndoTable do undo.AddEntity(UndoTable[i]) end
			undo.AddFunction(function(Undo, Tool, pl)
				if Tool and pl and pl:IsValid() then
					if Tool.Hold then Tool.Hold[pl] = false end
					if Tool.AimEnt then Tool.AimEnt[pl] = nil end
				end
			end, self,pl)
			undo.SetPlayer(pl)
			undo.SetCustomUndoText("Undone No Collide World, To All Constrained")
			undo.Finish()
			return true 
		end
	elseif Option == 5 then	--	No collide player only
		if !trace.Entity:IsValid() then return end
		if CLIENT then return true end
		
		if trace.Entity:GetCollisionGroup() == COLLISION_GROUP_WEAPON then
			trace.Entity:SetCollisionGroup(COLLISION_GROUP_NONE)
			if IsValid(trace.Entity.NocollideDummy) then trace.Entity.NocollideDummy:Remove() end
			return true
		else
			trace.Entity:SetCollisionGroup(COLLISION_GROUP_WEAPON)
			
			undo.Create("Undone No Collide World, Player Only")
			local Dummy = ents.Create("info_null")
			if !trace.Entity.UndoNoCollidePlayer then trace.Entity:CallOnRemove("UndoNoCollidePlayer"..trace.Entity:EntIndex(),function(Ent) if Ent.NocollideDummy and Ent.NocollideDummy:IsValid() then Ent.NocollideDummy:Remove() end end,trace.Entity) end
			trace.Entity.UndoNoCollidePlayer = true
			trace.Entity.NocollideDummy = Dummy
			undo.AddEntity(Dummy)
			
			undo.AddFunction(function(Undo, Ent, Tool, pl)
				if Tool and pl and pl:IsValid() then
					if Tool.Hold then Tool.Hold[pl] = false end
					if Tool.AimEnt then Tool.AimEnt[pl] = nil end
				end
				if Ent and Ent:IsValid() then Ent:SetCollisionGroup(COLLISION_GROUP_NONE) end
			end, trace.Entity,self,pl)
			undo.SetPlayer(pl)
			undo.SetCustomUndoText("Undone No Collide World, Player Only")
			undo.Finish()
			return true
		end
	elseif Option == 6 then	--	No collide within box
		if !trace.Entity:IsValid() then return end
		if CLIENT then return true end
		local Distance = self:GetClientNumber("distance")
		local AddVector = Vector(Distance,Distance,Distance)
		local UndoTable = {}
		for k,v in pairs(ents.FindInBox(trace.Entity:LocalToWorld(trace.Entity:OBBMins()-AddVector), trace.Entity:LocalToWorld(trace.Entity:OBBMaxs()+AddVector))) do
			if v:IsValid() and v != trace.Entity and !v:IsPlayer() then
				local Const = constraint.NoCollideWorld(trace.Entity, v, 0, 0)
				if IsValid(Const) then UndoTable[#UndoTable+1] = Const end
			end
		end
		if #UndoTable == 0 then return end
		undo.Create("No Collide World, Within Box")
		for i=1,#UndoTable do undo.AddEntity(UndoTable[i]) end
		undo.AddFunction(function(Undo, Tool, pl)
			if Tool and pl and pl:IsValid() then
				if Tool.Hold then Tool.Hold[pl] = false end
				if Tool.AimEnt then Tool.AimEnt[pl] = nil end
			end
		end, self,pl)
		undo.SetPlayer(pl)
		undo.SetCustomUndoText("Undone No Collide World, Within Box")
		undo.Finish()
		return true
	elseif Option == 7 then	--	No collide within sphere
		if !trace.Entity:IsValid() then return end
		if CLIENT then return true end
		local Distance = self:GetClientNumber("distance")
		local UndoTable = {}
		for k,v in pairs(ents.FindInSphere(trace.Entity:LocalToWorld(trace.Entity:OBBCenter()), (trace.Entity:OBBMaxs()/2):Length()+Distance)) do
			if v:IsValid() and v != trace.Entity and !v:IsPlayer() then
				local Const = constraint.NoCollideWorld(trace.Entity, v, 0, 0)
				if IsValid(Const) then UndoTable[#UndoTable+1] = Const end
			end
		end
		if #UndoTable == 0 then return end
		undo.Create("No Collide World, Within Sphere")
		for i=1,#UndoTable do undo.AddEntity(UndoTable[i]) end
		undo.AddFunction(function(Undo, Tool, pl)
			if Tool and pl and pl:IsValid() then
				if Tool.Hold then Tool.Hold[pl] = false end
				if Tool.AimEnt then Tool.AimEnt[pl] = nil end
			end
		end, self,pl)
		undo.SetPlayer(pl)
		undo.SetCustomUndoText("Undone No Collide World, Within Sphere")
		undo.Finish()
		return true
	elseif Option == 8 then	--	No collide within box all constrained
		if !trace.Entity:IsValid() then return end
		if CLIENT then return true end
		local Distance = self:GetClientNumber("distance")
		local AddVector = Vector(Distance,Distance,Distance)
		local Entities = ExtractEntities(trace.Entity,nil,nil,tobool(self:GetClientNumber("ignore")))
		if Entities then
			local UndoTable = {}
			for k1, Ent1 in pairs(Entities) do
				if Ent1:IsValid() and !Ent1:IsPlayer() then
					for k,v in pairs(ents.FindInBox(Ent1:LocalToWorld(Ent1:OBBMins()-AddVector), Ent1:LocalToWorld(Ent1:OBBMaxs()+AddVector))) do
						if v:IsValid() and v != Ent1 and !v:IsPlayer() then
							local Const = constraint.NoCollideWorld(Ent1, v, 0, 0)
							if IsValid(Const) then UndoTable[#UndoTable+1] = Const end
						end
					end
				end
			end
			if #UndoTable == 0 then return end
			undo.Create("No Collide World, Within Box All Constrained")
			for i=1,#UndoTable do undo.AddEntity(UndoTable[i]) end
			undo.AddFunction(function(Undo, Tool, pl)
				if Tool and pl and pl:IsValid() then
					if Tool.Hold then Tool.Hold[pl] = false end
					if Tool.AimEnt then Tool.AimEnt[pl] = nil end
				end
			end, self,pl)
			undo.SetPlayer(pl)
			undo.SetCustomUndoText("Undone No Collide World, Within Box All Constrained")
			undo.Finish()
			return true
		end
	elseif Option == 9 then	--	No collide within sphere all constrained
		if !trace.Entity:IsValid() then return end
		if CLIENT then return true end
		local Distance = self:GetClientNumber("distance")
		local Entities = ExtractEntities(trace.Entity,nil,nil,tobool(self:GetClientNumber("ignore")))
		if Entities then
			local UndoTable = {}
			for k1, Ent1 in pairs(Entities) do
				if Ent1:IsValid() and !Ent1:IsPlayer() then
					for k,v in pairs(ents.FindInSphere(Ent1:LocalToWorld(Ent1:OBBCenter()), (Ent1:OBBMaxs()/2):Length()+Distance)) do
						if v:IsValid() and v != Ent1 and !v:IsPlayer() then
							local Const = constraint.NoCollideWorld(Ent1, v, 0, 0)
							if IsValid(Const) then UndoTable[#UndoTable+1] = Const end
						end
					end
				end
			end
			if #UndoTable == 0 then return end
			undo.Create("No Collide World, Within Sphere All Constrained")
			for i=1,#UndoTable do undo.AddEntity(UndoTable[i]) end
			undo.SetPlayer(pl)
			undo.SetCustomUndoText("Undone No Collide World, Within Sphere All Constrained")
			undo.Finish()
			return true
		end
	elseif Option == 10 then	--	To all selected entities
		if CLIENT then return true end
		if SERVER and !trace.Entity:IsValid() and trace.Entity != game.GetWorld() then return end
		local EntityIndex = trace.Entity:EntIndex()
		if !SendDone2[pl] then SendDone2[pl] = 0 end
		if !SendToClient2[pl] then SendToClient2[pl] = {} end
		
		if !self.TASE then
			self.TASE = {}
			self.TASE[1] = {}
			self.TASE[2] = {}
			self.TASE[3] = {}
			--[[
			self.TASE[1][Index][Count] = Do count
			
			self.TASE[2][Low index][High index] = 1 = create, 2 = remove, 3 = ignore
			
			self.TASE[3][Do count][1] = Low index
			self.TASE[3][Do count][2] = High index
			]]
		end
		
		local function NocollideFind(Ent1, Ent2)
			if Ent1 == game.GetWorld() then
				Ent1 = Ent2
				Ent2 = game.GetWorld()
			end
			if !IsValid(Ent1) then return end
			if !Ent1:GetTable().Constraints then return end
			for k, v in pairs(Ent1:GetTable().Constraints) do
				if v:IsValid() then
					local CTab = v:GetTable()
					if (CTab.Type == "NoCollideWorld" or CTab.Type == "NoCollide") and ((CTab.Ent1 == Ent1 and CTab.Ent2 == Ent2) or (CTab.Ent2 == Ent1 and CTab.Ent1 == Ent2)) then return v,CTab.Type end
				end	
			end
			return
		end
		
		local function RemoveObject(Index)
			for i1=1,#self.TASE[1][Index] do
				local DoC = self.TASE[1][Index][i1]
				if DoC and self.TASE[3][DoC] then
					local LIndex = self.TASE[3][DoC][1]
					local HIndex = self.TASE[3][DoC][2]
					if self.TASE[2][LIndex] and self.TASE[2][LIndex][HIndex] then
						local SendC = #SendToClient2[pl]+1
						SendToClient2[pl][SendC] = {}
						if LIndex == 0 then
							if self.TASE[2][LIndex][HIndex] == 1 then
								SendToClient2[pl][SendC][1] = HIndex
								SendToClient2[pl][SendC][3] = -12
							elseif self.TASE[2][LIndex][HIndex] == 2 then
								SendToClient2[pl][SendC][1] = HIndex
								SendToClient2[pl][SendC][3] = -13
							else
								SendToClient2[pl][SendC][1] = HIndex
								SendToClient2[pl][SendC][3] = -14
							end
						elseif HIndex == 0 then
							if self.TASE[2][LIndex][HIndex] == 1 then
								SendToClient2[pl][SendC][1] = LIndex
								SendToClient2[pl][SendC][3] = -12
							elseif self.TASE[2][LIndex][HIndex] == 2 then
								SendToClient2[pl][SendC][1] = LIndex
								SendToClient2[pl][SendC][3] = -13
							else
								SendToClient2[pl][SendC][1] = LIndex
								SendToClient2[pl][SendC][3] = -14
							end
						else
							if self.TASE[2][LIndex][HIndex] == 1 then
								SendToClient2[pl][SendC][1] = LIndex
								SendToClient2[pl][SendC][2] = HIndex
								SendToClient2[pl][SendC][3] = -15
							elseif self.TASE[2][LIndex][HIndex] == 2 then
								SendToClient2[pl][SendC][1] = LIndex
								SendToClient2[pl][SendC][2] = HIndex
								SendToClient2[pl][SendC][3] = -16
							else
								SendToClient2[pl][SendC][1] = LIndex
								SendToClient2[pl][SendC][2] = HIndex
								SendToClient2[pl][SendC][3] = -17
							end
						end
						self.TASE[2][LIndex][HIndex] = nil
					end
					self.TASE[3][DoC] = false
					for i2=1,#self.TASE[1][HIndex] do if !self.TASE[3][self.TASE[1][HIndex][i2]] then self.TASE[1][HIndex][i2] = false end end
					for i2=1,#self.TASE[1][LIndex] do if !self.TASE[3][self.TASE[1][LIndex][i2]] then self.TASE[1][LIndex][i2] = false end end
				end
			end
			self.TASE[1][Index] = false
			local Translate = {}
			local New = {}
			local Count = 0
			for i1=1,#self.TASE[3] do
				if self.TASE[3][i1] then
					Count = Count+1
					Translate[i1] = Count
					local LIndex = self.TASE[3][i1][1]
					local HIndex = self.TASE[3][i1][2]
					New[Count] = self.TASE[3][i1]
				end
			end
			self.TASE[3] = New
			for k,v in pairs(self.TASE[1]) do
				if v then
					self.TASE[1][k] = {}
					local Count = 0
					for i=1,#v do
						if v[i] and self.TASE[3][Translate[v[i]]] then
							Count = Count+1
							self.TASE[1][k][Count] = Translate[v[i]]
						end
					end
				end
			end
		end
		
		if self.TASE[1][EntityIndex] then
			RemoveObject(EntityIndex)
			return true
		else
			self.TASE[1][EntityIndex] = {}
		end
		
		if tobool(self:GetClientNumber("remove")) then
			for k,v in pairs(self.TASE[1]) do
				if k != EntityIndex and self.TASE[1][EntityIndex] and self.TASE[1][k] then
					local Ent2
					if k == 0 then Ent2 = game.GetWorld() else Ent2 = ents.GetByIndex(k) end
					local Nocollide, Type = NocollideFind(trace.Entity, Ent2)
					if Type == "NoCollideWorld" then
						local SendC = #SendToClient2[pl]+1
						SendToClient2[pl][SendC] = {}
						if EntityIndex == 0 then
							SendToClient2[pl][SendC][1] = k
							SendToClient2[pl][SendC][3] = 13
						elseif k == 0 then
							SendToClient2[pl][SendC][1] = EntityIndex
							SendToClient2[pl][SendC][3] = 13
						else
							SendToClient2[pl][SendC][1] = k
							SendToClient2[pl][SendC][2] = EntityIndex
							SendToClient2[pl][SendC][3] = 16
						end
						local LIndex = math.min(k,EntityIndex)
						local HIndex = math.max(k,EntityIndex)
						local DoC = #self.TASE[3]+1
						self.TASE[1][LIndex][#self.TASE[1][LIndex]+1] = DoC
						self.TASE[1][HIndex][#self.TASE[1][HIndex]+1] = DoC
						
						if !self.TASE[2][LIndex] then self.TASE[2][LIndex] = {} end
						self.TASE[2][LIndex][HIndex] = 2
						
						self.TASE[3][DoC] = {}
						self.TASE[3][DoC][1] = LIndex
						self.TASE[3][DoC][2] = HIndex
					elseif !Nocollide then
						local SendC = #SendToClient2[pl]+1
						SendToClient2[pl][SendC] = {}
						if EntityIndex == 0 then
							SendToClient2[pl][SendC][1] = k
							SendToClient2[pl][SendC][3] = 14
						elseif k == 0 then
							SendToClient2[pl][SendC][1] = EntityIndex
							SendToClient2[pl][SendC][3] = 14
						else
							SendToClient2[pl][SendC][1] = k
							SendToClient2[pl][SendC][2] = EntityIndex
							SendToClient2[pl][SendC][3] = 17
						end
						local LIndex = math.min(k,EntityIndex)
						local HIndex = math.max(k,EntityIndex)
						local DoC = #self.TASE[3]+1
						self.TASE[1][LIndex][#self.TASE[1][LIndex]+1] = DoC
						self.TASE[1][HIndex][#self.TASE[1][HIndex]+1] = DoC
						
						if !self.TASE[2][LIndex] then self.TASE[2][LIndex] = {} end
						self.TASE[2][LIndex][HIndex] = 3
						
						self.TASE[3][DoC] = {}
						self.TASE[3][DoC][1] = LIndex
						self.TASE[3][DoC][2] = HIndex
					end
				end
			end
		else
			for k,v in pairs(self.TASE[1]) do
				if k != EntityIndex and self.TASE[1][EntityIndex] and self.TASE[1][k] then
					local Ent2
					if k == 0 then Ent2 = game.GetWorld() else Ent2 = ents.GetByIndex(k) end
					if !NocollideFind(trace.Entity, Ent2) then
						local SendC = #SendToClient2[pl]+1
						SendToClient2[pl][SendC] = {}
						if EntityIndex == 0 then
							SendToClient2[pl][SendC][1] = k
							SendToClient2[pl][SendC][3] = 12
						elseif k == 0 then
							SendToClient2[pl][SendC][1] = EntityIndex
							SendToClient2[pl][SendC][3] = 12
						else
							SendToClient2[pl][SendC][1] = k
							SendToClient2[pl][SendC][2] = EntityIndex
							SendToClient2[pl][SendC][3] = 15
						end
						local LIndex = math.min(k,EntityIndex)
						local HIndex = math.max(k,EntityIndex)
						local DoC = #self.TASE[3]+1
						self.TASE[1][LIndex][#self.TASE[1][LIndex]+1] = DoC
						self.TASE[1][HIndex][#self.TASE[1][HIndex]+1] = DoC
						
						if !self.TASE[2][LIndex] then self.TASE[2][LIndex] = {} end
						self.TASE[2][LIndex][HIndex] = 1
						
						self.TASE[3][DoC] = {}
						self.TASE[3][DoC][1] = LIndex
						self.TASE[3][DoC][2] = HIndex
					end
				end
			end
		end
		return true
	end
end

function TOOL:RightClick(trace)
	if self:GetClientNumber("options") == 10 then
		if CLIENT then return true end
		if !self.TASE or !self.TASE[3] then return end
		local pl = self:GetOwner()
		if !IsValid(pl) then return end
		if self.Hold then self.Hold[pl] = false end
		if self.AimEnt then self.AimEnt[pl] = nil end
		SendDone2[pl] = 0
		SendToClient2[pl] = {}
		net.Start("DrawNoCollide")
		net.WriteString("0b")
		net.Send(pl)
		
		local UndoTable = {}
		local Ents = {}
		local DidRemove
		
		for i=1,#self.TASE[3] do
			if self.TASE[3][i] then
				local LIndex = self.TASE[3][i][1]
				local HIndex = self.TASE[3][i][2]
				if Ents[LIndex] == nil then
					if LIndex == 0 then
						Ents[LIndex] = game.GetWorld()
					else
						local Ent = ents.GetByIndex(LIndex)
						if IsValid(Ent) or Ent == game.GetWorld() then Ents[LIndex] = Ent else Ents[LIndex] = false end
					end
				end
				if Ents[HIndex] == nil then
					if HIndex == 0 then
						Ents[HIndex] = game.GetWorld()
					else
						local Ent = ents.GetByIndex(HIndex)
						if IsValid(Ent) or Ent == game.GetWorld() then Ents[HIndex] = Ent else Ents[HIndex] = false end
					end
				end
				if Ents[LIndex] and Ents[HIndex] then
					if self.TASE[2][LIndex][HIndex] == 1 then
						local Const = constraint.NoCollideWorld(Ents[LIndex], Ents[HIndex], 0, 0)
						if IsValid(Const) then UndoTable[#UndoTable+1] = Const end
					elseif self.TASE[2][LIndex][HIndex] == 2 then
						local Ent1 = Ents[LIndex]
						local Ent2 = Ents[HIndex]
						if Ent1 == game.GetWorld() then
							Ent1 = Ent2
							Ent2 = game.GetWorld()
						end
						if Ent1:GetTable().Constraints then
							for k, v in pairs(Ent1:GetTable().Constraints) do
								if v:IsValid() then
									local CTab = v:GetTable()
									if CTab.Type == "NoCollideWorld" and ((CTab.Ent1 == Ent1 and CTab.Ent2 == Ent2) or (CTab.Ent2 == Ent1 and CTab.Ent1 == Ent2)) then
										DidRemove = true
										v:Remove()
										break
									end
								end	
							end
						end
					end
				end
			end
		end
		
		self.TASE = nil
		
		if #UndoTable == 0 then if DidRemove then return true else return end end
		undo.Create("No Collide World, To All Selected Entities")
		for i=1,#UndoTable do undo.AddEntity(UndoTable[i]) end
		undo.SetPlayer(pl)
		undo.SetCustomUndoText("Undone No Collide World, To All Selected Entities")
		undo.Finish()
		return true
	else
		if !trace.Entity then return end
		if !trace.Entity:IsValid() then return end
		if trace.Entity:IsPlayer() then return end
		if CLIENT then return true end
		
		local pl = self:GetOwner()
		if !IsValid(pl) then return end
		if self.Hold then self.Hold[pl] = false end
		if self.AimEnt then self.AimEnt[pl] = nil end
		
		if trace.Entity:GetCollisionGroup() == COLLISION_GROUP_WORLD then
			trace.Entity:SetCollisionGroup(COLLISION_GROUP_NONE)
			if trace.Entity.Nocollide and trace.Entity.Nocollide:IsValid() then trace.Entity.Nocollide:Remove() end
			return true
		else
			local function NocollideFind(Ent1, Ent2)
				if !Ent1:GetTable().Constraints then return end
				for k, v in pairs(Ent1:GetTable().Constraints) do
					if v:IsValid() then
						local CTab = v:GetTable()
						if (CTab.Type == "NoCollideWorld" or CTab.Type == "NoCollide") and ((CTab.Ent1 == Ent1 and CTab.Ent2 == Ent2) or (CTab.Ent2 == Ent1 and CTab.Ent1 == Ent2)) then return v end
					end	
				end
				return
			end
			local Const = NocollideFind(trace.Entity, game.GetWorld())
			if IsValid(Const) then
				Const:Remove()
				Const = NULL
			end
			Const = constraint.NoCollideWorld(trace.Entity, game.GetWorld(), trace.PhysicsBone, 0)
			if IsValid(Const) then
				pl:AddCount("nocollide_world", Const)
				trace.Entity:SetCollisionGroup(COLLISION_GROUP_WORLD)
				trace.Entity.Nocollide = Const
				if IsValid(trace.Entity.NocollideDummy) then trace.Entity.NocollideDummy:Remove() end
				
				undo.Create("No Collide World, Disable Collisions")
				undo.AddEntity(Const)
				undo.AddFunction(function(Undo, Ent, Tool, pl)
					if Tool and pl and pl:IsValid() then
						if Tool.Hold then Tool.Hold[pl] = false end
						if Tool.AimEnt then Tool.AimEnt[pl] = nil end
					end
					if Ent and Ent:IsValid() and !IsValid(Ent.NocollideDummy) then Ent:SetCollisionGroup(COLLISION_GROUP_NONE) end
				end, trace.Entity,self,pl)
				undo.SetPlayer(pl)
				undo.SetCustomUndoText("Undone No Collide World, Disable Collisions")
				undo.Finish()
				return true
			end
		end
	end
end

function TOOL:Reload()
	if CLIENT then return true end
	local pl = self:GetOwner()
	if !self.Hold then self.Hold = {} end
	if !IsValid(pl) then return end
	self.Hold[pl] = !self.Hold[pl]
end

local SendToClient = {}
local SendDone = {}

function TOOL:Think()
	if CLIENT then return end
	local Option = self:GetClientNumber("options")
	local Stage = self:GetStage()
	if Option == 1 and Stage != 0 and Stage != 1 then self:SetStage(0) elseif Option == 2 and Stage != 2 then self:SetStage(2) elseif Option == 3 and Stage != 3 and Stage != 4 then self:SetStage(3) elseif Option == 4 and Stage != 5 then self:SetStage(5) elseif Option == 5 and Stage != 6 then self:SetStage(6) elseif Option == 6 and Stage != 7 then self:SetStage(7) elseif Option == 7 and Stage != 8 then self:SetStage(8) elseif Option == 8 and Stage != 5 then self:SetStage(5) elseif Option == 9 and Stage != 5 then self:SetStage(5) elseif Option == 10 and Stage != 9 then self:SetStage(9) end
	
	local pl = self:GetOwner()
	if !IsValid(pl) then return end
	if !SendDone[pl] then SendDone[pl] = 0 end
	if !SendToClient[pl] then SendToClient[pl] = {} end
	if !self.AimEnt then self.AimEnt = {} end
	if !self.Hold then self.Hold = {} end
	if Option != self.OldOption then
		self.OldOption = Option
		self:ClearObjects()
		SendDone[pl] = 0
		self.AimEnt[pl] = nil
		SendToClient[pl] = {}
		self.TASE = nil
		net.Start("DrawNoCollide")
		net.WriteString("0")
		net.Send(pl)
	end
	if !self.Hold[pl] then 
		local trace = pl:GetEyeTrace()
		if !tobool(self:GetClientNumber("effect")) and trace.Entity and trace.Entity:IsValid() and !trace.Entity:IsPlayer() then
			if trace.Entity != self.AimEnt[pl] or Option != self.OldOption then
				self.OldOption = Option
				Stage = self:GetStage()
				SendDone[pl] = 0
				SendToClient[pl] = {}
				net.Start("DrawNoCollide")
				net.WriteString("0a")
				net.Send(pl)
				local TraceEntityIndex = trace.Entity:EntIndex()
				local Ignore
				local ToolEnt1 = self:GetEnt(1)
				local function NocollideFind(Ent1, Ent2)
					if Ent1 == game.GetWorld() then
						Ent1 = Ent2
						Ent2 = game.GetWorld()
					end
					if !Ent1:GetTable().Constraints then return end
					for k, v in pairs(Ent1:GetTable().Constraints) do
						if v:IsValid() then
							local CTab = v:GetTable()
							if (CTab.Type == "NoCollideWorld" or CTab.Type == "NoCollide") and ((CTab.Ent1 == Ent1 and CTab.Ent2 == Ent2) or (CTab.Ent2 == Ent1 and CTab.Ent1 == Ent2)) then return v end
						end	
					end
					return
				end
				if Option == 1 or Option == 2 or Option == 3 or Option == 5 or Option == 10 then
					local AllEnts = {}
					AllEnts[TraceEntityIndex] = true
					if constraint.HasConstraints(trace.Entity) and Stage != 4 then
						local Cons = constraint.GetTable(trace.Entity)
						for i=1,#Cons do
							if Cons[i]["Type"] == "NoCollideWorld" or Cons[i]["Type"] == "NoCollide" then
								local Ent1Index
								local Ent2Index
								if Cons[i]["Entity"] then
									if Cons[i]["Entity"][1] then Ent1Index = Cons[i]["Entity"][1]["Index"] end
									if Cons[i]["Entity"][2] then Ent2Index = Cons[i]["Entity"][2]["Index"] end
								end
								if Ent1Index and Ent2Index then
									local Count = #SendToClient[pl]+1
									SendToClient[pl][Count] = {}
									if Ent1Index == 0 then
										AllEnts[Ent2Index] = true
										if Stage == 1 then
											if self:GetEnt(1) != trace.Entity and (game.GetWorld() == self:GetEnt(1) or ents.GetByIndex(Ent2Index) == self:GetEnt(1)) and Cons[i]["Type"] == "NoCollideWorld" then
												SendToClient[pl][Count][1] = Ent2Index
												SendToClient[pl][Count][3] = 7
											else
												SendToClient[pl][Count][1] = Ent2Index
												SendToClient[pl][Count][3] = 6
											end
										elseif Option == 10 and self.TASE then
											local LIndex = math.min(Ent1Index,Ent2Index)
											local HIndex = math.max(Ent1Index,Ent2Index)
											if self.TASE[2][LIndex] and self.TASE[2][LIndex][HIndex] and self.TASE[2][LIndex][HIndex] == 2 then
												SendToClient[pl][Count] = nil
											else
												SendToClient[pl][Count][1] = Ent2Index
												SendToClient[pl][Count][3] = 6
											end
										else
											SendToClient[pl][Count][1] = Ent2Index
											SendToClient[pl][Count][3] = 6
										end
										if ents.GetByIndex(Ent2Index) == trace.Entity and ((Stage == 1 and self:GetEnt(1) == game.GetWorld()) or Stage == 2) then Ignore = true end
									elseif Ent2Index == 0 then
										AllEnts[Ent1Index] = true
										if Stage == 1 then
											if self:GetEnt(1) != trace.Entity and (ents.GetByIndex(Ent1Index) == self:GetEnt(1) or game.GetWorld() == self:GetEnt(1)) and Cons[i]["Type"] == "NoCollideWorld" then
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][3] = 7
											else
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][3] = 6
											end
										elseif Option == 10 and self.TASE then
											local LIndex = math.min(Ent1Index,Ent2Index)
											local HIndex = math.max(Ent1Index,Ent2Index)
											if self.TASE[2][LIndex] and self.TASE[2][LIndex][HIndex] and self.TASE[2][LIndex][HIndex] == 2 then
												SendToClient[pl][Count] = nil
											else
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][3] = 6
											end
										else
											SendToClient[pl][Count][1] = Ent1Index
											SendToClient[pl][Count][3] = 6
										end
										if ents.GetByIndex(Ent1Index) == trace.Entity and ((Stage == 1 and self:GetEnt(1) == game.GetWorld()) or Stage == 2) then Ignore = true end
									else
										AllEnts[Ent1Index] = true
										AllEnts[Ent2Index] = true
										if Stage == 1 then
											if self:GetEnt(1) != trace.Entity and (ents.GetByIndex(Ent1Index) == self:GetEnt(1) or ents.GetByIndex(Ent2Index) == self:GetEnt(1)) and Cons[i]["Type"] == "NoCollideWorld" then
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][2] = Ent2Index
												SendToClient[pl][Count][3] = 3
											else
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][2] = Ent2Index
												SendToClient[pl][Count][3] = 2
											end
											local Ent1 = ents.GetByIndex(Ent1Index)
											local Ent2 = ents.GetByIndex(Ent2Index)
											if (Ent1 == trace.Entity and Ent2 == self:GetEnt(1)) or (Ent2 == trace.Entity and Ent1 == self:GetEnt(1)) then Ignore = true end
										elseif Option == 10 and self.TASE then
											local LIndex = math.min(Ent1Index,Ent2Index)
											local HIndex = math.max(Ent1Index,Ent2Index)
											if self.TASE[2][LIndex] and self.TASE[2][LIndex][HIndex] and self.TASE[2][LIndex][HIndex] == 2 then
												SendToClient[pl][Count] = nil
											else
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][2] = Ent2Index
												SendToClient[pl][Count][3] = 2
											end
										else
											SendToClient[pl][Count][1] = Ent1Index
											SendToClient[pl][Count][2] = Ent2Index
											SendToClient[pl][Count][3] = 2
										end
									end
								end
							end
						end
					end
					for k,v in pairs(AllEnts) do
						if k != 0 then
							local CollisionGroup = ents.GetByIndex(k):GetCollisionGroup()
							if CollisionGroup == COLLISION_GROUP_WORLD then
								if Option == 5 and ents.GetByIndex(k) == trace.Entity then Ignore = true end
								local Count = #SendToClient[pl]+1
								SendToClient[pl][Count] = {}
								SendToClient[pl][Count][1] = k
								SendToClient[pl][Count][3] = 10
							elseif CollisionGroup == COLLISION_GROUP_WEAPON then
								if Option == 5 and ents.GetByIndex(k) == trace.Entity then Ignore = true end
								local Count = #SendToClient[pl]+1
								SendToClient[pl][Count] = {}
								SendToClient[pl][Count][1] = k
								SendToClient[pl][Count][3] = 11
							end
						end
					end
					if ((Stage == 1 and self:GetEnt(1) != trace.Entity) or Stage == 2) and !Ignore then
						local Ent1Index = TraceEntityIndex
						local Ent2Index 
						if Stage == 1 then Ent2Index = self:GetEnt(1):EntIndex() else Ent2Index = 0 end
						local Count = #SendToClient[pl]+1
						SendToClient[pl][Count] = {}
						if Ent1Index == 0 then
							SendToClient[pl][Count][1] = Ent2Index
							SendToClient[pl][Count][3] = 5
						elseif Ent2Index == 0 then
							SendToClient[pl][Count][1] = Ent1Index
							SendToClient[pl][Count][3] = 5
						else
							SendToClient[pl][Count][1] = Ent1Index
							SendToClient[pl][Count][2] = Ent2Index
							SendToClient[pl][Count][3] = 1
						end
					elseif Stage == 4 then
						local AllEnts = {}
						AllEnts[TraceEntityIndex] = true
						local Entities = ExtractEntities(trace.Entity,nil,nil,tobool(self:GetClientNumber("ignore")))
						if self.Ents1 and Entities then
							local Done = {}
							for k1, Ent1 in pairs(self.Ents1) do
								if Ent1:IsValid() or Ent1 == game.GetWorld() then
									for k2, Ent2 in pairs(Entities) do
										if (Ent2:IsValid() or Ent2 == game.GetWorld()) and Ent1 != Ent2 then
											local Ent1Index = Ent1:EntIndex()
											local Ent2Index = Ent2:EntIndex()
											local Lowest = math.min(Ent1Index,Ent2Index)
											local Highest = math.max(Ent1Index,Ent2Index)
											if !Done[Lowest] then Done[Lowest] = {} end
											if !Done[Lowest][Highest] then
												Done[Lowest][Highest] = true
												AllEnts[Ent1Index] = true
												AllEnts[Ent2Index] = true
												local Count = #SendToClient[pl]+1
												SendToClient[pl][Count] = {}
												if NocollideFind(Ent1,Ent2) then
													if Ent1Index == 0 then
														SendToClient[pl][Count][1] = Ent2Index
														SendToClient[pl][Count][3] = 6
													elseif Ent2Index == 0 then
														SendToClient[pl][Count][1] = Ent1Index
														SendToClient[pl][Count][3] = 6
													else
														SendToClient[pl][Count][1] = Ent1Index
														SendToClient[pl][Count][2] = Ent2Index
														SendToClient[pl][Count][3] = 2
													end
												else
													if Ent1Index == 0 then
														SendToClient[pl][Count][1] = Ent2Index
														SendToClient[pl][Count][3] = 5
													elseif Ent2Index == 0 then
														SendToClient[pl][Count][1] = Ent1Index
														SendToClient[pl][Count][3] = 5
													else
														SendToClient[pl][Count][1] = Ent1Index
														SendToClient[pl][Count][2] = Ent2Index
														SendToClient[pl][Count][3] = 1
													end
												end
											end
										end
									end
								end
							end
						end
						for k,v in pairs(AllEnts) do
							if k != 0 then
								local CollisionGroup = ents.GetByIndex(k):GetCollisionGroup()
								if CollisionGroup == COLLISION_GROUP_WORLD then
									local Count = #SendToClient[pl]+1
									SendToClient[pl][Count] = {}
									SendToClient[pl][Count][1] = k
									SendToClient[pl][Count][3] = 10
								elseif CollisionGroup == COLLISION_GROUP_WEAPON then
									local Count = #SendToClient[pl]+1
									SendToClient[pl][Count] = {}
									SendToClient[pl][Count][1] = k
									SendToClient[pl][Count][3] = 11
								end
							end
						end
					elseif Option == 5 and !Ignore then
						local Count = #SendToClient[pl]+1
						SendToClient[pl][Count] = {}
						SendToClient[pl][Count][1] = TraceEntityIndex
						SendToClient[pl][Count][3] = 9
					end
				elseif Option == 4 then
					local AllEnts = {}
					AllEnts[TraceEntityIndex] = true
					local Entities = ExtractEntities(trace.Entity,nil,nil,tobool(self:GetClientNumber("ignore")))
					if Entities then
						local Done = {}
						for k1, Ent1 in pairs(Entities) do
							for k2, Ent2 in pairs(Entities) do
								if Ent1 != Ent2 then
									if Ent1:IsValid() and Ent2:IsValid() then
										local Ent1Index = Ent1:EntIndex()
										local Ent2Index = Ent2:EntIndex()
										local Lowest = math.min(Ent1Index,Ent2Index)
										local Highest = math.max(Ent1Index,Ent2Index)
										if !Done[Lowest] then Done[Lowest] = {} end
										if !Done[Lowest][Highest] then
											Done[Lowest][Highest] = true
											AllEnts[Ent1Index] = true
											AllEnts[Ent2Index] = true
											local Count = #SendToClient[pl]+1
											SendToClient[pl][Count] = {}
											if NocollideFind(Ent1,Ent2) then
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][2] = Ent2Index
												SendToClient[pl][Count][3] = 2
											else
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][2] = Ent2Index
												SendToClient[pl][Count][3] = 1
											end
										end
									elseif (Ent1:IsValid() or Ent1 == game.GetWorld()) and (Ent2:IsValid() or Ent2 == game.GetWorld()) and NocollideFind(Ent1,Ent2) then
										local Ent1Index = Ent1:EntIndex()
										local Ent2Index = Ent2:EntIndex()
										local Lowest = math.min(Ent1Index,Ent2Index)
										local Highest = math.max(Ent1Index,Ent2Index)
										if !Done[Lowest] then Done[Lowest] = {} end
										if !Done[Lowest][Highest] then
											Done[Lowest][Highest] = true
											AllEnts[Ent1Index] = true
											AllEnts[Ent2Index] = true
											local Count = #SendToClient[pl]+1
											SendToClient[pl][Count] = {}
											if Ent1Index == 0 then
												SendToClient[pl][Count][1] = Ent2Index
												SendToClient[pl][Count][3] = 6
											elseif Ent2Index == 0 then
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][3] = 6
											end
										end
									end
								end
							end
						end
					end
					for k,v in pairs(AllEnts) do
						if k != 0 then
							local CollisionGroup = ents.GetByIndex(k):GetCollisionGroup()
							if CollisionGroup == COLLISION_GROUP_WORLD then
								local Count = #SendToClient[pl]+1
								SendToClient[pl][Count] = {}
								SendToClient[pl][Count][1] = k
								SendToClient[pl][Count][3] = 10
							elseif CollisionGroup == COLLISION_GROUP_WEAPON then
								local Count = #SendToClient[pl]+1
								SendToClient[pl][Count] = {}
								SendToClient[pl][Count][1] = k
								SendToClient[pl][Count][3] = 11
							end
						end
					end
				else
					local AllEnts = {}
					AllEnts[TraceEntityIndex] = true
					local Distance = self:GetClientNumber("distance")
					if Option == 6 then
						local AddVector = Vector(Distance,Distance,Distance)
						for k,v in pairs(ents.FindInBox(trace.Entity:LocalToWorld(trace.Entity:OBBMins()-AddVector), trace.Entity:LocalToWorld(trace.Entity:OBBMaxs()+AddVector))) do
							if v:IsValid() and v:GetPhysicsObject():IsValid() and v != trace.Entity and !v:IsPlayer() then
								local Ent = v:EntIndex()
								AllEnts[Ent] = true
								local Count = #SendToClient[pl]+1
								SendToClient[pl][Count] = {}
								if NocollideFind(v,trace.Entity) then
									SendToClient[pl][Count][1] = Ent
									SendToClient[pl][Count][2] = TraceEntityIndex
									SendToClient[pl][Count][3] = 2
								else
									SendToClient[pl][Count][1] = Ent
									SendToClient[pl][Count][2] = TraceEntityIndex
									SendToClient[pl][Count][3] = 1
								end
							end
						end
					elseif Option == 7 then
						for k,v in pairs(ents.FindInSphere(trace.Entity:LocalToWorld(trace.Entity:OBBCenter()), (trace.Entity:OBBMaxs()/2):Length()+Distance)) do
							if v:IsValid() and v:GetPhysicsObject():IsValid() and v != trace.Entity and !v:IsPlayer() then
								local Ent = v:EntIndex()
								AllEnts[Ent] = true
								local Count = #SendToClient[pl]+1
								SendToClient[pl][Count] = {}
								if NocollideFind(v,trace.Entity) then
									SendToClient[pl][Count][1] = Ent
									SendToClient[pl][Count][2] = TraceEntityIndex
									SendToClient[pl][Count][3] = 2
								else
									SendToClient[pl][Count][1] = Ent
									SendToClient[pl][Count][2] = TraceEntityIndex
									SendToClient[pl][Count][3] = 1
								end
							end
						end
					elseif Option == 8 then
						local Entities = ExtractEntities(trace.Entity,nil,nil,tobool(self:GetClientNumber("ignore")))
						if Entities then
							local AddVector = Vector(Distance,Distance,Distance)
							for k1, Ent1 in pairs(Entities) do
								if Ent1:IsValid() and !Ent1:IsPlayer() then
									for k,v in pairs(ents.FindInBox(Ent1:LocalToWorld(Ent1:OBBMins()-AddVector), Ent1:LocalToWorld(Ent1:OBBMaxs()+AddVector))) do
										if v:IsValid() and v:GetPhysicsObject():IsValid() and v != Ent1 and !v:IsPlayer() then
											local Ent1Index = Ent1:EntIndex()
											local Ent2Index = v:EntIndex()
											AllEnts[Ent1Index] = true
											AllEnts[Ent2Index] = true
											local Count = #SendToClient[pl]+1
											SendToClient[pl][Count] = {}
											if NocollideFind(v,Ent1) then
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][2] = Ent2Index
												SendToClient[pl][Count][3] = 2
											else
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][2] = Ent2Index
												SendToClient[pl][Count][3] = 1
											end
										end
									end
								end
							end
						end
					elseif Option == 9 then
						local Entities = ExtractEntities(trace.Entity,nil,nil,tobool(self:GetClientNumber("ignore")))
						if Entities then
							for k1, Ent1 in pairs(Entities) do
								if Ent1:IsValid() and !Ent1:IsPlayer() then
									for k,v in pairs(ents.FindInSphere(Ent1:LocalToWorld(Ent1:OBBCenter()), (Ent1:OBBMaxs()/2):Length()+Distance)) do
										if v:IsValid() and v:GetPhysicsObject():IsValid() and v != Ent1 and !v:IsPlayer() then
											local Ent1Index = Ent1:EntIndex()
											local Ent2Index = v:EntIndex()
											AllEnts[Ent1Index] = true
											AllEnts[Ent2Index] = true
											local Count = #SendToClient[pl]+1
											SendToClient[pl][Count] = {}
											if NocollideFind(v,Ent1) then
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][2] = Ent2Index
												SendToClient[pl][Count][3] = 2
											else
												SendToClient[pl][Count][1] = Ent1Index
												SendToClient[pl][Count][2] = Ent2Index
												SendToClient[pl][Count][3] = 1
											end
										end
									end
								end
							end
						end
					end
					for k,v in pairs(AllEnts) do
						if k != 0 then
							local CollisionGroup = ents.GetByIndex(k):GetCollisionGroup()
							if CollisionGroup == COLLISION_GROUP_WORLD then
								local Count = #SendToClient[pl]+1
								SendToClient[pl][Count] = {}
								SendToClient[pl][Count][1] = k
								SendToClient[pl][Count][3] = 10
							elseif CollisionGroup == COLLISION_GROUP_WEAPON then
								local Count = #SendToClient[pl]+1
								SendToClient[pl][Count] = {}
								SendToClient[pl][Count][1] = k
								SendToClient[pl][Count][3] = 11
							end
							if NocollideFind(ents.GetByIndex(k),game.GetWorld()) then
								local Count = #SendToClient[pl]+1
								SendToClient[pl][Count] = {}
								SendToClient[pl][Count][1] = k
								SendToClient[pl][Count][3] = 6
							end
						end
					end
				end
				self.AimEnt[pl] = trace.Entity
			end
		else
			if self.AimEnt[pl] != nil then
				SendDone[pl] = 0
				self.AimEnt[pl] = nil
				SendToClient[pl] = {}
				net.Start("DrawNoCollide")
				net.WriteString("0a")
				net.Send(pl)
			end
		end
	end
end

function TOOL:Holster()
	if SERVER then
		local pl = self:GetOwner()
		if self.Hold then self.Hold[pl] = false end
		SendDone[pl] = 0
		if self.AimEnt then self.AimEnt[pl] = nil end
		SendToClient[pl] = {}
		self.TASE = nil
		net.Start("DrawNoCollide")
		net.WriteString("0")
		net.Send(pl)
		self:ClearObjects()
	end
end

function TOOL.BuildCPanel(CPanel)
	CPanel:AddControl("Header", {Text = "#Tool.nocollide_world.name", Description = "#Tool.nocollide_world.desc"})
	
	local ctrl = vgui.Create("CtrlListBox", CPanel)
	ctrl:AddOption("Like default no collide", {nocollide_world_options = "1"})
	ctrl:AddOption("No collide world only", {nocollide_world_options = "2"})
	ctrl:AddOption("Select all constrained", {nocollide_world_options = "3"})
	ctrl:AddOption("To all constrained", {nocollide_world_options = "4"})
	ctrl:AddOption("No collide player only", {nocollide_world_options = "5"})
	ctrl:AddOption("No collide within box", {nocollide_world_options = "6"})
	ctrl:AddOption("No collide within sphere", {nocollide_world_options = "7"})
	ctrl:AddOption("No collide within box all constrained", {nocollide_world_options = "8"})
	ctrl:AddOption("No collide within sphere all constrained", {nocollide_world_options = "9"})
	ctrl:AddOption("To all selected entities", {nocollide_world_options = "10"})
	
	local left = vgui.Create("DLabel", CPanel)
	left:SetText("Nocollide Options")
	left:SetDark(true)
	ctrl:SetHeight(25)
	ctrl:Dock(TOP)
	
	CPanel:AddItem(left, ctrl)
	
	CPanel.IgnoreCheckbox = CPanel:AddControl("Checkbox", {Label = "Ignore No Collide", Command = "nocollide_world_ignore"})
	
	CPanel.RemoveCheckbox = CPanel:AddControl("Checkbox", {Label = "Remove No Collide Or Ignore", Command = "nocollide_world_remove"})
	
	CPanel.AddDistance = vgui.Create("Panel", CPanel)
	CPanel.AddDistance:Dock(TOP)
	CPanel.AddDistance:DockMargin(4, 20, 0, 0)
	CPanel.AddDistance:SetVisible(true)
	
	CPanel.AddDistance.TextArea = CPanel.AddDistance:Add("DTextEntry")
	CPanel.AddDistance.TextArea:SetDrawBackground(false)
	CPanel.AddDistance.TextArea:SetNumeric(true)
	CPanel.AddDistance.TextArea.OnChange = function(val)
		val = tonumber(val:GetValue()) or 0
		if val then
			CPanel.AddDistance.Scratch:SetValue(val)
			val = tonumber(CPanel.AddDistance.Scratch:GetFloatValue()) or 0
			CPanel.AddDistance.Slider:SetSlideX(CPanel.AddDistance.Scratch:GetFraction(val))
		end
	end
	
	CPanel.AddDistance.Slider = CPanel.AddDistance:Add("DSlider", CPanel.AddDistance)
	CPanel.AddDistance.Slider:SetLockY(0.5)
	CPanel.AddDistance.Slider.TranslateValues = function(slider, x, y)
		local val = math.Clamp(x*1000, 0, 1000)
		if val then
			CPanel.AddDistance.Scratch:SetValue(val)
			if CPanel.AddDistance.TextArea != vgui.GetKeyboardFocus() then
				local str = CPanel.AddDistance.Scratch:GetTextValue()
				if string.find(str,".",1,true) then str = string.Explode(".", str, true)[1] end
				CPanel.AddDistance.TextArea:SetValue(str)
			end
		end
		return CPanel.AddDistance.Scratch:GetFraction(), y
	end
	CPanel.AddDistance.Slider:SetTrapInside(true)
	Derma_Hook(CPanel.AddDistance.Slider, "Paint", "Paint", "NumSlider")
	CPanel.AddDistance.Slider:SetNotches(10)
	
	CPanel.AddDistance.Label = vgui.Create("DLabel", CPanel.AddDistance)
	CPanel.AddDistance.Label:SetMouseInputEnabled(true)
	CPanel.AddDistance.Label:SetDark(true)
	CPanel.AddDistance.Label:SetText("Add Distance")
	
	CPanel.AddDistance.Scratch = CPanel.AddDistance.Label:Add("DNumberScratch")
	CPanel.AddDistance.Scratch:SetImageVisible(false)
	CPanel.AddDistance.Scratch:Dock(FILL)
	CPanel.AddDistance.Scratch.OnValueChanged = function()
		local val = tonumber(CPanel.AddDistance.Scratch:GetFloatValue()) or 0
		CPanel.AddDistance.Slider:SetSlideX(CPanel.AddDistance.Scratch:GetFraction(val))
		if CPanel.AddDistance.TextArea != vgui.GetKeyboardFocus() then
			local str = CPanel.AddDistance.Scratch:GetTextValue()
			if string.find(str,".",1,true) then str = string.Explode(".", str, true)[1] end
			CPanel.AddDistance.TextArea:SetValue(str)
		end
	end
	CPanel.AddDistance.Scratch:SetMin(0)
	CPanel.AddDistance.Scratch:SetMax(1000)
	CPanel.AddDistance.Scratch:SetDecimals(0)
	CPanel.AddDistance.Scratch:SetConVar("nocollide_world_distance")
	
	CPanel.AddDistance:SetTall(32)
	
	function CPanel.AddDistance:PerformLayout()
		local Left = 5
		CPanel.AddDistance.Label:SetPos(Left, 0)
		CPanel.AddDistance.Label:SetWide(70, 0)
		Left = Left+70
		CPanel.AddDistance.Slider:SetPos(Left, 0)
		local Right = CPanel:GetWide()-10
		Right = Right-35
		CPanel.AddDistance.TextArea:SetPos(Right, 0)
		CPanel.AddDistance.TextArea:SetWide(30)
		CPanel.AddDistance.Slider:SetWide((Right-Left)-5)
	end
	
	local val = GetConVarNumber("nocollide_world_distance") or 0
	if val then
		CPanel.AddDistance.Scratch:SetValue(val)
		val = tonumber(CPanel.AddDistance.Scratch:GetFloatValue()) or 0
		CPanel.AddDistance.Slider:SetSlideX(CPanel.AddDistance.Scratch:GetFraction(val))
		if CPanel.AddDistance.TextArea != vgui.GetKeyboardFocus() then
			local str = CPanel.AddDistance.Scratch:GetTextValue()
			if string.find(str,".",1,true) then str = string.Explode(".", str, true)[1] end
			CPanel.AddDistance.TextArea:SetValue(str)
		end
	end
	
	CPanel:AddControl("Checkbox", {Label = "Hide Effect", Command = "nocollide_world_effect"})
	
	local function CVarChange(_,Old,New)
		if New then
			if CPanel.IgnoreCheckbox then if New == "3" or New == "4" or New == "8" or New == "9" then CPanel.IgnoreCheckbox:SetVisible(true) else CPanel.IgnoreCheckbox:SetVisible(false) end end
			if CPanel.AddDistance then if New == "6" or New == "7" or New == "8" or New == "9" then CPanel.AddDistance:SetVisible(true) else CPanel.AddDistance:SetVisible(false) end end
			if CPanel.RemoveCheckbox and New == "10" then CPanel.RemoveCheckbox:SetVisible(true) else CPanel.RemoveCheckbox:SetVisible(false) end
		end
	end
	cvars.AddChangeCallback("nocollide_world_options", CVarChange)
	CVarChange(nil,nil,GetConVarString("nocollide_world_options"))
end

if SERVER then
	hook.Add("Tick", "NoCollideWorldTick", function()
		for k,pl in pairs(player.GetAll()) do
			if SendToClient[pl] and SendToClient[pl][SendDone[pl]+1] then
				local S = SendDone[pl]+1
				SendDone[pl] = S
				net.Start("DrawNoCollide")
				if SendToClient[pl][S][2] then net.WriteString(tostring(SendToClient[pl][S][1]).."_"..SendToClient[pl][S][2].."_"..SendToClient[pl][S][3]) else net.WriteString(tostring(SendToClient[pl][S][1]).."_"..SendToClient[pl][S][3]) end
				net.Send(pl)
				if !SendToClient[pl][S+1] then
					SendDone[pl] = 0
					SendToClient[pl] = {}
				end
			end
			if SendToClient2[pl] and SendToClient2[pl][SendDone2[pl]+1] then
				local S = SendDone2[pl]+1
				SendDone2[pl] = S
				net.Start("DrawNoCollide")
				if SendToClient2[pl][S][2] then net.WriteString(tostring(SendToClient2[pl][S][1]).."_"..SendToClient2[pl][S][2].."_"..SendToClient2[pl][S][3]) else net.WriteString(tostring(SendToClient2[pl][S][1]).."_"..SendToClient2[pl][S][3]) end
				net.Send(pl)
				if !SendToClient2[pl][S+1] then
					SendDone2[pl] = 0
					SendToClient2[pl] = {}
				end
			end
		end
	end)

	local MAX_CONSTRAINTS_PER_SYSTEM = 100
	
	local function CreateConstraintSystem()
		local System = ents.Create("phys_constraintsystem")
		if !IsValid(System) then return end
		System:SetKeyValue("additionaliterations", GetConVarNumber("gmod_physiterations"))
		System:Spawn()
		System:Activate()
		return System
	end
	
	local function FindOrCreateConstraintSystem(Ent1, Ent2)
		local System
		if !Ent1:IsWorld() and Ent1:GetTable().ConstraintSystem and Ent1:GetTable().ConstraintSystem:IsValid() then System = Ent1:GetTable().ConstraintSystem end
		if System and System:IsValid() and System:GetVar("constraints", 0) > MAX_CONSTRAINTS_PER_SYSTEM then System = nil end
		if !System and !Ent2:IsWorld() and Ent2:GetTable().ConstraintSystem and Ent2:GetTable().ConstraintSystem:IsValid() then System = Ent2:GetTable().ConstraintSystem end
		if System and System:IsValid() and System:GetVar("constraints", 0) > MAX_CONSTRAINTS_PER_SYSTEM then System = nil end
		if !System or !System:IsValid() then System = CreateConstraintSystem() end
		if !System then return end
		Ent1.ConstraintSystem = System
		Ent2.ConstraintSystem = System
		System.UsedEntities = System.UsedEntities or {}
		table.insert(System.UsedEntities, Ent1)
		table.insert(System.UsedEntities, Ent2)
		System:SetVar("constraints", System:GetVar("constraints", 0)+1)
		return System
	end
	
	function constraint.NoCollideWorld(Ent1, Ent2, Bone1, Bone2)
		if !Ent1 or !Ent2 then return false end
		
		if Ent1 == game.GetWorld() then
			Ent1 = Ent2
			Ent2 = game.GetWorld()
			Bone1 = Bone2
			Bone2 = 0
		end
		
		if !Ent1:IsValid() or (!Ent2:IsWorld() and !Ent2:IsValid()) then return false end
		
		Bone1 = Bone1 or 0
		Bone2 = Bone2 or 0
		
		local Phys1 = Ent1:GetPhysicsObjectNum(Bone1)
		local Phys2 = Ent2:GetPhysicsObjectNum(Bone2)
		
		if !Phys1 or !Phys1:IsValid() or !Phys2 or !Phys2:IsValid() then return false end
		
		if Phys1 == Phys2 then return false end
		
		if Ent1:GetTable().Constraints then
			for k, v in pairs(Ent1:GetTable().Constraints) do
				if v:IsValid() then
					local CTab = v:GetTable()
					if (CTab.Type == "NoCollideWorld" or CTab.Type == "NoCollide") and ((CTab.Ent1 == Ent1 and CTab.Ent2 == Ent2) or (CTab.Ent2 == Ent1 and CTab.Ent1 == Ent2)) then return false end
				end	
			end
		end
		
		local System = FindOrCreateConstraintSystem(Ent1, Ent2)
		
		if !IsValid(System) then return false end
		
		SetPhysConstraintSystem(System)
		
		local Constraint = ents.Create("phys_ragdollconstraint")
		
		if !IsValid(Constraint) then
			SetPhysConstraintSystem(NULL)
			return false
		end
		Constraint:SetKeyValue("xmin", -180)
		Constraint:SetKeyValue("xmax", 180)
		Constraint:SetKeyValue("ymin", -180)
		Constraint:SetKeyValue("ymax", 180)
		Constraint:SetKeyValue("zmin", -180)
		Constraint:SetKeyValue("zmax", 180)
		Constraint:SetKeyValue("spawnflags", 3)
		Constraint:SetPhysConstraintObjects(Phys1, Phys2)
		Constraint:Spawn()
		Constraint:Activate()
		
		SetPhysConstraintSystem(NULL)
		constraint.AddConstraintTable(Ent1, Constraint, Ent2)
		
		local ctable = 
		{
			Type 			= "NoCollideWorld",
			Ent1  			= Ent1,
			Ent2 			= Ent2,
			Bone1 			= Bone1,
			Bone2 			= Bone2
		}
		
		Constraint:SetTable(ctable)
		
		return Constraint
	end
	duplicator.RegisterConstraint("NoCollideWorld", constraint.NoCollideWorld, "Ent1", "Ent2", "Bone1", "Bone2")
end
--lua/weapons/heavy_knuckle/shared.lua:
if CLIENT then
SWEP.DrawWeaponInfoBox = true
end

SWEP.Author       = "-CRY-minal-"
SWEP.Purpose      = "Weighted knuckles, beats harder than usual"
SWEP.Instructions = "Kick their ass!"

SWEP.PrintName = " Heavy knuckle"
SWEP.Category = "Gluk Melee"
SWEP.Spawnable= true

SWEP.ViewModelFOV = 60
SWEP.ViewModel = "models/weapons/cstrike/c_knife_t.mdl"
SWEP.WorldModel = ""
SWEP.ViewModelFlip = false
SWEP.BobScale = 1
SWEP.SwayScale = 0

SWEP.HoldType = "knife"

SWEP.AutoSwitchTo = true
SWEP.AutoSwitchFrom = false
SWEP.Weight = 0
SWEP.Slot = 0
SWEP.SlotPos = 0

SWEP.UseHands = true
SWEP.DrawAmmo = false
SWEP.Base = "weapon_base"

SWEP.Idle = 0
SWEP.IdleTimer = CurTime()

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Damage = 99
SWEP.Primary.DelayMiss = 1
SWEP.Primary.DelayHit = 1.3
SWEP.Primary.Force = 9000

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.ViewModelBoneMods = {
	["v_weapon.Knife_Handle"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["part1"] = { type = "Model", model = "models/props_c17/TrapPropeller_Lever.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0.05, 0.2, 1.5), angle = Angle(180, 90, -90), size = Vector(0.4, 0.4, 0.4), color = Color(145, 145, 145, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part2"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 1.299, 3), angle = Angle(0, 180, 0), size = Vector(0.012, 0.012, 0.012), color = Color(255, 145, 145, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part6"] = { type = "Model", model = "models/props_c17/TrapPropeller_Lever.mdl", bone = "v_weapon.Knife_Handle", rel = "part1", pos = Vector(-0.301, 0.004, -0.005), angle = Angle(0, 0, 0), size = Vector(0.4, 0.4, 0.4), color = Color(255, 145, 145, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part3"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 2.2, 2), angle = Angle(0, 180, 0), size = Vector(0.012, 0.012, 0.012), color = Color(145, 145, 145, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part5"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 2, -0.301), angle = Angle(0, 180, 0), size = Vector(0.012, 0.012, 0.012), color = Color(145, 145, 145, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part4"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "v_weapon.Knife_Handle", rel = "", pos = Vector(0, 2.599, 0.899), angle = Angle(0, 180, 0), size = Vector(0.012, 0.012, 0.012), color = Color(255, 145, 145, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} }
}
SWEP.WElements = {
	["part5"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4.9, 0, 0), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part2"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4.9, 0, -1.5), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part3"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.599, 0, 1.2), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part1"] = { type = "Model", model = "models/props_c17/TrapPropeller_Lever.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.599, 0, 0), angle = Angle(0, 0, 90), size = Vector(0.3, 0.3, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} },
	["part4"] = { type = "Model", model = "models/props_canal/canal_cap001.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.599, 0, -2.3), angle = Angle(0, 90, 0), size = Vector(0.009, 0.009, 0.009), color = Color(255, 255, 255, 255), surpresslightning = false, material = "phoenix_storms/gear", skin = 0, bodygroup = {} }
}

function SWEP:Initialize()
self:SetWeaponHoldType( self.HoldType )
self.Idle = 0
self.IdleTimer = CurTime() + 1
end

function SWEP:Deploy()
self:SetWeaponHoldType( self.HoldType )
self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
return true
end

function SWEP:Holster()
self.Idle = 0
self.IdleTimer = CurTime()
return true
end

function SWEP:PrimaryAttack()
self:SetHoldType( self.HoldType )
local tr = util.TraceLine( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 64,
filter = self.Owner,
mask = MASK_SHOT_HULL,
} )
if !IsValid( tr.Entity ) then
tr = util.TraceHull( {
start = self.Owner:GetShootPos(),
endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 64,
filter = self.Owner,
mins = Vector( -16, -16, 0 ),
maxs = Vector( 16, 16, 0 ),
mask = MASK_SHOT_HULL,
} )
end
if SERVER then
if IsValid( tr.Entity ) then
local dmg = DamageInfo()
local attacker = self.Owner
if !IsValid( attacker ) then
attacker = self
end
dmg:SetAttacker( attacker )
dmg:SetInflictor( self )
dmg:SetDamage( self.Primary.Damage )
dmg:SetDamageForce( self.Owner:GetForward() * self.Primary.Force )
tr.Entity:TakeDamageInfo( dmg )
end
if !tr.Hit then
self.Owner:EmitSound( "Weapon_HL_Crowbar.Miss" )
end
if tr.Hit then
local bullet = {}
bullet.Num = 1
bullet.Src = self.Owner:GetShootPos()
bullet.Dir = self.Owner:GetAimVector()
bullet.Distance = 64
bullet.Spread = Vector( 0, 0, 0 )
bullet.Tracer = 0
bullet.Force = 0
bullet.Damage = 0
bullet.AmmoType = "none"
self.Owner:FireBullets( bullet )
if tr.Entity:IsNPC() || tr.Entity:IsPlayer() then
self.Owner:EmitSound( "Flesh.ImpactHard" )
else
self.Owner:EmitSound( "Weapon_HL_Crowbar.Hit" )
end
end
end
if !tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
end
if tr.Hit then
self.Weapon:SendWeaponAnim( ACT_VM_MISSCENTER )
self:SetNextPrimaryFire( CurTime() + self.Primary.DelayHit )
self:SetNextSecondaryFire( CurTime() + self.Primary.DelayHit )
end
self:ShootEffects()
self.Idle = 0
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end

function SWEP:SecondaryAttack()
end

function SWEP:ShootEffects()
self.Owner:SetAnimation( PLAYER_ATTACK1 )
end

function SWEP:Reload()
end

function SWEP:Think()
if self.IdleTimer <= CurTime() then
if self.Idle == 0 then
self.Idle = 1
end
if SERVER and self.Idle == 1 then
self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
end
self.IdleTimer = CurTime() + self.Owner:GetViewModel():SequenceDuration()
end
end






/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

function SWEP:Initialize()

	// other initialize code goes here

	if CLIENT then
		
		self:SetWeaponHoldType( self.HoldType )	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				--[[// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]--
			end
		end
		
	end

end

function SWEP:Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end
--addons/arccw_weapons/lua/weapons/masita_cr2.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 3 -- Change this if you want to select the weapon with other number

-- Trivia
SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "CR-2"
SWEP.Trivia_Class = "Heavy-Blaster Pistol"
SWEP.Trivia_Desc = "The CR-2 heavy blaster pistol was a heavy blaster pistol manufactured by Corellian Arms that was utilized by the Royal Naboo Security Forces. Small and agile, it had an extreme rate of fire and shoot ionized bolts. It also could be configured with night vision scopes or have an extended stock for reduced recoil."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/cr2.png"

-- Viewmodel & Entity Properties
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/everfall/weapons/viewmodels/c_cr2.mdl"
SWEP.WorldModel = "models/everfall/weapons/worldmodels/w_cr2.mdl"
SWEP.ViewModelFOV = 50
SWEP.WorldModelOffset = {
    pos = Vector(-11.4, 5, -5),
    ang = Angle(-10, 0, 180),
    scale = 1.2,
    bone = "ValveBiped.Bip01_R_Hand",
}

SWEP.NoHideLeftHandInCustomization = true

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.8,
    [HITGROUP_CHEST] = 1.5,
    [HITGROUP_LEFTARM] = 1.1,
    [HITGROUP_RIGHTARM] = 1.1,
}

SWEP.Damage = 37
SWEP.RangeMin = 197
SWEP.DamageMin = 24
SWEP.Range = 480
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 413
SWEP.TraceNum = 1
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_green"
SWEP.TracerCol = Color(0, 250, 0)
SWEP.HullSize = 1
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 55
SWEP.Recoil = 0.23
SWEP.RecoilSide = 0.11
SWEP.RecoilRise = 0.11
SWEP.Delay = 60 / 427
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 2
	},
    {
        Mode = 1
    },
    {
        Mode = 0
    },            
}
SWEP.AccuracyMOA = 0.59
SWEP.HipDispersion = 447
SWEP.MoveDispersion = 54

-- Speed Mult
SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.83
SWEP.SightTime = 0.2

-- Ammo, Sounds & MuzzleEffect
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 90
SWEP.FirstShootSound = "armas/disparos/cr-2/blasters_cr2_laser_close_var_07.mp3"
SWEP.ShootSound = "armas/disparos/cr-2/blasters_cr2_laser_close_var_08.mp3"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"

SWEP.NoFlash = nil
SWEP.MuzzleEffect = "wpn_muzzleflash_dc17_green"
SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 250, 0)

-- Ironsight
SWEP.IronSightStruct = {
    Pos = Vector(-4.152, -5.928, 2.367),
    Ang = Angle(0, 0, 0),
     Magnification = 1.4,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

-- Holdtype
SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "smg"
SWEP.HoldtypeSights = "rpg"
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, 3, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(4.019, -5.226, -0.805)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(15, -5, -1.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.InBipodPos = Vector(-8, 0, -4)
SWEP.InBipodMult = Vector(2, 1, 1)

SWEP.Bipod_Integral = true -- Integral bipod (ie, weapon model has one)
SWEP.BipodDispersion = 1 -- Bipod dispersion for Integral bipods
SWEP.BipodRecoil = 1 -- Bipod recoil for Integral bipods
-- Attachments
SWEP.AttachmentElements = {
    ["cr2_barrel_extended"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
        AttPosMods = {
            [2] = {
                vpos = Vector(-0.45, 0.7, 13.4),
            },
        }
    },
    ["cr2_stock"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
}

SWEP.Attachments = {
    [1] = {
        PrintName = "Sight",
        DefaultAttName = "Standard", 
        Slot = "optic", 
        Bone = "cr2",
        Offset = {
            vpos = Vector(-0.45, -1.7, -1),
            vang = Angle(90, 0, -90),
        },
        CorrectiveAng = Angle(0, 0, 0),
        CorrectivePos = Vector(0, 0, 0),
    },     
    [2] = {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "cr2",
        Offset = {
            vpos = Vector(-0.45, 0.7, 11.4),
            vang = Angle(90, 0, -90),

        },
    },       
    [3] = {
        PrintName = "Barrel",
        DefaultAttName = "None",
        Slot = "cr2_barrel",
    },   
    [4] = {
        PrintName = "Stock",
        DefaultAttName = "None",
        Slot = "cr2_stock",
    },  
    [5] = {
        PrintName = "Internal Modifications",
        DefaultAttName = "None",
        Slot = "uc_fg",
    },   
    [6] = {
        PrintName = "Ammo", 
        DefaultAttName = "Standard",
        Slot = "ammo",
    },
    [7] = {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    [8] = {
        PrintName = "Charms",
        DefaultAttName = "None",
        VMScale = Vector(0.7, 0.7, 0.7),
        Slot = {"charm"},
        Bone = "cr2",
        Offset = {
            vpos = Vector(0, -1.4, 3.3),
            vang = Angle(90, 0, -90),
        },
    },    
    [9] = {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "cr2",
        Offset = {
            vpos = Vector(0.7, -0.7, -1),
            vang = Angle(90, 0, -90),
        },
    },         
}

-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "Idle"
    },
    ["fire"] = {
        Source = "Fire"
    },
    ["fire_iron"] = {
        Source = "Neutral"
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_lgequip.wav",
                p = 100, 
                v = 75,
                t = 0, 
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armasclasicas/wpn_empire_medequip.wav",
                p = 100,
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload", 
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        SoundTable = {
            {s = "everfall/weapons/miscellaneous/reload/reset/overheatactivecoolingsuccess_var_03.mp3", t = 2.2 },
            {s = "everfall/weapons/miscellaneous/reload/overheat/overheat_overheated_large_var_03.mp3", t = 0.1 / 30},
        },
    },
}
--addons/arccw_weapons/lua/weapons/masita_dc17m_sniper.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true

SWEP.Category = "AOCRP - Nicht eingestelle Waffen"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-17m Sniper"
SWEP.Trivia_Class = "Modular Blaster Rifle"
SWEP.Trivia_Desc = "The DC-17m Interchangeable Weapon System, also known as the DC-17m Repeating Blaster Rifle, was a type of repeating blaster rifle used by Republic clone commandos during the Clone Wars. It could change between a repeating blaster rifle and grenade launcher by switching the weapon's barrel module."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc17m_sniper_new.png"

SWEP.Slot = 3

SWEP.UseHands = true
SWEP.NoHideLeftHandInCustomization = true
SWEP.MirrorVMWM = true
SWEP.UseHands = true
SWEP.ViewModel = "models/arccw/kraken/c_dc17m_sniper.mdl"
SWEP.WorldModel = "models/arccw/kraken/w_dc17m_sniper.mdl"
SWEP.ViewModelFOV = 53
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(-5, 9, -6),
    ang = Angle(-10, 0, 180),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 1,
}

-- Damage & Properties
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 2,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.Damage = 55
SWEP.RangeMin = 190
SWEP.DamageMin = 35
SWEP.Range = 630
SWEP.Penetration = 1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5
SWEP.ChamberSize = 0

SWEP.Primary.ClipSize = 5

SWEP.Recoil = 1.28
SWEP.RecoilSide = 0.12
SWEP.RecoilRise = 0.98

SWEP.Delay = 60 / 102
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 1
    },
    {
        Mode = 0
    },        
}

SWEP.AccuracyMOA = 0.1
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 100

SWEP.NoFlash = nil

SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false --
SWEP.MuzzleFlashColor = Color(0, 0, 255)

-- Ironsight & Properties
SWEP.Primary.Ammo = "ar2"

SWEP.ShootVol = 150
SWEP.ShootPitch = 100
SWEP.ShootPitchVariation = 0.05

SWEP.ShootSound = "armas/disparos/dc17m/dc17m_sniper_fire0.wav"
SWEP.FirstShootSound = "armas/disparos/dc17m/dc17m_sniper_fire0.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc17m/dc17m_fire_silenced.wav"

SWEP.IronSightStruct = {
    Pos = Vector(-7.594, 0, 0.651),
    Ang = Angle(0.574, -1.456, 0),
     Magnification = 1.6,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 55,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-3, 3, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.SprintPos = Vector(7, 0, -4)
SWEP.SprintAng = Angle(5, 40, 0)

SWEP.CustomizePos = Vector(0, 3, -4)
SWEP.CustomizeAng = Angle(12.149, 30.547, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

-- Attachments
SWEP.Attachments = {
    {
        PrintName = "Sight",
        DefaultAttName = "Standard",
        Slot = "optic",
        Bone = "weaponAttach_R",
        Offset = {
            vpos = Vector(0, -0.1, 4.8),
            vang = Angle(0, -0.5, 0),
        },
        CorrectiveAng = Angle(0, 1, 0),
        CorrectivePos = Vector(0, 0, 0),
    },
    {
        PrintName = "Tactical",
        DefaultAttName = "None",
        Slot = {"tactical", "tac_pistol"},
        VMScale = Vector(0.7, 0.7, 0.7),
        Bone = "weaponAttach_R",
        Offset = {
            vpos = Vector(13, -1.76, 2.7),
            vang = Angle(0, 0, 90),
        },
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "None",
        Slot = {"muzzle", "dlt19_muzzle", "dc15a_muzzle", "cr2_muzzle", "cr2c_muzzle", "stealth_muzzle", "b1120_muzzle"},
        Bone = "weaponAttach_R",
        Offset = {
            vpos = Vector(28, 0, 3.9),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Energization",
        DefaultAttName = "Standard",
        Slot = {"ammo", "special_ammo"}
    },
    {
        PrintName = "Perk",
        DefaultAttName = "None",
        Slot = "perk",
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        Bone = "weaponAttach_R",
        VMScale = Vector(0.7, 0.7, 0.7),
        Offset = {
            vpos = Vector(0, -1.4, 2.4),
            vang = Angle(0, 0, 0),
        },
    },
    {
        PrintName = "Killcounter",
        DefaultAttName = "None",
        Slot = {"killcounter"},
        Bone = "weaponAttach_R",
        VMScale = Vector(0.9, 0.9, 0.9),
        Offset = {
            vpos = Vector(-2, -1.3, 3.4),
            vang = Angle(0, 0, 20),
        },
    },
}

SWEP.Animations = {
    ["enter_inspect"]= {
        Source = "pose",
        SoundTable = {
            {
                s = "armas/disparos/dc17m/dc17m_sniper_pose.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 100, -- volume
                t = 1, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["idle"] = {
        Source = "idle",
    },
    ["bash"] = {
        Source = "melee", 
        SoundTable = {
            {s = "armas/disparos/dc17m/melee0.wav", t = 0.1 },
        },
    },
    ["fire"] = {
        Source = "fire"
    },
    ["fire_iron"] = {
        Source = false
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = {
            {
                s = "armas/disparos/dc17m/dc17m_sniper_unholster.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 100, -- volume
                t = 0.1, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armas/disparos/dc17m/dc17m_sniper_unholster.wav", -- sound; can be string or table
                p = 100, -- pitch
                v = 75, -- volume
                t = 0.1, -- time at which to play relative to Animations.Time
                c = CHAN_ITEM, -- channel to play the sound
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2, 
        SoundTable = {
            {s = "armas/disparos/dc17m/dc17m_sniper_reload.wav", t = 0.1 }, --s sound file
        },
    },
}
--addons/arccw_weapons/lua/weapons/masita_dc17s.lua:
AddCSLuaFile()

SWEP.Base = "arccw_masita_base"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Slot = 1 -- Change this if you want to select the weapon with other number

SWEP.Category = "REP"
SWEP.Credits = "Kraken/Masita"
SWEP.PrintName = "DC-17s [Blue]"
SWEP.Trivia_Class = "Heavy Blaster Pistol"
SWEP.Trivia_Desc = "The DC-17s hand blaster, also known as DC-17s blaster pistol, was a heavy blaster pistol wielded by the clone troopers of the Grand Army of the Galactic Republic during the Clone Wars. An advanced firearm, it was fielded to elite soldiers in the army, most notably Advanced Recon Commandos, clone trooper commanders, and clone jet troopers. This one version is a powerful one."
SWEP.Trivia_Manufacturer = "BlasTech Industries"
SWEP.Trivia_Calibre = "Tibanna Gas"
SWEP.Trivia_Year = 2023
SWEP.IconOverride = "entities/masita/dc17s_blue.png"

-- Viewmodel & Entity Properties
SWEP.MirrorVMWM = false
SWEP.UseHands = true
SWEP.ViewModel = "models/weapon/ven/ggn/dc17s_single.mdl"
SWEP.WorldModel = "models/arccw/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV = 60
SWEP.HideViewmodel = false
SWEP.WorldModelOffset = {
    pos = Vector(0, 0, 0),
    ang = Angle(0, 0, 0),
    bone = "ValveBiped.Bip01_R_Hand",
    scale = 0.009
}

SWEP.DefaultSkin = 1

-- Damage & Tracer
SWEP.BodyDamageMults =  {
    [HITGROUP_HEAD] = 1.5,
    [HITGROUP_CHEST] = 1,
    [HITGROUP_LEFTARM] = 0.9,
    [HITGROUP_RIGHTARM] = 0.9,
}

SWEP.AutoReload = true
SWEP.Damage = 30
SWEP.RangeMin = 300
SWEP.DamageMin = 15
SWEP.Range = 550
SWEP.Penetration = 1.1
SWEP.DamageType = DMG_BULLET
SWEP.MuzzleVelocity = 400
SWEP.PhysTracerProfile = 1
SWEP.TracerNum = 1
SWEP.Tracer = "tracer_blue"
SWEP.TracerCol = Color(0, 0, 255)
SWEP.HullSize = 1.5
SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 20
SWEP.Recoil = 0.5
SWEP.RecoilPunch = 0.3
SWEP.RecoilSide = 0.2
SWEP.RecoilRise = 0.17
SWEP.Delay = 60 / 425
SWEP.Num = 1
SWEP.Firemodes = {
	{
		Mode = 1
	},
    {
        Mode = 2
    },
    {
        Mode = 0
    },    
}

SWEP.AccuracyMOA = 0.57
SWEP.HipDispersion = 576
SWEP.MoveDispersion = 53

-- Sounds & Muzzleflash
SWEP.ShootSound = "armas/disparos/dc17s.wav"
SWEP.ShootSoundSilenced = "armas/disparos/dc19.wav"
SWEP.NoFlash = nil 

SWEP.FastMuzzleEffect = nil
SWEP.GMMuzzleEffect = false
SWEP.MuzzleFlashColor = Color(0, 0, 255)


-- Ironsight & Holdtype
SWEP.Primary.Ammo = "ar2"
SWEP.ShootVol = 100
SWEP.ShootPitch = 100
SWEP.IronSightStruct = {
    Pos = Vector(-3.947, 1.389, 0.526),
    Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "weapon_hand/ads/0242-00001a46.mp3",
     SwitchFromSound = "weapon_hand/ads/0242-00001a43.mp3",
     ViewModelFOV = 60,
}

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "pistol"
SWEP.HoldtypeSights = "revolver"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL

SWEP.ActivePos = Vector(1, 6, 1)
SWEP.ActiveAng = Angle(-3.2, -3, 0)

SWEP.SprintPos = Vector(1, -6, -10)
SWEP.SprintAng = Angle(40, 0, 0)

SWEP.HolsterPos = Vector(4, -3, 2)
SWEP.HolsterAng = Vector(-15, 30, -15)

SWEP.CustomizePos = Vector(10, 0, -1.08)
SWEP.CustomizeAng = Angle(6.8, 30.7, 10.3)


-- Attachments
SWEP.DefaultElements = {"dc17s"}
SWEP.AttachmentElements = {
    ["dc17s"] = { 
        WMElements = {
            {
                Model = "models/weapon/ven/ggn/dc17s_single_world.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(1, 1, 1),
                ModelSkin = 1,
                Offset = {
                    pos = Vector(450, 50, -100),
                    ang = Angle(0, -10, -180),
                }
            },
            {
                Model = "models/hunter/plates/plate.mdl",
                Bone = "ValveBiped.Bip01_R_Hand",
                Scale = Vector(0, 0, 0),
                Offset = {
                    pos = Vector(1900, 200, -200),
                    ang = Angle(0, -10, 180)
                },
                IsMuzzleDevice = true
            }, 
        },
    },
}
WMOverride = "models/weapon/ven/ggn/dc17s_single_world.mdl"

SWEP.Attachments = {
    {
        PrintName = "Sight", -- name of the attachment
        DefaultAttName = "Standard", -- default name (like: 'default', 'none', 'standard')
        Slot = "optic", -- slots, you can add attachments per slot using this: Slot = {"optic", "optics", "etc"},
        Bone = "DC17S_Root",
        WMScale = Vector(111, 111, 111),
        Offset = {
            vpos = Vector(0.001, -1.9, -2.32),
            vang = Angle(90, 0, -90),
            wpos = Vector(600, 100, -475),
            wang = Angle(0, -10, 180)
        },
    },
    {
        PrintName = "Laser/Flashlight", 
        DefaultAttName = "None",
        Slot = {"tac_pistol", "tactical"},
        Bone = "DC17S_Root",
        WMScale = Vector(111, 111, 111),
        Offset = {
            vpos = Vector(-0.101, 0.557, 7.738),
            vang = Angle(90, 0, -90),
            wpos = Vector(1450, 265, -175),
            wang = Angle(0, -10, 180)
        },
    },    
    {
        PrintName = "Ammo",
        DefaultAttName = "Standard",
        Slot = {"aocrp_ammo"}
    },
    {
        PrintName = "Charm",
        DefaultAttName = "None",
        Slot = {"charm"},
        WMScale = Vector(111, 111, 111),
        Bone = "DC17S_Root",
        Offset = {
            vpos = Vector(0.768, -0.238, 0),
            vang = Angle(90, 0, -90),
            wpos = Vector(750, 225, -350),
            wang = Angle(0, -10, 180)
        },
    },          
}


-- Don't touch this unless you know what you're doing
SWEP.Animations = {
    ["idle"] = {
        Source = "idle"
    },
    ["sprint"] = {
        Source = "base_sprint_loop"
    },
    ["fire"] = {
        Source = "shoot"
    },
    ["draw"] = {
        Source = "draw",
        Mult = 1.1,
        SoundTable = {
            {
                s = "armas/misc/dc17s_draw.wav",
                p = 100,
                v = 75, 
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["holster"] = {
        Source = "holster",
        SoundTable = {
            {
                s = "armas/misc/dc17s_holster.wav",
                p = 100, 
                v = 75,
                t = 0,
                c = CHAN_ITEM,
            },
        }
    },
    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL, 
        SoundTable = {
            {s = "dc17s_1", t = 1 / 30},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_PISTOL, 
        SoundTable = {
            {s = "dc17s_2", t = 4 / 30},
        },
    },


sound.Add({
    name =          "dc17s_1",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armas/misc/dc17s_reload.wav"
    }),
sound.Add({
    name =          "dc17s_2",
    channel =       CHAN_ITEM,
    volume =        1.5,
    sound =             "armas/misc/dc17s_empty.wav"
    }),
}


--addons/weapons_other/lua/weapons/recondroidkit.lua:
////////////////////////////////////////////////////////////////
// Deployment Tool, Deployment Base
// By Svn
///////////////////////////////////////////////////////////////
//Editing this file will invalidate your support warranty.////


------------------------------------------------------------------------
-- Weapon Variables
SWEP.PrintName 				= "Recon Droid Kit"
SWEP.Author 				= "Evan"
SWEP.Spawnable 				= true
SWEP.DrawCrosshair			= true
SWEP.DrawAmmo 				= false
SWEP.Slot = 3
SWEP.SlotPos = 5
SWEP.Category = "AOCRP - Eingestellte Waffen"
SWEP.Primary.Ammo			= ""
SWEP.Secondary.Ammo         = ""
SWEP.Primary.Damage         = 0
SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.AllowsAutoSwitchFrom  	= false
------------------------------------------------------------------------
-- SCK Variables
SWEP.HoldType 				= "duel"
SWEP.ViewModelFOV 			= 59.9
SWEP.ViewModelFlip 			= false
SWEP.UseHands				= false
SWEP.ViewModel 				= "models/weapons/c_arms_citizen.mdl"
SWEP.WorldModel 			= "models/weapons/w_pistol.mdl"
SWEP.ShowViewModel 			= false
SWEP.ShowWorldModel 		= false
SWEP.WElements = {
	["we"] = { 
		type = "Model",
		model = "models/props/starwars/weapons/repairkit.mdl", //models/props_junk/wood_crate001a.mdl
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(3.635, 11.947, 0),
		angle = Angle(0, -5.844, -174.157),
		size = Vector(1, 1, 1),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}
------------------------------------------------------------------------
-- Data Tables
function SWEP:SetupDataTables()
	
end
------------------------------------------------------------------------
function SWEP:OnDrop()
	

end
-- Primary
function SWEP:PrimaryAttack()
	local ply2 = self.Owner
	if CLIENT then return end
	local pos = self:DroidPos()
	if !pos then return end
	local ent = ents.Create("recondroid")
	if IsValid( ent ) then
	local SpawnAng = self.Owner:EyeAngles()
	SpawnAng.p = 0
	SpawnAng.y = SpawnAng.y + 180
	ent:SetPos(pos) 
	ent:SetAngles(SpawnAng )
	ent:Spawn()
	ent:Activate()
	ent:GetPhysicsObject():EnableGravity(false)
	self.Owner.droid = ent
	ent.pilot = self.Owner
	self.Owner:SetNWEntity( "droid", ent )
	self.Owner:SetNWBool( "deployed", true )
	

	self.Owner:StripWeapon("ReconDroidKit")	
	timer.Simple( 1, function() ply2:Give("recondroidcontroller") end )
	--self.Owner:Give("ReconDroidController")
	
	end
end

function SWEP:DroidPos()
	local ply = self.Owner
	local pos = ply:GetShootPos()
	local ang = ply:GetAimVector()
	if ang.z > 0 then return false end
	local td = {}
	td.start = pos
	td.endpos = pos+(ang*120)
	td.filter = ply
	local trace = util.TraceLine(td)
	return trace.HitPos
end
------------------------------------------------------------------------
-- Reload
function SWEP:Reload()
	
end
------------------------------------------------------------------------
-- Secondary
function SWEP:SecondaryAttack()
	
end
------------------------------------------------------------------------
-- Facepunch Code

function SWEP:Think()
	
end
------------------------------------------------------------------------
-- SCK, By Clavus
function SWEP:Initialize()
	self:SetHoldType("duel")
	
	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end

end
function SWEP:Holster()
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	return true
end
function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then

	
	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end

--addons/weapons_other/lua/weapons/seil.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- weapon_cuff_standard.lua SHARED --
--                                 --
-- Rope handcuffs.                 --
-------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_leash_base"

SWEP.Category = "AOCRP - Tools"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "A weak leash."

SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.AdminSpawnable = true

SWEP.Slot = 3
SWEP.PrintName = "Leine"

//
// Handcuff Vars
SWEP.CuffTime = 0.8 // Seconds to handcuff
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "models/props_foliage/tree_deciduous_01a_trunk"
SWEP.CuffRope = "cable/rope"
SWEP.CuffStrength = 0.85
SWEP.CuffRegen = 0.8
SWEP.RopeLength = 200
SWEP.CuffReusable = true

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0.1 // Randomise strangth
SWEP.CuffRegenVariance = 0.2 // Randomise regen

--addons/weapons_other/lua/weapons/tc_schild.lua:
AddCSLuaFile()


/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Downloading content from workshop
---------------------------------------------------------------------------------------------------------------------------------------------
*/	

--if SERVER then resource.AddWorkshop("2441211404"); end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Config
---------------------------------------------------------------------------------------------------------------------------------------------
*/

SWEP.shieldDamage = 10;
SWEP.bashReloadTime = 20;
SWEP.stunTime = 1;

SWEP.canBeDestroyedByDamage = false;
SWEP.onlyExplosionDamage = true;
SWEP.defaultHealth = 1000;

local deleteShieldsAfterDeath = true;

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Default SWEP config
---------------------------------------------------------------------------------------------------------------------------------------------
*/

SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
SWEP.Author = "Drover | Edit by Mickerd"
SWEP.Contact = "Discord: Mickerd#1593"
SWEP.Purpose = ""
SWEP.IconLetter = ""
SWEP.PrintName = "Kampfschild"
SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "physgun"
SWEP.HoldType ="physgun"
SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "AOCRP - Eingestellte Waffen"

SWEP.ViewModel = Model("models/drover/shield.mdl");
SWEP.WorldModel = Model("models/weapons/arccw_go/v_shield.mdl");



SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""



/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Initialize
---------------------------------------------------------------------------------------------------------------------------------------------
*/

function SWEP:Initialize()
    self:SetHoldType("physgun");
end



function SWEP:SetupShield()
	--if true then return end
	if CLIENT then return end;
	self.shieldProp = ents.Create("prop_physics");
	self.shieldProp:SetModel("models/hunter/blocks/cube075x2x025.mdl");
	
	self.shieldProp:Spawn(); 
	--self.shieldProp:SetModelScale(0,0);
	local phys = self.shieldProp:GetPhysicsObject();
	if not IsValid(phys) then
		self.Owner:ChatPrint("not valid physics object!");
		return;
	end
	phys:SetMass(5000);
	
	local nothand = false;
	local attach = self.Owner:LookupAttachment("anim_attachment_RH");
	if attach == nil or attach == 0 then
		--self.Owner:ChatPrint("Attachment 'anim_attachment_RH' not found for this player model!");
		attach = self.Owner:LookupAttachment("forward");
		nothand = true;
		if attach == nil or attach == 0 then
			self.Owner:ChatPrint("Attachment 'anim_attachment_RH' and 'forward' not found for this player model!");
			return;
		end
	end
	
	local up = -15;
	local forward = 15;
	local right = -8;
	
	local aforward = 20;
	local aup = 70;
	
	if nothand then
	    up = -20;
		forward = 17;
		aforward = 0;
		aup = 90;
	end
	local attachTable = self.Owner:GetAttachment(attach);
	self.shieldProp:SetPos(attachTable.Pos + attachTable.Ang:Up()*up + attachTable.Ang:Forward()*forward + attachTable.Ang:Right()*right);
	
	attachTable.Ang:RotateAroundAxis(attachTable.Ang:Forward(),110);
	attachTable.Ang:RotateAroundAxis(attachTable.Ang:Up(),0);
	attachTable.Ang:RotateAroundAxis(attachTable.Ang:Right(),105);
	self.shieldProp:SetAngles(attachTable.Ang);
	self.shieldProp:SetCollisionGroup( COLLISION_GROUP_WORLD );
	self.shieldProp:SetParent(self.Owner,attach);
	self.shieldProp:SetRenderMode( RENDERMODE_TRANSCOLOR )
	self.shieldProp:SetColor(Color(0,0,0,0))
	--self.shieldProp:SetModelScale(1,0);
	--self.shieldProp:SetNoDraw( true )
--[[ 	timer.Simple(0.2,function()
		if IsValid(self) and IsValid(self.shieldProp) then
			self.shieldProp:SetModelScale(1,0);
			net.Start("disable_shielddraw") net.WriteEntity(self) net.WriteEntity(self.shieldProp) net.Send(self.Owner);
		end
	end) ]]
	
	--self:SetupCollisionHelp()
end


/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				CheckPlace
---------------------------------------------------------------------------------------------------------------------------------------------
*/
function SWEP:CheckPlace(pos)

	local mins = Vector( -10, -20, -3);
	local maxs = Vector( 20, 20, 40);
	local tr = {
		start = pos, 
		endpos = pos + Vector(0,0,5), 
		mins = mins, 
		maxs = maxs,
		filter = {self.Owner,self.shieldProp}
	}
	local hullTrace = util.TraceHull( tr );
	if ( hullTrace.Hit ) then
		return false;
	end	
	return true;	
end



/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Shield bash
---------------------------------------------------------------------------------------------------------------------------------------------
*/


function SWEP:FreezeEnemy(ply)
	ply:Freeze(true);
	timer.Create('unfreezemeswep'..tostring(ply:EntIndex()),self.stunTime,1,function()
		if IsValid(ply) then ply:Freeze(false); end
	end)
end

function SWEP:FindEnemy()
	local mins = Vector( -10, -10, -3);
	local maxs = Vector( 10, 10, 40);
	local pos = self.Owner:GetPos() + self.Owner:GetForward()*35 + Vector(0,0,40);
	local tr = {
		start = pos, 
		endpos = pos + Vector(0,0,5), 
		mins = mins, 
		maxs = maxs,
		filter = {self.Owner,self.shieldProp,Entity(0)}
	}
	local hullTrace = util.TraceHull( tr );
	if ( hullTrace.Hit ) then
		if hullTrace.Entity:IsPlayer() then
			return hullTrace.Entity;
		end
		return false;
	end
	return false;
end


function SWEP:ShieldBash()
	local enemy = self:FindEnemy();
    --self.Owner:EmitSound("w/dc15x/sdkaswq.wav");
	if enemy == false then return end;
	--enemy:TakeDamage(self.shieldDamage,self.Owner,self);
	--self:FreezeEnemy(enemy);

    --print(b:Nick() .. " > "..b:GetPos():DistToSqr( self:GetPos() ))
    GMSERV:AddStatus(b, enemy, "stun", 3, 10, true)
    self:EmitSound("everfall/explosions/ion/destruction_explosions_modular_sfx_small_disruption_var_05.mp3")

   -- self.Owner:EmitSound("w/dc15x/sdkaswq.wav");

end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Primary attack
---------------------------------------------------------------------------------------------------------------------------------------------
*/

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire(CurTime() + self.bashReloadTime);
	--self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK );
	if CLIENT then return end;


    --self:ShieldBash()

	
end


/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Secondary attack / Deploy static shield
---------------------------------------------------------------------------------------------------------------------------------------------
*/
function SWEP:SecondaryAttack()
	if CLIENT then return end;

--[[ 	for k, v in pairs(ents.GetAll()) do
		if v:GetClass() == "police_shield" then
			if v.Owner == self.Owner then
				v:Remove()
			end
		end
	end

	local ang = self.Owner:GetAngles()
	ang.p = 0;
	ang.r = 0;
	local pos = self.Owner:GetPos() + ang:Forward()*45 + Vector(0,0,10);
	local checkingPlace = self:CheckPlace(pos);
	if not checkingPlace then return end;
	local shieldEnt = ents.Create("police_shield");
	shieldEnt:SetPos(pos);
	local tempAngle = self.Owner:GetAngles();
	shieldEnt:SetAngles(Angle(0,tempAngle.y,0));
	
	shieldEnt.canBeDestroyedByDamage = self.canBeDestroyedByDamage;
	shieldEnt.onlyExplosionDamage = self.onlyExplosionDamage;
	shieldEnt.currentHealth = self.defaultHealth;
	
	shieldEnt:Spawn();
	shieldEnt.Owner = self.Owner;

	self:Remove(); ]]
end



/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Network initialize && Client Receive
---------------------------------------------------------------------------------------------------------------------------------------------
*/

if SERVER then
	util.AddNetworkString("disable_shielddraw");
	util.AddNetworkString("shieldbash");
end

if CLIENT then
	net.Receive("disable_shielddraw",function()
		local weaponEntity = net.ReadEntity();
		local shieldProp = net.ReadEntity();
		if IsValid(shieldProp) then
			shieldProp:SetNoDraw(true);
		if IsValid(weaponEntity) then
			weaponEntity.shieldProp = shieldProp;
		end	
		end
	end)
	
	
net.Receive('shieldbash',function()
	local ply = net.ReadEntity();
	if not IsValid(ply) or not ply:IsPlayer() or not ply:Alive() then return end;
--[[ 	ply:AnimRestartGesture( GESTURE_SLOT_GRENADE,ACT_GMOD_GESTURE_MELEE_SHOVE_2HAND, true );
 ]]
    local elec = EffectData()
    elec:SetOrigin(ply:GetPos())
    elec:SetMagnitude(3)
end)
	
	
end

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Weapon dropped / replace world model
---------------------------------------------------------------------------------------------------------------------------------------------
*/
/*
 hook.Add("onDarkRPWeaponDropped","Police Shield",function(d2, ent, weapon)
	if weapon:GetClass() == "weapon_policeshield" then
		ent:SetModel("models/drover/w_shield.mdl");
	end
 end)
*/

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Player Death / delete our shields
---------------------------------------------------------------------------------------------------------------------------------------------
*/

-- Nicht mehr da

-- hook.Add("PlayerDeath","PlayerDeathDeleteShields",function(ply)
-- 	if deleteShieldsAfterDeath then
-- 		for k,v in pairs(ents.FindByClass("police_shield")) do
-- 			if v.Owner != nil and IsValid(v.Owner) and v.Owner == ply then
-- 				v:Remove();
-- 			end
-- 		end
-- 	end	
-- end)

hook.Add("OnPlayerChangedTeam","PlayerChangeTeamDeleteShields",function(ply)
    if deleteShieldsAfterDeath then
        for k,v in pairs(ents.FindByClass("police_shield")) do
            if v.Owner != nil and IsValid(v.Owner) and v.Owner == ply then
                v:Remove();
            end
        end
    end
end)

/* 
---------------------------------------------------------------------------------------------------------------------------------------------
				Reload && Deploy && Holster && Drop && Remove
---------------------------------------------------------------------------------------------------------------------------------------------
*/


function SWEP:ViewModelDrawn(viewmodel)
	if IsValid(self.shieldProp) and !self.shieldProp:GetNoDraw() then
		self.shieldProp:SetNoDraw(true);
	end
end

if CLIENT then
	local WorldModel = ClientsideModel(SWEP.WorldModel)

	-- Settings...
	WorldModel:SetSkin(1)
	WorldModel:SetNoDraw(true)


	function SWEP:DrawWorldModel()
		local _Owner = self:GetOwner()

		if (IsValid(_Owner)) then
			-- Specify a good position
			local offsetVec = Vector(8,2,-24)
			local offsetAng = Angle(-10,15,200)
			
			local boneid = _Owner:LookupBone("ValveBiped.Bip01_R_Hand") -- Right Hand
			if !boneid then return end

			local matrix = _Owner:GetBoneMatrix(boneid)
			if !matrix then return end

			local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())

			WorldModel:SetPos(newPos)
			WorldModel:SetAngles(newAng)

			WorldModel:SetupBones()
		else
			WorldModel:SetPos(self:GetPos())
			WorldModel:SetAngles(self:GetAngles())
		end

		WorldModel:DrawModel()
	end
end

function SWEP:Reload()

end

function SWEP:Deploy()
	self:SetHoldType("physgun"); 
	self:SetupShield();
	return true
end

function SWEP:Holster()
	if CLIENT then return end;
	if not IsValid(self.shieldProp) then return true end;
	self.shieldProp:Remove();
	if not IsValid(self.collProp) then return true end;
	self.collProp:Remove()
	return true;
end


function SWEP:OnDrop()
	if CLIENT then return end;
	if not IsValid(self.shieldProp) then return true end;
	self.shieldProp:Remove();
	if not IsValid(self.collProp) then return true end;
	self.collProp:Remove()
	return true;
end

function SWEP:OnRemove()
	if CLIENT then return end;
	if not IsValid(self.shieldProp) then return true end;
	self.shieldProp:Remove();
	if not IsValid(self.collProp) then return true end;
	self.collProp:Remove()
	return true;
end


--addons/weapon_jedi/lua/weapons/weapon_lscs/sh_stance_override.lua:

function SWEP:SetStance( stance )
	if isnumber( stance ) then
		self:SetNWStance( stance )
	else
		self:SetLockedCombo( stance  )
		self:SetNWStance( -1 )
	end
end

function SWEP:GetStance()
	return self:GetNWStance()
end

function SWEP:SetLockedCombo( name )
	local data = LSCS:GetStance( name )

	if data then
		self._lscsLockedCombo = name

		if SERVER then
			net.Start( "lscs_stance_override_networker" )
				net.WriteEntity( self )
				net.WriteString( name )
			net.Broadcast()
		end
	else
		self._lscsLockedCombo = nil
	end
end

if SERVER then
	util.AddNetworkString( "lscs_stance_override_networker" )

	function SWEP:GetLockedCombo()
		return self._lscsLockedCombo or "default"
	end

	net.Receive( "lscs_stance_override_networker", function( len, ply )
		local SWEP = net.ReadEntity()

		if not IsValid( SWEP ) then return end

		net.Start( "lscs_stance_override_networker" )
			net.WriteEntity( SWEP )
			net.WriteString( SWEP:GetLockedCombo() )
		net.Send( ply )
	end )
else
	function SWEP:GetLockedCombo()
		if not self._lscsComboRequested then -- only request once ( for fresh connected players )
			self._lscsComboRequested = true

			net.Start( "lscs_stance_override_networker" )
				net.WriteEntity( self )
			net.SendToServer()
		end

		return self._lscsLockedCombo or "default"
	end

	net.Receive( "lscs_stance_override_networker", function( len )
		local SWEP = net.ReadEntity()
		if not IsValid(SWEP) then return end

        local stance = net.ReadString()
        if not LSCS:GetStance(stance) then return end

        if isfunction(SWEP.SetLockedCombo) then
		    SWEP:SetLockedCombo(stance)
        end
	end)
end

--addons/aoc_nextbots/lua/weapons/weapon_npc_westar35.lua:
AddCSLuaFile()

SWEP.Base   = "weapon_summes_npcbase"

SWEP.PrintName = "NPC: Westar35 Rifle"
SWEP.Spawnable = false
SWEP.Author = "Deltaa"

SWEP.WorldModel = "models/arccw/sw_battlefront/weapons/westar_35_rifle.mdl"
SWEP.Weight = 3

SWEP.NextShoot = 0.3
SWEP.Damage = 30
SWEP.Tracer = "effect_npc_laser_red"
SWEP.ImpactEffect = "rw_sw_impact_red"
SWEP.Sound = "everfall/weapons/dlt-19d/blasters_dlt19d_laser_close_var_01.mp3"
SWEP.ClipSize = 30
SWEP.Spread = 0.2


--addons/weapons_other/lua/entities/anim_gmantele.lua:
AddCSLuaFile()

DEFINE_BASECLASS("base_anim")

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false
ENT.Author = "Axel"
ENT.DoNotDuplicate = true
ENT.PhysgunDisabled = true
ENT.AutomaticFrameAdvance = true
ENT.WorldModel = "models/weapons/w_suitcase_passenger.mdl"
ENT.RenderGroup = RENDERGROUP_BOTH

ENT.OpenSound = "doors/metal_move1.wav"
ENT.CloseSound = "doors/door_metal_rusty_move1.wav"
ENT.FullyOpen = "doors/door_metal_thin_open1.wav"


function ENT:SetupDataTables()
	self:NetworkVar("Float", 0, "EndDoorTime")
	self:NetworkVar("Bool", 1, "Close")
	self:NetworkVar("Vector", 0, "PlayerColor")
end

if SERVER then
	function ENT:Initialize()
		BaseClass.Initialize(self)
		self:ResetSequence("idle_all_01")
		self:SetEndDoorTime(CurTime() + 2)
	end

	function ENT:Think()
		BaseClass.Think(self)
		if not self.StartWalking and self:GetEndDoorTime() < CurTime() then
			self:ResetSequence("walk_suitcase")
			self.StartWalking = CurTime() + 2.1
			self:SetVelocity(self:GetForward() * 30)
			self:SetMoveType(MOVETYPE_NOCLIP)
			self:SetPoseParameter("move_x", 0.5)
		elseif self.StartWalking and self.StartWalking < CurTime() and not self.ClosingDoor then
			self:SetEndDoorTime(CurTime() + 1)
			self.ClosingDoor = true
			SafeRemoveEntityDelayed(self, 2)
		end

		self:NextThink(CurTime())
		return true
	end

	function ENT:UpdateTransmitState()
		return TRANSMIT_ALWAYS
	end
end

if CLIENT then
	local function DrawWall(pos, angle, width, height, color)
		if width < 0 or height < 0 then return end
		render.SetColorMaterial()
		render.DrawQuad(
			LocalToWorld(Vector( 0, -height, 0 ), angle_zero, pos, angle),
			LocalToWorld(Vector( 0, 0, 0 ), angle_zero, pos, angle),
			LocalToWorld(Vector( width, 0, 0 ), angle_zero, pos, angle),
			LocalToWorld(Vector( width, -height, 0 ), angle_zero, pos, angle),
			color or COLOR_WHITE
		)
	end

	function ENT:Initialize()
		self:SetIK(false)
		self:DrawShadow(false)
		if not IsValid(self.ClientModel) then
			self.ClientModel = ClientsideModel(self.WorldModel)
			self.ClientModel:SetNoDraw(true)
		end
	end

	function ENT:Think()
		BaseClass.Think(self)

		self:SetNextClientThink(CurTime())
		self:SetRenderBounds(Vector(-16, -16, 0), Vector(16, 16, 64), Vector(75, 75, 75))
		return true
	end

	function ENT:OnRemove()
		if IsValid(self.ClientModel) then
			self.ClientModel:Remove()
		end
	end

	function ENT:DrawTranslucent()
		self:DrawShadow(false)
		if self:GetEndDoorTime() == 0 and not self.DPos or not self.StartTime then
			self.DPos = util.QuickTrace(self:GetPos() + self:GetUp() * 2, self:GetForward() * 41, function() return false end).HitPos - self:GetForward()
			self.StartTime = CurTime()
			self:EmitSound(self.OpenSound)
			return
		end

		local pos, ang = self.DPos, self:GetForward():Angle()
		ang:RotateAroundAxis(ang:Up(), 180)
		local dang = self:GetForward():Angle()
		dang:RotateAroundAxis(dang:Up(), 180)
		dang:RotateAroundAxis(dang:Right(), - 90)
		dang:RotateAroundAxis(dang:Up(), 90)

		if self:GetEndDoorTime() < CurTime() and not self.CloseLatch then
			self.CloseLatch = true
			self:EmitSound(self.FullyOpen)
		elseif self.CloseLatch and self:GetEndDoorTime() > CurTime() and not self.Close then
			self.Close = true
			self.StartTime = CurTime()
			self:EmitSound(self.CloseSound)
		end

		local dur, elapsed = self:GetEndDoorTime() - self.StartTime, CurTime() - self.StartTime
		local per = math.Clamp(elapsed / dur, 0, 1)


		render.SetStencilEnable(true)
		render.ClearStencil()
		render.SetStencilTestMask(255)
		render.SetStencilWriteMask(255)

		render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
		render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
		render.SetStencilFailOperation(STENCILOPERATION_KEEP)
		render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_ALWAYS)
		render.SetStencilReferenceValue(1)

		per = (not self.Close and per or (1 - per))
		DrawWall(pos + ang:Right() * 25 + ang:Up() * 100 * per - Vector(0, 0, 1), dang, 50, 100 * per)

		local oldclip = render.EnableClipping(true)
		render.PushCustomClipPlane(-self:GetForward(), -self:GetForward():Dot(self.DPos))

		render.SetStencilReferenceValue(0)
		self:DrawModel()
		self:DrawBriefcase()

		render.PopCustomClipPlane()

		render.SetStencilReferenceValue(1)
		render.SetStencilPassOperation(STENCILOPERATION_KEEP)
		render.SetStencilFailOperation(STENCILOPERATION_KEEP)
		render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
		render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)

		render.SuppressEngineLighting(true)
		render.ResetModelLighting(0, 0, 0)
		render.SetLocalModelLights(
			{
				{
					type = MATERIAL_LIGHT_SPOT,
					color = Vector(0.6, 0.6, 0.6),
					pos = self:GetPos() + self:GetForward() * 120 + self:GetUp() * 64,
					dir = -self:GetForward(),
					outerAngle = 90,
					linearFalloff = true,
				}
			}
		)

		render.PushCustomClipPlane(self:GetForward(), self:GetForward():Dot(self.DPos))
		render.DepthRange( 0, 0.1 )
		self:DrawModel()
		self:DrawBriefcase()
		render.DepthRange( 0, 1 )

		render.PopCustomClipPlane()
		render.SuppressEngineLighting(false)
		render.EnableClipping(oldclip)
		render.SetStencilEnable(false)

		dang:RotateAroundAxis(self:GetUp(), 180)
		DrawWall(pos - ang:Right() * 25 + ang:Up() * 100 * per - Vector(0, 0, 1), dang, 50, 100 * per)

	end

	function ENT:Draw()
		self:DrawTranslucent()
	end

	local offsetVec = Vector(5, -1, 0)
	local offsetAng = Angle(-90, 0, 0)
	function ENT:DrawBriefcase()
		local boneid = self:LookupBone("ValveBiped.Bip01_R_Hand") -- Right Hand
		if not boneid or not IsValid(self.ClientModel) then return end

		local matrix = self:GetBoneMatrix(boneid)
		if not matrix then return end

		local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())

		self.ClientModel.IsBrief = true
		self.ClientModel:SetPos(newPos)
		self.ClientModel:SetAngles(newAng)
		self.ClientModel:DrawModel()
	end
end
--gamemodes/starwarsrp/entities/entities/aoc_fahrzeugmarker.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Fahrzeugspawn"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP - Spawns"
ENT.Spawnable       = true
ENT.Editable        = true
if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/maxofs2d/cube_tool.mdl" )
        self:DrawShadow( false )

        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_NONE)
        self:SetSolid(SOLID_VPHYSICS)
        self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
    end

end

function ENT:SetupDataTables()

	self:NetworkVar( "String", 0, "PlatformName", { KeyName = "platformname",	Edit = { type = "Generic",	order = 1} } ) 
	self:NetworkVar( "Bool", 0, "PublicSpawner", { KeyName = "publicspawner",	Edit = { type = "Boolean",	order = 1} } ) 

	if SERVER then
		self:SetPlatformName("Unbekannt")
        self:SetPublicSpawner(false)
	end
end

if CLIENT then
    function ENT:Draw()
        if LocalPlayer():GetMoveType() == MOVETYPE_NOCLIP then
            self:DrawModel() 

            if LocalPlayer():GetPos():DistToSqr(self:GetPos()) < 1000*1000 then
                render.DrawWireframeBox( self:GetPos(), self:GetAngles(), Vector( -200, -200, -200 ), Vector( 200, 200, 200 ), Color(200,0,0,200) ) -- draws the box 
            end
        end
    end

end
--gamemodes/starwarsrp/entities/entities/aoc_gearmarker.lua:
AddCSLuaFile()


ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName		= "Spawn (Gear)"
ENT.Author			= "Lt. Sammy"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Category        = "AOCRP - Spawns"
ENT.Spawnable       = true
ENT.Editable = true

if SERVER then
        
    function ENT:Initialize()

        self:SetModel( "models/hunter/plates/plate1x1.mdl" )
        self:DrawShadow( false )
        self:SetColor(Color(0,0,255))
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_NONE)
        self:SetSolid(SOLID_VPHYSICS)
        self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
    end

end



function ENT:SetupDataTables()

    local editTbl = {}


    if SERVER then
        

        for k, v in pairs(AOCRP.Gear.Data) do
            local unit = AOCRP.Units[v.unitid].prefix
            editTbl[unit.."#"..v.name] = v.gearid
        end
    end

    if CLIENT then
    
        if AOCRP.Gears then
            for k, v in pairs(AOCRP.Gears) do
                local unit = AOCRP.Units[v.unitid].prefix
                editTbl[unit.."#"..v.name] = v.gearid
            end  
        end
    end

	self:NetworkVar( "Int", 0, "GearSpawn", { KeyName = "gearspawn",	Edit = { type = "Combo", order = 1, text = "", values=editTbl} } ) 

	if SERVER then
		self:SetGearSpawn(1)
	end
end

if CLIENT then

    function ENT:Draw()
        if LocalPlayer():GetMoveType() == MOVETYPE_NOCLIP then
            self:DrawModel() 
        end
    end

end
--gamemodes/starwarsrp/entities/entities/aoc_sicherheitslevel.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Category = "AOCRP"
ENT.PrintName = "Sicherheitslevel"
ENT.Author = "Lt. Sammy"
ENT.Spawnable = true
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.Editable = true

function ENT:SetupDataTables()


    local editTbl = {}

    for k, v in pairs(AOCRP.Config.Sicherheitslevel) do
        editTbl[v.name] = k
    end
    
	self:NetworkVar( "Int", 0, "Sicherheitslevel", { KeyName = "sicherheitslevel",	Edit = { type = "Combo", order = 1, text = "", values=editTbl} } ) 
    self:NetworkVar("String", 1, "Bereichsname", { KeyName = "bereichsname",	Edit = { type = "Generic",	order = 1 } } )
    self:NetworkVar("Float", 1, "ScreenScale", { KeyName = "screenscale",	Edit = { type = "Float",	order = 1, min = 0.05, max = 1} } )
end

if SERVER then

    
    function ENT:Initialize()
        self:SetRenderMode(RENDERMODE_TRANSALPHA)
        self:DrawShadow(false)
        self:SetModel("models/hunter/plates/plate1x1.mdl")
        self:SetMaterial("models/effects/vol_light001")
        self:SetSolid(SOLID_VPHYSICS)
        self:SetCollisionGroup(COLLISION_GROUP_WORLD)
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        local phys = self:GetPhysicsObject()
        if IsValid(phys) then
            phys:EnableMotion(false)
        end
        self.heldby = 0
    end

    function ENT:PhysicsUpdate(phys)
        if self.heldby <= 0 then
            phys:Sleep()
        end
    end

    local function textScreenPickup(ply, ent)
        if IsValid(ent) and ent:GetClass() == "aoc_sicherheitslevel" then
            ent.heldby = ent.heldby + 1
        end
    end
    hook.Add("PhysgunPickup", "AOCRPSLPreventTravelPickup", textScreenPickup)

    local function textScreenDrop(ply, ent)
        if IsValid(ent) and ent:GetClass() == "aoc_sicherheitslevel" then
            ent.heldby = ent.heldby - 1
            local phys = ent:GetPhysicsObject()
            if IsValid(phys) then
                ent:PhysicsUpdate(phys)
            end
        end
    end
    hook.Add("PhysgunDrop", "AOCRPSLPreventTravelDrop", textScreenDrop)

end

if CLIENT then
    function ENT:Initialize()
        self:SetMaterial("models/effects/vol_light001")
        self:SetRenderMode(RENDERMODE_NONE)
    end


--[[     PIXEL.RegisterFont("AOCRP.Sicherheitslevel.Title", "Agency FB", 60, 10)
    PIXEL.RegisterFont("AOCRP.Sicherheitslevel.Text", "DermaLarge", 40, 1000)
    PIXEL.RegisterFont("AOCRP.Sicherheitslevel.Level", "Aurebesh", 60, 1)
 ]]
    surface.CreateFont( "AOCRP_Sicherheitslevel_Title", {font = "Agency FB",size = 60,weight = 10} )
    surface.CreateFont( "AOCRP_Sicherheitslevel_Text", {font = "DermaLarge",size = 40,weight = 1000} )
    surface.CreateFont( "AOCRP_Sicherheitslevel_Level", {font = "Aurebesh",size = 60,weight = 1} )

    local plyShootPos, ang, pos, camangle

    local w = 500
    local h = 500
    local linew = 300


    local function isAllowed(sleveldata)

        if LocalPlayer():GetRankID() >= sleveldata.rank then
            return true
        end
        if table.HasValue(sleveldata.units, LocalPlayer():GetUnitID()) then 
            return true 
        end
        return false
    end 

    local distance = 7
    function ENT:DrawTranslucent()
		ang = self:GetAngles()
		pos = self:GetPos()


        if LocalPlayer():GetPos():DistToSqr(pos) > distance^distance then return end 
        if !AOCRP.Config.Sicherheitslevel[self:GetSicherheitslevel()] then return end

        local scale = 0.15
        local SLevelData = AOCRP.Config.Sicherheitslevel[self:GetSicherheitslevel()]

        if self:GetScreenScale() > 0 then
            scale = self:GetScreenScale()
        end
        

		cam.Start3D2D(pos, ang, scale )

            draw.DrawText(SLevelData.text,"AOCRP_Sicherheitslevel_Level", 0,-120, Color(255,255,255,255),TEXT_ALIGN_CENTER)

            draw.DrawText(self:GetBereichsname(),"AOCRP_Sicherheitslevel_Title", 0,-65, Color(255,255,255),TEXT_ALIGN_CENTER)

            if isAllowed(SLevelData) then
                surface.SetDrawColor(0,160,0)

            else 
                surface.SetDrawColor(160,0,0)
                draw.DrawText("ZUTRITT VERBOTEN","AOCRP_Sicherheitslevel_Text", 0,9, Color(160,0,0),TEXT_ALIGN_CENTER)

            end
            surface.DrawRect(-linew/2,0,linew,5)

		cam.End3D2D()
        camangle = Angle(ang.p, ang.y, ang.r)
        newAng = camangle:RotateAroundAxis(camangle:Right(), 180)
		cam.Start3D2D(pos, camangle, scale )

            draw.DrawText(SLevelData.text,"AOCRP_Sicherheitslevel_Level", 0,AOCH(-120), Color(255,255,255,255),TEXT_ALIGN_CENTER)

            draw.DrawText(self:GetBereichsname(),"AOCRP_Sicherheitslevel_Title", 0, AOCH(-65), Color(255,255,255),TEXT_ALIGN_CENTER)

            if isAllowed(SLevelData) then
                surface.SetDrawColor(0,160,0)

            else 
                surface.SetDrawColor(160,0,0)
                draw.DrawText("ZUTRITT VERBOTEN","AOCRP_Sicherheitslevel_Text", 0, AOCH(9), Color(160,0,0),TEXT_ALIGN_CENTER)

            end
            surface.DrawRect(-linew/2,0,linew,AOCH(5))

		cam.End3D2D()
    end

end
--addons/aoc_nextbots/lua/entities/aocrp_nextbot_aqua.lua:
AddCSLuaFile()

ENT.Base = "summe_nextbot"
ENT.PrintName = "Aqua Battledroid"
ENT.Category = "AOCRP | Nextbots"
ENT.Spawnable = false
ENT.AdminOnly = false

ENT.Model = "models/valley/aquadroid/aquadroid.mdl"
ENT.Weapon = "weapon_npc_aqua"
ENT.HP = 400
ENT.ShootingRange = 1000
ENT.LooseRadius = 2000
ENT.Proficiency = .2

ENT.Melee = false
ENT.MeleeDamage = 25
ENT.MeleeDelay = 3

ENT.ThrowGrenades = false
ENT.Grenades = {"summe_gr_grenade"}

ENT.Scale = 1

ENT.Sounds = false

ENT.Anims = {
    ["idle"] = {"g_look"},
    ["shoot"] = {"shoot_ar2"},
    ["reload"] = {"reload_smg1"},
    ["walk_slow"] = {"walkholdall1"},
    ["walk_fast"] = {"runholdingall1"},
}

function ENT:OnNPCSpawn()
    self:PlayAnimation("idle", true)
end

if SERVER then
    ENT.AllowShooting = true

    function ENT:ShootEnemy()
        if not self.AllowShooting then return end

        local weapon = self:GetWeapon()
        local enemy = self:GetEnemy()
    
        if not IsValid(weapon) then return end
        if AOCRPNextbots:CannotTarget(enemy) then self:SetEnemy(false) return end
    
        weapon.LastEnemy = enemy
    
        if weapon:Clip1() > 0 then
            if self.IsReloading then return end
            self:PlayAnimation("shoot")
    
            if math.random(0, 100) > 98 then
                self:SpecialAbility()
                return
            end

            weapon:PrimaryAttack()

        else
            if self.IsReloading then return end
            self.IsReloading = true
            self:MakeSound("weapons/bf3/standard_reload2.ogg", 0)
            self:PlayAnimation("reload")
            timer.Simple(3, function()
                if not IsValid(weapon) then return end
                weapon:SetClip1(self.NormalWeaponClip)
                self.IsReloading = false
            end)
        end
    end

    util.AddNetworkString("SummeNextbots.Auqa.SpecialAbility")

    function ENT:SpecialAbility()
        self.AllowShooting = false

        self:EmitSound("aoc/nextbot/aqua/blasters_relby-v10_bossk_charge_var_02.mp3", 100, 100, 1, CHAN_WEAPON)

        timer.Simple(1, function()
            if not IsValid(self) then return end

            local ents_ = player.FindInSphere(self:EyePos(), self.ShootingRange)
            local weapon = self:GetWeapon()
            local entsCount = 0

            for k, v in RandomPairs(ents_) do
                local tr = util.TraceLine({
                    start = self:GetPos() + Vector(0, 0, 170),
                    endpos = v:HeadTarget(v:GetPos()) - Vector(0, 0, 10),
                    filter = {weapon, self},
                })
            
                if tr.Entity != v then
                    ents_[k] = nil
                    continue 
                end

                if hook.Run("SummeNextbot.CannotTarget", v, self) then
                    ents_[k] = nil
                    continue 
                end

                if entsCount > 5 then
                    ents_[k] = nil
                    continue
                end

                entsCount = entsCount + 1

                v:ScreenFade(SCREENFADE.IN, color_white, 1, 2)

                self:EmitSound("aoc/nextbot/aqua/blaster_iondisruptor_laser_addon_close_var_0".. math.random(4, 8).. ".mp3", 100, 100, 1, CHAN_WEAPON)
            end

            timer.Create("SummeNextbots.Auqa.SpecialAbDmg", 0.1, 10, function()
                for k, v in pairs(ents_) do
                    if not IsValid(v) or not v:Alive() then continue end
                    if not IsValid(self) then return end

                    local d = DamageInfo()
                    d:SetDamage(13)
                    d:SetAttacker(self)
                    d:SetDamageType(DMG_SHOCK) 

                    v:TakeDamageInfo(d)
                end
            end)

            net.Start("SummeNextbots.Auqa.SpecialAbility")
            net.WriteEntity(self)
            net.WriteTable(ents_)
            net.Broadcast()

            timer.Simple(3, function()
                if not IsValid(self) then return end

                self:EmitSound("aoc/nextbot/aqua/blasters_deathray_charge_start_var_01.mp3", 100, 100, 1, CHAN_WEAPON)
                self.AllowShooting = true
            end)
        end)
    end
end

if CLIENT then
    local colorRed = Color(150, 0, 0, 230)
    local colorGrey = Color(15, 15, 15, 230)
    local colorWhite = Color(255,255,255)
    local Laser = Material("cable/physbeam")
    local LaserSmall = Material("cable/blue_elec")
    local MaterialGlow = Material("sprites/light_glow02_add")
    local MaterialGlow2 = Material("sprites/blueflare1_noz_gmod")
    local ColorGlow = Color(0,217,255)
    local ColorGlow2 = Color(0,119,2555)

    net.Receive("SummeNextbots.Auqa.SpecialAbility", function(len)
        local nextbot = net.ReadEntity()
        local players = net.ReadTable()

        nextbot.targets = players
        nextbot.specialthing = true

        timer.Simple(1, function()
            if not IsValid(nextbot) then return end

            nextbot.specialthing = false
        end)
    end)

    function ENT:Draw()
        self:DrawModel()

        if self.specialthing then
            local pos = self:GetPos() + Vector(0, 0, 170)

            local Vector1 = self:LocalToWorld( Vector( 0, 0, 50 ) )
            local Vector2 = self:LocalToWorld( Vector( 0, 0, 165 ) ) 
            render.SetMaterial( Laser )
            render.DrawBeam( Vector1, Vector2, 40, 1, 2, Color( 255, 255, 255, 255 ) ) 

            render.SetMaterial(MaterialGlow)
            render.DrawSprite(Vector2, 200, 200, ColorGlow)

            render.SetMaterial(MaterialGlow2)
            render.DrawSprite(Vector2, 20, 20, ColorGlow2)

            for k, v in pairs(self.targets) do
                if not IsValid(v) or not v:Alive() then continue end

                local randVec = v:GetPos() + Vector(0, 0, math.random(0, 80))

                render.SetMaterial(LaserSmall)
                render.DrawBeam(pos, randVec, 10, 1, 5, color_white)

                render.SetMaterial(MaterialGlow)
                render.DrawSprite(randVec, 50, 50, ColorGlow)
            end
        end
    end
end
--addons/aoc_nextbots/lua/entities/aocrp_nextbot_combine.lua:
AddCSLuaFile()

ENT.Base = "summe_nextbot"
ENT.PrintName = "Benjamin Heuer"
ENT.Category = "AOCRP | Nextbots"
ENT.Spawnable = false
ENT.AdminOnly = false

ENT.Model = "models/Combine_Soldier.mdl"
ENT.Weapon = "weapon_npc_ee3"
ENT.HP = 400
ENT.ShootingRange = 2000
ENT.LooseRadius = 4000
ENT.Proficiency = .05

ENT.Melee = true
ENT.MeleeDamage = 25
ENT.MeleeDelay = 3

ENT.ThrowGrenades = true
ENT.Grenades = {"summe_gr_impact"}

ENT.Sounds = {}

ENT.Anims = {
    ["idle"] = {"idle1"},
    ["shoot"] = {"shootar2alt"},
    ["reload"] = {"reload"},
    ["walk_slow"] = {"walk_all"},
    ["walk_fast"] = {"runaimall1_sg"},
    ["melee"] = {"meleeattack01"},
}

function ENT:OnNPCSpawn()
    self:PlayAnimation("idle")
end
--addons/arccw_base_modified/lua/entities/arccw_ammo_ar2.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"
ENT.RenderGroup               = RENDERGROUP_TRANSLUCENT

ENT.PrintName                 = "Rifle Ammo"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/rifle_ammo.mdl"

ENT.AmmoType = "ar2"
ENT.AmmoCount = 30

ENT.DetonationDamage = 50
ENT.DetonationRadius = 256
ENT.DetonationSound = "weapons/ar1/ar1_dist2.wav"
--addons/arccw_weapons/lua/entities/arccw_rocket_tandem/shared.lua:
ENT.Type 				= "anim"
ENT.Base 				= "base_entity"
ENT.PrintName 			= "RPG-7 Tandem Round"
ENT.Author 				= ""
ENT.Information 		= ""

ENT.Spawnable 			= false


AddCSLuaFile()

ENT.Model = "models/items/ar2_grenade.mdl"
ENT.Ticks = 0
ENT.FuseTime = 4.5

if SERVER then

function ENT:Initialize()
    local pb_vert = 1
    local pb_hor = 1
    self:SetModel(self.Model)
    self:PhysicsInitBox( Vector(-pb_vert,-pb_hor,-pb_hor), Vector(pb_vert,pb_hor,pb_hor) )

    local phys = self:GetPhysicsObject()
    if phys:IsValid() then
        phys:Wake()
        phys:EnableGravity(false)
    end

    self.SpawnTime = CurTime()
    self.motorsound = CreateSound( self, "weapons/rpg/rocket1.wav")
    self.motorsound:Play()

    timer.Simple(0.1, function()
        if !IsValid(self) then return end
        self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)
    end)
end

function ENT:Think()
    if SERVER and CurTime() - self.SpawnTime >= self.FuseTime then
        self:Detonate()
    end
end

function ENT:OnRemove()
    self.motorsound:Stop()
end

end

function ENT:Think()
    if SERVER then
        local phys = self:GetPhysicsObject()
        phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )

        if self.SpawnTime + self.FuseTime <= CurTime() then
            self:Detonate()
        end
    else
        if self.Ticks % 5 == 0 then
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end
            if !IsValid(emitter) then return end

            local smoke = emitter:Add("particle/particle_smokegrenade", self:GetPos())
            smoke:SetVelocity( VectorRand() * 25 )
            smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
            smoke:SetDieTime( math.Rand(1.5, 2.0) )
            smoke:SetStartAlpha( 255 )
            smoke:SetEndAlpha( 0 )
            smoke:SetStartSize( 0 )
            smoke:SetEndSize( 100 )
            smoke:SetRoll( math.Rand(-180, 180) )
            smoke:SetRollDelta( math.Rand(-0.2,0.2) )
            smoke:SetColor( 20, 20, 20 )
            smoke:SetAirResistance( 5 )
            smoke:SetPos( self:GetPos() )
            smoke:SetLighting( false )
            emitter:Finish()
        end

        self.Ticks = self.Ticks + 1
    end
end

function ENT:Detonate()
    if !self:IsValid() then return end
    local effectdata = EffectData()
        effectdata:SetOrigin( self:GetPos() )

    if self:WaterLevel() >= 1 then
        util.Effect( "WaterSurfaceExplosion", effectdata )
        self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
    else
        util.Effect( "Explosion", effectdata)
        self:EmitSound("phx/kaboom.wav", 125, 100, 1, CHAN_AUTO)
    end

    local attacker = self

    if self.Owner:IsValid() then
        attacker = self.Owner
    end

    util.BlastDamage(self, attacker, self:GetPos(), 64, 1500)

    self:FireBullets({
        Attacker = attacker,
        Damage = 0,
        Tracer = 0,
        Distance = 20000,
        Dir = self:GetVelocity(),
        Src = self:GetPos(),
        Callback = function(att, tr, dmg)
            util.Decal("Scorch", tr.StartPos, tr.HitPos - (tr.HitNormal * 16), self)
        end
    })

    self:Remove()
end

function ENT:PhysicsCollide(colData, collider)
    self:Detonate()
end

function ENT:Draw()
    cam.Start3D() -- Start the 3D function so we can draw onto the screen.
        render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
        render.DrawSprite( self:GetPos(), math.random(100, 200), math.random(100, 200), Color(255, 255, 255) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
    cam.End3D()
end
--lua/entities/d_sidious_chair.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "base_anim"
ENT.Type = "vehicle"

ENT.PrintName = "Darth Sidious Chair"
ENT.Author = "Syphadias, Liam0102s Help"
ENT.Category = "Star Wars Vehicles: Chairs"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;
ENT.EntModel = "models/starwars/syphadias/props/d_sidious_chair/d_sidious_chair.mdl";

list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then



AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("d_sidious_chair");
	e:SetPos(tr.HitPos + Vector(0,0,20));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()

	self:SetModel(self.EntModel);
	self:PhysicsInit(SOLID_VPHYSICS);
	self:SetMoveType(MOVETYPE_VPHYSICS);
	self:SetSolid(SOLID_VPHYSICS);
	self:StartMotionController();
	self:SetUseType(SIMPLE_USE);
	self:SetRenderMode(RENDERMODE_TRANSALPHA);

	self:SecretChair(self:GetPos()+self:GetUp()*16+self:GetForward()*1,self:GetAngles()+Angle(0,-90,8)); // Will most likely require tinkering for position
	
	local phys = self:GetPhysicsObject()

	if(phys:IsValid()) then
		phys:Wake()
		phys:SetMass(100000)
	end
end

function ENT:SecretChair(pos,ang)

	local e = ents.Create("prop_vehicle_prisoner_pod");
	e:SetPos(pos);
	e:SetAngles(ang);
	e:SetParent(self);
	e:SetModel("models/nova/airboat_seat.mdl");
	e:SetRenderMode(RENDERMODE_TRANSALPHA);
	e:SetColor(Color(255,255,255,0));
	e:Spawn();
	e:Activate();
	e.IsSyphSeat = true;
	self.Chair = e;
end

hook.Add("PlayerEnteredVehicle","SyphSeatEnter", function(p,v)
	if(IsValid(p) and IsValid(v)) then
		if(v.IsSyphSeat) then
			p:SetNWEntity("SyphSeat",v)
		end
	end
end)

hook.Add("PlayerLeaveVehicle","SyphSeatExit", function(p,v)
	if(IsValid(p) and IsValid(v)) then
		if(v.IsSyphSeat) then
			p:SetNWEntity("SyphSeat",NULL)
		end
		p:SetPos(v:GetPos()+v:GetUp()*10+v:GetForward()*52)
		p:SetEyeAngles(Angle(0,v:GetAngles().y+90,0))
	end
end)

function ENT:Use(p)
	
	if(!IsValid(self.Chair)) then return end;
	p:EnterVehicle(self.Chair);

end

end

if CLIENT then
	
	function ENT:Draw() self:DrawModel() end
	
	local View = {}
	hook.Add("CalcView", "SyphSeatView", function()

		local p = LocalPlayer();
		local Seat = p:GetNWEntity("SyphSeat",NULL);

		if(IsValid(Seat)) then
			if(Seat:GetThirdPersonMode()) then
				local pos = Seat:GetPos()+LocalPlayer():GetAimVector():GetNormal()*-100+Seat:GetUp()*175;
				local face = ((Seat:GetPos() + Vector(0,0,100))- pos):Angle();
					View.origin = pos;
					View.angles = face;
				return View;
			end
		end
	end)
	
	hook.Add( "ShouldDrawLocalPlayer", "SyphSeatPlayerDraw", function( p )
		local Seat = p:GetNWEntity("SyphSeat",NULL);
		if(IsValid(Seat)) then
			if(Seat:GetThirdPersonMode()) then
				return true;
			end
		end
	end);
end
--gamemodes/starwarsrp/entities/entities/ent_climbform/shared.lua:
--Made by MrRangerLP

AddCSLuaFile("shared.lua")

ENT.Base 				= "base_gmodentity"
ENT.Type 				= "anim"
ENT.Category 			= "AOCRP"

ENT.PrintName 			= "Kletterbox"
ENT.Author				= "MrRangerLP (Meteor)"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false
ENT.DisableDuplicator 	= true
ENT.DoNotDuplicate 		= true

util.PrecacheModel("models/props_junk/wood_crate001a.mdl")

if CLIENT then
	local AngleConstant1 = Angle(-180,90,-90)
	local AngleConstant2 = Angle(-180,-90,-90)
	local AngleConstant3 = Angle(0,-180,90)
	local AngleConstant4 = Angle(0,0,90)

	local ColorOrangeIsh = Color(255,191,0)
	local ColorWhite = Color(255,255,255)
	local ColorVeryDarkGrey = Color(16,16,16)
	local ColorMisc = Color(33,200,0,255)

	local Me
	local UndecorateNick = UndecorateNick or function(Str) return Str end -- Metastruct and general markup compatibility

	function ENT:TextPosInit()
		self.TextPosAngles = {
			self:GetPos() + (self:GetUp() * 1) + (self:GetForward() * -21), self:GetAngles() + AngleConstant1,
			self:GetPos() + (self:GetUp() * 1) + (self:GetForward() * 21), self:GetAngles() + AngleConstant2,
			self:GetPos() + (self:GetUp() * 1) + (self:GetRight() * -21), self:GetAngles() + AngleConstant3,
			self:GetPos() + (self:GetUp() * 1) + (self:GetRight() * 21), self:GetAngles() + AngleConstant4
		}
	end

	function ENT:Initialize()
		self:TextPosInit()
		self.Text = "Climbgame"
		self.LastPos = self:GetPos()
		self.LastAng = self:GetAngles()
	end

	function ENT:Draw()
		self:DrawModel()

		self.SharedOwner = self:GetNWEntity("SharedOwner")
		self.ClimbCountC = self:GetNWInt("Climbcount",0)

		if not IsValid(self.SharedOwner) and (self:GetPos() ~= self.LastPos or self:GetAngles() ~= self.LastAng) then -- The entity can still be picked up so we need to update the textpos constantly
			self:TextPosInit()
			self.LastPos = self:GetPos()
			self.LastAng = self:GetAngles()
		end

		if self.Text == "Climbgame" and IsValid(self.SharedOwner) then
			self.Text = UndecorateNick(self.SharedOwner:Nick())
			Me = LocalPlayer() == self.SharedOwner and self.SharedOwner
		end

		for k = 1,#self.TextPosAngles,2 do
			cam.Start3D2D(self.TextPosAngles[k],self.TextPosAngles[k + 1],0.1)
				draw.SimpleTextOutlined(self.Text,"DermaLarge",0,-30,ColorOrangeIsh,TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER,2,ColorVeryDarkGrey)

				--print(self.ClimbCountC)
				if self.ClimbCountC > 0 then
					draw.SimpleTextOutlined("Fortschritt: " .. tostring(self.ClimbCountC) .. " " .. "box" .. (self.ClimbCountC > 1 and "es" or ""),"DermaLarge",0,30,ColorMisc,TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER,2,ColorVeryDarkGrey)
				end
			cam.End3D2D()
		end
	end

	function ENT:Think()
		if (self:GetNWBool("Fell") or self:GetNWBool("GameFinished")) and IsValid(self.SharedOwner) and self.SharedOwner == Me then
			local Count = self:GetNWInt("Climbcount")
			local CountStr = "" .. tostring(Count) -- For some reason we have to append this to a string, otherwise it will be invisible in the valve chatbox

			if Count > 0 then -- Do not display any text if we didn't even climb a single box. (Yes, this is possible to trigger)
				if self:GetNWBool("Fell") then
					chat.AddText(ColorWhite,"[",ColorOrangeIsh,"Kletterspiel",ColorWhite,"]: Du hast ",ColorOrangeIsh,CountStr,ColorWhite," boxen geschafft!")
				end

				if self:GetNWBool("GameFinished") then
					chat.AddText(ColorWhite,"[",ColorOrangeIsh,"Kletterspiel",ColorWhite,"]: Du hast es bis zum Ende geschafft! Highscore ",ColorOrangeIsh,CountStr,ColorWhite," boxen!")
				end
			end

			self:SetNextClientThink(CurTime() + 100000) -- We only want this to be displayed once. This method is better than using a variable
			return true
		end
	end
end
--addons/arccw_weapons/lua/entities/ent_rw_rocket/shared.lua:
ENT.Type 			= "anim"  
ENT.PrintName			= "CW Rocket"  
ENT.Spawnable			= false
ENT.AdminSpawnable		= false

local rSound = Sound("Missile.Accelerate")

if SERVER then

AddCSLuaFile( "shared.lua" )

function ENT:Initialize()   

self.flightvector = self.Entity:GetForward() * ((30*15.5)/5)
self.timeleft = CurTime() + 15
self.Owner = self:GetOwner()
self.Entity:SetModel( "models/sw_battlefront/weapons/rocketprojectile.mdl" )
self.Entity:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,  	
self.Entity:SetMoveType( MOVETYPE_NONE )   --after all, gmod is a physics  	
self.Entity:SetSolid( SOLID_VPHYSICS )        -- CHEESECAKE!    >:3     
self.Entity:EmitSound(rSound, 75, 100)

--self.Entity:SetColor(Color(128 255 0,255))

Glow = ents.Create("env_sprite")
Glow:SetKeyValue("rendercolor","255, 255, 255")
Glow:SetKeyValue("scale","1")
Glow:SetPos(self.Entity:GetPos())
Glow:SetParent(self.Entity)
Glow:Spawn()
Glow:Activate()
self.Entity:SetNWBool("smoke", 10, true)

end   

 function ENT:Think()

		if self.timeleft < CurTime() then
		self.Entity:Remove()
		end

	Table	={} 			//Table name is table name
	Table[1]	=self.Owner 		//The person holding the gat
	Table[2]	=self.Entity 		//The cap

	local trace = {}
		trace.start = self.Entity:GetPos()
		trace.endpos = self.Entity:GetPos() + self.flightvector
		trace.filter = Table
	local tr = util.TraceLine( trace )
	

		if tr.HitSky then
			self.Entity:Remove()
			return true
		end
	
		if tr.Hit then
				local effectdata = EffectData()
					effectdata:SetOrigin(tr.HitPos)			// Where is hits
					effectdata:SetNormal(tr.HitNormal)		// Direction of particles
					effectdata:SetEntity(self.Entity)		// Who done it?
					effectdata:SetScale(2)			        // Size of explosion
					effectdata:SetRadius(tr.MatType)		// What texture it hits
					effectdata:SetMagnitude(18)			    // Length of explosion trails
					util.Effect( "rw_rocket_explosion", effectdata )
					util.BlastDamage(self.Entity, self:OwnerGet(), tr.HitPos, 450, 1000)
					util.Decal("Scorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)
					self.Entity:SetNWBool("smoke", false)
					
			self:Explosion()
			self.Entity:Remove()	
		end
	
	self.Entity:SetPos(self.Entity:GetPos() + self.flightvector)
	self.flightvector = self.flightvector - (self.flightvector/1500)  + Vector(math.Rand(-0.2,0.2), math.Rand(-0.2,0.2),math.Rand(-0.2,0.2)) + Vector(0,0,-0.05)
	self.Entity:SetAngles(self.flightvector:Angle() + Angle(0,0,0))
	self.Entity:NextThink( CurTime() )
	return true
	
end
 
 function ENT:Explosion()

	self:EmitSound("BaseExplosionEffect.Sound", 500, 100)	
	self.Entity:StopSound(rSound)

	local shake = ents.Create("env_shake")
		shake:SetOwner(self.Owner)
		shake:SetPos(self.Entity:GetPos())
		shake:SetKeyValue("amplitude", "2000")	// Power of the shake
		shake:SetKeyValue("radius", "900")		// Radius of the shake
		shake:SetKeyValue("duration", "2.5")	// Time of shake
		shake:SetKeyValue("frequency", "1225")	// How har should the screenshake be
		shake:SetKeyValue("spawnflags", "4")	// Spawnflags(In Air)
		shake:Spawn()
		shake:Activate()
		shake:Fire("StartShake", "", 0)
	
	local ar2Explo = ents.Create("env_fire")
		ar2Explo:SetOwner(self.Owner)
		ar2Explo:SetPos(self.Entity:GetPos())
		ar2Explo:Spawn()
		ar2Explo:Activate()
		ar2Explo:Fire("Explode", "", 0)

end

function ENT:OwnerGet()
	if IsValid(self.Owner) then
		return self.Owner
	else
		return self.Entity
	end
end

end

if CLIENT then
 function ENT:Draw()             
 	self.Entity:DrawModel()       // Draw the model.   
 end
 
   function ENT:Initialize()
	pos = self:GetPos()
	self.emitter = ParticleEmitter( pos )
 end
 
 function ENT:Think()
	if (self.Entity:GetNWBool("smoke")) then
	pos = self:GetPos()
		for i=1, (1) do
			local particle = self.emitter:Add( "particle/smokesprites_000"..math.random(1,9), pos + (self:GetForward() * -10 * i))
			if (particle) then
				particle:SetVelocity((self:GetForward() * -400)+(VectorRand()* 10) )
				particle:SetDieTime( math.Rand( 10, 5 ) )
				particle:SetStartAlpha( math.Rand( 85, 115 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand( 10, 1 ) )
				particle:SetEndSize( 1 )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-1, 1) )
				particle:SetColor( 115 , 115 , 115 ) 
 				particle:SetAirResistance( 200 ) 
 				particle:SetGravity( Vector( 100, 0, 0 ) ) 	
			end
		
		end
	end
end
end
--addons/tools/lua/entities/heart_turbolaser/shared.lua:
ENT.Type = "anim";
ENT.Base = "base_anim";
ENT.PrintName = "heart_turbolaser";
ENT.Author = "drunken hearted";

ENT.Spawnable = false;

function ENT:SetupDataTables()
	self:NetworkVar( "String", "0", "ColR" );
	self:NetworkVar( "String", "1", "ColG" );
	self:NetworkVar( "String", "2", "ColB" );

	self:NetworkVar("Float", "0", "Scale");
end

--addons/joes_stuff/lua/entities/joe_cable/cl_init.lua:
include('shared.lua')

function ENT:GetColorScheme()
	return BombSystem.presets[BombSystem.preset][self:GetUnPresetColor()]
end

function ENT:Draw()
	-- if BombSystem.preset then
	-- 	self:SetColor(self:GetColorScheme())
		if LocalPlayer():GetEyeTrace().Entity == self then
			local ang = (LocalPlayer():GetPos() - self:GetPos()):Angle()
			ang.y = ang.y - 272
			ang.p = 0
			ang.r = 90
			cam.Start3D2D(self:GetPos() + Vector(0,0,10), ang, 0.1)
				draw.SimpleText(self:GetUnPresetColor() or "ERROR", "DermaLarge", 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			cam.End3D2D()
		end
	-- end

	self:DrawModel()
end
--addons/weapon_joe_fort/lua/entities/joefort_ressource_100/shared.lua:
ENT.Type = "anim"
ENT.Base = "joefort_ressource_base"
 
ENT.PrintName = "Resource Crate"
ENT.Author  = "Joe"
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.Category = "JoeFort"

ENT.Ressourceamount = 100
ENT.model = "models/Items/item_item_crate.mdl"
ENT.Destroyable = true
--lua/entities/laat_detonator/shared.lua:
ENT.Base            = "base_gmodentity"
ENT.Type            = "anim"

ENT.PrintName       = "Detonator"
ENT.Author          = "!Ben"
ENT.Information     = ""
ENT.Category        = "[LFS] - Star Wars Pack"

ENT.Spawnable		= false
ENT.AdminSpawnable	= false

game.AddParticles("particles/gb5_100lb.pcf")
PrecacheParticleSystem("100lb_ground")
--addons/lvs_addons/lua/entities/lunasflightschool_niksacokica_tx-427/shared.lua:

ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "TX-427"
ENT.Author = "kavtehman and xn"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/lfs_vehicles/tx427/tx427_static.mdl"
ENT.GibModels = {
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 2

ENT.MaxHealth = 3500

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 250
ENT.MaxVelocityY = 180

ENT.MaxTurnRate = 0.5

ENT.BoostAddVelocityX = 120
ENT.BoostAddVelocityY = 120

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.TurretTurnRate = 100

ENT.RotorPos = Vector(-130, 0, 100)

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Entity", "CoDriver" )
	self:AddDT( "Entity", "CoSeat" )
	self:AddDT( "Float", "TurretPitch" )
	self:AddDT( "Float", "TurretYaw" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end
function ENT:OnIsCarried( name, old, new)
	if new == old then return end
	if new then
		self:SetPoseParameter("blasters_left_yaw", 0 )
		self:SetPoseParameter("blasters_left_pitch", 0 )

		self:SetPoseParameter("blasters_right_yaw", 0 )
		self:SetPoseParameter("blasters_right_pitch", 0 )
		
		self:SetPoseParameter("missiles_left_pitch", 0 )
		self:SetPoseParameter("missiles_right_pitch", 0 )
		self:SetDisabled( true )
	else
		self:SetDisabled( false )
	end
end

function ENT:GetEyeTrace()
	local startpos = self:GetPos()

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( Vector(0,0,33) )
	end

	local trace = util.TraceLine( {
		start = startpos,
		endpos = (startpos + self:GetAimVector() * 50000),
		filter = self:GetCrosshairFilterEnts()
	} )

	return trace
end

function ENT:GetAimAngles()
	local trace = self:GetEyeTrace()

	local AimAnglesR = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(10,-60,81) ) ):GetNormalized():Angle() )
	local AimAnglesL = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(10,60,81) ) ):GetNormalized():Angle() )

	return AimAnglesR, AimAnglesL
end

function ENT:WeaponsInRange()
	if self:GetIsCarried() then return false end

	local AimAnglesR, AimAnglesL = self:GetAimAngles()

	return not ((AimAnglesR.p >= 30 and AimAnglesL.p >= 30) or (AimAnglesR.p <= -25 and AimAnglesL.p <= -25) or (math.abs(AimAnglesL.y) + math.abs(AimAnglesL.y)) >= 60)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 102
	weapon.Delay = 0.3
	weapon.HeatRateUp = 0.3
	weapon.HeatRateDown = 0.05
	weapon.Attack = function( ent )
		if not ent:WeaponsInRange() then return true end
		local turretPos = ent.directionTurretPos or "right"
		local turretYPos = ent.turrentColumnPos or 0
		local turretXPos = ent.turrentRowPox or 0

		local newMuzzle = "missiles_" .. turretPos .. "_muzzle_" .. turretYPos .. (turretPos == "right" and turretXPos or 3 - turretXPos)

		local Driver = ent:GetDriver()

		if not IsValid( ent ) then return end
		ent:TakeAmmo()

		local att = self:LookupAttachment(newMuzzle)

		local pos1 = self:GetAttachment( att ).Pos
		local ang1 = ( -self:GetAttachment( att ).Ang:Right() ):Angle()
		local projectile = ents.Create( "lvs_concussionmissile" )
		projectile:SetPos( pos1 )
		projectile:SetAngles( ang1 )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile.GetTarget = function( missile ) return missile end
		projectile.GetTargetPos = function( missile )
			return missile:LocalToWorld( Vector(150,0,0) + VectorRand() * math.random(-3,3) )
		end 
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( 4000 )
		projectile:SetDamage( 400 )
		projectile:SetRadius( 200 )
		projectile:Enable()
		projectile:EmitSound( "LVS.IFTX.FIRE_MISSILE" )

		if turretPos == "right" then
			ent.directionTurretPos = "left"
		else
			ent.directionTurretPos = "right"
			if turretXPos == 3 then
				ent.turrentRowPox = 0
				if turretYPos == 3 then
					ent.turrentColumnPos = 0
				else
					ent.turrentColumnPos = turretYPos + 1
				end
			else
				ent.turrentRowPox = turretXPos + 1
			end
		end
	end
	weapon.OnThink = function( ent, active )
		if ent:GetIsCarried() then
			self:SetPoseParameter("missiles_right_pitch", 0 )
			self:SetPoseParameter("missiles_right_yaw", 0 )

			self:SetPoseParameter("missiles_left_pitch", 0 )
			self:SetPoseParameter("missiles_left_yaw", 0 )

			return
		end

		local AimAnglesR, AimAnglesL = ent:GetAimAngles()

		self:SetPoseParameter("missiles_right_pitch", -AimAnglesR.p )
		self:SetPoseParameter("missiles_right_yaw", -AimAnglesR.y )

		self:SetPoseParameter("missiles_left_pitch", -AimAnglesL.p )
		self:SetPoseParameter("missiles_left_yaw", -AimAnglesL.y )
	end
	self:AddWeapon( weapon )


	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)
	self.RearGunAngleRange = 35

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Ammo = -1
	weapon.Delay = 0.6
	weapon.HeatRateUp = 0.02
	weapon.HeatRateDown = 0.03
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > base.RearGunAngleRange then return true end

		local trace = ent:GetEyeTrace()

		local Pos,Ang = WorldToLocal( Vector(0,0,0), (trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,180,0) ) )

		if not IsValid( ent ) then return end
		ent:TakeAmmo()

		local mru = self:LookupAttachment( "blaster_right_muzzle_up" ) 
		local RightMuzzleUp = self:GetAttachment(mru)
		local mrd = self:LookupAttachment( "blaster_right_muzzle_down" ) 
		local RightMuzzleDown = self:GetAttachment(mrd)

		local mlu = self:LookupAttachment( "blaster_left_muzzle_up" ) 
		local LeftMuzzleUp = self:GetAttachment(mlu)
		local mld = self:LookupAttachment( "blaster_left_muzzle_down" ) 
		local LeftMuzzleDown = self:GetAttachment(mld)

		if not RightMuzzleUp or not RightMuzzleDown or not LeftMuzzleUp or not LeftMuzzleDown then return end
		local muzzles = { RightMuzzleUp, LeftMuzzleUp, RightMuzzleDown, LeftMuzzleDown }
		self:EmitSound( "niksacokica/tx-427/cannon_small.wav" )

		for i, muzzle in ipairs( muzzles ) do
			local bullet = {}
			bullet.Src 	= muzzle.Pos
			bullet.Dir 	= (trace.HitPos - muzzle.Pos):GetNormalized()
			bullet.Spread 	= Vector( 0.015,  0.015, 0.01 )
			bullet.TracerName = "lvs_laser_blue"
			bullet.Force	= 100
			bullet.HullSize 	= 1
			bullet.Damage	= 100
			bullet.Velocity = 40000
			bullet.Attacker 	= ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				local effectdata = EffectData()
					effectdata:SetStart( Vector(50,50,255) ) 
					effectdata:SetOrigin( tr.HitPos )
					effectdata:SetNormal( tr.HitNormal )
				util.Effect( "lvs_laser_impact", effectdata )
			end
			ent:LVSFireBullet( bullet )
		end
		
		ent:TakeAmmo()

		if ent.MirrorPrimary then
			if not IsValid( ent.SNDLeft ) then return end
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
			return
		end
		
	end	

	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		

		local trace = ent:GetEyeTrace()

        local _,AimAnglesR = WorldToLocal(Vector(0,0,0),(trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,0,0) ) )
        local _,AimAnglesL = WorldToLocal(Vector(0,0,0),(trace.HitPos - self:LocalToWorld( Vector(-400,0,158.5)) ):GetNormalized():Angle(), Vector(0,0,0), self:LocalToWorldAngles( Angle(0,0,0) ) )

		base:SetPoseParameter("blasters_right_pitch", -AimAnglesR.p )
		base:SetPoseParameter("blasters_right_yaw",  AimAnglesR.y )

		base:SetPoseParameter("blasters_left_pitch", -AimAnglesL.p )
		base:SetPoseParameter("blasters_left_yaw", AimAnglesL.y )
		
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local RearGunInRange = ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > base.RearGunAngleRange

		local Col = RearGunInRange and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		base:PaintCrosshairCenter( Pos2D, Col )
		base:PaintCrosshairOuter( Pos2D, Col )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 3 )

	self:InitTurret()
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/iftx/loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "lvs/vehicles/iftx/loop_hi.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	},
	{
		sound = "^lvs/vehicles/iftx/dist.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		SoundLevel = 90,
	},
}

sound.Add( {
	name = "LVS.IFTX.FIRE_MISSILE",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 125,
	pitch = {95, 105},
	sound = "lvs/vehicles/iftx/fire_missile.mp3"
} )

--lua/entities/lvs_av7/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:CalcEngineSound( RPM, Pitch, Doppler )
	if self.ENG then
		self.ENG:ChangePitch(  math.Clamp(math.Clamp(  60 + Pitch * 50, 80,255) + Doppler,0,255) )
		self.ENG:ChangeVolume( math.Clamp( -1 + Pitch * 6, 0.5,1) )
	end
	
	if self.DIST then
		self.DIST:ChangePitch(  math.Clamp(math.Clamp(  50 + Pitch * 60, 50,255) + Doppler,0,255) )
		self.DIST:ChangeVolume( math.Clamp( -1 + Pitch * 6, 0,1) )
	end
end

function ENT:OnRemove()
	self:SoundStop()
end

function ENT:SoundStop()
	if self.DIST then
		self.DIST:Stop()
	end
	
	if self.ENG then
		self.ENG:Stop()
	end
end

--addons/lvs_base/lua/entities/lvs_base/sh_weapons.lua:

ENT.WEAPONS = {
	[1] = {},
}

function ENT:InitWeapons()
end

function ENT:AddWeapon( weaponData, PodID )
	if not istable( weaponData ) then print("[LVS] couldn't register weapon") return end

	local data = table.Copy( weaponData )

	if not PodID or PodID <= 1 then
		PodID = 1
	end

	if not self.WEAPONS[ PodID ] then
		self.WEAPONS[ PodID ] = {}
	end

	local default = LVS:GetWeaponPreset( "DEFAULT" )

	data.Icon = data.Icon or Material("lvs/weapons/bullet.png")
	data.Ammo = data.Ammo or -1
	data.Delay = data.Delay or FrameTime()

	if isnumber( data.Clip ) and data.Clip > 0 then
		data.HeatIsClip = true

		local ShootDelay = data.Delay

		local Clip = data.Clip
		local ReloadSpeed = data.ReloadSpeed or 2

		data.HeatRateUp = 1.00001 / (ShootDelay * Clip)
		data.HeatRateDown = 1 / ReloadSpeed
		data.OnReload = data.OnReload or default.OnReload
	else
		data.HeatRateUp = data.HeatRateUp or default.HeatRateUp
		data.HeatRateDown = data.HeatRateDown or default.HeatRateDown
	end

	data.Attack = data.Attack or default.Attack
	data.StartAttack = data.StartAttack or default.StartAttack
	data.FinishAttack = data.FinishAttack or default.FinishAttack
	data.OnSelect = data.OnSelect or default.OnSelect
	data.OnDeselect = data.OnDeselect or default.OnDeselect
	data.OnThink = data.OnThink or default.OnThink
	data.OnOverheat = data.OnOverheat or default.OnOverheat
	data.OnRemove = data.OnRemove or default.OnRemove
	data.UseableByAI = data.UseableByAI ~= false

	table.insert( self.WEAPONS[ PodID ], data )
end

function ENT:UpdateWeapon( PodID, WeaponID, weaponData )
	if not self.WEAPONS[ PodID ] then return end

	if not self.WEAPONS[ PodID ][ WeaponID ] then return end

	table.Merge( self.WEAPONS[ PodID ][ WeaponID ], weaponData )
end

function ENT:HasWeapon( ID )
	return istable( self.WEAPONS[1][ ID ] )
end

function ENT:AIHasWeapon( ID )
	local weapon = self.WEAPONS[1][ ID ]
	if not istable( weapon ) then return false end

	return weapon.UseableByAI
end

function ENT:GetActiveWeapon()
	local SelectedID = self:GetSelectedWeapon()
	local CurWeapon = self.WEAPONS[1][ SelectedID ]

	return CurWeapon, SelectedID
end

function ENT:GetMaxAmmo()
	local CurWeapon = self:GetActiveWeapon()

	if not CurWeapon then return -1 end

	return CurWeapon.Ammo or -1
end

function ENT:GetClip()
	local CurWeapon = self:GetActiveWeapon()

	if not CurWeapon then return 0 end

	local HeatIncrement = (CurWeapon.HeatRateUp or 0.2) * math.max(CurWeapon.Delay or 0, FrameTime())

	local Ammo = self:GetNWAmmo()

	if self:GetMaxAmmo() <= 0 and CurWeapon.Clip then
		Ammo = CurWeapon.Clip
	end

	return math.min( math.ceil( math.Round( (1 - self:GetNWHeat()) / HeatIncrement, 1 ) ), Ammo )
end

if SERVER then
	function ENT:WeaponRestoreAmmo()
		local AmmoIsSet = false

		for PodID, data in pairs( self.WEAPONS ) do
			for id, weapon in pairs( data ) do
				local MaxAmmo = weapon.Ammo or -1
				local CurAmmo = weapon._CurAmmo or -1

				if CurAmmo == MaxAmmo then continue end

				self.WEAPONS[PodID][ id ]._CurAmmo = MaxAmmo

				AmmoIsSet = true
			end
		end

		if AmmoIsSet then
			self:SetNWAmmo( self:GetAmmo() )

			for _, pod in pairs( self:GetPassengerSeats() ) do
				local weapon = pod:lvsGetWeapon()

				if not IsValid( weapon ) then continue end

				weapon:SetNWAmmo( weapon:GetAmmo() )
			end
		end

		return AmmoIsSet
	end
	
	function ENT:WeaponsOnRemove()
		for _, data in pairs( self.WEAPONS ) do
			for ID, Weapon in pairs( data ) do
				if not Weapon.OnRemove then continue end

				Weapon.OnRemove( self )
			end
		end
	end

	function ENT:WeaponsFinish()
		if not self._activeWeapon then return end

		local CurWeapon = self.WEAPONS[1][ self._activeWeapon ]

		if not CurWeapon then return end

		if CurWeapon.FinishAttack then
			CurWeapon.FinishAttack( self )
		end

		self._activeWeapon = nil
		self.OldAttack = false
	end

	function ENT:GetAmmo()
		if self:GetAI() then return self:GetMaxAmmo() end

		local CurWeapon = self:GetActiveWeapon()

		if not CurWeapon then return -1 end

		return CurWeapon._CurAmmo or self:GetMaxAmmo()
	end

	function ENT:TakeAmmo( num )
		if self:GetMaxAmmo() <= 0 then return end

		local CurWeapon = self:GetActiveWeapon()

		CurWeapon._CurAmmo = math.max( self:GetAmmo() - (num or 1), 0 )

		self:SetNWAmmo( CurWeapon._CurAmmo )
	end

	function ENT:GetHeat( weaponid )
		local CurWeapon

		if isnumber( weaponid ) and weaponid > 0 then
			CurWeapon = self.WEAPONS[1][ weaponid ]
		else
			CurWeapon = self:GetActiveWeapon()
		end

		if not CurWeapon then return 0 end

		return (CurWeapon._CurHeat or 0)
	end

	function ENT:GetOverheated()
		local CurWeapon = self:GetActiveWeapon()

		if not CurWeapon then return false end

		return CurWeapon.Overheated == true
	end

	function ENT:SetOverheated( overheat )
		if self:GetOverheated() == overheat then return end

		local CurWeapon = self:GetActiveWeapon()

		if not CurWeapon then return end

		CurWeapon.Overheated = overheat

		self:SetNWOverheated( overheat )

		if self:GetHeat() == 0 then return end

		if CurWeapon.OnOverheat then
			CurWeapon.OnOverheat( self )
		end
	end

	function ENT:SetHeat( heat )
		local CurWeapon = self:GetActiveWeapon()

		if not CurWeapon then return end

		heat = math.Clamp( heat, 0, 1 )

		CurWeapon._CurHeat = heat

		if self:GetNWHeat() == heat then return end

		self:SetNWHeat( heat )
	end

	function ENT:CanAttack()
		local CurWeapon = self:GetActiveWeapon()

		return (CurWeapon._NextFire or 0) < CurTime()
	end

	function ENT:SetNextAttack( time )
		local CurWeapon = self:GetActiveWeapon()

		CurWeapon._NextFire = time
	end

	function ENT:WeaponsShouldFire()
		if self:GetAI() then return self._AIFireInput end

		local ply = self:GetDriver()

		if not IsValid( ply ) then return false end

		return ply:lvsKeyDown( "ATTACK" )
	end

	function ENT:WeaponsThink()
		local EntTable = self:GetTable()

		local T = CurTime()
		local FT = FrameTime()
		local CurWeapon, SelectedID = self:GetActiveWeapon()
	
		for ID, Weapon in pairs( EntTable.WEAPONS[1] ) do
			local IsActive = ID == SelectedID

			if Weapon.OnThink then Weapon.OnThink( self, IsActive ) end

			if IsActive then continue end

			if Weapon.HeatIsClip and not Weapon.Overheated and Weapon._CurHeat ~= 0 then
				Weapon.Overheated = true
				Weapon._CurHeat = 1

				if Weapon.OnReload then Weapon.OnReload( self ) end
			end

			-- cool all inactive weapons down
			Weapon._CurHeat = Weapon._CurHeat and Weapon._CurHeat - math.min( Weapon._CurHeat, (Weapon.HeatRateDown or 0.25) * FT ) or 0
		end

		if not CurWeapon then return end

		local ShouldFire = self:WeaponsShouldFire()
		local CurHeat = self:GetHeat()

		if self:GetOverheated() then
			if CurHeat <= 0 then
				self:SetOverheated( false )
			else
				ShouldFire = false
			end
		else
			if CurHeat >= 1 then
				self:SetOverheated( true )
				ShouldFire = false
				if CurWeapon.OnReload then CurWeapon.OnReload( self ) end
			end
		end

		if self:GetMaxAmmo() > 0 then
			if self:GetAmmo() <= 0 then
				ShouldFire = false
			end
		end

		if ShouldFire ~= EntTable.OldAttack then
			EntTable.OldAttack = ShouldFire

			if ShouldFire then
				if CurWeapon.StartAttack then
					CurWeapon.StartAttack( self )
				end
				EntTable._activeWeapon = SelectedID
			else
				self:WeaponsFinish()
			end
		end

		if ShouldFire then
			if not self:CanAttack() then return end

			local ShootDelay = (CurWeapon.Delay or 0)

			self:SetNextAttack( T + ShootDelay )
			self:SetHeat( CurHeat + (CurWeapon.HeatRateUp or 0.2) * math.max(ShootDelay, FT) )

			if not CurWeapon.Attack then return end

			if CurWeapon.Attack( self ) then
				self:SetHeat( CurHeat - math.min( self:GetHeat(), (CurWeapon.HeatRateDown or 0.25) * FT ) )
				self:SetNextAttack( T )
			end

			EntTable._lvsNextActiveWeaponCoolDown = T + 0.25
		else
			if (EntTable._lvsNextActiveWeaponCoolDown or 0) > T then return end

			if CurWeapon.HeatIsClip and not CurWeapon.Overheated then

				self:SetHeat( self:GetHeat() )
	
				return
			end

			self:SetHeat( self:GetHeat() - math.min( self:GetHeat(), (CurWeapon.HeatRateDown or 0.25) * FT ) )
		end
	end

	function ENT:SelectWeapon( ID )
		if not isnumber( ID ) then return end

		if self.WEAPONS[1][ ID ] then
			self:SetSelectedWeapon( ID )
		end

		local ply = self:GetDriver()

		if not IsValid( ply ) then return end

		net.Start( "lvs_select_weapon" )
		net.Send( ply )
	end

	function ENT:OnWeaponChanged( name, old, new)
		if new == old then return end

		self:WeaponsFinish()

		local PrevWeapon = self.WEAPONS[1][ old ]
		if PrevWeapon and PrevWeapon.OnDeselect then
			PrevWeapon.OnDeselect( self, new )
		end

		local NextWeapon = self.WEAPONS[1][ new ]
		if NextWeapon and NextWeapon.OnSelect then
			NextWeapon.OnSelect( self, old )
			self:SetNWAmmo( NextWeapon._CurAmmo or NextWeapon.Ammo or -1 )
			self:SetNWOverheated( NextWeapon.Overheated == true )
		end
	end

	return
end

function ENT:DrawWeaponIcon( PodID, ID, x, y, width, height, IsSelected, IconColor )
end

function ENT:SelectWeapon( ID )
	if not isnumber( ID ) then return end

	net.Start( "lvs_select_weapon" )
		net.WriteInt( ID, 5 )
		net.WriteBool( false )
	net.SendToServer()
end

function ENT:NextWeapon()
	net.Start( "lvs_select_weapon" )
		net.WriteInt( 1, 5 )
		net.WriteBool( true )
	net.SendToServer()
end

function ENT:PrevWeapon()
	net.Start( "lvs_select_weapon" )
		net.WriteInt( -1, 5 )
		net.WriteBool( true )
	net.SendToServer()
end

LVS:AddHudEditor( "WeaponSwitcher", ScrW() - 210, ScrH() - 165,  200, 68, 200, 68, "WEAPON SELECTOR", 
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintWeapons then return end
		vehicle:LVSHudPaintWeapons( X, Y, W, H, ScrX, ScrY, ply )
	end
)

LVS:AddHudEditor( "WeaponInfo", ScrW() - 230, ScrH() - 85,  220, 75, 220, 75, "WEAPON INFO", 
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintWeaponInfo then return end

		vehicle:LVSHudPaintWeaponInfo( X, Y, W, H, ScrX, ScrY, ply )
	end
)

function ENT:GetAmmoID( ID )
	local ply = LocalPlayer()

	if not IsValid( ply ) then return end

	local Base = ply:lvsGetWeaponHandler()

	if not IsValid( Base ) then return -1 end

	local selected = Base:GetSelectedWeapon()
	local weapon = self.WEAPONS[ Base:GetPodIndex() ][ ID ]

	if ID == selected then
		weapon._CurAmmo = Base:GetNWAmmo()
	else
		weapon._CurAmmo = weapon._CurAmmo or weapon.Ammo or -1
	end

	return weapon._CurAmmo
end


local Circles = {
	[1] = {r = -1, col = Color(0,0,0,200)},
	[2] = {r = 0, col = Color(255,255,255,200)},
	[3] = {r = 1, col = Color(255,255,255,255)},
	[4] = {r = 2, col = Color(255,255,255,200)},
	[5] = {r = 3, col = Color(0,0,0,200)},
}

local function DrawCircle( X, Y, target_radius, heatvalue, overheated )
	local endang = 360 * heatvalue

	if endang == 0 then return end

	for i = 1, #Circles do
		local data = Circles[ i ]
		local radius = target_radius + data.r
		local segmentdist = endang / ( math.pi * radius / 2 )

		for a = 0, endang, segmentdist do
			local r = data.col.r
			local g = data.col.g * (1 - math.min(a / 270,1))
			local b = data.col.b * (1 - math.min(a / 90,1))

			surface.SetDrawColor( r, g, b, data.col.a )

			surface.DrawLine( X - math.sin( math.rad( a ) ) * radius, Y + math.cos( math.rad( a ) ) * radius, X - math.sin( math.rad( a + segmentdist ) ) * radius, Y + math.cos( math.rad( a + segmentdist ) ) * radius )
		end
	end
end

ENT.HeatMat = Material( "lvs/heat.png" )
ENT.HeatIsClipMat = Material( "lvs/3d2dmats/refil.png" )

local color_white = color_white
local color_red = Color(255,0,0,255)

function ENT:LVSHudPaintWeaponInfo( X, Y, w, h, ScrX, ScrY, ply )
	local Base = ply:lvsGetWeaponHandler()

	if not IsValid( Base ) then return end

	local ID = Base:GetSelectedWeapon()

	if not Base:HasWeapon( ID ) then return end

	local Weapon = Base:GetActiveWeapon()
	local Heat = Base:GetNWHeat()
	local OverHeated = Base:GetNWOverheated()
	local Ammo = Base:GetNWAmmo()

	if Weapon and Weapon.HeatIsClip then
		local Pod = ply:GetVehicle()

		if not IsValid( Pod ) then return end

		local PodID = Base:GetPodIndex()

		local FT = FrameTime()
		local ShootDelay = math.max(Weapon.Delay or 0, FT)
		local HeatIncrement = (Weapon.HeatRateUp or 0.2) * ShootDelay

		local Clip = Base:GetClip()

		if OverHeated then
			Clip = 0

			local hX = X + w - h * 0.5
			local hY = Y + h * 0.25 + h * 0.25
	
			surface.SetMaterial( self.HeatIsClipMat )
			surface.SetDrawColor( 0, 0, 0, 200 )
			surface.DrawTexturedRectRotated( hX + 3, hY + 1, h, h, 0 )
			surface.SetDrawColor( 255, 0, 0, 255 )
			surface.DrawTexturedRectRotated( hX + 1, hY - 1, h, h, 0 )

			DrawCircle( hX, hY, h * 0.35, Heat )
		end

		Ammo = Ammo - Clip

		local ColDyn = (Clip == 0 or OverHeated) and color_red or color_white

		draw.DrawText( "AMMO ", "LVS_FONT", X + 72, Y + 35, ColDyn, TEXT_ALIGN_RIGHT )

		draw.DrawText( Clip, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, ColDyn, TEXT_ALIGN_LEFT )

		if Base:GetMaxAmmo() <= 0 then return end

		local ColDyn2 = Ammo <= Weapon.Clip and color_red or color_white

		X = X + math.max( (#string.Explode( "", Clip ) - 1) * 18, 0 )

		draw.DrawText( "/", "LVS_FONT_HUD_LARGE", X + 96, Y + 30, ColDyn2, TEXT_ALIGN_LEFT )

		draw.DrawText( Ammo, "LVS_FONT", X + 110, Y + 40, ColDyn2, TEXT_ALIGN_LEFT )

		return
	end

	local hX = X + w - h * 0.5
	local hY = Y + h * 0.25 + h * 0.25
	local hAng = math.cos( CurTime() * 50 ) * 5 * (OverHeated and 1 or Heat ^ 2)

	surface.SetMaterial( self.HeatMat )
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawTexturedRectRotated( hX + 4, hY + 1, h * 0.5, h * 0.5, hAng )

	if OverHeated then
		surface.SetDrawColor( 255, 0, 0, 255 )
	else
		surface.SetDrawColor( 255, 255 * (1 - Heat), 255 * math.max(1 - Heat * 1.5,0), 255 )
	end

	surface.DrawTexturedRectRotated( hX + 2, hY - 1, h * 0.5, h * 0.5, hAng )

	DrawCircle( hX, hY, h * 0.35, Heat )

	if Base:GetMaxAmmo() <= 0 then return end

	draw.DrawText( "AMMO ", "LVS_FONT", X + 72, Y + 35, color_white, TEXT_ALIGN_RIGHT )
	draw.DrawText( Ammo, "LVS_FONT_HUD_LARGE", X + 72, Y + 20, color_white, TEXT_ALIGN_LEFT )
end

function ENT:LVSHudPaintWeapons( X, Y, w, h, ScrX, ScrY, ply )
	local EntTable = self:GetTable()

	local Base = ply:lvsGetWeaponHandler()

	if not IsValid( Base ) then return end

	local Pod = ply:GetVehicle()

	if not IsValid( Pod ) then return end

	local PodID = Base:GetPodIndex()

	local num = #self.WEAPONS[ PodID ]

	if num <= 1 then return end

	local CenterY = (Y + h * 0.5)
	local CenterX = (X + w * 0.5)

	local FlatSelector = CenterX > ScrX * 0.333 and CenterX < ScrX * 0.666

	local T = CurTime()
	local FT = RealFrameTime()

	local gap = 4
	local SizeY = h - gap

	local Selected = Base:GetSelectedWeapon()
	if Selected ~= EntTable._OldSelected then
		EntTable._OldSelected = Selected
		Pod._SelectActiveTime = T + 2
	end

	local tAlpha = (Pod._SelectActiveTime or 0) > T and 1 or 0
	local tAlphaRate = FT * 15

	EntTable.smAlphaSW = EntTable.smAlphaSW and (EntTable.smAlphaSW + math.Clamp(tAlpha - EntTable.smAlphaSW,-tAlphaRate,tAlphaRate)) or 0

	if EntTable.smAlphaSW > 0.95 then
		EntTable._DisplaySelected = Selected
	else
		EntTable._DisplaySelected = EntTable._DisplaySelected or Selected
	end

	local A255 = 255 * EntTable.smAlphaSW
	local A150 = 150 * EntTable.smAlphaSW

	local Col = Color(0,0,0,A150)
	local ColSelect = Color(255,255,255,A150)

	local SwapY = 0

	if Y < (ScrY * 0.5 - h * 0.5) then
		SwapY = 1
	end

	for ID = 1, num do
		local IsSelected = EntTable._DisplaySelected == ID
		local n = num - ID
		local xPos = FlatSelector and X + (w + gap) * (ID - 1) - ((w + gap) * 0.5 * num - w * 0.5) or X
		local yPos = FlatSelector and Y - h * math.min(SwapY,0) or Y - h * n + (num - 1) * h * SwapY

		draw.RoundedBox(5, xPos, yPos, w, SizeY, IsSelected and ColSelect or Col )

		if IsSelected then
			surface.SetDrawColor( 0, 0, 0, A255 )
		else
			surface.SetDrawColor( 255, 255, 255, A255 )
		end

		if isbool( EntTable.WEAPONS[PodID][ID].Icon ) then
			local col = IsSelected and Color(255,255,255,A255) or Color(0,0,0,A255) 
			self:DrawWeaponIcon( PodID, ID, xPos, yPos, SizeY * 2, SizeY, IsSelected, col )
		else
			surface.SetMaterial( self.WEAPONS[PodID][ID].Icon )
			surface.DrawTexturedRect( xPos, yPos, SizeY * 2, SizeY )
		end

		local ammo = self:GetAmmoID( ID )

		if ammo > -1 then
			draw.DrawText( ammo, "LVS_FONT_HUD", xPos + w - 10, yPos + SizeY * 0.5 - 10, IsSelected and Color(0,0,0,A255) or Color(255,255,255,A255), TEXT_ALIGN_RIGHT )
		else
			draw.DrawText( "O", "LVS_FONT_HUD", xPos + w - 19, yPos + SizeY * 0.5 - 10, IsSelected and Color(0,0,0,A255) or Color(255,255,255,A255), TEXT_ALIGN_RIGHT )
			draw.DrawText( "O", "LVS_FONT_HUD", xPos + w - 10, yPos + SizeY * 0.5 - 10, IsSelected and Color(0,0,0,A255) or Color(255,255,255,A255), TEXT_ALIGN_RIGHT )
		end
	end
end
--addons/lvs_addons/lua/entities/lvs_fakehover_iftx/cl_init.lua:
include("shared.lua")
include( "sh_turret.lua" )
include( "cl_prediction.lua" )

function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(-30,0,43) ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(-85,65,14) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(-85,-65,14) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

function ENT:OnFrame()
	self:BTLProjector()
	self:PredictPoseParamaters()
	self:DamageFX()
end

function ENT:BTLProjector()
	local Fire = self:GetBTLFire()

	if Fire == self.OldFireBTL then return end

	self.OldFireBTL = Fire
	
	if Fire then
		local effectdata = EffectData()
		effectdata:SetEntity( self )
		util.Effect( "lvs_laat_left_projector", effectdata )
	end
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if ply == self:GetDriver() and not pod:GetThirdPersonMode() then
		return pos + self:GetForward() * 40 - self:GetUp() * 20, angles, fov
	end

	local GunnerPod = self:GetGunnerSeat()

	if pod == GunnerPod and pod:GetThirdPersonMode() then
		return GunnerPod:LocalToWorld( Vector(0,0,60) ), angles + Angle(6,0,0), fov
	end

	return pos, angles, fov
end

function ENT:RemoveLight()
	if IsValid( self.projector ) then
		self.projector:Remove()
		self.projector = nil
	end
end

function ENT:OnRemoved()
	self:RemoveLight()
end

function ENT:PreDraw()
	self:DrawDriverBTL()

	return true
end

ENT.LightMaterial = Material( "effects/lvs/laat_spotlight" )
ENT.GlowMaterial = Material( "sprites/light_glow02_add" )

function ENT:PreDrawTranslucent()
	if self:GetBodygroup( 2 ) ~= 1 then 
		self:RemoveLight()
		return false
	end

	if not IsValid( self.projector ) then
		local thelamp = ProjectedTexture()
		thelamp:SetBrightness( 10 ) 
		thelamp:SetTexture( "effects/flashlight/soft" )
		thelamp:SetColor( Color(255,255,255) ) 
		thelamp:SetEnableShadows( true ) 
		thelamp:SetFarZ( 2500 ) 
		thelamp:SetNearZ( 75 ) 
		thelamp:SetFOV( 60 )
		self.projector = thelamp
	end

	local Start1 = self:LocalToWorld( Vector(64,6,10.5) )
	local Start2 = self:LocalToWorld( Vector(64,-6,10.5) )

	local Dir1 = self:LocalToWorldAngles( Angle(0,5,0) ):Forward()
	local Dir2 = self:LocalToWorldAngles( Angle(0,-5,0) ):Forward()

	render.SetMaterial( self.GlowMaterial )
	render.DrawSprite( Start1, 32, 32, Color( 100, 100, 100, 255) )
	render.DrawSprite( Start2, 32, 32, Color( 100, 100, 100, 255) )

	render.SetMaterial( self.LightMaterial )
	render.DrawBeam( Start1,  Start1 + Dir1 * 400, 150, 0, 0.99, Color( 100, 100, 100, 5) ) 
	render.DrawBeam( Start2,  Start2 + Dir2 * 400, 150, 0, 0.99, Color( 100, 100, 100, 5) ) 

	if IsValid( self.projector ) then
		self.projector:SetPos( self:LocalToWorld( Vector(60,0,10.5) ) )
		self.projector:SetAngles( self:LocalToWorldAngles( Angle(15,0,0) ) )
		self.projector:Update()
	end

	return false
end

local COLOR_RED = Color(255,0,0,255)
local COLOR_WHITE = Color(255,255,255,255)

function ENT:LVSPreHudPaint( X, Y, ply )
	if self:GetIsCarried() then return false end

	if ply == self:GetDriver() then
		local Col = self:WeaponsInRange() and COLOR_WHITE or COLOR_RED

		local Pos2D = self:GetEyeTrace().HitPos:ToScreen() 

		self:PaintCrosshairCenter( Pos2D, Col )
		self:PaintCrosshairOuter( Pos2D, Col )
		self:LVSPaintHitMarker( Pos2D )
	end

	return true
end

function ENT:DrawDriverBTL()
	local pod = self:GetGunnerSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if not IsValid( ply ) or (ply == plyL and plyL:GetViewEntity() == plyL and not pod:GetThirdPersonMode()) then return end

	if self:GetBodygroup(1) == 2 then
		ply:SetSequence( "sit_rollercoaster" )
		ply:SetRenderAngles( self:GetAngles() )
		ply:DrawModel()

		return
	end

	local ID = self:LookupAttachment( "muzzle_ballturret_left" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local _,Ang = LocalToWorld( Vector(0,0,0), Angle(-90,0,-90), Muzzle.Pos, Muzzle.Ang )

	local LAng = self:WorldToLocalAngles( Ang )
	LAng.p = 0
	LAng.r = 0

	ply:SetSequence( "sit_rollercoaster" )
	ply:SetRenderAngles( self:LocalToWorldAngles( LAng ) )
	ply:DrawModel()
end

--lua/entities/lvs_fakehover_mtt/cl_prediction.lua:
function ENT:PredictPoseParamaters()
	local pod = self:GetGunnerSeat()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:InvalidateBoneCache()
end
--addons/lvs_addons/lua/entities/lvs_fakehover_snail/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:OnFrame()

end

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end
	
	self.nextDFX = self.nextDFX or 0
	
	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05
		
		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(-90,0,40) ) )
		util.Effect( "lvs_blacksmoke", effectdata )
	end
end


local COLOR_RED = Color(255,0,0,255)
local COLOR_WHITE = Color(255,255,255,255)


function ENT:CalcEngineSound( RPM, Pitch, Doppler )
	if self.ENG then
		self.ENG:ChangePitch(  math.Clamp(math.Clamp(  60 + Pitch * 50, 80,255) + Doppler,0,255) )
		self.ENG:ChangeVolume( math.Clamp( -1 + Pitch * 6, 0.5,1) )
	end
	
	if self.DIST then
		self.DIST:ChangePitch(  math.Clamp(math.Clamp(  50 + Pitch * 60, 50,255) + Doppler,0,255) )
		self.DIST:ChangeVolume( math.Clamp( -1 + Pitch * 6, 0,1) )
	end
end

function ENT:OnRemove()
	self:SoundStop()
end

function ENT:SoundStop()
	if self.DIST then
		self.DIST:Stop()
	end
	
	if self.ENG then
		self.ENG:Stop()
	end
end

--addons/lvs_addons/lua/entities/lvs_hail_missile.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Hail Missile"
ENT.Author = "Luna / Dec"
ENT.Information = "LVS Hail Missile"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

ENT.ExplosionEffect = "lvs_explosion_small"

ENT.lvsProjectile = true

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "Active" )
	self:NetworkVar( "Entity", 0, "NWTarget" )
end

if SERVER then
	util.AddNetworkString( "lvs_missile_hud" )

	function ENT:GetAvailableTargets()
		local targets = {
			[1] = player.GetAll(),
			[2] = LVS:GetVehicles(),
			[3] = LVS:GetNPCs(),
		}

		return targets
	end

	function ENT:FindTarget( pos, forward, cone_ang, cone_len )
		local targets = self:GetAvailableTargets()

		local Attacker = self:GetAttacker()
		local Parent = self:GetParent()
		local Owner = self:GetOwner()
		local Target = NULL
		local DistToTarget = 0

		for _, tbl in ipairs( targets ) do
			for _, ent in pairs( tbl ) do
				if not IsValid( ent ) or ent == Parent or ent == Owner or Target == ent or Attacker == ent then continue end

				local pos_ent = ent:GetPos()
				local dir = (pos_ent - pos):GetNormalized()
				local ang = math.deg( math.acos( math.Clamp( forward:Dot( dir ) ,-1,1) ) )

				if ang > cone_ang then continue end

				local dist, _, _ = util.DistanceToLine( pos, pos + forward * cone_len, pos_ent )

				if not IsValid( Target ) then
					Target = ent
					DistToTarget = dist

					continue
				end

				if dist < DistToTarget then
					Target = ent
					DistToTarget = dist
				end
			end
		end

		self:SetTarget( Target )

		local ply = self:GetAttacker()

		if not IsValid( ply ) or not ply:IsPlayer() then return end

		net.Start( "lvs_missile_hud", true )
			net.WriteEntity( self )
		net.Send( ply )
	end

	function ENT:SetEntityFilter( filter )
		if not istable( filter ) then return end

		self._FilterEnts = {}

		for _, ent in pairs( filter ) do
			self._FilterEnts[ ent ] = true
		end
	end
	function ENT:SetTarget( ent ) self:SetNWTarget( ent ) end
	function ENT:SetDamage( num ) self._dmg = num end
	function ENT:SetThrust( num ) self._thrust = num end
	function ENT:SetSpeed( num ) self._speed = num end
	function ENT:SetTurnSpeed( num ) self._turnspeed = num end
	function ENT:SetRadius( num ) self._radius = num end
	function ENT:SetAttacker( ent ) self._attacker = ent end

	function ENT:GetAttacker() return self._attacker or NULL end
	function ENT:GetDamage() return (self._dmg or 800) end
	function ENT:GetRadius() return (self._radius or 250) end
	function ENT:GetSpeed() return (self._speed or 3000) end
	function ENT:GetTurnSpeed() return (self._turnspeed or 1) * 100 end
	function ENT:GetThrust() return (self._thrust or 500) end
	function ENT:GetTarget()
		if IsValid( self:GetNWTarget() ) then
			local Pos = self:GetPos()
			local tPos = self:GetTargetPos()

			local Sub = tPos - Pos
			local Len = Sub:Length()
			local Dir = Sub:GetNormalized()
			local Forward = self:GetForward()

			local AngToTarget = math.deg( math.acos( math.Clamp( Forward:Dot( Dir ) ,-1,1) ) )

			local LooseAng = math.min( Len / 100, 90 )

			if AngToTarget > LooseAng then
				self:SetNWTarget( NULL )
			end
		end

		return self:GetNWTarget()
	end
	function ENT:GetTargetPos()
		local Target = self:GetNWTarget()

		if not IsValid( Target ) then return Vector(0,0,0) end

		if isfunction( Target.GetShield ) then
			if Target:GetShield() > 0 then
				return Target:LocalToWorld( VectorRand() * math.random( -1000, 1000 ) )
			end
		end

		if isfunction( Target.GetMissileOffset ) then
			return Target:LocalToWorld( Target:GetMissileOffset() )
		end

		return Target:GetPos()
	end

	function ENT:SpawnFunction( ply, tr, ClassName )

		local ent = ents.Create( ClassName )
		ent:SetPos( ply:GetShootPos() )
		ent:SetAngles( ply:EyeAngles() )
		ent:Spawn()
		ent:Activate()
		ent:SetAttacker( ply )
		ent:Enable()

		return ent
	end

	function ENT:Initialize()	
		self:SetModel( "models/kingpommes/starwars/hailfire/hailfire_rocket_flying.mdl" )
		self:SetMoveType( MOVETYPE_NONE )
		self:SetRenderMode( RENDERMODE_TRANSALPHA )
	end

	function ENT:Enable()
		if self.IsEnabled then return end

		local Parent = self:GetParent()

		if IsValid( Parent ) then
			self:SetOwner( Parent )
			self:SetParent( NULL )
		end

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		self:PhysWake()

		self.IsEnabled = true

		local pObj = self:GetPhysicsObject()
		
		if not IsValid( pObj ) then
			self:Remove()

			print("LVS: missing model. Missile terminated.")

			return
		end

		pObj:SetMass( 1 ) 
		pObj:EnableGravity( false ) 
		pObj:EnableMotion( true )
		pObj:EnableDrag( false )

		self:SetTrigger( true )

		self:StartMotionController()

		self:PhysWake()

		self.SpawnTime = CurTime()

		self:SetActive( true )
	end

	function ENT:PhysicsSimulate( phys, deltatime )
		phys:Wake()

		local Thrust = self:GetThrust()
		local Speed = self:GetSpeed()
		local Pos = self:GetPos()
		local velL = self:WorldToLocal( Pos + self:GetVelocity() )

		local ForceLinear = (Vector( Speed * Thrust,0,0) - velL) * deltatime

		local Target = self:GetTarget()

		if not IsValid( Target ) then
			return (-phys:GetAngleVelocity() * 250 * deltatime), ForceLinear, SIM_LOCAL_ACCELERATION
		end

		local AngForce = -self:WorldToLocalAngles( (self:GetTargetPos() - Pos):Angle() )

		local ForceAngle = (Vector(AngForce.r,-AngForce.p,-AngForce.y) * self:GetTurnSpeed() - phys:GetAngleVelocity() * 5 ) * 250 * deltatime

		return ForceAngle, ForceLinear, SIM_LOCAL_ACCELERATION
	end

	function ENT:Think()	
		local T = CurTime()

		self:NextThink( T + 1 )

		if not self.SpawnTime then return true end

		if (self.SpawnTime + 12) < T then
			self:Detonate()
		end

		return true
	end

	ENT.IgnoreCollisionGroup = {
		[COLLISION_GROUP_NONE] = true,
		[COLLISION_GROUP_WORLD] =  true,
	}

	function ENT:StartTouch( entity )
		if entity == self:GetAttacker() then return end

		if istable( self._FilterEnts ) and self._FilterEnts[ entity ] then return end

		if entity.GetCollisionGroup and self.IgnoreCollisionGroup[ entity:GetCollisionGroup() ] then return end

		if entity.lvsProjectile then return end

		self:Detonate( entity )
	end

	function ENT:EndTouch( entity )
	end

	function ENT:Touch( entity )
	end

	function ENT:PhysicsCollide( data )
		if istable( self._FilterEnts ) and self._FilterEnts[ data.HitEntity ] then return end

		self:Detonate()
	end

	function ENT:OnTakeDamage( dmginfo )	
	end

	function ENT:Detonate( target )
		if not self.IsEnabled or self.IsDetonated then return end

		self.IsDetonated = true

		local Pos =  self:GetPos() 

		local effectdata = EffectData()
			effectdata:SetOrigin( Pos )
		util.Effect( self.ExplosionEffect, effectdata )

		if IsValid( target ) and not target:IsNPC() then
			Pos = target:GetPos() -- place explosion inside the hit targets location so they receive full damage. This fixes all the garbage code the LFS' missile required in order to deliver its damage
		end

		local attacker = self:GetAttacker()

		util.BlastDamage( self, IsValid( attacker ) and attacker or game.GetWorld(), Pos, self:GetRadius(), self:GetDamage() )

		SafeRemoveEntityDelayed( self, FrameTime() )
	end
else
	function ENT:Initialize()	
	end

	function ENT:Enable()
		if self.IsEnabled then return end

		self.IsEnabled = true

		self.snd = CreateSound(self, "KingPommes/starwars/hailfire/flying.wav")
		self.snd:SetSoundLevel( 80 )
		self.snd:Play()

		local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
			effectdata:SetEntity( self )
		util.Effect( "lvs_missiletrail", effectdata )
	end

	function ENT:CalcDoppler()
		local Ent = LocalPlayer()

		local ViewEnt = Ent:GetViewEntity()

		if Ent:lvsGetVehicle() == self then
			if ViewEnt == Ent then
				Ent = self
			else
				Ent = ViewEnt
			end
		else
			Ent = ViewEnt
		end

		local sVel = self:GetVelocity()
		local oVel = Ent:GetVelocity()

		local SubVel = oVel - sVel
		local SubPos = self:GetPos() - Ent:GetPos()

		local DirPos = SubPos:GetNormalized()
		local DirVel = SubVel:GetNormalized()

		local A = math.acos( math.Clamp( DirVel:Dot( DirPos ) ,-1,1) )

		return (1 + math.cos( A ) * SubVel:Length() / 13503.9)
	end

	function ENT:Draw()
		if not self:GetActive() then return end

		self:DrawModel()
	end

	function ENT:Think()
		if self.snd then
			self.snd:ChangePitch( 100 * self:CalcDoppler() )
		end

		if self.IsEnabled then return end

		if self:GetActive() then
			self:Enable()
		end
	end

	function ENT:SoundStop()
		if self.snd then
			self.snd:Stop()
		end
	end

	function ENT:OnRemove()
		self:SoundStop()
	end

	local function DrawDiamond( X, Y, radius, angoffset )
		angoffset = angoffset or 0

		local segmentdist = 90
		local radius2 = radius + 1

		for ang = 0, 360, segmentdist do
			local a = ang + angoffset
			surface.DrawLine( X + math.cos( math.rad( a ) ) * radius, Y - math.sin( math.rad( a ) ) * radius, X + math.cos( math.rad( a + segmentdist ) ) * radius, Y - math.sin( math.rad( a + segmentdist ) ) * radius )
			surface.DrawLine( X + math.cos( math.rad( a ) ) * radius2, Y - math.sin( math.rad( a ) ) * radius2, X + math.cos( math.rad( a + segmentdist ) ) * radius2, Y - math.sin( math.rad( a + segmentdist ) ) * radius2 )
		end
	end

	local color_red = Color(255,0,0,255)
	local HudTargets = {}
	hook.Add( "HUDPaint", "!!!!lvs_missile_hud", function()
		local T = CurTime()

		local Index = 0

		surface.SetDrawColor( 255, 0, 0, 255 )

		for ID, _ in pairs( HudTargets ) do
			local Missile = Entity( ID )

			if not IsValid( Missile ) then
				HudTargets[ ID ] = nil

				continue
			end

			local Target = Missile:GetNWTarget()

			if not IsValid( Target ) then
				HudTargets[ ID ] = nil

				continue
			end

			local MissilePos = Missile:GetPos():ToScreen()
			local TargetPos = Target:LocalToWorld( Target:OBBCenter() ):ToScreen()

			Index =  Index + 1

			if not TargetPos.visible then continue end

			DrawDiamond( TargetPos.x, TargetPos.y, 40, ID * 1337 - T * 100 )

			if isfunction( Target.GetShield ) and Target:GetShield() > 0 then
				draw.DrawText("WEAK LOCK", "LVS_FONT", TargetPos.x + 20, TargetPos.y + 20, color_red, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			else
				draw.DrawText(" FULL LOCK", "LVS_FONT", TargetPos.x + 20, TargetPos.y + 20, color_red, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
			end

			if not MissilePos.visible then continue end

			DrawDiamond( MissilePos.x, MissilePos.y, 16, ID * 1337 - T * 100 )
			draw.DrawText( Index, "LVS_FONT", MissilePos.x + 10, MissilePos.y + 10, color_red, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )
		
			surface.DrawLine( MissilePos.x, MissilePos.y, TargetPos.x, TargetPos.y )
		end
	end )

	net.Receive( "lvs_missile_hud", function( len )
		local ent = net.ReadEntity()

		if not IsValid( ent ) then return end

		HudTargets[ ent:EntIndex() ] = true
	end )
end
--addons/lvs_addons/lua/entities/lvs_repdestroyer_swtor/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-151,87,15), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,-87,15), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,87,-15), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-151,-87,-15), 0, 20, 2, 1000, 150 )
end
 
-- Engine Particles start

ENT.EngineColor = Color( 255, 196, 0)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-984.59,100.67,-4.4),
	Vector(-984.59,-100.67,-4.4),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-34,326,-13), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-34,-326,-13), 0, 20, 2, 1000, 150 )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 1)
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(100,125) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 255, 196, 0)
	end
end

function ENT:OnFrame()
	self:EngineEffects()
end


-- Engine Particles End

 
function ENT:PostDraw()
	if not self:GetEngineActive() then return end
 
end
 
function ENT:OnStartBoost()
	self:EmitSound( "ophra/ships/powerstart3.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "ophra/ships/shutdown.wav", 85 )
end


--addons/lvs_addons/lua/entities/lvs_repulsorlift_dropship/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if pod == self:GetDriverSeat() then

		if pod:GetThirdPersonMode() then
			pos = pos + self:GetUp() * 200, angles, fov
		end

		return pos, angles, fov
	end

	return pos, angles, fov
end

function ENT:OnSpawn()
end

function ENT:OnFrame()
	local HeldEntity = self:GetHeldEntity()

	local IsHeld = IsValid( HeldEntity )

	if IsHeld ~= self._oldHeldEntity then
		self._oldHeldEntity = IsHeld

		if IsHeld then
			self:BuildFilter()
		else
			self:ResetFilters()
		end
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "^lvs/vehicles/laat/boost_"..math.random(1,2)..".wav", 85 )
end

function ENT:OnStopBoost()
end

--addons/lvs_addons/lua/entities/lvs_repulsorlift_gunship/sh_ballturret_right.lua:

function ENT:SetPosBTR()
	local BTR = self:GetBTPodR()

	if not IsValid( BTR ) then return end

	local ID = self:LookupAttachment( "muzzle_ballturret_right" )
	local Muzzle = self:GetAttachment( ID )

	if Muzzle then
		local PosL = self:WorldToLocal( Muzzle.Pos + Muzzle.Ang:Right() * 28 - Muzzle.Ang:Up() * 65 )
		BTR:SetLocalPos( PosL )
	end
end

function ENT:TraceBTR()
	local ID = self:LookupAttachment( "muzzle_ballturret_right" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:SetPoseParameterBTR( weapon )
	if not IsValid( weapon:GetDriver() ) and not weapon:GetAI() then return end

	local AimAng = weapon:WorldToLocal( weapon:GetPos() + weapon:GetAimVector() ):Angle()
	AimAng:Normalize()

	self:SetPoseParameter("ballturret_right_pitch", AimAng.p )
	self:SetPoseParameter("ballturret_right_yaw", -AimAng.y )
end

function ENT:InitWeaponBTR()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/laserbeam.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.3
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if not base._CanUseBT then return end

		local trace = base:TraceBTR()

		base:BallturretDamage( trace.Entity, ent:GetDriver(), trace.HitPos, (trace.HitPos - ent:GetPos()):GetNormalized() )
	end
	weapon.StartAttack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		if not base._CanUseBT then return end

		base:SetBTRFire( true )

		if not IsValid( self.sndBTR ) then return end

		self.sndBTR:Play()
		self.sndBTR:EmitSound( "lvs/vehicles/laat/ballturret_fire.mp3", 110 )
	end
	weapon.FinishAttack = function( ent )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetBTRFire( false )

		if not IsValid( self.sndBTR ) then return end

		self.sndBTR:Stop()
	end
	weapon.OnThink = function( ent, active )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		base:SetPoseParameterBTR( ent )
		base:SetPosBTR()

		if not ent:GetAI() then return end

		local ID = base:LookupAttachment( "muzzle_ballturret_right" )
		local Muzzle = base:GetAttachment( ID )
		if not Muzzle then return end

		if ent:AngleBetweenNormal(Muzzle.Ang:Up(),ent:GetAimVector()) > 5 then
			ent:SetHeat( 1 )
			ent:SetOverheated( true )
		end
	end
	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()

		local view = {}
		view.origin = pos
		view.angles = angles
		view.fov = fov
		view.drawviewer = false

		if not IsValid( base ) then return view end

		local ID = base:LookupAttachment( "muzzle_ballturret_right" )
		local Muzzle = base:GetAttachment( ID )

		if Muzzle then
			local Pos,Ang = LocalToWorld( Vector(0,25,-45), Angle(270,0,-90), Muzzle.Pos, Muzzle.Ang )

			view.origin = Pos
		end

		return view
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceBTR().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 4 )
end
--addons/laat_g/lua/entities/lvs_repulsorlift_gunship_heavy/sh_gunner3.lua:
function ENT:InitWeaponGunner3()
	local COLOR_RED = Color(255,0,0,255)
	local COLOR_WHITE = Color(255,255,255,255)
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Delay = 1 
	weapon.HeatRateUp = 1
	weapon.HeatRateDown = 0.05
	weapon.Attack = function( ent )
		local dir = ent:GetAimVector()
		
		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 70 then return true end



		local Pos = Vector(50,0,-10)

		local Driver = ent:GetDriver()

		local ID3 = self:LookupAttachment( "105mm" )
		local Muzzle3 = self:GetAttachment( ID3 )

		local projectile = ents.Create("lvs_custommissile")
		projectile:SetPos( Muzzle3.Pos )
		projectile:SetAngles( dir:Angle() )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 )
	end
	weapon.FinishAttack = function( ent )
		ent:SetBodygroup( 1, 0 )

		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound("lvs/vehicles/laat/fire_missile_large.mp3", 125 )

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.01

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end

	weapon.CalcView = function( ent, ply, pos, angles, fov, pod )
		local base = ent:GetVehicle()
		base.ZoomFov = 60

		if not IsValid( base ) then 
			return LVS:CalcView( ent, ply, pos, angles, fov, pod )
		end

		if pod:GetThirdPersonMode() then
			pos = pos + base:GetUp() * 100
		end

		return LVS:CalcView( base, ply, pos, angles, fov, pod )
	end

	weapon.HudPaint = function( ent, X, Y, ply )
		local Col = (ent:AngleBetweenNormal( ent:GetAimVector(), ent:GetForward() ) > 70) and COLOR_RED or COLOR_WHITE

		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen() 

		local base = ent:GetVehicle()
		if not IsValid( base ) then return end

		base:LVSPaintHitMarker( Pos2D )
		
		if not ent:GetDriverSeat():GetThirdPersonMode() then
			local mat = Material( "hud/ac130/105mm.png" )
			surface.SetDrawColor( Col )
			surface.SetMaterial( mat ) 
			surface.DrawTexturedRectRotated( X - 962, Y -542, X , Y , 0 )
		else
			base:PaintCrosshairCenter( Pos2D, Col )
			base:PaintCrosshairOuter( Pos2D, Col )
		end
	end
	self:AddWeapon( weapon, 5 )

end
--addons/laat_g/lua/entities/lvs_repulsorlift_gunship_heavy/cl_prediction.lua:

function ENT:PredictBTL()
	local pod = self:GetBTPodL()

	if not IsValid( pod ) then return end

	local plyL = LocalPlayer()
	local ply = pod:GetDriver()

	if ply ~= plyL then return end

	self:SetPosBTL()
	self:SetPoseParameterBTL( pod:lvsGetWeapon() )
end

function ENT:PredictPoseParamaters()
	self:PredictBTL()

	self:InvalidateBoneCache()
end
--addons/lvs_addons/lua/entities/lvs_starfighter_consulradiance/cl_init.lua:
include("shared.lua")


ENT.EngineFXPos = {
	Vector(-1003.18,-588.23,233.03),
	Vector(-990.07,16.88,232.96),
	Vector(-976.98,620.49,232.9),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(833.19,-307.46,232.38), 0, 20, 2, 2500, 150 )
	self:RegisterTrail( Vector(833.19,307.46,232.38), 0, 20, 2, 2500, 150 )
	self:RegisterTrail( Vector(833.69,-307.43,196.78), 0, 20, 2, 2500, 150 )
	self:RegisterTrail( Vector(833.69,307.43,196.78), 0, 20, 2, 2500, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 2000 + self:GetThrottle() * 40 + self:GetBoost() * 0.8

	render.SetMaterial( self.EngineGlow )
	render.DrawSprite( self:LocalToWorld( Vector(-1003.18,-588.23,233.03) ), Size, Size, Color( 255,255,0) )
	render.DrawSprite( self:LocalToWorld( Vector(-990.07,16.88,232.96) ), Size, Size, Color(255,255,0) )
	render.DrawSprite( self:LocalToWorld( Vector(-976.98,620.49,232.9) ), Size, Size, Color( 255,255,0) )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, v in pairs( self.EngineFXPos ) do
		local Sub = Mirror and 1 or -1
		local vOffset = self:LocalToWorld( v )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(20,25) )
		particle:SetEndSize( math.Rand(0,50) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		
		particle:SetColor( 255, 172, 28 )
	end
end
function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/frigates/takeoff2.mp3", 500 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vwing/brake.wav", 120 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_droidtrifighter/cl_init.lua:
include("shared.lua")

ENT.EngineFXPos = {
	Vector(-104.75,0,31.59),
	Vector(-104.75,-27.74,-15.54),
	Vector(-104.75,27.74,-15.54),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-120,0,31.59), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-120,-27.74,-15.54), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-120,27.74,-15.54), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 40 + self:GetBoost() * 0.8

	render.SetMaterial( self.EngineGlow )
	render.DrawSprite( self:LocalToWorld( Vector(-120,0,31.59) ), Size, Size, Color( 255, 100, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(-120,-27.74,-15.54) ), Size, Size, Color( 255, 100, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(-120,27.74,-15.54) ), Size, Size, Color( 255, 100, 0, 255) )

	render.DrawSprite( self:LocalToWorld( Vector(79,16.99,9.81) ), 16, 16, Color( 255, 0, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(84,13.55,8.05) ), 12, 12, Color( 255, 0, 0, 255) )

	render.DrawSprite( self:LocalToWorld( Vector(79,-16.99,9.81) ), 16, 16, Color( 255, 0, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(84,-13.55,8.05) ), 12, 12, Color( 255, 0, 0, 255) )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, v in pairs( self.EngineFXPos ) do
		local Sub = Mirror and 1 or -1
		local vOffset = self:LocalToWorld( v )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		
		particle:SetColor( 255, 100, 200 )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/vulturedroid/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vulturedroid/brake.wav", 85 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_ebonhawk/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )

	if self:GetGunnerSeat() == ply:GetVehicle() then
		if pod:GetThirdPersonMode() then
			return pos + self:GetUp() * 100, angles, fov
		end
	end

	return pos, angles, fov
end

ENT.RED = Color(255,0,0,255)
ENT.WHITE = Color(255,255,255,255)

function ENT:LVSPreHudPaint( X, Y, ply )
	local Pod = self:GetGunnerSeat()

	if Pod ~= ply:GetVehicle() then return true end

	local weapon = Pod:lvsGetWeapon()

	if not IsValid( weapon ) then return true end
	
	local Col = (self:AngleBetweenNormal( weapon:GetAimVector(), weapon:GetForward() ) > 60) and self.RED or self.WHITE

	local Pos2D = weapon:GetEyeTrace().HitPos:ToScreen() 

	self:PaintCrosshairCenter( Pos2D, Col )
	self:PaintCrosshairOuter( Pos2D, Col )
	self:LVSPaintHitMarker( Pos2D )

	return true
end

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-200,400,85), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-200,-400,85), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-200,400,110), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-200,-400,110), 0, 20, 2, 1000, 150 )
	
	self:RegisterTrail( Vector(-550,120,123), 0, 20, 2, 700, 150 )
	self:RegisterTrail( Vector(-550,-120,123), 0, 20, 2, 700, 150 )
end


function ENT:OnFrame()
	self:EngineEffects()
	self:AnimGunner()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost()
	local Mirror = false

	render.SetMaterial( self.EngineGlow )

	for i = -1,1,2 do
		local pos = self:LocalToWorld( Vector(-550,105 * i,123) )
		render.DrawSprite( pos, Size, Size, Color( 255, 150, 0, 255) )
	end
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for i = -1,1,2 do
		local vOffset = self:LocalToWorld( Vector(-570,-105 * i,123) )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )
		if not particle then return end

		particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(55,65) )
		particle:SetEndSize( math.Rand(15,5) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
				
		particle:SetColor( 255, 50, 200 )
	end
end

function ENT:AnimGunner()
	local Pod = self:GetGunnerSeat()

	if not IsValid( Pod ) then return end

	local weapon = Pod:lvsGetWeapon()

	if not IsValid( weapon ) then return end

	local EyeAngles = self:WorldToLocalAngles( weapon:GetAimVector():Angle() )
	EyeAngles:RotateAroundAxis( EyeAngles:Up(), 60 )

	local Yaw = math.Clamp( EyeAngles.y,-60,60)
	local Pitch = math.Clamp( EyeAngles.p,-60,60 )

	self:ManipulateBoneAngles( 1, Angle(-Yaw,0,0) )
	self:ManipulateBoneAngles( 2, Angle(0,0, math.max( Pitch, -25 ) ) )
end

function ENT:AnimAstromech()
end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/vulturedroid/boost.wav", 125 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/arc170/brake.wav", 125 )
end

--addons/lvs_addons/lua/entities/lvs_starfighter_eta2/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Eta-2 Interceptor"
ENT.Author = "Royster"
ENT.Information = "Eta-2 Actis-Class Light Interceptor"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/roystarwars/eta2.mdl"

ENT.AITEAM = 2

ENT.MaxVelocity = 3250
ENT.MaxThrust = 1250

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1.05
ENT.TurnRateYaw = 1.5
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 1000
ENT.MaxShield = 600

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )

	if SERVER then
		self:NetworkVarNotify( "Foils", self.OnFoilsChanged )
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(150.632,-13.724,-3.184),
		Vector(150.632,13.724-3.184),
	}

	self.LightPositions = {
		 Vector(74.669,59.924,-13.864),
		 Vector(74.669,-59.924,-13.864),
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.3
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		if not ent:GetFoils() then
			ent:SetHeat( ent:GetHeat() + 0.5 )
		end
	
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.LightPositions[ent.NumPrim]

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( CurPos )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize = 15
		bullet.Damage	= 80
		bullet.Velocity = 80000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart( Vector(0,255,0) ) 
			effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(50, 255, 50))
		effectdata:SetOrigin(bullet.Src )
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		else
			ent.SNDRight:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
		if ent.SetFoils then ent:SetFoils( true ) end
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		if not ent:GetFoils() then
			ent:SetHeat(ent:GetHeat() + 0.5)
		end
	
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( CurPos )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.025,  0.025, 0 )
		bullet.TracerName = "lvs_laser_green"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 100
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(0,255,0) ) 
				effectdata:SetOrigin( tr.HitPos )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetStart( Vector(50,255,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
		if ent.SetFoils then ent:SetFoils( true ) end
	end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/arc170/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/arc170/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_gauntlet/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Gauntlet Heavy Fighter"
ENT.Author = "Nashatok"
ENT.Information = "Modified Aggressor-class Assault Fighter, used by bounty hunter and assassin IG-88B"
ENT.Category = "[LVS] - Star Wars"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.SpawnNormalOffset = -25

ENT.MDL = "models/gauntlet/sfp_gauntlet.mdl"

ENT.AITEAM = 1

ENT.MaxVelocity = 2500
ENT.MaxThrust = 2500

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 800
ENT.MaxShield = 100

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "Foils" )
	self:AddDT( "Entity", "GunnerSeat" )
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Ammo = 600
	weapon.Delay = 0.12
	weapon.HeatRateUp = 0.34
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		local bullet = {}
		bullet.Dir 	= ent:GetForward()
		bullet.Spread 	= Vector( 0.015,  0.015, 0 )
		bullet.TracerName = "lvs_laser_yellow"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 20
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(200,150,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		for i = -1,1,2 do
			bullet.Src 	= ent:LocalToWorld( Vector(150,40 * i,172) )

			local effectdata = EffectData()
			effectdata:SetStart( Vector(200,150,50) )
			effectdata:SetOrigin( bullet.Src )
			effectdata:SetNormal( ent:GetForward() )
			effectdata:SetEntity( ent )
			util.Effect( "lvs_muzzle_colorable", effectdata )

			ent:LVSFireBullet( bullet )
		end

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )


	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 12
	weapon.Delay = 0 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.25
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.5

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector( 180, (ent._swapMissile and -180 or 180), 172 )

		local Driver = self:GetDriver()

		local projectile = ents.Create( "lvs_protontorpedo" )
		projectile:SetPos( ent:LocalToWorld( Pos ) )
		projectile:SetAngles( ent:LocalToWorldAngles( Angle(0,ent._swapMissile and 1 or -1,0) ) )
		projectile:SetParent( ent )
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker( IsValid( Driver ) and Driver or self )
		projectile:SetEntityFilter( ent:GetCrosshairFilterEnts() )
		projectile:SetSpeed( ent:GetVelocity():Length() + 4000 )

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid( ent._ProtonTorpedo ) then return end

		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.75

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
	
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Delay = 0.1
	weapon.Attack = function( ent )
		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local dir = ent:GetAimVector()

		if ent:AngleBetweenNormal( dir, ent:GetForward() ) > 60 then return true end

		local trace = ent:GetEyeTrace()

		ent.SwapTopBottom = not ent.SwapTopBottom

		local veh = ent:GetVehicle()

		veh.SNDTail:PlayOnce( 100 + math.Rand(-3,3), 1 )

		local bullet = {}
		bullet.Src = veh:LocalToWorld( ent.SwapTopBottom and Vector(-450,6,180) or Vector(-450,-6,180) )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.03,  0.03, 0.03 )
		bullet.TracerName = "lvs_laser_yellow"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 45
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(200,150,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon, 2 )
end

ENT.FlyByAdvance = 0.75
ENT.FlyBySound = "lvs/vehicles/naboo_n1_starfighter/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "eng_jedistarfighter_hi_lp.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_hyenabomber/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Hyena-Class Bomber"
ENT.Author = "Salty"
ENT.Information = "Droid Hyena Bomber of the Trade Federation"
ENT.Category = "AOCRP - KUS - Flugobjekte"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/salty/hyenaclassbomber.mdl"
ENT.GibModels = {
	"models/Salty/HyenaGib1.mdl",
	"models/Salty/HyenaGib2.mdl",
	"models/Salty/HyenaGib3.mdl",
	"models/gibs/helicopter_brokenpiece_01.mdl",
	"models/gibs/helicopter_brokenpiece_02.mdl",
	"models/gibs/helicopter_brokenpiece_03.mdl",
	"models/combine_apc_destroyed_gib02.mdl",
	"models/combine_apc_destroyed_gib04.mdl",
	"models/combine_apc_destroyed_gib05.mdl",
	"models/props_c17/trappropeller_engine.mdl",
	"models/gibs/airboat_broken_engine.mdl",
}

ENT.AITEAM = 1

ENT.MaxVelocity = 2235
ENT.MaxThrust = 2235

ENT.ThrustVtol = 100
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1.25

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 2500
ENT.MaxShield = 1000

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(78.22,-7.97,76.47),
		Vector(78.22,7.97,76.47),
	}

    -- Primary Weapon: Laser Cannons
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Delay = 0.16
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src = ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 10
		bullet.HullSize = 40
		bullet.Damage = 40
		bullet.Velocity = 60000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart( Vector(255,50,50) ) 
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent.PrimarySND:PlayOnce(95 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1, 1), 1)
	end
	weapon.OnSelect = function(ent)
        ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
    end
	weapon.OnOverheat = function(ent)
        ent:EmitSound("lvs/overheat.wav")
    end
	self:AddWeapon(weapon)

    -- Secondary Weapon: Concussion Missile
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/missile.png")
	weapon.Ammo = 100
	weapon.Delay = 0 
	weapon.HeatRateUp = -0.3
	weapon.HeatRateDown = 0.25
	weapon.Attack = function(ent)
		local T = CurTime()

		if IsValid(ent._ProtonTorpedo) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local T = CurTime()

		if (ent._nextMissle or 0) > T then return end

		ent._nextMissle = T + 0.35

		ent._swapMissile = not ent._swapMissile

		local Pos = Vector(53.12,41.35,57.04)

		local Driver = self:GetDriver()

		local projectile = ents.Create("lvs_concussionmissile")
		projectile:SetPos(ent:LocalToWorld(Pos))
		projectile:SetAngles(ent:GetAngles())
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker(IsValid( Driver ) and Driver or self)
		projectile:SetEntityFilter(ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(ent:GetVelocity():Length() + 4000)

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack( CurTime() + 0.1 ) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid(ent._ProtonTorpedo) then return end
		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/hyena/protonfire.wav", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 0.25

		ent:SetHeat( NewHeat )
		if NewHeat >= 1 then
			ent:SetOverheated( true )
		end
	end
	weapon.OnSelect = function(ent)
        ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
    end
	weapon.OnOverheat = function(ent)
        ent:EmitSound("lvs/overheat.wav")
    end
	self:AddWeapon(weapon)
	
	-- Bombs
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/bomb.png")
	weapon.Ammo = 50
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0.5
	weapon.HeatRateDown = 0.05
	weapon.Attack = function(ent)
		local base = ent:GetVehicle()
		if not IsValid(base) then return end

		local bomb = ents.Create("hyena_bomb")
		bomb:SetPos(self:LocalToWorld(Vector(50, 40, -160)))
		bomb:SetAngles(self:GetAngles())
		bomb:Spawn()
		bomb:Activate()
		bomb.Attacker = self:GetDriver()
		bomb.Inflictor = self
		bomb:SetVelocity(self:GetVelocity())

		ent:TakeAmmo()

		constraint.NoCollide(ent, base, 0, 0)
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)
end

sound.Add( {
	name = "LVS.VULTURE.FLYBY",
	sound = {"lvs/vehicles/vulturedroid/flyby.wav","lvs/vehicles/vulturedroid/flyby_a.wav","lvs/vehicles/vulturedroid/flyby_b.wav","lvs/vehicles/vulturedroid/flyby_c.wav"}
} )

ENT.FlyByAdvance = 0
ENT.FlyBySound = "LVS.VULTURE.FLYBY" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/hyena/hyenaidlesound.wav",
		Pitch = 100,
		PitchMin = 0,
		PitchMax = 105,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = false,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_t42/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "T-42"
ENT.Author = "Nashatok"
ENT.Information = "Light Interceptor designed by MandalMotors, popular among pirates and militias"
ENT.Category = "[LVS] - Star Wars"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/t42/sfp_t42.mdl"

ENT.AITEAM = 1

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 450
ENT.MaxShield = 100

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(180,40,90),
		Vector(180,-40,90),
		Vector(180,40,55),
		Vector(180,-40,55),
	}
	
	--Weapon 1 - Rapid-fire Laser Cannons
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Ammo = 1200
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 4 then self.NumPrim = 1 end

		local pod = ent:GetDriverSeat()

		if not IsValid( pod ) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull( {
			start = startpos,
			endpos = (startpos + ent:GetForward() * 50000),
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		} )

		local bullet = {}
		bullet.Src 	= ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir 	= (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread 	= Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 40
		bullet.Damage	= 30
		bullet.Velocity = 60000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )
		
		ent:LVSFireBullet( bullet )

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav") end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	self:AddWeapon( weapon )
	
	self:AddWeapon( LVS:GetWeaponPreset( "TURBO" ) )
end

ENT.FlyByAdvance = 0.75
ENT.FlyBySound = "lvs/vehicles/vwing/flyby.wav" 
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/arc170/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/lvs_addons/lua/entities/lvs_starfighter_vulture/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-25, 115, 120), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-25, -115, 120), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-25, 115, 80), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-25, -115, 80), 0, 20, 2, 1000, 150)
end

function ENT:OnFrame()
end

function ENT:OnStartBoost()
	self:EmitSound("lvs/vehicles/vulturedroid/boost.wav", 85)
end

function ENT:OnStopBoost()
	self:EmitSound("lvs/vehicles/vulturedroid/brake.wav", 85)
end
--addons/lvs_addons/lua/entities/lvs_starfighter_vwing/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color( 255, 220, 150, 255)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EngineCenter = Material( "vgui/circle" )
ENT.EnginePos = {
	[1] = Vector(-155,0,76.85),
	[2] = Vector(-155,0,41.82),
}

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if self:GetDriver() == ply and not pod:GetThirdPersonMode() then
		local newpos = pos + self:GetForward() * 37 + self:GetUp() * 8

		return newpos, angles, fov
	else
		return pos, angles, fov
	end
end

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-152,55,55), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-152,-55,55), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
	self:AnimWings()
end

function ENT:AnimWings()
	self._sm_wing = self._sm_wing or 1

	local target_wing = self:GetFoils() and 0 or 1
	local RFT = RealFrameTime() * (0.5 + math.abs( math.sin( self._sm_wing * math.pi ) ) * 0.5)
	local RateUp = RFT * 2
	local RateDown = RFT * 1.5

	self._sm_wing = self._sm_wing + math.Clamp(target_wing - self._sm_wing,-RateDown,RateUp)

	local DoneMoving = self._sm_wing == 1 or self._sm_wing == 0

	if self._oldDoneMoving ~= DoneMoving then
		self._oldDoneMoving = DoneMoving
		if not DoneMoving then
			self:EmitSound("lvs/vehicles/vwing/sfoils.wav")
		end
	end

	self:SetPoseParameter( "wings", 1 - self._sm_wing )

	self:InvalidateBoneCache()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 255, 200, 50 )
	end
end

function ENT:PostDraw()
	if not self:GetEngineActive() then return end

	cam.Start3D2D( self:LocalToWorld( Vector(-136,0,76.85) ), self:LocalToWorldAngles( Angle(-90,0,0) ), 1 )
		surface.SetDrawColor( self.EngineColor )
		surface.SetMaterial( self.EngineCenter )
		surface.DrawTexturedRectRotated( 0, 0, 20, 20 , 0 )
		surface.SetDrawColor( color_white )
		surface.SetMaterial( self.EngineGlow )
		surface.DrawTexturedRectRotated( 0, 0, 20, 20 , 0 )
	cam.End3D2D()
	
	cam.Start3D2D( self:LocalToWorld( Vector(-136,0,41.82) ), self:LocalToWorldAngles( Angle(-90,0,0) ), 1 )
		surface.SetDrawColor( self.EngineColor )
		surface.SetMaterial( self.EngineCenter )
		surface.DrawTexturedRectRotated( 0, 0, 20, 20 , 0 )
		surface.SetDrawColor( color_white )
		surface.SetMaterial( self.EngineGlow )
		surface.DrawTexturedRectRotated( 0, 0, 20, 20 , 0 )
	cam.End3D2D()
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 60 + self:GetThrottle() * 60 + self:GetBoost()

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/vwing/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vwing/brake.wav", 85 )
end

--addons/lvs_addons/lua/entities/lvs_turret_av_red/shared.lua:
ENT.Base = "lvs_base_turret"

ENT.PrintName = "Anti-Vehicle Turret"
ENT.Author = "Luna"
ENT.Information = "Hard-hitting, but very limited firing arc. Good for dealing with pesky tanks."
ENT.Category = "[LVS] - Turrets (CIS)"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/antivehicleturret/Anti-VehicleTurret.mdl"

ENT.AITEAM = 1

ENT.MaxVelocity = 3000
ENT.MaxThrust = 3000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1
ENT.ForceAngleDampingMultiplier = 1

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_DROP_IN_AIR = true
ENT.LAATC_PICKUP_POS = Vector(-200,0,25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

ENT.MaxHealth = 7500


function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )
	self:AddDT( "Entity", "GunnerSeat" )
	self:AddDT( "Float", "TurretPitch" )
	self:AddDT( "Float", "TurretYaw" )

	if SERVER then
		self:NetworkVarNotify( "IsCarried", self.OnIsCarried )
	end
end

function ENT:TraceTurret()
	local ID = self:LookupAttachment( "muzzle" )
	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return end

	local dir = Muzzle.Ang:Up()
	local pos = Muzzle.Pos

	local trace = util.TraceLine( {
		start = pos,
		endpos = (pos + dir * 50000),
	} )

	return trace
end

function ENT:GetAimAngles( ent )
    local trace = ent:GetEyeTrace()
    local AimAngles = self:WorldToLocalAngles( (trace.HitPos - self:LocalToWorld( Vector(0,0,30) ) ):GetNormalized():Angle() )

    return AimAngles
end

function ENT:WeaponsInRange( ent )
    local AimAngles = self:GetAimAngles( ent )

    return not (AimAngles.p >= 8 or AimAngles.p <= -10)
end

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.5
	weapon.HeatRateUp = 0.67
	weapon.HeatRateDown = 0.2
    weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local base = ent:GetVehicle()

		local ID = self:LookupAttachment( "muzzle" )
		local Muzzle = self:GetAttachment( ID )

		if not Muzzle then return end	

		local Pos = Muzzle.Pos
		local Dir = Muzzle.Ang:Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.01,  0.01, 0.01)
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 450
		bullet.Velocity = 20000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_explosion", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		base.PrimarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
		ent:LVSFireBullet( bullet )
		
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )	
		if ent:GetVehicle():GetIsCarried( ent ) then
			self:SetPoseParameter("turret_pitch", 0 )
			self:SetPoseParameter("turret_yaw", 0 )
		end
		
		local AimAngles = self:GetAimAngles( ent )

		self:SetPoseParameter("turret_pitch", AimAngles.p )
		self:SetPoseParameter("turret_yaw", AimAngles.y )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
	
	
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/dual_mg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.5
    weapon.Attack = function( ent )
        if not ent:GetVehicle():WeaponsInRange( ent ) then return true end
		local base = ent:GetVehicle()

		local ID_L = self:LookupAttachment( "muzzle_left" )
		local ID_R = self:LookupAttachment( "muzzle_right" )
		local MuzzleLeft = self:GetAttachment( ID_L )
		local MuzzleRight = self:GetAttachment( ID_R )

		if not MuzzleLeft or not MuzzleRight then return end		

		ent.MirrorPrimary = not ent.MirrorPrimary

		local Pos = ent.MirrorPrimary and MuzzleLeft.Pos or MuzzleRight.Pos
		local Dir =  (ent.MirrorPrimary and MuzzleLeft.Ang or MuzzleRight.Ang):Up()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector( 0.015,  0.015, 0.015 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force	= 10
		bullet.HullSize 	= 25
		bullet.Damage	= 35
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart( Vector(255,50,50) ) 
				effectdata:SetOrigin( tr.HitPos )
				effectdata:SetNormal( tr.HitNormal )
			util.Effect( "lvs_laser_impact", effectdata )
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		base.SecondarySND:PlayOnce( 100 + math.Rand(-3,3), 1 )
		ent:LVSFireBullet( bullet )
		
	end
	weapon.OnSelect = function( ent ) ent:EmitSound("physics/metal/weapon_impact_soft3.wav")end
	weapon.OnOverheat = function( ent ) ent:EmitSound("lvs/overheat.wav") end
	weapon.OnThink = function( ent, active )	
		if ent:GetVehicle():GetIsCarried( ent ) then
			self:SetPoseParameter("turret_pitch", 0 )
			self:SetPoseParameter("turret_yaw", 0 )
		end
		
		local AimAngles = self:GetAimAngles( ent )

		self:SetPoseParameter("turret_pitch", AimAngles.p )
		self:SetPoseParameter("turret_yaw", AimAngles.y )
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()

		if not IsValid( base ) then return end

		local Pos2D = base:TraceTurret().HitPos:ToScreen()

		base:PaintCrosshairCenter( Pos2D, color_white )
		base:PaintCrosshairOuter( Pos2D, color_white )
		base:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon, 2 )
end

ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"
--addons/lvs_addons/lua/entities/lvs_v19/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
end

ENT.EngineColor = Color( 129, 228, 218, 255)
ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EnginePos = {
		Vector(-215,-122.3,8.38),
		Vector(-215,122.3,8.38),
		Vector(-25.93,0,225.85),
	}

function ENT:OnFrame()
	self:EngineEffects()
	self:AnimWings()
end

function ENT:OnWingsChanged()
	if not self:GetWingsDown() then
		self.EnginePos = {
			Vector(-215,-122.3,8.38),
			Vector(-215,122.3,8.38),
		}
		local function EngineTimer()
			self.EnginePos = {
			Vector(-140,0,-207.25),
			Vector(-215.42,-122.3,8.38),
			Vector(-215.42,122.3,8.38),
			}
		end
		timer.Simple(0.5, EngineTimer)
		
	else
		self.EnginePos = {
			Vector(-215,-122.3,8.38),
			Vector(-215,122.3,8.38),
		}
		local function EngineTimer()
			self.EnginePos = {
			Vector(-25.93,0,225.85),
			Vector(-215.42,-122.3,8.38),
			Vector(-215.42,122.3,8.38),
			}
		end
		timer.Simple(0.5, EngineTimer)
	end
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, pos in pairs( self.EnginePos ) do
		local vOffset = self:LocalToWorld( pos )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(25,35) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 129, 228, 218 )
	end
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

	render.SetMaterial( self.EngineGlow )

	for _, pos in pairs( self.EnginePos ) do
		render.DrawSprite(  self:LocalToWorld( pos ), Size, Size, self.EngineColor )
	end

end

function ENT:AnimCockpit()
end

function ENT:OnStartBoost()
	self:EmitSound( "ARC170_BOOST", 70 )
end

function ENT:OnStopBoost()
	self:EmitSound( "ARC170_BRAKE", 70 )
end

function ENT:AnimWings()

	self._sm_wing = self._sm_wing or 1
	
	local RFT = RealFrameTime() * 10
	
	local target_wing = self:GetWingsDown() and 0 or 1

	local Rate = RFT * 0.2

	self._sm_wing = self._sm_wing + math.Clamp(target_wing - self._sm_wing,-Rate,Rate)

	local DoneMoving = self._sm_wing == 1 or self._sm_wing == 0

	local Ang = (1 - self._sm_wing) * 180

	local A5 = Ang
	local A6 = Ang
    local A7 = -Ang

	self:ManipulateBoneAngles( 2, Angle(0,0,A5*0.7) )
	self:ManipulateBoneAngles( 1, Angle(0,0,A7*0.7) )
	self:ManipulateBoneAngles( 3, Angle(0,A6,0) )

	self:InvalidateBoneCache()
end

--addons/lvs_addons/lua/entities/lvs_vehicle_spammer.lua:

AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "AI Vehicle Spammer"
ENT.Author = "Luna"
ENT.Information = "AI Vehicle Spawner. Spammer in the hands of a Minge."
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false
ENT.Editable = true

function ENT:SetupDataTables()
	local AllSents = scripted_ents.GetList() 
	local SpawnOptions = {}

	for _, v in pairs( AllSents ) do
		if not v or not istable( v.t ) or not v.t.Spawnable then continue end

		if v.t.Base and v.t.Base:lower() == "lvs_base_wheeldrive" and not v.t.lvsShowInSpawner then continue end

		if v.t.lvsShowInSpawner == false then continue end

		if v.t.lvsShowInSpawner or (v.t.Base and (string.StartWith( v.t.Base:lower(), "lvs_base" ) or string.StartWith( v.t.Base:lower(), "lunasflightschool" ))) then
			if v.t.Category and v.t.PrintName then
				local nicename = v.t.Category.." - "..v.t.PrintName
				if not table.HasValue( SpawnOptions, nicename ) then
					SpawnOptions[nicename] = v.t.ClassName
				end
			end
		end
	end

	self:NetworkVar( "String",0, "Type",	{ KeyName = "Vehicle Type",Edit = { type = "Combo",	order = 1,values = SpawnOptions,category = "Vehicle-Options"} } )
	self:NetworkVar( "Int",3, "TeamOverride", { KeyName = "AI Team", Edit = { type = "Int", order = 4,min = -1, max = 3, category = "Vehicle-Options"} } )
	self:NetworkVar( "Int",4, "RespawnTime", { KeyName = "spawntime", Edit = { type = "Int", order = 5,min = 1, max = 120, category = "Vehicle-Options"} } )
	self:NetworkVar( "Int",5, "Amount", { KeyName = "amount", Edit = { type = "Int", order = 6,min = 1, max = 10, category = "Vehicle-Options"} } )
	self:NetworkVar( "Int",6, "SpawnWithSkin", { KeyName = "spawnwithskin", Edit = { type = "Int", order = 8,min = 0, max = 16, category = "Vehicle-Options"} } )
	self:NetworkVar( "Int",7, "SpawnWithHealth", { KeyName = "spawnwithhealth", Edit = { type = "Int", order = 9,min = 0, max = 50000, category = "Vehicle-Options"} } )
	self:NetworkVar( "Int",8, "SpawnWithShield", { KeyName = "spawnwithshield", Edit = { type = "Int", order = 10,min = 0, max = 50000, category = "Vehicle-Options"} } )

	self:NetworkVar( "Int",10, "SelfDestructAfterAmount", { KeyName = "selfdestructafteramount", Edit = { type = "Int", order = 22,min = 0, max = 100, category = "Spawner-Options"} } )
	self:NetworkVar( "Bool",2, "MasterSwitch" )

	if SERVER then
		self:NetworkVarNotify( "Type", self.OnTypeChanged )

		self:SetRespawnTime( 2 )
		self:SetAmount( 1 )
		self:SetSelfDestructAfterAmount( 0 )
		self:SetSpawnWithHealth( 0 )
		self:SetSpawnWithShield( 0 )
		self:SetTeamOverride( -1 )
	end
end

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal * 1 )
		ent:Spawn()
		ent:Activate()

		return ent

	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:Initialize()	
		self:SetModel( "models/hunter/plates/plate8x8.mdl" )
		
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )
		self:DrawShadow( false )

		self:SetCollisionGroup( COLLISION_GROUP_WORLD )
		
		self.NextSpawn = 0
	end

	function ENT:Use( ply )
		if not IsValid( ply ) then return end

		if not IsValid( self.Defusor ) then
			self.Defusor = ply
			self.DefuseTime = CurTime()
		end
	end
	
	function ENT:Think()
		if IsValid( self.Defusor ) and isnumber( self.DefuseTime ) then
			if self.Defusor:KeyDown( IN_USE ) then
				if CurTime() - self.DefuseTime > 1 then
					self:SetMasterSwitch( not self:GetMasterSwitch() )

					for k, v in pairs( ents.FindByClass( "lvs_vehicle_spammer" ) ) do
						if v ~= self and IsValid( v ) then
							v:SetMasterSwitch( self:GetMasterSwitch() )
						end
					end

					if self:GetMasterSwitch() then
						self.Defusor:PrintMessage( HUD_PRINTTALK, "ALL AI-Spawners Enabled")
					else
						self.Defusor:PrintMessage( HUD_PRINTTALK, "ALL AI-Spawners Disabled")
					end

					self.Defusor = nil
				end
			else
				self:SetMasterSwitch( not self:GetMasterSwitch() )

				if self:GetMasterSwitch() then
					self.Defusor:PrintMessage( HUD_PRINTTALK, "AI-Spawner Enabled")
				else
					self.Defusor:PrintMessage( HUD_PRINTTALK, "AI-Spawner Disabled")
				end

				self.Defusor = nil
			end
		end

		if not self:GetMasterSwitch() then return end

		self.spawnedvehicles = self.spawnedvehicles or {}

		if self.ShouldSpawn then
			if self.NextSpawn < CurTime() then
				
				self.ShouldSpawn = false
				
				local pos = self:LocalToWorld( Vector( 0, 0, 150 ) )
				local ang = self:LocalToWorldAngles( Angle( 0, 90, 0 ) )
				
				local Type = self:GetType()
				
				if Type ~= "" then
					local spawnedvehicle = ents.Create( Type )
					
					if IsValid( spawnedvehicle ) then
						if spawnedvehicle.SpawnNormalOffsetSpawner then
							spawnedvehicle:SetPos( self:LocalToWorld( Vector(0,0,spawnedvehicle.SpawnNormalOffsetSpawner) ) )
						else
							spawnedvehicle:SetPos( pos + Vector(0,0,spawnedvehicle.SpawnNormalOffset or 0) )
						end
						spawnedvehicle:SetAngles( ang )
						spawnedvehicle:Spawn()
						spawnedvehicle:Activate()
						spawnedvehicle:SetAI( true )
						spawnedvehicle:SetSkin( self:GetSpawnWithSkin() )
						spawnedvehicle.SpawnedByAISpawner = true

						if self:GetTeamOverride() >= 0 then
							spawnedvehicle:SetAITEAM( self:GetTeamOverride() )
						end

						if self:GetSpawnWithHealth() > 0 then
							spawnedvehicle.MaxHealth = self:GetSpawnWithHealth()
							spawnedvehicle:SetHP( self:GetSpawnWithHealth() )
						end
	
						if self:GetSpawnWithShield() > 0 then
							spawnedvehicle.MaxShield = self:GetSpawnWithShield()
							spawnedvehicle:SetShield( self:GetSpawnWithShield() )
						end

						if spawnedvehicle.LFS and not spawnedvehicle.DontPushMePlease then
							local PhysObj = spawnedvehicle:GetPhysicsObject()
							
							if IsValid( PhysObj ) then
								PhysObj:SetVelocityInstantaneous( -self:GetRight() * 1000 )
							end
						end

						table.insert( self.spawnedvehicles, spawnedvehicle )

						if self:GetSelfDestructAfterAmount() > 0 then
							self.RemoverCount = isnumber( self.RemoverCount ) and self.RemoverCount + 1 or 1

							if self.RemoverCount >= self:GetSelfDestructAfterAmount() then
								self:Remove()
							end
						end
					end
				end
			end
		else
			local AmountSpawned = 0
			for k,v in pairs( self.spawnedvehicles ) do
				if IsValid( v ) then
					AmountSpawned = AmountSpawned + 1
				else
					self.spawnedvehicles[k] = nil
				end
			end

			if AmountSpawned < self:GetAmount() then
				self.ShouldSpawn = true
				self.NextSpawn = CurTime() + self:GetRespawnTime()
			end
		end

		self:NextThink( CurTime() )

		return true
	end
end

if CLIENT then
	local WhiteList = {
		["weapon_physgun"] = true,
		["weapon_physcannon"] = true,
		["gmod_tool"] = true,
	}

	local TutorialDone = false
	local mat = Material( "models/wireframe" )
	local FrameMat = Material( "lvs/3d2dmats/frame.png" )
	local ArrowMat = Material( "lvs/3d2dmats/arrow.png" )

	function ENT:Draw()
		local ply = LocalPlayer()

		if not IsValid( ply ) then return end

		if TutorialDone then
			if GetConVarNumber( "cl_draweffectrings" ) == 0 then return end

			local wep = ply:GetActiveWeapon()

			if not IsValid( wep ) then return end

			local weapon_name = wep:GetClass()

			if not WhiteList[ weapon_name ] then
				return
			end
		else
			local wep = ply:GetActiveWeapon()

			if not IsValid( wep ) then return end

			local weapon_name = wep:GetClass()

			if not WhiteList[ weapon_name ] then
				if weapon_name == "gmod_camera" then return end

				local Trace = ply:GetEyeTrace()
				if Trace.Entity ~= self or (ply:GetShootPos() - Trace.HitPos):Length() > 800 then return end
			end
		end

		local Pos = self:GetPos()
		local R = 190
		render.SetMaterial( mat )
		render.DrawBox( Pos, self:GetAngles(), Vector(-R,-R,0), Vector(R,R,200), color_white )

		for i = 0, 180, 180 do
			cam.Start3D2D( Pos, self:LocalToWorldAngles( Angle(i,0,0) ), 0.185 )
				if self:GetMasterSwitch() then
					local T4 = CurTime() * 4

					local OY = math.cos( T4 )
					local A = math.max( math.sin( T4 ), 0 )
		
					surface.SetMaterial( ArrowMat )

					if self:GetType() == "" then
						surface.SetDrawColor( 255, 0, 0, A * 255 )
						surface.DrawTexturedRect( -512, -512 + OY * 512, 1024, 1024 )

						surface.SetDrawColor( 255, 0, 0, math.abs( math.cos( T4 ) ) ^ 2 * 255  )
					else
						surface.SetDrawColor( 0, 127, 255, A * 255 )
						surface.DrawTexturedRect( -512, -512 + OY * 512, 1024, 1024 )

						surface.SetDrawColor( 0, 127, 255, 255 )
					end
				else
					surface.SetDrawColor( 255, 0, 0, 255 )
		
					surface.SetMaterial( ArrowMat )
					surface.DrawTexturedRect( -512, -512, 1024, 1024 )
				end

				surface.SetMaterial( FrameMat )
				surface.DrawTexturedRect( -1024, -1024, 2048, 2048 )
			cam.End3D2D()
		end
	end

	hook.Add( "HUDPaint", "!!!!!!!11111lvsvehiclespammer_tutorial", function()
		if TutorialDone then
			hook.Remove( "HUDPaint", "!!!!!!!11111lvsvehiclespammer_tutorial" )
		end

		local ply = LocalPlayer()

		if ply:InVehicle() then return end

		local trace = ply:GetEyeTrace()
		local Dist = (ply:GetShootPos() - trace.HitPos):Length()

		if Dist > 800 then return end

		local Ent = trace.Entity

		if not IsValid( Ent ) then return end

		if Ent:GetClass() ~= "lvs_vehicle_spammer" then return end

		local pos = Ent:GetPos()
		local scr = pos:ToScreen()
		local Alpha = 255

		if Ent:GetType() == "" then
			draw.SimpleText( "Hold C => Right Click on me => Edit Properties => Choose a Type", "LVS_FONT", scr.x, scr.y - 10, Color(255,255,255,Alpha), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		else
			if not Ent:GetMasterSwitch() then
				local Key = input.LookupBinding( "+use" )
				if not isstring( Key ) then Key = "+use is not bound to a key" end

				draw.SimpleText( "Now press ["..Key.."] to enable!", "LVS_FONT", scr.x, scr.y - 10, Color(255,255,255,Alpha), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				draw.SimpleText( "or hold ["..Key.."] to enable globally!", "LVS_FONT", scr.x, scr.y + 10, Color(255,255,255,Alpha), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			else
				TutorialDone = true
			end
		end
	end )
end
--addons/lvs_addons/lua/entities/lvs_walker_atrt/cl_init.lua:
include("shared.lua")

function ENT:OnFrame()
	self:AnimGunner()
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if ply == self:GetDriver() and not pod:GetThirdPersonMode() then
		return pos + self:GetForward() * 60 - self:GetUp() * 30, angles, fov
	end

	return pos, angles, fov
end

function ENT:AnimGunner()
	if IsValid(self:GetDriver()) then
		local Aim = self:GetDriver():EyeAngles()

		local AimX = math.Clamp(Aim.x, -30, 30)
		local AimZ = math.Clamp(Aim.y, 10, 160)

		self:ManipulateBoneAngles(self:LookupBone("turret_x"), Angle(0, 0, AimX))
		self:ManipulateBoneAngles(self:LookupBone("turret_z"), Angle(AimZ - 90, 0, 0))

		return true
	else
		self:ManipulateBoneAngles(self:LookupBone("turret_x"), Angle(0,0,0))
		self:ManipulateBoneAngles(self:LookupBone("turret_z"), Angle(0,0,0))
	end
end

function ENT:LVSHudPaint(X, Y, ply)
	if self:GetIsCarried() then return end

	local Pos2D = self:GetEyeTrace().HitPos:ToScreen()

	local dir = self:GetAimVector()
	if self:AngleBetweenNormal(dir, self:GetForward()) > 60 then return true end
	if self:AngleBetweenNormal(dir, self:GetUp()) > 120 then return true end

	local InRange = self:AngleBetweenNormal(dir, self:GetForward()) > 60 or self:AngleBetweenNormal(dir, self:GetUp()) > 120

	local col = InRange and white or red
	self:PaintCrosshairCenter(Pos2D, col)
	self:PaintCrosshairOuter(Pos2D, col)
	self:LVSPaintHitMarker(Pos2D)
end

--addons/weapons_other/lua/entities/mk5.lua:
AddCSLuaFile()

if SERVER then
	resource.AddFile( "materials/entities/jetpack2.png" )
end

DEFINE_BASECLASS( "jetpack_base" )

ENT.Spawnable = false
ENT.PrintName = "Jump Pack"

if CLIENT then
	ENT.MatHeatWave		= Material( "sprites/heatwave" )
	ENT.MatFire			= Material( "effects/fire_cloud1" )


	AccessorFunc( ENT , "NextParticle" , "NextParticle" )
	AccessorFunc( ENT , "LastActive" , "LastActive" )
	AccessorFunc( ENT , "LastFlameTrace" , "LastFlameTrace" )
	AccessorFunc( ENT , "NextFlameTrace" , "NextFlameTrace" )

	ENT.MaxEffectsSize = 0.25
	ENT.MinEffectsSize = 0.1



	ENT.JetpackFireBlue = Color( 0 , 0 , 255 , 128 )
	ENT.JetpackFireWhite = Color( 255 , 255 , 255 , 128 )
	ENT.JetpackFireNone = Color( 255 , 255 , 255 , 0 )
	ENT.JetpackFireRed = Color( 255 , 128 , 128 , 255 )

else

	ENT.StandaloneApeShitAngular = Vector( 0 , 10 , 10 )	--do a corkscrew
	ENT.StandaloneApeShitLinear = Vector( 0 , 0 , 0 )

	ENT.StandaloneAngular = vector_origin
	ENT.StandaloneLinear = Vector( 0 , 0 , 0 )

	ENT.ShowPickupNotice = true
	ENT.SpawnOnGroundConVar = CreateConVar(
		"sv_spawnjetpackonground" ,
		"0",
		{
			FCVAR_SERVER_CAN_EXECUTE,
			FCVAR_ARCHIVE
		},
		"When true, it will spawn the jetpack on the ground, otherwise it will try equipping it right away, if you already have one equipped it will not do anything"
	)
end

--use this to calculate the position on the parent because I can't be arsed to deal with source's parenting bullshit with local angles and position
--plus this is also called during that parenting position recompute, so it's perfect

ENT.AttachmentInfo = {
	BoneName = "ValveBiped.Bip01_Spine2",
	OffsetVec = Vector( 3.5 , -6 , -0.2 ),
	OffsetAng = Angle( 180 , 90 , -91 ),
}

sound.Add( {
	name = "jetpack.thruster_loop_new2",
	channel = CHAN_ITEM,
	volume = 1.0,
	level = 75,
	sound = "everfall/equipment/jetpack/jumptrooper/rocket_loop/jetpack_jumpcop_rocketloop_01.mp3"
})

local sv_gravity = GetConVar "sv_gravity"

function ENT:SpawnFunction( ply, tr, ClassName )

	if not tr.Hit then return end

	local SpawnPos = tr.HitPos + tr.HitNormal * 36

	local ent = ents.Create( ClassName )
	ent:SetSlotName( ClassName )	--this is the best place to set the slot, only modify it ingame when it's not equipped
	ent:SetPos( SpawnPos )
	ent:SetAngles( Angle( 90 , 0 , 0 ) )
	ent:Spawn()

	--try equipping it, if we can't we'll just remove it
	if not self.SpawnOnGroundConVar:GetBool() then
		--forced should not be set here, as we still kinda want the equip logic to work as normal
		if not ent:Attach( ply , false ) then
			ent:Remove()
			return
		end
	end

	return ent

end

function ENT:Initialize()
	BaseClass.Initialize( self )
	if SERVER then
		self:SetModel( "models/hunter/plates/plate.mdl" )
		self:SetMaterial ( "Models/effects/vol_light001" )
		self:InitPhysics()

		self:SetMaxHealth( 100 )
		self:SetHealth( self:GetMaxHealth() )

		self:SetInfiniteFuel( false )
		self:SetMaxFuel(100)
		self:SetFuel( self:GetMaxFuel() )
		self:SetFuelDrain(12)	--drain in seconds
		self:SetFuelRecharge( 17 )	--recharge in seconds
		self:SetActive( false )
		self:SetCanStomp( false )
		self:SetDoGroundSlam( false )
		self:SetAirResistance( 3.5 )
		self:SetRemoveGravity( true )
		self:SetJetpackSpeed( 2500 )
		self:SetJetpackStrafeSpeed( 600 )
		self:SetJetpackVelocity( 900 )
		self:SetJetpackStrafeVelocity( 5000 )
	else
		self:SetLastActive( false )
		self:SetNextParticle( 0 )
		self:SetNextFlameTrace( 0 )
		self:SetLastFlameTrace( nil )
	end
end

function ENT:SetupDataTables()
	BaseClass.SetupDataTables( self )

	self:DefineNWVar( "Bool" , "Active" )
	self:DefineNWVar( "Bool" , "GoneApeshit" , true )	--set either when the owner dies with us active, or when we're being shot at
	self:DefineNWVar( "Bool" , "RemoveGravity" )
	self:DefineNWVar( "Bool" , "InfiniteFuel" , true , "Infinite Fuel" )
	self:DefineNWVar( "Bool" , "DoGroundSlam" )
	self:DefineNWVar( "Bool" , "CanStomp" , true , "Can stomp" )

	self:DefineNWVar( "Float" , "Fuel" )
	self:DefineNWVar( "Float" , "MaxFuel" )	--don't modify the max amount, the drain scales anyway, set to -1 to disable the fuel drain
	self:DefineNWVar( "Float" , "FuelDrain" , true , "Seconds to drain fuel" , 2 , 80 ) --how many seconds it's gonna take to drain all the fuel
	self:DefineNWVar( "Float" , "FuelRecharge" , true , "Seconds to recharge the fuel" , 1 , 60 ) --how many seconds it should take to fully recharge this
	self:DefineNWVar( "Float" , "AirResistance" , true , "Air Resistance" , 0 , 10 )
	self:DefineNWVar( "Float" , "GoneApeshitTime" ) --only used if infinite fuel is on

	self:DefineNWVar( "Int" , "Key" )	--override it to disallow people from editing the key since it's unused
	self:DefineNWVar( "Int" , "JetpackSpeed" , true , "Jetpack idle upward speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackStrafeSpeed" , true , "Jetpack idle side speed" , 1 , 1000 )
	self:DefineNWVar( "Int" , "JetpackVelocity" , true , "Jetpack active upward speed" , 1 , 3000 )
	self:DefineNWVar( "Int" , "JetpackStrafeVelocity" , true , "Jetpack active side speed" , 1 , 3000 )

end

function ENT:HandleFly( predicted , owner , movedata , usercmd )
	self:SetActive( self:CanFly( owner , movedata ) )

	--we have infinite fuel and the apeshit timeout hasn't been set, do it now
	--this is most useful because I CBA to do that everytime ok?
	--also it's serverside only because we only set the apeshit on the server anyway

	if SERVER then
		if self:GetGoneApeshit() and self:GetGoneApeshitTime() == 0 and self:GetInfiniteFuel() then
			self:SetGoneApeshitTime( CurTime() + 5 )
		end
	end

	--the check below has to be done with prediction on the client!

	if CLIENT and not predicted then
		return
	end

	--fixes a bug where if you set goneapeshit manually via the contextmenu and the physobj is asleep it wouldn't apply the simulated forces
	if SERVER and not predicted and self:GetGoneApeshit() then
		local physobj = self:GetPhysicsObject()
		if IsValid( physobj ) and physobj:IsAsleep() then
			physobj:Wake()
		end
	end

	--if we have an apeshit timeout, calm us down ( this doesn't check for infinite fuel, in case we did this manually )
	if self:GetGoneApeshit() and self:GetGoneApeshitTime() ~= 0 and self:GetGoneApeshitTime() <= CurTime() then
		self:SetGoneApeshit( false )
		self:SetGoneApeshitTime( 0 )
	end
end

function ENT:HandleFuel( predicted )

	--like with normal rules of prediction, we don't want to run on the client if we're not in the simulation

	if not predicted and CLIENT then
		return
	end

	--we set the think rate on the entity to the tickrate on the server, we could've done NextThink() - CurTime(), but it's only a setter, not a getter
	local ft = engine.TickInterval()

	--screw that, during prediction we need to recharge with FrameTime()
	if predicted then
		ft = FrameTime()
	end

	local fueltime = self:GetActive() and self:GetFuelDrain() or self:GetFuelRecharge()

	local fuelrate = self:GetMaxFuel() / ( fueltime / ft )

	if self:GetActive() then
		fuelrate = fuelrate * -1

		if self:GetGoneApeshit() then
			--drain twice as much fuel if we're going craaaazy
			fuelrate = fuelrate * 2
		end

		--don't drain any fuel when infinite fuel is on, but still allow recharge
		if self:GetInfiniteFuel() then
			fuelrate = 0
		end
	else
		--recharge in different ways if we have an owner or not, because players might drop and reequip the jetpack to exploit the recharging
		if IsValid( self:GetControllingPlayer() ) then
			--can't recharge until our owner is on the ground!
			--prevents the player from tapping the jump button to fly and recharge at the same time
			if not self:GetControllingPlayer():OnGround() then
				fuelrate = 0
			end
		else
			--only recharge if our physobj is sleeping and it's valid ( should never be invalid in the first place )
			local physobj = self:GetPhysicsObject()
			if not IsValid( physobj ) or not physobj:IsAsleep() then
				fuelrate = 0
			end
		end
	end

	--holy shit, optimization??
	if fuelrate ~= 0 then
		self:SetFuel( math.Clamp( self:GetFuel() + fuelrate , 0 , self:GetMaxFuel() ) )
	end

	--we exhausted all of our fuel, chill out if we're crazy
	if not self:HasFuel() and self:GetGoneApeshit() then
		self:SetGoneApeshit( false )
	end
end

function ENT:HandleLoopingSounds()

	--create the soundpatch if it doesn't exist, it might happen on the client sometimes since it's garbage collected

	if not self.JetpackSound then
		self.JetpackSound = CreateSound( self, "jetpack.thruster_loop_new2" )
	end

	if self:GetActive() then
		local pitch = 125

		if self:GetGoneApeshit() then
			pitch = 175
		end

		self.JetpackSound:PlayEx( 0.5  , pitch )
	else
		self.JetpackSound:FadeOut( 0.1 )
	end
end

function ENT:HasFuel()
	return self:GetFuel() > 0
end

function ENT:GetFuelFraction()
	return self:GetFuel() / self:GetMaxFuel()
end

function ENT:CanFly( owner , mv )


	if IsValid( owner ) then

		--don't care about player inputs in this case, the player's jetpack is going craaazy

		if self:GetGoneApeshit() then
			return owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and self:HasFuel()
		end

		return ( mv:KeyDown( IN_JUMP ) or mv:KeyDown( IN_DUCK ) or mv:KeyDown( IN_SPEED ) ) and not owner:OnGround() and owner:WaterLevel() == 0 and owner:GetMoveType() == MOVETYPE_WALK and owner:Alive() and self:HasFuel()
	end

	--making it so the jetpack can also fly on its own without an owner ( in the case we want it go go nuts if the player dies or some shit )
	if self:GetGoneApeshit() then
		return self:WaterLevel() == 0 and self:HasFuel()
	end

	return false
end

function ENT:Think()

	--still act if we're not being held by a player
	if not self:IsCarried() then
		self:HandleFly( false )
		self:HandleFuel( false )
	end

	--animation related stuff should be fine to call here



	return BaseClass.Think( self )
end

function ENT:PredictedSetupMove( owner , mv , usercmd )

	self:HandleFly( true , owner , mv , usercmd )
	self:HandleFuel( true )

	if self:GetActive() then

		local vel = mv:GetVelocity()

		if mv:KeyDown( IN_JUMP ) and vel.z < self:GetJetpackSpeed() then

			-- Apply constant jetpack_velocity
			--self:EmitSound("everfall/equipment/jetpack/jumptrooper/thrust/jetpack_jumpcop_thrust_var_0".. math.random(1, 7) ..".mp3")

			vel.z = vel.z + self:GetJetpackVelocity() * FrameTime()

		elseif mv:KeyDown( IN_SPEED ) and vel.z < 0 then

			-- Apply just the right amount of thrust

			vel.z = math.Approach( vel.z , 0 , self:GetJetpackVelocity() * FrameTime() )

		end



		-- Quickly descend to do a ground slam, don't check for the velocity cap, we want to slam down as fast as we can
		if self:GetCanStomp() then
			self:SetDoGroundSlam( mv:KeyDown( IN_DUCK ) )
		end

		--even if the user can't stomp, we still allow him to go down by crouching

		if mv:KeyDown( IN_DUCK ) then
			vel.z = vel.z - self:GetJetpackVelocity() * FrameTime()
		end

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--

		if vel.z == 0 then

			self:SetRemoveGravity( true )

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

		end

		--
		-- Apply movement velocity
		--

		local move_vel = Vector( 0, 0, 0 )

		local ang = mv:GetMoveAngles()
		ang.p = 0

		move_vel:Add( ang:Right() * mv:GetSideSpeed() )
		move_vel:Add( ang:Forward() * mv:GetForwardSpeed() )

		move_vel:Normalize()
		move_vel:Mul( self:GetJetpackStrafeVelocity() * FrameTime() )

		if vel:Length2D() < self:GetJetpackStrafeSpeed() then

			vel:Add( move_vel )

		end

		--TODO: goneapeshit stuff, do it before air resistance

		if self:GetGoneApeshit() then
			--boost us in the direction the jetpack is facing in the world ( actual third person angles )
			--ragdolling the user and attaching us to the ragdoll would be quite expensive and wouldn't be worth it
			--as cool as that might look, that might also break stuff in other gamemodes

			local addvel = self:GetAngles():Up() * -1 * self:GetJetpackVelocity() * FrameTime()
			vel:Add( addvel )
		end

		--
		-- Apply air resistance
		--
		vel.x = math.Approach( vel.x, 0, FrameTime() * self:GetAirResistance() * vel.x )
		vel.y = math.Approach( vel.y, 0, FrameTime() * self:GetAirResistance() * vel.y )

		--
		-- Write our calculated velocity back to the CMoveData structure
		--
		mv:SetVelocity( vel )

		mv:SetForwardSpeed( 0 )
		mv:SetSideSpeed( 0 )
		mv:SetUpSpeed( 0 )

		-- Removes the crouch button from the movedata, effectively disabling the crouching behaviour

		mv:SetButtons( bit.band( mv:GetButtons(), bit.bnot( IN_DUCK ) ) )

	end
end

function ENT:PredictedThink( owner , movedata )
end

function ENT:PredictedMove( owner , data )
	if self:GetActive() and self:GetGoneApeshit() then
		owner:SetGroundEntity( NULL )
	end
end

function ENT:PredictedFinishMove( owner , movedata )
	if self:GetActive() then

		--
		-- Remove gravity when velocity is supposed to be zero for hover mode
		--
		if self:GetRemoveGravity() then
			local vel = movedata:GetVelocity()

			vel.z = vel.z + sv_gravity:GetFloat() * 0.5 * FrameTime()

			movedata:SetVelocity( vel )

			self:SetRemoveGravity( false )
		end

	end
end

local	SF_PHYSEXPLOSION_NODAMAGE			=	0x0001
local	SF_PHYSEXPLOSION_PUSH_PLAYER		=	0x0002
local	SF_PHYSEXPLOSION_RADIAL				=	0x0004
local	SF_PHYSEXPLOSION_TEST_LOS			=	0x0008
local	SF_PHYSEXPLOSION_DISORIENT_PLAYER	=	0x0010

function ENT:PredictedHitGround( ply , inwater , onfloater , speed )

	local dogroundslam = self:GetDoGroundSlam()
	self:SetDoGroundSlam( false )

	if dogroundslam and speed > 500 then

		self:EmitPESound( "Player.FallDamage" , nil , nil , nil , nil , true )
		--ply:EmitSound( "Player.FallDamage" )
		--self:EmitPESound( "" , nil , nil , nil , nil , true )	--find the sound smod uses when the player hits the ground in smod

		local fraction = self:GetJetpackStrafeVelocity() / speed	--because the fall speed might be higher than the jetpack one

		local effect = EffectData()
		effect:SetEntity( ply )
		effect:SetOrigin( ply:WorldSpaceCenter() )	--apparently the player is considered in the ground in this hook and stuff doesn't spawn
		effect:SetScale( 128 )
		util.Effect( "ThumperDust" , effect , true )	--todo, make our own effect where the particles start from the player and expand in a circle
														--can even copy the code from c_thumper_dust
		if SERVER then
			--TODO: get the code from the sdk and replicate this on my own
			ply:LagCompensation( true )

			--[[
			local physexpl = ents.Create( "env_physexplosion" )

			if IsValid( physexpl ) then
				physexpl:SetPos( ply:WorldSpaceCenter() )
				physexpl:SetKeyValue( "spawnflags" , bit.bor( SF_PHYSEXPLOSION_NODAMAGE , SF_PHYSEXPLOSION_RADIAL , SF_PHYSEXPLOSION_TEST_LOS ) )
				physexpl:SetKeyValue( "magnitude" , 500 * fraction )
				physexpl:SetKeyValue( "radius" , 250 )
				physexpl:Spawn()
				physexpl:Fire( "Explode" , "" , 0 )
				physexpl:Fire( "Kill" , "" , 0.1 )
			end
			]]



			--this is kind of shit but it's needed to make prediction actually work properly on this screenshake shit
			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( ply )
			end

			util.ScreenShake( self:GetPos() , 1.5 , 250 , 1 , 500 )

			if SERVER and not game.SinglePlayer() then
				SuppressHostEvents( NULL )
			end

			ply:LagCompensation( false )
		end

		ply:AnimRestartGesture( GESTURE_SLOT_JUMP, ACT_LAND, true )
		return true	--override the fall damage and other hooks
	end
end

if SERVER then

	function ENT:OnTakeDamage( dmginfo )
		--we're already dead , might happen if multiple jetpacks explode at the same time
		if self:Health() <= 0 then
			return
		end

		self:TakePhysicsDamage( dmginfo )

		local oldhealth = self:Health()

		local newhealth = math.Clamp( self:Health() - dmginfo:GetDamage() , 0 , self:GetMaxHealth() )
		self:SetHealth( newhealth )

		if self:Health() <= 0 then
			--maybe something is relaying damage to the jetpack instead, an explosion maybe?
			if IsValid( self:GetControllingPlayer() ) then
				self:Remove( true )
			end
			self:Detonate( dmginfo:GetAttacker() )
			return
		end

		--roll a random, if we're not being held by a player and the random succeeds, go apeshit
		if dmginfo:GetDamage() > 3 and not self:GetGoneApeshit() then
			local rand = math.random( 1 , 10 )
			if rand <= 2 then
				if IsValid( self:GetControllingPlayer() ) then
					self:Remove( true )
				end
				self:SetGoneApeshit( true )
			end
		end
	end

	function ENT:OnAttach( ply )
		self:SetDoGroundSlam( false )
		--self:SetSolid( SOLID_BBOX )	--we can still be hit when on the player's back
	end

	function ENT:CanAttach( ply )
		if self:GetGoneApeshit() then
			return false
		end
	end

	function ENT:OnDrop( ply , forced )
		if IsValid( ply ) and not ply:Alive() then
			--when the player dies while still using us, keep us active and let us fly with physics until
			--our fuel runs out
			if self:GetActive() then
				self:SetGoneApeshit( true )
			end
		else
			self:SetActive( false )
		end

	end

	function ENT:OnInitPhysics( physobj )
		if IsValid( physobj ) then
			physobj:SetMass( 75 )
			self:StartMotionController()
		end
		self:SetCollisionGroup( COLLISION_GROUP_NONE )
		--self:SetCollisionGroup( COLLISION_GROUP_WEAPON )	--set to COLLISION_GROUP_NONE to reenable collisions against players and npcs
	end

	function ENT:OnRemovePhysics( physobj )
		self:StopMotionController()
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS_TRIGGER )
		--self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
	end

	function ENT:PhysicsSimulate( physobj , delta )

		--no point in applying forces and stuff if something is holding our physobj

		if self:GetActive() and not self:GetBeingHeld() then
			physobj:Wake()
			local force = self.StandaloneLinear
			local angular = self.StandaloneAngular

			if self:GetGoneApeshit() then
				force = self.StandaloneApeShitLinear
				angular = self.StandaloneApeShitAngular
			end

			--yes I know we're technically modifying the variable stored in ENT.StandaloneApeShitLinear and that it might fuck up other jetpacks
			--but it won't because we're simply using it as a cached vector_origin and overriding the z anyway
			force.z = -self:GetJetpackVelocity()

			return angular * physobj:GetMass() , force * physobj:GetMass() , SIM_LOCAL_FORCE
		end
	end

	function ENT:PhysicsCollide( data , physobj )
		--taken straight from valve's code, it's needed since garry overwrote VPhysicsCollision, friction sound is still there though
		--because he didn't override the VPhysicsFriction
		if data.DeltaTime >= 0.05 and data.Speed >= 70 then
			local volume = data.Speed * data.Speed * ( 1 / ( 320 * 320 ) )
			if volume > 1 then
				volume = 1
			end

			--TODO: find a better impact sound for this model
			self:EmitSound( "SolidMetal.ImpactHard" , nil , nil , volume , CHAN_BODY )
		end

		if self:CheckDetonate( data , physobj ) then
			self:Detonate()
		end
	end

	--can't explode on impact if we're not active
	function ENT:CheckDetonate( data , physobj )
		return self:GetActive() and data.Speed > 500 and not self:GetBeingHeld()
	end

	function ENT:Detonate( attacker )
		--you never know!
		if self:IsEFlagSet( EFL_KILLME ) then
			return
		end

		self:Remove()

		local fuel = self:GetFuel()
		local atk = IsValid( attacker ) and attacker or self

		--check how much fuel was left when we impacted
		local dmg = 1.5 * fuel
		local radius = 2.5 * fuel

		util.BlastDamage( self , atk , self:GetPos() , radius , dmg )
		util.ScreenShake( self:GetPos() , 1.5 , dmg , 0.25 , radius * 2 )

		local effect = EffectData()
		effect:SetOrigin( self:GetPos() )
		effect:SetMagnitude( dmg )	--this is actually the force of the explosion
		effect:SetFlags( bit.bor( 0x80 , 0x20 ) ) --NOFIREBALLSMOKE, ROTATE
		util.Effect( "Explosion" , effect )
	end



else

	function ENT:Draw( flags )
		if GetViewEntity() == self:GetOwner() and !self:GetOwner():ShouldDrawLocalPlayer() then return end
		local pos , ang = self:GetCustomParentOrigin()

		--even though the calcabsoluteposition hook should already prevent this, it doesn't on other players
		--might as well not give it the benefit of the doubt in the first place
		if pos and ang then
			self:SetPos( pos )
			self:SetAngles( ang )
			self:SetupBones()
		end

		self:DrawModel( flags )

		local atchpos , atchang = self:GetEffectsOffset()

		local effectsscale = self:GetEffectsScale()

		--technically we shouldn't draw the fire from here, it should be done in drawtranslucent
		--but since we draw from the player and he's not translucent this won't get called despite us being translucent
		--might as well just set us to opaque

		if self:GetActive() then	-- and bit.band( flags , STUDIO_TRANSPARENCY ) ~= 0 then
			self:DrawJetpackFire( atchpos , atchang , effectsscale )
			self:DrawJetpackFire( atchpos , atchang , effectsscale )
		end

		self:DrawJetpackSmoke( atchpos  , atchang , effectsscale )
	end

	--the less fuel we have, the smaller our particles will be
	function ENT:GetEffectsScale()
		return Lerp( self:GetFuel() / self:GetMaxFuel() , self.MinEffectsSize , self.MaxEffectsSize )
	end

	function ENT:GetEffectsOffset()
		local angup = self:GetAngles():Up()
		return self:GetPos() + angup * 5, angup
	end


	end



	--copied straight from the thruster code
	function ENT:DrawJetpackFire( pos , normal , scale )
		local scroll = 1000 + UnPredictedCurTime() * -10

		--the trace makes sure that the light or the flame don't end up inside walls
		--although it should be cached somehow, and only do the trace every tick

		local tracelength = 148 * scale


		if self:GetNextFlameTrace() < UnPredictedCurTime() or not self:GetLastFlameTrace() then
			local tr = {
				start = pos,
				endpos = pos + normal * tracelength,
				mask = MASK_OPAQUE,
				filter = {
					self:GetControllingPlayer(),
					self
				},
			}

			self:SetLastFlameTrace( util.TraceLine( tr ) )
			self:SetNextFlameTrace( UnPredictedCurTime() +  engine.TickInterval() )
		end

		local traceresult = self:GetLastFlameTrace()

		--what
		if not traceresult then
			return
		end

		-- traceresult.Fraction * ( 60 * scale ) / tracelength


		--TODO: fix the middle segment not being proportional to the tracelength ( and Fraction )

		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 32 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()


		render.SetMaterial( self.MatFire )

		render.StartBeam( 3 )
			render.AddBeam( pos, 100 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 40 * scale , scroll + 1, self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 32 * scale , scroll + 3, self.JetpackFireNone )
		render.EndBeam()

		scroll = scroll * 0.5

		render.UpdateRefractTexture()
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos, 8 * scale , scroll , self.JetpackFireBlue )
			render.AddBeam( pos + normal * 32 * scale, 32 * scale , scroll + 2, color_white )
			render.AddBeam( traceresult.HitPos, 48 * scale , scroll + 5, self.JetpackFireNone )
		render.EndBeam()


		scroll = scroll * 1.3
		render.SetMaterial( self.MatHeatWave )
		render.StartBeam( 3 )
			render.AddBeam( pos , 8 * scale , scroll, self.JetpackFireBlue )
			render.AddBeam( pos + normal * 60 * scale , 16 * scale , scroll + 1 , self.JetpackFireWhite )
			render.AddBeam( traceresult.HitPos , 16 * scale , scroll + 3 , self.JetpackFireNone )
		render.EndBeam()

		local light = DynamicLight( self:EntIndex() )

		if not light then
			return
		end

		light.Pos = traceresult.HitPos
		light.r = self.JetpackFireRed.r
		light.g = self.JetpackFireRed.g
		light.b = self.JetpackFireRed.b
		light.Brightness = 3
		light.Dir = normal
		light.InnerAngle = -45 --light entities in a cone
		light.OuterAngle = 45 --
		light.Size = 250 * scale -- 125 when the scale is 0.25
		light.Style = 1	--this should do the flicker for us
		light.Decay = 1000
		light.DieTime = UnPredictedCurTime() + 1
	end

	function ENT:DrawJetpackSmoke( pos , normal , scale )

		if not self.JetpackParticleEmitter then
			local emittr = ParticleEmitter( pos )
			if not emittr then
				return
			end
			self.JetpackParticleEmitter = emittr
		end

		--to prevent the smoke from drawing inside of the player when he's looking at a mirror, draw it manually if he's the local player
		--this behaviour is disabled if he's not the one actually using the jetpack ( this also happens when the jetpack is dropped and flies off )

		local particlenodraw = self:IsCarriedByLocalPlayer( true )

		self.JetpackParticleEmitter:SetNoDraw( particlenodraw )

		if self:GetNextParticle() < UnPredictedCurTime() and self:GetActive() then
			local particle = self.JetpackParticleEmitter:Add( "particle/particle_noisesphere", pos )
			if particle then
				--only increase the time on a successful particle
				self:SetNextParticle( UnPredictedCurTime() + 0.01 )
				particle:SetLighting( true )
				particle:SetCollide( true )
				particle:SetBounce( 0.25 )
				particle:SetVelocity( normal * self:GetJetpackSpeed() )
				particle:SetDieTime( 0.1 )
				particle:SetStartAlpha( 15 )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( 16 * scale )
				particle:SetEndSize( 64 * scale )
				particle:SetRoll( math.Rand( -10 , 10  ) )
				particle:SetRollDelta( math.Rand( -0.2 , 0.2 ) )
				particle:SetColor( 255 , 255 , 255 )
			end
		end

		if particlenodraw then
			self.JetpackParticleEmitter:Draw()
		end
	end



function ENT:HandleMainActivityOverride( ply , velocity )
	if self:GetActive() then
		local vel2d = velocity:Length2D()
		local idealact = ACT_INVALID

		if IsValid( ply:GetActiveWeapon() ) then
			idealact = ACT_MP_SWIM	--vel2d >= 10 and ACT_MP_SWIM or ACT_MP_SWIM_IDLE
		else
			idealact = ACT_HL2MP_IDLE + 9
		end

		if self:GetDoGroundSlam() then
			idealact = ACT_MP_CROUCH_IDLE
		end

		return idealact , ACT_INVALID
	end
end

function ENT:HandleUpdateAnimationOverride( ply , velocity , maxseqgroundspeed )
	if self:GetActive() then
		ply:SetPlaybackRate( 0 )	--don't do the full swimming animation
		return true
	end
end

function ENT:OnRemove()

	if CLIENT then

		--if stopping the soundpatch doesn't work, stop the sound manually
		if self.JetpackSound then
			self.JetpackSound:Stop()
			self.JetpackSound = nil
		else
			self:StopSound( "jetpack.thruster_loop_new2" )
		end


		if self.JetpackParticleEmitter then
			self.JetpackParticleEmitter:Finish()
			self.JetpackParticleEmitter = nil
		end
	end

	BaseClass.OnRemove( self )
end


--addons/star_wars_mortar/lua/entities/mortar_bomb_shell/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end
--addons/weapons_other/lua/entities/recondroidcamera/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.Category = "Evan's Remote Recon"
ENT.PrintName = "Recon Droid Camera"
ENT.Spawnable = true
ENT.AdminSpawnable = false

if SERVER then
	//AddCSLuaFile("autorun/swep_net.lua")
end

function ENT:SetupDataTables()
		
		
	if ( SERVER ) then
		
	end

end
--addons/arccw_weapons/lua/entities/rocket_imp/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "MiniMag Rocket"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.CollisionGroup = COLLISION_GROUP_PROJECTILE

ENT.Model = "models/weapons/star_wars_battlefront/com_weap_missile.mdl"
ENT.FuseTime = 15
ENT.ArmTime = 0

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
            phys:Wake()
	phys:SetMass(2)
            phys:SetBuoyancyRatio(0)
            phys:EnableGravity( false )
        end

        self.kt = CurTime() + self.FuseTime
        self.motorsound = CreateSound( self, "weapons/star_wars_battlefront/common/ammo_rocket_lp02.wav")
    end

    self.at = CurTime() + self.ArmTime
    self.Armed = false
end

function ENT:OnRemove()
    if SERVER then
        self.motorsound:Stop()
    end
end


function ENT:PhysicsCollide(data, physobj)
    if self.at <= CurTime() then
        self:Detonate()
    elseif self.at > CurTime() then
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )
        util.Effect( "RPGShotDown", effectdata)
        util.Effect( "StunstickImpact", effectdata)
        self:Remove()
    end
end

function ENT:Arm()
    if SERVER then
        self.motorsound:Play()
    end
end

function ENT:Think()

    if CurTime() >= self.at and !self.Armed then
        self:Arm()
        self.Armed = true
    end

    if SERVER then

        if self.Armed then
            local phys = self:GetPhysicsObject()
            phys:ApplyForceCenter( self:GetAngles():Forward() * 500 )
        end

        if CurTime() >= self.kt then
            self:Detonate()
        end
    end

    if CLIENT then
        if self.Armed then
		ParticleEffectAttach( "astw2_swbf_muzzle_imp_sniper", PATTACH_POINT_FOLLOW, self, 0 )
            local emitter = ParticleEmitter(self:GetPos())

            if !self:IsValid() or self:WaterLevel() > 2 then return end

            local smoke = emitter:Add("effects/swbf/thicksmoke", self:GetPos())
        smoke:SetGravity( Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)) )
        smoke:SetVelocity( self:GetAngles():Forward() * 100 )
        smoke:SetDieTime( math.Rand(0.5,0.75) )
        smoke:SetStartAlpha( 85 )
        smoke:SetEndAlpha( 0 )
        smoke:SetStartSize( 15 )
        smoke:SetEndSize( 140 )
        smoke:SetRoll( math.Rand(-180, 180) )
        smoke:SetRollDelta( math.Rand(-0.2,0.2) )
        smoke:SetColor( 225, 225, 225 )
        smoke:SetAirResistance( 50 )
        smoke:SetPos( self:GetPos() )
        smoke:SetLighting( true )
        emitter:Finish()
        end
    end
end

function ENT:Detonate()
    if SERVER then
        if !self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_imp_rocket", self:GetPos(), self:GetAngles() )
	sound.Play( "weapons/star_wars_battlefront/common/exp_ord_rocket_large0" .. math.random(1,3) .. ".wav",  self:GetPos(), 100, 100 )
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        util.BlastDamage(self, attacker, self:GetPos(), 400, 400)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),18000,500,1.2,2048)
        self:Remove()
    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()

        if self.Armed then
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/blueflare1") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(200, 300), math.random(200, 300), Color(150, 255, 100) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
        end
    end
end
--gamemodes/starwarsrp/entities/entities/rs4_ent/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_gmodentity"
ENT.PrintName		= "RS4"
ENT.Author			= "Hoff"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

hook.Add("Initialize","CreateC4Convars",function()
    if !ConVarExists("C4_DoorSearchRadius") then
        CreateConVar("C4_Infinite", 0, { FCVAR_REPLICATED, FCVAR_ARCHIVE }, "Should C4 be infinite? 1 = infinite")
        CreateConVar("C4_ThrowSpeed", 1, { FCVAR_REPLICATED, FCVAR_ARCHIVE }, "How long is the delay between C4 throws?")
        CreateConVar("C4_Magnitude", 175, { FCVAR_REPLICATED, FCVAR_ARCHIVE }, "How strong is the C4 explosion?")
        CreateConVar("C4_KnockDoors", 0, { FCVAR_REPLICATED, FCVAR_ARCHIVE }, "Should C4 knock down doors?")
        CreateConVar("C4_DoorKnockStrength", 500, { FCVAR_REPLICATED, FCVAR_ARCHIVE }, "How hard should the door be blasted?")
        CreateConVar("C4_DoorSearchRadius", 75, { FCVAR_REPLICATED, FCVAR_ARCHIVE }, "How far away should doors be effected?")
    end
    if CLIENT then
        if !ConVarExists("C4_RedLight") then
            CreateClientConVar("C4_RedLight", 1, true)
        end
        local function funcCallback(CVar, PreviousValue, NewValue)
            net.Start("C4_Convars_Change", true)
            net.WriteString(CVar)
            net.WriteFloat(tonumber(NewValue))
            net.SendToServer()
        end
        cvars.AddChangeCallback("C4_Infinite", funcCallback)
        cvars.AddChangeCallback("C4_ThrowSpeed", funcCallback)
        cvars.AddChangeCallback("C4_Magnitude", funcCallback)
        cvars.AddChangeCallback("C4_KnockDoors", funcCallback)
        cvars.AddChangeCallback("C4_DoorKnockStrength", funcCallback)
        cvars.AddChangeCallback("C4_DoorSearchRadius", funcCallback)
    end
end)

if SERVER then
    util.AddNetworkString("C4_Convars_Change")

    net.Receive("C4_Convars_Change", function(len, ply)
        if !ply:IsAdmin() then
            return
        end
        local cvar_name = net.ReadString()
        local cvar_val = net.ReadFloat()
        RunConsoleCommand(cvar_name, cvar_val)
    end)

end

--addons/joes_stuff/lua/entities/shield_2/cl_init.lua:
include('shared.lua')

--addons/sse_101/lua/entities/sse_battlepad.lua:
AddCSLuaFile()


ENT.Base = "sse_base"
ENT.Category        = "SSE"
ENT.PrintName		= "Battlepad"
ENT.Spawnable       = true

ENT.ConfigName = "Battlepad"
ENT.NoHudName = true




if CLIENT then
    function ENT:Draw()
        self:DrawModel()



        local imgui = SSE.Imgui

        local radarSize = self:ConfigValue("Size") -- Half of the radar size (since the radar is square)
        
        -- Fetch map bounds
        local world = game.GetWorld()
        local mapMinBound, mapMaxBound = world:GetModelBounds()
        
        -- Function to map world coordinates to radar coordinates
        local function WorldToRadar(worldPos)
            -- Calculate scale based on the map bounds
            local scaleX = radarSize * 2 / (mapMaxBound.x - mapMinBound.x)
            local scaleY = radarSize * 2 / (mapMaxBound.y - mapMinBound.y)
    
            -- Convert world position to radar position
            local radarX = (worldPos.x - mapMinBound.x) * scaleX - radarSize
            local radarY = (worldPos.y - mapMinBound.y) * scaleY - radarSize
    
            -- Clamp to ensure the position stays within the radar square
            radarX = math.Clamp(radarX, -radarSize, radarSize)
            radarY = math.Clamp(radarY, -radarSize, radarSize)
    
            return radarX, radarY
        end
    
        if imgui.Entity3D2D(self, Vector(0, 0, 43), Angle(0, 90, 0), 0.1, 1000, 500) then
            -- Draw filled radar square
            draw.RoundedBox(0, -radarSize, -radarSize, radarSize * 2, radarSize * 2, self:ConfigValue("BackgroundColor"))
    
            -- Draw radar center
            --draw.RoundedBox(50, -5, -5, 10, 10, Color(0, 255, 0, 200))
    

            -- Draw radar border
            surface.SetDrawColor(255, 255, 255, 255)
            surface.DrawOutlinedRect(-radarSize, -radarSize, radarSize * 2, radarSize * 2)


 
            -- Draw players on the radar
            for k, v in ipairs(ents.GetAll()) do
                local good = false
                local color = Color(255, 0, 0)
                if v:IsPlayer() or self:ConfigValue("FriendlyEntities")[v:GetClass()] then 
                    good = true
                    color = Color(0, 255, 0)
                end

                if v:IsNPC() or v:IsNextBot() or self:ConfigValue("EnemyEntities")[v:GetClass()] then 
                    good = true
                    color = Color(255, 0, 0)
                end

              

          
                if !good then continue end
          
                local pX, pY = WorldToRadar(v:GetPos())
    
                local name = v.PrintName or ""
                -- Ensure the player dot is drawn within radar boundaries
                if math.abs(pX) <= radarSize and math.abs(pY) <= radarSize then
                    draw.RoundedBox(50, pX - 5, pY - 5, 10, 10, color)

               
                end
            end
    
            local rX, rY = WorldToRadar(self:GetPos())
            draw.RoundedBox(50, rX-5,rY-5, 10, 10, Color(255,0,255) )

            draw.DrawText("W",AOCDerma:DF("l", 50, 10),0, 180,Color(255,255,255), TEXT_ALIGN_CENTER)
            draw.DrawText("O",AOCDerma:DF("l", 50, 10),0, -240,Color(255,255,255), TEXT_ALIGN_CENTER)
            draw.DrawText("N",AOCDerma:DF("l", 50, 10),325, -25,Color(255,255,255), TEXT_ALIGN_CENTER)
            draw.DrawText("S",AOCDerma:DF("l", 50, 10),-325, -25,Color(255,255,255), TEXT_ALIGN_CENTER)
             
            
            imgui.End3D2D()
        end

    end

end






--addons/sse_101/lua/entities/sse_restriced_area.lua:
AddCSLuaFile()



ENT.Base = "sse_base"
ENT.PrintName		= "Restricted Area Sign"
ENT.Spawnable       = true
ENT.ConfigName = "RestrictedSign"
ENT.NoHudName = true
ENT.Category        = "SSE"


if CLIENT then
    
    function ENT:Draw()
        self:DrawModel()

        -- Get Model Height
        local min, max = self:GetModelBounds()
        local height = max.z - min.z

        local imgui = SSE.Imgui

        if imgui.Entity3D2D(self, Vector(0, 0, height+25), Angle(0, 90, 90), 0.1, 1000, 500) then

            draw.SimpleText(self:ConfigValue("Text1"), SSE.xFont(self:ConfigValue("Font1")), 0, 50, self:ConfigValue("Color1"), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            draw.RoundedBox(0, -300, 90, 600, 2, Color(255,255,255))
            draw.SimpleText(self:ConfigValue("Text2"), SSE.xFont(self:ConfigValue("Font2")), 0, 120, self:ConfigValue("Color2"), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            draw.SimpleText(self:ConfigValue("Text3"), SSE.xFont(self:ConfigValue("Font3")), 0, 220, self:ConfigValue("Color3"), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            draw.SimpleText(self:ConfigValue("Text4"), SSE.xFont(self:ConfigValue("Font4")), 0, 180, self:ConfigValue("Color4"), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

            imgui.End3D2D()
        end

        if imgui.Entity3D2D(self, Vector(0, 0, height+25), Angle(0, -90, 90), 0.1, 1000, 500) then

            draw.SimpleText(self:ConfigValue("Text1"), SSE.xFont(self:ConfigValue("Font1")), 0, 50, self:ConfigValue("Color1"), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            draw.RoundedBox(0, -300, 90, 600, 2, Color(255,255,255))
            draw.SimpleText(self:ConfigValue("Text2"), SSE.xFont(self:ConfigValue("Font2")), 0, 120, self:ConfigValue("Color2"), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            draw.SimpleText(self:ConfigValue("Text3"), SSE.xFont(self:ConfigValue("Font3")), 0, 220, self:ConfigValue("Color3"), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            draw.SimpleText(self:ConfigValue("Text4"), SSE.xFont(self:ConfigValue("Font4")), 0, 180, self:ConfigValue("Color4"), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

            imgui.End3D2D()
        end
    end


end
--addons/sse_101/lua/entities/sse_tempwepstorage.lua:
AddCSLuaFile()


ENT.Base = "sse_base"
ENT.PrintName		= "Temporary Weapon Storage"
ENT.Spawnable       = true
ENT.ConfigName = "TempWepStorage"
ENT.Category        = "SSE"
if SERVER then
        
 
    ENT.WeaponStorage = {}
    
    function ENT:Use( activator, caller )

        if self.WeaponStorage[activator:EntIndex()] then 

            for k, v in pairs(self.WeaponStorage[activator:EntIndex()]) do 
                activator:Give(v)
            end

            self.WeaponStorage[activator:EntIndex()] = nil
        else 
    
            local waffen = activator:GetWeapons()

            local classTbl = {}

            for k, v in pairs(waffen) do
                table.insert(classTbl, v:GetClass())
            end 

            self.WeaponStorage[activator:EntIndex()] = classTbl

            activator:StripWeapons()

            for k, v in pairs( self:ConfigValue("KeepWeapons") ) do
                activator:Give(v)
            end
        end


    end


end


--addons/sse_101/lua/entities/sse_weaponbox.lua:
AddCSLuaFile()



ENT.Base = "sse_base"
ENT.PrintName		= "Weapon Box"
ENT.Spawnable       = true
ENT.ConfigName = "WeaponBox"
ENT.ClientInteraction = true
ENT.Category        = "SSE"





if SERVER then
     

    util.AddNetworkString( "SSE_WeaponBox_GIVE" )
    util.AddNetworkString( "SSE_WeaponBox_TAKE" )
    
    
    
    net.Receive( "SSE_WeaponBox_GIVE", function( len, ply )

        local wep = net.ReadString()
        local weaponbox = net.ReadEntity()

        if !IsValid(weaponbox) then return end
        if !weaponbox:ConfirmUse(ply) then return end
        
        getWeaponsFunc = weaponbox:ConfigValue("GetWeapons")
        weaponbox = getWeaponsFunc(ply)

        if !table.HasValue(weaponbox,wep) then return end

        ply:Give(wep)
        ply:SelectWeapon(wep)

        ply:EmitSound("items/ammo_pickup.wav")

    end)
    
    net.Receive( "SSE_WeaponBox_TAKE", function( len, ply )
        local wep = net.ReadString()
        local weaponbox = net.ReadEntity()

        if !IsValid(weaponbox) then return end
        if !weaponbox:ConfirmUse(ply) then return end

        getWeaponsFunc = weaponbox:ConfigValue("GetWeapons")
        weaponbox = getWeaponsFunc(ply)

        if !table.HasValue(weaponbox,wep) then return end

        ply:StripWeapon(wep)
        ply:EmitSound("items/ammo_pickup.wav")
    
    end)
    
    
    end
        
    
    if CLIENT then
    
        function SSE_WeaponBox(data,weaponbox) 

            if !IsValid(weaponbox) then return end
            if !istable(data) then LocalPlayer():ChatPrint("*** ".. weaponbox:ConfigValue("NoWeps")) return end
            if table.IsEmpty(data) then LocalPlayer():ChatPrint("*** ".. weaponbox:ConfigValue("NoWeps")) return end

            if ValidPanel(SSE_WeaponBoxFrame) then SSE_WeaponBoxFrame:Remove() end
            SSE_WeaponBoxFrame = SSE:DefaultFrame()
            SSE_WeaponBoxFrame:SetSize(SSEW(500),SSEH(600))
            SSE_WeaponBoxFrame:Center()
            SSE_WeaponBoxFrame:SetNewTitle(weaponbox:ConfigValue("FrameTitle"))
            SSE_WeaponBoxFrame:SetSizable(false)
            SSE_WeaponBoxFrame:SetDraggable(false)

            function SSE_WeaponBoxFrame:OnRemove()
                if IsValid(weaponbox) then
                    weaponbox:InvalidateUseConfirm(LocalPlayer())
                end
            end
    
            local content = SSE:ScrollBar(SSE_WeaponBoxFrame) 
            content:Dock(FILL)
        
  
            for _, v in ipairs(data) do
                local text = v
                local wepTbl = weapons.Get(v)
            
    
                if istable(wepTbl) then
                    text = wepTbl.PrintName
                end
    
                
    
                    local btn = SSE:Button(content, text, function() 
    
                        if LocalPlayer():HasWeapon(v) then
                            net.Start( "SSE_WeaponBox_TAKE" )
                            net.WriteString(v)
                            net.WriteEntity(weaponbox)
                            net.SendToServer()
                        else
                            net.Start( "SSE_WeaponBox_GIVE" )
                            net.WriteString(v)
                            net.WriteEntity(weaponbox)
                            net.SendToServer()      
                        end
                    end, "bc")
    
                    btn:Dock(TOP)
                    btn:DockMargin(5,10,5,0)
    
                    function btn:Think() 
                         if LocalPlayer():HasWeapon(v) then
                            self.akzent = Color(0,200,0)
                            self.akzenthover = Color(0,255,0,255)
                         else
                            self.akzent = Color(200,0,0)
                            self.akzenthover = Color(255,0,0,255)
                         end
                    end
            end        
        end

        function ENT:ClientUse()
            getWeaponsFunc = self:ConfigValue("GetWeapons")
            SSE_WeaponBox(getWeaponsFunc(LocalPlayer()),self) 
        end 
    

    end

    
--addons/aoc_nextbots/lua/entities/summe_nextbot/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end
--addons/arccw_weapons/lua/entities/tfa_battlefront_ent_nade_impact.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.Spawnable = false

function ENT:Draw()
    self:DrawModel()
end

function ENT:Initialize()
    if SERVER then
        self:SetModel( "models/forrezzur/impactgrenade.mdl" )
        self:PhysicsInit(SOLID_VPHYSICS)
    self:SetSolid(SOLID_VPHYSICS)

    local phys = self:GetPhysicsObject()
    if (IsValid(phys)) then
        phys:SetMass(1)
    end
        self:DrawShadow( true )
    end
    self.ExplodeTimer = CurTime() + 100000
end

function ENT:PhysicsCollide( data, phys )
    if  (20 < data.Speed and 0.25 < data.DeltaTime) then
    self.ExplodeTimer = 0
    end
end

function ENT:Think()
    if SERVER and (self.ExplodeTimer and self.ExplodeTimer <= CurTime()) then
        self:Explode()
    end
    self:NextThink(CurTime())
    return true
end

function ENT:Explode()
	local effectdata = EffectData()
    effectdata:SetOrigin( self:GetPos() )
    util.Effect("Explosion", effectdata)
    util.BlastDamage( self, self.Owner, self:GetPos(), 150, 100 )
    local spos = self:GetPos()
    local trs = util.TraceLine({start=spos + Vector(0,0,64), endpos=spos + Vector(0,0,-32), filter=self})
    util.Decal("Scorch", trs.HitPos + trs.HitNormal, trs.HitPos - trs.HitNormal)    
    self:Remove()
end

function ENT:OnRemove()
end
--addons/arccw_weapons/lua/entities/tfa_battlefront_ent_nade_incendiary.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.Spawnable = false

function ENT:Draw()
self:DrawModel()
end

function ENT:Initialize()
	if SERVER then
		self:SetModel( "models/weapons/tfa_starwars/w_incendiary.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
		self:DrawShadow( true )
	end
	self:EmitSound("weapons/tfa_starwars/Incendiary_Charge_01.wav")
	self.ActiveTimer = CurTime() + 1
	self.IgniteEnd = 0
	self.IgniteEndTimer = CurTime()
	self.IgniteStage = 0
	self.IgniteStageTimer = CurTime()
	ParticleEffectAttach("incgrenade_thrown_trail",PATTACH_POINT_FOLLOW,self,1)
	self:PhysicsInitSphere( 8 )
end

function ENT:PhysicsCollide( data,phys )
	if SERVER and self.ActiveTimer > CurTime() || data.Speed >= 2000 then
		self:EmitSound( "TFA_CSGO_SmokeGrenade.Bounce" )
	end
	local ang = data.HitNormal:Angle()
	ang.p = math.abs( ang.p )
	ang.y = math.abs( ang.y )
	ang.r = math.abs( ang.r )
	
	if ang.p > 90 or ang.p < 60 then
		self.Entity:EmitSound(Sound("TFA_CSGO_SmokeGrenade.Bounce"))
	else
		if SERVER then
			local molotovfire = ents.Create( "tfa_battlefront_fire_2" )
			molotovfire:SetPos( self:GetPos() )
			molotovfire:SetOwner( self.Owner )
			molotovfire:Spawn()
			timer.Simple( 8, function()
				if IsValid( molotovfire ) then
					molotovfire:Remove()
				end
			end )
			
			local molotovfire = ents.Create( "tfa_battlefront_fire_1" )
			local pos = self:GetPos()
			molotovfire:SetPos( self:GetPos() )
			molotovfire:SetOwner( self.Owner )
			molotovfire:SetCreator( self )
			molotovfire:Spawn()
			timer.Simple( 8, function()
				if IsValid( molotovfire ) then
					molotovfire:Remove()
				end
			end )
			
			self:SetMoveType( MOVETYPE_NONE )
			self:SetSolid( SOLID_NONE )
			self:PhysicsInit( SOLID_NONE )
			self:SetCollisionGroup( COLLISION_GROUP_NONE )
			self:SetRenderMode( RENDERMODE_TRANSALPHA )
			self:SetColor( Color( 255, 255, 255, 0 ) )
			self:DrawShadow( false )
			self:StopParticles()
		end
		self:EmitSound("TFA_CSGO_IncGrenade.Start")
		self.IgniteEnd = 1
		self.IgniteEndTimer = CurTime() + 7
		self.IgniteStage = 1
		self.IgniteStageTimer = CurTime() + 0.1
	end
end

function ENT:OnRemove()
	if SERVER then
		self:StopSound( "TFA_CSGO_Inferno.Loop" )
		self:EmitSound( "TFA_CSGO_Inferno.FadeOut" )
	end
end
--addons/arccw_weapons/lua/entities/tfa_battlefront_ent_nade_poison.lua:
ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.PrintName = "explosive Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false 

ENT.BounceSound = Sound("TFA_CSGO_SmokeGrenade.Bounce")
ENT.ExplodeSound = Sound("weapons/tfa_starwars/Smoke_Explosive_Puff_01.wav")

AddCSLuaFile()

function ENT:Initialize()
	if SERVER then
		self:SetModel("models/forrezzur/dioxisgrenade.mdl") 
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
		
		local phys = self:GetPhysicsObject()
		if phys:IsValid() then
			phys:Wake()
			phys:SetBuoyancyRatio(0)
		end
		
		self.Delay = CurTime() + 2
		self.NextParticle = 0
		self.ParticleCount = 0
		self.First = true
		self.IsDetonated = false
	end
	self:EmitSound("TFA_CSGO_SmokeGrenade.Throw")
end

function ENT:PhysicsCollide(data, physobj)
	if SERVER then
		self.HitP = data.HitPos
		self.HitN = data.HitNormal

		if self:GetVelocity():Length() > 60 then
			self:EmitSound(self.BounceSound)
		end
		
		if self:GetVelocity():Length() < 5 then
			self:SetMoveType(MOVETYPE_NONE)
		end
		
	end
end

function ENT:Think()
    if SERVER then    
        if CurTime() > self.Delay then
            if self.IsDetonated == false then
                self:Detonate(self,self:GetPos())
                self.IsDetonated = true
            end
        end
    end
    if self.IsDetonated == true then
    for k, v in pairs( ents.FindInSphere( self:GetPos(), 216 ) ) do
            if v:IsPlayer() or v:IsNPC() then
                damage = DamageInfo()
                damage:SetDamage( math.random( 3, 7 ) )
                damage:SetAttacker( self:GetOwner() )
                damage:SetDamageType( DMG_NERVEGAS )
                v:TakeDamageInfo( damage )
                v:ViewPunch( Angle( math.random( -3, 3 ), math.random( -3, 3 ), math.random( -3, 3 ) ) )
            end
        end
    end
    self:NextThink( CurTime() + 0.25 )
    return true
end
		
function ENT:Detonate(self,pos)
	self.ParticleCreated = false
	self.ExtinguishParticleCreated = false
	if SERVER then
		if not self:IsValid() then return end
		self:SetNWBool("IsDetonated",true)
		self:EmitSound(self.ExplodeSound)
		local gas = EffectData()
		gas:SetOrigin(pos)
		gas:SetEntity(self.Owner) //i dunno, just use it!
		util.Effect("tfa_csgo_poisonade", gas)
	end
	
	self:SetMoveType( MOVETYPE_NONE )
	
	if SERVER then
		SafeRemoveEntityDelayed(self,30)
	end
	
end

function ENT:Draw()
	if CLIENT then
		self:DrawModel()
	end
end
--addons/arccw_weapons/lua/entities/tfa_battlefront_ent_nade_stun.lua:
ENT.Type = "anim"
ENT.Base = "arccw_thr"
ENT.PrintName = "explosive Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false 

ENT.BounceSound = Sound("TFA_CSGO_SmokeGrenade.Bounce")
ENT.ExplodeSound = Sound("weapons/tfa_starwars/Shock_Explosion_02.wav")

AddCSLuaFile()

function ENT:Initialize()
	if SERVER then
		self:SetModel("models/weapons/tfa_starwars/w_flash.mdl") 
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
		
		local phys = self:GetPhysicsObject()
		if phys:IsValid() then
			phys:Wake()
			phys:SetBuoyancyRatio(0)
		end
		
		self.Delay = CurTime() + 3
		self.NextParticle = 0
		self.ParticleCount = 0
		self.First = true
		self.IsDetonated = false
	end
	self:EmitSound("weapons/tfa_starwars/Shock_Charge_01.wav")
end

function ENT:PhysicsCollide(data, physobj)
	if SERVER then
		self.HitP = data.HitPos
		self.HitN = data.HitNormal

		if self:GetVelocity():Length() > 60 then
			self:EmitSound(self.BounceSound)
		end
		
		if self:GetVelocity():Length() < 5 then
			self:SetMoveType(MOVETYPE_NONE)
		end
		
	end
end

function ENT:Think()
    if SERVER then    
        if CurTime() > self.Delay then
            if self.IsDetonated == false then
                self:Detonate(self,self:GetPos())
                self.IsDetonated = true
            end
        end
    end
    if self.IsDetonated == true then
			local elec = EffectData()
		elec:SetOrigin(self:GetPos())
		elec:SetMagnitude(3)
		util.Effect("Sparks", elec)
for k, v in pairs( ents.FindInSphere( self:GetPos(), 120 ) ) do
    if v:IsPlayer() then
			FreezePlayer(self)
			v:ScreenFade(SCREENFADE.IN, Color(255, 255, 255, 100), 0.2, 0)
			v:EmitSound("weapons/stunstick/spark"..math.random(1,3)..".wav")
			damage = DamageInfo()
                damage:SetDamage( math.random( 2, 5 ) )
                damage:SetAttacker( self:GetOwner() )
                damage:SetDamageType( DMG_SHOCK )
            v:TakeDamageInfo( damage )
                    end
                end
			end
	
    self:NextThink( CurTime() + 0.3 )
    return true
end

function FreezePlayer(self,pos)
	for k, v in pairs( ents.FindInSphere( self:GetPos(), 200 ) ) do
    if v:IsPlayer() then
	local fx = EffectData()
        fx:SetOrigin( v:GetPos() )
        fx:SetMagnitude(2)
        util.Effect("TeslaHitBoxes",fx)
            v:Freeze( true )
timer.Simple(3, function()
            v:Freeze( false )
			end)
		end
	end
end
	
function ENT:Detonate(self,pos)
	self.ParticleCreated = false
	self.ExtinguishParticleCreated = false
	if SERVER then
		if not self:IsValid() then return end
		self:SetNWBool("IsDetonated",true)
		self:EmitSound(self.ExplodeSound)
	end
	
	self:SetMoveType( MOVETYPE_NONE )
	
	if SERVER then
		SafeRemoveEntityDelayed(self,5)
	end
	
end

function ENT:Draw()
	if CLIENT then
		self:DrawModel()
	end
end
--addons/arccw_weapons/lua/entities/tfbow_arrow_stuck_clientside/shared.lua:

-- Copyright (c) 2018-2020 TFA Base Devs

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

ENT.Type = "anim"
ENT.PrintName = "Sawblade"
ENT.Author = ""
ENT.Contact = ""
ENT.Purpose = ""
ENT.Instructions = ""
ENT.DoNotDuplicate = true
ENT.DisableDuplicator = true

ENT.glitchthreshold = 24 --threshold distance from bone to reset pos
ENT.glitchthresholds = {}
ENT.glitchthresholds["ValveBiped.Bip01_Head1"] = 8
ENT.glitchthresholds["ValveBiped.Bip01_Head"] = 8
ENT.glitchthresholds["ValveBiped.Bip01_R_Hand"] = 1
ENT.glitchthresholds["ValveBiped.Bip01_L_Hand"] = 1
ENT.glitchthresholds["ValveBiped.Bip01_Spine2"] = 40

ENT.Hull = 1.5 --Expand hull to make it easier to grab
ENT.PredictCL = false
ENT.UseMod = false --Experimentally modify the parent's Use func

local cv_al = GetConVar("sv_tfa_arrow_lifetime")
local nzombies

local function GetBoneCenter(ent, bone)
	local bonechildren = ent:GetChildBones(bone)

	if #bonechildren <= 0 then
		return ent:GetBonePosition(bone)
	else
		local bonepos = ent:GetBonePosition(bone)
		local tmppos = bonepos

		if tmppos then
			for i = 1, #bonechildren do
				local childpos = ent:GetBonePosition(bonechildren[i])

				if childpos then
					tmppos = (tmppos + childpos) / 2
				end
			end
		else
			return ent:GetPos()
		end

		return tmppos
	end
end

function ENT:Initialize()

	if nzombies == nil then
		nzombies = nZombies or NZ or NZombies or engine.ActiveGamemode() == "nzombies"
	end

	local mdl = self:GetModel()

	if not mdl or mdl == "" or mdl == "models/error.mdl" then
		self:SetModel("models/weapons/w_tfa_arrow.mdl")
	end

	if SERVER then

		local mins = (self:OBBMins() and self:OBBMins() or Vector(0, 0, 0)) - Vector(1, 1, 1)
		local maxs = (self:OBBMaxs() and self:OBBMaxs() or Vector(0, 0, 0)) + Vector(1, 1, 1)
		self:PhysicsInitBox(mins * self.Hull, maxs * self.Hull)
		--self:PhysicsInit( SOLID_VPHYSICS )
		--self:SetSolid( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		local phys = self:GetPhysicsObject()

		if (phys:IsValid()) then
			phys:Wake()
			phys:SetMass(2)
			phys:EnableGravity(false)
			phys:EnableCollisions(false)
		end

		if self.SetUseType then
			self:SetUseType(SIMPLE_USE)
		end

		if cv_al:GetInt() ~= -1 then
			timer.Simple( cv_al:GetFloat(), function()
				if IsValid(self) then
					self:Remove()
				end
			end)
		end

		self:SetUseType( SIMPLE_USE )
	end

	if SERVER then
		self:TargetEnt( true )
	end

	if CLIENT then
		self:SetPredictable(false)
	end

	if (self:GetModel() and self:GetModel() == "") then
		self:SetModel("models/weapons/w_tfa_arrow.mdl")
	end

	self:SetCollisionGroup(COLLISION_GROUP_WEAPON)

	self:DrawShadow(true)
end

function ENT:TargetEnt( init )
	if self.targent and IsValid(self.targent) then
		if init then
			local ent, bone, bonepos, bonerot
			ent = self.targent
			bone = self.targent:TranslatePhysBoneToBone(self.targphysbone)
			self.targbone = bone

			if not ent:GetBoneCount() or ent:GetBoneCount() <= 1 or string.find(ent:GetModel(), "door") then
				bonepos = ent:GetPos()
				bonerot = ent:GetAngles()
				self.enthasbones = false
			else
				if ent.SetupBones then
					ent:SetupBones()
				end

				bonepos, bonerot = ent:GetBonePosition(bone)
				self.enthasbones = true
			end

			if self.enthasbones == true then
				local gpos = self:GetPos()
				local bonepos2 = GetBoneCenter(ent, bone)
				local tmpgts = self.glitchthresholds[ent:LookupBone(bone)] or self.glitchthreshold

				while gpos:Distance(bonepos2) > tmpgts do
					self:SetPos((gpos + bonepos2) / 2)
					gpos = (gpos + bonepos2) / 2
				end
			end

			if not bonepos then
				bonepos = ent:GetPos()
				bonerot = ent:GetAngles()
			end

			self.posoff, self.angoff = WorldToLocal(self:GetPos(), self:GetAngles(), bonepos, bonerot)
		end
		self:FollowBone( self.targent, self.targbone or -1 )
		self:SetOwner( self.targent )
		self:SetLocalPos( self.posoff )
		self:SetLocalAngles( self.angoff )
		self.HTE = true
		if SERVER and self.PredictCL then
			timer.Simple(0.05,function()
				if IsValid(self) then
					net.Start("tfaArrowFollow")
					net.WriteEntity( self )
					net.WriteEntity( self.targent )
					net.WriteInt( self.targbone, 8 )
					net.WriteVector( self.posoff )
					net.WriteAngle( self.angoff )
					net.Broadcast()
				end
			end)
		end
	end
end

function ENT:Think()
	if CLIENT and not self.PredictCL then return end
	if IsValid(self.targent) and self.targent.Health and self.targent:Health() <= 0 and self.targent.GetRagdollEntity then
		local rag = self.targent:GetRagdollEntity()
		if IsValid(rag) then
			self.targent = rag
			self:TargetEnt( false )
		end
	end
	local par = self:GetParent()
	if IsValid(par) and self.UseMod and not par.HasUseMod then
		par.HasUseMod = true
		par.ArrowUseOld = par.ArrowUseOld or par.Use
		par.Use = function( parent, ... )
			for _,v in pairs( par:GetChildren() ) do
				if v.Use then v:Use(...) end
			end
			parent:Use( ... )
		end
		par:SetUseType( SIMPLE_USE )
	end
	if SERVER and not self.HTE then
		self:TargetEnt( true )
	end
	self:NextThink(CurTime())
	return true
end
--addons/arccw_weapons/lua/entities/thermal_detonator/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "Thermal Detonator (Thrown)"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.Model = "models/weapons/star_wars_battlefront/ThermalDetonator_thrown.mdl"
ENT.FuseTime = 2
ENT.ArmTime = 0
ENT.ImpactFuse = false

AddCSLuaFile()

function ENT:Initialize()
    if SERVER then
        self:SetModel( self.Model )
        self:SetMoveType( MOVETYPE_VPHYSICS )
        self:SetSolid( SOLID_VPHYSICS )
        self:PhysicsInit( SOLID_VPHYSICS )
        self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )
        self:DrawShadow( true )

        local phys = self:GetPhysicsObject()
        if phys:IsValid() then
	    phys:SetMass(10)
            phys:Wake()
            phys:SetBuoyancyRatio(0)
        end

        self.kt = CurTime() + self.FuseTime
        self.at = CurTime() + self.ArmTime
    end
end

function ENT:PhysicsCollide(data, physobj)
    if SERVER then
        if data.Speed > 75 then
            self:EmitSound(Sound("weapons/star_wars_battlefront/common/imp_grenade_stone_0" .. math.random(1,3) .. ".wav"))
        elseif data.Speed > 25 then
            self:EmitSound(Sound("weapons/star_wars_battlefront/common/imp_grenade_dirt_0" .. math.random(1,3) .. ".wav"))
        end
		self:SetAngles(Angle(0,0,0))
        if self.at <= CurTime() and self.ImpactFuse then
            self:Detonate()
	

        end
    end
end

function ENT:Think()
	
    if SERVER and CurTime() >= self.kt then
        self:Detonate()
    end
end

function ENT:Detonate()
    if SERVER then
        if not self:IsValid() then return end
        local effectdata = EffectData()
            effectdata:SetOrigin( self:GetPos() )

        if self:WaterLevel() >= 1 then
            util.Effect( "WaterSurfaceExplosion", effectdata )
        else
            ParticleEffect( "astw2_swbf_explosion_thermal_detonator", self:GetPos(), self:GetAngles() )
sound.Play( "weapons/star_wars_battlefront/common/exp_ord_thermalDetonator0" .. math.random(1,2) .. ".wav",  self:GetPos(), 100, 100 )
        end

        local attacker = self

        if self.Owner:IsValid() then
            attacker = self.Owner
        end

        util.BlastDamage(self, attacker, self:GetPos(), 350, 175)
		util.Decal( "Scorch", self:GetPos(), self:GetPos() - Vector(0, 0, 32), self )
		util.ScreenShake(self:GetPos(),18000,500,1.2,2048)
        self:Remove()

    end
end

function ENT:Draw()
    if CLIENT then
        self:DrawModel()
		
            cam.Start3D() -- Start the 3D function so we can draw onto the screen.
                render.SetMaterial( Material("effects/swbf/flare0") ) -- Tell render what material we want, in this case the flash from the gravgun
                render.DrawSprite( self:GetPos(), math.random(30, 40), math.random(30, 40), Color(155, 50, 50) ) -- Draw the sprite in the middle of the map, at 16x16 in it's original colour with full alpha.
            cam.End3D()
      
    end
end
--addons/aocrp_emplacements/lua/entities/turret_40mm_frag/cl_init.lua:
 include('shared.lua')     
 //[[---------------------------------------------------------     
 //Name: Draw     Purpose: Draw the model in-game.     
 //Remember, the things you render first will be underneath!  
 //-------------------------------------------------------]]  
 function ENT:Draw()      
 // self.BaseClass.Draw(self)  
 -- We want to override rendering, so don't call baseclass.                                   
 // Use this when you need to add to the rendering.        
 self.Entity:DrawModel()       // Draw the model.   
 end  
--addons/aocrp_emplacements/lua/entities/turret_grenade/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
	self.MuzzleAttachment=self:LookupAttachment("muzzle")
	self.shootPos=self:GetDTEntity(1)
	
end
--[[
ENT.HiddenShooter=false
function ENT:Think()
	if not self.HiddenShooter and IsValid(self.shootPos) then
		self.shootPos:SetRenderMode(RENDERMODE_TRANSCOLOR)
		self.shootPos:SetColor(Color(255,255,255,1))
		self.HiddenShooter=true
	end
	
end]]

function ENT:Draw()
	
	self:DrawModel()
	
end
--addons/aocrp_emplacements/lua/entities/turret_rail/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_anim"

ENT.Category		= "Emplacements"
ENT.PrintName 		= "Railcannon Turret"
ENT.Author			= "Wolly/BOT_09"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false

ENT.TurretFloatHeight	=3
ENT.TurretModelOffset	=Vector(0,0,44)
ENT.TurretTurnMax		=0.7

ENT.LastShot 			=0
ENT.ShotInterval 		=4.5

function ENT:SetupDataTables()
	self:DTVar("Entity",0,"Shooter")
	self:DTVar("Entity",1,"ShootPos")
end

function ENT:SetShooter(plr)
	self.Shooter=plr
	self:SetDTEntity(0,plr)
end

function ENT:GetShooter(plr)
	if SERVER then
		return self.Shooter
	elseif CLIENT then
		return self:GetDTEntity(0)
	end
end


function ENT:Use(plr)
	if not self:ShooterStillValid() then
		self:SetShooter(plr)
		self:StartShooting()
		self.ShooterLast=plr
		
		
	else
		if plr==self.Shooter then
			self:SetShooter(nil)
			self:FinishShooting()

		end
	end
end


function ENT:ShooterStillValid()
	local shooter=nil
	if SERVER then
		shooter=self.Shooter
	elseif CLIENT then
		shooter=self:GetDTEntity(0)
	end
	
	return IsValid(shooter) and shooter:Alive() and ((self:GetPos()+self.TurretModelOffset):Distance(shooter:GetShootPos())<=90)
end

function ENT:Think()
	
	if not IsValid(self.turretBase) and SERVER then
		SafeRemoveEntity(self)
	else
		if IsValid(self) then
			
			if SERVER then
				self.BasePos=self.turretBase:GetPos()
				self.OffsetPos=self.turretBase:GetAngles():Up()*1
			end
			
			if self:ShooterStillValid() then
			
				if SERVER then
					local offsetAng=(self:GetAttachment(self.MuzzleAttachment).Pos-self:GetDesiredShootPos()):GetNormal()
					local offsetDot=(self.turretBase:GetAngles():Right()*-1):DotProduct(offsetAng)
					local HookupPos=self:GetAttachment(self.HookupAttachment).Pos
					if offsetDot>=self.TurretTurnMax then
						local offsetAngNew=offsetAng:Angle()
						offsetAngNew:RotateAroundAxis(offsetAngNew:Up(),-90)
						
						self.OffsetAng=offsetAngNew
						
					end
				end
				
				local pressKey=IN_BULLRUSH
				if CLIENT and game.SinglePlayer() then
					pressKey=IN_ATTACK
					
				end
				
				self.Firing=self:GetShooter():KeyDown(pressKey)
				
			else
				self.Firing=false
				if SERVER then
					self.OffsetAng=self.turretBase:GetAngles()
					
					self:SetShooter(nil)
					self:FinishShooting()
				end
			end
			
			if self.Firing then
				self:DoShot()
			end
			self:NextThink(CurTime())
			return true
		end

	self.Shooter:DrawViewModel(true)
	self.Shooter:SetButtons(bit.bor(cmd:GetButtons() - IN_ATTACK, IN_BULLRUSH))

	end
end	

function ENT:DoShot()
	
	
	if self.LastShot+self.ShotInterval<CurTime() then
		if SERVER then
			
			local effectPosAng=self:GetAttachment(self.MuzzleAttachment)
			local vPoint = effectPosAng.Pos
			local effectdata = EffectData()
			effectdata:SetStart( vPoint )
			effectdata:SetOrigin( vPoint )
			effectdata:SetAngles(effectPosAng.Ang + Angle(0,-90,0))
			effectdata:SetEntity(self)
			effectdata:SetScale( 1 )
			util.Effect( "MuzzleEffect", effectdata )
			self:EmitSound(self.ShotSound,50,100)
			
			
		end
		
		if IsValid(self.shootPos) and SERVER then
			local nade = ents.Create("rail_shell")
			local attachAng=self:GetAttachment(self.MuzzleAttachment)
			nade:SetPos(self.shootPos:GetPos() + self.shootPos:GetUp()*30)
			nade:SetAngles(self.shootPos:GetAngles() + Angle(self.Shooter:EyeAngles().p, -90, 0))
			nade:Spawn()
			
			nade:SetOwner(self.Shooter)
			
			self:GetPhysicsObject():ApplyForceCenter( self:GetRight()*-10000 )
			
		end
		
		self.LastShot=CurTime()
	end
	
end
--addons/arccw_weapons/lua/effects/arccw_apex_tracer_energy_rifle/init.lua:
EFFECT.TracerName = "tfa_apex_energy_tracer_ar"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    --print(self.ParticleName)
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetStart(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.EndPos = data:GetOrigin()
    -- util.ParticleTracerEx(self.ParticleName, self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_POINT, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.Position)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(5.0, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--addons/arccw_weapons/lua/effects/arccw_apex_tracer_shotgun/init.lua:
EFFECT.TracerName = "tfa_apex_tracer_shotgun"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    --print(self.ParticleName)
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment() or 1
    self.Position = self:GetTracerShootPos(data:GetStart(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.EndPos = data:GetOrigin()
    -- util.ParticleTracerEx(self.ParticleName, self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_POINT, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.Position)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(5.0, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--addons/arccw_weapons/lua/effects/arccw_apex_tracer_sniper/init.lua:
EFFECT.TracerName = "tfa_apex_tracer_sniper"

function EFFECT:Init(data)
    self.WeaponEnt = data:GetEntity()
    --print(self.ParticleName)
    if not IsValid(self.WeaponEnt) then return end
    self.Attachment = data:GetAttachment()
    self.Position = self:GetTracerShootPos(data:GetStart(), self.WeaponEnt, self.Attachment)

    if IsValid(self.WeaponEnt.Owner) then
        if self.WeaponEnt.Owner == LocalPlayer() then
            if not self.WeaponEnt.Owner:GetViewEntity() then
                ang = self.WeaponEnt.Owner:EyeAngles()
                ang:Normalize()
                --ang.p = math.max(math.min(ang.p,55),-55)
                self.Forward = ang:Forward()
            else
                self.WeaponEnt = self.WeaponEnt.Owner:GetViewModel()
            end
            --ang.p = math.max(math.min(ang.p,55),-55)
        else
            ang = self.WeaponEnt.Owner:EyeAngles()
            ang:Normalize()
            self.Forward = ang:Forward()
        end
    end

    self.EndPos = data:GetOrigin()
    -- util.ParticleTracerEx(self.ParticleName, self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)
    local pcf = CreateParticleSystem(self.WeaponEnt, self.TracerName, PATTACH_POINT, self.Attachment)
    if IsValid(pcf) then
        pcf:SetControlPoint(0,self.Position)
        pcf:SetControlPoint(1,self.EndPos)
        pcf:StartEmission()
    end
    timer.Simple(5.0, function()
        if IsValid(pcf) then
            pcf:StopEmissionAndDestroyImmediately()
        end
    end)
end

function EFFECT:Think()
    return false
end

function EFFECT:Render()
    if self.InValid then return false end
end
--addons/arccw_weapons/lua/effects/effect_astw2_halo3_impact/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/swbf/sparks" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/swrc/smg_impacts", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.2 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 10 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, 8 do
			local smokeTexture	= "effects/swbf/thicksmoke"
			
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(250, 2500));
			particle_s:SetDieTime(math.Rand(2, 5));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(10, 20));
			particle_s:SetEndSize(math.Rand(20, 40));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(50, 150);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(false);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo3_impact_spiker/init.lua:
EFFECT.Duration			= 0.25;
EFFECT.Size				= 32;

local MaterialGlow		= Material( "effects/halo3/8pt_ringed_star_flare" );

function EFFECT:Init( data )

	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = self.Duration;

	-- particles
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/spiker_muzzleflash", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.15 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 30 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 185, 100);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
	for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/explosive_burst", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.1, 0.2 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 25 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 185, 100);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/muzzle_flash_round_gaseous", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.2, 0.3 ) );
			particle:SetStartAlpha( 155 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 25 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(255, 185, 185);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
			for i = 1, 1 do

			local particle = emitter:Add( "effects/halo3/electric_arcs", self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + Vector(math.Rand(3, 5),math.Rand(3, 5),1) * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.05, 0.1 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 3, 5 ) );
			particle:SetEndSize( 20 );
			particle:SetRoll( math.Rand(-55, 85) );
			particle:SetGravity( Vector( 0, 0, 0 ) );
			particle:SetColor(100, 100, 255);
			particle:SetCollide( true );
			particle:SetBounce( 0 );
			particle:SetAirResistance( 500 );

		end
		emitter:Finish();
	end
	end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;

end


function EFFECT:Render()

	local frac = math.max( 0, self.LifeTime / self.Duration );
	local rgb = 255 * frac;
	local color = Color( 255, 145, rgb, 255 );

	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, self.Size, self.Size, color );

end

--addons/arccw_weapons/lua/effects/effect_astw2_halo_spv3_tracer_carbine/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 16000;
EFFECT.Length				= 5096;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/halo3/muzzle_flash_01" );
local MaterialFront			= Material( "effects/halo_spv3/flash/smg_new" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end

end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 8, 8, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 15, 0, 1, color_white );
	
end

--addons/arccw_weapons/lua/effects/effect_astw2_swbf_laser_crimson/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4000;
EFFECT.Length				= 128;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/swbf/blasterfire_red" );
local MaterialFront			= Material( "effects/swbf/blasterfire_red" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 0, 0, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 20, 0, 1, color_white );
	
end

--addons/aoc_nextbots/lua/effects/effect_npc_laser_cyan.lua:
TRACER_FLAG_USEATTACHMENT = 0x0002
SOUND_FROM_WORLD = 0
CHAN_STATIC = 6

EFFECT.Speed = 6500
EFFECT.Length = 64
EFFECT.WhizDistance = 72

local MaterialMain = Material("effects/sw_laser_blue_main")
local MaterialFront = Material("effects/sw_laser_blue_front")
local MaterialGlow = Material("sprites/light_glow02_add")
local ColorRed = Color(0, 225, 255)

function EFFECT:GetTracerOrigin(data)
    local start = data:GetStart()

    if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
        local entity = data:GetEntity()

        if (not IsValid(entity)) then
            return start
        end
        if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then
            return start
        end

        if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
            local pl = entity:GetOwner()
            if (IsValid(pl)) then
                local vm = pl:GetViewModel()
                if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
                    entity = vm
                else
                    if (entity.WorldModel) then
                        entity:SetModel(entity.WorldModel)
                    end
                end
            end
        end

        local attachment = entity:GetAttachment(data:GetAttachment())
        if (attachment) then
            start = attachment.Pos
        end
    end

    return start
end

function EFFECT:Init(data)
    self.StartPos = self:GetTracerOrigin(data)
    self.EndPos = data:GetOrigin()

    self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)

    local diff = (self.EndPos - self.StartPos)

    self.Normal = diff:GetNormal()
    self.StartTime = 0
    self.LifeTime = (diff:Length() + self.Length) / self.Speed

    local weapon = data:GetEntity()
    if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
        local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
    end
end

function EFFECT:Think()
    self.LifeTime = self.LifeTime - FrameTime()
    self.StartTime = self.StartTime + FrameTime()

    return self.LifeTime > 0
end

function EFFECT:Render()
    local endDistance = self.Speed * self.StartTime
    local startDistance = endDistance - self.Length

    startDistance = math.max(0, startDistance)
    endDistance = math.max(0, endDistance)

    local startPos = self.StartPos + self.Normal * startDistance
    local endPos = self.StartPos + self.Normal * endDistance

    render.SetMaterial(MaterialFront)
    render.DrawSprite(endPos, 8, 8, color_white)

    render.SetMaterial(MaterialMain)
    render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)

    render.SetMaterial(MaterialGlow)
    render.DrawSprite(startPos, 50, 50, ColorRed)
end

--addons/arccw_weapons/lua/effects/effect_t_shuriken/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 20000;
EFFECT.Length				= 1000;
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "effects/sw_laser_blue_main" );
local MaterialFront			= Material( "effects/sw_laser_blue_front" );

function EFFECT:GetTracerOrigin( data )

	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart();
	
	-- use attachment?
	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity();
		
		if( not IsValid( entity ) ) then return start; end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start; end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			
			-- use the view model
			local pl = entity:GetOwner();
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel();
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm;
				else
					-- HACK: fix the model in multiplayer
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel );
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() );
		if( attachment ) then
			start = attachment.Pos;
		end

	end
	
	return start;

end


function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data );
	self.EndPos = data:GetOrigin();
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos );

	local diff = ( self.EndPos - self.StartPos );
	
	self.Normal = diff:GetNormal();
	self.StartTime = 0;
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed;
	
	-- whiz by sound
	local weapon = data:GetEntity();
	if( IsValid( weapon ) and ( not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer() ) ) then

		local dist, pos, time = util.DistanceToLine( self.StartPos, self.EndPos, EyePos() );
	end
end


function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime();
	self.StartTime = self.StartTime + FrameTime(); 

	return self.LifeTime > 0;

end


function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime;
	local startDistance = endDistance - self.Length;
	
	startDistance = math.max( 0, startDistance );
	endDistance = math.max( 0, endDistance );

	local startPos = self.StartPos + self.Normal * startDistance;
	local endPos = self.StartPos + self.Normal * endDistance;
	
	render.SetMaterial( MaterialFront );
	render.DrawSprite( endPos, 8, 8, color_white );

	render.SetMaterial( MaterialMain );
	render.DrawBeam( startPos, endPos, 7, 3, 3, color_white );
	
end

--addons/lvs_base/lua/effects/lvs_exhaust_fire.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Dir = data:GetNormal()
	local Ent = data:GetEntity()
	local Scale = data:GetMagnitude()

	if not IsValid( Ent ) then return end

	local emitter = Ent:GetParticleEmitter( Pos )

	if not IsValid( emitter ) then return end

	local particle = emitter:Add( "effects/lvs_base/fire", Pos )

	if particle then
		particle:SetVelocity( Dir * 70 )
		particle:SetDieTime( 0.2 )
		particle:SetAirResistance( 0 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 10 + 18 * Scale )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-1,1) * 180 )
		particle:SetColor( 255,255,255 )
		particle:SetGravity( Vector( 0, 0, 100 ) )
		particle:SetCollide( false )
	end
	
	for i = 1, 3 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), Pos )
		
		if particle then
			particle:SetVelocity( Dir * 40 * i )
			particle:SetDieTime( 0.2 )
			particle:SetAirResistance( 0 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( (5 + 5 * Scale) - i )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-1,1) * 180 )
			particle:SetColor( 255,255,255 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_base/lua/effects/lvs_firetrail.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Entity = data:GetEntity()
	self.Scale = data:GetScale()
	self.DieTime = CurTime() + data:GetMagnitude()
	self.Pos = data:GetStart()
	
	if not IsValid( self.Entity ) then return end

	self.Emitter = ParticleEmitter( self.Entity:LocalToWorld( self.Pos ), false )
end


function EFFECT:Think()
	if IsValid( self.Entity ) then
		local Pos = self.Entity:LocalToWorld( self.Pos )

		local T = CurTime()

		if (self.nextDFX or 0) < T then
			self.nextDFX = T + 0.05

			if self.Emitter then
				local particle = self.Emitter:Add( Materials[ math.random(1, #Materials ) ], Pos )

				if particle then
					particle:SetVelocity( VectorRand() * 100 * self.Scale )
					particle:SetDieTime( 3 )
					particle:SetAirResistance( 0 )
					particle:SetStartAlpha( 150 )
					particle:SetStartSize( 150 * self.Scale )
					particle:SetEndSize( math.Rand(200,300) * self.Scale )
					particle:SetRoll( math.Rand(-1,1) * 100 )
					particle:SetColor( 40,40,40 )
					particle:SetGravity( Vector( 0, 0, 0 ) )
					particle:SetCollide( false )
				end

				local particle = self.Emitter:Add( "effects/lvs_base/fire", Pos )

				if particle then
					particle:SetVelocity( VectorRand() * 100 * self.Scale )
					particle:SetDieTime( math.random(40,80) / 100 )
					particle:SetAirResistance( 0 ) 
					particle:SetStartAlpha( 255 )
					particle:SetStartSize( 130 * self.Scale )
					particle:SetEndSize( math.Rand(50,100) * self.Scale )
					particle:SetRoll( math.Rand(-1,1) * 180 )
					particle:SetColor( 255,255,255 )
					particle:SetGravity( Vector( 0, 0, 70 ) )
					particle:SetCollide( false )
				end

				for i = 0,3 do
					local particle = self.Emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), Pos + VectorRand() * 100 * self.Scale )

					if particle then
						particle:SetVelocity( VectorRand() * 100 * self.Scale )
						particle:SetDieTime( math.random(30,60) / 100 )
						particle:SetAirResistance( 0 ) 
						particle:SetStartAlpha( 255 )
						particle:SetStartSize( 70 * self.Scale )
						particle:SetEndSize( math.Rand(25,80) * self.Scale )
						particle:SetRoll( math.Rand(-1,1) * 180 )
						particle:SetColor( 255,255,255 )
						particle:SetGravity( Vector( 0, 0, 40 ) )
						particle:SetCollide( false )
					end
				end
			end
		end

		if self.DieTime < CurTime() then 
			if self.Emitter then
				self.Emitter:Finish()
			end

			return false
		end

		return true
	end

	if self.Emitter then
		self.Emitter:Finish()
	end

	return false
end

function EFFECT:Render()
end

--addons/lvs_addons/lua/effects/lvs_hover_water.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Ent = data:GetEntity()
	self.Size = data:GetMagnitude()

	if not IsValid( Ent ) then return end

	self.LifeTime = math.Rand(1.5,3)
	self.DieTime = CurTime() + self.LifeTime

	self.Splash = {
		Pos = Pos,
		Mat = Material("effects/splashwake1"),
		RandomAng = math.random(0,360),
	}

	local emitter = Ent:GetParticleEmitter( Ent:GetPos() )

	if emitter and emitter.Add then
		local particle = emitter:Add( "effects/splash4", Pos )
		if not particle then return end

		local Vel = Ent:GetVelocity():Length()

		particle:SetVelocity( Vector(0,0,math.Clamp(Vel / 2,100,250)) )
		particle:SetDieTime( 0.25 + math.min(Vel / 200,0.35) )
		particle:SetAirResistance( 60 ) 
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( self.Size * 0.2 )
		particle:SetEndSize(  self.Size * 2 )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		particle:SetColor( 255,255,255 )
		particle:SetGravity( Vector( 0, 0, -600 ) )
		particle:SetCollide( false )
	end
end


function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	end
	return true
end

function EFFECT:Render()
	if self.Splash and self.LifeTime then
		local Scale = ((self.DieTime - self.LifeTime - CurTime()) / self.LifeTime)
		local S =  self.Size * 5 + (self.Size * 5) * Scale
		local Alpha = 100 + 100 * Scale

		cam.Start3D2D( self.Splash.Pos + Vector(0,0,1), Angle(0,0,0), 1 )
			surface.SetMaterial( self.Splash.Mat )
			surface.SetDrawColor( 255, 255, 255 , Alpha )
			surface.DrawTexturedRectRotated( 0, 0, S , S, self.Splash.RandomAng )
		cam.End3D2D()
	end
end
--addons/lvs_addons/lua/effects/lvs_laser_blue_long.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 2500 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 2, endpos + dir * len * 2, 200, 1, 0, Color( 0, 0, 255, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 0, 0, 255, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--addons/lvs_addons/lua/effects/lvs_laser_red.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1000 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 4, endpos + dir * len * 4, 200, 1, 0, Color( 255, 0, 0, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 255, 0, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--addons/lvs_base/lua/effects/lvs_shield_impact.lua:

local LastImpact = 0

function EFFECT:Init( data )
	self.Ent = data:GetEntity()
	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )

	local T = CurTime()

	self.LifeTime = 0.2
	self.DieTime = T + self.LifeTime

	local DontHurtEars = math.Clamp( T - LastImpact, 0.4, 1 ) ^ 2

	LastImpact = T

	sound.Play( "lvs/shield_deflect.ogg", self.Pos, 120, 100, DontHurtEars )

	self:Spark( self.Pos )

	if IsValid( self.Ent ) then
		self.Model = ClientsideModel( self.Ent:GetModel(), RENDERMODE_TRANSCOLOR )
		self.Model:SetMaterial("models/alyx/emptool_glow")
		self.Model:SetColor( Color(200,220,255,255) )
		self.Model:SetParent( self.Ent, 0 )
		self.Model:SetMoveType( MOVETYPE_NONE )
		self.Model:SetLocalPos( Vector( 0, 0, 0 ) )
		self.Model:SetLocalAngles( Angle( 0, 0, 0 ) )
		self.Model:AddEffects( EF_BONEMERGE )
	end
end

function EFFECT:Spark( pos )
	local emitter = ParticleEmitter( pos, false )

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/rico1", pos )

		local vel = VectorRand() * 500

		if not particle then continue end

		particle:SetVelocity( vel )
		particle:SetAngles( vel:Angle() + Angle(0,90,0) )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetStartAlpha( math.Rand( 200, 255 ) )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(10,20) )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand(-100,100) )
		particle:SetRollDelta( math.Rand(-100,100) )
		particle:SetColor( 0, 127, 255 )

		particle:SetAirResistance( 0 )
	end

	emitter:Finish()
end

function EFFECT:Think()
	if not IsValid( self.Ent ) then
		if IsValid( self.Model ) then
			self.Model:Remove()
		end
	end

	if self.DieTime < CurTime() then 
		if IsValid( self.Model ) then
			self.Model:Remove()
		end

		return false
	end
	
	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( self.mat )
	render.DrawSprite( self.Pos, 800 * Scale, 800 * Scale, Color( 0, 127, 255, 255) )
	render.DrawSprite( self.Pos, 200 * Scale, 200 * Scale, Color( 255, 255, 255, 255) )
end

--addons/lvs_base/lua/effects/lvs_tracer_orange.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 1600 * bullet:GetLength()

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 3, 1, 0, Color( 255, 255, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 10, 1, 0, Color( 125, 50, 0, 255 ) )
end

--addons/arccw_weapons/lua/effects/new_laser_small.lua:
AddCSLuaFile()

EFFECT.DoTracer				= true
EFFECT.TracerColor			= Color(0, 150, 200)
EFFECT.TracerChanceFP		= 1
EFFECT.TracerChanceTP		= 1
EFFECT.Speed 				= 5000
EFFECT.BaseMat				= "effects/drc_sw/lens_light0"
EFFECT.TailMat				= "effects/drc_sw/beam1"
EFFECT.BaseSize				= 1
EFFECT.TailWidth			= 2
EFFECT.TailLength 			= 100
EFFECT.FirstPersonScale		= 1
EFFECT.FirstPersonSpeed		= 0.5

EFFECT.TracerLight			= true
EFFECT.LightColor			= Color(0, 100, 255)
EFFECT.LightBrightness		= 1
EFFECT.LightSize			= 300

EFFECT.MuzzleEffect		= "drc_sw_muzzle_blue"
EFFECT.ImpactEffect		= nil
EFFECT.ImpactSound		= "vrc.bolt_impact"

EFFECT.Beams = {}
EFFECT.BeamLifeTime = 1

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if data:GetEntity() == LocalPlayer():GetViewModel() then
		self.WeaponEnt = LocalPlayer():GetActiveWeapon()
		self.BaseSize = self.BaseSize * self.FirstPersonScale
		self.TailWidth = self.TailWidth * self.FirstPersonScale
		self.Speed = self.Speed * self.FirstPersonSpeed
		if self.DoTracer == true && math.Rand(0, 1) > self.TracerChanceFP then self.DoTracer = false end
	else
		if self.DoTracer == true && math.Rand(0, 1) > self.TracerChanceTP then self.DoTracer = false end
	end
	self.StartPos = self.WeaponEnt:GetWeaponAttachment("muzzle").Pos
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.TracerColor = self.WeaponEnt.EffectTint
	
	if self.ImpactSound then sound.Play(self.ImpactSound, self.EndPos) end
	
	local subt = self.EndPos - self.StartPos
	self.Normal = subt:GetNormal()
	self.StartTime = 0

	self.LifeTime = (subt:Length() + self.TailLength) / self.Speed
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, thyme = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
	
	if self.ImpactEffect then
		local ImpactData = EffectData()
		ImpactData:SetOrigin(self.EndPos)
		ImpactData:SetStart(self.StartPos)
		ImpactData:SetAttachment(data:GetAttachment())
		ImpactData:SetEntity(data:GetEntity())
		util.Effect(self.ImpactEffect, ImpactData)
	end
	
	if self.MuzzleEffect then
		local MuzzleData = EffectData()
		MuzzleData:SetOrigin(self.StartPos)
		MuzzleData:SetStart(self.EndPos)
		MuzzleData:SetAttachment(data:GetAttachment())
		MuzzleData:SetEntity(data:GetEntity())
		util.Effect(self.MuzzleEffect, MuzzleData)
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	local endDistance = self.Speed * self.StartTime
	local endPos = self.StartPos + self.Normal * endDistance
	
	if self.TracerLight == true then
	local ParticleLight = DynamicLight(self:EntIndex())
		if (ParticleLight) then
			ParticleLight.pos = endPos
			ParticleLight.r = self.LightColor.r
			ParticleLight.g = self.LightColor.g
			ParticleLight.b = self.LightColor.b
			ParticleLight.brightness = self.LightBrightness
			ParticleLight.Decay = 1000
			ParticleLight.Size = self.LightSize
			ParticleLight.nomodel = 0
			ParticleLight.style = 6
			ParticleLight.DieTime = CurTime() + 3
		end
	else end
	
	self.BeamAlpha = 255 * ( 1 - self.LifeTime )
	
	if !self.Life then self.Life = 0.001 end
	self.Life = self.Life + FrameTime() / self.BeamLifeTime
	self.BeamAlpha = 255 * ( 1 - self.Life )
	return ( self.Life < 1 )
--	return self.LifeTime > 0
end


function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.TailLength
	
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
	if self.DoTracer == true && self.LifeTime > 0 then
		render.SetMaterial(Material(self.BaseMat))
		render.DrawSprite(endPos, 8 * self.BaseSize, 8 * self.BaseSize, self.TracerColor)
		render.SetMaterial(Material(self.TailMat))
		render.DrawBeam(startPos, endPos, self.TailWidth, 0, 1, self.TracerColor)
	end
	
	if self.Beams then
		for k,v in pairs(self.Beams) do
			local texcoord = math.Rand( 0, 1 )
			local norm = (self.StartPos - self.EndPos) * self.LifeTime
			v.Length = norm:Length()
			render.SetMaterial(Material(v.Mat))
			for i=1,v.Passes do
				render.DrawBeam( self.StartPos - self.WeaponEnt:GetWeaponAttachment("muzzle").Ang:Up(), 
				self.EndPos, 
				v.Width / 2, texcoord, 
				texcoord + ( ( self.StartPos - self.EndPos ):Length() / 128 ),
				Color(v.Colour.r, v.Colour.g, v.Colour.b, self.BeamAlpha))
			end
		end
	end
end
--addons/weapon_jedi/lua/effects/saber_block.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Dir = data:GetNormal()
	self.LifeTime = 0.2
	self.DieTime = CurTime() + self.LifeTime
	
	self:Spark( self.Pos, self.Dir )
end

function EFFECT:Spark( pos, dir )
	local emitter = ParticleEmitter( pos, false )
	
	for i = 0, 20 do
		local particle = emitter:Add( "sprites/rico1", pos )
		
		local vel = VectorRand() * 200 + dir * 80
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.1,0.2) )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(2,4) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )

			particle:SetAirResistance( 0 )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end
	
	return true
end

local mat = Material( "sprites/light_glow02_add" )

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( mat )
	render.DrawSprite( self.Pos + self.Dir, 150 * Scale, 150 * Scale, Color( 255, 255, 200, 255) ) 
end

--addons/arccw_weapons/lua/effects/sw_explosion.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	
	self:Explosion( Pos )
	
	sound.Play( "ambient/explosions/explode_4.wav", Pos, 95, 200, 0.5 )
end

function EFFECT:Explosion( pos )
	local emitter = ParticleEmitter( pos, false )
	
	for i = 0,20 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], pos )
		
		if particle then
			particle:SetVelocity( VectorRand() * 800 )
			particle:SetDieTime( math.Rand(1,2) )
			particle:SetAirResistance( math.Rand(1000,1500) ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(5,15) )
			particle:SetEndSize( math.Rand(30,50) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 20,20,20 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end
	
	for i = 0, 20 do
		local particle = emitter:Add( "sprites/rico1", pos )
		
		local vel = VectorRand() * 800
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.1,0.15) )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(6,12) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( 255, 255, 255 )

			particle:SetAirResistance( 0 )
		end
	end
	
	for i = 0, 40 do
		local particle = emitter:Add( "sprites/flamelet"..math.random(1,5), pos )
		
		if particle then
			particle:SetVelocity( VectorRand() * 300 )
			particle:SetDieTime( 0.14 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( math.Rand(10,20) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end
	
	emitter:Finish()
	
	local dlight = DynamicLight( math.random(0,9999) )
	if dlight then
		dlight.pos = pos
		dlight.r = 255
		dlight.g = 180
		dlight.b = 100
		dlight.brightness = 8
		dlight.Decay = 2000
		dlight.Size = 100
		dlight.DieTime = CurTime() + 0.1
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/arccw_weapons/lua/effects/tfa_csgo_healnade/init.lua:
--Thanks Inconceivable/Generic Default
function EFFECT:Init(data)
	self.Entity = data:GetEntity()
	pos = data:GetOrigin()
	self.Emitter = ParticleEmitter(pos)
	for i=1, 10 do
		local particle = self.Emitter:Add( "tfa_csgo/particle/particle_smokegrenade", pos)
		if (particle) then
			particle:SetVelocity( VectorRand():GetNormalized()*math.Rand(150, 300) )
			if i <= 5 then 
				particle:SetDieTime( 20 )
			else
				particle:SetDieTime( math.Rand( 15,20 ) )
			end
			particle:SetStartAlpha( math.Rand( 66, 166 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 66 )
			particle:SetEndSize( 166 )
			particle:SetRoll( math.Rand(0, 360) )
			particle:SetRollDelta( math.Rand(-1, 1)/3 )
			particle:SetColor( 125, 255, 255 ) 
			particle:SetAirResistance( 82 ) 
			//particle:SetGravity( Vector(math.Rand(-30, 30),math.Rand(-30, 30), -200 )) 	
			particle:SetCollide( true )
			particle:SetBounce( 1 )
		end
	end

end

function EFFECT:Think()
return false
end

function EFFECT:Render()

end
--addons/arccw_weapons/lua/effects/tracer_yellow/init.lua:
EFFECT.Mat = Material("effects/laser_tracer")
EFFECT.Speed = 1024 * 15
EFFECT.TracerLength = 5

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	-- Keep the start and end pos - we're going to interpolate between them
    self.StartPos = self:GetTracerShootPos(self.Position, self.WeaponEnt, self.Attachment)
    self.EndPos = data:GetOrigin()

	self.Dir = self.EndPos - self.StartPos

	self:SetRenderBoundsWS( self.StartPos, self.EndPos )

    self.StartTime = 0
	self.TracerTime = math.min( 1, self.StartPos:Distance( self.EndPos ) / 7000 ) * 1
	self.Length = 0.33

	-- Die when it reaches its target
	self.DieTime = CurTime() + self.TracerTime

	local Dir = self.Dir:GetNormalized()

	local emitter = ParticleEmitter( self.StartPos, false )

	for i = 0, 5 do
		local particle = emitter:Add( Materials[math.random(1,table.Count( Materials ))], self.StartPos )

		local rCol = 255

		if particle then
			particle:SetVelocity( Dir * math.Rand(100,500) + VectorRand() * math.Rand(0,10) )
			particle:SetDieTime( math.Rand(0.05,0.2) )
			particle:SetAirResistance( math.Rand(50,100) )
			particle:SetStartAlpha( 5 )
			particle:SetStartSize( 2 )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( rCol, rCol, rCol )
			particle:SetGravity( VectorRand() * 200 + Vector(0,0, -500) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

local hitColor = Vector(218, 165, 18)

function EFFECT:Think()
    self.StartTime = self.StartTime + FrameTime()

	if CurTime() > self.DieTime then
		local effectdata = EffectData()
			effectdata:SetStart( hitColor )
			effectdata:SetOrigin( self.EndPos )
			effectdata:SetNormal( self.Dir:GetNormalized() )
		util.Effect( "laser_hit", effectdata )

		return false
	end

	return true
end

local mainColor = Color(218, 165, 18)
local innerColor = Color(192, 192, 192)

function EFFECT:Render()
	local fDelta = ( self.DieTime - CurTime() ) / self.TracerTime
	fDelta = math.Clamp( fDelta, 0, 1 ) ^ 2

	local sinWave = math.sin( fDelta * math.pi )

	local Pos1 = self.EndPos - self.Dir * ( fDelta - sinWave * self.Length )

	render.SetMaterial( self.Mat )
	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        8, 5, 0, mainColor
    )

	render.DrawBeam( Pos1,
		self.EndPos - self.Dir * ( fDelta + sinWave * self.Length ),
        2, 5, 0, innerColor
    )

    if --[[DynamicTracer:GetBool()]] true then
    local spawn = util.CRC(tostring(self:GetPos()))
    local dlight = DynamicLight(self:EntIndex() + spawn)
    local endDistance = self.Speed * self.StartTime
    local endPos = self.StartPos + self.Dir:GetNormalized() * endDistance

    if (dlight) then
        dlight.pos = endPos
        dlight.r = 218
        dlight.g = 165
        dlight.b = 18
        dlight.brightness = 7
        dlight.Decay = 1000
        dlight.Size = 500
        dlight.DieTime = CurTime() + 3
    end
end
end
--LuaCmd:
LSCS:RefreshMenu() LocalPlayer():lscsBuildPlayerInfo()