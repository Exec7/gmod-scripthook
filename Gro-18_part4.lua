--Stealed clientside server code by exechack.cc
--Hostname: Große Armee der Republik ★EGM★ [57 / 100] [v4.0.11] - Part 4/5 - 06/04/2025


--addons/bkeypads/lua/bkeypads/lang/english.lua:
return {
	Name = "English",
	Flag = "flag16/gb.png",
	Phrases = {
		-- 4.0.0
		Welcome = "Welcome",
		TutorialWelcomeTip = "Welcome to Billy's Keypads!",
		TutorialPlacingKeypads = "Placing Keypads",
		TutorialPlacingKeypadsTip = "Learn how to place keypads with the toolgun",
		TutorialWhatIsKeypad = "What's a Keypad?",
		TutorialKeypadAppearance = "Keypad Appearance",
		TutorialKeypadAppearanceTip = "Customizing the appearance of your keypads",
		TutorialKeypadAccess = "Keypad Access",
		TutorialKeypadAccessTip = "Controlling who has access and who doesn't have access to your keypads",
		TutorialWhatIsFadingDoor = "What's a Fading Door?",
		Linking = "Linking",
		TutorialLinkingKeypads = "Linking Keypads",
		TutorialLinkingKeypadsTip = "Linking keypads together to form a network of access rules",
		TutorialLinkingFadingDoors = "Linking Fading Doors",
		TutorialLinkingFadingDoorsTip = "Linking keypads to fading doors",
		TutorialLinkingMapObjects = "Linking Map Objects",
		TutorialLinkingMapObjectsTip = "Linking keypads to map objects (doors, buttons, etc.)",
		TutorialKeypadTypes = "Keypad Types", -- Types = types of keypad: FaceID, PIN, keycard, etc.
		KeycardScanner = "Keycard Scanner",
		TutorialPINTip = "Keypads that you punch a numeric code into (e.g. 6969)",
		TutorialKeycardScannerTip = "Keypads that you insert a keycard into",
		TutorialFaceIDTip = "Keypads that you scan your face",
		Language = "Language",
		TutorialLanguageMsg = "You can change the language of Billy's Keypads by changing Garry's Mod's language in the bottom right.\nIf everything is still English for you, then it means we haven't translated Billy's Keypads to your language yet, sorry!",
		TutorialSettingsMsg = "You can access your personal settings for Billy's Keypads (this will carry across servers) in Q > Options > Billy's Keypads.\nWe've opened it for you! If you want to close the spawnmenu, click the empty space outside of it.",
		TutorialConfiguringFadingDoors = "Configuring Fading Doors",
		TutorialMapDoors = "Map Doors",
		TutorialMapButtons = "Buttons",
		MapObjects = "Map Objects",
		TutorialQuickStart = "Quick Start / TL;DR",

		YouTubeTutorials = "YouTube Tutorials",
		YouTubeTutorialsTip = "A collection of YouTube tutorials created by the community",

		TutorialWhatIsFadingDoorCaption = "Fading Doors are props which momentarily become translucent and passable when opened",
		TutorialWhatIsFadingDoorCaption2 = "You can create them using the \"%tool.bkeypads_fading_door.name%\" tool",
		TutorialWhatIsFadingDoorCaption3 = "You can't get stuck in fading doors; they will not close on you.",
		TutorialWhatIsFadingDoorCaption4 = "They will close as you exit them.",

		TutorialWhatIsKeypadCaption1 = "Keypads are devices that can be used to secure access to a wide variety of systems, doors and objects",
		TutorialWhatIsKeypadCaption2 = "There are three different types of keypad: FaceID, PIN and Keycard Scanners",
		TutorialWhatIsKeypadCaption3 = "Here's a keypad in action!",

		TutorialKeypadAccessCaption1 = "Keypads are capable of very advanced access configurations, i.e., who has access, and who doesn't?",
		TutorialKeypadAccessCaption2 = "Each keypad has a whitelist and a blacklist configured by its creator",
		TutorialKeypadAccessCaption3 = "A wide variety of different access groups can be whitelisted or blacklisted to keypads",
		TutorialKeypadAccessCaption4 = "Give it a try!",

		TutorialLinkingFadingDoorsStep1 = "First, create the Fading Door (if you haven't already)",
		TutorialLinkingFadingDoorsStep2 = "Next, get out your \"%tool.bkeypads_linker.name%\" tool and click the keypad",
		TutorialLinkingFadingDoorsStep3 = "Finally, simply click on the Fading Door",
		TutorialLinkingFadingDoorsStep4 = "Let's test it!",
		TutorialLinkingFadingDoorsStep5 = "Nice.",

		TutorialPaymentKeypads = "Payment Keypads",
		TutorialPaymentKeypadsCaption1 = "Keypads can be set up with an access charge",
		TutorialPaymentKeypadsCaption2 = "The keypad will behave like a normal keypad to the creator of the keypad",
		TutorialPaymentKeypadsCaption3 = "But, to anyone else, they'll be charged money for access",
		TutorialPaymentKeypadsCaption4 = "Payment keypads can also be configured to only charge non-whitelisted people",

		TutorialEasy = "Easy!",

		-- 3.3.1
		Setting_Dyslexia = "Dyslexia",
		Setting_DyslexiaTip = "Enable dyslexia font",

		-- 3.3.0
		PermaProps = "What are you doing? That's the wrong tool for making keypads persistent bro.",
		PermaProps_AlreadySaved = "This entity has already been saved by Billy's Keypads. There is no need to PermaProp it.",
		Nevermind = "Nevermind",
		MirrorPlacement = "Mirror Placement", -- Mirror Placement will place the keypad on the opposite side of the prop too
		MirrorPlacementTip = "Mirrors the placement of the keypad on the prop.\nThe mirrored keypad will not count towards your keypad limit.\nThey are welded together, and removing either of the keypads will remove the other.\nThey will be automatically linked together for you.",

		-- 3.2.0
		RainbowBackground = "Rainbow Background",

		-- 3.1.0
		KeypadOnlyFadingDoors = "NOT A FADING DOOR",

		-- 3.0.2
		PaymentPrompt = "This keypad will charge you %s for access.\nWould you like to continue?",
		PaymentNamedPrompt = "\"%s\" will charge you %s for access.\nWould you like to continue?",
		PaymentPromptTitle = "Payment Required",

		-- 3.0.1
		CrackerNotLinked = "NOT LINKED",

		-- 3.0.0
		CrackerWaiting = "WAITING",
		CrackerTooFar = "TOO FAR",
		CrackerReady = "READY",
		CrackerCantCrack = "CANT CRACK",
		CrackSuccess = "SUCCESS",
		CrackFailed = "FAILED",
		KeypadCracker = "Keypad Cracker",
		NoneProfileError = "You cannot use the persistent keypads tool whilst the \"none\" profile is active",
		NoneProfileToolscreen = "\"none\" profile is active",

		-- 2.4.0
		DoorLock = "Lock Door",
		DoorLockTip = "Locks the door automatically for you",
		DisableMapObjTip = "When enabled, the map object will be disabled; nothing will be able to interact with it (including battering rams, lockpicks, etc.) and it can only be interacted with via the keypad.\n\nFor doors, this will automatically keep them locked.",
		Undo_bkeycard_pickup = "Undo Dropped Keycard",
		Undone_bkeycard_pickup = "Undone Dropped Keycard",
		FlagName = "Flag: %s",
		HelixFlag = "Helix Flag", -- do not translate Helix
		Flag = "Flag",

		-- 2.3.0
		KeypadImages = "Keypad Images",
		BanFromFeature = "Ban Player from Feature",
		UnbanFromFeature = "Unban Player from Feature",
		BannedFromFeature = "You are banned from this feature!",
		BannedFromFeatureAdmin = "Player successfully BANNED from feature",
		UnbannedFromFeatureAdmin = "Player successfully UNBANNED from feature",
		FadingDoorKey = "Open Key", -- key on keyboard that opens fading door
		FadingDoorKeyTip = "The key on your keyboard that opens the fading door",
		FadingDoorLinkTip = "You can link fading doors to keypads using the Linker tool",
		UncrackableIncompatibilitiesTip = "NOTE: Some keypad crackers may not be compatible and may ignore this",

		-- 2.2.0
		Access = "Access",
		AccessCharge = "Access Charge",
		AccessDenied = "Access Denied",
		AccessDeniedKey = "Access Denied Key",
		AccessDeniedKeyTip = "The key that will be pressed on your keyboard when access is denied",
		AccessDeniedNotificationTip = "Receive notifications when access is DENIED from someone on this keypad?",
		AccessGranted = "Access Granted",
		AccessGrantedKey = "Access Granted Key",
		AccessGrantedKeyTip = "The key that will be pressed on your keyboard when access is granted",
		AccessGrantedNotificationTip = "Receive notifications when access is GRANTED to someone on this keypad?",
		AccessLogs = "Access Logs",
		KeypadAccessLogs = "Keypad Access Logs",
		AccessLogsWarrant = "You need a warrant in order to be able to view the access logs of this keypad.",
		AccessTable = "Access Table",
		ActiveSound = "Active Sound",
		AddGroup = "Add %s",
		Added = "Added",
		AdminMenu = "Admin Menu",
		AdminTool = "Admin Tool",
		All = "All",
		AllSuperiorKeycards = "All Superior Keycards",
		Appearance = "Appearance",
		AreYouSureDeleteImage = "Are you sure you want to delete this image?",
		AuthMode = "Auth Mode",
		AutoFadingDoor = "Auto Fading Door",
		AutoFadingDoorTip = "Automatically create & link fading doors when creating a keypad on the prop you're looking at",
		BackgroundColor = "Background Color",
		Behaviour = "Behaviour",
		Blacklist = "Blacklist",
		BlacklistTip = "Who should access be denied from?\nThe blacklist is prioritized over the whitelist.",
		Blacklisted = "Blacklisted",
		Broken = "Broken",
		Buttons = "Buttons",
		CanKeypadCrack = "Can Keypad Crack",
		Cancel = "Cancel",
		Charge = "Charge",
		ChargeUnauthorized = "Only charge unauthorized users",
		ChargeUnauthorizedTip = "Should only unauthorized (blacklisted/not whitelisted) users be charged for access,\nor should everyone be charged for access?",
		CheckingURL = "Checking URL... please wait",
		Cleaned__bkeypads_fading_doors = "Cleaned Fading Doors (bKeypads)",
		Cleaned_bKeypads = "Cleaned Keypads",
		Cleanup__bkeypads_fading_doors = "Fading Doors (bKeypads)",
		Clear = "Clear",
		ClearAccessMatrixConfirm = "Are you sure you want to clear the access table?",
		CloseSound = "Close Sound",
		Configuration = "Configuration",
		CopiedExclamation = "Copied!",
		CopyName = "Copy Name",
		CopySteamID = "Copy SteamID",
		CopySteamID64 = "Copy SteamID64",
		CopyValue = "Copy Value",
		CustomEllipsis = "Custom...",
		DBinderTip = "Right click to remove",
		Delay = "Delay",
		Delete = "Delete",
		DeleteImage = "Delete Image",
		DeleteSaveConfirm = "Are you sure you want to delete save \"%s\"?",
		Denied = "Denied",
		Destructible = "Destructible",
		Destruction = "Destruction",
		DisableMapObj = "Disable Map Object",
		Dismiss = "Dismiss",
		DomainNotWhitelisted = "That domain is not whitelisted!",
		Done = "Done",
		Doors = "Doors",
		DroppedKeycard = "Dropped Keycard",
		DroppedKeycardHideToHolders = "Hide To Holders",
		DroppedKeycardHideToHoldersTip = "If checked then players who pickup this keycard will not be able to see it on the ground afterwards.\n\nWARNING: Due to a Gmod bug, currently it is not possible to hide the keycards and prevent players colliding with them, meaning they could get pushed around by confused players who can't see them.",
		DroppedKeycardLevel = "Level(s)",
		DroppedKeycardPersistenceTip = "If checked this dropped keycard will spawn every time the map is loaded.\n\nRight click on the dropped keycard with the Billy's Keypads Persistence tool (found in Spawn Menu > Admin Tab > Persistence) to delete it from the map.\n\nYou can also manipulate the keycard with your physgun to place + save it to a more desirable location.",
		DroppedKeycardPhysics = "Enable Physics",
		DroppedKeycardPhysicsTip = "If checked then the dropped keycard can be moved around.\n\nIf persistent, this will disable the keycard's position being saved on server shut down or when moved with the physgun.",
		DroppedKeycardPlayerModel = "Player Model",
		DroppedKeycardQuantity = "Quantity",
		DroppedKeycardQuantityInfinite = "Infinite",
		DroppedKeycardTouchToPickup = "Touch To Pickup",
		DroppedKeycardTouchToPickupTip = "If checked then players can walk over/touch this keycard to pick it up, as well as press E on it.",
		Enable = "Enable",
		EnterUsergroup = "Enter the name of the usergroup",
		Error = "Error",
		FaceID = "FaceID",
		FaceIDTip = "Use facial scanning for authentication",
		FadingDoor = "Fading Door",
		FadingDoorCreated = "Fading door created!",
		FadingDoorHelp = "The Fading Door tool allows you to make almost any prop into a door!\n\nFading Doors can linked to a keypad using the Linker tool, allowing you to control access to your base, creations or valuables.",
		FadingDoorRemoved = "Fading door removed!",
		FadingDoorSettingsCopied = "Fading door settings copied!",
		FadingDoorUpdated = "Fading door updated!",
		Finished = "Finished",
		Freeze = "Freeze",
		FreezeTip = "Whether the keypad should be frozen when it is spawned",
		Friends = "Friends",
		General = "General",
		Granted = "Granted",
		GroupAgendaGroup = "Agenda Group",
		GroupCustomLuaFunction = "Custom Lua Function",
		GroupCustomTeamGroup = "Custom Team Group",
		GroupDemoteGroup = "Demote Group",
		GroupDoorGroup = "Door Group",
		GroupJobCategory = "Job Category",
		GroupKeycardLevel = "Keycard Level",
		GroupMe = "Me",
		Hacked = "Hacked",
		HealthAdded = "+%d HP",
		Help = "Help",
		HideMapObj = "Hide",
		HideMapObjTip = "This will prevent the button from being rendered in the world.\n\nThis may not work on some buttons due to the map; redirect +use may be more appropriate if so.",
		HoldLength = "Hold Length:",
		HoldLengthTip = "How long should the keypad output for in seconds?",
		Idle = "Idle",
		ImageAlreadyExists = "You've already added this image (\"%s\")",
		ImageName = "Image name...",
		ImageURL = "Image URL",
		Indestructible = "Indestructible",
		InitialDelay = "Initial Delay:",
		InitialDelayTip = "How long should the keypad wait in seconds before outputting?",
		InvalidImage = "Invalid image:\n",
		InvalidURL = "That was an invalid URL. Examples:\n\nhttps://i.imgur.com/9j3U3SY.jpg\nhttps://i.imgur.com/auA1H2y.jpg",
		Job = "Job",
		Jobs = "Jobs",
		JobsSelector = "Job(s) Selector",
		Key = "Key",
		Keycard = "Keycard",
		KeycardDrop = "Drop",
		KeycardInstructions = "Left click on a keycard scanner to insert your keycard\n\nRight click to identify yourself\n\nR/RELOAD to open the keycard inventory",
		KeycardLevel = "Level %d",
		KeycardLevels = "Levels",
		KeycardSwitch = "Switch",
		KeycardTip = "Use keycards for authentication",
		KeypadAccessMatrixCopied = "Copied keypad access table!",
		KeypadAccessMatrixCopyError = "There was an error copying the access table of this keypad - sorry!",
		KeypadAccessMatrixCopying = "Downloading keypad access table...",
		KeypadAccessTip2 = "Right-click on a line to remove it",
		KeypadBattery = "Keypad Battery",
		KeypadBroken = "Keypad broken!",
		KeypadHackedAdminHidden = "[CLICK TO VIEW]",
		KeypadMethod = "Method",
		KeypadNameTip = "Give a friendly name to your keypad.\nThis will show up in notifications, and can help staff members identify your keypad in the logs.",
		KeypadOnlyFadingDoor = "This fading door can only be opened and closed via a keypad!",
		KeypadRepaired = "Keypad repaired!",
		KeypadShield = "Keypad Shield",
		KeypadShieldBattery = "Keypad Shield Battery",
		LastSaved = "Last Saved: %s",
		LastUpdated = "Last Updated",
		LinkTypeButton = "MAP BUTTON LINK",
		LinkTypeDoor = "MAP DOOR LINK",
		LinkTypeFadingDoor = "FADING DOOR LINK",
		LinkTypeKeypad = "KEYPAD LINK",
		LinkTypeMap = "MAP OBJECT LINK",
		LinkedSuccessfully = "Linked successfully!",
		Linker = "Linker",
		LinkerHelp = "The Linker tool allows you to link fading doors, map doors and map buttons to keypads.\n\nWith the Linker tool, you can even link two keypads together, meaning they'll share the same access configuration!",
		LoadSave = "Load Save",
		LoadSaveFailed = "Failed to load this save! It may be corrupted, too old, or a bug/error occurred.",
		LoadSaveWarning = "Are you sure you want to load save \"%s\"?\nYou will lose any unsaved settings.",
		LoadingEllipsis = "Loading...",
		LogoImage = "Logo/Image",
		Look = "Look",
		ManualSteamID = "SteamID/SteamID64/Steam Profile Link",
		ManualSteamIDError = "We could not recognize the SteamID, SteamID64 or Steam Profile Link you entered.\nExamples:\n\nSteamID: %s\nSteamID64: %s\nSteam Profile Link: %s\nSteam Profile Link: %s",
		ManualSteamIDNetworkError = "There was a network error that prevented us from parsing this Steam profile link.\nPlease try again later or manually enter a SteamID/SteamID64.",
		ManualSteamIDProfileError = "We couldn't extract a SteamID from this Steam profile link - please check the link and try again.",
		ManualSteamIDProfileNotFound = "There is no Steam user at this profile link!\nPlease try again later or manually enter a SteamID/SteamID64.",
		MapDoorToggleTip = "This will cause the door to be opened or closed but not reverted when the keypad has finished its output.",
		MapDoubleToggle = "Double Toggle",
		MapDoubleToggleTip = "This will cause the button be toggled twice (PRESS .. PRESS).",
		MapHold = "Hold",
		MapHoldTip = "This will cause the button to be held down until the keypad has completed its \"Hold Length\" (PRESS .. WAIT .. DEPRESS)",
		MapLinking = "Map Linking",
		MapPreventLockpick = "Prevent Lockpick",
		MapPreventLockpickTip = "On DarkRP, this will prevent the door from being lockpicked.",
		MapRedirectUse = "Redirect +use to Keypad",
		MapRedirectUseTip = "This will cause any player trying to use the map object to have that +use redirected to the keypad.",
		MapToggle = "Toggle",
		MapToggleTip = "This will cause the button to be toggled once (PRESS) rather than the default (PRESS .. DEPRESS).",
		MaxHealth = "Max Health",
		Mode = "Mode",
		Mouse = "Mouse",
		Name = "Name",
		Nearby = "Nearby",
		NewImage = "+ New",
		NewImageSubtitle = "Enter the URL of the image.\n\n* Must be hosted on a whitelisted domain\n* Recommended dimensions: 256x256\n* Must be a JPEG or PNG\n* Maximum size: 2 MB",
		NewImageTitle = "New Image",
		No = "No",
		NoCollide = "No Collide",
		NoCollideTip = "Whether the keypad should collide with players and entities or not - don't worry, it won't fall out of the world",
		NoData = "No Data",
		None = "None",
		NotPersistent = "Not Persistent",
		Notification_Access = "Access was %s to %s",
		Notification_Access_Named = "Access was %s to %s for keypad %s",
		Notification_DENIED = "DENIED",
		Notification_GRANTED = "GRANTED",
		Notification_PaymentCantAfford = "You can't afford the %s charge for access to this keypad!",
		Notification_PaymentCantAfford_Named = "You can't afford the %s charge for access to %s!",
		Notification_PaymentReceived = "You've received %s from %s for keypad access!",
		Notification_PaymentReceived_Named = "You've received %s from %s for access to %s!",
		Notification_PaymentTaken = "You've paid %s to access this keypad",
		Notification_PaymentTaken_Named = "You've paid %s to access %s",
		Notifications = "Notifications",
		Offline = "Offline",
		Online = "Online",
		OpenSound = "Open Sound",
		Optimizing = "Optimizing: %s",
		OwnedBy = "Owned By",
		PIN = "PIN",
		PINTip = "Use 1 to 6 digit PINs for authentication\nTIP: You can use your numpad to input PINs on keypads!",
		Payment = "Payment",
		PaymentAboveMaximum = "The maximum amount you can charge is %s",
		PaymentBelowMinimum = "The minimum amount you can charge is %s",
		PaymentEntry = "Enter how much you want to charge people for entry.\nThey will be warned before they are charged.",
		PaymentMaximum = "Maximum: %s",
		PaymentMinimum = "Minimum: %s",
		Persistence = "Persistence",
		PersistenceHelp = "This tool allows you to create persistent keypads - keypads that persist after a server restart.\n\nThe tool also has a powerful feature called profiles, which allow you to create separate persistent keypad configurations on the same map, and switch between them on the fly.\n\nNOTE: If you've made changes to a persistent keypad, such as moving its position or angle, you'll need to press your RELOAD key on it to save the changes.",
		Persistent = "Persistent",
		PersistentKeycardSave = "Persistent dropped keycard saved!",
		Player = "Player",
		Players = "Players",
		PlayersSelector = "Player(s) Selector",
		Preview = "Preview",
		Profile = "Profile",
		ProfileSwitchedChat = "Persistent profile switched to \"%s\"",
		Profiles = "Profiles",
		Properties = "Properties",
		PseudoMapLink = "Pseudolink",
		PseudoMapLinkTip = "When enabled, the linked keypad will simply do nothing to the map object when access is granted/denied. This allows you to simply just disable lockpicking, +redirect use, disable or hide buttons and doors without the keypad affecting them.",
		Recent = "Recent",
		Refresh = "Refresh",
		Remove = "Remove",
		RepeatDelay = "Repeat Delay:",
		RepeatDelayTip = "How long should the keypad wait in seconds in between output repeats?",
		Repeats = "Repeats:",
		RepeatsTip = "How many times should the keypad repeat its output?",
		Reset = "Reset",
		ResetAllData = "Reset All Billy's Keypads Data",
		ResetAllDataAreYouSure = "Are you sure you want to reset all Billy's Keypads Data?\nThis can be used to fix errors if your local files have been corrupted.\nThis will reset all your settings, saved keypads, caches, etc and return Billy's Keypads back to a clean slate for you.\n\nIf you're only getting errors on this server, Billy's Keypads might be outdated. Ask the server owner if they have kept the script up to date!",
		ResetSettings = "Reset Settings",
		ResetSettingsAreYouSure = "Are you sure you want to reset the settings?\nThe spawn menu will be reloaded.",
		Reversed = "Reversed",
		SBoxLimit__bkeypads_fading_doors = "You've hit the Fading Doors (bKeypads) limit!",
		SBoxLimit_bKeypads = "You've hit the Keypads limit!",
		Save = "Save",
		SaveKeypad = "Save Keypad",
		SaveKeypadAlreadyExists = "This file already exists, would you like to overwrite it?\nFile was last modified on %s",
		SaveKeypadFileName = "Saved keypad file name:",
		SaveLoadTip = "You can save and load keypad configurations here!",
		SavePersistentKeypads = "Save Persistent Keypads",
		SavedKeypads = "Saved Keypads",
		Scanning = "Scanning",
		ScanningStatus = "Scanning Status",
		Search = "Search",
		SearchEllipsis = "Search...",
		SetLogoImage = "Set Logo/Image",
		SetPayment = "Set Payment",
		SetPaymentTip = "Charge people for access to this keypad",
		Setting_3D2DDistance = "3D2D Render Distance",
		Setting_3D2DDistanceTip = "At what distance should 3D2D GUI start to fade out? (e.g. keypad screens, keycard decals, keycard identification etc.)",
		Setting_Accessibility = "Accessibility",
		Setting_AutoThreshold = "Auto FPS Threshold",
		Setting_AutoThresholdTip = "What FPS should Auto start making optimizations at?",
		Setting_CustomImages = "Custom Images",
		Setting_CustomImagesTip = "If you don't want to see custom images on keypads, you can force disable them here. You'll still be able to see your own custom images.",
		Setting_CustomImages_Imgur = "Imgur only",
		Setting_CustomImages_ImgurTip = "Custom images can be used to identify your IP address. It is very difficult to link an IP address to each player on the server, but if you are concerned about security you can force custom images to be Imgur.com only.\n\nNOTE: By default, Imgur is the only whitelisted custom images source but this can be changed by the server owner (who already knows your IP address anyway)",
		Setting_DrawKeypadProperties = "Draw Keypad Properties",
		Setting_DrawKeypadPropertiesTip = "Draws keypad properties under keypads you are about to place.",
		Setting_KeycardTextures = "Disable Dynamic Keycard Textures",
		Setting_KeycardTexturesTip = "Dynamic Keycard Textures are generally very well optimized but low end PCs or FPS draining servers may struggle.",
		Setting_NotificationsMax = "Maximum Notifications",
		Setting_NotificationsMaxTip = "The maximum number of notifications that can appear before old ones are discarded.",
		Setting_NotificationsTextSize = "Text Size",
		Setting_NotificationsTime = "Notification Time",
		Setting_NotificationsTimeTip = "How long should notifications be shown for before disappearing?",
		Setting_Optimizations = "Optimizations",
		Setting_OptimizationsTip = "Billy's Keypads makes performance optimizations based on your game's FPS.\n\nAuto: Tracks your FPS and makes optimizations on the fly\nNone: No optimizations are made\nPotato: All optimizations are forced",
		Setting_Optimizations_Auto = "Auto",
		Setting_Optimizations_Potato = "Potato",
		Setting_Other = "Other",
		Setting_PINInputMode = "PIN Input Mode",
		Setting_PINInputModeTip = "How do you prefer to enter keypad PINs?\n\nLook = Look at each button and press E\nMouse = Press E on keypad to release mouse and click buttons",
		Setting_TooltipSize = "Tooltip Text Size",
		Settings = "Settings",
		Shield = "Shield",
		ShieldAdded = "+%d Shield",
		Size = "Size",
		Slant = "Slant Keypad",
		SlantTip = "Gives the (randomized) effect of the keypad just barely hanging onto the wall",
		Slanted = "Slanted",
		Sounds = "Sounds",
		Spawn = "Spawn",
		SpawnDroppedKeycard = "Spawn Dropped Keycard",
		SpawnMenuKeypad = " Keypad",
		SteamFriends = "Steam Friends",
		SteamIDFinder = "SteamID Finder",
		Switch = "Switch",
		Team = "Team",
		Teams = "Teams",
		Time = "Time",
		ToggleActive = "Toggle Active",
		ToolHelp1 = "Keypads allow you to control access to doors, fading doors, Wiremod components, and more.",
		ToolHelp2 = "You can give people access to keypads through keycards and facial recognition, which can detect the SteamID, usergroup, job/team of a friend.",
		ToolHelp3 = "Through custom Lua functions, the server developers can add more functionality, such as level, gangs/parties, etc.",
		ToolHelp4 = "However, your keypads can be cracked by keypad crackers; listen out for beeping noises!",
		ToolScreenNoPermission = "You don't have permission to use this!",
		ToolScreenNoPermissionEnt = "You don't have permission for this entity!",
		Tutorial = "Tutorial",
		Type = "Type",
		Uncrackable = "Uncrackable",
		UncrackableTip = "Whether the keypad is crackable by a keypad cracker",
		Undo_bKeypad = "Keypad",
		Undo_bKeypads_Button_Link = "Button Link (bKeypads)",
		Undo_bKeypads_Door_Link = "Door Link (bKeypads)",
		Undo_bKeypads_FadingDoor = "Fading Door (bKeypads)",
		Undo_bKeypads_FadingDoor_Link = "Fading Door Link (bKeypads)",
		Undo_bKeypads_Keypad_Link = "Keypad Link (bKeypads)",
		Undo_bKeypads_Map_Link = "Map Link (bKeypads)",
		Undone_bKeypad = "Undone Keypad",
		Undone_bKeypads_Button_Link = "Undone Button Link (bKeypads)",
		Undone_bKeypads_Door_Link = "Undone Door Link (bKeypads)",
		Undone_bKeypads_FadingDoor = "Undone Fading Door (bKeypads)",
		Undone_bKeypads_FadingDoor_Link = "Undone Fading Door Link (bKeypads)",
		Undone_bKeypads_Keypad_Link = "Undone Keypad Link (bKeypads)",
		Undone_bKeypads_Map_Link = "Undone Map Link (bKeypads)",
		Unknown = "Unknown",
		UnlinkedSuccessfully = "Unlinked successfully!",
		Unnamed = "(Unnamed)",
		Usergroup = "Usergroup",
		Value = "Value",
		ViewProfile = "View Profile",
		Weld = "Weld",
		WeldTip = "Whether the keypad should be welded when it is spawned",
		When = "When",
		Whitelist = "Whitelist",
		WhitelistTip = "Who should access be granted to?",
		Whitelisted = "Whitelisted",
		WhitelistedDomains = "Whitelisted Domains",
		WhitelistedDomainsTip = "This server only allows the following image URL domains:",
		Who = "Who",
		WiremodTip = "Whether to enable Wiremod inputs and outputs on this keypad or not",
		Yes = "Yes",
		s_hour = "%d hour ago",
		s_hours = "%d hours ago",
		s_minute = "%d minute ago",
		s_minutes = "%d minutes ago",
		s_second = "%d second ago",
		s_seconds = "%d seconds ago",
		["tool.bkeypads.copy"] = "Copy Keypad Access Table",
		["tool.bkeypads.create_update"] = "Create/Update Keypad",
		["tool.bkeypads.desc"] = "Creates keypads for securing access to doors, fading doors, etc.",
		["tool.bkeypads.name"] = "Billy's Keypads",
		["tool.bkeypads.switch_linker"] = "Switch to Linker Tool",
		["tool.bkeypads_admin_tool.desc"] = "View keypad links, access tables, properties and access logs",
		["tool.bkeypads_admin_tool.focus"] = "Focus on keypad",
		["tool.bkeypads_admin_tool.help"] = "The admin tool can be used to view a variety of information about a keypad.\n\nLook at a keypad to show its properties.\n\nLeft click to focus on the keypad.\nRight click to unfocus the keypad.\n\nPress RELOAD to open the admin menu (properties, access logs, access table.)",
		["tool.bkeypads_admin_tool.menu"] = "View admin menu",
		["tool.bkeypads_admin_tool.name"] = "Admin Tool",
		["tool.bkeypads_admin_tool.unfocus"] = "Unfocus",
		["tool.bkeypads_breaker.break_keypad"] = "Break keypad",
		["tool.bkeypads_breaker.desc"] = "\"Breaks\" keypads for cinematic effect",
		["tool.bkeypads_breaker.help"] = "\"Breaks\" keypads for cinematic effect. Broken keypads cannot be used, and will keep any linked map entities, doors, fading doors and keys open & unlocked.\n\nThis is great for server events where you want to simulate hacked or faulty security systems.",
		["tool.bkeypads_breaker.name"] = "Keypad Breaker",
		["tool.bkeypads_breaker.repair_keypad"] = "Repair keypad",
		["tool.bkeypads_fading_door.copy"] = "Copy settings",
		["tool.bkeypads_fading_door.desc"] = "Makes anything into a fading door",
		["tool.bkeypads_fading_door.door"] = "Create/update fading door",
		["tool.bkeypads_fading_door.info1"] = "Fading doors allow you to turn any prop into a door which players can walk through",
		["tool.bkeypads_fading_door.info2"] = "The fading door can only be opened and closed via a keypad",
		["tool.bkeypads_fading_door.info3"] = "Use the Linker tool to link keypads to fading doors",
		["tool.bkeypads_fading_door.name"] = "Fading Doors",
		["tool.bkeypads_fading_door.remove"] = "Remove fading door",
		["tool.bkeypads_linker.Finished"] = "Finished",
		["tool.bkeypads_linker.desc"] = "Links keypads to fading doors, map objects and other keypads",
		["tool.bkeypads_linker.link_all"] = "Link to Keypad/Fading Door/Map Object",
		["tool.bkeypads_linker.link_fading_door"] = "Link to Fading Door",
		["tool.bkeypads_linker.link_keypad"] = "Link to Keypad",
		["tool.bkeypads_linker.link_map_obj"] = "Link to Map Object",
		["tool.bkeypads_linker.link_map_obj_info"] = "Don't forget to configure map object links to your liking in the tool settings!",
		["tool.bkeypads_linker.name"] = "Linker",
		["tool.bkeypads_linker.on_access_denied"] = "On Access Denied...",
		["tool.bkeypads_linker.on_access_granted"] = "On Access Granted...",
		["tool.bkeypads_linker.select"] = "Select Keypad",
		["tool.bkeypads_linker.switch_access"] = "Switch Access Mode",
		["tool.bkeypads_linker.switch_keypads"] = "Switch to Keypads Tool",
		["tool.bkeypads_linker.unlink_fading_door"] = "Unlink from Fading Door",
		["tool.bkeypads_linker.unlink_keypad"] = "Unlink from Keypad",
		["tool.bkeypads_linker.unlink_map_obj"] = "Unlink from Map Object",
		["tool.bkeypads_persistence.delete"] = "Delete Persistent Keypad",
		["tool.bkeypads_persistence.desc"] = "Allows you to create keypads that persist after server restarts",
		["tool.bkeypads_persistence.make_persistent"] = "Make Persistent",
		["tool.bkeypads_persistence.name"] = "Persistence",
		["tool.bkeypads_persistence.notification.created"] = "Created persistent keypad for profile \"%s\"",
		["tool.bkeypads_persistence.notification.deleted"] = "Deleted persistent keypad from profile \"%s\"",
		["tool.bkeypads_persistence.notification.updated"] = "Saved persistent keypad to profile \"%s\"",
		["tool.bkeypads_persistence.update"] = "Update Persistent Keypad",
	}
}
--addons/bkeypads/lua/bkeypads/sh_keypad_data.lua:
bKeypads.KeypadData = {}

function bKeypads.KeypadData:AccessMatrix()
	return {
		bKeypads.ACCESS_GROUP.VERSION,
		
		[bKeypads.ACCESS_GROUP.PAYMENT] = false,
		
		[bKeypads.ACCESS_TYPE.WHITELIST] = {
			[bKeypads.ACCESS_GROUP.STEAM_FRIENDS] = false,
			[bKeypads.ACCESS_GROUP.PLAYER] = {},
			[bKeypads.ACCESS_GROUP.USERGROUP] = {},
			[bKeypads.ACCESS_GROUP.TEAM] = {},

			[bKeypads.ACCESS_GROUP.KEYCARD_LEVEL] = {},
			[bKeypads.ACCESS_GROUP.SUPERIOR_KEYCARDS] = false,

			[bKeypads.ACCESS_GROUP.DARKRP_JOB] = {},
			[bKeypads.ACCESS_GROUP.DARKRP_JOB_CATEGORY] = {},
			
			[bKeypads.ACCESS_GROUP.DARKRP_DOOR_GROUP] = {},
			[bKeypads.ACCESS_GROUP.DARKRP_DEMOTE_GROUP] = {},
			[bKeypads.ACCESS_GROUP.DARKRP_AGENDA_GROUP] = {},

			[bKeypads.ACCESS_GROUP.CUSTOM_LUA_FUNCTION] = {},
			[bKeypads.ACCESS_GROUP.CUSTOM_TEAM_GROUP] = {},
			[bKeypads.ACCESS_GROUP.CUSTOM_ADDON_FUNCTION] = {},

			[bKeypads.ACCESS_GROUP.HELIX_FLAG] = {}
		},
		
		[bKeypads.ACCESS_TYPE.BLACKLIST] = {
			[bKeypads.ACCESS_GROUP.STEAM_FRIENDS] = false,
			[bKeypads.ACCESS_GROUP.PLAYER] = {},
			[bKeypads.ACCESS_GROUP.USERGROUP] = {},
			[bKeypads.ACCESS_GROUP.TEAM] = {},

			[bKeypads.ACCESS_GROUP.KEYCARD_LEVEL] = {},
			[bKeypads.ACCESS_GROUP.SUPERIOR_KEYCARDS] = false,

			[bKeypads.ACCESS_GROUP.DARKRP_JOB] = {},
			[bKeypads.ACCESS_GROUP.DARKRP_JOB_CATEGORY] = {},

			[bKeypads.ACCESS_GROUP.DARKRP_DOOR_GROUP] = {},
			[bKeypads.ACCESS_GROUP.DARKRP_DEMOTE_GROUP] = {},
			[bKeypads.ACCESS_GROUP.DARKRP_AGENDA_GROUP] = {},

			[bKeypads.ACCESS_GROUP.CUSTOM_LUA_FUNCTION] = {},
			[bKeypads.ACCESS_GROUP.CUSTOM_TEAM_GROUP] = {},
			[bKeypads.ACCESS_GROUP.CUSTOM_ADDON_FUNCTION] = {},

			[bKeypads.ACCESS_GROUP.HELIX_FLAG] = {}
		},
	}
end

-- TODO programmatic access matrices

local defaultEntries = {
	bKeypads.ACCESS_GROUP.PLAYER,
	bKeypads.ACCESS_GROUP.USERGROUP,
	bKeypads.ACCESS_GROUP.TEAM,

	bKeypads.ACCESS_GROUP.KEYCARD_LEVEL,

	bKeypads.ACCESS_GROUP.DARKRP_JOB,
	bKeypads.ACCESS_GROUP.DARKRP_JOB_CATEGORY,

	bKeypads.ACCESS_GROUP.DARKRP_DOOR_GROUP,
	bKeypads.ACCESS_GROUP.DARKRP_DEMOTE_GROUP,
	bKeypads.ACCESS_GROUP.DARKRP_AGENDA_GROUP,

	bKeypads.ACCESS_GROUP.CUSTOM_LUA_FUNCTION,
	bKeypads.ACCESS_GROUP.CUSTOM_TEAM_GROUP,
	bKeypads.ACCESS_GROUP.CUSTOM_ADDON_FUNCTION,

	bKeypads.ACCESS_GROUP.HELIX_FLAG,
}
function bKeypads.KeypadData:MergeAccessMatrix(accessMatrix)
	for _, key in ipairs(defaultEntries) do
		for _, access_type in ipairs(bKeypads.ACCESS_TYPES) do
			accessMatrix[access_type][key] = accessMatrix[access_type][key] or {}
		end
	end
end

function bKeypads.KeypadData:CreationData()
	return {
		GrantedKey = 0,
		GrantedDelay = 0,
		GrantedRepeats = 0,
		GrantedRepeatDelay = bKeypads.Config.Scanning.AccessGranted.MinimumRepeatDelay,

		DeniedKey = 0,
		DeniedDelay = 0,
		DeniedRepeats = 0,
		DeniedRepeatDelay = bKeypads.Config.Scanning.AccessDenied.MinimumRepeatDelay,

		--PIN = "",
		--ImageURL = "",
	}
end

--## FILE SERIALIZATION / DESERIALIZATION ##

bKeypads.KeypadData.File = {}
bKeypads.KeypadData.File.Instances = {}

do
	local function pack(...) return {...} end

	local f_debug_funcs = {"Close", "Flush", "Read", "ReadBool", "ReadByte", "ReadDouble", "ReadFloat", "ReadLine", "ReadLong", "ReadShort", "ReadULong", "ReadUShort", "Seek", "Size", "Skip", "Tell", "Write", "WriteBool", "WriteByte", "WriteDouble", "WriteFloat", "WriteLong", "WriteShort", "WriteULong", "WriteUShort"}
	local f_debug_func_overrides = {}
	for i, func in ipairs(f_debug_funcs) do
		f_debug_func_overrides[func] = function(self, ...)
			local argsStr = "\t"
			for k, v in ipairs({...}) do argsStr = argsStr .. "\t" .. tostring(v) end

			local returnArgs = pack(self.f[func](self.f, ...))

			local returnStr = "\t"
			for k, v in ipairs(returnArgs) do returnStr = returnStr .. "\t" .. tostring(v) end

			print(self.f:Tell(), func .. argsStr:sub(2) .. returnStr:sub(2))

			return unpack(returnArgs)
		end
	end

	function bKeypads.KeypadData.File:Open(name, write, path, debug)
		bKeypads.KeypadData.File:Close(name, path)
		
		local f = file.Open(name, write and "wb" or "rb", path)
		if debug then
			print(write and "====== FILE WRITE ======" or "====== FILE READ ======")
			local fakeFile = {f = f}
			for func, debug_func in pairs(f_debug_func_overrides) do
				fakeFile[func] = debug_func
			end
			return fakeFile
		else
			bKeypads.KeypadData.File.Instances[name .. path] = f
			return f
		end
	end

	function bKeypads.KeypadData.File:Close(name, path)
		local file_id = name .. path
		if bKeypads.KeypadData.File.Instances[file_id] ~= nil then
			bKeypads.KeypadData.File.Instances[file_id]:Close()
			bKeypads.KeypadData.File.Instances[file_id] = nil
		end
	end
end

function bKeypads.KeypadData.File:Serialize(f, accessMatrix)
	f:WriteByte(accessMatrix[1]) -- File version

	f:WriteBool(accessMatrix[bKeypads.ACCESS_GROUP.PAYMENT] ~= false)
	if accessMatrix[bKeypads.ACCESS_GROUP.PAYMENT] then
		f:WriteULong(accessMatrix[bKeypads.ACCESS_GROUP.PAYMENT])
	end

	for _, list in ipairs({accessMatrix[bKeypads.ACCESS_TYPE.WHITELIST], accessMatrix[bKeypads.ACCESS_TYPE.BLACKLIST]}) do
		local access_type_count_pointer = f:Tell()
		f:Skip(1)

		local access_type_count = 0
		for access_type, data in pairs(list) do
			if istable(data) then
				if not table.IsEmpty(data) then
					f:WriteByte(access_type)

					local access_count_pointer = f:Tell()
					f:Skip(2)

					local access_count = 0
					for access, access_data in pairs(data) do
						if access_type == bKeypads.ACCESS_GROUP.PLAYER then
							f:WriteByte(#access)
							f:Write(string.sub(access, 1, 255)) -- steamid64
							if access_data == true then
								f:WriteBool(true)
							else
								f:WriteBool(false)
								f:WriteByte(#access_data)
								f:Write(string.sub(access_data, 1, 255)) -- nick
							end
						elseif (
							access_type == bKeypads.ACCESS_GROUP.KEYCARD_LEVEL
						) then
							f:WriteUShort(access)
						else
							f:WriteByte(#access)
							f:Write(string.sub(access, 1, 255))
						end

						access_count = access_count + 1
					end

					local bounce_back_pointer = f:Tell()
					f:Seek(access_count_pointer)
					f:WriteUShort(access_count)
					f:Seek(bounce_back_pointer)

					access_type_count = access_type_count + 1
				end
			elseif isbool(data) and data == true then
				f:WriteByte(access_type)
				access_type_count = access_type_count + 1
			end
		end

		local bounce_back_pointer = f:Tell()
		f:Seek(access_type_count_pointer)
		f:WriteByte(access_type_count)
		f:Seek(bounce_back_pointer)
	end

	f:Close()
end

function bKeypads.KeypadData.File:Deserialize(f)
	local accessMatrix = bKeypads.KeypadData:AccessMatrix()

	accessMatrix[1] = f:ReadByte()

	accessMatrix[bKeypads.ACCESS_GROUP.PAYMENT] = f:ReadBool() and f:ReadULong() or false

	for _, list in ipairs({accessMatrix[bKeypads.ACCESS_TYPE.WHITELIST], accessMatrix[bKeypads.ACCESS_TYPE.BLACKLIST]}) do
		local access_type_count = f:ReadByte()
		for i=1,access_type_count do
			local access_type = f:ReadByte()
			if access_type == bKeypads.ACCESS_GROUP.SUPERIOR_KEYCARDS or access_type == bKeypads.ACCESS_GROUP.STEAM_FRIENDS then
				list[access_type] = true
			else
				local access_count = f:ReadUShort()
				for i=1,access_count do
					if access_type == bKeypads.ACCESS_GROUP.PLAYER then
						local steamid64 = f:Read(f:ReadByte())
						local nick = f:ReadBool() or f:Read(f:ReadByte())
						list[access_type][steamid64] = nick
					elseif (
						access_type == bKeypads.ACCESS_GROUP.KEYCARD_LEVEL
					) then
						list[access_type][f:ReadUShort()] = true
					else
						list[access_type][f:Read(f:ReadByte())] = true
					end
				end
			end
		end
	end

	f:Close()

	bKeypads.KeypadData:MergeAccessMatrix(accessMatrix)

	return accessMatrix
end

--## NET SERIALIZATION / DESERIALIZATION ##--

bKeypads.KeypadData.Net = {}

function bKeypads.KeypadData.Net:Serialize(accessMatrix)
	net.WriteBool(accessMatrix[bKeypads.ACCESS_GROUP.PAYMENT] ~= false)
	if accessMatrix[bKeypads.ACCESS_GROUP.PAYMENT] then
		net.WriteUInt(accessMatrix[bKeypads.ACCESS_GROUP.PAYMENT], 32)
	end

	for _, list in ipairs({accessMatrix[bKeypads.ACCESS_TYPE.WHITELIST], accessMatrix[bKeypads.ACCESS_TYPE.BLACKLIST]}) do
		for access_type, data in pairs(list) do
			if istable(data) then
				if not table.IsEmpty(data) then
					net.WriteBool(true)
					net.WriteUInt(access_type, bKeypads.ACCESS_GROUP.BITS)

					for access, access_data in pairs(data) do
						net.WriteBool(true)
						if access_type == bKeypads.ACCESS_GROUP.PLAYER then
							net.WriteString(access)
							if access_data == true then
								net.WriteBool(true)
							else
								net.WriteBool(false)
								net.WriteString(access_data)
							end
						elseif (
							access_type == bKeypads.ACCESS_GROUP.KEYCARD_LEVEL
						) then
							net.WriteUInt(access, 16)
						else
							net.WriteString(access)
						end
					end
					
					net.WriteBool(false)
				end
			elseif isbool(data) and data == true then
				net.WriteBool(true)
				net.WriteUInt(access_type, bKeypads.ACCESS_GROUP.BITS)
			end
		end
		net.WriteBool(false)
	end
end

function bKeypads.KeypadData.Net:Deserialize()
	local accessMatrix = bKeypads.KeypadData:AccessMatrix()

	accessMatrix[bKeypads.ACCESS_GROUP.PAYMENT] = net.ReadBool() and net.ReadUInt(32) or false

	local entry_count = 0
	for _, list in ipairs({accessMatrix[bKeypads.ACCESS_TYPE.WHITELIST], accessMatrix[bKeypads.ACCESS_TYPE.BLACKLIST]}) do
		local i = 0
		while (net.ReadBool() and i <= bKeypads.ACCESS_GROUP.LAST and entry_count < 4096) do
			i = i + 1
			local access_type = net.ReadUInt(bKeypads.ACCESS_GROUP.BITS)
			if access_type == bKeypads.ACCESS_GROUP.SUPERIOR_KEYCARDS or access_type == bKeypads.ACCESS_GROUP.STEAM_FRIENDS then
				list[access_type] = true
				entry_count = entry_count + 1
			elseif list[access_type] ~= nil then
				if access_type == bKeypads.ACCESS_GROUP.PLAYER then
					while (net.ReadBool() and entry_count < 4096) do
						entry_count = entry_count + 1
						list[access_type][net.ReadString()] = net.ReadBool() or net.ReadString()
					end
				elseif access_type == bKeypads.ACCESS_GROUP.KEYCARD_LEVEL then
					while (net.ReadBool() and entry_count < 4096) do
						entry_count = entry_count + 1
						list[access_type][net.ReadUInt(16)] = true
					end
				else
					while (net.ReadBool() and entry_count < 4096) do
						entry_count = entry_count + 1
						list[access_type][net.ReadString()] = true
					end
				end
			end
		end

		if entry_count >= 4096 then break end
	end

	return accessMatrix
end

--## DarkRP Memeology ##--

bKeypads:GMInitialize(function() if DarkRP then
	local function OptimizedDarkRPDataStructures()
		bKeypads.DarkRP = {}

		bKeypads.DarkRP.JobCategories = {
			Members = {},
			Teams = {}
		}

		bKeypads.DarkRP.DoorGroups = {
			Members = {},
			Teams = {}
		}

		bKeypads.DarkRP.Agendas = {
			Members = {},
			Teams = {}
		}

		bKeypads.DarkRP.DemoteGroups = {}

		if DarkRPAgendas then
			for _, agenda in pairs(DarkRPAgendas) do
				bKeypads.DarkRP.Agendas.Members[agenda.Title] = agenda

				bKeypads.DarkRP.Agendas.Teams[agenda.Title] = {}

				for _, team_index in ipairs(agenda.Listeners) do
					bKeypads.DarkRP.Agendas.Teams[agenda.Title][team_index] = true
				end

				if not agenda.Manager then continue end
				if istable(agenda.Manager) then
					for _, team_index in ipairs(agenda.Manager) do
						bKeypads.DarkRP.Agendas.Teams[agenda.Title][team_index] = true
					end
				else
					bKeypads.DarkRP.Agendas.Teams[agenda.Title][agenda.Manager] = true
				end
			end
		end

		if RPExtraTeamDoors then
			for name, doorGroup in pairs(RPExtraTeamDoors) do
				bKeypads.DarkRP.DoorGroups.Members[name] = doorGroup

				bKeypads.DarkRP.DoorGroups.Teams[name] = {}
				for _, team_index in ipairs(doorGroup) do
					bKeypads.DarkRP.DoorGroups.Teams[name][team_index] = true
				end
			end
		end

		if DarkRP.getDemoteGroups then
			for _, demoteGroup in pairs(DarkRP.getDemoteGroups()) do
				if not demoteGroup.name then continue end
				bKeypads.DarkRP.DemoteGroups[demoteGroup.name] = bKeypads.DarkRP.DemoteGroups[demoteGroup.name] or {}
				bKeypads.DarkRP.DemoteGroups[demoteGroup.name][demoteGroup.value] = true
			end
		end

		if DarkRP.getCategories then
			local categories = DarkRP.getCategories()
			if categories then
				categories = DarkRP.getCategories().jobs
				if categories then
					for _, category in ipairs(categories) do
						bKeypads.DarkRP.JobCategories.Members[category.name] = category

						bKeypads.DarkRP.JobCategories.Teams[category.name] = {}
						for _, job in ipairs(category.members) do
							bKeypads.DarkRP.JobCategories.Teams[category.name][job.team] = true
						end
					end
				end
			end
		end
	end
	OptimizedDarkRPDataStructures()
	hook.Add("bKeypads.ConfigUpdated", "bKeypads.DarkRP.ConfigUpdated", OptimizedDarkRPDataStructures)
end end)

if SERVER then
	util.AddNetworkString("bKeypads.SteamFriends")

	local SteamFriends = {}
	net.Receive("bKeypads.SteamFriends", function(_, ply)
		local ply2 = net.ReadEntity()
		if IsValid(ply2) and ply2:IsPlayer() and ply2 ~= ply then
			SteamFriends[ply] = SteamFriends[ply] or {}
			SteamFriends[ply][ply2] = net.ReadBool() or nil
		end
	end)

	function bKeypads:IsSteamFriends(ply1, ply2)
		return SteamFriends[ply1] and SteamFriends[ply2] and SteamFriends[ply1][ply2] and SteamFriends[ply2][ply1]
	end
else
	local SteamFriends = {}
	timer.Create("bKeypads.SteamFriends", 10, 0, function()
		for _, ply in ipairs(player.GetHumans()) do
			if ply == LocalPlayer() then continue end
			local status = ply:GetFriendStatus() == "friend"
			if (status == true and not SteamFriends[ply]) or (status == false and SteamFriends[ply] == true) then
				SteamFriends[ply] = status
				net.Start("bKeypads.SteamFriends")
					net.WriteEntity(ply)
					net.WriteBool(status)
				net.SendToServer()
			end
		end
	end)
end
--addons/bkeypads/lua/bkeypads/cl_settings.lua:
local FPSThink, FPSPaint, OptimizingThink

bKeypads.Settings = {}

hook.Add("AddToolMenuTabs", "bKeypads.Spawnmenu.Options", function()
	spawnmenu.AddToolTab("Options", "Options", "icon16/wrench.png")
end)
hook.Add("AddToolMenuCategories", "bKeypads.Spawnmenu.Options", function()
	spawnmenu.AddToolCategory("Options", "Billy's Keypads", "Billy's Keypads")
end)
hook.Add("PopulateToolMenu", "bKeypads.Spawnmenu.Options.Settings", function()
	spawnmenu.AddToolMenuOption("Options", "Billy's Keypads", "bKeypads.Settings", "#bKeypads_Settings", "", "", function(CPanel)
		bKeypads:InjectSmoothScroll(CPanel)
		bKeypads.Settings:BuildCPanel(CPanel)
	end)
end)

function bKeypads.Settings:Init()
	bKeypads.Settings.Registry = {
		["#bKeypads_Setting_Other"] = {
			{
				key = "tooltip_text_size",
				name = "#bKeypads_Setting_TooltipSize",

				type = "number",
				default = 13,
				min = 8,
				max = 24,

				onChange = function(val)
					bKeypads:CreateTooltipFont()
				end,

				postPanel = function(categoryPanel, settingPanel)
					bKeypads:RecursiveTooltip(bKeypads.L"Preview", settingPanel)
				end,
			},
			
			{
				key = "draw_properties",
				name = "#bKeypads_Setting_DrawKeypadProperties",
				tip = "#bKeypads_Setting_DrawKeypadPropertiesTip",

				type = "boolean",
				default = false
			}
		},

		["#bKeypads_Setting_CustomImages"] = {
			{
				key = "custom_images",
				name = "#bKeypads_Enable",
				tip = "#bKeypads_Setting_CustomImagesTip",

				type = "boolean",
				default = true
			},

			{
				key = "force_imgur",
				name = "#bKeypads_Setting_CustomImages_Imgur",
				tip = "#bKeypads_Setting_CustomImages_ImgurTip",

				type = "boolean",
				default = false
			},
		},
		
		["#bKeypads_Notifications"] = {
			{
				key = "notification_sounds",
				name = "#bKeypads_Sounds",

				type = "boolean",
				default = true
			},

			{
				key = "notification_time",
				name = "#bKeypads_Setting_NotificationsTime",
				tip = "#bKeypads_Setting_NotificationsTimeTip",

				type = "number",
				default = 3,
				min = 1,
				max = 10,
			},

			{
				key = "notification_max",
				name = "#bKeypads_Setting_NotificationsMax",
				tip = "#bKeypads_Setting_NotificationsMaxTip",

				type = "number",
				default = 4,
				min = 1,
				max = 10,
			},

			{
				key = "notification_text_size",
				name = "#bKeypads_Setting_NotificationsTextSize",

				type = "number",
				default = 18,
				min = 14,
				max = 24,

				onChange = function()
					bKeypads.Notifications:CreateFont()
				end,
			},
		},
		
		["#bKeypads_Setting_Optimizations"] = {
			{
				key = "optimizations",
				name = "#bKeypads_Setting_Optimizations",
				tip = "#bKeypads_Setting_OptimizationsTip",

				type = "combo",
				default = "auto",
				choices = {
					["auto"] = {
						name = "#bKeypads_Setting_Optimizations_Auto",
						icon = "icon16/wand.png"
					},
					["none"] = {
						name = "#bKeypads_None",
						icon = "icon16/lightning.png"
					},
					["potato"] = {
						name = "#bKeypads_Setting_Optimizations_Potato",
						icon = "icon16/box.png"
					},
				},

				prePanel = function(categoryPanel)
					local FPSPanel = vgui.Create("DPanel", categoryPanel)
					FPSPanel:DockPadding(5, 5, 5, 5)
					FPSPanel.Paint = FPSPaint

					FPSPanel.FPSLabel = vgui.Create("DLabel", FPSPanel)
					FPSPanel.FPSLabel:SetContentAlignment(5)
					FPSPanel.FPSLabel:Dock(TOP)
					FPSPanel.FPSLabel:SetText("FPS: ?")
					FPSPanel.FPSLabel:SetFont("DebugOverlay")
					FPSPanel.FPSLabel:SetTextColor(color_white)
					FPSPanel.FPSLabel.Think = FPSThink
					
					FPSPanel.OptimizingLabel = vgui.Create("DLabel", FPSPanel)
					FPSPanel.OptimizingLabel:SetContentAlignment(5)
					FPSPanel.OptimizingLabel:Dock(TOP)
					FPSPanel.OptimizingLabel:SetText("Optimizing: ?")
					FPSPanel.OptimizingLabel:SetFont("DebugOverlay")
					FPSPanel.OptimizingLabel:SetTextColor(color_white)
					FPSPanel.OptimizingLabel.Think = OptimizingThink

					categoryPanel:AddItem(FPSPanel)
				end,
			},

			{
				key = "optimizations_fps_threshold",
				name = "#bKeypads_Setting_AutoThreshold",
				tip = "#bKeypads_Setting_AutoThresholdTip",

				type = "number",
				default = 45,
				min = 5,
				max = 100,

				onChange = function(val)
					bKeypads.Performance.FPSThreshold = val
				end,
			},

			{
				key = "optimizations_3d2d_distance",
				name = "#bKeypads_Setting_3D2DDistance",
				tip = "#bKeypads_Setting_3D2DDistanceTip",

				type = "number",
				default = 1000,
				min = 100,
				max = 5000
			},

			{
				key = "optimizations_disable_keycard_textures",
				name = "#bKeypads_Setting_KeycardTextures",
				tip = "#bKeypads_Setting_KeycardTexturesTip",

				type = "boolean",
				default = false,

				onChange = function(disable)
					if disable then
						bKeypads.Keycards.Textures:Reset()
					end
				end,
			},
		},
		
		["#bKeypads_Setting_Accessibility"] = {
			--[[
			{
				key = "color_blindness",
				name = "#bKeypads_Setting_ColorBlindness",
				tip = "#bKeypads_Setting_ColorBlindnessTip",
				
				-- TODO
			},
			]]

			{
				key = "pin_input_mode",
				name = "#bKeypads_Setting_PINInputMode",
				tip = "#bKeypads_Setting_PINInputModeTip",
				type = "combo",
				default = "look",
				choices = {
					["look"] = {
						name = "#bKeypads_Look",
						icon = "icon16/eye.png"
					},
					["mouse"] = {
						name = "#bKeypads_Mouse",
						icon = "icon16/mouse.png"
					}
				},
			},

			{
				key = "dyslexia",
				name = "#bKeypads_Setting_Dyslexia",
				tip = "#bKeypads_Setting_DyslexiaTip",
				type = "boolean",
				default = false,

				onChange = function()
					include("bkeypads/cl_fonts.lua")
					RunConsoleCommand("spawnmenu_reload")
				end,
				
				postPanel = function(categoryPanel, settingPanel, helpPanel)
					bKeypads.RecursiveDyslexia(settingPanel)
					bKeypads.RecursiveDyslexia(helpPanel)
				end,
			},
		},
	}
end
bKeypads.Settings:Init()
bKeypads.Settings.Metadata = {}

bKeypads.Settings.KeyValues = {}
for category, members in pairs(bKeypads.Settings.Registry) do
	for _, setting in ipairs(members) do
		bKeypads.Settings.KeyValues[setting.key] = setting.default
		bKeypads.Settings.Metadata[setting.key] = setting
	end
end

function bKeypads.Settings:Get(key)
	return bKeypads.Settings.KeyValues[key]
end

function bKeypads.Settings:Set(key, val)
	if bKeypads.Settings.Metadata[key] and bKeypads.Settings.Metadata[key].type == "number" then
		bKeypads.Settings.KeyValues[key] = math.Round(val, bKeypads.Settings.Metadata[key].decimals or 0)
	else
		bKeypads.Settings.KeyValues[key] = val
	end
	bKeypads.Settings:Save()
end

function bKeypads.Settings:Save()
	file.Write("bkeypads/settings.json", util.TableToJSON(bKeypads.Settings.KeyValues))
end

function bKeypads.Settings:Load()
	if not file.Exists("bkeypads/settings.json", "DATA") then
		bKeypads.Settings:Save()
	else
		local saved = file.Read("bkeypads/settings.json", "DATA")
		if saved then
			saved = util.JSONToTable(saved)
			if saved then
				table.Merge(bKeypads.Settings.KeyValues, saved)
			end
		end
	end
end
bKeypads.Settings:Load()

do
	local FPSColor = Color(255,255,255)
	function FPSThink(self)
		self.FPSLerp = Lerp(0.05, self.FPSLerp or bKeypads.Performance.FPS, bKeypads.Performance.FPS)
		self:SetText("FPS: " .. math.Round(self.FPSLerp))

		local FPSFrac = bKeypads.Performance.FPSAverage / 120
		FPSColor.r = Lerp(FPSFrac, 255, 0)
		FPSColor.g = Lerp(FPSFrac, 0, 255)
		FPSColor.b = 0
		self:SetTextColor(FPSColor)
	end
	function OptimizingThink(self)
		self:SetText(bKeypads.L("Optimizing"):format(bKeypads.Performance:Optimizing() and bKeypads.L("Yes") or bKeypads.L("No")))
		self:SetTextColor(bKeypads.Performance:Optimizing() and bKeypads.COLOR.RED or bKeypads.COLOR.GREEN)
	end
	function FPSPaint(self, w, h)
		surface.SetDrawColor(0, 0, 0)
		surface.DrawRect(0, 0, w, h)

		self:SetTall(self.FPSLabel:GetTall() + self.OptimizingLabel:GetTall() + 10)
	end

	local function ResetSettings()
		surface.PlaySound("npc/roller/mine/rmine_predetonate.wav")

		bKeypads.STOOL.BlockSpawnmenuClose = true
		Derma_Query("#bKeypads_ResetSettingsAreYouSure", "#bKeypads_ResetSettings", "#bKeypads_Yes", function()

			bKeypads.STOOL.BlockSpawnmenuClose = false

			surface.PlaySound("npc/roller/remote_yes.wav")
			file.Delete("bkeypads/settings.json")

			bKeypads.Settings:Init()
			bKeypads.Settings:Load()
			
			RunConsoleCommand("spawnmenu_reload")

		end, "#bKeypads_No", function() bKeypads.STOOL.BlockSpawnmenuClose = false end)
	end

	local function recursive_delete(path)
		local fs, ds = file.Find(path .. "/*", "DATA")
		if fs then
			for _, f in ipairs(fs) do
				file.Delete(path .. "/" .. f)
			end
		end
		if ds then
			for _, d in ipairs(ds) do
				recursive_delete(path .. "/" .. d)
			end
		end
	end
	local function ResetAllData()
		surface.PlaySound("npc/roller/mine/rmine_predetonate.wav")

		bKeypads.STOOL.BlockSpawnmenuClose = true
		Derma_Query("#bKeypads_ResetAllDataAreYouSure", "#bKeypads_ResetAllData", "#bKeypads_Yes", function()

			bKeypads.STOOL.BlockSpawnmenuClose = false

			surface.PlaySound("npc/roller/remote_yes.wav")
			recursive_delete("bkeypads")

			bKeypads.Settings:Init()
			bKeypads.Settings:Load()

			-- Reset cvars
			local vdf = file.Read("cfg/client.vdf", "GAME")
			if vdf then
				for cvar in vdf:gmatch("\"(bkeypads_.-)\"") do
					local ConVar = GetConVar(cvar)
					if ConVar then
						ConVar:Revert()
					end
				end
			end

			include("autorun/_bkeypads_load.lua") -- spooky
			
			RunConsoleCommand("spawnmenu_reload")

		end, "#bKeypads_No", function() bKeypads.STOOL.BlockSpawnmenuClose = false end)
	end

	local function SettingPanelChanged(self, val)
		bKeypads.Settings:Set(self.key, val)
		if (self.settingOnChange) then self.settingOnChange(val) end
	end

	local function ComboBoxChanged(self, _, __, val)
		bKeypads.Settings:Set(self.key, val)
		if (self.settingOnChange) then self.settingOnChange(val) end
	end

	function bKeypads.Settings:BuildCPanel(CPanel)
		bKeypads.Settings.CPanel = CPanel
		CPanel.SettingPanels = {}

		bKeypads:InjectSmoothScroll(CPanel)
		bKeypads:STOOLMatrix(CPanel, false)

		local ResetButton = vgui.Create("DButton", CPanel)
		ResetButton:SetText("#bKeypads_Reset")
		ResetButton:SetIcon("icon16/arrow_refresh.png")
		ResetButton.DoClick = ResetSettings
		CPanel:AddItem(ResetButton)
		CPanel:InvalidateLayout()

		local ResetAllDataButton = vgui.Create("DButton", CPanel)
		ResetAllDataButton:SetText("#bKeypads_ResetAllData")
		ResetAllDataButton:SetIcon("icon16/error.png")
		ResetAllDataButton.DoClick = ResetAllData
		CPanel:AddItem(ResetAllDataButton)
		CPanel:InvalidateLayout()

		timer.Simple(0, function()
			for category, members in pairs(bKeypads.Settings.Registry) do
				local categoryPanel = vgui.Create("DForm", CPanel)
				categoryPanel:SetLabel(category)
				categoryPanel:SetExpanded(true)

				for _, setting in ipairs(members) do
					if setting.prePanel then setting.prePanel(categoryPanel) end
					
					local settingLabel, settingPanel

					if setting.type == "boolean" then

						local CheckBox = vgui.Create("DCheckBoxLabel", categoryPanel)
						settingPanel = CheckBox

						CheckBox:SetText(setting.name)
						CheckBox:SetChecked(bKeypads.Settings:Get(setting.key))

						CheckBox.OnChange = SettingPanelChanged
						
					elseif setting.type == "number" then

						setting.decimals = setting.decimals or (setting.default % 1 > 0 and #tostring(setting.default % 1) - 2) or 0

						local NumSlider = vgui.Create("DNumSlider", categoryPanel)
						settingPanel = NumSlider
						
						NumSlider:SetText(setting.name)
						NumSlider:SetDefaultValue(setting.default)
						if setting.min then NumSlider:SetMin(setting.min) end
						if setting.max then NumSlider:SetMax(setting.max) end
						NumSlider:SetDecimals(setting.decimals)
						NumSlider:SetValue(bKeypads.Settings:Get(setting.key))

						NumSlider.OnValueChanged = SettingPanelChanged
						
					elseif setting.type == "combo" then

						settingLabel = vgui.Create("DLabel", categoryPanel)
						settingLabel:SetText(setting.name)

						local ComboBox = vgui.Create("DComboBox", categoryPanel)
						settingPanel = ComboBox

						ComboBox:SetMinimumSize(nil, 25)
						
						local selected = bKeypads.Settings:Get(setting.key)
						for key, choice in pairs(setting.choices) do
							ComboBox:AddChoice(choice.name, key, selected == key, choice.icon)
						end

						ComboBox.OnSelect = ComboBoxChanged

					end

					if settingPanel.SetDark then settingPanel:SetDark(true) end
					settingPanel.key = setting.key
					settingPanel.settingOnChange = setting.onChange

					if IsValid(settingLabel) then
						settingLabel:SetDark(true)
						settingPanel:Dock(FILL)
						categoryPanel:AddItem(settingLabel, settingPanel)

						settingLabel:SetTall(25)
					else
						categoryPanel:AddItem(settingPanel)
					end
					local helpPanel
					if setting.tip then
						helpPanel = categoryPanel:Help(setting.tip)
						helpPanel:DockMargin(0, 0, 0, 0)
					end
					if setting.postPanel then setting.postPanel(categoryPanel, settingPanel, helpPanel) end

					CPanel.SettingPanels[setting.key] = settingPanel
				end

				CPanel:AddItem(categoryPanel)
			end

			local padding = vgui.Create("DPanel", CPanel)
			padding.Paint = nil
			padding:SetTall(10)
			CPanel:AddItem(padding)

			hook.Run("bKeypads.BuildCPanel", CPanel)
		end)
	end
end
--addons/bkeypads/lua/bkeypads/sh_destruction.lua:
hook.Add("loadCustomDarkRPItems", "bKeypads.DestructionItems", function()

	local batteryConfig = table.Copy(bKeypads.Config.KeypadDestruction.DarkRP.Battery)
	if not batteryConfig.Disabled then
		local batteryItemName = batteryConfig.Name
		batteryConfig.Disabled = nil
		batteryConfig.Name = nil

		batteryConfig.ent = "bkeypads_repair"
		batteryConfig.model = "models/items/battery.mdl"
		batteryConfig.price = batteryConfig.price or 500
		batteryConfig.max = batteryConfig.max or 0
		batteryConfig.cmd = batteryConfig.cmd or "buykeypadbattery"

		DarkRP.createEntity(batteryItemName, batteryConfig)
	end

	local shieldBatteryConfig = table.Copy(bKeypads.Config.KeypadDestruction.DarkRP.ShieldBattery)
	if not shieldBatteryConfig.Disabled then
		local shieldBatteryItemName = shieldBatteryConfig.Name
		shieldBatteryConfig.Disabled = nil
		shieldBatteryConfig.Name = nil

		shieldBatteryConfig.ent = "bkeypads_shield"
		shieldBatteryConfig.model = "models/items/battery.mdl"
		shieldBatteryConfig.price = shieldBatteryConfig.price or 1000
		shieldBatteryConfig.max = shieldBatteryConfig.max or 0
		shieldBatteryConfig.cmd = shieldBatteryConfig.cmd or "buykeypadshield"

		DarkRP.createEntity(shieldBatteryItemName, shieldBatteryConfig)
	end

end)
--addons/bkeypads/lua/bkeypads/cl_fake_angles.lua:
-- Prevents cheats from figuring out keypad codes from player view angles

local CMD_BTN_MASK = bit.bor(IN_ATTACK, IN_ATTACK2, IN_RELOAD, IN_WEAPON1, IN_WEAPON2)

local function IsGun(wep)
	return wep:GetPrimaryAmmoType() ~= -1 or wep:GetSecondaryAmmoType() ~= -1
end

bKeypads.FakeAngles = {
	UnmutatedTraceStruct = {},

	GetEyeData = function()
		if bKeypads.FakeAngles.Keypad and bKeypads.FakeAngles.Unmutated and bKeypads.FakeAngles.CalcViewStruct then
			return bKeypads.FakeAngles.CalcViewStruct.origin, bKeypads.FakeAngles.Unmutated:Forward()
		else
			local ply = LocalPlayer()
			return ply:EyePos(), ply:GetAimVector()
		end
	end,

	CalcView = function(ply, origin, angles, fov, znear, zfar)
		if ply ~= LocalPlayer() then return end
		if bKeypads.FakeAngles.Keypad and bKeypads.FakeAngles.Unmutated then
			bKeypads.FakeAngles.CalcViewStruct = bKeypads.FakeAngles.CalcViewStruct or {}

			bKeypads.FakeAngles.CalcViewStruct.origin = origin
			bKeypads.FakeAngles.CalcViewStruct.fov = fov
			bKeypads.FakeAngles.CalcViewStruct.znear = znear
			bKeypads.FakeAngles.CalcViewStruct.zfar = zfar

			bKeypads.FakeAngles.CalcViewStruct.angles = bKeypads.FakeAngles.Unmutated or angles

			if bKeypads.FakeAngles.Unmutated then
				bKeypads.FakeAngles.UnmutatedTraceStruct.start = origin
				bKeypads.FakeAngles.UnmutatedTraceStruct.endpos = origin + (bKeypads.FakeAngles.Unmutated:Forward() * 1024)
				bKeypads.FakeAngles.UnmutatedTraceStruct.filter = ply
				
				local UnmutatedTrace = util.TraceLine(bKeypads.FakeAngles.UnmutatedTraceStruct)
				if UnmutatedTrace.Entity ~= bKeypads.FakeAngles.Keypad then
					bKeypads.FakeAngles.Unlock = bKeypads.FakeAngles.Unmutated
				end
			end

			return bKeypads.FakeAngles.CalcViewStruct
		end
	end,

	CalcViewModelView = function(Weapon, ViewModel, OldEyePos, OldEyeAng)
		if not IsValid(Weapon) then return end
		if bKeypads.FakeAngles.Keypad and bKeypads.FakeAngles.Unmutated and bKeypads.FakeAngles.CalcViewStruct then
			local EyePos, EyeAng = bKeypads.FakeAngles.CalcViewStruct.origin, bKeypads.FakeAngles.CalcViewStruct.angles

			local vm_origin, vm_angles = EyePos, EyeAng

			local func = Weapon.GetViewModelPosition
			if func then
				local pos, ang = func(Weapon, EyePos*1, EyeAng*1)
				vm_origin = pos or vm_origin
				vm_angles = ang or vm_angles
			end

			func = Weapon.CalcViewModelView
			if func then
				local pos, ang = func(Weapon, ViewModel, OldEyePos*1, OldEyeAng*1, EyePos*1, EyeAng*1)
				vm_origin = pos or vm_origin
				vm_angles = ang or vm_angles
			end

			return vm_origin, vm_angles
		end
	end,

	CreateMove = function(cmd)
		if bKeypads.FakeAngles.Unlock then
			cmd:SetViewAngles(bKeypads.FakeAngles.Unlock)

			bKeypads.FakeAngles.Unlock = nil
			bKeypads.FakeAngles.Unmutated = nil
			bKeypads.FakeAngles.Keypad = nil

			return
		end

		if bKeypads.Settings:Get("pin_input_mode") == "look" then
			local ply = LocalPlayer()
			local wep = ply:GetActiveWeapon()
			local tr = ply:GetEyeTrace()
			if
				tr.Hit and IsValid(tr.Entity) and tr.Entity.bKeypad and ply:GetUseEntity() == tr.Entity and tr.Entity:GetAuthMode() == bKeypads.AUTH_MODE.PIN and
				bit.band(cmd:GetButtons(), CMD_BTN_MASK) == 0 and
				ply:GetViewEntity() == ply and
				(not IsValid(wep) or (wep:GetClass() ~= "gmod_tool" and not IsGun(wep))) and
				cmd:GetForwardMove() == 0 and cmd:GetSideMove() == 0 and cmd:GetUpMove() == 0 and
				ply:GetVelocity():IsZero() and
				tr.Entity:GetVelocity():IsZero()
			then
				bKeypads.FakeAngles.Keypad = tr.Entity

				local MutatedAngles = (tr.Entity:LocalToWorld(tr.Entity:OBBCenter()) - ply:EyePos()):Angle()

				if not bKeypads.FakeAngles.Unmutated then
					bKeypads.FakeAngles.Unmutated = cmd:GetViewAngles()
				else
					bKeypads.FakeAngles.Unmutated = bKeypads.FakeAngles.Unmutated + (cmd:GetViewAngles() - MutatedAngles)
				end

				bKeypads.FakeAngles.Unmutated:Normalize()

				cmd:SetViewAngles(MutatedAngles)

				return
			end
		end

		if bKeypads.FakeAngles.Unmutated then
			cmd:SetViewAngles(bKeypads.FakeAngles.Unmutated)
		end
		bKeypads.FakeAngles.Unmutated = nil
		bKeypads.FakeAngles.Keypad = nil
	end
}

hook.Add("CalcView", "bKeypads.Anticheat.CalcView", bKeypads.FakeAngles.CalcView)
hook.Add("CalcViewModelView", "bKeypads.Anticheat.CalcViewModelView", bKeypads.FakeAngles.CalcViewModelView)
hook.Add("CreateMove", "bKeypads.Anticheat.CreateMove", bKeypads.FakeAngles.CreateMove)
--addons/bkeypads/lua/bkeypads/cl_health_display.lua:
local scale_3d2d = 0.02
local barPadding = 10
function bKeypads:DrawHealth(ent, w, h)
	if ent:Health() <= 0 then return end
	
	surface.SetDrawColor(0, 0, 0, 200)
	surface.DrawRect(-w / 2, -h, w, h)

	ent.m_fHealthFrac = Lerp(FrameTime() * 15, ent.m_fHealthFrac or 1, math.max(math.min(ent:Health() / ent:GetMaxHealth(), 1), 0))
	local healthFrac = math.Round(ent.m_fHealthFrac, 3)

	surface.SetDrawColor((1 - healthFrac) * 255, healthFrac * 255, 0)
	surface.DrawRect((-w / 2) + barPadding, -h + barPadding, (w - (barPadding * 2)) * healthFrac, h - (barPadding * 2))

	if ent.GetMaxShield and ent:GetMaxShield() > 0 then
		ent.ShieldFrac = Lerp(FrameTime() * 15, ent.ShieldFrac or 0, math.max(math.min(ent:GetShield() / math.max(ent.m_iMaxShield, ent:GetMaxHealth()), 1), 0))
		local shieldFrac = math.Round(ent.ShieldFrac, 3)

		surface.SetDrawColor(bKeypads.COLOR.GMODBLUE)
		surface.DrawRect((-w / 2) + barPadding, -h + barPadding, (w - (barPadding * 2)) * shieldFrac, h - (barPadding * 2))
	end

	return (-50 * 2 * scale_3d2d) - 1.5
end
--addons/bkeypads/lua/bkeypads/lib/clip.lua:
AddCSLuaFile()
if SERVER then return end

local render = render
local Vector = Vector
local STENCIL_ALWAYS = STENCIL_ALWAYS
local STENCIL_KEEP = STENCIL_KEEP
local STENCIL_REPLACE = STENCIL_REPLACE
local STENCIL_EQUAL = STENCIL_EQUAL
local MATERIAL_CULLMODE_CW = MATERIAL_CULLMODE_CW
local MATERIAL_CULLMODE_CCW = MATERIAL_CULLMODE_CCW

local transparent = Color(0, 0, 0, 0)
local clipping = false

local clip = {}
setmetatable(clip, {
	__call = function()
		if clipping then
			clipping = false
			render.SetStencilEnable(false)
			return true
		end
		return false
	end
})
setfenv(1, clip)

local stencil do
local stenciling = false
function stencil()
	if stenciling then
		render.SetStencilCompareFunction(STENCIL_EQUAL)
		stenciling = false
		return
	end

	render.SetStencilWriteMask(0xFF)
	render.SetStencilTestMask(0xFF)
	render.SetStencilReferenceValue(0)
	render.SetStencilCompareFunction(STENCIL_ALWAYS)
	render.SetStencilPassOperation(STENCIL_KEEP)
	render.SetStencilFailOperation(STENCIL_KEEP)
	render.SetStencilZFailOperation(STENCIL_KEEP)
	render.ClearStencil()

	render.SetStencilEnable(true)
	render.SetStencilReferenceValue(1)

	render.SetStencilCompareFunction(STENCIL_ALWAYS)
	render.SetStencilPassOperation(STENCIL_REPLACE)

	stenciling = true
end end

do
	local vert1, vert2, vert3, vert4 = Vector(), Vector(), Vector(), Vector()
	function clip:Scissor2D(w, h, x, y, z)
		if clip() then return end

			vert1:SetUnpacked(
				x or 0,
				y or 0,
				z or 0
			)

			vert2:SetUnpacked(
				x or 0,
				h + (y or 0),
				z or 0
			)

			vert3:SetUnpacked(
				w + (x or 0),
				h + (y or 0),
				z or 0
			)

			vert4:SetUnpacked(
				w + (x or 0),
				y or 0,
				z or 0
			)
			
		stencil()

			render.CullMode(MATERIAL_CULLMODE_CW)
				render.SetColorMaterial()
				render.DrawQuad(vert1, vert2, vert3, vert4, transparent)
			render.CullMode(MATERIAL_CULLMODE_CCW)

		stencil()

		clipping = true
	end
end

do
	function clip:Scissor3D(pos, ang, mins, maxs)
		if clip() then return end

		stencil()

			render.SetColorMaterial()
			render.DrawBox(pos, ang, mins, maxs, transparent, true)

		stencil()

		clipping = true
	end
end

return clip
--addons/bkeypads/lua/bkeypads/lib/markup.lua:
-- FIXME https://github.com/Facepunch/garrysmod/pull/1732
-- probably won't get merged for years, so here we are

local string = string
local table = table
local surface = surface
local tostring = tostring
local ipairs = ipairs
local setmetatable = setmetatable
local math = math
local utf8 = utf8
local _Color = Color

local MarkupObject = {}
MarkupObject.__index = MarkupObject
--debug.getregistry().MarkupObject = MarkupObject

local markup = {}
setfenv(1, markup)

--[[---------------------------------------------------------
	Name: Constants used for text alignment.
		  These must be the same values as in the draw module.
-----------------------------------------------------------]]
TEXT_ALIGN_LEFT		= 0
TEXT_ALIGN_CENTER	= 1
TEXT_ALIGN_RIGHT	= 2
TEXT_ALIGN_TOP		= 3
TEXT_ALIGN_BOTTOM	= 4

--[[---------------------------------------------------------
	Name: Color(Color(r, g, b, a))
	Desc: Convenience function which converts a Color object into a string
	      which can be used in the <color=r,g,b,a></color> tag

	      e.g. Color(255, 0, 0, 150) -> 255,0,0,150
	           Color(255, 0, 0)      -> 255,0,0
	           Color(255, 0, 0, 255) -> 255,0,0

	Usage: markup.Color(Color(r, g, b, a))
-----------------------------------------------------------]]
function Color( col )
	return
		col.r .. "," ..
		col.g .. "," ..
		col.b ..
		-- If the alpha value is 255, we don't need to include it in the <color> tag, so just omit it:
		( col.a == 255 and "" or ( "," .. col.a ) )
end

local Color = _Color

--[[---------------------------------------------------------
	Name: Temporary information used when building text frames.
-----------------------------------------------------------]]
local colour_stack = { Color( 255, 255, 255 ) }
local font_stack = { "DermaDefault" }
local blocks = {}

local colourmap = {

-- it's all black and white
	["black"] =		Color( 0, 0, 0 ),
	["white"] =		Color( 255, 255, 255 ),

-- it's greys
	["dkgrey"] =	Color( 64, 64, 64 ),
	["grey"] =		Color( 128, 128, 128 ),
	["ltgrey"] =	Color( 192, 192, 192 ),

-- account for speeling mistakes
	["dkgray"] =	Color( 64, 64, 64 ),
	["gray"] =		Color( 128, 128, 128 ),
	["ltgray"] =	Color( 192, 192, 192 ),

-- normal colours
	["red"] =		Color( 255, 0, 0 ),
	["green"] =		Color( 0, 255, 0 ),
	["blue"] =		Color( 0, 0, 255 ),
	["yellow"] =	Color( 255, 255, 0 ),
	["purple"] =	Color( 255, 0, 255 ),
	["cyan"] =		Color( 0, 255, 255 ),
	["turq"] =		Color( 0, 255, 255 ),

-- dark variations
	["dkred"] =		Color( 128, 0, 0 ),
	["dkgreen"] =	Color( 0, 128, 0 ),
	["dkblue"] =	Color( 0, 0, 128 ),
	["dkyellow"] =	Color( 128, 128, 0 ),
	["dkpurple"] =	Color( 128, 0, 128 ),
	["dkcyan"] =	Color( 0, 128, 128 ),
	["dkturq"] =	Color( 0, 128, 128 ),

-- light variations
	["ltred"] =		Color( 255, 128, 128 ),
	["ltgreen"] =	Color( 128, 255, 128 ),
	["ltblue"] =	Color( 128, 128, 255 ),
	["ltyellow"] =	Color( 255, 255, 128 ),
	["ltpurple"] =	Color( 255, 128, 255 ),
	["ltcyan"] =	Color( 128, 255, 255 ),
	["ltturq"] =	Color( 128, 255, 255 ),

}

--[[---------------------------------------------------------
	Name: colourMatch(c)
	Desc: Match a colour name to an rgb value.
	Usage: ** INTERNAL ** Do not use!
-----------------------------------------------------------]]
local function colourMatch( c )
	return colourmap[ string.lower( c ) ]
end

--[[---------------------------------------------------------
	Name: ExtractParams(p1,p2,p3)
	Desc: This function is used to extract the tag information.
	Usage: ** INTERNAL ** Do not use!
-----------------------------------------------------------]]
local function ExtractParams( p1, p2, p3 )

	if ( string.sub( p1, 1, 1 ) == "/" ) then

		local tag = string.sub( p1, 2 )

		if ( tag == "color" or tag == "colour" ) then
			table.remove( colour_stack )
		elseif ( tag == "font" or tag == "face" ) then
			table.remove( font_stack )
		end

	else

		if ( p1 == "color" or p1 == "colour" ) then

			local rgba = colourMatch( p2 )

			if ( rgba == nil ) then
				rgba = {}
				local x = { "r", "g", "b", "a" }
				local n = 1
				for k, v in string.gmatch( p2, "(%d+),?" ) do
					rgba[ x[ n ] ] = k
					n = n + 1
				end
			end

			table.insert( colour_stack, rgba )

		elseif ( p1 == "font" or p1 == "face" ) then

			table.insert( font_stack, tostring( p2 ) )

		end

	end
end

--[[---------------------------------------------------------
	Name: CheckTextOrTag(p)
	Desc: This function places data in the "blocks" table
		  depending of if p is a tag, or some text
	Usage: ** INTERNAL ** Do not use!
-----------------------------------------------------------]]
local function CheckTextOrTag( p )
	if ( p == "" ) then return end
	if ( p == nil ) then return end

	if ( string.sub( p, 1, 1 ) == "<" ) then
		string.gsub( p, "<([/%a]*)=?([^>]*)", ExtractParams )
	else

		local text_block = {}
		text_block.text = p
		text_block.colour = colour_stack[ #colour_stack ]
		text_block.font = font_stack[ #font_stack ]
		table.insert( blocks, text_block )

	end
end

--[[---------------------------------------------------------
	Name: ProcessMatches(p1,p2,p3)
	Desc: CheckTextOrTag for 3 parameters. Called by string.gsub
	Usage: ** INTERNAL ** Do not use!
-----------------------------------------------------------]]
local function ProcessMatches( p1, p2, p3 )
	if ( p1 ) then CheckTextOrTag( p1 ) end
	if ( p2 ) then CheckTextOrTag( p2 ) end
	if ( p3 ) then CheckTextOrTag( p3 ) end
end

--[[---------------------------------------------------------
	Name: MarkupObject:GetWidth()
	Desc: Returns the width of a markup block
	Usage: ml:GetWidth()
-----------------------------------------------------------]]
function MarkupObject:GetWidth()
	return self.totalWidth
end

--[[---------------------------------------------------------
	Name: MarkupObject:GetMaxWidth()
	Desc: Returns the maximum width of a markup block
	Usage: ml:GetMaxWidth()
-----------------------------------------------------------]]
function MarkupObject:GetMaxWidth()
	return self.maxWidth or self.totalWidth
end

--[[---------------------------------------------------------
	Name: MarkupObject:GetHeight()
	Desc: Returns the height of a markup block
	Usage: ml:GetHeight()
-----------------------------------------------------------]]
function MarkupObject:GetHeight()
	return self.totalHeight
end

function MarkupObject:Size()
	return self.totalWidth, self.totalHeight
end

--[[---------------------------------------------------------
	Name: MarkupObject:Draw(xOffset, yOffset, halign, valign, alphaoverride)
	Desc: Draw the markup text to the screen as position xOffset, yOffset.
		  Halign and Valign can be used to align the text relative to its offset.
		  Alphaoverride can be used to override the alpha value of the text-colour.
		  textAlign can be used to align the actual text inside of its bounds.
	Usage: MarkupObject:Draw(100, 100)
-----------------------------------------------------------]]
function MarkupObject:Draw( xOffset, yOffset, halign, valign, alphaoverride, textAlign )
	for i, blk in ipairs( self.blocks ) do
		local y = yOffset + ( blk.height - blk.thisY ) + blk.offset.y
		local x = xOffset

		if ( halign == TEXT_ALIGN_CENTER ) then		x = x - ( self.totalWidth / 2 )
		elseif ( halign == TEXT_ALIGN_RIGHT ) then	x = x - self.totalWidth
		end

		x = x + blk.offset.x

		if ( valign == TEXT_ALIGN_CENTER ) then		y = y - ( self.totalHeight / 2 )
		elseif ( valign == TEXT_ALIGN_BOTTOM ) then	y = y - self.totalHeight
		end

		local alpha = blk.colour.a
		if ( alphaoverride ) then alpha = alphaoverride end

		surface.SetFont( blk.font )
		surface.SetTextColor( blk.colour.r, blk.colour.g, blk.colour.b, alpha )

		surface.SetTextPos( x, y )
		if ( textAlign ~= TEXT_ALIGN_LEFT and self.maxWidth ) then
			local lineWidth = self.lineWidths[ blk.offset.y ]
			if ( lineWidth ) then
				if ( textAlign == TEXT_ALIGN_CENTER ) then
					surface.SetTextPos( x + ( ( self.maxWidth - lineWidth ) / 2 ), y )
				elseif ( textAlign == TEXT_ALIGN_RIGHT ) then
					surface.SetTextPos( x + ( self.maxWidth - lineWidth ), y )
				end
			end
		end

		surface.DrawText( blk.text )
	end
end

--[[---------------------------------------------------------
	Name: Escape(str)
	Desc: Converts a string to its escaped, markup-safe equivalent
	Usage: markup.Escape("<font=Default>The font will remain unchanged & these < > & symbols will also appear normally</font>")
-----------------------------------------------------------]]
local escapeEntities, unescapeEntities = {
	["&"] = "&amp;",
	["<"] = "&lt;",
	[">"] = "&gt;"
}, {
	["&amp;"] = "&",
	["&lt;"] = "<",
	["&gt;"] = ">"
}
function Escape( str )
	return ( string.gsub( tostring( str ), "[&<>]", escapeEntities ) )
end

--[[---------------------------------------------------------
	Name: Parse(ml, maxwidth)
	Desc: Parses the pseudo-html markup language, and creates a
		  MarkupObject, which can be used to the draw the
		  text to the screen. Valid tags are: font and colour.
		  \n and \t are also available to move to the next line,
		  or insert a tab character.
		  Maxwidth can be used to make the text wrap to a specific
		  width and allows for text alignment (e.g. centering) inside
		  the bounds.
	Usage: markup.Parse("<font=Default>changed font</font>\n<colour=255,0,255,255>changed colour</colour>")
-----------------------------------------------------------]]
function Parse( ml, maxwidth )

	ml = utf8.force( ml ) -- Ensure we have valid UTF-8 data

	colour_stack = { Color( 255, 255, 255 ) }
	font_stack = { "DermaDefault" }
	blocks = {}

	if ( !string.find( ml, "<" ) ) then
		ml = ml .. "<nop>"
	end

	string.gsub( ml, "([^<>]*)(<[^>]+.)([^<>]*)", ProcessMatches )

	local xOffset = 0
	local yOffset = 0
	local xSize = 0
	local xMax = 0
	local thisMaxY = 0
	local new_block_list = {}
	local ymaxes = {}
	local lineWidths = {}

	local lineHeight = 0
	for i, blk in ipairs( blocks ) do

		surface.SetFont( blk.font )
		
		blk.text = string.gsub( blk.text, "(&.-;)", unescapeEntities )

		local thisY = 0
		local curString = ""
		for j, c in utf8.codes( blk.text ) do

			local ch = utf8.char( c )

			if ( ch == "\n" ) then

				if ( thisY == 0 ) then
					thisY = lineHeight
					thisMaxY = lineHeight
				else
					lineHeight = thisY
				end

				if ( string.len( curString ) > 0 ) then
					local x1 = surface.GetTextSize( curString )

					local new_block = {
						text = curString,
						font = blk.font,
						colour = blk.colour,
						thisY = thisY,
						thisX = x1,
						offset = {
							x = xOffset,
							y = yOffset
						}
					}
					table.insert( new_block_list, new_block )
					if ( xOffset + x1 > xMax ) then
						xMax = xOffset + x1
					end
				end

				xOffset = 0
				xSize = 0
				yOffset = yOffset + thisMaxY
				thisY = 0
				curString = ""
				thisMaxY = 0

			elseif ( ch == "\t" ) then

				if ( string.len( curString ) > 0 ) then
					local x1 = surface.GetTextSize( curString )

					local new_block = {
						text = curString,
						font = blk.font,
						colour = blk.colour,
						thisY = thisY,
						thisX = x1,
						offset = {
							x = xOffset,
							y = yOffset
						}
					}
					table.insert( new_block_list, new_block )
					if ( xOffset + x1 > xMax ) then
						xMax = xOffset + x1
					end
				end
				
				curString = ""

				local xOldSize = xSize
				xSize = 0
				local xOldOffset = xOffset
				xOffset = math.ceil( ( xOffset + xOldSize ) / 50 ) * 50

				if ( xOffset == xOldOffset ) then
					xOffset = xOffset + 50
					
					if ( maxwidth and xOffset > maxwidth ) then
						-- Needs a new line
						if ( thisY == 0 ) then
							thisY = lineHeight
							thisMaxY = lineHeight
						else
							lineHeight = thisY
						end
						xOffset = 0
						yOffset = yOffset + thisMaxY
						thisY = 0
						thisMaxY = 0
					end
				end
			else
				local x, y = surface.GetTextSize( ch )

				if ( x == nil ) then return end

				if ( maxwidth and maxwidth > x ) then
					if ( xOffset + xSize + x >= maxwidth ) then

						-- need to: find the previous space in the curString
						--          if we can't find one, take off the last character
						--          and insert as a new block, incrementing the y etc

						local lastSpacePos = string.len( curString )
						for k = 1,string.len( curString ) do
							local chspace = string.sub( curString, k, k )
							if ( chspace == " " ) then
								lastSpacePos = k
							end
						end

						local previous_block = new_block_list[ #new_block_list ]
						local wrap = lastSpacePos == string.len( curString ) && lastSpacePos > 0
						if ( previous_block and previous_block.text:match(" $") and wrap and surface.GetTextSize( blk.text ) < maxwidth ) then
							-- If the block was preceded by a space, wrap the block onto the next line first, as we can probably fit it there
							local trimmed, trimCharNum = previous_block.text:gsub(" +$", "")
							if ( trimCharNum > 0 ) then
								previous_block.text = trimmed
								previous_block.thisX = surface.GetTextSize( previous_block.text )
							end
						else
							if ( wrap ) then
								-- If the block takes up multiple lines (and has no spaces), split it up
								local sequenceStartPos = utf8.offset( curString, 0, lastSpacePos )
								ch = string.match( curString, utf8.charpattern, sequenceStartPos ) .. ch
								j = utf8.offset( curString, 1, sequenceStartPos )
								curString = string.sub( curString, 1, sequenceStartPos - 1 )
							else
								-- Otherwise, strip the trailing space and start a new line
								ch = string.sub( curString, lastSpacePos + 1 ) .. ch
								j = lastSpacePos + 1
								curString = string.sub( curString, 1, math.max( lastSpacePos - 1, 0 ) )
							end

							local m = 1
							while string.sub( ch, m, m ) == " " do
								m = m + 1
							end
							ch = string.sub( ch, m )

							local x1,y1 = surface.GetTextSize( curString )

							if ( y1 > thisMaxY ) then
								thisMaxY = y1
								ymaxes[ yOffset ] = thisMaxY
								lineHeight = y1
							end

							local new_block = {
								text = curString,
								font = blk.font,
								colour = blk.colour,
								thisY = thisY,
								thisX = x1,
								offset = {
									x = xOffset,
									y = yOffset
								}
							}
							table.insert( new_block_list, new_block )

							if ( xOffset + x1 > xMax ) then
								xMax = xOffset + x1
							end

							curString = ""
						end

						xOffset = 0
						xSize = 0
						x, y = surface.GetTextSize( ch )
						yOffset = yOffset + thisMaxY
						thisY = 0
						thisMaxY = 0
					end
				end

				curString = curString .. ch

				thisY = y
				xSize = xSize + x

				if ( y > thisMaxY ) then
					thisMaxY = y
					ymaxes[ yOffset ] = thisMaxY
					lineHeight = y
				end
			end
		end

		if ( string.len( curString ) > 0 ) then

			local x1 = surface.GetTextSize( curString )

			local new_block = {
				text = curString,
				font = blk.font,
				colour = blk.colour,
				thisY = thisY,
				thisX = x1,
				offset = {
					x = xOffset,
					y = yOffset
				}
			}
			table.insert( new_block_list, new_block )

			lineHeight = thisY

			if ( xOffset + x1 > xMax ) then
				xMax = xOffset + x1
			end
			xOffset = xOffset + x1
		end
		xSize = 0
	end

	local totalHeight = 0
	for i, blk in ipairs( new_block_list ) do
		blk.height = ymaxes[ blk.offset.y ]

		if ( blk.offset.y + blk.height > totalHeight ) then
			totalHeight = blk.offset.y + blk.height
		end

		lineWidths[ blk.offset.y ] = math.max( lineWidths[ blk.offset.y ] or 0, blk.offset.x + blk.thisX )
	end

	return setmetatable( {
		totalHeight = totalHeight,
		totalWidth = xMax,
		maxWidth = maxwidth,
		lineWidths = lineWidths,
		blocks = new_block_list
	}, MarkupObject )
end

return markup
--lua/autorun/advr_utils.lua:
function ADVR_GetAllEnts(pos, radius, allow_weapons, allow_no_model)
    local entsList = {}

    local foundEnts
    if pos and radius then
        foundEnts = ents.FindInSphere(pos, radius)
    else
        foundEnts = ents.GetAll()
    end

    for k, ent in ipairs(foundEnts) do
        if not ent:IsValid() then continue end
        if ent:EntIndex() == -1 then continue end
        if ADVRBlacklist[ent:GetClass()] then continue end
        if not allow_weapons and ent:IsWeapon() then continue end
        if not allow_no_model and (ent:GetModel() == "" or ent:GetModel() == nil) then continue end

        local constraineds = {}

        if SERVER and ent:IsConstrained() then
            local constrainedEntities = constraint.GetAllConstrainedEntities(ent)

            for _, cEnt in pairs(constrainedEntities) do
                table.insert(constraineds, cEnt:EntIndex())
            end
        end

        local entInfo = {
			index = ent:EntIndex(),
			pos = ent:GetPos(),
			angles = ent:GetAngles(),
			normal = ent:GetUp(),
			class = ent.GetClass and ent:GetClass() or "",
			name = ent.GetName and ent:GetName() or "",
			model = ent.GetModel and ent:GetModel() or "",
            constraineds = constraineds
		}

        if entInfo.model ~= "" and string.GetExtensionFromFilename(entInfo.model) == "mdl" then
            entInfo.isMissing = not file.Exists(entInfo.model, "GAME")
        end

		table.insert(entsList, entInfo)
	end

    return entsList
end


-- Diretamente do remover tool do GMod
function ADVR_RemoveEnt(ent)
	if not IsValid(ent) or ent:IsPlayer() then return false end

	if CLIENT then return true end

    -- Remove all constraints (this stops ropes from hanging around)
    constraint.RemoveAll(ent)

    -- Remove it properly in 1 second
    timer.Simple(1, function()
        if IsValid(ent) then
            ent:Remove()
        end
    end)

    -- Make it non solid
    ent:SetNotSolid(true)
    ent:SetMoveType(MOVETYPE_NONE)
    ent:SetNoDraw(true)

    -- Send Effect
    local ed = EffectData()
        ed:SetOrigin(ent:GetPos())
        ed:SetEntity(ent)
    util.Effect("entity_remove", ed, true, true)

    return true
end


-- Removo a entidade e todos os penduricalhos
function ADVR_RemoveEntWithConstraineds(ent)
    if not IsValid(ent) or ent:IsPlayer() then return false end

    if CLIENT then return true end

    local constrainedEntities = constraint.GetAllConstrainedEntities(ent)

    for k, cEnt in pairs(constrainedEntities) do
        ADVR_RemoveEnt(cEnt)
    end

    return true
end
--lua/autorun/alarm.lua:
if !SERVER or game.GetMap() != "rp_kamino_extensive" then return end

sound.Add({
	name = "kamino_alarm",
	channel = CHAN_STATIC,
	volume = 0.7,
	level = 80,
	pitch = { 95 },
	sound = "mysounds/starwars/alarm3.wav"
})

sound.Add({
	name = "acclamator_alarm",
	channel = CHAN_STATIC,
	volume = 0.7,
	level = 80,
	pitch = { 95 },
	sound = "mysounds/starwars/alarm.wav"
})

local zones = {
    ["kamino"] = {
        {
            ["min"] = Vector(-8192,-8192,-13312),
            ["max"] = Vector( 8192, 8192,- 6656)
        }    
    },
    ["acclamator"] = {
        {  
            ["min"] = Vector(-5120,-8704,7168),
            ["max"] = Vector( 2048,-3584,9728)
        }
    }
}
 
local function InZone(ply)
    local pos = ply:GetPos()
 
    for zoneName, zones in pairs(zones) do
        for k, zone in pairs(zones) do
            if pos.x < zone.min.x then continue end
            if pos.y < zone.min.y then continue end
            if pos.z < zone.min.z then continue end
 
            if pos.x > zone.max.x then continue end
            if pos.y > zone.max.y then continue end
            if pos.z > zone.max.z then continue end
 
            return true, zoneName
        end
    end
 
    return false
end
 
local OldKaminoAlarm = false
local OldAcclamatorAlarm = false
local NextThink = 0
 
hook.Add("Think", "KaminoAlarm", function()
    if NextThink > CurTime() then return end
   
    if !isbool(KaminoAlarm) then
        KaminoAlarm = false
    end
    if !isbool(AcclamatorAlarm) then
        AcclamatorAlarm = false
    end
 
    for k, ply in pairs(player.GetAll()) do
        if !isbool(ply.InZone) then
            ply.InZone = false
        end
       
        local lastInZone = ply.InZone
        local inZone, zone = InZone(ply)
 
        --the kamino alarm was toggled
        if OldKaminoAlarm != KaminoAlarm then
            if KaminoAlarm and inZone and zone == "kamino" then
                ply:EmitSound("kamino_alarm")
            else
                ply:StopSound("kamino_alarm")
            end
           
            OldKaminoAlarm = KaminoAlarm
        end
 
        --the acclamator alarm was toggled
        if OldAcclamatorAlarm != AcclamatorAlarm then
            if AcclamatorAlarm and inZone and zone == "acclamator" then
                ply:EmitSound("acclamator_alarm")
            else
                ply:StopSound("acclamator_alarm")
            end
           
            OldAcclamatorAlarm = AcclamatorAlarm
        end
 
        --player entered or left a zone
        if lastInZone != inZone then
            if inZone then
                if zone == "kamino" and KaminoAlarm then
                    ply:EmitSound("kamino_alarm")
                elseif zone == "acclamator" and AcclamatorAlarm then
                    ply:EmitSound("acclamator_alarm")
                end
            else
                ply:StopSound("kamino_alarm")
                ply:StopSound("acclamator_alarm")
            end
        end
 
        ply.InZone = inZone
    end
 
    NextThink = CurTime() + 0.5
end)
--lua/autorun/ameda.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "MasAmeda",		"models/player/tiki/ameda.mdl" )

--lua/autorun/anakin_bf2.lua:
--anakin robe
list.Set( "anakin_robe", "models/cyanblue/sw/anakin/anakin.mdl")
player_manager.AddValidModel( "anakin_robe", "models/cyanblue/sw/anakin/anakin.mdl" );

--anakin general
list.Set( "anakin_general", "models/kaiido/anakin/anakin.mdl")
player_manager.AddValidModel( "anakin_general", "models/kaiido/anakin/anakin.mdl" );


--lua/autorun/b2_battledroid.lua:
list.Set( "b2_battledroid", "models/player/hydro/b2_battledroid/b2_battledroid.mdl" )   // "models/player/hydro/b2_battledroid/b2_battledroid.mdl" )
player_manager.AddValidModel( "b2_battledroid", "models/player/hydro/b2_battledroid/b2_battledroid.mdl" )   // "models/player/hydro/b2_battledroid/b2_battledroid.mdl" )
player_manager.AddValidHands( "b2_battledroid", "models/player/hydro/b2_battledroid/b2_battledroid_hands.mdl", 0, "00000000" ) // "models/player/hydro/b2_battledroid/b2_battledroid_hands.mdl", 0, "00000000"

--lua/autorun/badbatch.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )
	
end

AddPlayerModel ("Bad Batch Hunter", "models/badbatch/hunter/hunter.mdl" )
AddPlayerModel ("Bad Batch crosshair", "models/badbatch/crosshair/badbatchcrosshair.mdl" )
AddPlayerModel ("Bad Batch tech", "models/badbatch/tech/tech.mdl" )
AddPlayerModel ("Bad Batch wrecker", "models/badbatch/wrecker/wrecker.mdl" )
--lua/autorun/bailorgana_padme.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "Bail Organa",		"models/player/tiki/bailorgana.mdl" )
AddPlayerModel( "Padme Amidala", 				"models/player/imagundi/padme/padme.mdl" )

--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--lua/autorun/bobafettyoungsuit.lua:
player_manager.AddValidModel( "CGI Young Boba", "models/player/valley/BobaFettYoungSuit.mdl" )

local Category = "CGI Young Boba"

local NPC =
{
	Name = "Young Boba Friendly",
	Class = "npc_citizen",
	KeyValues =
	{
		citizentype = 4
	},
	Model = "models/player/valley/npc/BobaFettYoungSuitNPC.mdl",
	Health = "1000",
	Category = "CGI Young Boba"
}

list.Set( "NPC", "npc_valley_youngbobaf", NPC )

local Category = "CGI Young Boba"

local NPC =
{
	Name = "Young Boba Enemy",
	Class = "npc_combine_s",
	Model = "models/player/valley/npc/BobaFettYoungSuitNPC.mdl",
	Health = "1000",
	Category = "CGI Young Boba"
}

list.Set( "NPC", "npc_valley_youngbobae", NPC )

if SERVER then
	resource.AddWorkshop("884888084")
end
--lua/autorun/concorkill.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "Senator Concorkill",		"models/player/tiki/concorkill.mdl" )

--lua/autorun/dathomir_npc.lua:
local NPC = {
	Name = "Nightsister (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightsister_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_nightsister_f", NPC )


local NPC = {
	Name = "Nightsister (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightsister_h.mdl",
}
list.Set( "NPC", "npc_nightsister_h", NPC )


local NPC = {
	Name = "Nightbrother (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightbrother_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_nightbrother_f", NPC )


local NPC = {
	Name = "Nightbrother (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightbrother_h.mdl",
}
list.Set( "NPC", "npc_nightbrother_h", NPC )

local NPC = {
	Name = "Nightbrother Brawler (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightbrother_brawler_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_nightbrother_brawler_f", NPC )


local NPC = {
	Name = "Nightbrother Brawler (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightbrother_brawler_h.mdl",
}
list.Set( "NPC", "npc_nightbrother_brawler_h", NPC )

local NPC = {
	Name = "Old Daka (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightsister_olddaka_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_nightsister_olddaka_f", NPC )


local NPC = {
	Name = "Old Daka (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightsister_olddaka_h.mdl",
}
list.Set( "NPC", "npc_nightsister_olddaka_h", NPC )

local NPC = {
	Name = "Mother Talzin (Friendly)",
	Class = "npc_citizen",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightsister_mothertalzin_f.mdl",
	KeyValues = { citizentype = CT_UNIQUE }
}
list.Set( "NPC", "npc_nightsister_mothertalzin_f", NPC )


local NPC = {
	Name = "Mother Talzin (Hostile)",
	Class = "npc_combine_s",
	Category = "CGI Dathomir Warriors",
	Model = "models/npc/dathomir/npc_nightsister_mothertalzin_h.mdl",
}
list.Set( "NPC", "npc_nightsister_mothertalzin_h", NPC )

local Category = "CGI Dathomir Warriors"




--lua/autorun/dooku_pm_sirris.lua:
player_manager.AddValidModel( "Dooku_PM",	"models/sirris_sw/Dooku_PM.mdl" )
list.Set( "PlayerOptionsModel",  "Dooku_PM",	"models/sirris_sw/Dooku_PM.mdl" )
player_manager.AddValidHands( "Dooku_PM",	"models/sirris_sw/Dooku_PM_arms.mdl", 4, "01000000")
--lua/autorun/egm_ccsiyo.lua:
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.501stSiyo", function()
	-- 501st Siyo Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "501st_siyo", "501st Siyo - Armor", {
		["body"] = "egm/custom_char/501st/siyo/body/body",
		["body_mirrored"] = "egm/custom_char/501st/siyo/body/body",

		["kama"] = "egm/501st/attachments/kama_black",
		["kama_arc"] = "egm/501st/attachments/kama_arc_black",

		["rank_tab"] = "egm/501st/attachments/rank_tab",

		["pauldron"] = "egm/501st/attachments/pauldron",
		["pauldron_simple"] = "egm/501st/attachments/pauldron_simple",

		["ammo_arm"] = "egm/501st/attachments/ammo_arm",
		["antenna_shoulder"] = "egm/501st/attachments/antenna_shoulder",
	})
	-- 501st Siyo Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "501st_siyo", "501st - Siyo Helmet", {
		["helmet"] = "egm/custom_char/501st/siyo/body/helmet",
		["antenna_back"] = "egm/501st/attachments/antenna_back",
		["armor"] = "egm/501st/attachments/armor",
		["binoculars"] = "egm/501st/attachments/binoculars",
		["rangefinder"] = "egm/501st/attachments/rangefinder",
		["sunvisor"] = "egm/501st/attachments/sunvisor",
		["arc_crest"] = "egm/501st/lore/echo/arc_crest",
	})
end)
--addons/playermodels/lua/autorun/egm_custom_playermodel.lua:
list.Set( "PlayerOptionsModel",  "Hondo Ohnaka", "models/player/ohanak_gang/pm_pirate_hondo.mdl" );
player_manager.AddValidModel( "Hondo Ohnaka", "models/player/ohanak_gang/pm_pirate_hondo.mdl" );


list.Set( "PlayerOptionsModel", "Jedi Gungan", "models/player/jedi/gungan.mdl" )
player_manager.AddValidModel( "Jedi Gungan", "models/player/jedi/gungan.mdl" )


list.Set( "PlayerOptionsModel", "SEC Mann", "models/player/n7legion/killingfloor2/horzine_sec_suit_male.mdl" )
player_manager.AddValidModel( "SEC Mann", "models/player/n7legion/killingfloor2/horzine_sec_suit_male.mdl" )


list.Set( "PlayerOptionsModel", "SEC Frau", "models/player/n7legion/killingfloor2/horzine_sec_suit_female.mdl" )
player_manager.AddValidModel( "SEC Frau", "models/player/n7legion/killingfloor2/horzine_sec_suit_female.mdl" )


list.Set( "PlayerOptionsModel", "KGJ Typ", "models/yates/rangercombat.mdl" )
player_manager.AddValidModel( "KGJ Typ", "models/yates/rangercombat.mdl" )


list.Set( "PlayerOptionsModel", "Kaleesh CC.2", "models/player/valley/xalek.mdl" )
player_manager.AddValidModel( "Kaleesh CC.2", "models/player/valley/xalek.mdl" )


list.Set( "PlayerOptionsModel", "Seuchenschutzanzug", "models/player/cdc_soldier_player.mdl" )
player_manager.AddValidModel( "Seuchenschutzanzug", "models/player/cdc_soldier_player.mdl" )


list.Set( "PlayerOptionsModel", "Plo Koon BF2", "models/hevoc/bf2_plokoon/bf2_plokoon.mdl")
player_manager.AddValidModel( "Plo Koon BF2", "models/hevoc/bf2_plokoon/bf2_plokoon.mdl")


list.Set( "PlayerOptionsModel", "HK-55", "models/odd/nikout/swtor/player/hk51.mdl")
player_manager.AddValidModel( "HK-55", "models/odd/nikout/swtor/player/hk51.mdl" )


list.Set( "PlayerOptionsModel", "Bodyguard Droid", "models/player/swtor/droids/bodyguard_droid.mdl" )
player_manager.AddValidModel( "Bodyguard Droid", "models/player/swtor/droids/bodyguard_droid.mdl" )


list.Set( "PlayerOptionsModel", "Combat Medic Droid", "models/player/swtor/droids/combat_medicaldroid.mdl" )
player_manager.AddValidModel( "Combat Medic Droid", "models/player/swtor/droids/combat_medicaldroid.mdl" )


list.Set( "PlayerOptionsModel", "Enforcer Droid", "models/player/swtor/droids/enforcerdroid.mdl" )
player_manager.AddValidModel( "Enforcer Droid", "models/player/swtor/droids/enforcerdroid.mdl" )


list.Set( "PlayerOptionsModel", "Slicer Droid", "models/player/swtor/droids/slicer_droid.mdl" )
player_manager.AddValidModel( "Slicer Droid", "models/player/swtor/droids/slicer_droid.mdl" )


list.Set( "PlayerOptionsModel", "Worker Droid", "models/player/swtor/droids/worker_droid.mdl")
player_manager.AddValidModel( "Worker Droid", "models/player/swtor/droids/worker_droid.mdl")
--lua/autorun/egm_cutter.lua:
-- Register the ST Custom Char Cutter Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.STCutter", function()
	-- Cutter Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "st_cutter", "ST Cutter - Armor", {
        ["body"] = "egm/custom_char/st/cutter/body",
		["body_mirrored"] = "egm/custom_char/st/cutter/body_2",

		["arc_gear_body"] = "egm/custom_char/st/cutter/gear",
		["arc_gear_legs"] = "egm/custom_char/st/cutter/gear",
		["arc_gear_arms"] = "egm/custom_char/st/cutter/gear",
		["pauldron_big"] = "egm/custom_char/st/cutter/gear",

		["kama_arc"] = "egm/custom_char/st/cutter/arc_kama",
		["holsters"] = "egm/custom_char/st/cutter/gear",

		["kama"] = "egm/shock_trooper_refresh/trooper/kama",

		["pauldron"] = "egm/shock_trooper_refresh/trooper/specialist",
		["ammo_arm"] = "egm/shock_trooper_refresh/trooper/specialist",
    })
	-- Helmet P2
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "st_cutter", "ST Cutter - Helmet", {
		["helmet"] = "egm/custom_char/st/cutter/helmet",
		["sunvisor"] = "egm/custom_char/st/cutter/heavy",
		["armor"] = "egm/shock_trooper_refresh/trooper/heavy",
		["binoculars"] = "egm/shock_trooper_refresh/trooper/specialist",
	})
end)
--lua/autorun/egm_decho.lua:
-- Register the Custom Char Decho Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.104thdecho", function()
	-- Decho Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "104th_decho", "104th decho - Armor", {
        ["body"] = "egm/custom_char/104th/decho/body",
		["body_mirrored"] = "egm/custom_char/104th/decho/body2",

		["kama"] = "egm/104th/shared/heavy",
		["kama_arc"] = "egm/custom_char/104th/decho/kama_arc",
		
		["pauldron"] = "egm/custom_char/104th/decho/specialist",
		["ammo_arm"] = "egm/custom_char/104th/decho/specialist",
	})
	
	-- Decho ARF Helmet
		BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "104th_decho", "104th decho - Helmet", {
		["helmet_arf"] = "egm/custom_char/104th/decho/helmet_arf",
		["antenna_arf"] = "egm/core/helmet_arf/antenna_arf",
		["armor"] = "egm/custom_char/104th/decho/armor",
	})
	-- Decho Jumppack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jumppack/bp_jumppack.mdl", "104th_decho", "104th decho - Jumppack", {
		["bp_jumppack"] = "egm/custom_char/104th/decho/specialist",
	})
end)
--lua/autorun/egm_epsilon.lua:
-- Register the Custom Char Epsilon Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.RMCEpsilon", function()
	-- Epsilon Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "rmc_epsilon", "Epsilon Body", {
		["body"] = "egm/rmc/jumptrooper/body",
		["body_mirrored"] = "egm/custom_char/rmc/epsilon/body2",

		["kama"] = "egm/rmc/attachments/heavy",
		["kama_arc"] = "egm/custom_char/rmc/epsilon/kama_arc",

		["pauldron"] = "egm/rmc/attachments/specialist_red",
		["ammo_arm"] = "egm/rmc/attachments/specialist",
		
		["pauldron_big"] = "egm/custom_char/rmc/epsilon/gear",
		["holsters"] = "egm/custom_char/rmc/epsilon/gear",
		["arc_gear_body"] = "egm/custom_char/rmc/epsilon/gear",
		["arc_gear_legs"] = "egm/custom_char/rmc/epsilon/gear",
		["arc_gear_arms"] = "egm/custom_char/rmc/epsilon/gear",
	})
	-- Epsilon Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "rmc_epsilon", "Epsilon Helmet", {
		["helmet"] = "egm/custom_char/rmc/epsilon/helmet",
		
		["sunvisor"] = "egm/rmc/attachments/heavy_red",
		["armor"] = "egm/rmc/attachments/heavy_red",
		
		["arc_crest"] = "egm/custom_char/rmc/epsilon/arc_crest",
		
		["binoculars"] = "egm/rmc/attachments/specialist",
	})
		-- Jetpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "rmc_epsilon", "Epsilon Jetpack", {
		["bp_jetpack"] = "egm/custom_char/rmc/epsilon/jetpack",
	})
end)
--lua/autorun/egm_jay.lua:
-- Register the Custom Char Jay Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.41stJay", function()
	-- Jay Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "41st_jay", "41st jay - Armor", {
        ["body"] = "egm/custom_char/41st/jay/body",
		["body_mirrored"] = "egm/custom_char/41st/jay/body2",

		["kama"] = "egm/41st/trooper/heavy",
		["kama_arc"] = "egm/custom_char/41st/jay/kama_arc",

		["holsters"] = "egm/custom_char/41st/jay/gear",
		["arc_gear_body"] = "egm/custom_char/41st/jay/gear",
		["arc_gear_legs"] = "egm/custom_char/41st/jay/gear",
		["arc_gear_arms"] = "egm/custom_char/41st/jay/gear",
		["pauldron_big"] = "egm/custom_char/41st/jay/gear",
		
		["pauldron"] = "egm/41st/trooper/specialist",
		["ammo_arm"] = "egm/41st/trooper/specialist",

		["strap"] = "egm/41st/trooper/heavy",
		["straps_double"] = "egm/41st/trooper/heavy",
		["straps_double_grenades"] = "egm/41st/trooper/heavy",
		["straps_double_datapad"] = "egm/41st/trooper/heavy",
		["strap"] = "egm/41st/trooper/heavy",
		["strap_grenades"] = "egm/41st/trooper/heavy",
		["strap_datapad"] = "egm/41st/trooper/heavy",
        ["ammo_shoulder"] = "egm/41st/trooper/heavy",
	})
	
	-- Jay ARF Helmet
		BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "41st_jay", "41st jay - Helmet", {
		["helmet_arf"] = "egm/custom_char/41st/jay/helmet_arf",
		["antenna_arf"] = "egm/core/helmet_arf/antenna_arf",
		["armor"] = "egm/41st/arf/armor_arf",

	})
end)
--lua/autorun/egm_mandalorian.lua:
-- Register the mandalorian material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.mandalorian", function()
	-- Mandalorian Purple
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_male/mando_male.mdl", "mando_purple", "Purple Mandalorian Armor", {
		["armor_parts"] = "egm/mandalorian/civilian/purple/armor_parts",
		["helmet"] = "egm/mandalorian/civilian/purple/helmet",
	})
	-- Mandalorian Purple Woman
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_female/mando_female.mdl", "mando_purple", "Purple Female Mandalorian Armor", {
		["armor_parts"] = "egm/mandalorian/civilian/purple/armor_parts",
		["helmet"] = "egm/mandalorian/civilian/purple/helmet",
	})
	-- Mandalorian Black
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_male/mando_male.mdl", "mando_black", "Black Mandalorian Armor", {
		["armor_parts"] = "egm/mandalorian/civilian/black/armor_parts",
		["helmet"] = "egm/mandalorian/civilian/black/helmet",
	})
	-- Mandalorian Black Woman
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_female/mando_female.mdl", "mando_black", "Black Female Mandalorian Armor", {
		["armor_parts"] = "egm/mandalorian/civilian/black/armor_parts",
		["helmet"] = "egm/mandalorian/civilian/black/helmet",
	})
	-- Mandalorian Blue
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_male/mando_male.mdl", "mando_blue", "Blue Mandalorian Armor", {
		["armor_parts"] = "egm/mandalorian/civilian/blue/armor_parts",
		["helmet"] = "egm/mandalorian/civilian/blue/helmet",
	})
	-- Mandalorian Blue Woman
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_female/mando_female.mdl", "mando_blue", "Blue Female Mandalorian Armor", {
		["armor_parts"] = "egm/mandalorian/civilian/blue/armor_parts",
		["helmet"] = "egm/mandalorian/civilian/blue/helmet",
	})
	-- Mandalorian Gold
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_male/mando_male.mdl", "mando_gold", "Gold Mandalorian Armor", {
		["armor_parts"] = "egm/mandalorian/civilian/gold/armor_parts",
		["helmet"] = "egm/mandalorian/civilian/gold/helmet",
	})
	-- Mandalorian Gold Woman
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_female/mando_female.mdl", "mando_gold", "Gold Female Mandalorian Armor", {
		["armor_parts"] = "egm/mandalorian/civilian/gold/armor_parts",
		["helmet"] = "egm/mandalorian/civilian/gold/helmet",
	})
	-- Mandalorian Green
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_male/mando_male.mdl", "mando_green", "Green Mandalorian Armor", {
		["armor_parts"] = "egm/mandalorian/civilian/green/armor_parts",
		["helmet"] = "egm/mandalorian/civilian/green/helmet",
	})
	-- Mandalorian Green Woman
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_female/mando_female.mdl", "mando_green", "Green Female Mandalorian Armor", {
		["armor_parts"] = "egm/mandalorian/civilian/green/armor_parts",
		["helmet"] = "egm/mandalorian/civilian/green/helmet",
	})
	-- Mandalorian Orange
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_male/mando_male.mdl", "mando_orange", "Orange Mandalorian Armor", {
		["armor_parts"] = "egm/mandalorian/civilian/orange/armor_parts",
		["helmet"] = "egm/mandalorian/civilian/orange/helmet",
	})
	-- Mandalorian Orange Woman
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_female/mando_female.mdl", "mando_orange", "Orange Female Mandalorian Armor", {
		["armor_parts"] = "egm/mandalorian/civilian/orange/armor_parts",
		["helmet"] = "egm/mandalorian/civilian/orange/helmet",
	})
	-- Mandalorian Red
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_male/mando_male.mdl", "mando_red", "Red Mandalorian Armor", {
		["armor_parts"] = "egm/mandalorian/civilian/red/armor_parts",
		["helmet"] = "egm/mandalorian/civilian/red/helmet",
	})
	-- Mandalorian Red Woman
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_female/mando_female.mdl", "mando_red", "Red Female Mandalorian Armor", {
		["armor_parts"] = "egm/mandalorian/civilian/red/armor_parts",
		["helmet"] = "egm/mandalorian/civilian/red/helmet",
	})
	-- Mandalorian White
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_male/mando_male.mdl", "mando_white", "White Mandalorian Armor", {
		["armor_parts"] = "egm/mandalorian/civilian/white/armor_parts",
		["helmet"] = "egm/mandalorian/civilian/white/helmet",
	})
	-- Mandalorian White Woman
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_female/mando_female.mdl", "mando_white", "White Female Mandalorian Armor", {
		["armor_parts"] = "egm/mandalorian/civilian/white/armor_parts",
		["helmet"] = "egm/mandalorian/civilian/white/helmet",
	})
	-- Mandalorian Bardan Jusik
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_male/mando_male.mdl", "bardanjusik_mando", "Bardan Jusik Mandalorian", {
		["armor_parts"] = "egm/mandalorian/seb/bardan_jusik/armor_parts",
		["helmet"] = "egm/mandalorian/seb/bardan_jusik/helmet",
	})
	-- Mandalorian Jetpack Black
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_jetpack/mando_jetpack.mdl", "mando_black", "Black Mandalorian Jetpack", {
		["jetpack_v2"] = "egm/mandalorian/civilian/black/jetpack_v2",
	})
	-- Mandalorian Jetpack Blue
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_jetpack/mando_jetpack.mdl", "mando_blue", "Blue Mandalorian Jetpack", {
		["jetpack_v2"] = "egm/mandalorian/civilian/blue/jetpack_v2",
	})
	-- Mandalorian Jetpack Gold
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_jetpack/mando_jetpack.mdl", "mando_gold", "Gold Mandalorian Jetpack", {
		["jetpack_v2"] = "egm/mandalorian/civilian/gold/jetpack_v2",
	})
	-- Mandalorian Jetpack Green
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_jetpack/mando_jetpack.mdl", "mando_green", "Green Mandalorian Jetpack", {
		["jetpack_v2"] = "egm/mandalorian/civilian/green/jetpack_v2",
	})
	-- Mandalorian Jetpack Orange
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_jetpack/mando_jetpack.mdl", "mando_orange", "Orange Mandalorian Jetpack", {
		["jetpack_v2"] = "egm/mandalorian/civilian/orange/jetpack_v2",
	})
	-- Mandalorian Jetpack Red
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_jetpack/mando_jetpack.mdl", "mando_red", "Red Mandalorian Jetpack", {
		["jetpack_v2"] = "egm/mandalorian/civilian/red/jetpack_v2",
	})
	-- Mandalorian Jetpack White
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_jetpack/mando_jetpack.mdl", "mando_white", "White Mandalorian Jetpack", {
		["jetpack_v2"] = "egm/mandalorian/civilian/white/jetpack_v2",
	})
	-- Mandalorian Jetpack Purple
	BaseModel:RegisterMaterialSet("models/egm/temp/mando_jetpack/mando_jetpack.mdl", "mando_purple", "Purple Mandalorian Jetpack", {
		["jetpack_v2"] = "egm/mandalorian/civilian/purple/jetpack_v2",
	})
end)
--lua/autorun/egm_silent.lua:
-- Register the Custom Char Silent Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.SWTSilent", function()
	-- Silent Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_synthmesh/clone_synthmesh.mdl", "swt_silent", "Silent Body", {
		["body"] = "egm/custom_char/swt/silent/body",
		["synthmesh"] = "egm/custom_char/swt/silent/synthmesh",

		["kama"] = "egm/custom_char/swt/silent/kama",

		["pauldron"] = "egm/custom_char/swt/silent/specialist",
		["ammo_chest"] = "egm/custom_char/swt/silent/specialist",
		["ammo_arm"] = "egm/custom_char/swt/silent/specialist",
		
		["antenna_shoulder"] = "egm/swt/attachment/antenna_shoulder",
		
		["holsters"] = "egm/custom_char/swt/silent/gear",
		["pockets"] = "egm/custom_char/swt/silent/gear",
	})
	-- Silent Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_synthmesh/helmet_synthmesh.mdl", "swt_silent", "Silent Helmet", {
		["helmet_synthmesh"] = "egm/custom_char/swt/silent/helmet",
		["flashlight"] = "egm/custom_char/swt/silent/helmet",
		["antenna_back"] = "egm/swt/attachment/helmet_equipment",
		["antenna_ear_big"] = "egm/swt/attachment/helmet_equipment",
	})
	-- Silent Backpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_utility/bp_utility.mdl", "swt_silent", "Silent Backpack", {
		["bp_utility"] = "egm/custom_char/swt/silent/backpack",
	})
end)
--lua/autorun/egm_spearhead.lua:
-- Register the Custom Char Spearhead Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.RMCSpearhead", function()
	-- Spearhead Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "rmc_spearhead", "RMC Spearhead - Armor", {
		["body"] = "egm/custom_char/rmc/spearhead/body",
		["body_mirrored"] = "egm/custom_char/rmc/spearhead/body",

		["kama"] = "egm/rmc/attachments/heavy",
		["kama_arc"] = "egm/custom_char/rmc/spearhead/kama_arc",

		["pauldron"] = "egm/rmc/attachments/specialist",
		["ammo_arm"] = "egm/rmc/attachments/specialist",
	})
	-- Spearhead Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "rmc_spearhead", "RMC Spearhead - Helmet", {
		["helmet"] = "egm/custom_char/rmc/spearhead/helmet",
		
		["sunvisor"] = "egm/rmc/attachments/heavy_red",
		["armor"] = "egm/rmc/attachments/heavy_red",
		
		["binoculars"] = "egm/rmc/attachments/specialist",
		["rangefinder"] = "egm/rmc/attachments/rangefinder",
	})
	-- Spearhead Helmet Airborne
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_airborne/helmet_airborne.mdl", "rmc_spearhead_airborne", "RMC Spearhead - Airborne Helmet", {
		["helmet_airborne"] = "egm/custom_char/rmc/spearhead/helmet_1",
		
		["sunvisor"] = "egm/rmc/attachments/heavy_red",
		
		["binoculars"] = "egm/rmc/attachments/specialist",
		["rangefinder"] = "egm/rmc/attachments/rangefinder",
	})

	-- Spearhead Jetpack
	BaseModel:RegisterMaterialSet("models/egm/core/bp_jetpack/bp_jetpack.mdl", "rmc_spearhead", "RMC Spearhead - Jetpack", {
		["bp_jetpack"] = "egm/custom_char/rmc/spearhead/jetpack",
	})
end)
--lua/autorun/egm_swt.lua:
-- Register the tactical engineering battalion material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.SWTTrooper", function()
	-- SWT Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "swt_trooper", "SWT Trooper - Armor", {
		["body"] = "egm/swt/haupteinheit/body",
		["body_mirrored"] = "egm/swt/haupteinheit/body",

		["antenna_shoulder"] = "egm/swt/attachment/antenna_shoulder",
		["antenna_back"] = "egm/swt/attachment/antenna_back",
		
		["kama"] = "egm/swt/attachment/heavy",
		["kama_arc"] = "egm/swt/attachment/kama_arc",
		
		["holsters"] = "egm/swt/attachment/gear",
		["pockets"] = "egm/swt/attachment/gear",
		
        ["pauldron"] = "egm/swt/attachment/specialist",
		["ammo_arm"] = "egm/swt/attachment/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "swt_trooper", "SWT Trooper - Helmet", {
		["helmet"] = "egm/swt/haupteinheit/helmet",

		["binoculars"] = "egm/swt/attachment/specialist",

		["sunvisor"] = "egm/swt/attachment/heavy",
		["armor"] = "egm/swt/attachment/heavy",
		
		["camera"] = "egm/swt/attachment/helmet_equipment",
		["antenna_back"] = "egm/swt/attachment/helmet_equipment",
		["antenna_ear_big"] = "egm/swt/attachment/helmet_equipment",
		
		["rangefinder"] = "egm/swt/attachment/rangefinder",
		
		["antenna_big"] = "egm/swt/attachment/antenna_big",
		["antenna_ear"] = "egm/swt/attachment/antenna_ear",
	})
	-- SWT Skelett
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "swt_skeleton", "SWT Skeleton - Armor", {
		["body"] = "egm/swt/haupteinheit/body2",
		["body_mirrored"] = "egm/swt/haupteinheit/body2",

		["antenna_shoulder"] = "egm/swt/attachment/antenna_shoulder",
		["antenna_back"] = "egm/swt/attachment/antenna_back",
		
		["kama"] = "egm/swt/attachment/heavy_grey",
		["kama_arc"] = "egm/swt/attachment/kama_arc_grey",
		
		["holsters"] = "egm/swt/attachment/gear",
		["pockets"] = "egm/swt/attachment/gear",
		
        ["pauldron"] = "egm/swt/attachment/specialist",
		["ammo_arm"] = "egm/swt/attachment/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "swt_skeleton", "SWT Skeleton - Helmet", {
		["helmet"] = "egm/swt/haupteinheit/helmet2",

		["binoculars"] = "egm/swt/attachment/specialist",

		["sunvisor"] = "egm/swt/attachment/heavy",
		["armor"] = "egm/swt/attachment/heavy",
		
		["camera"] = "egm/swt/attachment/helmet_equipment",
		["antenna_back"] = "egm/swt/attachment/helmet_equipment",
		["antenna_ear_big"] = "egm/swt/attachment/helmet_equipment",
		
		["rangefinder"] = "egm/swt/attachment/rangefinder",
		
		["antenna_big"] = "egm/swt/attachment/antenna_big",
		["antenna_ear"] = "egm/swt/attachment/antenna_ear",
	})
	-- SWT Devil
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "swt_devil", "SWT Devil - Armor", {
		["body"] = "egm/swt/haupteinheit/body3",
		["body_mirrored"] = "egm/swt/haupteinheit/body3",

		["antenna_shoulder"] = "egm/swt/attachment/antenna_shoulder",
		["antenna_back"] = "egm/swt/attachment/antenna_back",
		
		["kama"] = "egm/swt/attachment/heavy_red",
		["kama_arc"] = "egm/swt/attachment/kama_arc_red",
		
		["holsters"] = "egm/swt/attachment/gear",
		["pockets"] = "egm/swt/attachment/gear",
		
        ["pauldron"] = "egm/swt/attachment/specialist",
		["ammo_arm"] = "egm/swt/attachment/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "swt_devil", "SWT Devil - Helmet", {
		["helmet"] = "egm/swt/haupteinheit/helmet3",

		["binoculars"] = "egm/swt/attachment/specialist",

		["sunvisor"] = "egm/swt/attachment/heavy",
		["armor"] = "egm/swt/attachment/heavy",
		
		["camera"] = "egm/swt/attachment/helmet_equipment",
		["antenna_back"] = "egm/swt/attachment/helmet_equipment",
		["antenna_ear_big"] = "egm/swt/attachment/helmet_equipment",
		
		["rangefinder"] = "egm/swt/attachment/rangefinder",
		
		["antenna_big"] = "egm/swt/attachment/antenna_big",
		["antenna_ear"] = "egm/swt/attachment/antenna_ear",
	})
	-- SWT Sakral
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "swt_sacred", "SWT Sacred - Armor", {
		["body"] = "egm/swt/haupteinheit/body4",
		["body_mirrored"] = "egm/swt/haupteinheit/body4",

		["antenna_shoulder"] = "egm/swt/attachment/antenna_shoulder",
		["antenna_back"] = "egm/swt/attachment/antenna_back",
		
		["kama"] = "egm/swt/attachment/heavy_grey",
		["kama_arc"] = "egm/swt/attachment/kama_arc_grey",
		
		["holsters"] = "egm/swt/attachment/gear",
		["pockets"] = "egm/swt/attachment/gear",
		
        ["pauldron"] = "egm/swt/attachment/specialist",
		["ammo_arm"] = "egm/swt/attachment/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "swt_sacred", "SWT Sacred - Helmet", {
		["helmet"] = "egm/swt/haupteinheit/helmet4",

		["binoculars"] = "egm/swt/attachment/specialist",

		["sunvisor"] = "egm/swt/attachment/heavy",
		["armor"] = "egm/swt/attachment/heavy",
		
		["camera"] = "egm/swt/attachment/helmet_equipment",
		["antenna_back"] = "egm/swt/attachment/helmet_equipment",
		["antenna_ear_big"] = "egm/swt/attachment/helmet_equipment",
		
		["rangefinder"] = "egm/swt/attachment/rangefinder",
		
		["antenna_big"] = "egm/swt/attachment/antenna_big",
		["antenna_ear"] = "egm/swt/attachment/antenna_ear",
	})
	-- SWT RMC
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "swt_rmc", "SWT RMC - Armor", {
		["body"] = "egm/swt/haupteinheit/body5",
		["body_mirrored"] = "egm/swt/haupteinheit/body5",

		["antenna_shoulder"] = "egm/swt/attachment/antenna_shoulder",
		["antenna_back"] = "egm/swt/attachment/antenna_back",
		
		["kama"] = "egm/swt/attachment/heavy_red",
		["kama_arc"] = "egm/swt/attachment/kama_arc",
		
		["holsters"] = "egm/swt/attachment/gear",
		["pockets"] = "egm/swt/attachment/gear",
		
        ["pauldron"] = "egm/swt/attachment/specialist",
		["ammo_arm"] = "egm/swt/attachment/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "swt_rmc", "SWT RMC - Helmet", {
		["helmet"] = "egm/swt/haupteinheit/helmet5",

		["binoculars"] = "egm/swt/attachment/specialist",

		["sunvisor"] = "egm/swt/attachment/heavy",
		["armor"] = "egm/swt/attachment/heavy",
		
		["camera"] = "egm/swt/attachment/helmet_equipment",
		["antenna_back"] = "egm/swt/attachment/helmet_equipment",
		["antenna_ear_big"] = "egm/swt/attachment/helmet_equipment",
		
		["rangefinder"] = "egm/swt/attachment/rangefinder",
		
		["antenna_big"] = "egm/swt/attachment/antenna_big",
		["antenna_ear"] = "egm/swt/attachment/antenna_ear",
	})
	-- SWT TEB
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "swt_teb", "SWT TEB - Armor", {
		["body"] = "egm/swt/haupteinheit/body6",
		["body_mirrored"] = "egm/swt/haupteinheit/body6",

		["antenna_shoulder"] = "egm/swt/attachment/antenna_shoulder",
		["antenna_back"] = "egm/swt/attachment/antenna_back",
		
		["kama"] = "egm/swt/attachment/heavy",
		["kama_arc"] = "egm/swt/attachment/kama_arc_grey",
		
		["holsters"] = "egm/swt/attachment/gear",
		["pockets"] = "egm/swt/attachment/gear",
		
        ["pauldron"] = "egm/swt/attachment/specialist",
		["ammo_arm"] = "egm/swt/attachment/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "swt_teb", "SWT TEB - Helmet", {
		["helmet"] = "egm/swt/haupteinheit/helmet6",

		["binoculars"] = "egm/swt/attachment/specialist",

		["sunvisor"] = "egm/swt/attachment/heavy",
		["armor"] = "egm/swt/attachment/heavy",
		
		["camera"] = "egm/swt/attachment/helmet_equipment",
		["antenna_back"] = "egm/swt/attachment/helmet_equipment",
		["antenna_ear_big"] = "egm/swt/attachment/helmet_equipment",
		
		["rangefinder"] = "egm/swt/attachment/rangefinder",
		
		["antenna_big"] = "egm/swt/attachment/antenna_big",
		["antenna_ear"] = "egm/swt/attachment/antenna_ear",
	})
	-- SWT Veteran
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "swt_vet", "SWT Veteran - Armor", {
		["body"] = "egm/swt/veteran/body",
		["body_mirrored"] = "egm/swt/veteran/body",

		["antenna_shoulder"] = "egm/swt/attachment/antenna_shoulder",
		["antenna_back"] = "egm/swt/attachment/antenna_back",
		
		["kama"] = "egm/swt/attachment/heavy_red",
		["kama_arc"] = "egm/swt/attachment/kama_arc_red",
		
		["holsters"] = "egm/swt/attachment/gear",
		["pockets"] = "egm/swt/attachment/gear",
		
        ["pauldron"] = "egm/swt/attachment/specialist",
		["ammo_arm"] = "egm/swt/attachment/specialist",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "swt_vet", "SWT Veteran 1 - Helmet", {
		["helmet"] = "egm/swt/veteran/helmet",

		["binoculars"] = "egm/swt/attachment/specialist",

		["sunvisor"] = "egm/swt/attachment/heavy",
		["armor"] = "egm/swt/attachment/heavy",
		
		["camera"] = "egm/swt/attachment/helmet_equipment",
		["antenna_back"] = "egm/swt/attachment/helmet_equipment",
		["antenna_ear_big"] = "egm/swt/attachment/helmet_equipment",
		
		["rangefinder"] = "egm/swt/attachment/rangefinder",
		
		["antenna_big"] = "egm/swt/attachment/antenna_big",
		["antenna_ear"] = "egm/swt/attachment/antenna_ear",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "swt_vet2", "SWT Veteran 2 - Helmet", {
		["helmet"] = "egm/swt/veteran/helmet2",

		["binoculars"] = "egm/swt/attachment/specialist",

		["sunvisor"] = "egm/swt/attachment/heavy",
		["armor"] = "egm/swt/attachment/heavy",
		
		["camera"] = "egm/swt/attachment/helmet_equipment",
		["antenna_back"] = "egm/swt/attachment/helmet_equipment",
		["antenna_ear_big"] = "egm/swt/attachment/helmet_equipment",
		
		["rangefinder"] = "egm/swt/attachment/rangefinder",
		
		["antenna_big"] = "egm/swt/attachment/antenna_big",
		["antenna_ear"] = "egm/swt/attachment/antenna_ear",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "swt_pilot", "SWT Pilot - Helmet", {
		["helmet_pilot"] = "egm/swt/haupteinheit/helmet_pilot",
		["helmet_pilot_breath"] = "egm/swt/attachment/helmet_pilot_breath",
	})
	-- Backpacks und Sidebags
	BaseModel:RegisterMaterialSet("models/egm/core/backpack/backpack.mdl", "swt_trooper", "SWT Trooper - Backpack", {
		["backpack"] = "egm/swt/attachment/heavy",
	})
	BaseModel:RegisterMaterialSet("models/egm/core/sidebag/sidebag.mdl", "swt_trooper", "SWT Trooper - Sidebag", {
		["sidebag"] = "egm/swt/attachment/heavy",
	})
end)
--lua/autorun/egm_sylas.lua:
-- Register the CTP Custom Char Sylas Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.CTPSylas", function()
	-- Sylas Body
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "ctp_sylas", "CTP Sylas - Armor", {
        ["body"] = "egm/custom_char/ctp/sylas/body",
		["body_mirrored"] = "egm/custom_char/ctp/sylas/body_1",

		["kama_arc"] = "egm/custom_char/ctp/sylas/kama_arc",

		["pauldron_big"] = "egm/custom_char/ctp/sylas/gear",
    })
	-- Helmet Pilot
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_pilot/helmet_pilot.mdl", "ctp_sylas", "CTP Sylas Pilot - Helmet", {
		["helmet_pilot"] = "egm/custom_char/ctp/sylas/helmet",
	})
	-- Helmet ARF
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_arf/helmet_arf.mdl", "ctp_sylas_arf", "CTP Sylas ARF - Helmet", {
		["helmet_arf"] = "egm/custom_char/ctp/sylas/helmet_1",
	})
end)
--lua/autorun/egm_tommat.lua:
-- Register the 327th Custom Charakter Tommat Materials
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.327thTommat", function()
	-- Base Tommat Trooper
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "327th_tommat", "327th - Rasem Armor", {
		["body"] = "egm/custom_char/327th/tommat/body",
		["body_mirrored"] = "egm/custom_char/327th/tommat/body_2",

		["kama"] = "egm/327th_new/lore_char/bly/kama",

		["pauldron"] = "egm/327th_new/trooper/specialist",
		["pauldron_simple"] = "egm/327th_new/trooper/pauldron_simple",
	})
	-- 327th Trooper Helmet
	BaseModel:RegisterMaterialSet("models/egm/core/helmet_p2/helmet_p2.mdl", "327th_tommat", "327th - Rasem Helmet", {
		["helmet"] = "egm/custom_char/327th/tommat/helmet",
		["binoculars"] = "egm/327th_new/trooper/specialist",
	})
end)
--lua/autorun/egm_training.lua:
-- Register the navy material sets
hook.Add("BaseModel.RegisterMaterialSets", "EGM.CWRP.Training", function()
	-- Rekrut Uniform
	BaseModel:RegisterMaterialSet("models/egm/core/uniform/uniform.mdl", "recruit", "Recruit Uniform", {
		["body"] = "egm/training/recruit/body",
		["legs"] = "egm/training/recruit/legs",
	})

	-- Trainer Armor
	BaseModel:RegisterMaterialSet("models/egm/core/clone_armor/clone_armor.mdl", "trainer", "Trainer Armor", {
		["body"] = "egm/training/trainer/body",
		["body_mirrored"] = "egm/training/trainer/body",
	})
end)
--addons/playermodels/lua/autorun/eventpack_egm_cis.lua:
local function AddPlayerModel(name, model)
	list.Set("PlayerOptionsModel", name, model)
	player_manager.AddValidModel(name, model )
end

AddPlayerModel("General Grievous", 	"models/aussisengels/grievous/general_grievous.mdl")
player_manager.AddValidHands( "General Grievous", "models/aussisengels/grievous/general_grievous_hands.mdl",0,"10000000" )
AddPlayerModel( "Admiral Trench", 	"models/pm_admiral_trench.mdl" )
--addons/fprofiler/lua/fprofiler/cami.lua:
--[[
CAMI - Common Admin Mod Interface.
Makes admin mods intercompatible and provides an abstract privilege interface
for third party addons.

IMPORTANT: This is a draft script. It is very much WIP.

Follows the specification on this page:
https://docs.google.com/document/d/1QIRVcAgZfAYf1aBl_dNV_ewR6P25wze2KmUVzlbFgMI


Structures:
	CAMI_USERGROUP, defines the charactaristics of a usergroup:
	{
		Name
			string
			The name of the usergroup
		Inherits
			string
			The name of the usergroup this usergroup inherits from
	}

	CAMI_PRIVILEGE, defines the charactaristics of a privilege:
	{
		Name
			string
			The name of the privilege
		MinAccess
			string
			One of the following three: user/admin/superadmin
		HasAccess
			function(
				privilege :: CAMI_PRIVILEGE,
				actor     :: Player,
				target    :: Player
			) :: bool
			optional
			Function that decides whether a player can execute this privilege,
			optionally on another player (target).
	}
]]

-- Version number in YearMonthDay format.
local version = 20150902.1

if CAMI and CAMI.Version >= version then return end

CAMI = CAMI or {}
CAMI.Version = version

--[[
usergroups
	Contains the registered CAMI_USERGROUP usergroup structures.
	Indexed by usergroup name.
]]
local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
	user = {
		Name = "user",
		Inherits = "user"
	},
	admin = {
		Name = "admin",
		Inherits = "user"
	},
	superadmin = {
		Name = "superadmin",
		Inherits = "admin"
	}
}

--[[
privileges
	Contains the registered CAMI_PRIVILEGE privilege structures.
	Indexed by privilege name.
]]
local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}

--[[
CAMI.RegisterUsergroup
	Registers a usergroup with CAMI.

	Parameters:
		usergroup
			CAMI_USERGROUP
			(see CAMI_USERGROUP structure)
		source
			any
			Identifier for your own admin mod. Can be anything.
			Use this to make sure CAMI.RegisterUsergroup function and the
			CAMI.OnUsergroupRegistered hook don't cause an infinite loop



	Return value:
		CAMI_USERGROUP
			The usergroup given as argument.
]]
function CAMI.RegisterUsergroup(usergroup, source)
	usergroups[usergroup.Name] = usergroup

	hook.Call("CAMI.OnUsergroupRegistered", nil, usergroup, source)
	return usergroup
end

--[[
CAMI.UnregisterUsergroup
	Unregisters a usergroup from CAMI. This will call a hook that will notify
	all other admin mods of the removal.

	Call only when the usergroup is to be permanently removed.

	Parameters:
		usergroupName
			string
			The name of the usergroup.
		source
			any
			Identifier for your own admin mod. Can be anything.
			Use this to make sure CAMI.UnregisterUsergroup function and the
			CAMI.OnUsergroupUnregistered hook don't cause an infinite loop

	Return value:
		bool
			Whether the unregistering succeeded.
]]
function CAMI.UnregisterUsergroup(usergroupName, source)
	if not usergroups[usergroupName] then return false end

	local usergroup = usergroups[usergroupName]
	usergroups[usergroupName] = nil

	hook.Call("CAMI.OnUsergroupUnregistered", nil, usergroup, source)

	return true
end

--[[
CAMI.GetUsergroups
	Retrieves all registered usergroups.

	Return value:
		Table of CAMI_USERGROUP, indexed by their names.
]]
function CAMI.GetUsergroups()
	return usergroups
end

--[[
CAMI.GetUsergroup
	Receives information about a usergroup.

	Return value:
		CAMI_USERGROUP
			Returns nil when the usergroup does not exist.
]]
function CAMI.GetUsergroup(usergroupName)
	return usergroups[usergroupName]
end

--[[
CAMI.UsergroupInherits
	Returns true when usergroupName1 inherits usergroupName2.
	Note that usergroupName1 does not need to be a direct child.
	Every usergroup trivially inherits itself.

	Parameters:
		usergroupName1
			string
			The name of the usergroup that is queried.
		usergroupName2
			string
			The name of the usergroup of which is queried whether usergroupName1
			inherits from.

	Return value:
		bool
			Whether usergroupName1 inherits usergroupName2.
]]
function CAMI.UsergroupInherits(usergroupName1, usergroupName2)
	repeat
		if usergroupName1 == usergroupName2 then return true end

		usergroupName1 = usergroups[usergroupName1] and
						 usergroups[usergroupName1].Inherits or
						 usergroupName1
	until not usergroups[usergroupName1] or
		  usergroups[usergroupName1].Inherits == usergroupName1

	-- One can only be sure the usergroup inherits from user if the
	-- usergroup isn't registered.
	return usergroupName1 == usergroupName2 or usergroupName2 == "user"
end

--[[
CAMI.InheritanceRoot
	All usergroups must eventually inherit either user, admin or superadmin.
	Regardless of what inheritance mechism an admin may or may not have, this
	always applies.

	This method always returns either user, admin or superadmin, based on what
	usergroups eventually inherit.

	Parameters:
		usergroupName
			string
			The name of the usergroup of which the root of inheritance is
			requested

	Return value:
		string
			The name of the root usergroup (either user, admin or superadmin)
]]
function CAMI.InheritanceRoot(usergroupName)
	if not usergroups[usergroupName] then return end

	local inherits = usergroups[usergroupName].Inherits
	while inherits ~= usergroups[usergroupName].Inherits do
		usergroupName = usergroups[usergroupName].Inherits
	end

	return usergroupName
end

--[[
CAMI.RegisterPrivilege
	Registers a privilege with CAMI.
	Note: do NOT register all your admin mod's privileges with this function!
	This function is for third party addons to register privileges
	with admin mods, not for admin mods sharing the privileges amongst one
	another.

	Parameters:
		privilege
			CAMI_PRIVILEGE
			See CAMI_PRIVILEGE structure.

	Return value:
		CAMI_PRIVILEGE
			The privilege given as argument.
]]
function CAMI.RegisterPrivilege(privilege)
	privileges[privilege.Name] = privilege

	hook.Call("CAMI.OnPrivilegeRegistered", nil, privilege)

	return privilege
end

--[[
CAMI.UnregisterPrivilege
	Unregisters a privilege from CAMI. This will call a hook that will notify
	all other admin mods of the removal.

	Call only when the privilege is to be permanently removed.

	Parameters:
		privilegeName
			string
			The name of the privilege.

	Return value:
		bool
			Whether the unregistering succeeded.
]]
function CAMI.UnregisterPrivilege(privilegeName)
	if not privileges[privilegeName] then return false end

	local privilege = privileges[privilegeName]
	privileges[privilegeName] = nil

	hook.Call("CAMI.OnPrivilegeUnregistered", nil, privilege)

	return true
end

--[[
CAMI.GetPrivileges
	Retrieves all registered privileges.

	Return value:
		Table of CAMI_PRIVILEGE, indexed by their names.
]]
function CAMI.GetPrivileges()
	return privileges
end

--[[
CAMI.GetPrivilege
	Receives information about a privilege.

	Return value:
		CAMI_PRIVILEGE when the privilege exists.
			nil when the privilege does not exist.
]]
function CAMI.GetPrivilege(privilegeName)
	return privileges[privilegeName]
end

--[[
CAMI.PlayerHasAccess
	Queries whether a certain player has the right to perform a certain action.
	Note: this function does NOT return an immediate result!
	The result is in the callback!

	Parameters:
		actorPly
			Player
			The player of which is requested whether they have the privilege.
		privilegeName
			string
			The name of the privilege.
		callback
			function(bool, string)
			This function will be called with the answer. The bool signifies the
			yes or no answer as to whether the player is allowed. The string
			will optionally give a reason.
		targetPly
			Optional.
			The player on which the privilege is executed.
		extraInfoTbl
			Optional.
			Table containing extra information.
			Officially supported members:
				Fallback
					string
					Either of user/admin/superadmin. When no admin mod replies,
					the decision is based on the admin status of the user.
					Defaults to admin if not given.
				IgnoreImmunity
					bool
					Ignore any immunity mechanisms an admin mod might have.
				CommandArguments
					table
					Extra arguments that were given to the privilege command.

	Return value:
		None, the answer is given in the callback function in order to allow
		for the admin mod to perform e.g. a database lookup.
]]
-- Default access handler
local defaultAccessHandler = {["CAMI.PlayerHasAccess"] =
	function(_, actorPly, privilegeName, callback, _, extraInfoTbl)
		-- The server always has access in the fallback
		if not IsValid(actorPly) then return callback(true, "Fallback.") end

		local priv = privileges[privilegeName]

		local fallback = extraInfoTbl and (
			not extraInfoTbl.Fallback and actorPly:IsAdmin() or
			extraInfoTbl.Fallback == "user" and true or
			extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or
			extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())


		if not priv then return callback(fallback, "Fallback.") end

		callback(
			priv.MinAccess == "user" or
			priv.MinAccess == "admin" and actorPly:IsAdmin() or
			priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()
			, "Fallback.")
	end,
	["CAMI.SteamIDHasAccess"] =
	function(_, _, _, callback)
		callback(false, "No information available.")
	end
}
function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly,
extraInfoTbl)
	hook.Call("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly,
		privilegeName, callback, targetPly, extraInfoTbl)
end

--[[
CAMI.GetPlayersWithAccess
	Finds the list of currently joined players who have the right to perform a
	certain action.
	NOTE: this function will NOT return an immediate result!
	The result is in the callback!

	Parameters:
		privilegeName
			string
			The name of the privilege.
		callback
			function(players)
			This function will be called with the list of players with access.
		targetPly
			Optional.
			The player on which the privilege is executed.
		extraInfoTbl
			Optional.
			Table containing extra information.
			Officially supported members:
				Fallback
					string
					Either of user/admin/superadmin. When no admin mod replies,
					the decision is based on the admin status of the user.
					Defaults to admin if not given.
				IgnoreImmunity
					bool
					Ignore any immunity mechanisms an admin mod might have.
				CommandArguments
					table
					Extra arguments that were given to the privilege command.
]]
function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly,
extraInfoTbl)
	local allowedPlys = {}
	local allPlys = player.GetAll()
	local countdown = #allPlys

	local function onResult(ply, hasAccess, _)
		countdown = countdown - 1

		if hasAccess then table.insert(allowedPlys, ply) end
		if countdown == 0 then callback(allowedPlys) end
	end

	for _, ply in pairs(allPlys) do
		CAMI.PlayerHasAccess(ply, privilegeName,
			function(...) onResult(ply, ...) end,
			targetPly, extraInfoTbl)
	end
end

--[[
CAMI.SteamIDHasAccess
	Queries whether a player with a steam ID has the right to perform a certain
	action.
	Note: the player does not need to be in the server for this to
	work.

	Note: this function does NOT return an immediate result!
	The result is in the callback!

	Parameters:
		actorSteam
			Player
			The SteamID of the player of which is requested whether they have
			the privilege.
		privilegeName
			string
			The name of the privilege.
		callback
			function(bool, string)
			This function will be called with the answer. The bool signifies the
			yes or no answer as to whether the player is allowed. The string
			will optionally give a reason.
		targetSteam
			Optional.
			The SteamID of the player on which the privilege is executed.
		extraInfoTbl
			Optional.
			Table containing extra information.
			Officially supported members:
				IgnoreImmunity
					bool
					Ignore any immunity mechanisms an admin mod might have.
				CommandArguments
					table
					Extra arguments that were given to the privilege command.

	Return value:
		None, the answer is given in the callback function in order to allow
		for the admin mod to perform e.g. a database lookup.
]]
function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback,
targetSteam, extraInfoTbl)
	hook.Call("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam,
		privilegeName, callback, targetSteam, extraInfoTbl)
end

--[[
CAMI.SignalUserGroupChanged
	Signify that your admin mod has changed the usergroup of a player. This
	function communicates to other admin mods what it thinks the usergroup
	of a player should be.

	Listen to the hook to receive the usergroup changes of other admin mods.

	Parameters:
		ply
			Player
			The player for which the usergroup is changed
		old
			string
			The previous usergroup of the player.
		new
			string
			The new usergroup of the player.
		source
			any
			Identifier for your own admin mod. Can be anything.
]]
function CAMI.SignalUserGroupChanged(ply, old, new, source)
	hook.Call("CAMI.PlayerUsergroupChanged", nil, ply, old, new, source)
end

--[[
CAMI.SignalSteamIDUserGroupChanged
	Signify that your admin mod has changed the usergroup of a disconnected
	player. This communicates to other admin mods what it thinks the usergroup
	of a player should be.

	Listen to the hook to receive the usergroup changes of other admin mods.

	Parameters:
		ply
			string
			The steam ID of the player for which the usergroup is changed
		old
			string
			The previous usergroup of the player.
		new
			string
			The new usergroup of the player.
		source
			any
			Identifier for your own admin mod. Can be anything.
]]
function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
	hook.Call("CAMI.SteamIDUsergroupChanged", nil, steamId, old, new, source)
end

--addons/fprofiler/lua/fprofiler/util.lua:

-- Try to find the function represented by a string
function FProfiler.funcNameToObj(str)
	if isfunction(str) then return str end

	local times = FProfiler.Internal.getCallCounts()
	for func, _ in pairs(times) do
		if tostring(func) == str then return func end
	end

	local tbl = _G
	local exploded = string.Explode(".", str, false)
	if not exploded or not exploded[1] then return end

	for i = 1, #exploded - 1 do
		tbl = (tbl or {})[exploded[i]]
		if not istable(tbl) then return end
	end

	local func = (tbl or {})[exploded[#exploded]]

	if not isfunction(func) then return end

	return func
end

-- Read a file
function FProfiler.readSource(fname, startLine, endLine)
	if not file.Exists(fname, "GAME") then return "" end
	if startLine < 0 or endLine < 0 or endLine < startLine then return "" end

	local f = file.Open(fname, "r", "GAME")

	for i = 1, startLine - 1 do f:ReadLine() end

	local res = {}
	for i = startLine, endLine do
		table.insert(res, f:ReadLine() or "")
	end

	return table.concat(res, "\n")
end

--lua/autorun/glowsticks_sound.lua:
sound.Add(
{
    name = "Glowstick.Shake",
    channel = CHAN_USER_BASE+1,
    volume = 1.0,
    soundlevel = SNDLVL_IDLE,
    sound = "glowstick/glowstick_shake.wav"
})
sound.Add(
{
    name = "Glowstick.Snap",
    channel = CHAN_USER_BASE+1,
    volume = 1.0,
    soundlevel = SNDLVL_IDLE,
    sound = "glowstick/glowstick_snap.wav"
})
--addons/gm_express/lua/gm_express/sh_helpers.lua:
AddCSLuaFile()
express.version = 1
express.revision = 1
express._putCache = {}
express._maxCacheTime = ( 24 - 1 ) * 60 * 60 -- TODO: Get this from the server, similar to the version check
express._waitingForAccess = {}
express.domain = CreateConVar(
    "express_domain", "gmod-express.einfach-gaming.de", FCVAR_ARCHIVE + FCVAR_REPLICATED, "The domain of the Express server"
)

-- Useful for self-hosting if you need to set express_domain to localhost
-- and direct clients to a global IP/domain to hit the same service
express.domain_cl = CreateConVar(
    "express_domain_cl", "", FCVAR_ARCHIVE + FCVAR_REPLICATED, "The client-specific domain of the Express server. If empty, express_domain will be used."
)

express.sendDelay = CreateConVar(
    "express_send_delay", 0.15, FCVAR_ARCHIVE + FCVAR_REPLICATED, "How long to wait (in seconds) before sending the Express Message ID to the recipient (longer delays will result in increased reliability)"
)


-- Runs the correct net Send function based on the realm --
function express.shSend( target )
    if CLIENT then
        net.SendToServer()
    else
        net.Send( target )
    end
end


-- Returns the correct domain based on the realm and convars --
function express:getDomain()
    local domain = self.domain:GetString()
    if SERVER then return domain end

    local clDomain = self.domain_cl:GetString()
    if clDomain ~= "" then return clDomain end

    return domain
end


-- Creates the base of the API URL from the protocol, domain, and version --
function express:makeBaseURL()
    local protocol = self._protocol
    local domain = self:getDomain()
    return string.format( "%s://%s/v%d", protocol, domain, self.version )
end


-- Creates a full URL with the given access token --
function express:makeAccessURL( action, ... )
    local url = self:makeBaseURL()
    local args = { action, self.access,  ... }

    return url .. "/" .. table.concat( args, "/" )
end


-- Sets the access token and runs requests that were waiting --
function express:SetAccess( access )
    self.access = access

    local waiting = self._waitingForAccess
    for _, callback in ipairs( waiting ) do
        callback()
    end

    self._waitingForAccess = {}
end


-- Checks the version of the API and alerts of a mismatch --
function express.CheckRevision()

    local suffix = " on version check! This is bad!"
    local err = function( msg )
        return "Express: " .. msg .. suffix
    end

    local url = express:makeBaseURL() .. "/revision"
    local success = function( body, _, _, code )
        assert( code >= 200 and code < 300, err( "Invalid response code (" .. code .. ")" ) )

        local dataHolder = util.JSONToTable( body )
        assert( dataHolder, err( "Invalid JSON response" ) )

        local revision = dataHolder.revision
        assert( revision, err( "Invalid JSON response" ) )

        local current = express.revision
        if revision ~= current then
            error( err( "Revision mismatch! Expected " .. current .. ", got " .. revision ) )
        end
    end

    http.Fetch( url, success, function( message )
        error( err( message ) )
    end, express.jsonHeaders )
end


-- Runs the main :Get function, or queues the request if no access token is set --
function express:_get( id, cb )
    if self.access then
        return self:Get( id, cb )
    end

    table.insert( self._waitingForAccess, function()
        self:Get( id, cb )
    end )
end


-- Runs the main :GetSize function, or queues the request if no access token is set --
-- FIXME: If this gets delayed because it doesn't have an access token, the PreDl Receiver will not be able to stop the download --
function express:_getSize( id, cb )
    if self.access then
        return self:GetSize( id, cb )
    end

    table.insert( self._waitingForAccess, function()
        self:GetSize( id, cb )
    end )
end


---Encodes and compresses the given data, then sends it to the API if not already cached
function express:_put( data, cb )
    if table.Count( data ) == 0 then
        error( "Express: Tried to send empty data!" )
    end

    data = pon.encode( data )

    if string.len( data ) > self._maxDataSize then
        data = "<enc>" .. util.Compress( data )
        assert( data, "Express: Failed to compress data!" )

        local dataLen = string.len( data )
        if dataLen > self._maxDataSize then
            error( "Express: Data too large (" .. dataLen .. " bytes)" )
        end
    end

    local hash = util.SHA1( data )

    local cached = self._putCache[hash]
    if cached then
        local cachedAt = cached.cachedAt

        if os.time() <= ( cachedAt + self._maxCacheTime ) then
            -- Force the callback to run asynchronously for consistency
            timer.Simple( 0, function()
                cb( cached.id, hash )
            end )

            return
        end
    end

    local function wrapCb( id )
        self._putCache[hash] = { id = id, cachedAt = os.time() }
        cb( id, hash )
    end

    if self.access then
        return self:Put( data, wrapCb )
    end

    table.insert( self._waitingForAccess, function()
        self:Put( data, wrapCb )
    end )
end


-- TODO: Fix GLuaTest so we can actually test this function...
-- Creates a contextual callback for the :_put endpoint, delaying the notification to the recipient(s) --
function express:_putCallback( message, plys, onProof )
    return function( id, hash )
        if onProof then
            self:SetExpected( hash, onProof, plys )
        end

        -- Cloudflare isn't fulfilling their promise that the first lookup in
        -- each region will "search" for the target key in K/V if it has't been cached yet.
        -- This delay makes it more likely that the data will have "settled" into K/V before the first lookup
        -- (Once it's cached as a 404, it'll stay that way for about 60 seconds)
        timer.Simple( self.sendDelay:GetFloat(), function()
            net.Start( "express" )
            net.WriteString( message )
            net.WriteString( id )
            net.WriteBool( onProof ~= nil )

            express.shSend( plys )
        end )
    end
end


-- Calls the _put function with a contextual callback --
function express:_send( message, data, plys, onProof )
    self:_put( data, self:_putCallback( message, plys, onProof ) )
end


-- Assigns a callback to the given message --
function express:_setReceiver( message, cb )
    message = string.lower( message )
    self._receivers[message] = cb
end


-- Returns the receiver set for the given message --
function express:_getReceiver( message )
    message = string.lower( message )
    return self._receivers[message]
end


-- Returns the pre-download receiver set for the given message --
function express:_getPreDlReceiver( message )
    message = string.lower( message )
    return self._preDlReceivers[message]
end


-- Returns a realm-specific timeout value for HTTP requests --
function express:_getTimeout()
    return CLIENT and 240 or 60
end


-- Ensures that the given HTTP response code indicates a succcessful request --
function express._checkResponseCode( code )
    local isOk = isnumber( code ) and code >= 200 and code < 300
    if isOk then return end

    error( "Express: Invalid response code (" .. tostring( code ) .. ")" )
end


-- Attempts to re-register with the new domain, and then verifies its version --
cvars.AddChangeCallback( "express_domain", function()
    express._putCache = {}

    if SERVER then express:Register() end

    express:CheckRevision()
end, "domain_check" )

-- Both client and server should check the version on startup so that errors are caught early --
cvars.AddChangeCallback( "express_domain_cl", function( _, _, new )
    if CLIENT then express._putCache = {} end
    if new == "" then return end

    express:CheckRevision()
end, "domain_check" )


hook.Add( "ExpressLoaded", "Express_HTTPInit", function()
    hook.Add( "Tick", "Express_RevisionCheck", function()
        hook.Remove( "Tick", "Express_RevisionCheck" )
        if SERVER then express:Register() end
        express:CheckRevision()
    end )
end )

--addons/gtawards/lua/gtawards/client/cl_main.lua:
--------------------------------------
--     GTawards (c) 2015 - 2020     --
--                                  --
--  Created by Jakob 'ibot3' Müller --
--   and Pascal 'P4sca1' Sthamer    --
--									--
--  You are not permitted to share, --
--   	trade, give away, sell 		--
--      or otherwise distribute 	--
--------------------------------------

surface.CreateFont("GTawards.TopBar", {
	font = "Default",
	size = ScreenScale(8)
})

surface.CreateFont("GTawards.BottomBar", {
	font = "Default",
	size = ScreenScale(6)
})

GTawards.Color1 = Color(46, 46, 46, 255)   	   --background
GTawards.Color2 = Color(18, 132, 170)		   --bar
GTawards.Color3 = Color(128, 128, 128, 255)    --foreground
GTawards.Color4 = Color(96, 96, 96, 255)       --settings tab: darker foreground
GTawards.TextColor = Color(255, 255, 255, 255) --text color

GTawards.TimePanel = GTawards.TimePanel or {}
GTawards.TimePanel.Settings = GTawards.TimePanel.Setings or {}
GTawards.Ranks = GTawards.Ranks or {}

function GTawards.TimePanel:Initialize()
	if #table.GetKeys(GTawards.TimePanel.Settings) == 0 then return end

	-- Make sure xsize is not greater than 1.
	if tonumber(GTawards.TimePanel.Settings["xsize"]) > 1 then
		GTawards.TimePanel.Settings["xsize"] = 1
	end
	
	-- Cache settings (panel is updated when settings change).
	local xsize = ScrW() * tonumber(GTawards.TimePanel.Settings["xsize"])
	local ysize = ScrH() * 0.06

	local xpadding = GTawards.TimePanel.Settings["xpadding"]
	local ypadding = GTawards.Settings["ypadding"]

	local xpadding = GTawards.TimePanel.Settings["xpadding"]
	local ypadding = GTawards.TimePanel.Settings["ypadding"]

	local xrelative = GTawards.TimePanel.Settings["xrelative"]
	local yrelative = GTawards.TimePanel.Settings["yrelative"]

	local cornerRadius = tonumber(GTawards.TimePanel.Settings["cornerRadius"])

	local xpos = 0
	local ypos = 0

	if xrelative == "right" and yrelative == "top" then
		xpos = ScrW() - xsize - xpadding
		ypos = ypadding
	elseif xrelative == "right" and yrelative == "bottom" then
		xpos = ScrW() - xsize - xpadding
		ypos = ScrH() - ysize - ypadding
	elseif xrelative == "left" and yrelative == "top" then
		xpos = xpadding
		ypos = ypadding
	elseif xrelative == "left" and yrelative == "bottom" then
		xpos = xpadding
		ypos = ScrH() - ysize - ypadding
	end

	local onlyShowOnScoreboard = tobool(GTawards.TimePanel.Settings["onlyShowOnScoreboard"])

	local barColor = string.ToColor(string.Replace(tostring(GTawards.TimePanel.Settings["barColor"]), ",", ""))
	local bgColorTop = string.ToColor(string.Replace(tostring(GTawards.TimePanel.Settings["bgColorTop"]), ",", ""))
	local bgColorBot = string.ToColor(string.Replace(tostring(GTawards.TimePanel.Settings["bgColorBot"]), ",", ""))
	local fontColorTop = string.ToColor(string.Replace(tostring(GTawards.TimePanel.Settings["fontColorTop"]), ",", ""))
	local fontColorBot = string.ToColor(string.Replace(tostring(GTawards.TimePanel.Settings["fontColorBot"]), ",", ""))

	local sessionTimeEnabled = tobool(GTawards.TimePanel.Settings["sessionTime"])
	local hideBar = tobool(GTawards.TimePanel.Settings["hideBar"])

	-- Cache ranks and reachedMaxRank (panel is updated when ranks change).
	local currentRank = GTawards.Ranks[1]
	local nextRank = GTawards.Ranks[2] or false
	local reachedMaxRank = false
	local timeBetweenRanks = 0

	if !nextRank then
		reachedMaxRank = true
	else
		timeBetweenRanks = nextRank["time"] - currentRank["time"]
	end

	-- Create time panel if it does not exist already.
	if !IsValid(GTawards.TimePanel.Panel) then
		GTawards.TimePanel.Panel = vgui.Create("DPanel")
		GTawards.TimePanel.Panel:SetAlpha(0)
		GTawards.TimePanel.Panel:SetMouseInputEnabled(false)
		GTawards.TimePanel.Panel:SetKeyBoardInputEnabled(false)
		GTawards.TimePanel.Panel:SetDrawBackground(false)
	end

	-- Set the correct position and size.
	GTawards.TimePanel.Panel:SetPos(xpos, ypos)
	GTawards.TimePanel.Panel:SetSize(xsize, ysize)

	-- Make sure panel is visible when onlyShowOnScoreboard is false.
	if !onlyShowOnScoreboard then
		GTawards.TimePanel.Panel:AlphaTo(255, 0, 0)
	end

	-- Cache time and progress (updated every second).
	local currentTime
	local formattedCurrentTime
	local formattedSessionTime
	local formattedTimeLeft
	local percentage = 1
	local nextTimeUpdate = 0
	local textTopBar

	-- Paint the time panel.
	function GTawards.TimePanel.Panel:Paint(w, h)
		-- Recalculate variables that depend on time every second.
		local curTime = CurTime()
		if (curTime >= nextTimeUpdate) then
			currentTime = LocalPlayer():GT_GetTime()
			formattedCurrentTime = GTawards:ConvertTime(currentTime, "fullstring")
			formattedSessionTime = GTawards:ConvertTime(LocalPlayer():GT_GetSessionTime(), "string")

			if !reachedMaxRank then 
				formattedTimeLeft = GTawards:ConvertTime(math.max(nextRank["time"] - currentTime, 0), "string")
				percentage = math.min((currentTime - currentRank["time"]) / timeBetweenRanks, 1)
				textTopBar = GTawards:Translate("timepanel.time_left", formattedTimeLeft, nextRank.name)
			else
				textTopBar = GTawards:Translate("timepanel.reached_max_rank", currentRank.name)
			end
			
			nextTimeUpdate = curTime + 1
		end

		-- Top bar
		if !hideBar then
			draw.RoundedBox(cornerRadius, 0, 0, w, h * 0.55, bgColorTop)
			draw.RoundedBox(cornerRadius, 0, 0, w * percentage, h * 0.55, barColor)

			draw.SimpleText(
				textTopBar,
				"GTawards.TopBar",
				w * 0.5,
				h * 0.28,
				fontColorTop,
				TEXT_ALIGN_CENTER,
				TEXT_ALIGN_CENTER
			)
		end

		-- Bottom bar
		draw.RoundedBox(cornerRadius, 0, h * 0.65, w, h * 0.35, bgColorBot)
		if sessionTimeEnabled then
			draw.SimpleText(
				currentRank.name .. " | " .. formattedCurrentTime .. " (" .. formattedSessionTime .. ")",
				"GTawards.BottomBar",
				w * 0.5,
				h * 0.825,
				fontColorBot,
				TEXT_ALIGN_CENTER,
				TEXT_ALIGN_CENTER
			)
		else
			draw.SimpleText(
				currentRank.name .. " | " .. formattedCurrentTime,
				"GTawards.BottomBar",
				w * 0.5,
				h * 0.825,
				fontColorBot,
				TEXT_ALIGN_CENTER,
				TEXT_ALIGN_CENTER
			)
		end
	end

	-- Override hooks.
	if Vliss then
		hook.Add("Think", "GTawards.VlissCompatibility", function()
			if onlyShowOnScoreboard and not GTawards.AdminMenu then
				if IsValid(GetScoreboardPanel()) and GetScoreboardPanel():IsVisible() then
					GTawards.TimePanel.Panel:AlphaTo(255, 0, 0)
				else
					GTawards.TimePanel.Panel:AlphaTo(0, 0, 0)
				end
			end
		end)
	else
		hook.Add("ScoreboardShow", "GTawards.ScoreboardShow", function()
			if onlyShowOnScoreboard then
				GTawards.TimePanel.Panel:AlphaTo(255, 0.1, 0)
			end
		end)

		hook.Add("ScoreboardHide", "GTawards.ScoreboardHide", function()
			if onlyShowOnScoreboard then
				GTawards.TimePanel.Panel:AlphaTo(0,0.1,0)
			end
		end)
	end
end

-- Convenience alias. Re-initializes the panel, which updates settings, currentRank and nextRank.
-- Note that the currentTime and session is always up to date.
GTawards.TimePanel.Update = GTawards.TimePanel.Initialize

net.Receive("GTawards.InitializePlayer", function()
	GTawards.TimePanel.Settings = net.ReadTable()
	GTawards.Ranks = net.ReadTable() -- [1] = currentRank, [2] = nextRank
	GTawards.TimePanel:Initialize()

	local players = net.ReadTable()
	for k, data in pairs(players) do
		local ply = player.GetBySteamID64(data.steamId64)
		if IsValid(ply) then
			ply.GT_Time = data.time
			ply.GT_SessionTime = data.sessionTime
			ply.GT_LastTimeSync = os.time()
		end
	end
end)

net.Receive("GTawards.SyncTimePanelSettings", function()
	GTawards.TimePanel.Settings = net.ReadTable()
	GTawards.TimePanel:Update()
end)


net.Receive("GTawards.SyncPlayerRanks", function()
	GTawards.Ranks = net.ReadTable() -- [1] = currentRank, [2] = nextRank
	GTawards.TimePanel:Update()
end)

net.Receive("GTawards.SyncPlayerTime", function()
	local steamId64 = net.ReadString()
	local time = net.ReadInt(32)
	local sessionTime = net.ReadInt(32)

	local ply = player.GetBySteamID64(steamId64)
	if IsValid(ply) then
		ply.GT_Time = time
		ply.GT_SessionTime = sessionTime
		ply.GT_LastTimeSync = os.time()

		if ply == LocalPlayer() then
			GTawards.TimePanel:Update()
		end
	end
end)

hook.Add("InitPostEntity", "GTawardsInitialize", function()
	net.Start("GTawards.InitializePlayer")
	net.SendToServer()
end)
--addons/gtawards/lua/gtawards/client/cl_admin_main.lua:
--------------------------------------
--     GTawards (c) 2015 - 2020     --
--                                  --
--  Created by Jakob 'ibot3' Müller --
--   and Pascal 'P4sca1' Sthamer    --
--									--
--  You are not permitted to share, --
--   	trade, give away, sell 		--
--      or otherwise distribute 	--
--------------------------------------

GTawards.AdminMenu = false

net.Receive("GTawards.FetchServers", function()
	GTawards.Servers = net.ReadTable()
end)

local function GetAllSteamIDs()
	local steamids = {}

	for k, ply in pairs(player.GetHumans()) do
		steamids[#steamids+1] = ply:SteamID64()
	end

	return steamids
end

function GTawards:AdminMenu_Open()
	GTawards.AdminMenu = true

	if IsValid(GTawards.TimePanel.Panel) then
		GTawards.TimePanel.Panel:AlphaTo(255, 0.1, 0)
	end

	--DO NOT MODIFY THESE VALUES. THE PANEL IS NOT OPTIMISED FOR OTHER SIZES!
	local xsize = 400
	local ysize = 300
	local xpos  = ScrW()/2 - xsize/2
	local ypos  = ScrH()/2 - ysize/2
	local title = "GTawards - Admin  ::  Developed by ibot3 and P4sca1" -- {{ user_id | 25 }
	local xpadding = 30 

	local adminMenu = vgui.Create("DFrame")
	adminMenu:SetSize(xsize, ysize)
	adminMenu:SetPos(xpos, ypos)
	adminMenu:SetDraggable(true)
	adminMenu:SetTitle(title)
	function adminMenu:Paint(w, h)
		draw.RoundedBox(0, 0, 0, w, 24, GTawards.Color2)
		draw.RoundedBox(0, 0, 24, w, h - 24, GTawards.Color1)
		draw.RoundedBox(0, 10, 60, 8, h-73, GTawards.Color3)
	end

	function adminMenu:OnClose()
		GTawards.AdminMenu = false

		if tobool(GTawards.TimePanel.Settings["onlyShowOnScoreboard"]) then
			if IsValid(GTawards.TimePanel.Panel) then
				GTawards.TimePanel.Panel:AlphaTo(0, 0.1, 0)
			end
		end
	end

	local adminMenu_Sheet = vgui.Create("DPropertySheet", adminMenu)
	adminMenu_Sheet:DockMargin(5, 3, 0, 0)
	adminMenu_Sheet:Dock( FILL )
	function adminMenu_Sheet:Think()
		for k, v in pairs(adminMenu_Sheet.Items) do
			if !v.Tab then continue end
			v.Tab:SetTextColor(GTawards.TextColor)
			if adminMenu_Sheet:GetActiveTab() == v.Tab then
				function v.Tab:Paint(w, h)
					draw.RoundedBox(0, 0, 0, w-4.6, h, GTawards.Color3)
				end
			else
				function v.Tab:Paint(w, h)
					draw.RoundedBox(0, 0, 0, w-4.6, h, GTawards.Color1)
				end
			end
		end
	end
	function adminMenu_Sheet.Paint()
	end	

	local adminMenu_Ranks = vgui.Create("DPanel", adminMenu_Sheet)
	function adminMenu_Ranks:Paint(w, h)
		draw.RoundedBox(0, 0, 0, w, h, GTawards.Color3)
	end
	adminMenu_Sheet:AddSheet( "Ranks", adminMenu_Ranks, "icon16/medal_gold_1.png" )

	local adminMenu_Players = vgui.Create("DPanel", adminMenu_Sheet)
	function adminMenu_Players:Paint(w, h)
		draw.RoundedBox(0, 0, 0, w, h, GTawards.Color3)
 	end
	adminMenu_Sheet:AddSheet( "Players", adminMenu_Players, "icon16/user.png" )

	local adminMenu_OfflinePlayers = vgui.Create("DPanel", adminMenu_Sheet)
	function adminMenu_OfflinePlayers:Paint(w, h)
		draw.RoundedBox(0, 0, 0, w, h, GTawards.Color3)
 	end
	adminMenu_Sheet:AddSheet( "Search Player", adminMenu_OfflinePlayers, "icon16/magnifier.png" )

	local adminMenu_Settings = vgui.Create("DPanel", adminMenu_Sheet)
	function adminMenu_Settings:Paint(w, h)
		draw.RoundedBox(0, 0, 0, w, h, GTawards.Color3)
 	end
	adminMenu_Sheet:AddSheet( "Settings", adminMenu_Settings, "icon16/wrench.png" )



	----------------------------------------------------------------------
	----------------------------------RANKS-------------------------------
	----------------------------------------------------------------------
	local adminMenu_AddRank = vgui.Create("DImageButton", adminMenu_Ranks)
	adminMenu_AddRank:SetPos(345, 4)
	adminMenu_AddRank:SetSize(16, 16)
	adminMenu_AddRank:SetImage("icon16/group_add.png")
	function adminMenu_AddRank:DoClick()
		local main = vgui.Create("DFrame")
		main:SetSize(250, 220) 
		main:SetPos(ScrW()/2 - 125, ScrH()/2 - 110)
		main:SetDraggable(true)
		main:ShowCloseButton(false)
		main:SetTitle("Create new Group")
		function main.Paint()
			draw.RoundedBox(0, 0, 0, 250, 24, GTawards.Color2)
			draw.RoundedBox(0, 0, 24, 250, 276, GTawards.Color1)
		end

		local nameLabel = vgui.Create("DLabel", main)
		nameLabel:SetPos(10, 30)
		nameLabel:SetTextColor(GTawards.TextColor)
		nameLabel:SetText("Name of the group:")	
		nameLabel:SizeToContents()

		local nameEntry = vgui.Create("DTextEntry", main)
		nameEntry:SetPos(10, 50)
		nameEntry:SetSize(230, 20)
		nameEntry:RequestFocus()

		local weeksLabel = vgui.Create("DLabel", main)
		weeksLabel:SetPos(10, 90)
		weeksLabel:SetTextColor(GTawards.TextColor)
		weeksLabel:SetText("Weeks:")
		weeksLabel:SizeToContents()

		local daysLabel = vgui.Create("DLabel", main)
		daysLabel:SetPos(70, 90)
		daysLabel:SetTextColor(GTawards.TextColor)
		daysLabel:SetText("Days:")
		daysLabel:SizeToContents()

		local hourslabel = vgui.Create("DLabel", main)
		hourslabel:SetPos(130,90)
		hourslabel:SetTextColor(GTawards.TextColor)
		hourslabel:SetText("Hours:")
		hourslabel:SizeToContents()

		local minutesLabel = vgui.Create("DLabel", main)
		minutesLabel:SetPos(190,90)
		minutesLabel:SetTextColor(GTawards.TextColor)
		minutesLabel:SetText("Minutes:")
		minutesLabel:SizeToContents()

		local weeksEntry = vgui.Create("DNumberWang", main)
		weeksEntry:SetPos(10, 110)
		weeksEntry:SetSize(50, 20)
		weeksEntry:SetMinMax(0, 24000)

		local daysEntry = vgui.Create("DNumberWang", main)
		daysEntry:SetPos(70, 110)
		daysEntry:SetSize(50, 20)
		daysEntry:SetMinMax(0, 24000)

		local hoursEntry = vgui.Create("DNumberWang", main)
		hoursEntry:SetPos(130, 110)
		hoursEntry:SetSize(50, 20)
		hoursEntry:SetMinMax(0, 24)

		local minutesEntry = vgui.Create("DNumberWang", main)
		minutesEntry:SetPos(190, 110)
		minutesEntry:SetSize(50, 20)
		minutesEntry:SetMinMax(0, 60)

		local actionsLabel = vgui.Create("DLabel", main)
		actionsLabel:SetPos(10, 140)
		actionsLabel:SetTextColor(Color(255,255,255,255))
		actionsLabel:SetText(" Edit actions:\n right-click - edit - actions\n after creating the group")
		actionsLabel:SizeToContents()

		local submit = vgui.Create("DButton", main)
		submit:SetPos(10, 190)
		submit:SetSize(80, 20)
		submit:SetTextColor(Color(255, 255, 255, 255))
		submit:SetText("Submit")
		function submit:Paint(w, h)
			draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
		end
		function submit:DoClick()
			local weeks	  = weeksEntry:GetValue()
			local days    = daysEntry:GetValue()
			local hours   = hoursEntry:GetValue()
			local minutes = minutesEntry:GetValue()
			local seconds = weeks*7*24*60*60 + days*24*60*60 + hours*60*60 + minutes*60

			net.Start("GTawards.AddRank")
				net.WriteString(nameEntry:GetValue())
				net.WriteInt(seconds, 32)
			net.SendToServer()

			timer.Simple(0.5, function()
				net.Start("GTawards.FetchRanks")
				net.SendToServer()
			end)

			main:Close()
		end

		local cancel = vgui.Create("DButton", main)
		cancel:SetPos(160, 190)
		cancel:SetSize(80, 20)
		cancel:SetTextColor(Color(255, 255, 255, 255))
		cancel:SetText("Cancel")
		function cancel:Paint(w, h)
			draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
		end
		function cancel:DoClick()
			main:Close()
		end

		main:MakePopup()
	end

	local adminMenu_RankList_Refresh = vgui.Create("DImageButton", adminMenu_Ranks)
	adminMenu_RankList_Refresh:SetPos(320, 4)
	adminMenu_RankList_Refresh:SetSize(16,16)
	adminMenu_RankList_Refresh:SetImage("icon16/arrow_refresh.png")
	function adminMenu_RankList_Refresh:DoClick()
		net.Start("GTawards.FetchRanks")
		net.SendToServer()
	end

	local adminMenu_RankList = vgui.Create("DListView", adminMenu_Ranks)
	adminMenu_RankList:DockMargin(0, 25, 5, 5)
	adminMenu_RankList:Dock(FILL)
	adminMenu_RankList:SetMultiSelect(false)
	adminMenu_RankList:AddColumn("ID", _, 1):SetWidth(30)
	adminMenu_RankList:AddColumn("Name", _, 2)
	adminMenu_RankList:AddColumn("Time", _, 3)
	adminMenu_RankList:AddColumn("_seconds", _, 4):SetFixedWidth(0)
	--function adminMenu_RankList:Paint(w, h)
	--end
	--COLUMN PAINTING 

	net.Receive("GTawards.FetchRanks", function()
		local ranks = net.ReadTable()
		adminMenu_RankList:Clear()
		for k, v in pairs(ranks) do
			adminMenu_RankList:AddLine(k, v["name"], GTawards:ConvertTime(v["time"], "fullstring"), tonumber(v["time"]))
		end
		adminMenu_RankList:SortByColumn(4, false)
	end)

	function adminMenu_RankList:OnRowRightClick(index, row)
		local dermaMenu = DermaMenu()
		local edit, menuimg = dermaMenu:AddSubMenu("Edit")
		menuimg:SetImage("icon16/pencil.png")

		--[[EDIT: NAME]]--
		edit:AddOption("Name", function()
			local main = vgui.Create("DFrame")
			main:SetSize(190, 110)
			main:SetPos(ScrW()/2 - 95, ScrH()/2 - 55)
			main:SetDraggable(true)
			main:ShowCloseButton(false)
			main:SetTitle("Editing: Name")
			function main.Paint()
				draw.RoundedBox(0, 0, 0, 190, 24, GTawards.Color2)
				draw.RoundedBox(0, 0, 24, 190, 86, GTawards.Color1)
			end

			local nameLabel = vgui.Create("DLabel", main)
			nameLabel:SetPos(10, 30)
			nameLabel:SetTextColor(GTawards.TextColor)
			nameLabel:SetText("Name of the group (max 12):")
			nameLabel:SizeToContents()

			local nameEntry = vgui.Create("DTextEntry", main)
			nameEntry:SetPos(10, 50)
			nameEntry:SetSize(170, 20)
			nameEntry:SetText(adminMenu_RankList:GetLine(index):GetValue(2))
			nameEntry:RequestFocus()
			function nameEntry:OnValueChange(text)
				local max = 16
				if #text > max then
					text = string.sub(text, 0, max)
				end
			end

			local submit = vgui.Create("DButton", main)
			submit:SetPos(10, 80)
			submit:SetSize(80, 20)
			submit:SetText("Submit")
			submit:SetTextColor(GTawards.TextColor)
			function submit:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
			end
			function submit:DoClick()
				net.Start("GTawards.UpdateRankName")
					net.WriteInt(tonumber(adminMenu_RankList:GetLine(index):GetValue(1)), 32)
					net.WriteString(nameEntry:GetValue())
				net.SendToServer()

				net.Start("GTawards.FetchRanks")
				net.SendToServer()

				main:Close()
			end

			local cancel = vgui.Create("DButton", main)
			cancel:SetPos(100, 80)
			cancel:SetSize(80, 20)
			cancel:SetText("Cancel")
			cancel:SetTextColor(GTawards.TextColor)
			function cancel:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
			end
			function cancel:DoClick()
				main:Close()
			end

			main:MakePopup()
		end):SetImage("icon16/style.png")

		--[[EDIT: TIME]]--
		edit:AddOption("Time", function()
			local seconds = adminMenu_RankList:GetLine(index):GetValue(4)
			local timeTable = GTawards:ConvertTime(seconds, "table")
			local current_minutes = timeTable[1]
			local current_hours   =	timeTable[2]
			local current_days    =	timeTable[3]
			local current_weeks	  = timeTable[4]
			
			local main = vgui.Create("DFrame")
			main:SetSize(250, 110)
			main:SetPos(ScrW()/2 - 125, ScrH()/2 - 55)
			main:SetDraggable(true)
			main:ShowCloseButton(false)
			main:SetTitle("Editing: Time")
			function main.Paint()
				draw.RoundedBox(0, 0, 0, 250, 24, GTawards.Color2)
				draw.RoundedBox(0, 0, 24, 250, 86, GTawards.Color1)
			end

			local weeksLabel = vgui.Create("DLabel", main)
			weeksLabel:SetPos(10, 30)
			weeksLabel:SetTextColor(GTawards.TextColor)
			weeksLabel:SetText("Weeks:")
			weeksLabel:SizeToContents()

			local daysLabel = vgui.Create("DLabel", main)
			daysLabel:SetPos(70, 30)
			daysLabel:SetTextColor(GTawards.TextColor)
			daysLabel:SetText("Days:")
			daysLabel:SizeToContents()

			local hoursLabel = vgui.Create("DLabel", main)
			hoursLabel:SetPos(130, 30)
			hoursLabel:SetTextColor(GTawards.TextColor)
			hoursLabel:SetText("Hours:")
			hoursLabel:SizeToContents()
	
			local minutesLabel = vgui.Create("DLabel", main)
			minutesLabel:SetPos(190, 30)
			minutesLabel:SetTextColor(GTawards.TextColor)
			minutesLabel:SetText("Minutes:")
			minutesLabel:SizeToContents()

			local weeksEntry = vgui.Create("DNumberWang", main)
			weeksEntry:SetPos(10, 50)
			weeksEntry:SetSize(50, 20)
			weeksEntry:SetValue(current_weeks)
			weeksEntry:SetMinMax(0, 240000)
			weeksEntry:RequestFocus()

			local daysEntry = vgui.Create("DNumberWang", main)
			daysEntry:SetPos(70, 50)
			daysEntry:SetSize(50, 20)
			daysEntry:SetValue(current_days)
			daysEntry:SetMinMax(0, 6)
	
			local hoursEntry = vgui.Create("DNumberWang", main)
			hoursEntry:SetPos(130, 50)
			hoursEntry:SetSize(50, 20)
			hoursEntry:SetValue(current_hours)
			hoursEntry:SetMinMax(0, 24)
	
			local minutesEntry = vgui.Create("DNumberWang", main)
			minutesEntry:SetPos(190, 50)
			minutesEntry:SetSize(50, 20)
			minutesEntry:SetValue(current_minutes)
			minutesEntry:SetMax(60)
			minutesEntry:SetMinMax(0, 60)

			local submit = vgui.Create("DButton", main)
			submit:SetPos(10, 80)
			submit:SetSize(80, 20)
			submit:SetText("Submit")
			submit:SetTextColor(GTawards.TextColor)
			function submit:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
			end
			function submit:DoClick()
				local weeks	  = weeksEntry:GetValue()
				local days    = daysEntry:GetValue()
				local hours   = hoursEntry:GetValue()
				local minutes = minutesEntry:GetValue()
				local seconds = weeks*7*24*60*60 + days*24*60*60 + hours*60*60 + minutes*60

				net.Start("GTawards.UpdateRankTime")
					net.WriteInt(tonumber(adminMenu_RankList:GetLine(index):GetValue(1)), 32)
					net.WriteInt(seconds, 32)
				net.SendToServer()

				net.Start("GTawards.FetchRanks")
				net.SendToServer()

				main:Close()
			end

			local cancel = vgui.Create("DButton", main)
			cancel:SetPos(160, 80)
			cancel:SetSize(80, 20)
			cancel:SetText("Cancel")
			cancel:SetTextColor(GTawards.TextColor)
			function cancel:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
			end
			function cancel:DoClick()
				main:Close()
			end

			main:MakePopup()
		end):SetImage("icon16/clock.png")

		--[[EDIT: ACTIONS]]--
		edit:AddOption("Actions", function()
		 function OpenActionManager(new, currentData, id)
			local main = vgui.Create("DFrame")
			main:SetSize(500, 400)
			main:SetPos(ScrW()/2 - 300, ScrH()/2 - 200)
			main:SetDraggable(true)
			main:ShowCloseButton(true)
			main:SetTitle("Action Manager")
			function main:Paint(w, h)
				draw.RoundedBox(0, 0, 0, 500, 24, GTawards.Color2)
				draw.RoundedBox(0, 0, 24, 500, 576, GTawards.Color1)
				draw.RoundedBox(0, 10, 87, 8, 270, GTawards.Color3)
			end
	
			local actionsHint = vgui.Create("DLabel", main)
			actionsHint:DockMargin(5, 0, 0, 0)
			actionsHint:Dock(TOP)
			actionsHint:SetTextColor(GTawards.TextColor)
			if new then 
				actionsHint:SetText("You are creating new actions for: "..adminMenu_RankList:GetLine(index):GetValue(2))
			else
				actionsHint:SetText("You are editing the actions for: "..adminMenu_RankList:GetLine(index):GetValue(2))
			end
			
			local sheet = vgui.Create("DPropertySheet", main)
			function sheet.Paint()
			end
			function sheet:Think()
				for k, v in pairs(sheet.Items) do
					if !v.Tab then continue end
					v.Tab:SetTextColor(GTawards.TextColor)
					if sheet:GetActiveTab() == v.Tab then
						function v.Tab:Paint(w, h)
							draw.RoundedBox(0, 0, 0, w-4.6, h, GTawards.Color3)
						end
					else
						function v.Tab:Paint(w, h)
							draw.RoundedBox(0, 0, 0, w-4.6, h, GTawards.Color1)
						end
					end
				end
			end

			sheet:DockMargin(5, 10, 0, 30)
			sheet:Dock(FILL)

			local gnPanel = vgui.Create("DScrollPanel", sheet)
			function gnPanel:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, GTawards.Color3)
			end
			function gnPanel.VBar:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, Color(86, 86, 86, 200))
			end
			function gnPanel.VBar.btnUp:Paint(w, h)
				draw.RoundedBox(1, 0, 0, w, h, Color(56, 56, 56, 255))
			end
			function gnPanel.VBar.btnDown:Paint(w, h)
				draw.RoundedBox(1, 0, 0, w, h, Color(56, 56, 56, 255))
			end
			function gnPanel.VBar.btnGrip:Paint(w, h)
				draw.RoundedBox(1, 0, 0, w, h, Color(56, 56, 56, 200))
			end
			sheet:AddSheet("General", gnPanel, "icon16/wrench.png")
			
			local psPanel = vgui.Create("DPanel", sheet)
			function psPanel:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, GTawards.Color3)
			end 
			sheet:AddSheet("Pointshop", psPanel, "icon16/coins.png")
			
			groupPanel = vgui.Create("DPanel", sheet)
			function groupPanel:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, GTawards.Color3)
			end 
			sheet:AddSheet("Server Group", groupPanel, "icon16/group_go.png")

			dmPanel = vgui.Create("DPanel", sheet)
			function dmPanel:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, GTawards.Color3)
			end 
			sheet:AddSheet("DarkRP Money", dmPanel, "icon16/money.png")

			luaPanel = vgui.Create("DPanel", sheet)
			function luaPanel:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, GTawards.Color3)
			end 
			sheet:AddSheet("Custom Lua", luaPanel, "icon16/application_edit.png")



			--[[ACTIONS: General]]--
			local gnNameLabel = vgui.Create("DLabel", gnPanel)
			gnNameLabel:SetPos(5, 10)
			gnNameLabel:SetTextColor(GTawards.TextColor)
			gnNameLabel:SetText("The name of this action")
			gnNameLabel:SizeToContents()

			local gnNameEntry = vgui.Create("DTextEntry", gnPanel)
			gnNameEntry:SetSize(290, 20)
			gnNameEntry:SetPos(150, 10)
			gnNameEntry:SetText("")

			local gnServerLabel = vgui.Create("DLabel", gnPanel)
			gnServerLabel:SetPos(5, 40)
			gnServerLabel:SetTextColor(GTawards.TextColor)
			gnServerLabel:SetText("The server(s) this action should run on.\n Use CTRL to select multiple servers.\n A blue background means the server is selected.")
			gnServerLabel:SizeToContents()

			local gnServerList = vgui.Create("DListView", gnPanel)
			gnServerList:SetMultiSelect(true)
			gnServerList:SetSize(440, 100)
			gnServerList:SetPos(5, 80)
			gnServerList:AddColumn("ID", _, 1):SetFixedWidth(25)
			gnServerList:AddColumn("Hostname", _, 2)
			for k, v in pairs(GTawards.Servers) do 
				gnServerList:AddLine(v["id"], v["hostname"])
			end

			local gnServerListClear = vgui.Create("DButton", gnPanel)
			gnServerListClear:SetSize(100, 20)
			gnServerListClear:SetPos(445-100, 60-20)
			gnServerListClear:SetTextColor(GTawards.TextColor)
			gnServerListClear:SetText("Clear List")
			function gnServerListClear:Paint(w, h)
				draw.RoundedBox(0, 1, 1, w-2, 22, Color(106, 106, 106, 255))
				draw.RoundedBox(0, 0, 24, w-2, h-24-2, GTawards.Color1)

				surface.SetDrawColor(0, 0, 0, 180)
				surface.DrawOutlinedRect(0, 0, w, h)
			end
			function gnServerListClear:DoClick()
				gnServerList:Clear()
				for k, v in pairs(GTawards.Servers) do 
					gnServerList:AddLine(v["id"], v["hostname"])
				end

			end

			local gnRunMultipleLabel = vgui.Create("DLabel", gnPanel)
			gnRunMultipleLabel:SetPos(5, 185)
			gnRunMultipleLabel:SetTextColor(GTawards.TextColor)
			gnRunMultipleLabel:SetText("Run this action every time the user reaches the rank?\nThis is useful to regrant server groups.")
			gnRunMultipleLabel:SizeToContents()

			local gnRunMultipleCheckBox = vgui.Create("DCheckBox", gnPanel)
			gnRunMultipleCheckBox:SetSize(20, 22)
			gnRunMultipleCheckBox:SetPos(425, 185)

			local gnRunOnEveryServerLabel = vgui.Create("DLabel", gnPanel)
			gnRunOnEveryServerLabel:SetPos(5, 225)
			gnRunOnEveryServerLabel:SetTextColor(GTawards.TextColor)
			gnRunOnEveryServerLabel:SetText("Run this action on every server.\nOtherwise it will only run on the server on which the player connects first.")
			gnRunOnEveryServerLabel:SizeToContents()

			local gnRunOnEveryServerCheckBox = vgui.Create("DCheckBox", gnPanel)
			gnRunOnEveryServerCheckBox:SetSize(20, 20)
			gnRunOnEveryServerCheckBox:SetPos(425, 225)

			local gnExcludedLabel = vgui.Create("DLabel", gnPanel)
			gnExcludedLabel:SetPos(5, 265)
			gnExcludedLabel:SetTextColor(GTawards.TextColor)
			gnExcludedLabel:SetText("Excluded Server Groups for this action")
			gnExcludedLabel:SizeToContents()

			local gnExcludedList = vgui.Create("DListView", gnPanel)
			gnExcludedList:SetMultiSelect(true)
			gnExcludedList:SetSize(440, 100)
			gnExcludedList:SetPos(5, 285)
			gnExcludedList:AddColumn("Server Group")
			gnExcludedList:Clear()
			if ULib then
				for k, v in pairs(ULib.ucl.groups) do 
					gnExcludedList:AddLine(k)
				end
			elseif serverguard then
				for k, v in pairs(serverguard.ranks:GetStored()) do
					gnExcludedList:AddLine(k)
				end
			elseif sam then
				for k, v in pairs(sam.ranks.get_ranks()) do
					gnExcludedList:AddLine(k)
				end
			end
			
			local gnExcludedListClear = vgui.Create("DButton", gnPanel)
			gnExcludedListClear:SetSize(100, 20)
			gnExcludedListClear:SetPos(445-100, 285-20)
			gnExcludedListClear:SetTextColor(GTawards.TextColor)
			gnExcludedListClear:SetText("Clear List")
			function gnExcludedListClear:Paint(w, h)
				draw.RoundedBox(0, 1, 1, w-2, 22, Color(106, 106, 106, 255))
				draw.RoundedBox(0, 0, 24, w-2, h-24-2, GTawards.Color1)

				surface.SetDrawColor(0, 0, 0, 180)
				surface.DrawOutlinedRect(0, 0, w, h)
			end
			function gnExcludedListClear:DoClick()
				gnExcludedList:Clear()
				if ULib then
					for k, v in pairs(ULib.ucl.groups) do 
						gnExcludedList:AddLine(k)
					end
				elseif serverguard then
					for k, v in pairs(serverguard.ranks:GetStored()) do
						gnExcludedList:AddLine(k)
					end
				elseif sam then
					for k, v in pairs(sam.ranks.get_ranks()) do
						gnExcludedList:AddLine(k)
					end
				end
			end

			local gnSpacerLabel = vgui.Create("DLabel", gnPanel)
			gnSpacerLabel:SetPos(5, 385)
			gnSpacerLabel:SetText(" ")


			--[[ACTIONS: POINTSHOP POINTS]]--
			local psEnabledLabel = vgui.Create("DLabel", psPanel)
			psEnabledLabel:SetPos(5, 10)
			psEnabledLabel:SetTextColor(GTawards.TextColor)
			psEnabledLabel:SetText("Give Pointshop points on time reached")
			psEnabledLabel:SizeToContents()
			
			local psVersionLabel = vgui.Create("DLabel", psPanel)
			psVersionLabel:SetPos(5, 40)
			psVersionLabel:SetTextColor(GTawards.TextColor)
			psVersionLabel:SetText("Pointshop Version:")
			psVersionLabel:SizeToContents()
			psVersionLabel:SetDisabled(true)
			psVersionLabel:SetAlpha(0)
			
			local psPointsLabel = vgui.Create("DLabel", psPanel)
			psPointsLabel:SetPos(5, 70)
			psPointsLabel:SetTextColor(GTawards.TextColor)
			psPointsLabel:SetText("Points:")
			psPointsLabel:SizeToContents()
			psPointsLabel:SetDisabled(true)
			psPointsLabel:SetAlpha(0)
			
			local psPPointsLabel = vgui.Create("DLabel", psPanel)
			psPPointsLabel:SetPos(5, 100)
			psPPointsLabel:SetTextColor(GTawards.TextColor)
			psPPointsLabel:SetText("Premium Points:")
			psPPointsLabel:SizeToContents()
			psPPointsLabel:SetDisabled(true)
			psPPointsLabel:SetAlpha(0)

			local psPointsEntry = vgui.Create("DNumberWang", psPanel)
			psPointsEntry:SetPos(250, 70)
			psPointsEntry:SetSize(100, 20)
			psPointsEntry:SetDisabled(true)
			psPointsEntry:SetAlpha(0)
			psPointsEntry:SetMax(2000000000)
			
			local psPPointsEntry = vgui.Create("DNumberWang", psPanel)
			psPPointsEntry:SetPos(250, 100)
			psPPointsEntry:SetSize(100, 20)
			psPPointsEntry:SetDisabled(true)
			psPPointsEntry:SetAlpha(0)
			psPPointsEntry:SetMax(2000000000)
			
			local psVersionComboBox = vgui.Create("DComboBox", psPanel)
			psVersionComboBox:SetPos(250, 40)
			psVersionComboBox:SetSize(100, 20)
			psVersionComboBox:SetValue("Pointshop")
			psVersionComboBox:AddChoice("Pointshop 1")
			psVersionComboBox:AddChoice("Pointshop 2")
			function psVersionComboBox:OnSelect(index, value)
				psPointsLabel:SetDisabled(false)
				psPointsLabel:SetAlpha(255)
				psPointsEntry:SetDisabled(false)
				psPointsEntry:SetAlpha(255)
				psPPointsLabel:SetDisabled(true)
				psPPointsLabel:SetAlpha(0)
				psPPointsEntry:SetDisabled(true)
				psPPointsEntry:SetAlpha(0)
				if value == "Pointshop 2" then 
					psPPointsLabel:SetDisabled(false)
					psPPointsLabel:SetAlpha(255)
					psPPointsEntry:SetDisabled(false)
					psPPointsEntry:SetAlpha(255)
				end
			end
			psVersionComboBox:SetDisabled(true)
			psVersionComboBox:SetAlpha(0)
			
			local psEnabledCheckBox = vgui.Create("DCheckBox", psPanel)
			psEnabledCheckBox:SetSize(20, 20)
			psEnabledCheckBox:SetPos(250, 10)
			psEnabledCheckBox:SetValue(false)
			function psEnabledCheckBox:OnChange(enabled)
				if enabled then 
					psVersionLabel:SetDisabled(false)
					psVersionLabel:SetAlpha(255)
					psVersionComboBox:SetDisabled(false)
					psVersionComboBox:SetAlpha(255)
					if psVersionComboBox:GetSelected() == "Pointshop 1" then 
						psPointsLabel:SetDisabled(false)
						psPointsLabel:SetAlpha(255)
						psPointsEntry:SetDisabled(false)
						psPointsEntry:SetAlpha(255)
						psPPointsLabel:SetDisabled(true)
						psPPointsLabel:SetAlpha(0)
						psPPointsEntry:SetDisabled(true)
						psPPointsEntry:SetAlpha(0)
					elseif psVersionComboBox:GetSelected() == "Pointshop 2" then 
						psPointsLabel:SetDisabled(false)
						psPointsLabel:SetAlpha(255)
						psPointsEntry:SetDisabled(false)
						psPointsEntry:SetAlpha(255)
						psPPointsLabel:SetDisabled(false)
						psPPointsLabel:SetAlpha(255)
						psPPointsEntry:SetDisabled(false)
						psPPointsEntry:SetAlpha(255)
					end
				else 
					psVersionLabel:SetDisabled(true)
					psVersionLabel:SetAlpha(0)
					psVersionComboBox:SetDisabled(true)
					psVersionComboBox:SetAlpha(0)
					psPointsLabel:SetDisabled(true)
					psPointsLabel:SetAlpha(0)
					psPointsEntry:SetDisabled(true)
					psPointsEntry:SetAlpha(0)
					psPPointsEntry:SetDisabled(true)
					psPPointsEntry:SetAlpha(0)
					psPPointsLabel:SetDisabled(true)
					psPPointsLabel:SetAlpha(0)
				end
			end


			--[[ACTIONS: SERVER GROUP]]--
			local groupEnabledLabel = vgui.Create("DLabel", groupPanel)
			groupEnabledLabel:SetPos(5, 10)
			groupEnabledLabel:SetTextColor(GTawards.TextColor)
			groupEnabledLabel:SetText("Grant server group on time reached")
			groupEnabledLabel:SizeToContents()
			
			local groupLabel = vgui.Create("DLabel", groupPanel)
			groupLabel:SetPos(5, 40)
			groupLabel:SetTextColor(GTawards.TextColor)
			groupLabel:SetText("New Group:")
			groupLabel:SizeToContents()
			groupLabel:SetDisabled(true)
			groupLabel:SetAlpha(0)
			
			local groupSelector = vgui.Create("DComboBox", groupPanel)
			groupSelector:SetPos(250, 40)
			groupSelector:SetSize(100, 20)
			if ULib then
				for group in pairs(ULib.ucl.groups) do
					groupSelector:AddChoice(group)
				end
			elseif serverguard then
				for k, v in pairs(serverguard.ranks:GetStored()) do
					groupSelector:AddChoice(k)
				end
			elseif sam then
				for k, v in pairs(sam.ranks.get_ranks()) do
					groupSelector:AddChoice(k)
				end
			end
			groupSelector:SetDisabled(true)
			groupSelector:SetAlpha(0)
			
			local groupEnabledCheckBox = vgui.Create("DCheckBox", groupPanel)
			groupEnabledCheckBox:SetSize(20, 20)
			groupEnabledCheckBox:SetPos(250, 10)
			groupEnabledCheckBox:SetValue(false)
			function groupEnabledCheckBox:OnChange(enabled)
				if enabled then 
					groupLabel:SetDisabled(false)
					groupLabel:SetAlpha(255)
					groupSelector:SetDisabled(false)
					groupSelector:SetAlpha(255)
				else 
					groupLabel:SetDisabled(true)
					groupLabel:SetAlpha(0)
					groupSelector:SetDisabled(true)
					groupSelector:SetAlpha(0)
				end
			end


			--[[ACTIONS: DARKRP MONEY]]--
			local dmEnabledLabel = vgui.Create("DLabel", dmPanel)
			dmEnabledLabel:SetPos(5, 10)
			dmEnabledLabel:SetTextColor(GTawards.TextColor)
			dmEnabledLabel:SetText("Give DarkRP Money on time reached")
			dmEnabledLabel:SizeToContents()
			
			local dmLabel = vgui.Create("DLabel", dmPanel)
			dmLabel:SetPos(5, 40)
			dmLabel:SetTextColor(GTawards.TextColor)
			dmLabel:SetText("Amount:")
			dmLabel:SizeToContents()
			dmLabel:SetDisabled(true)
			dmLabel:SetAlpha(0)
			
			local dmSelector = vgui.Create("DNumberWang", dmPanel)
			dmSelector:SetPos(250, 40)
			dmSelector:SetSize(100, 20)
			dmSelector:SetEditable(false)
			dmSelector:SetAlpha(0)
			dmSelector:SetMax(2000000000)
			
			local dmEnabledCheckBox = vgui.Create("DCheckBox", dmPanel)
			dmEnabledCheckBox:SetSize(20, 20)
			dmEnabledCheckBox:SetPos(250, 10)
			dmEnabledCheckBox:SetValue(false)
			function dmEnabledCheckBox:OnChange(enabled)
				if enabled then 
					dmLabel:SetDisabled(false)
					dmLabel:SetAlpha(255)
					dmSelector:SetEditable(true)
					dmSelector:SetAlpha(255)
				else 
					dmLabel:SetDisabled(true)
					dmLabel:SetAlpha(0)
					dmSelector:SetEditable(false)
					dmSelector:SetAlpha(0)
				end
			end


			--[[ACTIONS: CUSTOM LUA]]--
			local luaEnabledLabel = vgui.Create("DLabel", luaPanel)
			luaEnabledLabel:SetPos(5, 10)
			luaEnabledLabel:SetTextColor(GTawards.TextColor)
			luaEnabledLabel:SetText("Execute custom lua code on time reached")
			luaEnabledLabel:SizeToContents()
			
			local luaLabel = vgui.Create("DLabel", luaPanel)
			luaLabel:SetPos(5, 40)
			luaLabel:SetTextColor(GTawards.TextColor)
			luaLabel:SetText("PLAYER is the variable for the Player. The code is only ran serverside.\nUse SendLua for clientside Code. Custom Code:")
			luaLabel:SizeToContents()
			luaLabel:SetDisabled(true)
			luaLabel:SetAlpha(0)
			
			local luaEntry = vgui.Create("DTextEntry", luaPanel)
			luaEntry:DockMargin(5,70,10,15)
			luaEntry:Dock(FILL)
			luaEntry:SetMultiline(true)
			luaEntry:SetEditable(false)
			luaEntry:SetAlpha(0)
			
			local luaEnabledCheckBox = vgui.Create("DCheckBox", luaPanel)
			luaEnabledCheckBox:SetSize(20, 20)
			luaEnabledCheckBox:SetPos(250, 10)
			luaEnabledCheckBox:SetValue(false)
			function luaEnabledCheckBox:OnChange(enabled)
				if enabled then 
					luaLabel:SetDisabled(false)
					luaLabel:SetAlpha(255)
					luaEntry:SetEditable(true)
					luaEntry:SetAlpha(255)
				else 
					luaLabel:SetDisabled(true)
					luaLabel:SetAlpha(0)
					luaEntry:SetEditable(false)
					luaEntry:SetAlpha(0)
				end
			end
			
			local submit = vgui.Create("DButton", main)
			submit:SetPos(10, 370)
			submit:SetSize(200, 20)
			if new then
				submit:SetText("Submit")
			else
				submit:SetText("Apply Changes")
			end
			submit:SetTextColor(GTawards.TextColor)
			function submit:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
			end

			--[[ACTIONS: SAVE]]--
			function submit:DoClick()
				local contentTable = {}

				local name = gnNameEntry:GetValue()
				local servers = {}
				for k, line in pairs(gnServerList:GetSelected()) do
					servers[line:GetValue(1)] = true
				end
				local runOnEveryServer
				if gnRunOnEveryServerCheckBox:GetChecked() then
					runOnEveryServer = "1"
				else
					runOnEveryServer = "0" 
				end
				local runMultiple
				if gnRunMultipleCheckBox:GetChecked() then
					runMultiple = "1"
				else
					runMultiple = "0" 
				end
				local excluded = {}
				for k, line in pairs(gnExcludedList:GetSelected()) do
					table.insert(excluded, line:GetValue(1))
				end
				local luaCode = luaEntry:GetValue()

				contentTable["psEnabled"]  = psEnabledCheckBox:GetChecked()
				contentTable["psVersion"]  = psVersionComboBox:GetValue()
				contentTable["psPoints"]   = psPointsEntry:GetValue()
				contentTable["psPPoints"]  = psPPointsEntry:GetValue()

				contentTable["groupEnabled"] = groupEnabledCheckBox:GetChecked()
				contentTable["group"]    = groupSelector:GetValue()

				contentTable["dmEnabled"]  = dmEnabledCheckBox:GetChecked()
				contentTable["drpMoney"]   = dmSelector:GetValue()

				contentTable["luaEnabled"] = luaEnabledCheckBox:GetChecked()

				if new then
					net.Start("GTawards.AddAction")
						net.WriteInt(tonumber(adminMenu_RankList:GetLine(index):GetValue(1)), 32)
						net.WriteString(util.TableToJSON(contentTable))
						net.WriteString(name)
						net.WriteString(util.TableToJSON(servers))
						net.WriteString(util.TableToJSON(excluded))
						net.WriteString(runOnEveryServer)
						net.WriteString(runMultiple)
						net.WriteString(luaCode)
					net.SendToServer()

					timer.Simple(0.5, function()
						net.Start("GTawards.FetchActions")
							net.WriteInt(tonumber(adminMenu_RankList:GetLine(index):GetValue(1)), 32)
						net.SendToServer()
					end)
				else
					local function UpdateAction(key, value)
						net.Start("GTawards.UpdateAction")
							net.WriteInt(id, 32)
							net.WriteString(key)
							net.WriteString(value)
						net.SendToServer()
					end

					UpdateAction("content", util.TableToJSON(contentTable))
					UpdateAction("name", name)
					UpdateAction("servers", util.TableToJSON(servers))
					UpdateAction("excluded", util.TableToJSON(excluded))
					UpdateAction("runoneveryserver", runOnEveryServer)
					UpdateAction("runmultiple", runMultiple)
					UpdateAction("luacode", luaCode)

					timer.Simple(0.5, function()
						net.Start("GTawards.FetchActions")
							net.WriteInt(tonumber(adminMenu_RankList:GetLine(index):GetValue(1)), 32)
						net.SendToServer()
					end)
				end

				main:Close()
			end
			
			local cancel = vgui.Create("DButton", main)
			cancel:SetPos(290, 370)
			cancel:SetSize(200, 20)
			cancel:SetText("Cancel")
			cancel:SetTextColor(GTawards.TextColor)
			function cancel:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
			end
			function cancel:DoClick()
				main:Close()
			end

			if !new then 
				--apply currentData:
				local contentTable = util.JSONToTable(currentData["content"])

				gnNameEntry:SetValue(currentData["name"])


				for k, line in pairs(gnServerList:GetLines()) do 
					for k2, v in pairs(util.JSONToTable(currentData["servers"])) do
						if tostring(k2) == tostring(line:GetValue(1)) then 
							gnServerList:SelectItem(line)
						end
					end
				end

				gnRunOnEveryServerCheckBox:SetValue(tonumber(currentData["runoneveryserver"]))
				gnRunMultipleCheckBox:SetValue(tonumber(currentData["runmultiple"]))
				
				for k, line in pairs(gnExcludedList:GetLines()) do 
					for k2, v in pairs(util.JSONToTable(currentData["excluded"])) do 
						if v == line:GetValue(1) then
							gnExcludedList:SelectItem(line)
						end
					end
				end

				psEnabledCheckBox:SetValue(contentTable["psEnabled"])

				if contentTable["psVersion"] == "Pointshop 1" then
					psVersionComboBox:ChooseOptionID(1)
				elseif contentTable["psVersion"] == "Pointshop 2" then
					psVersionComboBox:ChooseOptionID(2)
				end

				psPointsEntry:SetValue(contentTable["psPoints"])
				psPPointsEntry:SetValue(contentTable["psPPoints"])

				groupEnabledCheckBox:SetValue(contentTable["groupEnabled"])
				groupSelector:SetValue(contentTable["group"])

				dmEnabledCheckBox:SetValue(contentTable["dmEnabled"])
				dmSelector:SetValue(contentTable["drpMoney"])

				luaEnabledCheckBox:SetValue(contentTable["luaEnabled"])
				luaEntry:SetValue(currentData["luacode"])

			end	
			main:MakePopup()		
		 end

		 	local currentActions
		 	local main = vgui.Create("DFrame")
			main:SetSize(200, 230)
		 	main:SetPos(ScrW()/2 +210, ScrH()/2 - 115)
			main:SetDraggable(true)
		 	main:ShowCloseButton(true)
		 	main:SetTitle("Editing: Actions")
			function main:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, 24, GTawards.Color2)
				draw.RoundedBox(0, 0, 24, w, h-24, GTawards.Color1)
		 	end

			local actionLabel = vgui.Create("DLabel", main)
			actionLabel:SetPos(5, 30)
			actionLabel:SetTextColor(GTawards.TextColor)
			actionLabel:SetText("Current actions:")
			actionLabel:SizeToContents()

			local actionList = vgui.Create("DListView", main)
			actionList:SetPos(5, 50)
			actionList:SetSize(190, 150)
			actionList:SetMultiSelect(false)
			actionList:AddColumn("ID"):SetWidth(25)
			actionList:AddColumn("Name")

			function actionList:OnRowRightClick(actionIndex, row)
				local dermaMenu = DermaMenu()

				--[[EDIT]]--
				dermaMenu:AddOption("Edit", function()
					for k, v in pairs(currentActions) do 
						if k == actionList:GetLine(actionIndex):GetValue(1) then
							OpenActionManager(false, v, k)
						end
					end
				end):SetImage("icon16/pencil.png")

				--[[DELETE]]--
				dermaMenu:AddOption("Delete", function()
					net.Start("GTawards.DeleteAction")
						net.WriteInt(tonumber(actionList:GetLine(actionIndex):GetValue(1)), 32)
					net.SendToServer()

					actionList:RemoveLine(actionIndex)
				end):SetImage("icon16/delete.png")

				dermaMenu:Open()
			end

			local createNew = vgui.Create("DButton", main)
			createNew:SetSize(188, 20)
			createNew:SetPos(6, 199)
			createNew:SetTextColor(GTawards.TextColor)
			createNew:SetText("Create New Action")
			function createNew:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
			end
			function createNew:DoClick()
				OpenActionManager(true)
			end

			net.Receive("GTawards.FetchActions", function()
		 		currentActions = net.ReadTable()
		 		actionList:Clear()
		 		for k, v in pairs(currentActions) do 
					actionList:AddLine(k, v["name"])
				end
		 	end)

			main:MakePopup()

			net.Start("GTawards.FetchActions")
				net.WriteInt(tonumber(adminMenu_RankList:GetLine(index):GetValue(1)), 32)
		 	net.SendToServer()

		end):SetImage("icon16/application_view_tile.png")

		--[[DELETE]]-- {{ user_id sha256 gtawards }}
		dermaMenu:AddOption("Delete",function()
			local main = vgui.Create("DFrame")
			main:SetSize(190, 110)
			main:SetPos(ScrW()/2 - 95, ScrH()/2 - 55)
			main:SetDraggable(true)
			main:ShowCloseButton(false)
			main:SetTitle("Delete Rank")
			function main:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, 24, GTawards.Color2)
				draw.RoundedBox(0, 0, 24, w, h-24, GTawards.Color1)
			end

			local warning = vgui.Create("DLabel", main)
			warning:SetPos(10, 30)
			warning:SetTextColor(GTawards.TextColor)
			warning:SetText("Are you sure that you want to\ndelete "..adminMenu_RankList:GetLine(index):GetValue(2))
			warning:SizeToContents()

			local submit = vgui.Create("DButton", main)
			submit:SetPos(10, 80)
			submit:SetSize(80, 20)
			submit:SetText("Delete")
			submit:SetTextColor(GTawards.TextColor)
			function submit:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
			end
			function submit:DoClick()
				net.Start("GTawards.DeleteRank")
					net.WriteInt(tonumber(adminMenu_RankList:GetLine(index):GetValue(1)), 32)
				net.SendToServer()

				adminMenu_RankList:RemoveLine(index)

				main:Close()
			end

			local cancel = vgui.Create("DButton", main)
			cancel:SetPos(100, 80)
			cancel:SetSize(80, 20)
			cancel:SetText("Cancel")
			cancel:SetTextColor(GTawards.TextColor)
			function cancel:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
			end
			function cancel:DoClick()
				main:Close()
			end

			main:MakePopup()
		end):SetImage("icon16/delete.png")			

		dermaMenu:Open()
	end

	----------------------------------------------------------------------
	---------------------------ONLINE PLAYERS-----------------------------
	----------------------------------------------------------------------
	local adminMenu_PlayerList = vgui.Create("DListView", adminMenu_Players)
	adminMenu_PlayerList:DockMargin(0, 5, 5, 5)
	adminMenu_PlayerList:Dock(FILL)
	adminMenu_PlayerList:SetMultiSelect(false)
	adminMenu_PlayerList:AddColumn("Name", _, 1)
	adminMenu_PlayerList:AddColumn("Rank", _, 2)
	adminMenu_PlayerList:AddColumn("Time", _, 3)
	adminMenu_PlayerList:AddColumn("_seconds", _, 4):SetFixedWidth(0) --not visible
	adminMenu_PlayerList:AddColumn("_steam64", _, 5):SetFixedWidth(0) --not visible
	--function adminMenu_PlayerList:Paint(w, h)
	--end
	--COLUMN PAINTING 

	net.Receive("GTawards.FetchPlayerData",function()
		local playerData = net.ReadTable()
		adminMenu_PlayerList:Clear()
		for k, v in pairs(playerData) do
			adminMenu_PlayerList:AddLine(
				v["name"],
				v["rank"]["name"],
				GTawards:ConvertTime(v["time"], "fullstring"),
				v["time"],
				v["steam64"]
			)
		end
	end)

	local adminMenu_PlayerList_Refresh = vgui.Create("DImageButton", adminMenu_Players)
	adminMenu_PlayerList_Refresh:SetPos(345, 4)
	adminMenu_PlayerList_Refresh:SetSize(16,16)
	adminMenu_PlayerList_Refresh:SetImage("icon16/arrow_refresh.png")
	function adminMenu_PlayerList_Refresh:DoClick()
		net.Start("GTawards.FetchPlayerData")
			net.WriteTable(GetAllSteamIDs())
		net.SendToServer()
	end

	local title = vgui.Create("DLabel", adminMenu_Players)
	title:SetPos(0, 5)
	title:SetText("Search for a player (ENTER to search):")
	title:SetTextColor(GTawards.TextColor)
	title:SizeToContents()

	local searchBar = vgui.Create("DTextEntry", adminMenu_Players)
	searchBar:DockMargin(0, 25, 5, 5)
	searchBar:Dock(TOP)
	searchBar:SetText("")
	function searchBar:OnValueChange(str)
		local players = {}

		for k, ply in pairs(player.GetHumans()) do 
			if string.find(string.lower(ply:Nick()), string.lower(str)) then 
				players[#players+1] = ply:SteamID64()
			end
		end

		net.Start("GTawards.FetchPlayerData")
			net.WriteTable(players)
		net.SendToServer()
	end

	function adminMenu_PlayerList:OnRowRightClick(index, row)
		local dermaMenu = DermaMenu()

		--[[CHANGE TIME]]
		dermaMenu:AddOption("Change Time",function()
			local seconds = adminMenu_PlayerList:GetLine(index):GetValue(4)
			local timeTable = GTawards:ConvertTime(seconds, "table")
			local current_minutes = timeTable[1]
			local current_hours   =	timeTable[2]
			local current_days    =	timeTable[3]
			local current_weeks   = timeTable[4]
	
			local main = vgui.Create("DFrame")
			main:SetSize(250, 140)
			main:SetPos(ScrW()/2 - 125, ScrH()/2 - 70)
			main:SetDraggable(true)
			main:ShowCloseButton(false)
			main:SetTitle("Change Time")
			function main:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, 24, GTawards.Color2)
				draw.RoundedBox(0, 0, 24, w, h-24, GTawards.Color1)
			end

			local mainLabel = vgui.Create("DLabel", main)
			mainLabel:SetPos(10, 30)
			mainLabel:SetTextColor(Color(255, 255, 255, 255))
			mainLabel:SetText("You are changing time for\n"..adminMenu_PlayerList:GetLine(index):GetValue(1))
			mainLabel:SizeToContents()
	
			local weeksLabel = vgui.Create("DLabel", main)
			weeksLabel:SetPos(10, 60)
			weeksLabel:SetTextColor(GTawards.TextColor)
			weeksLabel:SetText("Weeks:")
			weeksLabel:SizeToContents()

			local daysLabel = vgui.Create("DLabel", main)
			daysLabel:SetPos(70, 60)
			daysLabel:SetTextColor(GTawards.TextColor)
			daysLabel:SetText("Days:")
			daysLabel:SizeToContents()

			local hoursLabel = vgui.Create("DLabel", main)
			hoursLabel:SetPos(130, 60)
			hoursLabel:SetTextColor(GTawards.TextColor)
			hoursLabel:SetText("Hours:")
			hoursLabel:SizeToContents()
	
			local minutesLabel = vgui.Create("DLabel", main)
			minutesLabel:SetPos(190, 60)
			minutesLabel:SetTextColor(GTawards.TextColor)
			minutesLabel:SetText("Minutes:")
			minutesLabel:SizeToContents()

			local weeksEntry = vgui.Create("DNumberWang", main)
			weeksEntry:SetPos(10, 80)
			weeksEntry:SetSize(50, 20)
			weeksEntry:SetValue(current_weeks)
			weeksEntry:SetMinMax(0, 240000)
			weeksEntry:RequestFocus()

			local daysEntry = vgui.Create("DNumberWang", main)
			daysEntry:SetPos(70, 80)
			daysEntry:SetSize(50, 20)
			daysEntry:SetValue(current_days)
			daysEntry:SetMinMax(0, 6)
	
			local hoursEntry = vgui.Create("DNumberWang", main)
			hoursEntry:SetPos(130, 80)
			hoursEntry:SetSize(50, 20)
			hoursEntry:SetValue(current_hours)
			hoursEntry:SetMinMax(0, 24)
	
			local minutesEntry = vgui.Create("DNumberWang", main)
			minutesEntry:SetPos(190, 80)
			minutesEntry:SetSize(50, 20)
			minutesEntry:SetValue(current_minutes)
			minutesEntry:SetMax(60)
			minutesEntry:SetMinMax(0, 60)
	
			local submit = vgui.Create("DButton", main)
			submit:SetPos(10, 110)
			submit:SetSize(80, 20)
			submit:SetText("Submit")
			submit:SetTextColor(GTawards.TextColor)
			function submit:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
			end
			function submit:DoClick()
				local weeks	  = weeksEntry:GetValue()
				local days    = daysEntry:GetValue()
				local hours   = hoursEntry:GetValue()
				local minutes = minutesEntry:GetValue()
				local seconds = weeks * 7 * 24 * 60 * 60 + days * 24 * 60 * 60 + hours * 60 * 60 + minutes * 60

				net.Start("GTawards.SetPlayerTime")
					net.WriteString(adminMenu_PlayerList:GetLine(index):GetValue(5))
					net.WriteInt(seconds, 32)
				net.SendToServer()

				net.Start("GTawards.FetchPlayerData")
					net.WriteTable(GetAllSteamIDs())
				net.SendToServer()

				main:Close()
			end

			local cancel = vgui.Create("DButton", main)
			cancel:SetPos(160, 110)
			cancel:SetSize(80, 20)
			cancel:SetText("Cancel")
			cancel:SetTextColor(GTawards.TextColor)
			function cancel:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
			end
			function cancel:DoClick()
				main:Close()
			end

			main:MakePopup()
		end):SetImage("icon16/clock_edit.png")

		--[[RESET TIME]]--
		dermaMenu:AddOption("Reset Time", function()
			local main = vgui.Create("DFrame")
			main:SetSize(190, 110)
			main:SetPos(ScrW()/2 - 40, ScrH()/2 - 40)
			main:SetDraggable(true)
			main:ShowCloseButton(false)
			main:SetTitle("Reset Time")
			function main:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, 24, GTawards.Color2)
				draw.RoundedBox(0, 0, 24, w, h-24, GTawards.Color1)
			end
	
			local warning = vgui.Create("DLabel", main)
			warning:SetPos(10, 40)
			warning:SetTextColor(GTawards.TextColor)
			warning:SetText("Are you sure that you want to reset\nthe time for "..adminMenu_PlayerList:GetLine(index):GetValue(1).." ?")
			warning:SizeToContents()
	
			local submit = vgui.Create("DButton", main)
			submit:SetPos(10, 80)
			submit:SetSize(80, 20)
			submit:SetText("Reset")
			submit:SetTextColor(GTawards.TextColor)
			function submit:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
			end
			function submit:DoClick()
				net.Start("GTawards.SetPlayerTime")
					net.WriteString(adminMenu_PlayerList:GetLine(index):GetValue(5))
					net.WriteInt(0, 32)
				net.SendToServer()

				net.Start("GTawards.FetchPlayerData")
					net.WriteTable(GetAllSteamIDs())
				net.SendToServer()

				main:Close()
			end
	
			local cancel = vgui.Create("DButton", main)
			cancel:SetPos(100, 80)
			cancel:SetSize(80, 20)
			cancel:SetText("Cancel")
			cancel:SetTextColor(GTawards.TextColor)
			function cancel:Paint(w, h)
				draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
			end
			function cancel:DoClick()
				main:Close()
			end
	
			main:MakePopup()
		end):SetImage("icon16/clock_delete.png")

		dermaMenu:Open()
	end

	----------------------------------------------------------------------
	--------------------------OFFLINE PLAYERS-----------------------------
	----------------------------------------------------------------------
	local searchLabel = vgui.Create("DLabel", adminMenu_OfflinePlayers)
	searchLabel:SetPos(45, 10)
	searchLabel:SetTextColor(Color(255, 255, 255, 255))
	searchLabel:SetText("Here you can edit player's time by SteamID or Steam64.\nOffline and online players possible.")
	searchLabel:SizeToContents()

	local steamIDLabel = vgui.Create("DLabel", adminMenu_OfflinePlayers)
	steamIDLabel:SetPos(45, 55)
	steamIDLabel:SetTextColor(Color(255, 255, 255, 255))
	steamIDLabel:SetText("SteamID or Steam64ID:")
	steamIDLabel:SizeToContents()

	local target = "7656119xxxxxxxxx"
	local steamIDEntry = vgui.Create("DTextEntry", adminMenu_OfflinePlayers)
	steamIDEntry:SetSize(200, 20)
	steamIDEntry:SetPos(45, 70)
	steamIDEntry:SetText("")
	steamIDEntry:SizeToContents()

	local search = vgui.Create("DButton", adminMenu_OfflinePlayers)
	search:SetSize(50, 20)
	search:SetPos(260, 70)
	search:SetTextColor(Color(255, 255, 255, 255))
	search:SetText("Search")
	function search:Paint(w, h)
		draw.RoundedBox(0, 1, 1, w-2, 22, GTawards.Color2)
		draw.RoundedBox(0, 0, 24, w-2, h-24-2, GTawards.Color1)

		surface.SetDrawColor(0, 0, 0, 180)
		surface.DrawOutlinedRect(0, 0, w, h)
	end

	local steam64Label = vgui.Create("DLabel", adminMenu_OfflinePlayers)
	steam64Label:SetPos(45, 115)
	steam64Label:SetTextColor(GTawards.TextColor)
	steam64Label:SetText("Steam64ID:")
	steam64Label:SizeToContents()

	local onlineTime = 0
	local onlineTimeLabel = vgui.Create("DLabel", adminMenu_OfflinePlayers)
	onlineTimeLabel:SetPos(45, 135)
	onlineTimeLabel:SetTextColor(GTawards.TextColor)
	onlineTimeLabel:SetText("Online Time:")
	onlineTimeLabel:SizeToContents()

	local statusLabel = vgui.Create("DLabel", adminMenu_OfflinePlayers)
	statusLabel:SetPos(45, 155)
	statusLabel:SetTextColor(GTawards.TextColor)
	statusLabel:SetText("Status:")
	statusLabel:SizeToContents()

	local foundResult = false

	function steamIDEntry:OnEnter()
		foundResult = false

		steam64Label:SetText("Steam64ID:")
		onlineTimeLabel:SetText("Online Time:")
		statusLabel:SetText("Status:")

		target = string.Trim(steamIDEntry:GetValue())
		if string.find(target, "STEAM_", 0, true) then 
			target = util.SteamIDTo64(target)
		end

		net.Start("GTawards.GetPlayerTime")
			net.WriteString(target)
		net.SendToServer()

		timer.Simple(1, function() --1 second should be enough time for the net receiver
			if !foundResult then
				statusLabel:SetTextColor(Color(200, 0, 0, 255))
				statusLabel:SetText("Status:            SteamID not found!")
				statusLabel:SizeToContents()
			end
		end)
	end

	net.Receive("GTawards.GetPlayerTime", function()
		onlineTime = net.ReadInt(32)
		steam64Label:SetText("Steam64ID:    "..target)
		steam64Label:SizeToContents()
		onlineTimeLabel:SetText("Online Time:    "..GTawards:ConvertTime(onlineTime, "fullstring"))
		onlineTimeLabel:SizeToContents()
		statusLabel:SetTextColor(Color(0, 255, 0, 255))
		statusLabel:SetText("Status:            Steam64ID found!")
		statusLabel:SizeToContents()
		foundResult = true
	end)

	search.DoClick = steamIDEntry.OnEnter

	local changeTimeButton = vgui.Create("DButton", adminMenu_OfflinePlayers)
	changeTimeButton:SetSize(100, 25)
	changeTimeButton:SetPos(45, 190)
	changeTimeButton:SetTextColor(Color(255, 255, 255, 255))
	changeTimeButton:SetText("Change Time")
	function changeTimeButton:Paint(w, h)
		draw.RoundedBox(0, 1, 1, w-1, 23, GTawards.Color2)
		draw.RoundedBox(0, 1, 24, w-1, h-24-1, GTawards.Color1)

		surface.SetDrawColor(0, 0, 0, 180)
		surface.DrawOutlinedRect(0, 0, w, h)
	end

	function changeTimeButton:DoClick()
		if !foundResult then return end

		local timeTable = GTawards:ConvertTime(onlineTime, "table")
		local current_minutes = timeTable[1]
		local current_hours   =	timeTable[2]
		local current_days    =	timeTable[3]
		local current_weeks   = timeTable[4]
	
		local main = vgui.Create("DFrame")
		main:SetSize(250, 140)
		main:SetPos(ScrW()/2 - 40, ScrH()/2 - 40)
		main:SetDraggable(true)
		main:ShowCloseButton(false)
		main:SetTitle("Change Time")
		function main:Paint(w, h)
			draw.RoundedBox(0, 0, 0, w, 24, GTawards.Color2)
			draw.RoundedBox(0, 0, 24, w, h-24, GTawards.Color1)
		end

		local mainLabel = vgui.Create("DLabel", main)
		mainLabel:SetPos(10, 30)
		mainLabel:SetTextColor(Color(255, 255, 255, 255))
		mainLabel:SetText("You are changing time for\n"..target)
		mainLabel:SizeToContents()

		local weeksLabel = vgui.Create("DLabel", main)
		weeksLabel:SetPos(10, 60)
		weeksLabel:SetTextColor(GTawards.TextColor)
		weeksLabel:SetText("Weeks:")
		weeksLabel:SizeToContents()

		local daysLabel = vgui.Create("DLabel", main)
		daysLabel:SetPos(70, 60)
		daysLabel:SetTextColor(GTawards.TextColor)
		daysLabel:SetText("Days:")
		daysLabel:SizeToContents()

		local hoursLabel = vgui.Create("DLabel", main)
		hoursLabel:SetPos(130, 60)
		hoursLabel:SetTextColor(GTawards.TextColor)
		hoursLabel:SetText("Hours:")
		hoursLabel:SizeToContents()

		local minutesLabel = vgui.Create("DLabel", main)
		minutesLabel:SetPos(190, 60)
		minutesLabel:SetTextColor(GTawards.TextColor)
		minutesLabel:SetText("Minutes:")
		minutesLabel:SizeToContents()
		
		local weeksEntry = vgui.Create("DNumberWang", main)
		weeksEntry:SetPos(10, 80)
		weeksEntry:SetSize(50, 20)
		weeksEntry:SetValue(current_weeks)
		weeksEntry:SetMinMax(0, 240000)
		weeksEntry:RequestFocus()

		local daysEntry = vgui.Create("DNumberWang", main)
		daysEntry:SetPos(70, 80)
		daysEntry:SetSize(50, 20)
		daysEntry:SetValue(current_days)
		daysEntry:SetMinMax(0, 6)
		
		local hoursEntry = vgui.Create("DNumberWang", main)
		hoursEntry:SetPos(130, 80)
		hoursEntry:SetSize(50, 20)
		hoursEntry:SetValue(current_hours)
		hoursEntry:SetMinMax(0, 24)
		
		local minutesEntry = vgui.Create("DNumberWang", main)
		minutesEntry:SetPos(190, 80)
		minutesEntry:SetSize(50, 20)
		minutesEntry:SetValue(current_minutes)
		minutesEntry:SetMax(60)
		minutesEntry:SetMinMax(0, 60)
	
		local submit = vgui.Create("DButton", main)
		submit:SetPos(10, 110)
		submit:SetSize(80, 20)
		submit:SetText("Submit")
		submit:SetTextColor(GTawards.TextColor)
		function submit:Paint(w, h)
			draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
		end
		function submit:DoClick()
			local weeks	  = weeksEntry:GetValue()
			local days    = daysEntry:GetValue()
			local hours   = hoursEntry:GetValue()
			local minutes = minutesEntry:GetValue()
			local seconds = weeks * 7 * 24 * 60 * 60 + days * 24 * 60 * 60 + hours * 60 * 60 + minutes * 60

			net.Start("GTawards.SetPlayerTime")
				net.WriteString(target)
				net.WriteInt(seconds, 32)
			net.SendToServer()

			timer.Simple(0.5, function()
				net.Start("GTawards.GetPlayerTime")
					net.WriteString(target)
				net.SendToServer()
			end)

			main:Close()
		end

		local cancel = vgui.Create("DButton", main)
		cancel:SetPos(100, 110)
		cancel:SetSize(80, 20)
		cancel:SetText("Cancel")
		cancel:SetTextColor(GTawards.TextColor)
		function cancel:Paint(w, h)
			draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
		end
		function cancel:DoClick()
			main:Close()
		end

		main:MakePopup()
	end

	local resetTimeButton = vgui.Create("DButton", adminMenu_OfflinePlayers)
	resetTimeButton:SetSize(100, 25)
	resetTimeButton:SetPos(210, 190)
	resetTimeButton:SetTextColor(Color(255, 255, 255, 255))
	resetTimeButton:SetText("Reset Time")
	function resetTimeButton:Paint(w, h)
		draw.RoundedBox(0, 1, 1, w-1, 23, GTawards.Color2)
		draw.RoundedBox(0, 1, 24, w-1, h-24-1, GTawards.Color1)

		surface.SetDrawColor(0, 0, 0, 180)
		surface.DrawOutlinedRect(0, 0, w, h)
	end
	function resetTimeButton:DoClick()
		if !foundResult then return end

		local main = vgui.Create("DFrame")
		main:SetSize(190, 110)
		main:SetPos(ScrW()/2 - 95, ScrH()/2 - 55)
		main:SetDraggable(true)
		main:ShowCloseButton(false)
		main:SetTitle("Reset Time")
		function main:Paint(w, h)
			draw.RoundedBox(0, 0, 0, w, 24, GTawards.Color2)
			draw.RoundedBox(0, 0, 24, w, h-24, GTawards.Color1)
		end
	
		local warning = vgui.Create("DLabel", main)
		warning:SetPos(10, 40)
		warning:SetTextColor(GTawards.TextColor)
		warning:SetText("Are you sure that you want to reset\nthe time for "..target.." ?")
		warning:SizeToContents()
	
		local submit = vgui.Create("DButton", main)
		submit:SetPos(10, 80)
		submit:SetSize(80, 20)
		submit:SetText("Reset")
		submit:SetTextColor(GTawards.TextColor)
		function submit:Paint(w, h)
			draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
		end
		function submit:DoClick()
			net.Start("GTawards.SetPlayerTime")
				net.WriteString(target)
				net.WriteInt(0, 32)
			net.SendToServer()

			timer.Simple(0.5, function()
				net.Start("GTawards.GetPlayerTime")
					net.WriteString(target)
				net.SendToServer()
			end)

			main:Close()
		end
	
		local cancel = vgui.Create("DButton", main)
		cancel:SetPos(100, 80)
		cancel:SetSize(80, 20)
		cancel:SetTextColor(GTawards.TextColor)
		cancel:SetText("Cancel")
		function cancel:Paint(w, h)
			draw.RoundedBox(0, 0, 0, w, h, GTawards.Color2)
		end
		function cancel:DoClick()
			main:Close()
		end
		main:MakePopup()
	end



	----------------------------------------------------------------------
	---------------------------------SETTINGS-----------------------------
	----------------------------------------------------------------------	
	local sessionTime			= true
	local onlyShowOnScoreboard  = true
	local hideBar				= false
	local importUTime			= false
	local importTR				= false
	local barColor 				= Color(255, 255, 255, 255)
	local bgColorTop 			= Color(255, 255, 255, 255)
	local bgColorBot 			= Color(255, 255, 255, 255)
	local xrelative 			= 0
	local cornerRadius			= 0
	local yrelative 			= 0
	local xpadding 				= 0
	local ypadding  			= 0
	local xsize  				= 0
	local fontColorTop 			= Color(255, 255, 255, 255)
	local fontColorBot 			= Color(255, 255, 255, 255)

	local settingsSheet = vgui.Create("DPropertySheet", adminMenu_Settings)
	settingsSheet:DockMargin(2, 10, 0, 0)
	settingsSheet:Dock(FILL)
	function settingsSheet:Think()
		for k, v in pairs(settingsSheet.Items) do
			if !v.Tab then continue end
			v.Tab:SetTextColor(GTawards.TextColor)
			if settingsSheet:GetActiveTab() == v.Tab then
				function v.Tab:Paint(w, h)
					draw.RoundedBox(0, 0, 0, w-4.6, h, GTawards.Color4)
				end
			else
				function v.Tab:Paint(w, h)
					draw.RoundedBox(0, 0, 0, w-4.6, h, GTawards.Color3)
				end
			end
		end
	end
	function settingsSheet.Paint()
	end

	local generalScrollPanel = vgui.Create("DScrollPanel", settingsSheet)
	generalScrollPanel:DockMargin(0, 0, 10, 10)
	generalScrollPanel:Dock(FILL)
	function generalScrollPanel:Paint(w, h)
		draw.RoundedBox(0, 0, 0, w, h, GTawards.Color4)
	end
	settingsSheet:AddSheet("General", generalScrollPanel, "icon16/cog.png")

	local colorsScrollPanel = vgui.Create("DScrollPanel", settingsSheet)
	colorsScrollPanel:DockMargin(0, 0, 10, 10)
	colorsScrollPanel:Dock(FILL)
	function colorsScrollPanel:Paint(w, h)
		draw.RoundedBox(0, 0, 0, w, h, GTawards.Color4)
	end
	settingsSheet:AddSheet("Colors", colorsScrollPanel, "icon16/color_wheel.png")

	local positionScrollPanel = vgui.Create("DScrollPanel", settingsSheet)
	positionScrollPanel:DockMargin(0, 0, 10, 10)
	positionScrollPanel:Dock(FILL)
	function positionScrollPanel:Paint(w, h)
		draw.RoundedBox(0, 0, 0, w, h, GTawards.Color4)
	end
	settingsSheet:AddSheet("Position", positionScrollPanel, "icon16/arrow_out.png")

	--[[GENERAL]]--

	local onlyShowOnScoreboardLabel = vgui.Create("DLabel", generalScrollPanel) 
	onlyShowOnScoreboardLabel:SetPos(5, 5)
	onlyShowOnScoreboardLabel:SetTextColor(GTawards.TextColor)
	onlyShowOnScoreboardLabel:SetText("Only show on scoreboard")
	onlyShowOnScoreboardLabel:SizeToContents()

	local onlyShowOnScoreboardCheckBox = vgui.Create("DCheckBox", generalScrollPanel)
	onlyShowOnScoreboardCheckBox:SetPos(184, 5)
	onlyShowOnScoreboardCheckBox:SetValue(onlyShowOnScoreboard)

	local hideBarLabel = vgui.Create("DLabel", generalScrollPanel) 
	hideBarLabel:SetPos(5, 25)
	hideBarLabel:SetTextColor(GTawards.TextColor)
	hideBarLabel:SetText("Hide Bar")
	hideBarLabel:SizeToContents()

	local hideBarCheckBox = vgui.Create("DCheckBox", generalScrollPanel)
	hideBarCheckBox:SetPos(184, 25)
	hideBarCheckBox:SetValue(hideBar)

	local sessionTimeLabel = vgui.Create("DLabel", generalScrollPanel) 
	sessionTimeLabel:SetPos(5, 45)
	sessionTimeLabel:SetTextColor(GTawards.TextColor)
	sessionTimeLabel:SetText("Show session Time")
	sessionTimeLabel:SizeToContents()

	local sessionTimeCheckBox = vgui.Create("DCheckBox", generalScrollPanel)
	sessionTimeCheckBox:SetPos(184, 45)
	sessionTimeCheckBox:SetValue(sessionTime)

	local cornerRadiusLabel = vgui.Create("DLabel", generalScrollPanel) 
	cornerRadiusLabel:SetPos(5, 65)
	cornerRadiusLabel:SetTextColor(GTawards.TextColor)
	cornerRadiusLabel:SetText("Bar Corner Radius")
	cornerRadiusLabel:SizeToContents()

	local cornerRadiusNumber = vgui.Create("DNumberWang", generalScrollPanel)
	cornerRadiusNumber:SetPos(184, 65)
	cornerRadiusNumber:SetValue(cornerRadius)

	local importLabel = vgui.Create("DLabel", generalScrollPanel) 
	importLabel:SetPos(5, 85)
	importLabel:SetTextColor(GTawards.TextColor)
	importLabel:SetText("Import")
	importLabel:SizeToContents()

	local importComboBox = vgui.Create("DComboBox", generalScrollPanel) 
	importComboBox:SetPos(184, 85)
	importComboBox:SetSize(155, 20)
	importComboBox:AddChoice("None")
	importComboBox:AddChoice("Time Rewards")
	importComboBox:AddChoice("UTime")
	importComboBox:SetValue("None")

	--[[COLORS]]--
	local colorSelectorLabel = vgui.Create("DLabel", colorsScrollPanel)
	colorSelectorLabel:SetPos(5, 5)
	colorSelectorLabel:SetTextColor(GTawards.TextColor)
	colorSelectorLabel:SetText("Element to change color for (only one edit at once!):")
	colorSelectorLabel:SizeToContents() 

	local colorSelector = vgui.Create("DComboBox", colorsScrollPanel)
	colorSelector:SetSize(156, 20)
	colorSelector:SetPos(5, 25)
	colorSelector:SetValue("Select element")
	colorSelector:AddChoice("Bar")
	colorSelector:AddChoice("Background top")
	colorSelector:AddChoice("Background bottom")
	colorSelector:AddChoice("Font top")
	colorSelector:AddChoice("Font bot")

	local colorMixer = vgui.Create("DColorMixer", colorsScrollPanel)
	colorMixer:SetSize(329, 85)
	colorMixer:SetPos(5, 55)
	colorMixer:SetPalette(false)	
	colorMixer:SetAlphaBar(true)
	colorMixer:SetWangs(false)
	colorMixer:SetColor(Color(255, 255, 255, 255))

	function colorSelector.OnSelect(panel, index, value)
		if value == "Bar" then 
			colorMixer:SetColor(barColor)
		elseif value == "Background top" then
			colorMixer:SetColor(bgColorTop)
		elseif value == "Background bottom" then
			colorMixer:SetColor(bgColorBot)
		elseif value == "Font top" then
			colorMixer:SetColor(fontColorTop)
		elseif value == "Font bot" then
			colorMixer:SetColor(fontColorBot)
		end
	end

	--[[POSITION]]-- {{ user_id }}
	local xrelativeLabel = vgui.Create("DLabel", positionScrollPanel)
	xrelativeLabel:SetPos(5, 5)
	xrelativeLabel:SetTextColor(GTawards.TextColor)
	xrelativeLabel:SetText("XPadding is relative to:")
	xrelativeLabel:SizeToContents() 

	local xrelativeSelector = vgui.Create("DComboBox", positionScrollPanel)
	xrelativeSelector:SetSize(155, 20)
	xrelativeSelector:SetPos(5, 25)
	xrelativeSelector:AddChoice("Left of screen")
	xrelativeSelector:AddChoice("Right of screen")

	local xpaddingLabel = vgui.Create("DLabel", positionScrollPanel)
	xpaddingLabel:SetPos(184, 5)
	xpaddingLabel:SetTextColor(GTawards.TextColor)
	xpaddingLabel:SetText("XPadding:")
	xpaddingLabel:SizeToContents() 

	local xpaddingSelector = vgui.Create("DNumberWang", positionScrollPanel)
	xpaddingSelector:SetSize(155, 20)
	xpaddingSelector:SetPos(184, 25)
	xpaddingSelector:SetMin(0)
	xpaddingSelector:SetMax(ScrW())

	local yrelativeLabel = vgui.Create("DLabel", positionScrollPanel)
	yrelativeLabel:SetPos(5, 55)
	yrelativeLabel:SetTextColor(GTawards.TextColor)
	yrelativeLabel:SetText("YPadding is relative to:")
	yrelativeLabel:SizeToContents() 

	local yrelativeSelector = vgui.Create("DComboBox", positionScrollPanel)
	yrelativeSelector:SetSize(155, 20)
	yrelativeSelector:SetPos(5, 75)
	yrelativeSelector:AddChoice("Top of screen")
	yrelativeSelector:AddChoice("Bottom of screen")

	local ypaddingLabel = vgui.Create("DLabel", positionScrollPanel)
	ypaddingLabel:SetPos(184, 55)
	ypaddingLabel:SetTextColor(GTawards.TextColor)
	ypaddingLabel:SetText("YPadding:")
	ypaddingLabel:SizeToContents() 

	local ypaddingSelector = vgui.Create("DNumberWang", positionScrollPanel)
	ypaddingSelector:SetSize(155, 20)
	ypaddingSelector:SetPos(185, 75)
	ypaddingSelector:SetMin(0)
	ypaddingSelector:SetMax(ScrH())

	local xsizeLabel = vgui.Create("DLabel", positionScrollPanel)
	xsizeLabel:SetPos(5, 105)
	xsizeLabel:SetTextColor(GTawards.TextColor)
	xsizeLabel:SetText("Width (multiplicated with screen's width-number between 0 and 1):")
	xsizeLabel:SizeToContents() 

	local xsizeSelector = vgui.Create("DNumberWang", positionScrollPanel)
	xsizeSelector:SetSize(155, 20)
	xsizeSelector:SetPos(5, 125)
	xsizeSelector:SetMinMax(0, 1)
	xsizeSelector:SetFraction(0.1)

	local apply = vgui.Create("DButton", adminMenu_Settings)
	apply:DockMargin(3, 0, 10, 10)
	apply:Dock(BOTTOM)
	apply:SetTextColor(GTawards.TextColor)
	apply:SetText("Apply Changes")
	function apply:Paint(w, h)
		draw.RoundedBox(0, 1, 1, w-2, 22, GTawards.Color2)
		draw.RoundedBox(0, 0, 24, w-2, h-24-2, GTawards.Color1)

		surface.SetDrawColor(0, 0, 0, 180)
		surface.DrawOutlinedRect(0, 0, w, h)
	end
	function apply:DoClick()
		local function UpdateSetting(setting, value)
			net.Start("GTawards.SetSetting")
				net.WriteString(setting)
				net.WriteString(value)
				net.WriteBool(true)
			net.SendToServer()
		end

		UpdateSetting("onlyShowOnScoreboard", tostring(onlyShowOnScoreboardCheckBox:GetChecked()))
		UpdateSetting("hideBar", tostring(hideBarCheckBox:GetChecked()))
		UpdateSetting("sessionTime", tostring(sessionTimeCheckBox:GetChecked()))
		UpdateSetting("cornerRadius", tonumber(cornerRadiusNumber:GetValue()))

		if importComboBox:GetValue() == "Time Rewards" then
			UpdateSetting("importTR", "true")
			UpdateSetting("importUTime", "false")
		elseif importComboBox:GetValue() == "UTime" then
			UpdateSetting("importTR", "false")
			UpdateSetting("importUTime", "true")
		else
			UpdateSetting("importTR", "false")
			UpdateSetting("importUTime", "false")
		end

		--convert colorTable to string
		local colorTable  = colorMixer:GetColor()
		local colorString = tostring(colorTable["r"])..", "..tostring(colorTable["g"])..", "..tostring(colorTable["b"]..", "..tostring(colorTable["a"]))

		if colorSelector:GetValue() == "Background bottom" then
			UpdateSetting("bgColorBot", colorString)
		elseif colorSelector:GetValue() == "Background top" then
			UpdateSetting("bgColorTop", colorString)
		elseif colorSelector:GetValue() == "Bar" then
			UpdateSetting("barColor", colorString)
		elseif colorSelector:GetValue() == "Font bot" then
			UpdateSetting("fontColorBot", colorString)
		elseif colorSelector:GetValue() == "Font top" then
			UpdateSetting("fontColorTop", colorString)
		end

		if xrelativeSelector:GetValue() == "Left of screen" then
			UpdateSetting("xrelative", "left")
		elseif xrelativeSelector:GetValue() == "Right of screen" then
			UpdateSetting("xrelative", "right")
		end

		UpdateSetting("xpadding", tostring(xpaddingSelector:GetValue()))

		if yrelativeSelector:GetValue() == "Bottom of screen" then
			UpdateSetting("yrelative", "bottom")
		elseif yrelativeSelector:GetValue() == "Top of screen" then
			UpdateSetting("yrelative", "top")
		end

		UpdateSetting("ypadding", tostring(ypaddingSelector:GetValue()))
		
		if tonumber(xsizeSelector:GetValue()) > 1 then 
			xsizeSelector:SetValue(1) 
		end
		
		UpdateSetting("xsize", tostring(xsizeSelector:GetValue()))

		net.Start("GTawards.GetSettings")
		net.SendToServer()
	end

	net.Receive("GTawards.GetSettings", function()
		local settings  = net.ReadTable()

		sessionTime			 = tobool(settings["sessionTime"])
		onlyShowOnScoreboard = tobool(settings["onlyShowOnScoreboard"])
		hideBar 			 = tobool(settings["hideBar"])
		importUTime			 = tobool(settings["importUTime"])
		importTR			 = tobool(settings["importTR"])
		barColor 			 = string.ToColor(string.Replace(tostring(settings["barColor"]), ",", ""))
		bgColorTop			 = string.ToColor(string.Replace(tostring(settings["bgColorTop"]), ",", ""))
		bgColorBot 			 = string.ToColor(string.Replace(tostring(settings["bgColorBot"]), ",", ""))
		cornerRadius		 = tonumber(settings["cornerRadius"])
		xrelative 			 = tostring(settings["xrelative"])
		yrelative 			 = tostring(settings["yrelative"])
		xpadding 			 = tonumber(settings["xpadding"])
		ypadding 			 = tonumber(settings["ypadding"])
		xsize 				 = tonumber(settings["xsize"])
		fontColorTop		 = string.ToColor(string.Replace(tostring(settings["fontColorTop"]), ",", "").." 255")
		fontColorBot		 = string.ToColor(string.Replace(tostring(settings["fontColorBot"]), ",", "").." 255")

		sessionTimeCheckBox:SetChecked(sessionTime)
		onlyShowOnScoreboardCheckBox:SetChecked(onlyShowOnScoreboard)
		hideBarCheckBox:SetChecked(hideBar)
		cornerRadiusNumber:SetValue(cornerRadius)

		if importUTime then 
			importComboBox:SetValue("UTime")
		elseif importTR then 
			importComboBox:SetValue("Time Rewards")
		else
			importComboBox:SetValue("None")
		end

		if colorSelector:GetValue() == "Bar" then 
			colorMixer:SetColor(barColor)
		elseif colorSelector:GetValue() == "Background top" then
			colorMixer:SetColor(bgColorTop)
		elseif colorSelector:GetValue() == "Background bottom" then
			colorMixer:SetColor(bgColorBot)
		elseif colorSelector:GetValue() == "Font top" then
			colorMixer:SetColor(fontColorTop)
		elseif colorSelector:GetValue() == "Font bot" then
			colorMixer:SetColor(fontColorBot)
		end

		if xrelative == "right" then
			xrelativeSelector:SetValue("Right of screen")
		elseif xrelative == "left" then 
			xrelativeSelector:SetValue("Left of screen")
		end

		if yrelative == "top" then
			yrelativeSelector:SetValue("Top of screen")
		elseif yrelative == "bottom" then 
			yrelativeSelector:SetValue("Bottom of screen")
		end

		xpaddingSelector:SetValue(xpadding)
		ypaddingSelector:SetValue(ypadding)
		xsizeSelector:SetValue(xsize)
	end)

	adminMenu:MakePopup()

	net.Start("GTawards.FetchRanks")
	net.SendToServer()

	net.Start("GTawards.FetchPlayerData")
		net.WriteTable(GetAllSteamIDs())
	net.SendToServer()

	net.Start("GTawards.GetSettings")
	net.SendToServer()

	net.Start("GTawards.FetchServers")
	net.SendToServer()
end

net.Receive("GTawards.OpenMenu", function()
	GTawards:AdminMenu_Open()
end)
--addons/hbombs_base/lua/autorun/hb_emp_soundlist.lua:

if SERVER then
	AddCSLuaFile();
emp_soundlist = {
	"gbombs_5/explosions/emp_wave/emp_discharge.mp3",
	"ambient/energy/newspark01.wav",
	"ambient/energy/newspark02.wav",
	"ambient/energy/newspark03.wav",
	"ambient/energy/newspark04.wav",
	"ambient/energy/newspark05.wav",
	"ambient/energy/newspark06.wav",
	"ambient/energy/newspark07.wav",
	"ambient/energy/newspark08.wav",
	"ambient/energy/newspark09.wav",
	"ambient/energy/newspark10.wav",
	"ambient/energy/newspark11.wav",
	}

end

--lua/vgui/stackercontrolpresets.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
--	PANEL:OpenPresetEditor()
--
--]]--
function PANEL:OpenPresetEditor()
	if ( not self.m_strPreset ) then return end
	self.Window = vgui.Create( "StackerPresetEditor" )
	self.Window:MakePopup()
	self.Window:Center()
	self.Window:SetType( self.m_strPreset )
	self.Window:SetConVars( self.ConVars )
	self.Window:SetPresetControl( self )
end

vgui.Register( "StackerControlPresets", PANEL, "ControlPresets" )
--lua/vgui/stackerpreseteditor.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

local vgui = vgui
local pairs = pairs
local AccessorFunc = AccessorFunc
local GetConVarString = GetConVarString

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

AccessorFunc( PANEL, "m_ConCommands", "ConCommands" )

--[[--------------------------------------------------------------------------
--
--	PANEL:Add()
--
--]]--
function PANEL:Add()
	if ( not self.m_ConVars ) then return end
	
	local ToName = self.txtName:GetValue()
	if ( not ToName or ToName == "" ) then return end
	
	-- Todo, Handle name collision
	local tabValues = {}
	
	for k, v in pairs( self.m_ConVars ) do
		tabValues[ v.CCmd ] = GetConVarString( v.CVar )
	end
		
	presets.Add( self.m_strType, ToName, tabValues )
	self:Update()
	self.PresetList:SelectByName( ToName )
	self.txtName:SetText( "" )
	
	if ( self.m_PresetControl ) then
		self.m_PresetControl:Update()
	end
end

vgui.Register( "StackerPresetEditor", PANEL, "PresetEditor" )
--lua/autorun/jabba.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )
	
end


AddPlayerModel( "Hutt", 		                      "models/hgn/swrp/swrp/hutt_01.mdl" )

--addons/lvs_base/lua/autorun/lvs_init.lua:

LVS = istable( LVS ) and LVS or {}

LVS.VERSION = 325
LVS.VERSION_GITHUB = 0
LVS.VERSION_TYPE = ".WS"
LVS.VERSION_ADDONS_OUTDATED = false

LVS.KEYS_CATEGORIES = {}
LVS.KEYS_REGISTERED = {}
LVS.pSwitchKeys = {[KEY_1] = 1,[KEY_2] = 2,[KEY_3] = 3,[KEY_4] = 4,[KEY_5] = 5,[KEY_6] = 6,[KEY_7] = 7,[KEY_8] = 8,[KEY_9] = 9,[KEY_0] = 10}
LVS.pSwitchKeysInv = {[1] = KEY_1,[2] = KEY_2,[3] = KEY_3,[4] = KEY_4,[5] = KEY_5,[6] = KEY_6,[7] = KEY_7,[8] = KEY_8,[9] = KEY_9,[10] = KEY_0}

LVS.ThemeColor = Color(127,0,0,255)

LVS.WHEEL_BRAKE = 1
LVS.WHEEL_STEER_NONE = 2
LVS.WHEEL_STEER_FRONT = 3
LVS.WHEEL_STEER_REAR = 4

LVS.WEAPONS = {
	["DEFAULT"] = {
		Icon = Material("lvs/weapons/bullet.png"),
		Ammo = 9999,
		Delay = 0,
		HeatRateUp = 0.2,
		HeatRateDown = 0.25,
		Attack = function( ent ) end,
		StartAttack = function( ent ) end,
		FinishAttack = function( ent ) end,
		OnSelect = function( ent, old ) end,
		OnDeselect = function( ent, new ) end,
		OnThink = function( ent, active ) end,
		OnOverheat = function( ent ) end,
		OnRemove = function( ent ) end,
		OnReload = function( ent ) end,
	},
}

function LVS:GetVersion()
	return LVS.VERSION
end

function LVS:AddKey(name, category, printname, cmd, default)
	local data = {
		printname = printname,
		id = name,
		category = category,
		cmd = cmd,
	}

	if not LVS.KEYS_CATEGORIES[ category ] then
		LVS.KEYS_CATEGORIES[ category ] = {}
	end

	if SERVER then
		table.insert( LVS.KEYS_REGISTERED, data )
	else
		if default then
			if isstring( default ) then
				local Key = input.LookupBinding( default )

				if Key then
					default = input.GetKeyCode( Key )
				else
					default = 0
				end
			end
		else
			default = 0
		end

		data.default = default

		table.insert( LVS.KEYS_REGISTERED, data )

		CreateClientConVar( cmd, default, true, true )
	end
end

function LVS:CheckUpdates()
	http.Fetch("https://raw.githubusercontent.com/SpaxscE/lvs_base/main/lua/autorun/lvs_init.lua", function(contents,size) 
		local Entry = string.match( contents, "LVS.VERSION%s=%s%d+" )

		if Entry then
			LVS.VERSION_GITHUB = tonumber( string.match( Entry , "%d+" ) ) or 0
		else
			LVS.VERSION_GITHUB = 0
		end

		if LVS.VERSION_GITHUB == 0 then
			print("[LVS] - Framework: latest version could not be detected, You have Version: "..LVS:GetVersion())
		else
			if LVS:GetVersion() >= LVS.VERSION_GITHUB then
				print("[LVS] - Framework is up to date, Version: "..LVS:GetVersion())
			else
				print("[LVS] - Framework: a newer version is available! Version: "..LVS.VERSION_GITHUB..", You have Version: "..LVS:GetVersion())

				if LVS.VERSION_TYPE == ".GIT" then
					print("[LVS] - Framework: get the latest version at https://github.com/SpaxscE/lvs_base")
				else
					print("[LVS] - Framework: restart your game/server to get the latest version!")
				end

				if CLIENT then 
					timer.Simple(18, function() 
						chat.AddText( Color( 255, 0, 0 ), "[LVS] - Framework: a newer version is available!" )
					end)
				end
			end
		end

		local Delay = 0
		local addons = file.Find( "data_static/lvs/*", "GAME" )

		for _, addonFile in pairs( addons ) do
			local addonInfo = file.Read( "data_static/lvs/"..addonFile, "GAME" )

			if not addonInfo then continue end

			local data = string.Explode( "\n", addonInfo )

			local wsid = string.Replace( addonFile, ".txt", "" )
			local addon_name = wsid
			local addon_url
			local addon_version

			for _, entry in pairs( data ) do
				if string.StartsWith( entry, "url=" ) then
					addon_url = string.Replace( entry, "url=", "" )
				end

				if string.StartsWith( entry, "version=" ) then
					addon_version = string.Replace( entry, "version=", "" )
				end

				if string.StartsWith( entry, "name=" ) then
					addon_name = string.Replace( entry, "name=", "" )
				end
			end

			if not addon_url or not addon_version then continue end

			addon_version = tonumber( addon_version )

			Delay = Delay + 1.5

			timer.Simple( Delay, function()
				http.Fetch(addon_url, function(con,_) 
					local addon_entry = string.match( con, "version=%d+" )

					local addon_version_git = 0

					if addon_entry then
						addon_version_git = tonumber( string.match( addon_entry, "%d+" ) ) or 0
					end

					local wsurl = "https://steamcommunity.com/sharedfiles/filedetails/?id="..wsid

					if addon_version_git == 0 then
						print("[LVS] latest version of "..addon_name.." ( "..wsurl.." ) could not be detected, You have Version: "..addon_version)
					else
						if addon_version_git > addon_version then
							print("[LVS] - "..addon_name.." ( "..wsurl.." ) is out of date!")

							if CLIENT then 
								timer.Simple(18, function() 
									chat.AddText( Color( 255, 0, 0 ),"[LVS] - "..addon_name.." is out of date!" )
								end)
							end

							LVS.VERSION_ADDONS_OUTDATED = true

						else
							print("[LVS] - "..addon_name.." is up to date, Version: "..addon_version)
						end
					end
				end)
			end )
		end
	end)
end

function LVS:GetWeaponPreset( name )
	if not LVS.WEAPONS[ name ] then return table.Copy( LVS.WEAPONS["DEFAULT"] ) end

	return table.Copy( LVS.WEAPONS[ name ] )
end

function LVS:AddWeaponPreset( name, data )
	if not isstring( name ) or not istable( data ) then return end

	LVS.WEAPONS[ name ] = data
end

function LVS:GetVehicleTypes()
	local VehicleTypes = {}

	for s, v in pairs( scripted_ents.GetList() ) do
		if not v.t or not isfunction( v.t.GetVehicleType ) then continue end

		local vehicletype = v.t:GetVehicleType()

		if not isstring( vehicletype ) or string.StartsWith( vehicletype, "LBase" ) or table.HasValue( VehicleTypes, vehicletype ) then continue end

		table.insert( VehicleTypes, vehicletype )
	end

	return VehicleTypes
end

AddCSLuaFile("lvs_framework/init.lua")
include("lvs_framework/init.lua")
--addons/lvs_base/lua/lvs_framework/autorun/lvs_confics.lua:
-- This is the important stuff for servers

-- Using these settings are recommended to get the best experience for your players that you want
hook.Add("Initialize","AuraDebugUpdateGlobals", function()
	aura_lvs_overhaul_config_cvarDisableAllClient = CreateClientConVar( "lvs_disable_all_overhaul_settings", 0, true, false) -- Can disable everything for a client, don't need to touch this, just for organization
end)

aura_lvs_overhaul_config_ui_color = Color(0,127,255,200)

aura_lvs_overhaul_config_open_menu_command 					= "!lvsConfig" -- Set this to whatever you want the command to be to open the config menu, if you dont want to use this file -- Default: !lvsMenu (Caps does not matter)

-- These next ones are for ALL clients, should these be false, the corrisponding feature will be disabled

aura_lvs_overhaul_config_enable_friendly_name_crosshair		= aura_lvs_overhaul_config_enable_friendly_name_crosshair 	or 		true -- Enables players to see friendly target ship pilot/driver name in crosshair -- Default: True
aura_lvs_overhaul_config_enable_friendly_hp_crosshair		= aura_lvs_overhaul_config_enable_friendly_hp_crosshair 	or 		true -- Enables players to see friendly target ship HP in crosshair -- Default: True
aura_lvs_overhaul_config_enable_HUD						 	= aura_lvs_overhaul_config_enable_HUD 						or 		true -- Enables HUD for all people in vehicles -- Default: True
aura_lvs_overhaul_config_enable_voice_interactions		 	= aura_lvs_overhaul_config_enable_voice_interactions 		or 		true -- Enables voice line interaction for all people in vehicles -- Default: True
aura_lvs_overhaul_config_enable_alerts					 	= aura_lvs_overhaul_config_enable_alerts 					or 		true -- Enables alerts/warnings for all people in vehicles -- Default: True
aura_lvs_overhaul_config_enable_rolling_with_ship			= aura_lvs_overhaul_config_enable_rolling_with_ship 		or 		true -- Enables players camera to roll with vehicle while in it -- Default: True
aura_lvs_overhaul_config_enable_radar					 	= aura_lvs_overhaul_config_enable_radar 					or 		true -- Enables radar for all people in vehicles -- Default: True
aura_lvs_overhaul_config_enable_hp_and_shield				= aura_lvs_overhaul_config_enable_hp_and_shield 			or		true -- Enables health and shield visuals for all people in vehicles -- Default: True
aura_lvs_overhaul_config_enable_hostile_alerts				= aura_lvs_overhaul_config_enable_hostile_alerts 			or 		true -- Enables alerts about number of hostiles targeting player for all people in vehicles -- Default: True

---------------------------------------------------------------------------------------------------------
--addons/lvs_base/lua/lvs_framework/autorun/lvs_entitytracker.lua:
LVS.VehiclesStored = LVS.VehiclesStored or {}
LVS.NPCsStored = LVS.NPCsStored or {}

function LVS:GetNPCs()
	for index, ent in pairs( LVS.NPCsStored ) do
		if not IsValid( ent ) then
			LVS.NPCsStored[ index ] = nil
		end
	end

	return LVS.NPCsStored
end

function LVS:GetVehicles()
	for index, ent in pairs( LVS.VehiclesStored ) do
		if not IsValid( ent ) then
			LVS.VehiclesStored[ index ] = nil
		end
	end

	return LVS.VehiclesStored
end

local Teams = {
	["npc_breen"] = 1,
	["npc_combine_s"] = 1,
	["npc_combinedropship"] = 1,
	["npc_combinegunship"] = 1,
	["npc_crabsynth"] = 1,
	["npc_cscanner"] = 1,
	["npc_helicopter"] = 1,
	["npc_manhack"] = 1,
	["npc_metropolice"] = 1,
	["npc_mortarsynth"] = 1,
	["npc_sniper"] = 1,
	["npc_stalker"] = 1,
	["npc_strider"] = 1,
	["npc_hunter"] = 1,

	["monster_human_grunt"] = 1,
	["monster_human_assassin"] = 1,
	["monster_sentry"] = 1,

	["npc_kleiner"] = 2,
	["npc_monk"] = 2,
	["npc_mossman"] = 2,
	["npc_vortigaunt"] = 2,
	["npc_alyx"] = 2,
	["npc_barney"] = 2,
	["npc_citizen"] = 2,
	["npc_dog"] = 2,
	["npc_eli"] = 2,
	["monster_scientist"] = 2,
	["monster_barney"] = 2,

	["npc_zombine"] = 3,
	["npc_fastzombie"] = 3,
	["npc_headcrab"] = 3,
	["npc_headcrab_black"] = 3,
	["npc_headcrab_fast"] = 3,
	["npc_antlion"] = 3,
	["npc_antlionguard"] = 3,
	["npc_zombie"] = 3,
	["npc_zombie_torso"] = 3,
	["npc_poisonzombie"] = 3,
	["monster_alien_grunt"] = 3,
	["monster_alien_slave"] = 3,
	["monster_gargantua"] = 3,
	["monster_bullchicken"] = 3,
	["monster_headcrab"] = 3,
	["monster_babycrab"] = 3,
	["monster_zombie"] = 3,
	["monster_houndeye"] = 3,
	["monster_nihilanth"] = 3,
	["monster_bigmomma"] = 3,
	["monster_babycrab"] = 3,
}
function LVS:GetNPCRelationship( npc_class )
	return Teams[ npc_class ] or 0
end

hook.Add( "OnEntityCreated", "!!!!lvsEntitySorter", function( ent )
	timer.Simple( 2, function() 
		if not IsValid( ent ) then return end

		if isfunction( ent.IsNPC ) and ent:IsNPC() then
			table.insert( LVS.NPCsStored, ent )

			if SERVER then
				hook.Run( "LVS.UpdateRelationship", ent )
			end
		end

		if ent.LVS then 
			if CLIENT and ent.PrintName then
				language.Add( ent:GetClass(), ent.PrintName)
			end

			table.insert( LVS.VehiclesStored, ent )

			if SERVER then
				LVS:FixVelocity()

				hook.Run( "LVS.UpdateRelationship", ent )
			end
		end
	end )
end )
--addons/lvs_base/lua/lvs_framework/autorun/lvs_pod.lua:

local meta = FindMetaTable( "Vehicle" )

if CLIENT then
	function meta:lvsGetPodIndex()
		local id = self:GetNWInt( "pPodIndex", -1 )

		if id ~= -1 then return id end

		-- code below is bandaid fix for ent:GetNWInt taking up to 5 minutes to update on client...

		local col = self:GetColor()
		local id_by_color = col.r

		-- 255 or 0 is suspicous...
		if id_by_color == 255 or id_by_color == 0 then return -1 end

		-- lets just assume its right... right?
		if id_by_color == col.g and id_by_color == col.b then
			return id_by_color
		end

		return -1
	end

	function meta:GetCameraHeight()
		if not self._lvsCamHeight then
			self._lvsCamHeight = 0

			net.Start("lvs_camera")
				net.WriteEntity( self )
			net.SendToServer()
		end

		return self._lvsCamHeight
	end

	function meta:SetCameraHeight( newheight )
		self._lvsCamHeight = newheight
	end

	function meta:lvsGetWeapon()
		if self._lvsWeaponEntChecked then
			return self._lvsWeaponEnt
		end

		local found = false

		for _, ent in ipairs( self:GetChildren() ) do
			if not ent.LVS_GUNNER then continue end

			self._lvsWeaponEntChecked = true
			self._lvsWeaponEnt = ent

			found = true

			break
		end

		return found and self._lvsWeaponEnt or NULL
	end

	net.Receive( "lvs_select_weapon", function( length)
		local ply = LocalPlayer()
		local vehicle = ply:lvsGetVehicle()

		if not IsValid( vehicle ) or vehicle:GetDriver() ~= ply then return end

		vehicle._SelectActiveTime = CurTime() + 2
	end)

	
	net.Receive( "lvs_camera", function( length, ply )
		local pod = net.ReadEntity()

		if not IsValid( pod ) then return end

		pod:SetCameraHeight( net.ReadFloat() )
	end)

	return
end

function meta:lvsGetPodIndex()
	return self:GetNWInt( "pPodIndex", -1 )
end

function meta:GetCameraHeight()
	return (self._lvsCamHeight or 0)
end

util.AddNetworkString( "lvs_select_weapon" )
util.AddNetworkString( "lvs_camera" )

net.Receive( "lvs_select_weapon", function( length, ply )
	if not IsValid( ply ) then return end

	local ID = net.ReadInt( 5 )
	local Increment = net.ReadBool()

	local base = ply:lvsGetWeaponHandler()

	if not IsValid( base ) then return end

	if Increment then
		base:SelectWeapon( base:GetSelectedWeapon() + ID )
	else
		base:SelectWeapon( ID )
	end
end)

net.Receive( "lvs_camera", function( length, ply )
	if not IsValid( ply ) then return end

	local pod = net.ReadEntity()

	if not IsValid( pod ) then return end

	net.Start("lvs_camera")
		net.WriteEntity( pod )
		net.WriteFloat( pod:GetCameraHeight() )
	net.Send( ply )
end)

function meta:SetCameraHeight( newheight )
	self._lvsCamHeight = newheight

	net.Start("lvs_camera")
		net.WriteEntity( self )
		net.WriteFloat( newheight )
	net.Broadcast()
end

function meta:lvsAddWeapon( ID )
	if IsValid( self._lvsWeaponEnt ) then
		return self._lvsWeaponEnt
	end

	local weapon = ents.Create( "lvs_base_gunner" )

	if not IsValid( weapon ) then return NULL end

	weapon:SetPos( self:LocalToWorld( Vector(0,0,33.182617) ) ) -- location exactly where ply:GetShootPos() is. This will make AI-Tracing easier.
	weapon:SetAngles( self:LocalToWorldAngles( Angle(0,90,0) ) )
	weapon:SetOwner( self )
	weapon:Spawn()
	weapon:Activate()
	weapon:SetParent( self )
	weapon:SetPodIndex( ID )
	weapon:SetDriverSeat( self )

	self._lvsWeaponEnt = weapon

	weapon:SetSelectedWeapon( 1 )

	return weapon
end

function meta:lvsGetWeapon()
	return self._lvsWeaponEnt
end

function meta:lvsSetPodIndex( index )
	-- garbage networking
	self:SetNWInt( "pPodIndex", index )

	self:SetMaterial( "null" )

	-- more reliable networking, lol
	self:SetColor( Color( index, index, index, 0 ) )
end

--addons/playermodels/lua/autorun/master_association.lua:
-- Emptied to remove Model from https://steamcommunity.com/sharedfiles/filedetails/?id=889827473
--lua/autorun/mosmesric_v2_bacta.lua:
-- Created by Oninoni
-- Based on Code by Syphadias
-- Huge thanks to them!

-- This has to match the map Name
if not (game.GetMap() == "rp_mos_mesric_v2_2" or game.GetMap() == "rp_mos_mesric_v2_1") then return end

-- The Ammount of Bacta Tanks that are used
local bactaCount = 2

-- The Name of the prop_vehicle_prisoner_pod without its suffix (e.g. bacta1, bacta2, ... -> bacta)
local entityName = "bacta"

-- Bacta Seat Don't fricking touch anything below this line!
local Category = "Map Utilities"
local function StandAnimation( vehicle, player )
	return player:SelectWeightedSequence( ACT_GMOD_NOCLIP_LAYER )
end
local V = {
    Name = "Bacta Tank Seat",
	Model = "models/lordtrilobite/starwars/props/bactatankb.mdl",
    Class = "prop_vehicle_prisoner_pod",
    Category = Category,
 
    Author = "Syphadias, Oninoni",
    Information = "Seat with custom animation",
    Offset = 16,
 
    KeyValues = {
        vehiclescript = "scripts/vehicles/prisoner_pod.txt",
        limitview = "0"
    },
    Members = {
        HandleAnimation = StandAnimation
    }
}
list.Set( "Vehicles", "bacta_seat", V )
 
if SERVER then
    local seatCache = {}
    local function IsValidSeat(seat)
        local seat = seatCache[seat]
     
        if seat and IsValid(seat) then
			return true
        end
     
        return false
    end
	
	hook.Add("Think", "UpdateseatPosBacta", function()
		for i = 1, bactaCount, 1 do
			if !IsValidSeat(i) then
				seatCache[i] = ents.FindByName(entityName .. i)[1]

				if !IsValidSeat(i) then
					continue
				end
			end

			seatCache[i]:SetVehicleClass("bacta_seat")
		end
	end)
end
--addons/openpermissions/lua/openpermissions/thirdparty/pon.lua:
--[[

DEVELOPMENTAL VERSION;

VERSION 1.2.2
Copyright thelastpenguin™

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author, thelastpenguin™, if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above still applies to the modified code.

	The author is not held responsible for any damages incured from the use of pon, you use it at your own risk.

DATA TYPES SUPPORTED:
 - tables  - 		k,v - pointers
 - strings - 		k,v - pointers
 - numbers -		k,v
 - booleans- 		k,v
 - Vectors - 		k,v
 - Angles  -		k,v
 - Entities- 		k,v
 - Players - 		k,v

CHANGE LOG
V 1.1.0
 - Added Vehicle, NPC, NextBot, Player, Weapon
V 1.2.0
 - Added custom handling for k,v tables without any array component.
V 1.2.1
 - fixed deserialization bug.

THANKS TO...
 - VERCAS for the inspiration.
]]


local pon = {};

local type, count = type, table.Count ;
local tonumber = tonumber ;
local format = string.format;
do
	local type, count = type, table.Count ;
	local tonumber = tonumber ;
	local format = string.format;

	local encode = {};

	local tryCache ;

	local cacheSize = 0;

	encode['table'] = function( self, tbl, output, cache )

		if( cache[ tbl ] )then
			output[ #output + 1 ] = format('(%x)',  cache[tbl] );
			return ;
		else
			cacheSize = cacheSize + 1;
			cache[ tbl ] = cacheSize;
		end


    local first = next(tbl, nil)
    local predictedNumeric = 1
    local lastKey = nil
    -- starts with a numeric dealio
    if first == 1 then
      output[#output + 1] = '{'

      for k,v in next, tbl do
        if k == predictedNumeric then
          predictedNumeric = predictedNumeric + 1

          local tv = type(v)
          if tv == 'string' then
            local pid = cache[v]
            if pid then
              output[#output + 1] = format('(%x)', pid)
            else
              cacheSize = cacheSize + 1
              cache[v] = cacheSize
              self.string(self, v, output, cache)
            end
          else
            self[tv](self, v, output, cache)
          end

        else
          break
        end
      end

			predictedNumeric = predictedNumeric - 1
    else
      predictedNumeric = nil
    end

    if predictedNumeric == nil then
      output[#output + 1] = '[' -- no array component
    else
      output[#output + 1] = '~' -- array component came first so shit needs to happen
    end

    for k, v in next, tbl, predictedNumeric do
      local tk, tv = type(k), type(v)

      -- WRITE KEY
      if tk == 'string' then
        local pid = cache[ k ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ k ] = cacheSize;

          self.string( self, k, output, cache );
        end
      else
        self[tk](self, k, output, cache)
      end

      -- WRITE VALUE
      if( tv == 'string' )then
        local pid = cache[ v ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ v ] = cacheSize;

          self.string( self, v, output, cache );
        end
      else
        self[ tv ]( self, v, output, cache );
      end
    end

    output[#output + 1] = '}'
	end
	--    ENCODE STRING
	local gsub = string.gsub ;
	encode['string'] = function( self, str, output )
		--if tryCache( str, output ) then return end
		local estr, count = gsub( str, ";", "\\;");
		if( count == 0 )then
			output[ #output + 1 ] = '\''..str..';';
		else
			output[ #output + 1 ] = '"'..estr..'";';
		end
	end
	--    ENCODE NUMBER
	encode['number'] = function( self, num, output )
		if num%1 == 0 then
			if num < 0 then
				output[ #output + 1 ] = format( 'x%x;', -num );
			else
				output[ #output + 1 ] = format('X%x;', num );
			end
		else
			output[ #output + 1 ] = tonumber( num )..';';
		end
	end
	--    ENCODE BOOLEAN
	encode['boolean'] = function( self, val, output )
		output[ #output + 1 ] = val and 't' or 'f'
	end
	--    ENCODE VECTOR
	encode['Vector'] = function( self, val, output )
		output[ #output + 1 ] = ('v'..val.x..','..val.y)..(','..val.z..';');
	end
	--    ENCODE ANGLE
	encode['Angle'] = function( self, val, output )
		output[ #output + 1 ] = ('a'..val.p..','..val.y)..(','..val.r..';');
	end
	encode['Entity'] = function( self, val, output )
		output[ #output + 1] = 'E'..(IsValid( val ) and (val:EntIndex( )..';') or '#');
	end
	encode['Player']  = encode['Entity'];
	encode['Vehicle'] = encode['Entity'];
	encode['Weapon']  = encode['Entity'];
	encode['NPC']     = encode['Entity'];
	encode['NextBot'] = encode['Entity'];
	encode['PhysObj'] = encode['Entity'];

	encode['nil'] = function()
		output[ #output + 1 ] = '?';
	end
	encode.__index = function( key )
		ErrorNoHalt('Type: '..key..' can not be encoded. Encoded as as pass-over value.');
		return encode['nil'];
	end

	do
		local empty, concat = table.Empty, table.concat ;
		function pon.encode( tbl )
			local output = {};
			cacheSize = 0;
			encode[ 'table' ]( encode, tbl, output, {} );
			local res = concat( output );

			return res;
		end
	end
end

do
	local tonumber = tonumber ;
	local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode ;
	local Vector, Angle, Entity = Vector, Angle, Entity ;

	local decode = {};
	decode['{'] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tv = sub( str, index, index );
			if( not tv or tv == '~' )then
				index = index + 1;
				break ;
			end
			if( tv == '}' )then
				return index + 1, cur;
			end

			-- READ THE VALUE
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );
			cur[ k ] = v;

			k = k + 1;
		end

		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY

			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end
	decode['['] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY
			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );
			if not k then continue end

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			if not self[tv] then
				print('did not find type: '..tv)
			end
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end

	-- STRING
	decode['"'] = function( self, index, str, cache )
		local finish = find( str, '";', index, true );
		local res = gsub( sub( str, index, finish - 1 ), '\\;', ';' );
		index = finish + 2;

		cache[ #cache + 1 ] = res;
		return index, res;
	end
	-- STRING NO ESCAPING NEEDED
	decode['\''] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local res = sub( str, index, finish - 1 )
		index = finish + 1;

		cache[ #cache + 1 ] = res;
		return index, res;
	end

	-- NUMBER
	decode['n'] = function( self, index, str, cache )
		index = index - 1;
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, num;
	end
	decode['0'] = decode['n'];
	decode['1'] = decode['n'];
	decode['2'] = decode['n'];
	decode['3'] = decode['n'];
	decode['4'] = decode['n'];
	decode['5'] = decode['n'];
	decode['6'] = decode['n'];
	decode['7'] = decode['n'];
	decode['8'] = decode['n'];
	decode['9'] = decode['n'];
	decode['-'] = decode['n'];
	-- positive hex
	decode['X'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end
	-- negative hex
	decode['x'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = -tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end

	-- POINTER
	decode['('] = function( self, index, str, cache )
		local finish = find( str, ')', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, cache[ num ];
	end

	-- BOOLEAN. ONE DATA TYPE FOR YES, ANOTHER FOR NO.
	decode[ 't' ] = function( self, index )
		return index, true;
	end
	decode[ 'f' ] = function( self, index )
		return index, false;
	end

	-- VECTOR
	decode[ 'v' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local vecStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', vecStr, false );
		return index, Vector( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ANGLE
	decode[ 'a' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local angStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', angStr, false );
		return index, Angle( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ENTITY
	decode[ 'E' ] = function( self, index, str, cache )
		if( str[index] == '#' )then
			index = index + 1;
			return index, NULL ;
		else
			local finish = find( str, ';', index, true );
			local num = tonumber( sub( str, index, finish - 1 ) );
			index = finish + 1;
			return index, Entity( num );
		end
	end
	-- PLAYER
	decode[ 'P' ] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, Entity( num ) or NULL;
	end
	-- NIL
	decode['?'] = function( self, index, str, cache )
		return index + 1, nil;
	end


	function pon.decode( data )
		local _, res = decode[sub(data,1,1)]( decode, 2, data, {});
		return res;
	end
end

return pon
--addons/openpermissions-config/lua/openpermissions_lua_functions.lua:
--[[

	    __                   ______                 __  _                 
	   / /   __  ______ _   / ____/_  ______  _____/ /_(_)___  ____  _____
	  / /   / / / / __ `/  / /_  / / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
	 / /___/ /_/ / /_/ /  / __/ / /_/ / / / / /__/ /_/ / /_/ / / / (__  ) 
	/_____/\__,_/\__,_/  /_/    \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/  
	                                                                      

	Welcome to the Lua functions config.
	OpenPermissions has been designed to be as customizable as possible.
	In this configuration, you can define custom Lua functions which OpenPermissions can use.

	These Lua functions can be used as Access Groups, which allow you to assign permissions to people
	who successfully pass your own custom Lua code.

]]

return {
	["canPermaProp"] = function(ply, permission_id)
		return ply:CanPermaProp()
	end,
}

--addons/openpermissions/lua/openpermissions/cl.lua:
local L = OpenPermissions.L
local Lf = OpenPermissions.Lf

local function DMenuOption_ColorIcon(option, color)
	option:SetIcon("icon16/box.png")
	function option.m_Image:Paint(w,h)
		surface.SetDrawColor(color)
		surface.DrawRect(0,0,w,h)
	end
end
local function GreenToRed_DMenu(i, max, option)
	DMenuOption_ColorIcon(option, Color(i / max * 255, 1 - (i / max) * 255, 0))
end

surface.CreateFont("OpenPermissions_14px", {
	font = "Roboto",
	size = 14,
})
surface.CreateFont("OpenPermissions_Tip", {
	font = "Roboto",
	size = 22,
})

function OpenPermissions:AddTooltip(pnl, options)
	pnl.OpenPermissions_Tooltip_OnCursorEntered = pnl.OnCursorEntered
	pnl.OpenPermissions_Tooltip_OnCursorExited = pnl.OnCursorExited

	function pnl:OnCursorEntered(...)
		pnl.OpenPermissions_Tooltip = vgui.Create("OpenPermissions.Tooltip")
		pnl.OpenPermissions_Tooltip:SetText(options.Text)
		pnl.OpenPermissions_Tooltip.VGUI_Element = pnl

		if (self.OpenPermissions_Tooltip_OnCursorEntered) then
			return self.OpenPermissions_Tooltip_OnCursorEntered(self, ...)
		end
	end

	function pnl:OnCursorExited(...)
		if (IsValid(self.OpenPermissions_Tooltip)) then
			self.OpenPermissions_Tooltip:Remove()
		end
		self.OpenPermissions_Tooltip = nil
		if (self.OpenPermissions_Tooltip_OnCursorExited) then
			return self.OpenPermissions_Tooltip_OnCursorExited(self, ...)
		end
	end
end
function OpenPermissions:RemoveTooltip(pnl)
	if (IsValid(pnl.OpenPermissions_Tooltip)) then
		pnl.OpenPermissions_Tooltip:Remove()
	end
	pnl.OpenPermissions_Tooltip = nil
	pnl.OnCursorEntered = pnl.OpenPermissions_Tooltip_OnCursorEntered
	pnl.OnCursorExited = pnl.OpenPermissions_Tooltip_OnCursorExited
end

local blur = Material("pp/blurscreen")
function OpenPermissions:OpenMenu(specific_addon)
	if (IsValid(OpenPermissions_Menu)) then
		OpenPermissions_Menu:Close()
	end

	OpenPermissions_Menu = vgui.Create("DFrame")

	local AccessGroups
	local PermissionsSave

	local Menu = OpenPermissions_Menu
	Menu:SetSize(850,500)
	Menu:SetTitle("OpenPermissions")
	Menu:SetIcon("icon16/shield.png")
	Menu:Center()
	Menu:MakePopup()

	local Tabs = vgui.Create("DPropertySheet", Menu)
	Tabs:Dock(FILL)

	local PermissionsTab = vgui.Create("DPanel", Tabs)
	PermissionsTab.Paint = nil

		local AccessGroupsDivider = vgui.Create("OpenPermissions.HorizontalDivider", PermissionsTab)
		AccessGroupsDivider:Dock(FILL)
		AccessGroupsDivider:SetDividerWidth(5)
		AccessGroupsDivider:SetLeftWidth(200)
		AccessGroupsDivider:SetRightMin(465)
		AccessGroupsDivider:SetLeftMin(150)

		local AddonsContainer = vgui.Create("OpenPermissions.ColumnLayout", AccessGroupsDivider)
		AccessGroupsDivider:SetRight(AddonsContainer)
		AddonsContainer:SetColumns(OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW, OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW, OpenPermissions_COLUMN_LAYOUT_COLUMN_GROW)
		AddonsContainer:SetPaddings(5,5)

		local AddonContentContainer = vgui.Create("DPanel", PermissionsTab)
		AddonContentContainer.Paint = nil
		AddonContentContainer:SetVisible(false)
		AddonContentContainer:Dock(FILL)
		AddonContentContainer:DockMargin(5,0,0,0)

			local AddonContent = vgui.Create("DPropertySheet", AddonContentContainer)
			AddonContent:Dock(FILL)
			function AddonContent:PaintOver(w,h)
				if (not self.ShowOverlay) then return end
				local x,y = self:LocalToScreen(0,0)
				local scrW,scrH = ScrW(), ScrH()
				surface.SetDrawColor(255,255,255)
				surface.SetMaterial(blur)
				for i=1,2 do
					blur:SetFloat("$blur", (i / 2) * 2)
					blur:Recompute()
					render.UpdateScreenEffectTexture()
					surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
				end

				surface.SetDrawColor(0,0,0,240)
				surface.DrawRect(0,0,w,h)

				draw.SimpleTextOutlined(L"select_an_access_group", "OpenPermissions_Tip", w / 2, h / 2, OpenPermissions.COLOR_WHITE, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 2, OpenPermissions.COLOR_BLACK)
			end

			local PermissionsContent = vgui.Create("OpenPermissions.HorizontalDivider", AddonContent)
			PermissionsContent:SetDividerWidth(5)
			PermissionsContent:SetRightMin(150)
			PermissionsContent:SetLeftMin(150)
			PermissionsContent.Paint = nil

				local PermissionsTree = vgui.Create("OpenPermissions.Tree", PermissionsContent)

				local PropertiesContent = vgui.Create("OpenPermissions.ScrollPanel", PermissionsContent)
				PropertiesContent:DockMargin(5,0,0,0)
				PropertiesContent:SetWide(150)
				PropertiesContent:SetDrawBackground(true)
				function PropertiesContent:AddProperty(options, indent_level, no_checkbox)
					local permission_row = vgui.Create("DPanel", PropertiesContent)
					permission_row.Paint = nil
					permission_row:Dock(TOP)
					permission_row:SetTall(16)
					permission_row:DockMargin(5 + ((indent_level or 0) * (16 + 5)),5,5,0)

					OpenPermissions:AddTooltip(permission_row, {Text = options.Tip or options.Label})

					local checkbox
					if (not no_checkbox) then
						permission_row:SetMouseInputEnabled(true)
						permission_row:SetCursor("hand")

						checkbox = vgui.Create("OpenPermissions.Checkbox", permission_row)
						checkbox:SetCrossable(true)
						checkbox:Dock(LEFT)
						checkbox:DockMargin(0,0,5,0)

						function permission_row:OnMouseReleased(m)
							if (m == MOUSE_LEFT) then
								checkbox:DoClick()
							elseif (m == MOUSE_RIGHT) then
								checkbox:DoRightClick()
							end
						end
					end

					if (options.Icon) then
						local icon = vgui.Create("DImage", permission_row)
						icon:Dock(LEFT)
						icon:SetSize(16,16)
						icon:DockMargin(0,0,5,0)
						icon:SetImage(options.Icon)
						icon:SetMouseInputEnabled(false)
					elseif (options.Color) then
						local col_icon = vgui.Create("DPanel", permission_row)
						col_icon:Dock(LEFT)
						col_icon:SetSize(16,16)
						col_icon:DockMargin(0,0,5,0)
						col_icon:SetMouseInputEnabled(false)
						function col_icon:Paint(w,h)
							surface.SetDrawColor(options.Color)
							surface.DrawRect(0,0,w,h)
						end
					end

					local label = vgui.Create("DLabel", permission_row)
					label:Dock(FILL)
					label:SetTextColor(OpenPermissions.COLOR_BLACK)
					label:SetText(options.Label)
					label:SetContentAlignment(4)
					label:SetMouseInputEnabled(false)

					return checkbox
				end

				PermissionsContent:SetLeft(PermissionsTree)
				PermissionsContent:SetRight(PropertiesContent)
				PermissionsContent:BalanceWidths()

			AddonContent:AddSheet(L"permissions", PermissionsContent, "icon16/group.png")

			local OperationsContainer = vgui.Create("OpenPermissions.ScrollPanel", AddonContent)
			AddonContent:AddSheet(L"operations", OperationsContainer, "icon16/wrench_orange.png")

			function AddonContent:SetShowOverlay(show)
				self.ShowOverlay = show
				self:SetMouseInputEnabled(not show)
				for _,v in ipairs(self:GetItems()) do
					v.Panel:SetMouseInputEnabled(not show)
				end
			end
			AddonContent:SetShowOverlay(true)

				local DeleteAccessGroup = vgui.Create("DButton", OperationsContainer)
				DeleteAccessGroup:SetSize(250,30)
				DeleteAccessGroup:SetText(L"delete_access_group")
				DeleteAccessGroup:SetIcon("icon16/delete.png")

				local CopyPasteContainer = vgui.Create("DPanel", OperationsContainer)
				CopyPasteContainer.Paint = nil
				CopyPasteContainer:SetSize(250,30)
				CopyPasteContainer:AlignTop(DeleteAccessGroup:GetTall() + 5)

					local CopyPermissions = vgui.Create("DButton", CopyPasteContainer)
					CopyPermissions:SetText(L"copy")
					CopyPermissions:SetIcon("icon16/page_copy.png")
					CopyPermissions:DockMargin(0,0,5,0)

					local PastePermissions = vgui.Create("DButton", CopyPasteContainer)
					PastePermissions:SetText(L"paste")
					PastePermissions:SetIcon("icon16/page_paste.png")
					PastePermissions:DockMargin(0,0,5,0)
					PastePermissions:SetDisabled(true)

					function CopyPermissions:DoClick()
						PastePermissions:SetDisabled(false)
						PastePermissions.PermissionsData = {}
						local copied_clashes = false
						for _,line in ipairs(AccessGroups:GetSelected()) do
							local identifier = line.Data.Enum .. " " .. line.Data.Value
							if (not OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] or not OpenPermissions.PermissionsRegistryEditing[line.Data.Value]) then continue end
							for access_group, perms in pairs(OpenPermissions.PermissionsRegistryEditing[line.Data.Enum]) do
								for permission_id, checked in pairs(perms) do
									if (PastePermissions.PermissionsData[permission_id] == nil) then
										local has_clashed = false
										for _,line_2 in ipairs(AccessGroups:GetSelected()) do
											local identifier_2 = line_2.Data.Enum .. " " .. line_2.Data.Value
											if (not OpenPermissions.PermissionsRegistryEditing[line_2.Data.Enum] or not OpenPermissions.PermissionsRegistryEditing[line_2.Data.Value]) then continue end
											if (identifier_2 == identifier) then continue end
											if (OpenPermissions.PermissionsRegistryEditing[line_2.Data.Enum][line_2.Data.Value][permission_id] ~= checked) then
												copied_clashes, has_clashed = true, true
												break
											end
										end
										if (not has_clashed) then
											PastePermissions.PermissionsData[permission_id] = checked
										else
											PastePermissions.PermissionsData[permission_id] = nil
										end
									elseif (PastePermissions.PermissionsData[permission_id] ~= checked) then
										copied_clashes = true
										PastePermissions.PermissionsData[permission_id] = nil
									end
								end
							end
						end
						if (copied_clashes) then
							Derma_Message(L"permission_clash_msg", "OpenPermissions", L"ok")
						end
					end
					function PastePermissions:DoClick()
						for _,line in ipairs(AccessGroups:GetSelected()) do
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] or {}
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] or {}
							table.Merge(OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value], PastePermissions.PermissionsData)
						end
					end

					function CopyPasteContainer:PerformLayout(w,h)
						CopyPermissions:SetSize((w - 2.5) / 2,h)
						CopyPermissions:AlignLeft(0)
						PastePermissions:SetSize((w - 2.5) / 2,h)
						PastePermissions:AlignRight(0)
					end

			local AddonNav = vgui.Create("DPanel", AddonContentContainer)
			AddonNav.Paint = nil
			AddonNav:Dock(BOTTOM)
			AddonNav:DockMargin(0,5,0,0)
			AddonNav:SetTall(30)

				PermissionsSave = vgui.Create("DButton", AddonNav)
				PermissionsSave:Dock(LEFT)
				PermissionsSave:SetWide(100)
				PermissionsSave:DockMargin(0,0,5,0)
				PermissionsSave:SetText(L"save")
				PermissionsSave:SetIcon("icon16/disk.png")
				PermissionsSave:SetDisabled(true)

				function PermissionsSave:RememberPermission(permission_id, checked)
					local is_disabled = true
					for _,line in ipairs(AccessGroups:GetSelected()) do
						if (checked == OpenPermissions.CHECKBOX.INHERIT or checked == false) then
							if (OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil) then
								OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id] = nil
								if (OpenPermissions:table_IsEmpty(OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value])) then
									OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] = nil
									if (OpenPermissions:table_IsEmpty(OpenPermissions.PermissionsRegistryEditing[line.Data.Enum])) then
										OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] = nil
									end
								end
							end
						else
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] or {}
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] or {}
							OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id] = checked
						end
						if (is_disabled) then
							if ((OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil) ~= (OpenPermissions.PermissionsRegistry[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistry[line.Data.Enum][line.Data.Value] ~= nil)) then
								is_disabled = false
							else
								if (OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil and OpenPermissions.PermissionsRegistry[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistry[line.Data.Enum][line.Data.Value] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id] ~= OpenPermissions.PermissionsRegistry[line.Data.Enum][line.Data.Value][permission_id]) then
									is_disabled = false
								elseif (not OpenPermissions:table_IsIdentical(OpenPermissions.PermissionsRegistryEditing, OpenPermissions.PermissionsRegistry)) then
									is_disabled = false
								end
							end
						end
					end
					self:SetDisabled(is_disabled)
				end
				function PermissionsSave:CheckedFromMemory(permission_id, checkbox)
					local checked
					for _,line in ipairs(AccessGroups:GetSelected()) do
						local should_be_checked = OpenPermissions.CHECKBOX.INHERIT
						if (OpenPermissions.PermissionsRegistryEditing[line.Data.Enum] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil and OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id] ~= nil) then
							should_be_checked = OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value][permission_id]
						elseif (OpenPermissions.DefaultPermissions[permission_id] ~= nil) then
							should_be_checked = OpenPermissions.DefaultPermissions[permission_id]
						end
						if (checked == nil) then
							checked = should_be_checked
						else
							if (should_be_checked ~= checked) then
								checkbox:SetAmbigious(true)
								return
							end
						end
					end
					checkbox:SetChecked(checked)
					checkbox:SetAmbigious(false)
				end
				function PermissionsSave:DoClick()
					OpenPermissions.PermissionsRegistry = table.Copy(OpenPermissions.PermissionsRegistryEditing)
					self:SetDisabled(true)
					surface.PlaySound("garrysmod/content_downloaded.wav")
					
					OpenPermissions:SerializeRegistry(OpenPermissions.REGISTRY.FLAT_FILE)
					net.Start("OpenPermissions.SavePermissions")
						OpenPermissions:StartNetworkTable(OpenPermissions.PermissionsRegistry)
					net.SendToServer()
					file.Delete("openpermissions_v2.dat")
				end

				local AddonBack = vgui.Create("DButton", AddonNav)
				AddonBack:Dock(LEFT)
				AddonBack:SetWide(100)
				AddonBack:DockMargin(0,0,5,0)
				AddonBack:SetText(L"back_btn")
				function AddonBack:DoClick()
					AddonsContainer:SetVisible(true)
					AddonContentContainer:SetVisible(false)

					AccessGroupsDivider:SetRight(AddonsContainer)
				end

				local AddonSelect = vgui.Create("OpenPermissions.ComboBox", AddonNav)
				AddonSelect:Dock(FILL)
				AddonSelect.AddonBtns = {}

				AddonSelect:SetSortItems(false)
				AddonSelect:AddChoice(L"all_addons", true, false, "icon16/layers.png")
				AddonSelect:AddSpacer()

				function AddonSelect:OnSelect(i, v, d)
					PropertiesContent:Clear()
					if (d == true) then
						function AccessGroups:OnRowSelected(i, row)
							AddonContent:SetShowOverlay(false)
							PermissionsTree:Clear()
							PropertiesContent:Clear()
							for id, data in pairs(OpenPermissions.Addons) do
								PermissionsTab:LoadPermissions(id, data, true)
							end
						end
						if (AccessGroups:GetSelectedLine() ~= nil) then
							AccessGroups:OnRowSelected()
						end
					else
						self.AddonBtns[d]:DoClick()
					end
				end

		local NavContent = vgui.Create("DPanel", PermissionsTab)
		AccessGroupsDivider:SetLeft(NavContent)
		NavContent.Paint = nil
		NavContent:Dock(LEFT)
		NavContent:SetWide(200)

			AccessGroups = vgui.Create("OpenPermissions.ListView", NavContent)
			AccessGroups:AddColumn(L"type"):SetFixedWidth(65)
			AccessGroups:AddColumn(L"access_group")
			AccessGroups:Dock(FILL)
			AccessGroups.Data = {}

			local KeyCategory = vgui.Create("DCollapsibleCategory", NavContent)
			KeyCategory:Dock(TOP)
			KeyCategory:SetTall(130)
			KeyCategory:DockMargin(0,0,0,5)
			KeyCategory:SetLabel(L"key")
			KeyCategory:SetExpanded(false)

				local KeyInfo = vgui.Create("OpenPermissions.ScrollPanel", NavContent)
				KeyInfo:SetDrawBackground(true)

				for name, enum in pairs(OpenPermissions.ACCESS_GROUP) do
					local Key = vgui.Create("DPanel", KeyInfo)
					Key:Dock(TOP)
					Key:DockMargin(5,5,5,0)

					local KeyColor = OpenPermissions.ACCESS_GROUP_KEY[enum]
					local KeyName = L("ACCESS_GROUP_" .. name)
					local KeyPoly = {
						{x = 9, y = 0},
						{x = 18, y = 9},
						{x = 9, y = 18},
						{x = 0, y = 9},
					}
					function Key:Paint(w,h)
						surface.SetDrawColor(KeyColor)
						draw.NoTexture()
						surface.DrawPoly(KeyPoly)

						draw.SimpleText(KeyName, "DermaDefault", 18 + 5, 8, OpenPermissions.COLOR_BLACK, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
					end
				end

				KeyCategory:SetContents(KeyInfo)
			
			local MultipleTip = vgui.Create("DLabel", NavContent)
			MultipleTip:Dock(TOP)
			MultipleTip:SetContentAlignment(5)
			MultipleTip:DockMargin(0,0,0,5)
			MultipleTip:SetText(L"hold_ctrl_to_select_multiple")
			MultipleTip:SetTextColor(OpenPermissions.COLOR_BLACK)

			local AddAccessGroup = vgui.Create("DButton", NavContent)
			AddAccessGroup:SetText(L"add_access_group")
			AddAccessGroup:SetIcon("icon16/add.png")
			AddAccessGroup:Dock(BOTTOM)
			AddAccessGroup:DockMargin(0,5,0,0)
			AddAccessGroup:SetTall(30)

			function AddAccessGroup:Add(enum, text, value)
				local val = value or text
				if (AccessGroups.Data[enum] and AccessGroups.Data[enum][val]) then
					Derma_Message(L"access_group_exists", L"error", L"ok")
				else
					local type
					for name, _enum in pairs(OpenPermissions.ACCESS_GROUP) do
						if (_enum == enum) then
							type = name
							break
						end
					end
					local line = AccessGroups:AddLine(L("ACCESS_GROUP_" .. type), text)
					line.Data = {
						Enum = enum,
						Value = val
					}
					function line:Paint(w,h)
						derma.SkinHook("Paint", "ListViewLine", self, w, h)

						surface.SetDrawColor(OpenPermissions.ACCESS_GROUP_KEY[enum])
						surface.DrawRect(0,0,w,h)
					end
					AccessGroups.Data[enum] = AccessGroups.Data[enum] or {}
					AccessGroups.Data[enum][val] = true
				end
			end
			for enum, accessors in pairs(OpenPermissions.PermissionsRegistry) do
				for val, vals in pairs(accessors) do
					enum = tonumber(enum)
					if (enum == OpenPermissions.ACCESS_GROUP.STEAMID) then
						AddAccessGroup:Add(enum, OpenPermissions:AccountIDToSteamID(tonumber(val)), tonumber(val))
					elseif (enum == OpenPermissions.ACCESS_GROUP.TEAM) then
						local team_index = OpenPermissions:GetTeamFromIdentifier(val)
						if (team_index) then
							AddAccessGroup:Add(enum, team.GetName(team_index), val)
						end
					elseif (enum == OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY) then
						if (OpenPermissions.IsDarkRP) then
							local category_index = OpenPermissions:DarkRP_GetCategoryFromIdentifier(val)
							if (category_index) then
								AddAccessGroup:Add(enum, DarkRP.getCategories().jobs[category_index].name, val)
							end
						end
					else
						AddAccessGroup:Add(enum, val)
					end
				end
			end

			function AddAccessGroup:DoClick()
				local menu = DermaMenu()
				
				local ACCESS_GROUP_USERGROUP, _ = menu:AddSubMenu(L"ACCESS_GROUP_USERGROUP") _:SetIcon("icon16/group.png")

					ACCESS_GROUP_USERGROUP:AddOption(L"custom_ellipsis", function()
						Derma_StringRequest(L"add_access_group", L"enter_usergroup", LocalPlayer():GetUserGroup(), function(usergroup)
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.USERGROUP, usergroup)
						end)
					end):SetIcon("icon16/pencil.png")

					local usergroups = {superadmin = true, admin = true, user = true}
					for _,ply in ipairs(player.GetHumans()) do
						for usergroup in pairs(OpenPermissions:GetUserGroups(ply)) do
							usergroups[usergroup] = true
						end
					end
					usergroups = table.GetKeys(usergroups)
					table.sort(usergroups)
					for i,usergroup in ipairs(usergroups) do
						GreenToRed_DMenu(i, #usergroups, ACCESS_GROUP_USERGROUP:AddOption(usergroup, function()
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.USERGROUP, usergroup)
						end))
					end

				local ACCESS_GROUP_STEAMID, _ = menu:AddSubMenu(L"ACCESS_GROUP_STEAMID") _:SetIcon("icon16/user_gray.png")

					ACCESS_GROUP_STEAMID:AddOption(L"custom_ellipsis", function()
						Derma_StringRequest(L"add_access_group", Lf("enter_steamid", LocalPlayer():SteamID(), LocalPlayer():SteamID64()), LocalPlayer():SteamID(), function(_input)
							local steamid64
							if (_input:find("^STEAM_%d:%d:%d+$")) then
								steamid64 = util.SteamIDTo64(_input)
							elseif (_input:find("^7656119%d+$")) then
								steamid64 = _input
							else
								Derma_Message(L"invalid_steamid", L"error", L"ok")
								return
							end
							local steamid = util.SteamIDFrom64(steamid64)
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.STEAMID, steamid, OpenPermissions:SteamIDToAccountID(steamid))
						end)
					end):SetIcon("icon16/pencil.png")

					local steamids = {}
					for _,ply in ipairs(player.GetHumans()) do
						table.insert(steamids, {Distance = ply:GetPos():DistToSqr(LocalPlayer():GetPos()), Name = ply:Nick(), SteamID = ply:SteamID(), AccountID = ply:AccountID(), Color = team.GetColor(ply:Team())})
					end
					table.SortByMember(steamids, "Distance", true)
					for i,item in ipairs(steamids) do
						DMenuOption_ColorIcon(ACCESS_GROUP_STEAMID:AddOption(item.Name, function()
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.STEAMID, item.SteamID, item.AccountID)
						end), item.Color)
					end

				local ACCESS_GROUP_TEAM, _ = menu:AddSubMenu(L"ACCESS_GROUP_TEAM") _:SetIcon("icon16/flag_green.png")

					if (OpenPermissions.IsDarkRP) then
						local categories = {}
						for i,c in ipairs(DarkRP.getCategories().jobs) do
							if (GAS:table_IsEmpty(c.members)) then continue end
							table.insert(categories, {name = c.name, color = c.color, members = c.members})
						end
						table.SortByMember(categories, "name", true)
						for i,c in ipairs(categories) do
							local submenu, _submenu = ACCESS_GROUP_TEAM:AddSubMenu(c.name)
							DMenuOption_ColorIcon(_submenu, c.color)

							local members = {}
							for _,member in ipairs(c.members) do
								table.insert(members, {name = member.name, color = member.color, index = member.team})
							end
							table.SortByMember(members, "name", true)
							for _,member in ipairs(members) do
								DMenuOption_ColorIcon(submenu:AddOption(member.name, function()
									AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.TEAM, member.name, OpenPermissions:GetTeamIdentifier(member.index))
								end), member.color)
							end
						end
					else
						local teams = {}
						for i,t in ipairs(team.GetAllTeams()) do
							table.insert(teams, {Name = t.Name, Index = i, Color = t.Color})
						end
						table.SortByMember(teams, "Name", true)
						for i,item in ipairs(teams) do
							DMenuOption_ColorIcon(ACCESS_GROUP_TEAM:AddOption(item.Name, function()
								AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.TEAM, item.Name, OpenPermissions:GetTeamIdentifier(i))
							end), item.Color)
						end
					end

				local ACCESS_GROUP_LUA_FUNCTION, _ = menu:AddSubMenu(L"ACCESS_GROUP_LUA_FUNCTION") _:SetIcon("icon16/script.png")
					local lua_functions = table.GetKeys(OpenPermissions.LuaFunctions)
					if (#lua_functions == 0) then
						ACCESS_GROUP_LUA_FUNCTION:AddOption(L"none_info")
					else
						table.sort(lua_functions)
						for i,lua_func_name in ipairs(lua_functions) do
							GreenToRed_DMenu(i, #lua_functions, ACCESS_GROUP_LUA_FUNCTION:AddOption(lua_func_name, function()
								AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.LUA_FUNCTION, lua_func_name)
							end))
						end
					end

				if (OpenPermissions.IsDarkRP) then
					local ACCESS_GROUP_DARKRP_CATEGORY, _ = menu:AddSubMenu(L"ACCESS_GROUP_DARKRP_CATEGORY") _:SetIcon("icon16/wrench_orange.png")
					local darkrp_categories = {}
					for i,category in ipairs(DarkRP.getCategories().jobs) do
						table.insert(darkrp_categories, {Name = category.name, Color = category.color, Category = category})
					end
					table.SortByMember(darkrp_categories, "Name", true)
					for i,item in ipairs(darkrp_categories) do
						DMenuOption_ColorIcon(ACCESS_GROUP_DARKRP_CATEGORY:AddOption(item.Name, function()
							AddAccessGroup:Add(OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY, item.Name, OpenPermissions:DarkRP_GetCategoryIdentifier(i))
						end), item.Color)
					end
				end

				hook.Run("OpenPermissions:AddAccessGroup", menu)

				menu:Open()
			end

		local function permissions_node_clicked(self, addon_id, v)
			PropertiesContent:Clear()

			local indent_level = 0
			local function _r(tbl, permission_id, my_parent, i)
				i = (i or 0) + 1
				local final_checkbox
				for i,v in ipairs(tbl) do
					local my_permission_id = permission_id
					if (v[2].Value) then
						my_permission_id = my_permission_id .. "/" .. v[2].Value
					end
					local new_checkbox = PropertiesContent:AddProperty(v[2], indent_level)
					final_checkbox = new_checkbox
					v[3] = new_checkbox
					v[4] = my_parent

					function new_checkbox:CheckAmbigious()
						if (my_parent) then
							local all_state
							local ambigious = false
							for _,_v in ipairs(my_parent[1]) do
								if (not IsValid(_v[3])) then continue end
								if (_v[3]:IsAmbigious()) then
									ambigious = true
									break
								elseif (all_state == nil) then
									all_state = _v[3]:GetChecked()
								elseif (all_state ~= _v[3]:GetChecked()) then
									ambigious = true
									break
								end
							end
							my_parent[3]:SetAmbigious(ambigious)
							if (not ambigious) then
								my_parent[3]:SetChecked(all_state)
							end
							my_parent[3]:CheckAmbigious()
						end
					end
					function new_checkbox:OnChange()
						self:CheckAmbigious()
						if (#v[1] > 0) then
							local function __r(tbl)
								for _,_v in ipairs(tbl) do
									_v[3]:SetChecked(self:GetChecked())
									_v[3]:OnChange()
									__r(_v[1])
								end
							end
							__r(v[1])
						else
							PermissionsSave:RememberPermission(my_permission_id, self:GetChecked())
						end
					end

					PermissionsSave:CheckedFromMemory(my_permission_id, new_checkbox)

					if (#v[1] > 0) then
						indent_level = indent_level + 1
						_r(v[1], my_permission_id, v, i)
					end
				end
				if (final_checkbox) then
					final_checkbox:CheckAmbigious()
				end
				indent_level = indent_level - 1
			end
			_r(v[1], addon_id)
		end
		function PermissionsTab:LoadPermissions(addon_id, addon_data, shouldnt_clear)
			PermissionsTab.AddonID, PermissionsTab.AddonData = addon_id, addon_data

			if (not shouldnt_clear) then
				PermissionsTree:Clear()
				PropertiesContent:Clear()
			end

			local tree = addon_data[1]
			local addon_options = addon_data[2]

			local root_node = PermissionsTree:AddNode(addon_options.Name or addon_id, addon_options.Icon)
			if (not shouldnt_clear) then root_node:SetExpanded(true) end
			function root_node:DoClick()
				-- show all permissions
				permissions_node_clicked(self, addon_id, addon_data)
			end

			local is_root = true
			local function r(tbl, node, permission_id, prev_options)
				local lowest_level = true
				for _,v in ipairs(tbl) do
					if (#v[1] > 0) then
						lowest_level = false
						break
					end
				end
				if (not is_root and lowest_level) then
					-- if we can't go any deeper then show property checkboxes
					-- when the node is clicked
					function node:DoClick()
						PropertiesContent:Clear()

						if (#tbl > 1) then
							local checkboxes = {}
							local master_checkbox = PropertiesContent:AddProperty(prev_options)
							function master_checkbox:OnChange()
								self:SetAmbigious(false)
								for _,v in ipairs(checkboxes) do
									v:SetChecked(self:GetChecked())
									v:OnChange()
								end
							end

							for i,v in ipairs(tbl) do
								local my_permission_id = permission_id
								if (v[2].Value) then
									my_permission_id = my_permission_id .. "/" .. v[2].Value
								end
								local checkbox = PropertiesContent:AddProperty(v[2], 1)
								table.insert(checkboxes, checkbox)
								function checkbox:CheckAmbigious()
									local all_state
									local ambigious = false
									for _,v in ipairs(checkboxes) do
										if (v:IsAmbigious()) then
											ambigious = true
											break
										elseif (all_state == nil) then
											all_state = v:GetChecked()
										elseif (all_state ~= v:GetChecked()) then
											ambigious = true
											break
										end
									end
									master_checkbox:SetAmbigious(ambigious)
									if (not ambigious) then master_checkbox:SetChecked(all_state) end
								end
								function checkbox:OnChange()
									PermissionsSave:RememberPermission(my_permission_id, self:GetChecked())
									self:CheckAmbigious()
								end
								PermissionsSave:CheckedFromMemory(my_permission_id, checkbox)
							end
							checkboxes[1]:CheckAmbigious()
						else
							local my_permission_id = permission_id
							if (tbl[1][2].Value) then
								my_permission_id = my_permission_id .. "/" .. tbl[1][2].Value
							end
							local checkbox = PropertiesContent:AddProperty(tbl[1][2])
							function checkbox:OnChange()
								PermissionsSave:RememberPermission(my_permission_id, self:GetChecked())
							end
							PermissionsSave:CheckedFromMemory(my_permission_id, checkbox)
						end
					end
				else
					is_root = false
				end

				for _,v in ipairs(tbl) do
					local my_permission_id = permission_id
					if (v[2].Value) then
						my_permission_id = my_permission_id .. "/" .. v[2].Value
					end
					local new_node = node:AddNode(v[2].Label)
					if (v[2].Icon) then
						new_node:SetIcon(v[2].Icon)
					elseif (v[2].Color) then
						function new_node.Icon:PaintOver(w,h)
							surface.SetDrawColor(v[2].Color)
							surface.DrawRect(0,0,w,h)
						end
					end
					if (#v[1] == 0) then
						function new_node:DoClick()
							PropertiesContent:Clear()
							local checkbox = PropertiesContent:AddProperty(v[2])
							function checkbox:OnChange()
								PermissionsSave:RememberPermission(my_permission_id, self:GetChecked())
							end
							PermissionsSave:CheckedFromMemory(my_permission_id, checkbox)
						end
					else
						function new_node:DoClick()
							permissions_node_clicked(self, my_permission_id, v)
						end
						r(v[1], new_node, my_permission_id, v[2])
					end
				end
			end
			r(tree, root_node, addon_id)
		end

	local TesterTab = vgui.Create("DPanel", Tabs)
	TesterTab.Paint = nil

	local HelpTabContent = vgui.Create("DPanel", Tabs)
	HelpTabContent.Paint = nil

	Tabs:AddSheet(L"permissions", PermissionsTab, "icon16/group.png")
	Tabs:AddSheet(L"tester", TesterTab, "icon16/wrench_orange.png")
	local HelpTab = Tabs:AddSheet(L"help", HelpTabContent, "icon16/help.png")

	local HelpContent
	function Tabs:OnActiveTabChanged(old, new)
		if (new == HelpTab.Tab) then
			if (IsValid(HelpContent)) then
				HelpContent:SetVisible(true)
			else
				HelpContent = vgui.Create("DPanel", HelpTabContent)
				HelpContent.Paint = nil
				HelpContent:Dock(FILL)

				local HelpControls = vgui.Create("DHTMLControls", HelpContent)
				HelpControls:Dock(TOP)
				HelpControls.HomeURL = "https://gmodadminsuite.github.io/OpenPermissions"

				local HelpHTML = vgui.Create("DHTML", HelpContent)
				HelpHTML:Dock(FILL)
				HelpHTML:OpenURL(HelpControls.HomeURL)

				HelpControls:SetHTML(HelpHTML)
			end
		elseif (IsValid(HelpContent)) then
			HelpContent:SetVisible(false)
		end
	end

	--## Create Dynamic Content ##--

	function DeleteAccessGroup:DoClick()
		for i,line in pairs(AccessGroups:GetLines()) do
			if (not line:IsLineSelected()) then continue end
			if (AccessGroups.Data[line.Data.Enum][line.Data.Value] ~= nil) then
				AccessGroups.Data[line.Data.Enum][line.Data.Value] = nil
			end
			if (OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] ~= nil) then
				OpenPermissions.PermissionsRegistryEditing[line.Data.Enum][line.Data.Value] = nil
			end
			AccessGroups:RemoveLine(i)
		end
		AddonContent:SetShowOverlay(true)
		AddonContent:SwitchToName(L"permissions")
		PermissionsTree:Clear()
		PropertiesContent:Clear()

		PermissionsSave:SetDisabled(false)
	end

	local sorted_addons = {}
	for id, data in pairs(OpenPermissions.Addons) do
		local options = data[2]
		table.insert(sorted_addons, {name = options.Name or id, id = id, data = data})
	end
	table.SortByMember(sorted_addons, "name", true)

	local AddonQueue = {}
	local ActiveAddon
	for _,addon_data in ipairs(sorted_addons) do
		local id, data = addon_data.id, addon_data.data
		local options = data[2]
		AddonSelect:AddChoice(options.Name or id, id, false, options.Icon)

		local Addon = vgui.Create("OpenPermissions.Addon", AddonsContainer)

		if (specific_addon == id) then
			ActiveAddon = Addon
		end

		AddonSelect.AddonBtns[id] = Addon

		Addon:SetSize(200,120)
		Addon:Setup(id, options)
		if (Addon.Addon.Logo) then
			OpenPermissions:AddTooltip(Addon, {
				Text = options.Name
			})
		end

		function Addon:DoClick()
			PropertiesContent:Clear()

			AddonSelect:SetValue(options.Name or id)

			AddonsContainer:SetVisible(false)
			AddonContentContainer:SetVisible(true)

			AccessGroupsDivider:SetRight(AddonContentContainer)

			CopyPermissions:SetDisabled(#AccessGroups:GetSelected() > 1)
			PastePermissions:SetDisabled(true)

			function AccessGroups:OnRowSelected(i, row)
				AddonContent:SetShowOverlay(false)
				PropertiesContent:Clear()
				PermissionsTab:LoadPermissions(id, data)
			end
			if (AccessGroups:GetSelectedLine() ~= nil) then
				AccessGroups:OnRowSelected()
			end
		end

		table.insert(AddonQueue, Addon)
		if (#AddonQueue == 3) then
			AddonsContainer:AddRow(AddonQueue[1], AddonQueue[2], AddonQueue[3])
			AddonQueue = {}
		end
	end
	if (#AddonQueue > 0) then
		AddonsContainer:AddRow(AddonQueue[1], AddonQueue[2], AddonQueue[3])
	end
	if (ActiveAddon) then
		ActiveAddon:DoClick()
	end
end

net.Receive("OpenPermissions.OpenMenu", function()
	OpenPermissions.Addons = OpenPermissions:ReceiveNetworkTable()
	OpenPermissions.PermissionsRegistryEditing = table.Copy(OpenPermissions.PermissionsRegistry)

	local specific_addon = net.ReadBool()
	if (specific_addon) then
		OpenPermissions:OpenMenu(net.ReadString())
	else
		OpenPermissions:OpenMenu()
	end
end)

concommand.Add("openpermissions", function(_, __, args)
	net.Start("OpenPermissions.OpenMenu")
		net.WriteString(table.concat(args, " "))
	net.SendToServer()
end, function(cmd, args)
	local stuff = {}
	if (OpenPermissions.Addons ~= nil) then
		if (#string.Trim(args) > 0) then
			for name in pairs(OpenPermissions.Addons) do
				if (name:lower():find(string.Trim(args):lower())) then
					stuff[#stuff + 1] = "openpermissions " .. name
				end
			end
		else
			for name in pairs(OpenPermissions.Addons) do
				stuff[#stuff + 1] = "openpermissions " .. name
			end
		end
	end
	table.sort(stuff)
	return stuff
end)

net.Receive("OpenPermissions.NoPermissions", function()
	OpenPermissions:ChatPrint(L"operator_only_menu", "[ERROR]", OpenPermissions.COLOR_RED)
end)

net.Receive("OpenPermissions.NotAnAddon", function()
	OpenPermissions:ChatPrint(L"not_an_addon", "[ERROR]", OpenPermissions.COLOR_RED)
end)
--lua/autorun/proxy.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "Proxy",		"models/player/tiki/proxy.mdl" )

--lua/autorun/r2c3po.lua:
/*
	Addon by Voikanaa	
*/

player_manager.AddValidModel( "R2-D2", 		"models/player/r2d2.mdl" );
list.Set( "PlayerOptionsModel", "R2-D2", 	"models/player/r2d2.mdl" );

player_manager.AddValidModel( "C-3PO", 	"models/player/c3po.mdl" );
player_manager.AddValidHands( "C-3PO", 	"models/player/c3po_hands.mdl", 0, "00000000" )
list.Set( "PlayerOptionsModel", "C-3PO", 	"models/player/c3po.mdl" );
--lua/autorun/rb655_ext_props_wpn_slct.lua:

AddCSLuaFile()

local extraItems = {
	{ ClassName = "weapon_alyxgun", PrintName = "#weapon_alyxgun", Category = "Half-Life 2", Author = "VALVe", Spawnable = true },
	{ ClassName = "weapon_oldmanharpoon", PrintName = "#weapon_oldmanharpoon", Category = "Half-Life 2", Author = "VALVe", Spawnable = true },
	{ ClassName = "weapon_annabelle", PrintName = "#weapon_annabelle", Category = "Half-Life 2", Author = "VALVe", Spawnable = true },
	{ ClassName = "weapon_citizenpackage", PrintName = "#weapon_citizenpackage", Category = "Half-Life 2", Author = "VALVe", Spawnable = true },
	{ ClassName = "weapon_citizensuitcase", PrintName = "#weapon_citizensuitcase", Category = "Half-Life 2", Author = "VALVe", Spawnable = true }
}

local function GiveWeapon( ply, ent, args )
	if ( !args or !args[ 1 ] or !isstring( args[ 1 ] ) ) then return end

	local className = args[ 1 ]

	local swep = list.Get( "Weapon" )[ className ]
	if ( swep == nil ) then
		for id, t in pairs( extraItems ) do
			if ( t.ClassName == className ) then swep = t end
		end
	end
	if ( swep == nil ) then return end

	-- Cannot validate if the player is admin for admin weapons if we got no player object (saves)
	if ( IsValid( ply ) ) then
		if ( ( !swep.Spawnable and !ply:IsAdmin() ) or ( swep.AdminOnly and !ply:IsAdmin() ) ) then return end
		if ( !hook.Run( "PlayerGiveSWEP", ply, className, swep ) ) then return end
	end

	ent:Give( className )
	if ( SERVER ) then duplicator.StoreEntityModifier( ent, "rb655_npc_weapon", args ) end
end
duplicator.RegisterEntityModifier( "rb655_npc_weapon", GiveWeapon )

local function changeWep( it, ent, wep )
	it:MsgStart()
		net.WriteEntity( ent )
		net.WriteString( wep )
	it:MsgEnd()
end

local nowep = {
	"cycler", "npc_furniture", "monster_generic",

	-- HL2
	"npc_seagull", "npc_crow", "npc_piegon", "npc_rollermine", "npc_turret_floor", "npc_stalker", "npc_turret_ground",
	"npc_combine_camera", "npc_turret_ceiling", "npc_cscanner", "npc_clawscanner", "npc_manhack", "npc_sniper",
	"npc_combinegunship", "npc_combinedropship", "npc_helicopter", "npc_antlion_worker", "npc_headcrab_black",
	"npc_hunter", "npc_vortigaunt", "npc_antlion", "npc_antlionguard", "npc_barnacle", "npc_headcrab",
	"npc_dog", "npc_gman", "npc_antlion_grub", "npc_strider", "npc_fastzombie", "npc_fastzombie_torso",
	"npc_headcrab_poison", "npc_headcrab_fast", "npc_poisonzombie", "npc_zombie", "npc_zombie_torso", "npc_zombine",

	-- HLS
	"monster_scientist", "monster_zombie", "monster_headcrab", "class C_AI_BaseNPC", "monster_tentacle",
	"monster_alien_grunt", "monster_alien_slave", "monster_human_assassin", "monster_babycrab", "monster_bullchicken",
	"monster_cockroach", "monster_alien_controller", "monster_gargantua", "monster_bigmomma", "monster_human_grunt",
	"monster_houndeye", "monster_nihilanth", "monster_barney", "monster_snark", "monster_turret", "monster_miniturret", "monster_sentry"
}

AddEntFunctionProperty( "rb655_npc_weapon_strip", "Strip Weapon", 651, function( ent )
	if ( ent:IsNPC() and IsValid( ent:GetActiveWeapon() ) and !table.HasValue( nowep, ent:GetClass() ) ) then return true end
	return false
end, function( ent )
	ent:GetActiveWeapon():Remove()
end, "icon16/gun.png" )

properties.Add( "rb655_npc_weapon", {
	MenuLabel = "Change Weapon (Popup)",
	MenuIcon = "icon16/gun.png",
	Order = 650,
	Filter = function( self, ent, ply )
		if ( !IsValid( ent ) or !gamemode.Call( "CanProperty", ply, "rb655_npc_weapon", ent ) ) then return false end
		if ( ent:IsNPC() and !table.HasValue( nowep, ent:GetClass() ) ) then return true end
		return false
	end,
	Action = function( self, ent )
		if ( !IsValid( ent ) ) then return false end

		local frame = vgui.Create( "DFrame" )
		frame:SetSize( ScrW() / 1.2, ScrH() / 1.1 )
		frame:SetTitle( "Change weapon of " .. language.GetPhrase( "#" .. ent:GetClass() ) )
		frame:Center()

		frame:MakePopup()

		frame:SetDraggable( false )

		function frame:Paint( w, h )
			Derma_DrawBackgroundBlur( self, self.m_fCreateTime )
			draw.RoundedBox( 0, 0, 0, w, h, Color( 0, 0, 0, 200 ) )
		end

		local PropPanel = vgui.Create( "ContentContainer", frame )
		PropPanel:SetTriggerSpawnlistChange( false )
		PropPanel:Dock( FILL )

		local Categorised = {}

		-- Add the hidden NPC only weapons
		Categorised[ "Half-Life 2" ] = table.Copy( extraItems )

		for k, weapon in pairs( list.Get( "Weapon" ) ) do
			if ( !weapon.Spawnable and !weapon.AdminSpawnable ) then continue end

			local cat = weapon.Category or "Other"
			if ( !isstring( cat ) ) then cat = tostring( cat ) end

			Categorised[ cat ] = Categorised[ cat ] or {}
			table.insert( Categorised[ cat ], weapon )
		end

		for CategoryName, v in SortedPairs( Categorised ) do
			local Header = vgui.Create( "ContentHeader", PropPanel )
			Header:SetText( CategoryName )
			PropPanel:Add( Header )

			for k, WeaponTable in SortedPairsByMemberValue( v, "PrintName" ) do
				if ( WeaponTable.AdminOnly and !LocalPlayer():IsAdmin() ) then continue end

				local icon = vgui.Create( "ContentIcon", PropPanel )
				icon:SetMaterial( "entities/" .. WeaponTable.ClassName .. ".png" )
				icon:SetName( WeaponTable.PrintName or ( "#" .. WeaponTable.ClassName ) )
				icon:SetAdminOnly( WeaponTable.AdminOnly or false )

				icon.DoClick = function()
					changeWep( self, ent, WeaponTable.ClassName )
					frame:Close()
				end

				PropPanel:Add( icon )
			end
		end

		local WarningThing = vgui.Create( "Panel", frame )
		WarningThing:SetHeight( 70 )
		WarningThing:Dock( BOTTOM )
		WarningThing:DockMargin( 0, 5, 0, 0 )
		function WarningThing:Paint( w, h )
			draw.RoundedBox( 0, 0, 0, w, h, Color( 255, 0, 0 ) )
		end

		local WarningText = vgui.Create( "DLabel", WarningThing )
		WarningText:Dock( TOP )
		WarningText:SetHeight( 35 )
		WarningText:SetContentAlignment( 5 )
		WarningText:SetTextColor( color_white )
		WarningText:SetFont( "DermaLarge" )
		WarningText:SetText( "WARNING! Not all NPCs can use weapons and not all weapons are usable by NPCs." )

		local WarningText2 = vgui.Create( "DLabel", WarningThing )
		WarningText2:Dock( TOP )
		WarningText2:SetHeight( 35 )
		WarningText2:SetContentAlignment( 5 )
		WarningText2:SetTextColor( color_white )
		WarningText2:SetFont( "DermaLarge" )
		WarningText2:SetText( "This is entirely dependent on the Addon the weapon and the NPC are from. This mod cannot change that." )
	end,
	Receive = function( self, length, ply )
		local ent = net.ReadEntity()
		if ( !IsValid( ent ) ) then return end
		if ( !ent:IsNPC() or table.HasValue( nowep, ent:GetClass() ) ) then return end

		local wep = net.ReadString()

		GiveWeapon( ply, ent, { wep } )
	end
} )

--lua/autorun/rb655_legacy_addon_props.lua:

AddCSLuaFile()

if ( SERVER ) then return end

language.Add( "spawnmenu.category.addonslegacy", "Addons - Legacy" )
language.Add( "spawnmenu.category.downloads", "Downloads" )

local function AddRecursive( pnl, folder )
	local files, folders = file.Find( folder .. "*", "MOD" )

	for k, v in pairs( files or {} ) do
		if ( !string.EndsWith( v, ".mdl" ) ) then continue end

		local cp = spawnmenu.GetContentType( "model" )
		if ( cp ) then
			local mdl = folder .. v
			mdl = string.sub( mdl, string.find( mdl, "models/" ), string.len( mdl ) )
			mdl = string.gsub( mdl, "models/models/", "models/" )
			cp( pnl, { model = mdl } )
		end
	end

	for k, v in pairs( folders or {} ) do AddRecursive( pnl, folder .. v .. "/" ) end
end

local function CountRecursive( folder )
	local files, folders = file.Find( folder .. "*", "MOD" )
	local val = 0

	for k, v in pairs( files or {} ) do if ( string.EndsWith( v, ".mdl" ) ) then val = val + 1 end end
	for k, v in pairs( folders or {} ) do val = val + CountRecursive( folder .. v .. "/" ) end
	return val
end

hook.Add( "PopulateContent", "LegacyAddonProps", function( pnlContent, tree, node )

	if ( !IsValid( node ) or !IsValid( pnlContent ) ) then
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR LEGACY ADDONS!!!" )
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR LEGACY ADDONS!!!" )
		print( "!!! Extended Spawnmenu: FAILED TO INITALIZE PopulateContent HOOK FOR LEGACY ADDONS!!!" )
		return
	end

	local ViewPanel = vgui.Create( "ContentContainer", pnlContent )
	ViewPanel:SetVisible( false )

	local addons = {}

	local _files, folders = file.Find( "addons/*", "MOD" )
	for _, f in pairs( folders ) do

		if ( !file.IsDir( "addons/" .. f .. "/models/", "MOD" ) ) then continue end

		local count = CountRecursive( "addons/" .. f .. "/models/", "MOD" )
		if ( count == 0 ) then continue end

		table.insert( addons, {
			name = f,
			count = count,
			path = "addons/" .. f .. "/models/"
		} )

	end

	local LegacyAddons = node:AddNode( "#spawnmenu.category.addonslegacy", "icon16/folder_database.png" )
	for _, f in SortedPairsByMemberValue( addons, "name" ) do

		local models = LegacyAddons:AddNode( f.name .. " (" .. f.count .. ")", "icon16/bricks.png" )
		models.DoClick = function()
			ViewPanel:Clear( true )
			AddRecursive( ViewPanel, f.path )
			pnlContent:SwitchPanel( ViewPanel )
		end

	end

	--[[ -------------------------- DOWNLOADS -------------------------- ]]

	local fi, fo = file.Find( "download/models", "MOD" )
	if ( !fi && !fo ) then return end

	local Downloads = node:AddFolder( "#spawnmenu.category.downloads", "download/models", "MOD", false, false, "*.*" )
	Downloads:SetIcon( "icon16/folder_database.png" )

	Downloads.OnNodeSelected = function( self, selectedNode )
		ViewPanel:Clear( true )

		local path = selectedNode:GetFolder()

		if ( !string.EndsWith( path, "/" ) && string.len( path ) > 1 ) then path = path .. "/" end
		local path_mdl = string.sub( path, string.find( path, "/models/" ) + 1 )

		for k, v in pairs( file.Find( path .. "/*.mdl", selectedNode:GetPathID() ) ) do

			local cp = spawnmenu.GetContentType( "model" )
			if ( cp ) then
				cp( ViewPanel, { model = path_mdl .. "/" .. v } )
			end

		end

		pnlContent:SwitchPanel( ViewPanel )
	end

end )

--[[ -------------------------------------------------------------------------- The addon info -------------------------------------------------------------------------- ]]

concommand.Add( "extsm_addoninfo", function()
	local frame = vgui.Create( "DFrame" )
	frame:SetSize( ScrW() - 100, ScrH() - 100 )
	frame:Center()
	frame:MakePopup()

	local sp = frame:Add( "DScrollPanel" )
	sp:Dock( FILL )

	sp:Add( "rb655_addonInfo" )
end )

hook.Add( "AddToolMenuCategories", "LegacyAddonPropsInfoCategory", function()
	spawnmenu.AddToolCategory( "Utilities", "Robotboy655", "#Robotboy655" )
end )

hook.Add( "PopulateToolMenu", "LegacyAddonPropsInfoThing", function()
	spawnmenu.AddToolMenuOption( "Utilities", "Robotboy655", "LegacyInfoPanel", "Addon Information", "", "", function( panel )
		panel:ClearControls()
		panel:Button( "Open addon data window", "extsm_addoninfo" )
	end )
end )

----------------------------------

function ScreenScaleH( size )
	return size * ( ScrH() / 480.0 )
end

surface.CreateFont( "AddonInfo_Header", {
	font	= "Helvetica",
	size	= ScreenScaleH( 24 ),
	weight	= 1000
} )

surface.CreateFont( "AddonInfo_Text", {
	font	= "Helvetica",
	size	= ScreenScaleH( 9 ),
	weight	= 1000
} )

surface.CreateFont( "AddonInfo_Small", {
	font	= "Helvetica",
	size	= ScreenScaleH( 8 )
} )

local function GetWorkshopLeftovers()

	local subscriptions = {}

	for id, t in pairs( engine.GetAddons() ) do
		subscriptions[ tonumber( t.wsid ) ] = true
	end

	local t = {}
	for id, fileh in pairs( file.Find( "addons/*.gma", "MOD" ) ) do
		local a = string.StripExtension( fileh )
		a = string.Explode( "_", a )
		a = tonumber( a[ #a ] )
		if ( !subscriptions[ a ] ) then
			table.insert( t, fileh )
		end
	end

	return t

end

local function GetSize( b )
	b = b / 1000

	if ( b < 1000 ) then
		return math.floor( b * 10 ) / 10 .. " KB"
	end

	b = b / 1000

	if ( b < 1000 ) then
		return math.floor( b * 10 ) / 10 .. " MB"
	end

	b = b / 1000

	return math.floor( b * 10 ) / 10 .. " GB"
end

local function DrawText( txt, font, x, y, clr )
	draw.SimpleText( txt, font, x, y, clr )

	surface.SetFont( font )
	return surface.GetTextSize( txt )
end

local PANEL = {}

function PANEL:Init()
	self.Computed = false
end

function PANEL:Compute()

	self.WorkshopSize = 0
	for id, fle in pairs( file.Find( "addons/*.gma", "MOD" ) ) do
		self.WorkshopSize = self.WorkshopSize + ( file.Size( "addons/" .. fle, "MOD" ) or 0 )
	end

	self.WorkshopWaste = 0
	self.WorkshopWasteFiles = {}
	for id, fle in pairs( GetWorkshopLeftovers() ) do
		self.WorkshopWaste = self.WorkshopWaste + ( file.Size( "addons/" .. fle, "MOD" ) or 0 )
		table.insert( self.WorkshopWasteFiles, { "addons/" .. fle, ( file.Size( "addons/" .. fle, "MOD" ) or 0 ) } )
	end

	-- -------------------------------------------

	local _files, folders = file.Find( "addons/*", "MOD" )

	self.LegacyAddons = {}
	for k, v in pairs( folders or {} ) do
		self.LegacyAddons[ "addons/" .. v .. "/" ] = "Installed"

		if ( file.IsDir( "addons/" .. v .. "/models/", "MOD" ) ) then
			self.LegacyAddons[ "addons/" .. v .. "/" ] = "Installed (Has Models)"
		end

		local _fi, fo = file.Find( "addons/" .. v .. "/*", "MOD" )
		if ( table.Count( fo or {} ) < 1 ) then
			self.LegacyAddons[ "addons/" .. v .. "/" ] = "Installed (Empty)"
		end

		if ( !file.IsDir( "addons/" .. v .. "/models/", "MOD" ) && !file.IsDir(  "addons/" .. v .. "/materials/", "MOD" ) && !file.IsDir(  "addons/" .. v .. "/lua/", "MOD" ) && !file.IsDir(  "addons/" .. v .. "/sound/", "MOD" ) ) then
			self.LegacyAddons[ "addons/" .. v .. "/" ] = "Installed Incorrectly!"
		end
	end

	-- -------------------------------------------

	local luaFiles = file.Find( "cache/lua/*", "MOD" )  -- Too many files to count actual size!
	self.LuaCacheSize = #luaFiles * 1400
	self.LuaCacheFiles = #luaFiles

	local wsFiles = file.Find( "cache/workshop/*", "MOD" )
	self.WSCacheSize = 0
	for id, fle in pairs( wsFiles ) do
		self.WSCacheSize = self.WSCacheSize + ( file.Size( "cache/workshop/" .. fle, "MOD" ) or 0 )
	end
	self.WSCacheFiles = #wsFiles

	self.Computed = true

end

function PANEL:Paint( w, h )

	if ( !self.Computed ) then
		self:Compute()
	end

	local txtW = self:GetParent():GetWide()
	local txtH = 0

	-- -----------------------

	local tW, tH = DrawText( "Cache Sizes", "AddonInfo_Header", 0, txtH, color_white )
	txtH = txtH + tH

	local localH = 0
	local localW = 0

	-- -----------------------

	tW, tH = DrawText( "~" .. GetSize( self.LuaCacheSize or 0 ) .. " (" .. self.LuaCacheFiles .. " files)", "AddonInfo_Small", 0, txtH + localH, Color( 220, 220, 220 ) )
	localH = localH + tH
	localW = math.max( localW, tW )

	tW, tH = DrawText( "~" .. GetSize( self.WSCacheSize or 0 ) .. " (" .. self.WSCacheFiles .. " files)", "AddonInfo_Small", 0, txtH + localH, Color( 220, 220, 220 ) )
	localH = localH + tH
	localW = math.max( localW, tW )

	-- -----------------------

	localW = localW + 25

	tW, tH = DrawText( "Server Lua cache", "AddonInfo_Small", localW, txtH, color_white )
	txtH = txtH + tH

	tW, tH = DrawText( "Workshop download cache", "AddonInfo_Small", localW, txtH, color_white )
	txtH = txtH + tH

	-- -------------------------------------------

	txtH = txtH + ScreenScaleH( 8 )
	tW, tH = DrawText( "Workshop Subscriptions", "AddonInfo_Header", 0, txtH, color_white )
	txtH = txtH + tH

	-- -------------------------------------------

	tW, tH = DrawText( "Used Size:  ", "AddonInfo_Text", 0, txtH, color_white )
	local maxW = tW
	txtH = txtH + tH

	tW, tH = DrawText( "Wasted Space:  ", "AddonInfo_Text", 0, txtH, color_white )
	maxW = math.max( maxW, tW )
	txtH = txtH + tH

	tW, tH = DrawText( "Total Size:  ", "AddonInfo_Text", 0, txtH, color_white )
	maxW = math.max( maxW, tW )
	txtH = txtH - tH * 2

	-- -------------------------------------------

	tW, tH = DrawText( GetSize( ( self.WorkshopSize - self.WorkshopWaste ) or 0 ), "AddonInfo_Text", maxW, txtH, Color( 220, 220, 220 ) )
	txtH = txtH + tH

	tW, tH = DrawText( GetSize( self.WorkshopWaste or 0 ), "AddonInfo_Text", maxW, txtH, Color( 220, 220, 220 ) )
	txtH = txtH + tH

	tW, tH = DrawText( GetSize( self.WorkshopSize or 0 ), "AddonInfo_Text", maxW, txtH, Color( 220, 220, 220 ) )
	txtH = txtH + tH * 2

	-- -------------------------------------------

	tW, tH = DrawText( "Files that aren't used: ( Safe to delete )", "AddonInfo_Text", 0, txtH, color_white )
	txtH = txtH + tH

	localH = 0
	localW = 0
	for id, t in pairs( self.WorkshopWasteFiles or {} ) do
		tW, tH = DrawText( GetSize( t[ 2 ] ) .. "    ", "AddonInfo_Small", 0, txtH + localH, Color( 220, 220, 220 ) )
		localH = localH + tH
		localW = math.max( localW, tW )
	end

	for id, t in pairs( self.WorkshopWasteFiles or {} ) do
		tW, tH = DrawText( t[ 1 ], "AddonInfo_Small", localW, txtH, color_white )
		txtH = txtH + tH
	end

	-- -------------------------------------------

	tW, tH = DrawText( "Legacy Addons", "AddonInfo_Header", 0, txtH + ScreenScaleH( 8 ), color_white )
	txtH = txtH + tH + ScreenScaleH( 8 )

	-- -------------------------------------------

	tW, tH = DrawText( "Legacy Addons with models:", "AddonInfo_Text", 0, txtH, color_white )
	txtH = txtH + tH

	if ( table.Count( self.LegacyAddons or {} ) > 0 ) then
		local maxNameW = 0
		local oldH = txtH
		for path, status in pairs( self.LegacyAddons or {} ) do
			tW, tH = DrawText( path, "AddonInfo_Small", 0, txtH, color_white )
			maxNameW = math.max( maxNameW, tW )
			txtH = txtH + tH
		end

		maxNameW = maxNameW + 25
		txtH = oldH

		for path, status in pairs( self.LegacyAddons or {} ) do
			tW, tH = DrawText( status, "AddonInfo_Small", maxNameW, txtH, Color( 220, 220, 220 ) )
			txtH = txtH + tH
		end
	else
		tW, tH = DrawText( "None.", "AddonInfo_Small", 0, txtH, color_white )
		txtH = txtH + tH
	end

	if ( !system.IsWindows() ) then
		txtH = txtH + tH

		tW, tH = DrawText( "OSX AND LINUX USERS BEWARE:", "AddonInfo_Text", 0, txtH, color_white )
		txtH = txtH + tH
		tW, tH = DrawText( "MAKE SURE ALL FILE AND FOLDER NAMES", "AddonInfo_Text", 0, txtH, color_white )
		txtH = txtH + tH
		tW, tH = DrawText( "IN ALL ADDONS ARE LOWERCASE ONLY", "AddonInfo_Text", 0, txtH, color_white )
		txtH = txtH + tH
		tW, tH = DrawText( "INCLUDING ALL SUB FOLDERS", "AddonInfo_Text", 0, txtH, color_white )
		txtH = txtH + tH
	end

	txtH = txtH + tH

	-- -------------------------------------------

	self:SetSize( txtW, txtH )
end

vgui.Register( "rb655_addonInfo", PANEL, "Panel" )

--[[ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ ]]

-- I spent too much time on this than I care to admit
hook.Add( "PopulatePropMenu", "rb655_LoadLegacySpawnlists", function()

	local sid = 0 --table.Count( spawnmenu.GetPropTable() )

	--local added = false

	for id, spawnlist in pairs( file.Find( "settings/spawnlist/*.txt", "MOD" ) ) do
		local content = file.Read( "settings/spawnlist/" .. spawnlist, "MOD" )
		if ( !content ) then continue end

		--[[local is = string.find( content, "TableToKeyValues" )
		if ( is != nil ) then continue end

		for id, t in pairs( spawnmenu.GetPropTable() ) do -- This somehow freezes the game when opening Q menu => FUCK THIS SHIT
			if ( t.name == "Legacy Spawnlists" ) then
				added = true
				sid = t.id
			end
		end

		if ( !added ) then
			spawnmenu.AddPropCategory( "rb655_legacy_spawnlists", "Legacy Spawnlists", {}, "icon16/folder.png", sid, 0 )
			added = true
		end]]

		content = util.KeyValuesToTable( content )

		if ( !content.entries or content.contents ) then continue end

		local contents = {}

		for eid, entry in pairs( content.entries ) do
			if ( type( entry ) == "table" ) then entry = entry.model end
			table.insert( contents, { type = "model", model = entry } )
		end

		if ( !content.information ) then content.information = { name = spawnlist } end

		spawnmenu.AddPropCategory( "settings/spawnlist/" .. spawnlist, content.information.name, contents, "icon16/page.png", sid + id, sid )

	end

end )

--lua/autorun/rotate_hyperspace.lua:
if not SERVER then return end

print("Rotate Hyperspace Loading")
hook.Add("OnEntityCreated", "RotateSWUHyperspace", function(ent)
    if ent:GetClass() != "swu_hyperspace" then return end
    
    print("Found hyperspace! rotating...", ent:GetClass())
   	timer.Simple(1, function() if not ent or not IsValid(ent) then return end ent:SetAngles(Angle(0, 0, 0)) print("Angles set.") end)
end)
--addons/mobile_ammunition/lua/autorun/rw_cvars_dispencer.lua:
CreateConVar("rw_sw_dispencer_health", "100000", 8192, "The amount of health of all dispencer")
CreateConVar("rw_sw_dispencer_timer", "2", 8192, "The cooldown between you can take ammo")
CreateConVar("rw_sw_dispencer_ammo_basic_count", "350", 8192, "The amount of basic ammo")
CreateConVar("rw_sw_dispencer_ammo_basic_count_grenade", "7", 8192, "The amount of basic ammo")
CreateConVar("rw_sw_dispencer_allammo_multiplier", "3", 8192, "The number of ammo given according to this multiplier of the clipsize")
CreateConVar("rw_sw_dispencer_ammo_crate_number", "5", 8192, "The number of ammo create you can throw with the swep")
--addons/sam/lua/sam/libs/message_pack/sh_messagepack.lua:
if SAM_LOADED then return end
--
-- lua-MessagePack : <https://fperrad.frama.io/lua-MessagePack/>
--
local SIZEOF_NUMBER = string.pack and #string.pack('n', 0.0) or 8
local maxinteger
local mininteger
local assert = assert
local error = error
local pairs = pairs
local pcall = pcall
local setmetatable = setmetatable
local tostring = tostring
local char = string.char
local format = string.format
local floor = math.floor
local tointeger = floor
local frexp = math.frexp
local ldexp = math.ldexp
local huge = math.huge
local tconcat = table.concat
local type = sam.type
local isnumber = sam.isnumber
local _ENV = nil
local m = {}

--[[ debug only
local function hexadump (s)
	return (s:gsub('.', function (c) return format('%02X ', c:byte()) end))
end
m.hexadump = hexadump
--]]
local function argerror(caller, narg, extramsg)
	error("bad argument #" .. tostring(narg) .. " to " .. caller .. " (" .. extramsg .. ")")
end

local function typeerror(caller, narg, arg, tname)
	argerror(caller, narg, tname .. " expected, got " .. type(arg))
end

local function checktype(caller, narg, arg, tname)
	if type(arg) ~= tname then
		typeerror(caller, narg, arg, tname)
	end
end

local packers = setmetatable({}, {
	__index = function(t, k)
		if k == 1 then return end -- allows ipairs
		error("pack '" .. k .. "' is unimplemented")
	end
})

m.packers = packers

packers["nil"] = function(buffer)
	buffer[#buffer + 1] = char(0xC0) -- nil
end

packers["boolean"] = function(buffer, bool)
	if bool then
		buffer[#buffer + 1] = char(0xC3) -- true
	else
		buffer[#buffer + 1] = char(0xC2) -- false
	end
end

packers["string_compat"] = function(buffer, str)
	local n = #str

	if n <= 0x1F then
		buffer[#buffer + 1] = char(0xA0 + n) -- fixstr
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDA, floor(n / 0x100), n % 0x100) -- str16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDB, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- str32
	else
		error"overflow in pack 'string_compat'"
	end

	buffer[#buffer + 1] = str
end

packers["_string"] = function(buffer, str)
	local n = #str

	if n <= 0x1F then
		buffer[#buffer + 1] = char(0xA0 + n) -- fixstr
	elseif n <= 0xFF then
		buffer[#buffer + 1] = char(0xD9, n) -- str8
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDA, floor(n / 0x100), n % 0x100) -- str16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDB, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- str32
	else
		error("overflow in pack 'string'")
	end

	buffer[#buffer + 1] = str
end

packers["binary"] = function(buffer, str)
	local n = #str

	if n <= 0xFF then
		buffer[#buffer + 1] = char(0xC4, n) -- bin8
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xC5, floor(n / 0x100), n % 0x100) -- bin16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xC6, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- bin32
	else
		error("overflow in pack 'binary'")
	end

	buffer[#buffer + 1] = str
end

local set_string = function(str)
	if str == "string_compat" then
		packers["string"] = packers["string_compat"]
	elseif str == "string" then
		packers["string"] = packers["_string"]
	elseif str == "binary" then
		packers["string"] = packers["binary"]
	else
		argerror("set_string", 1, "invalid option '" .. str .. "'")
	end
end

m.set_string = set_string

packers["map"] = function(buffer, tbl, n)
	if n <= 0x0F then
		buffer[#buffer + 1] = char(0x80 + n) -- fixmap
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDE, floor(n / 0x100), n % 0x100) -- map16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDF, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- map32
	else
		error("overflow in pack 'map'")
	end

	for k, v in pairs(tbl) do
		packers[type(k)](buffer, k)
		packers[type(v)](buffer, v)
	end
end

packers["array"] = function(buffer, tbl, n)
	if n <= 0x0F then
		buffer[#buffer + 1] = char(0x90 + n) -- fixarray
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xDC, floor(n / 0x100), n % 0x100) -- array16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xDD, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- array32
	else
		error("overflow in pack 'array'")
	end

	for i = 1, n do
		local v = tbl[i]
		packers[type(v)](buffer, v)
	end
end

local set_array = function(array)
	if array == "without_hole" then
		packers["_table"] = function(buffer, tbl)
			local is_map, n, max = false, 0, 0

			for k in pairs(tbl) do
				if isnumber(k) and k > 0 then
					if k > max then
						max = k
					end
				else
					is_map = true
				end

				n = n + 1
			end

			-- there are holes
			if max ~= n then
				is_map = true
			end

			if is_map then
				packers["map"](buffer, tbl, n)
			else
				packers["array"](buffer, tbl, n)
			end
		end
	elseif array == "with_hole" then
		packers["_table"] = function(buffer, tbl)
			local is_map, n, max = false, 0, 0

			for k in pairs(tbl) do
				if isnumber(k) and k > 0 then
					if k > max then
						max = k
					end
				else
					is_map = true
				end

				n = n + 1
			end

			if is_map then
				packers["map"](buffer, tbl, n)
			else
				packers["array"](buffer, tbl, max)
			end
		end
	elseif array == "always_as_map" then
		packers["_table"] = function(buffer, tbl)
			local n = 0

			for k in pairs(tbl) do
				n = n + 1
			end

			packers["map"](buffer, tbl, n)
		end
	else
		argerror("set_array", 1, "invalid option '" .. array .. "'")
	end
end

m.set_array = set_array

packers["table"] = function(buffer, tbl)
	packers["_table"](buffer, tbl)
end

packers["unsigned"] = function(buffer, n)
	if n >= 0 then
		if n <= 0x7F then
			buffer[#buffer + 1] = char(n) -- fixnum_pos
		elseif n <= 0xFF then
			buffer[#buffer + 1] = char(0xCC, n) -- uint8
		elseif n <= 0xFFFF then
			buffer[#buffer + 1] = char(0xCD, floor(n / 0x100), n % 0x100) -- uint16
		elseif n <= 4294967295.0 then
			buffer[#buffer + 1] = char(0xCE, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- uint32
		else
			buffer[#buffer + 1] = char(0xCF, 0, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- uint64 -- only 53 bits from double
		end
	else
		if n >= -0x20 then
			buffer[#buffer + 1] = char(0x100 + n) -- fixnum_neg
		elseif n >= -0x80 then
			buffer[#buffer + 1] = char(0xD0, 0x100 + n) -- int8
		elseif n >= -0x8000 then
			n = 0x10000 + n
			buffer[#buffer + 1] = char(0xD1, floor(n / 0x100), n % 0x100) -- int16
		elseif n >= -0x80000000 then
			n = 4294967296.0 + n
			buffer[#buffer + 1] = char(0xD2, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int32
		else
			buffer[#buffer + 1] = char(0xD3, 0xFF, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int64 -- only 53 bits from double
		end
	end
end

packers["signed"] = function(buffer, n)
	if n >= 0 then
		if n <= 0x7F then
			buffer[#buffer + 1] = char(n) -- fixnum_pos
		elseif n <= 0x7FFF then
			buffer[#buffer + 1] = char(0xD1, floor(n / 0x100), n % 0x100) -- int16
		elseif n <= 0x7FFFFFFF then
			buffer[#buffer + 1] = char(0xD2, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int32
		else
			buffer[#buffer + 1] = char(0xD3, 0, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int64 -- only 53 bits from double
		end
	else
		if n >= -0x20 then
			buffer[#buffer + 1] = char(0xE0 + 0x20 + n) -- fixnum_neg
		elseif n >= -0x80 then
			buffer[#buffer + 1] = char(0xD0, 0x100 + n) -- int8
		elseif n >= -0x8000 then
			n = 0x10000 + n
			buffer[#buffer + 1] = char(0xD1, floor(n / 0x100), n % 0x100) -- int16
		elseif n >= -0x80000000 then
			n = 4294967296.0 + n
			buffer[#buffer + 1] = char(0xD2, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int32
		else
			buffer[#buffer + 1] = char(0xD3, 0xFF, floor(n / 0x1000000000000) % 0x100, floor(n / 0x10000000000) % 0x100, floor(n / 0x100000000) % 0x100, floor(n / 0x1000000) % 0x100, floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100) -- int64 -- only 53 bits from double
		end
	end
end

local set_integer = function(integer)
	if integer == "unsigned" then
		packers["integer"] = packers["unsigned"]
	elseif integer == "signed" then
		packers["integer"] = packers["signed"]
	else
		argerror("set_integer", 1, "invalid option '" .. integer .. "'")
	end
end

m.set_integer = set_integer

packers["float"] = function(buffer, n)
	local sign = 0

	if n < 0.0 then
		sign = 0x80
		n = -n
	end

	local mant, expo = frexp(n)

	if mant ~= mant then
		buffer[#buffer + 1] = char(0xCA, 0xFF, 0x88, 0x00, 0x00) -- nan
	elseif mant == huge or expo > 0x80 then
		if sign == 0 then
			buffer[#buffer + 1] = char(0xCA, 0x7F, 0x80, 0x00, 0x00) -- inf
		else
			buffer[#buffer + 1] = char(0xCA, 0xFF, 0x80, 0x00, 0x00) -- -inf
		end
	elseif (mant == 0.0 and expo == 0) or expo < -0x7E then
		buffer[#buffer + 1] = char(0xCA, sign, 0x00, 0x00, 0x00) -- zero
	else
		expo = expo + 0x7E
		mant = floor((mant * 2.0 - 1.0) * ldexp(0.5, 24))
		buffer[#buffer + 1] = char(0xCA, sign + floor(expo / 0x2), (expo % 0x2) * 0x80 + floor(mant / 0x10000), floor(mant / 0x100) % 0x100, mant % 0x100)
	end
end

packers["double"] = function(buffer, n)
	local sign = 0

	if n < 0.0 then
		sign = 0x80
		n = -n
	end

	local mant, expo = frexp(n)

	if mant ~= mant then
		buffer[#buffer + 1] = char(0xCB, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- nan
	elseif mant == huge or expo > 0x400 then
		if sign == 0 then
			buffer[#buffer + 1] = char(0xCB, 0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- inf
		else
			buffer[#buffer + 1] = char(0xCB, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- -inf
		end
	elseif (mant == 0.0 and expo == 0) or expo < -0x3FE then
		buffer[#buffer + 1] = char(0xCB, sign, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) -- zero
	else
		expo = expo + 0x3FE
		mant = floor((mant * 2.0 - 1.0) * ldexp(0.5, 53))
		buffer[#buffer + 1] = char(0xCB, sign + floor(expo / 0x10), (expo % 0x10) * 0x10 + floor(mant / 0x1000000000000), floor(mant / 0x10000000000) % 0x100, floor(mant / 0x100000000) % 0x100, floor(mant / 0x1000000) % 0x100, floor(mant / 0x10000) % 0x100, floor(mant / 0x100) % 0x100, mant % 0x100)
	end
end

local set_number = function(number)
	if number == "float" then
		packers["number"] = function(buffer, n)
			if floor(n) == n and n < maxinteger and n > mininteger then
				packers["integer"](buffer, n)
			else
				packers["float"](buffer, n)
			end
		end
	elseif number == "double" then
		packers["number"] = function(buffer, n)
			if floor(n) == n and n < maxinteger and n > mininteger then
				packers["integer"](buffer, n)
			else
				packers["double"](buffer, n)
			end
		end
	else
		argerror("set_number", 1, "invalid option '" .. number .. "'")
	end
end

m.set_number = set_number

for k = 0, 4 do
	local n = tointeger(2 ^ k)
	local fixext = 0xD4 + k

	packers["fixext" .. tostring(n)] = function(buffer, tag, data)
		assert(#data == n, "bad length for fixext" .. tostring(n))
		buffer[#buffer + 1] = char(fixext, tag < 0 and tag + 0x100 or tag)
		buffer[#buffer + 1] = data
	end
end

packers["ext"] = function(buffer, tag, data)
	local n = #data

	if n <= 0xFF then
		buffer[#buffer + 1] = char(0xC7, n, tag < 0 and tag + 0x100 or tag) -- ext8
	elseif n <= 0xFFFF then
		buffer[#buffer + 1] = char(0xC8, floor(n / 0x100), n % 0x100, tag < 0 and tag + 0x100 or tag) -- ext16
	elseif n <= 4294967295.0 then
		buffer[#buffer + 1] = char(0xC9, floor(n / 0x1000000), floor(n / 0x10000) % 0x100, floor(n / 0x100) % 0x100, n % 0x100, tag < 0 and tag + 0x100 or tag) -- ext&32
	else
		error("overflow in pack 'ext'")
	end

	buffer[#buffer + 1] = data
end

function m.pack(data)
	local buffer = {}
	packers[type(data)](buffer, data)

	return tconcat(buffer)
end

local unpackers -- forward declaration

local function unpack_cursor(c)
	local s, i, j = c.s, c.i, c.j

	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end

	local val = s:byte(i)
	c.i = i + 1

	return unpackers[val](c, val)
end

m.unpack_cursor = unpack_cursor

local function unpack_str(c, n)
	local s, i, j = c.s, c.i, c.j
	local e = i + n - 1

	if e > j or n < 0 then
		c:underflow(e)
		s, i, j = c.s, c.i, c.j
		e = i + n - 1
	end

	c.i = i + n

	return s:sub(i, e)
end

local function unpack_array(c, n)
	local t = {}

	for i = 1, n do
		t[i] = unpack_cursor(c)
	end

	return t
end

local function unpack_map(c, n)
	local t = {}

	for i = 1, n do
		local k = unpack_cursor(c)
		local val = unpack_cursor(c)

		if k == nil or k ~= k then
			k = m.sentinel
		end

		if k ~= nil then
			t[k] = val
		end
	end

	return t
end

local function unpack_float(c)
	local s, i, j = c.s, c.i, c.j

	if i + 3 > j then
		c:underflow(i + 3)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4 = s:byte(i, i + 3)
	local sign = b1 > 0x7F
	local expo = (b1 % 0x80) * 0x2 + floor(b2 / 0x80)
	local mant = ((b2 % 0x80) * 0x100 + b3) * 0x100 + b4

	if sign then
		sign = -1
	else
		sign = 1
	end

	local n

	if mant == 0 and expo == 0 then
		n = sign * 0.0
	elseif expo == 0xFF then
		if mant == 0 then
			n = sign * huge
		else
			n = 0.0 / 0.0
		end
	else
		n = sign * ldexp(1.0 + mant / 0x800000, expo - 0x7F)
	end

	c.i = i + 4

	return n
end

local function unpack_double(c)
	local s, i, j = c.s, c.i, c.j

	if i + 7 > j then
		c:underflow(i + 7)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i + 7)
	local sign = b1 > 0x7F
	local expo = (b1 % 0x80) * 0x10 + floor(b2 / 0x10)
	local mant = ((((((b2 % 0x10) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8

	if sign then
		sign = -1
	else
		sign = 1
	end

	local n

	if mant == 0 and expo == 0 then
		n = sign * 0.0
	elseif expo == 0x7FF then
		if mant == 0 then
			n = sign * huge
		else
			n = 0.0 / 0.0
		end
	else
		n = sign * ldexp(1.0 + mant / 4503599627370496.0, expo - 0x3FF)
	end

	c.i = i + 8

	return n
end

local function unpack_uint8(c)
	local s, i, j = c.s, c.i, c.j

	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end

	local b1 = s:byte(i)
	c.i = i + 1

	return b1
end

local function unpack_uint16(c)
	local s, i, j = c.s, c.i, c.j

	if i + 1 > j then
		c:underflow(i + 1)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2 = s:byte(i, i + 1)
	c.i = i + 2

	return b1 * 0x100 + b2
end

local function unpack_uint32(c)
	local s, i, j = c.s, c.i, c.j

	if i + 3 > j then
		c:underflow(i + 3)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4 = s:byte(i, i + 3)
	c.i = i + 4

	return ((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4
end

local function unpack_uint64(c)
	local s, i, j = c.s, c.i, c.j

	if i + 7 > j then
		c:underflow(i + 7)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i + 7)
	c.i = i + 8

	return ((((((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
end

local function unpack_int8(c)
	local s, i, j = c.s, c.i, c.j

	if i > j then
		c:underflow(i)
		s, i, j = c.s, c.i, c.j
	end

	local b1 = s:byte(i)
	c.i = i + 1

	if b1 < 0x80 then
		return b1
	else
		return b1 - 0x100
	end
end

local function unpack_int16(c)
	local s, i, j = c.s, c.i, c.j

	if i + 1 > j then
		c:underflow(i + 1)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2 = s:byte(i, i + 1)
	c.i = i + 2

	if b1 < 0x80 then
		return b1 * 0x100 + b2
	else
		return ((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) - 1
	end
end

local function unpack_int32(c)
	local s, i, j = c.s, c.i, c.j

	if i + 3 > j then
		c:underflow(i + 3)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4 = s:byte(i, i + 3)
	c.i = i + 4

	if b1 < 0x80 then
		return ((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4
	else
		return ((((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) * 0x100 + (b3 - 0xFF)) * 0x100 + (b4 - 0xFF)) - 1
	end
end

local function unpack_int64(c)
	local s, i, j = c.s, c.i, c.j

	if i + 7 > j then
		c:underflow(i + 7)
		s, i, j = c.s, c.i, c.j
	end

	local b1, b2, b3, b4, b5, b6, b7, b8 = s:byte(i, i + 7)
	c.i = i + 8

	if b1 < 0x80 then
		return ((((((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
	else
		return ((((((((b1 - 0xFF) * 0x100 + (b2 - 0xFF)) * 0x100 + (b3 - 0xFF)) * 0x100 + (b4 - 0xFF)) * 0x100 + (b5 - 0xFF)) * 0x100 + (b6 - 0xFF)) * 0x100 + (b7 - 0xFF)) * 0x100 + (b8 - 0xFF)) - 1
	end
end

function m.build_ext(tag, data)
	return nil
end

local function unpack_ext(c, n, tag)
	local s, i, j = c.s, c.i, c.j
	local e = i + n - 1

	if e > j or n < 0 then
		c:underflow(e)
		s, i, j = c.s, c.i, c.j
		e = i + n - 1
	end

	c.i = i + n

	return m.build_ext(tag, s:sub(i, e))
end

local fn_1 = function(c, val) return val end
local fn_2 = function(c, val) return unpack_map(c, val % 0x10) end
local fn_3 = function(c, val) return unpack_array(c, val % 0x10) end
local fn_4 = function(c, val) return unpack_str(c, val % 0x20) end
local fn_5 = function(c, val) return val - 0x100 end

unpackers = setmetatable({
	[0xC0] = function() return nil end,
	[0xC2] = function() return false end,
	[0xC3] = function() return true end,
	[0xC4] = function(c) return unpack_str(c, unpack_uint8(c)) end, -- bin8
	[0xC5] = function(c) return unpack_str(c, unpack_uint16(c)) end, -- bin16
	[0xC6] = function(c) return unpack_str(c, unpack_uint32(c)) end, -- bin32
	[0xC7] = function(c) return unpack_ext(c, unpack_uint8(c), unpack_int8(c)) end,
	[0xC8] = function(c) return unpack_ext(c, unpack_uint16(c), unpack_int8(c)) end,
	[0xC9] = function(c) return unpack_ext(c, unpack_uint32(c), unpack_int8(c)) end,
	[0xCA] = unpack_float,
	[0xCB] = unpack_double,
	[0xCC] = unpack_uint8,
	[0xCD] = unpack_uint16,
	[0xCE] = unpack_uint32,
	[0xCF] = unpack_uint64,
	[0xD0] = unpack_int8,
	[0xD1] = unpack_int16,
	[0xD2] = unpack_int32,
	[0xD3] = unpack_int64,
	[0xD4] = function(c) return unpack_ext(c, 1, unpack_int8(c)) end,
	[0xD5] = function(c) return unpack_ext(c, 2, unpack_int8(c)) end,
	[0xD6] = function(c) return unpack_ext(c, 4, unpack_int8(c)) end,
	[0xD7] = function(c) return unpack_ext(c, 8, unpack_int8(c)) end,
	[0xD8] = function(c) return unpack_ext(c, 16, unpack_int8(c)) end,
	[0xD9] = function(c) return unpack_str(c, unpack_uint8(c)) end,
	[0xDA] = function(c) return unpack_str(c, unpack_uint16(c)) end,
	[0xDB] = function(c) return unpack_str(c, unpack_uint32(c)) end,
	[0xDC] = function(c) return unpack_array(c, unpack_uint16(c)) end,
	[0xDD] = function(c) return unpack_array(c, unpack_uint32(c)) end,
	[0xDE] = function(c) return unpack_map(c, unpack_uint16(c)) end,
	[0xDF] = function(c) return unpack_map(c, unpack_uint32(c)) end
}, {
	__index = function(t, k)
		if k < 0xC0 then
			if k < 0x80 then
				return fn_1
			elseif k < 0x90 then
				return fn_2
			elseif k < 0xA0 then
				return fn_3
			else
				return fn_4
			end
		elseif k > 0xDF then
			return fn_5
		else
			return function()
				error("unpack '" .. format("%#x", k) .. "' is unimplemented")
			end
		end
	end
})

local function cursor_string(str)
	return {
		s = str,
		i = 1,
		j = #str,
		underflow = function()
			error"missing bytes"
		end
	}
end

local function cursor_loader(ld)
	return {
		s = '',
		i = 1,
		j = 0,
		underflow = function(self, e)
			self.s = self.s:sub(self.i)
			e = e - self.i + 1
			self.i = 1
			self.j = 0

			while e > self.j do
				local chunk = ld()

				if not chunk then
					error"missing bytes"
				end

				self.s = self.s .. chunk
				self.j = #self.s
			end
		end
	}
end

function m.unpack(s)
	checktype("unpack", 1, s, "string")
	local cursor = cursor_string(s)
	local data = unpack_cursor(cursor)

	if cursor.i <= cursor.j then
		error("extra bytes")
	end

	return data
end

function m.unpacker(src)
	if type(src) == "string" then
		local cursor = cursor_string(src)

		return function()
			if cursor.i <= cursor.j then return cursor.i, unpack_cursor(cursor) end
		end
	elseif type(src) == "function" then
		local cursor = cursor_loader(src)

		return function()
			if cursor.i > cursor.j then
				pcall(cursor.underflow, cursor, cursor.i)
			end

			if cursor.i <= cursor.j then return true, unpack_cursor(cursor) end
		end
	else
		argerror("unpacker", 1, "string or function expected, got " .. type(src))
	end
end

set_string("string")
set_integer("unsigned")

if SIZEOF_NUMBER == 4 then
	maxinteger = 16777215
	mininteger = -maxinteger
	m.small_lua = true
	unpackers[0xCB] = nil -- double
	unpackers[0xCF] = nil -- uint64
	unpackers[0xD3] = nil -- int64
	set_number("float")
else
	maxinteger = 9007199254740991
	mininteger = -maxinteger
	set_number("double")

	if SIZEOF_NUMBER > 8 then
		m.long_double = true
	end
end

set_array("always_as_map")
m._VERSION = "0.5.2"
m._DESCRIPTION = "lua-MessagePack : a pure Lua implementation"
m._COPYRIGHT = "Copyright (c) 2012-2019 Francois Perrad"

return m
--
-- This library is licensed under the terms of the MIT/X11 license,
-- like Lua itself.
--
--addons/sam/lua/sam/sh_lang.lua:
if SAM_LOADED then return end

local lang = sam.load_file("sam_language.lua", "sh")

local original = lang
if not isstring(lang) then
	lang = "english"
end

local lang_path = "sam_languages/" .. lang .. ".lua"

if not file.Exists(lang_path, "LUA") then
	lang_path = "sam_languages/english.lua"
	if not file.Exists(lang_path, "LUA") then
		-- maybe they deleted english lang????
		sam.print("SAM is broken!")
		sam.print("Language '" .. tostring(original) .. "' doesn't exist and 'english' language file doesn't exist")
		return false
	else
		sam.print("Language '" .. tostring(original) .. "' doesn't exist falling back to english")
	end
end

local Language = sam.load_file(lang_path, "sh_")

local sub, find = string.sub, string.find

local white_color = Color(236, 240, 241)

do
	local args = {}
	function sam.add_message_argument(arg, func)
		if isstring(arg) and isfunction(func) then
			args[arg] = func
		end
	end

	local insert = function(t, v)
		t.__cnt = t.__cnt + 1
		t[t.__cnt] = v
	end

	function sam.format_message(msg, tbl, result, result_n)
		msg = Language[msg] or msg

		result = result or {}
		result.__cnt = result_n or 0

		local pos = 0
		local start, _end, arg, arg2 = nil, 0, nil, nil

		while true do
			start, _end, arg, arg2 = find(msg, "%{ *([%w_%#]+)([^%{}]-) *%}", _end)
			if not start then break end

			if pos ~= start then
				local txt = sub(msg, pos, start - 1)
				if txt ~= "" then
					insert(result, white_color)
					insert(result, txt)
				end
			end

			local ma = args[sub(arg, 1, 1)]
			if not ma then
				insert(result, "{" .. arg .. " " .. arg2 .. "}")
			else
				ma(result, tbl and tbl[arg], arg, unpack(arg2:Trim():Split(" ")))
			end

			pos = _end + 1
		end

		if pos <= #msg then
			insert(result, white_color)
			insert(result, sub(msg, pos))
		end

		return result
	end

	/*
		Admin
	*/
	sam.add_message_argument("A", function(result, admin)
		if sam.isconsole(admin) then
			-- we need to show that it's the real console!!!!!
			insert(result, Color(236, 240, 241))
			insert(result, "*")
			insert(result, Color(13, 130, 223))
			insert(result, "Console")
		else
			if sam.type(admin) == "Player" then
				if CLIENT and LocalPlayer() == admin then
					insert(result, Color(255, 215, 0))
					insert(result, sam.language.get("You"))
				else
					insert(result, Color(13, 130, 223))
					insert(result, admin:Name())
				end
			else
				insert(result, Color(13, 130, 223))
				insert(result, admin)
			end
		end
	end)

	/*
		Target(s)
	*/
	sam.add_message_argument("T", function(result, targets)
		for k, v in ipairs(sam.get_targets_list(targets)) do
			insert(result, v)
		end
	end)

	/*
		Value(s)
	*/
	sam.add_message_argument("V", function(result, value)
		insert(result, Color(0, 230, 64))
		insert(result, tostring(value))
	end)

	/*
		Text(s)
	*/
	sam.add_message_argument("S", function(result, text, _, color)
		insert(result, sam.get_color(color) or white_color)
		insert(result, tostring(text))
	end)

	-- https://gist.github.com/fernandohenriques/12661bf250c8c2d8047188222cab7e28
	local hex_rgb = function(hex)
		local r, g, b
		if #hex == 4 then
			r, g, b = tonumber(hex:sub(2, 2), 16) * 17, tonumber(hex:sub(3, 3), 16) * 17, tonumber(hex:sub(4, 4), 16) * 17
		else
			r, g, b = tonumber(hex:sub(2, 3), 16), tonumber(hex:sub(4, 5), 16), tonumber(hex:sub(6, 7), 16)
		end

		if not r or not g or not b then
			return color_white
		end

		return Color(r, g, b)
	end

	/*
		Colored Text(s)
	*/
	sam.add_message_argument("#", function(result, _, color, ...)
		local text = table.concat({...}, " ")
		insert(result, hex_rgb(color))
		insert(result, text)
	end)
end

function sam.get_message(msg)
	msg = Language[msg]
	if not msg then
		return false
	else
		return {Color(236, 240, 241), msg}
	end
end

function sam.language.get(key)
	return Language[key]
end

function sam.language.Add(key, value)
	Language[key] = value
end
--addons/sam/lua/sam_language.lua:
return "english"
--addons/sam/lua/sam/config/cl_config.lua:
if SAM_LOADED then return end

local sam = sam
local mp = sam.mp
local config = sam.config

function config.set(key, value, force)
	if not sam.isstring(key) then
		error("invalid setting name")
	end

	if not mp.packers[sam.type(value)] then
		error("not supported value type")
	end

	if not force and config.get(key) == value then return end
	sam.netstream.Start("Config.Set", key, value)
end

function config.get(key, default)
	local value = sam.get_global("Config")[key]
	if value ~= nil then
		return value
	end
	return default
end

local menu_settings = {}
function config.add_menu_setting(title, func)
	local i = #menu_settings + 1
	for k, v in ipairs(menu_settings) do
		if v.title == title then
			i = k
			break
		end
	end
	menu_settings[i] = {
		title = title,
		func = func,
	}
end

function config.get_menu_settings()
	return menu_settings
end

hook.Add("SAM.ChangedGlobalVar", "SAM.CheckLoadedConfig", function(key, value)
	if key == "Config" then
		config.loaded = true
		hook.Call("SAM.LoadedConfig", nil, value)
		hook.Remove("SAM.ChangedGlobalVar", "SAM.CheckLoadedConfig")
	end
end)
--addons/sam/lua/sam/player/sh_nw_vars.lua:
if SAM_LOADED then return end

local netstream = sam.netstream

local nwvars = {}

if SERVER then
	function sam.player.set_nwvar(ply, key, value, force)
		local id = ply:EntIndex()
		if force or nwvars[id][key] ~= value then
			nwvars[id][key] = value
			netstream.Start(nil, "SetNWVar", id, key, value)
		end
	end
end

if CLIENT then
	function sam.player.set_nwvar(ply, key, value)
		local id_vars = nwvars[ply:EntIndex()]
		id_vars[key] = value
	end

	netstream.Hook("SetNWVar", function(id, key, value)
		local id_vars = nwvars[id]
		if id_vars == nil then
			nwvars[id] = {
				[key] = value
			}
		else
			id_vars[key] = value
		end
	end)

	netstream.Hook("SendNWVars", function(vars)
		nwvars = vars
	end)

	netstream.Hook("RemoveNWVar", function(id)
		nwvars[id] = nil
	end)
end

function sam.player.get_nwvar(ply, key, default)
	local value = nwvars[ply:EntIndex()]
	if value then
		value = value[key]
		if value ~= nil then
			return value
		end
	end
	return default
end

if SERVER then
	hook.Add("OnEntityCreated", "SAM.NWVars", function(ent)
		if ent:IsPlayer() and ent:IsValid() then
			nwvars[ent:EntIndex()] = {}
			netstream.Start(ent, "SendNWVars", nwvars)
		end
	end)

	hook.Add("EntityRemoved", "SAM.NWVars", function(ent)
		if ent:IsPlayer() then
			local id = ent:EntIndex()
			nwvars[id] = nil
			netstream.Start(nil, "RemoveNWVar", id)
		end
	end)
end
--addons/sam/lua/sam/command/sh_command.lua:
if SAM_LOADED then return end

local sam = sam
local istable, isstring = sam.istable, sam.isstring

local commands = {}
local arguments = {}

do
	local command = {}

	local current_category = "other"
	function command.set_category(category)
		if isstring(category) then
			current_category = category
		end
	end

	function command.get_commands()
		return commands
	end

	function command.get_command(name)
		for i = 1, #commands do
			local cmd = commands[i]
			if cmd.name == name then
				return cmd, i
			end

			local aliases = cmd.aliases
			for i2 = 1, #aliases do
				local alias = aliases[i2]
				if alias == name then
					return cmd, i
				end
			end
		end
		return false
	end

	function command.remove_command(name)
		local cmd, index = command.get_command(name)
		if index then
			table.remove(commands, index)
			hook.Call("SAM.CommandRemoved", nil, cmd.name, cmd, index)
			return index
		end
		return false
	end

	function command.get_arguments()
		return arguments
	end

	do
		local argument_methods = {
			OnExecute = function(self, func)
				if isfunction(func) and SERVER then
					self.on_execute = func
				end
				return self
			end,
			Menu = function(self, func)
				if isfunction(func) and CLIENT then
					self.menu = func
				end
				return self
			end,
			AutoComplete = function(self, func)
				if isfunction(func) and CLIENT then
					self.auto_complete = func
				end
				return self
			end,
			End = function(self)
				if SERVER then
					arguments[self.name] = self.on_execute
				else
					arguments[self.name] = self
				end
			end
		}

		local argument_meta = {__index = argument_methods}
		function command.new_argument(name)
			if isstring(name) then
				return setmetatable({name = name}, argument_meta)
			end
		end
	end

	if CLIENT then
		function command.run_commands(to_run)
			local time = 0
			for i = 1, #to_run do
				timer.Simple(time, function()
					RunConsoleCommand("sam", unpack(to_run[i]))
				end)
				time = time + 0.76
			end
		end
	end

	--
	-- Methods
	--
	local Command_Methods = {}
	local Command_meta = {__index = Command_Methods}

	function command.new(cmd)
		if not isstring(cmd) then return end

		local new_command = setmetatable({}, Command_meta)
		new_command.can_console_run = true
		new_command.args = {}
		new_command.name = cmd:lower()
		new_command.aliases = {}
		new_command.category = current_category

		return new_command
	end

	local AddMethod = function(name, func)
		Command_Methods[name] = func
	end

	AddMethod("Aliases", function(self, ...)
		for k, v in ipairs({...}) do
			table.insert(self.aliases, v)
		end
		return self
	end)

	AddMethod("AddArg", function(self, name, data)
		if not isstring(name) then return end
		if not istable(data) then
			data = {}
		end
		data.name = name
		table.insert(self.args, data)
		return self
	end)

	AddMethod("DisallowConsole", function(self, disallow)
		self.can_console_run = isbool(disallow) and disallow or false
		return self
	end)

	AddMethod("SetCategory", function(self, category)
		if isstring(category) then
			self.category = category
		end
		return self
	end)

	AddMethod("Help", function(self, help)
		if isstring(help) then
			self.help = sam.language.get(help) or help
		end
		return self
	end)

	AddMethod("OnExecute", function(self, func)
		if isfunction(func) and SERVER then
			self.on_execute = func
		end
		return self
	end)

	AddMethod("SetPermission", function(self, perm, default_rank)
		if isstring(perm) then
			self.permission = perm
			self.default_rank = default_rank
		end
		return self
	end)

	AddMethod("GetRestArgs", function(self, get)
		if not isbool(get) then
			get = true
		end
		self.get_rest_args = get
		return self
	end)

	AddMethod("MenuHide", function(self, should_hide)
		if isbool(should_hide) then
			self.menu_hide = should_hide
		else
			self.menu_hide = true
		end
		return self
	end)

	AddMethod("DisableNotify", function(self, disable)
		if isbool(disable) then
			self.disable_notify = disable
		else
			self.disable_notify = true
		end
		return self
	end)

	AddMethod("End", function(self)
		local name = self.name
		if SERVER and not self.on_execute then
			sam.print("need an OnExecute function for the command!")
			debug.Trace()
			return
		end

		if self.permission then
			sam.permissions.add(self.permission, "Commands - " .. self.category, self.default_rank)
		end

		local _, index = command.get_command(name)
		if index then
			commands[index] = self
			hook.Call("SAM.CommandModified", nil, name, self, index)
		else
			hook.Call("SAM.CommandAdded", nil, name, self, table.insert(commands, self))
		end
	end)

	AddMethod("GetRequiredArgs", function(self)
		local required_args = {}
		local args = self.args
		for i = 1, #args do
			local v = args[i]
			if not v.optional then
				table.insert(required_args, v)
			end
		end
		return required_args
	end)

	AddMethod("GetOptionalArgs", function(self)
		local optional_args = {}
		local args = self.args
		for i = 1, #args do
			local v = args[i]
			if v.optional then
				table.insert(optional_args, v)
			end
		end
		return optional_args
	end)

	AddMethod("ArgsToString", function(self, return_table)
		local str_table = {}
		local args = self.args
		for i = 1, #self.args do
			local v = args[i]
			if not v.optional then
				table.insert(str_table, "<" .. (v.hint or v.name) .. ">")
			else
				table.insert(str_table, "[" .. (v.hint or v.name) .. "]")
			end
		end
		return return_table and str_table or table.concat(str_table, " ")
	end)

	AddMethod("HasArg", function(self, arg)
		local args = self.args
		for i = 1, #self.args do
			if args[i].name == arg then
				return true
			end
		end
		return false
	end)

	command.add_method = AddMethod

	sam.command = command
end

sam.__commands = commands
sam.__arguments = arguments
--addons/sui/lua/sui/vgui/sui_combobox.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local TEXT_FONT = SUI.CreateFont("ComboBox", "Roboto Regular", 16)

local GetColor = SUI.GetColor
local draw_material = sui.draw_material

local PANEL = {}

PANEL.NoOverrideClear = true

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()
	self.DropButton:Remove()
	self:SetFont(TEXT_FONT)
	self:SetSize(34, 22)
	self:SetIsMenu(true)

	local image = self:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/arrow.png")
	image.Draw = self.Paint
end

function PANEL:OpenMenu(pControlOpener)
	if pControlOpener and pControlOpener == self.TextEntry then return end
	if #self.Choices == 0 then return end

	if IsValid(self.Menu) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self.Menu = vgui.Create(NAME .. ".Menu", self)
	self.Menu:SetInternal(self)

	for k, v in ipairs(self.Choices) do
		self.Menu:AddOption(v, function()
			self:ChooseOption(v, k)
		end)
	end

	local x, y = self:LocalToScreen(0, self:GetTall())
	self.Menu:SetMinimumWidth(self:GetWide())
	self.Menu:Open(x, y, false, self)
end

function PANEL:Paint(w, h, from_image)
	local text_color = GetColor("menu_option_hover_text")

	if from_image then
		local size = SUI.ScaleEven(10)
		draw_material(nil, w - (size / 2) - 6, h / 2, size, text_color)
	else
		local col = GetColor("menu")
		self:RoundedBox("Background", 4, 0, 0, w, h, col)
		self:SetTextColor(text_color)
	end
end

function PANEL:PerformLayout()
end

sui.register("ComboBox", PANEL, "DComboBox")
--addons/sui/lua/sui/libs/png_encoder.lua:
local string = string
local table = table
local bit = bit

local char = string.char
local byte = string.byte

local insert = table.insert
local concat = table.concat

local bor = bit.bor
local bxor = bit.bxor
local band = bit.band
local bnot = bit.bnot
local lshift = bit.lshift
local rshift = bit.rshift

local ceil = math.ceil

local SIGNATURE = char(137, 80, 78, 71, 13, 10, 26, 10)

local crc_table = {}; do
	local n = 0
	while n < 256 do
		local c = n
		local k = 0
		while k < 8 do
			if band(c, 1) ~= 0 then
				c = bxor(0xedb88320, rshift(c, 1))
			else
				c = rshift(c, 1)
			end
			k = k + 1
		end
		crc_table[n + 1] = c
		n = n + 1
	end
end

local crc = function(buf)
	local c = 0xffffffff
	for i = 1, #buf do
		c = bxor(crc_table[band(bxor(c, byte(buf, i)), 0xff) + 1], rshift(c, 8))
	end
	return bxor(c, 0xffffffff)
end

local dword_as_string = function(dword)
	return char(
		rshift(band(dword, 0xff000000), 24),
		rshift(band(dword, 0x00ff0000), 16),
		rshift(band(dword, 0x0000ff00), 8),
		band(dword, 0x000000ff)
	)
end

local create_chunk = function(type, data, length)
	local CRC = crc(type .. data)
	return concat({
		dword_as_string(length or #data),
		type,
		data,
		dword_as_string(CRC)
	}, "", 1, 4)
end

local create_IHDR; do
	local ARGS = (
		-- bit depth
		char(8) ..
		-- color type: 6=truecolor with alpha
		char(6) ..
		-- compression method: 0=deflate, only allowed value
		char(0) ..
		-- filtering: 0=adaptive, only allowed value
		char(0) ..
		-- interlacing: 0=none
		char(0)
	)

	create_IHDR = function(w, h)
		return create_chunk("IHDR", concat({
			dword_as_string(w),
			dword_as_string(h),
			ARGS
		}, "", 1, 3), 13)
	end
end

local deflate_pack; do
	local BASE = 6552
	local NMAX = 5552
	local adler32 = function(str)
		local s1 = 1
		local s2 = 0
		local n = NMAX

		for i = 1, #str do
			s1 = s1 + byte(str, i)
			s2 = s2 + s1

			n = n - 1
			if n == 0 then
				s1 = s1 % BASE
				s2 = s2 % BASE
				n = NMAX
			end
		end

		s1 = s1 % BASE
		s2 = s2 % BASE

		return bor(lshift(s2, 16), s1)
	end

	local splitChunks = function(chunk, chunkSize)
		local len = ceil(#chunk / chunkSize)
		local ret = {}
		for i = 1, len do
			ret[i - 1] = chunk:sub(((i - 1) * chunkSize) + 1, chunkSize)
		end
		return ret
	end

	deflate_pack = function(str)
		local ret = {"\x78\x9c"}

		local chunks = splitChunks(str, 0xFFFF)
		local len = #chunks

		local i = 0
		while i < (len + 1) do
			local chunk = chunks[i]
			local chunk_n = #chunk

			insert(ret, i < len and "\x00" or "\x01")
			insert(ret, char(band(chunk_n, 0xff), band(rshift(chunk_n, 8), 0xff)))
			insert(ret, char(band(bnot(chunk_n), 0xff), band(rshift(bnot(chunk_n), 8), 0xff)))
			insert(ret, chunk)
			i = i + 1
		end

		local t = adler32(str)
		t = char(
			band(rshift(t, 24), 0xff),
			band(rshift(t, 16), 0xff),
			band(rshift(t, 8), 0xff),
			band(t, 0xff)
		)

		insert(ret, t)

		return concat(ret)
	end
end

local create_IDAT; do
	local slice = function(a, s, e)
		local ret, j = {}, 0
		for i = s, e - 1 do
			ret[j] = char(band(a[i] or 0, 0xFF))
			j = j + 1
		end
		return ret
	end

	local array_split_chunks = function(w, h, array, chunkSize)
		local ret = {}
		local i = 0
		local len = ceil((w * h * 4 + 4) / chunkSize)
		while i < len do
			ret[i] = slice(array, i * chunkSize, (i + 1) * chunkSize)
			i = i + 1
		end
		return ret
	end

	create_IDAT = function(w, h, chunk)
		local scanlines = array_split_chunks(w, h, chunk, w * 4)

		local image_bytes = {}
		for i = 0, #scanlines do
			local scanline = scanlines[i]
			insert(image_bytes, char(band(0, 0xFF)))
			insert(image_bytes, concat(scanline, "", 0, #scanline))
		end
		image_bytes = deflate_pack(concat(image_bytes))

		return create_chunk("IDAT", image_bytes)
	end
end

local IEND = create_chunk("IEND", "", 0)
local to_return = {SIGNATURE, nil, nil, IEND}
local generate_png = function(w, h, chunk)
	local IHDR = create_IHDR(w, h)
	local IDAT = create_IDAT(w, h, chunk)

	to_return[2] = IHDR
	to_return[3] = IDAT

	return concat(to_return, "", 1, 4)
end

return generate_png
--addons/sui/lua/sui/vgui/sui_label_panel.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local LABEL_FONT = SUI.CreateFont("LabelPanel", "Roboto", 18)

local PANEL = {}

local add = function(s, c)
	if IsValid(s.pnl) then
		s.pnl:Remove()
	end

	local pnl = vgui.Create(c, s)
	s.pnl = pnl

	return pnl
end

function PANEL:Init()
	self.title = ""

	local label = self:Add(NAME .. ".Label")
	label:Dock(LEFT)
	self.label = label

	self:SetFont(LABEL_FONT)

	self:Dock(TOP)
	self:InvalidateLayout(true)
	self.Add = add
end

function PANEL:SetPanel(pnl)
	if IsValid(self.pnl) then
		self.pnl:Remove()
	end

	pnl:SetParent(self)
	self.pnl = pnl
end

function PANEL:SetLabel(lbl)
	self.title = lbl
	self:InvalidateLayout(true)
end

function PANEL:SetFont(font)
	self.font = font
	self.label:SetFont(font)
end

function PANEL:PerformLayout(w, h)
	local label = self.label
	local pnl = self.pnl

	local pnl_w, pnl_h = 0, 0
	if pnl then
		pnl_w, pnl_h = pnl:GetSize()
	end

	label:SetWide(w - pnl_w - 4)
	label:SetText(sui.wrap_text(self.title, self.font, w - pnl_w - 4))

	local _, _h = label:GetTextSize()
	self:SetTall(math.max(_h, pnl_h))

	if pnl then
		pnl:SetPos(w - pnl_w, h / 2 - pnl_h / 2)
	end
end

sui.register("LabelPanel", PANEL, "PANEL")
--addons/sui/lua/sui/vgui/sui_query_box.lua:
local ScrW, ScrH = ScrW, ScrH
local DisableClipping = DisableClipping
local SetDrawColor = surface.SetDrawColor
local DrawRect = surface.DrawRect
local BlurPanel = sui.TDLib.BlurPanel
local lerp_color = sui.lerp_color

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local PANEL = {}

function PANEL:SetCallback(callback)
	self.callback = callback
end

function PANEL:Init()
	self:SetSize(0, 0)

	local bottom = self:Add("Panel")
	bottom:Dock(BOTTOM)
	bottom:DockMargin(4, 10, 4, 4)
	bottom:SetZPos(100)

	local save = bottom:Add(NAME .. ".Button")
	save:SetText("SAVE")
	save:Dock(RIGHT)
	save:SetEnabled(false)
	self.save = save

	function save.DoClick()
		self.callback()
		self:Remove()
	end

	local cancel = bottom:Add(NAME .. ".Button")
	cancel:Dock(RIGHT)
	cancel:DockMargin(0, 0, 4, 0)
	cancel:SetContained(false)
	cancel:SetColors(GetColor("query_box_cancel"), GetColor("query_box_cancel_text"))
	cancel:SetText("CANCEL")
	self.cancel = cancel

	function cancel.DoClick()
		self:Remove()
	end

	bottom:SetSize(save:GetWide() * 2 + 4, SUI.Scale(30))

	local body = self:Add("Panel")
	body:Dock(FILL)
	body:DockMargin(4, 4, 4, 4)
	body:DockPadding(3, 3, 3, 3)
	body:InvalidateLayout(true)
	body:InvalidateParent(true)

	local added = 1
	function body.OnChildAdded(s, child)
		added = added + 1
		child:Dock(TOP)
		child:SetZPos(added)
		child:InvalidateLayout(true)
		s:InvalidateLayout(true)
	end
	self.body = body

	function self:Add(name)
		return body:Add(name)
	end

	local old_Paint = self.Paint
	local trans = Color(0, 0, 0, 0)
	local new_col = Color(70, 70, 70, 100)
	function self:Paint(w, h)
		lerp_color(trans, new_col)

		local x, y = self:LocalToScreen(0, 0)
		DisableClipping(true)
			BlurPanel(self)
			SetDrawColor(trans)
			DrawRect(x * -1, y * -1, ScrW(), ScrH())
		DisableClipping(false)

		old_Paint(self, w, h)
	end
end

function PANEL:ChildrenHeight()
	local body = self.body

	self.header:InvalidateLayout(true)
	local height = self.header:GetTall()

	body:InvalidateLayout(true)
	self:InvalidateLayout(true)
	height = height + select(2, body:ChildrenSize())

	height = height + SUI.Scale(30) + 14 + 6

	return height
end

function PANEL:Paint(w, h)
	if GetColor("frame_blur") then
		BlurPanel(self)
	end

	self:RoundedBox("Background", 8, 0, 0, w, h, GetColor("query_box_bg"))
end

function PANEL:Done()
	self:InvalidateChildren(true)

	self.size_to_children = function()
		local h = self:ChildrenHeight()
		self:RealSetSize(self:GetWide(), h)
		self.real_h = h
	end

	self:Center()
	self:MakePopup()
	self:DoModal(true)

	timer.Simple(0.08, function()
		self:AddAnimations(self:GetWide(), self:ChildrenHeight(), true)
	end)
end

sui.register("QueryBox", PANEL, NAME .. ".Frame")
--addons/sui/lua/sui/vgui/sui_toggle_button.lua:
local Lerp = Lerp
local FrameTime = FrameTime

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

function Panel:Init()
	self:ScaleInit()

	local rounded_box = {}
	local switch_circle = {}
	function self:Paint(w, h)
		local is_checked = self:GetChecked()

		local _h = SUI.Scale(14)
		TDLib.RoundedBox(rounded_box, _h, 0, h / 2 - _h / 2, w, _h, is_checked and SUI.GetColor("toggle_button_active") or SUI.GetColor("toggle_button"))

		local size = h - 2
		do
			local pos = is_checked and (w - (size / 2)) or (h / 2 - 1)
			if self.pos then
				self.pos = Lerp(FrameTime() * 12, self.pos, pos)
			else
				self.pos = pos
			end
		end

		TDLib.DrawCircle(switch_circle, self.pos, h / 2, size / 2, is_checked and SUI.GetColor("toggle_button_switch_active") or SUI.GetColor("toggle_button_switch"))
	end

	self:SetSize(34, 20)
end

sui.register("ToggleButton", Panel, "DCheckBox")
--addons/sam/lua/sam/menu/tabs/players.lua:
if SAM_LOADED then return end

local sam = sam
local SQL = sam.SQL
local SUI = sam.SUI
local netstream = sam.netstream

sam.permissions.add("manage_players", nil, "superadmin")

local get_pages_count = function(count)
	count = count / 35
	local i2 = math.floor(count)
	return count ~= i2 and i2 + 1 or count
end

if SERVER then
	local check = function(ply)
		return ply:HasPermission("manage_players") and ply:sam_check_cooldown("MenuViewPlayers", 0.1)
	end

	local limit = 35

	local get_page_count = function(callback, res, page, column, order_by, sort_by, keyword)
		local query = [[
			SELECT
				COUNT(`steamid`) AS `count`
			FROM
				`sam_players`]]
		if keyword then
			if column == "steamid" and sam.is_steamid64(keyword) then
				keyword = util.SteamIDFrom64(keyword)
			end

			query = string.format("%s WHERE `%s` LIKE %s", query, column, SQL.Escape("%" .. keyword .. "%"))
		end
		SQL.Query(query, callback, true, {res, page, column, order_by, sort_by, keyword})
	end

	local valid_columns = {
		steamid = true,
		name = true,
		rank = true
	}

	local valid_sorts = {
		id = true,
		name = true,
		rank = true,
		play_time = true,
		last_join = true
	}

	local resolve_promise = function(data, arguments)
		local res = arguments[1]
		arguments[1] = data
		res(arguments)
	end

	local get_players = function(count_data, arguments)
		local res, page, column, order_by, sort_by, keyword = unpack(arguments)
		local count = count_data.count

		local current_page
		if page < 1 then
			page, current_page = 1, 1
		end

		local pages_count = get_pages_count(count)
		if page > pages_count then
			page, current_page = pages_count, pages_count
		end

		local query = [[
			SELECT
				`steamid`,
				`name`,
				`rank`,
				`expiry_date`,
				`first_join`,
				`last_join`,
				`play_time`
			FROM
				`sam_players`
		]]

		local args = {}

		if keyword then
			args[1] = column
			args[2] = "%" .. keyword .. "%"

			query = query .. [[
				WHERE
					`{1f}` LIKE {2}
			]]
		end

		args[3] = sort_by
		if order_by == "DESC" then
			query = query .. [[
				ORDER BY `{3f}` DESC
			]]
		else
			query = query .. [[
				ORDER BY `{3f}` ASC
			]]
		end

		args[4] = limit
		args[5] = math.abs(limit * (page - 1))

		query = query .. [[
			LIMIT {4} OFFSET {5}
		]]

		SQL.FQuery(query, args, resolve_promise, false, {res, count, current_page})
	end

	netstream.async.Hook("SAM.GetPlayers", function(res, ply, page, column, order_by, sort_by, keyword)
		if not isnumber(page) then return end
		if not valid_columns[column] then return end
		if order_by ~= "ASC" and order_by ~= "DESC" then return end
		if not valid_sorts[sort_by] then return end
		if keyword ~= nil and not sam.isstring(keyword) then return end

		get_page_count(get_players, res, page, column, order_by, sort_by, keyword)
	end, check)

	return
end

local GetColor = SUI.GetColor
local Line = sui.TDLib.LibClasses.Line

local COLUMN_FONT = SUI.CreateFont("Column", "Roboto", 18)
local LINE_FONT = SUI.CreateFont("Line", "Roboto", 16)
local NEXT_FONT = SUI.CreateFont("NextButton", "Roboto", 18)

local button_click = function(s)
	local v = s.v

	local dmenu = vgui.Create("SAM.Menu")
	dmenu:SetInternal(s)
	if v.name and v.name ~= "" then
		dmenu:AddOption("Copy Name", function()
			SetClipboardText(v.name)
		end)
	end

	dmenu:AddOption("Copy SteamID", function()
		SetClipboardText(v.steamid)
	end)

	dmenu:AddOption("Copy Rank", function()
		SetClipboardText(v.rank)
	end)

	dmenu:AddOption("Copy Play Time", function()
		SetClipboardText(sam.reverse_parse_length(tonumber(v.play_time) / 60))
	end)

	dmenu:AddSpacer()

	dmenu:AddOption("Change Rank", function()
		local querybox = vgui.Create("SAM.QueryBox")
		querybox:SetTitle(string.format("Change rank for '%s'", v.name or v.steamid))
		querybox:SetWide(360)

		local ranks = querybox:Add("SAM.ComboBox")
		ranks:SetTall(28)

		for rank_name in SortedPairsByMemberValue(sam.ranks.get_ranks(), "immunity", true) do
			if v.rank ~= rank_name then
				ranks:AddChoice(rank_name, nil, true)
			end
		end

		querybox:Done()
		querybox.save:SetEnabled(true)

		querybox:SetCallback(function()
			RunConsoleCommand("sam", "setrankid", v.steamid, ranks:GetValue())
		end)
	end)

	dmenu:Open()
end

sam.menu.add_tab("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/user.png", function(column_sheet)
	local refresh, pages
	local current_page, current_column, current_order, current_sort, keyword = nil, "steamid", "DESC", "id", nil

	local players_body = column_sheet:Add("Panel")
	players_body:Dock(FILL)
	players_body:DockMargin(0, 1, 0, 0)
	players_body:DockPadding(10, 10, 10, 10)

	local toggle_loading, is_loading = sam.menu.add_loading_panel(players_body)

	local title = players_body:Add("SAM.Label")
	title:Dock(TOP)
	title:SetFont(SAM_TAB_TITLE_FONT)
	title:SetText("Players")
	title:SetTextColor(GetColor("menu_tabs_title"))
	title:SizeToContents()

	local total = players_body:Add("SAM.Label")
	total:Dock(TOP)
	total:DockMargin(0, 6, 0, 0)
	total:SetFont(SAM_TAB_DESC_FONT)
	total:SetText("60 total players")
	total:SetTextColor(GetColor("menu_tabs_title"))
	total:SetPos(10, SUI.Scale(40))
	total:SizeToContents()

	local search_entry
	do
		local container = players_body:Add("SAM.Panel")
		container:Dock(TOP)
		container:DockMargin(0, 6, 10, 0)
		container:SetTall(30)

		local sort_by = container:Add("SAM.ComboBox")
		sort_by:Dock(RIGHT)
		sort_by:DockMargin(4, 0, 0, 0)
		sort_by:SetWide(106)
		sort_by:SetValue("Sort By (ID)")
		sort_by:AddChoice("ID")
		sort_by:AddChoice("Name")
		sort_by:AddChoice("Rank")
		sort_by:AddChoice("Play Time")

		function sort_by:OnSelect(_, value)
			value = value:lower():gsub(" ", "_")
			if current_sort ~= value then
				current_sort = value
				refresh()
			end
		end

		local sort_order = container:Add("SAM.ComboBox")
		sort_order:Dock(RIGHT)
		sort_order:SetWide(96)
		sort_order:SetValue("Desc")
		sort_order:AddChoice("Desc")
		sort_order:AddChoice("Asc")

		function sort_order:OnSelect(_, value)
			value = value:upper()
			if current_order ~= value then
				current_order = value
				refresh()
			end
		end

		local column = container:Add("SAM.ComboBox")
		column:Dock(RIGHT)
		column:DockMargin(0, 0, 4, 0)
		column:SetWide(140)

		column:SetValue("Search (SteamID)")
		column:AddChoice("SteamID")
		column:AddChoice("Name")
		column:AddChoice("Rank")

		function column:OnSelect(_, value)
			value = value:lower()
			if current_column ~= value then
				current_column = value
				refresh()
			end
		end

		search_entry = container:Add("SAM.TextEntry")
		search_entry:Dock(LEFT)
		search_entry:SetNoBar(true)
		search_entry:SetPlaceholder("Search...")
		search_entry:SetRadius(4)
		search_entry:SetWide(220)

		function search_entry:OnEnter(no_refresh)
			local value = self:GetValue()
			if keyword ~= value then
				keyword = value ~= "" and value or nil
				if not no_refresh then
					refresh()
				end
			end
		end
	end

	Line(players_body, nil, -5, SUI.Scale(15), -5, 0)

	do
		local columns = players_body:Add("Panel")
		columns:Dock(TOP)
		columns:DockMargin(0, 10, 0, 0)

		local info = columns:Add("SAM.Label")
		info:Dock(LEFT)
		info:DockMargin(4, 0, 0, 0)
		info:SetFont(COLUMN_FONT)
		info:SetText("Player")
		info:SetTextColor(GetColor("player_list_titles"))
		info:SetWide(SUI.Scale(280) + SUI.Scale(34))
		info:SizeToContentsY(3)

		local play_time = columns:Add("SAM.Label")
		play_time:Dock(LEFT)
		play_time:DockMargin(-4, 0, 0, 0)
		play_time:SetFont(COLUMN_FONT)
		play_time:SetText("Play Time")
		play_time:SetTextColor(GetColor("player_list_titles"))
		play_time:SetWide(SUI.Scale(180))
		play_time:SizeToContentsY(3)

		local rank_expiry = columns:Add("SAM.Label")
		rank_expiry:Dock(LEFT)
		rank_expiry:DockMargin(-4, 0, 0, 0)
		rank_expiry:SetFont(COLUMN_FONT)
		rank_expiry:SetText("Rank Expiry")
		rank_expiry:SetTextColor(GetColor("player_list_titles"))
		rank_expiry:SetWide(SUI.Scale(280))
		rank_expiry:SizeToContentsY(3)

		columns:SizeToChildren(false, true)
	end

	local body = players_body:Add("SAM.ScrollPanel")
	body:Dock(FILL)
	body:DockMargin(0, 10, 0, 0)
	body:SetVBarPadding(6)

	local set_data = function(data)
		body:GetCanvas():Clear()
		body.VBar.Scroll = 0

		local players, players_count, current_page_2 = unpack(data)
		total:SetText(players_count .. " total players")

		pages = get_pages_count(players_count)
		current_page.i = pages == 0 and 0 or current_page_2 or current_page.i
		current_page:SetText(current_page.i .. "/" .. pages)

		body:Line()

		for k, v in ipairs(players) do
			local line = body:Add("SAM.PlayerLine")
			line:DockMargin(0, 0, 0, 10)

			local name = v.name ~= "" and v.name or nil
			line:SetInfo({
				steamid = v.steamid,
				name = name,
				rank = v.rank
			})

			local play_time = line:Add("SAM.Label")
			play_time:Dock(LEFT)
			play_time:DockMargin(4, 0, 0, 0)
			play_time:SetFont(LINE_FONT)
			play_time:SetText(sam.reverse_parse_length(tonumber(v.play_time) / 60))
			play_time:SetTextColor(GetColor("player_list_data"))
			play_time:SetContentAlignment(4)
			play_time:SetWide(SUI.Scale(180))

			local expiry_date = tonumber(v.expiry_date)
			local rank_expiry = line:Add("SAM.Label")
			rank_expiry:Dock(LEFT)
			rank_expiry:DockMargin(-3, 0, 0, 0)
			rank_expiry:SetFont(LINE_FONT)
			rank_expiry:SetText(expiry_date == 0 and "Never" or sam.reverse_parse_length((expiry_date - os.time()) / 60))
			rank_expiry:SetTextColor(GetColor("player_list_data"))
			rank_expiry:SetContentAlignment(4)
			rank_expiry:SizeToContents()

			local but = line:Actions()
			but.v = v
			but:On("DoClick", button_click)

			body:Line()
		end
	end

	refresh = function()
		if not is_loading() and LocalPlayer():HasPermission("manage_players") then
			search_entry:OnEnter(true)
			local refresh_query = netstream.async.Start("SAM.GetPlayers", toggle_loading, current_page.i, current_column, current_order, current_sort, keyword)
			refresh_query:done(set_data)
		end
	end

	local bottom_panel = players_body:Add("SAM.Panel")
	bottom_panel:Dock(BOTTOM)
	bottom_panel:DockMargin(0, 6, 0, 0)
	bottom_panel:SetTall(30)
	bottom_panel:Background(GetColor("page_switch_bg"))

	local previous_page = bottom_panel:Add("SAM.Button")
	previous_page:Dock(LEFT)
	previous_page:SetWide(30)
	previous_page:SetText("<")
	previous_page:SetFont(NEXT_FONT)

	previous_page:On("DoClick", function()
		if current_page.i <= 1 then return end

		current_page.i = current_page.i - 1
		refresh()
	end)

	current_page = bottom_panel:Add("SAM.Label")
	current_page:Dock(FILL)
	current_page:SetContentAlignment(5)
	current_page:SetFont(SAM_TAB_DESC_FONT)
	current_page:SetText("loading...")
	current_page.i = 1

	local next_page = bottom_panel:Add("SAM.Button")
	next_page:Dock(RIGHT)
	next_page:SetWide(30)
	next_page:SetText(">")
	next_page:SetFont(NEXT_FONT)

	next_page:On("DoClick", function()
		if current_page.i == pages then return end

		current_page.i = current_page.i + 1
		refresh()
	end)

	function bottom_panel:Think()
		next_page:SetEnabled(current_page.i ~= pages)
		previous_page:SetEnabled(current_page.i > 1)
	end

	do
		local refresh_2 = function()
			timer.Simple(1, refresh)
		end

		for k, v in ipairs({"SAM.AuthedPlayer", "SAM.ChangedPlayerRank", "SAM.ChangedSteamIDRank"}) do
			hook.Add(v, "SAM.MenuPlayers", refresh_2)
		end
	end

	refresh()

	return players_body
end, function()
	return LocalPlayer():HasPermission("manage_players")
end, 2)
--addons/sam/lua/sam/modules/chat.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("Chat")

command.new("pm")
	:SetPermission("pm", "user")

	:AddArg("player", {allow_higher_target = true, single_target = true, cant_target_self = true})
	:AddArg("text", {hint = "message", check = function(str)
		return str:match("%S") ~= nil
	end})

	:GetRestArgs()

	:Help("pm_help")

	:OnExecute(function(ply, targets, message)
		if ply:sam_get_pdata("unmute_time") then
			return ply:sam_send_message("you_muted")
		end

		local target = targets[1]

		ply:sam_send_message("pm_to", {
			T = targets, V = message
		})

		if ply ~= target then
			target:sam_send_message("pm_from", {
				A = ply, V = message
			})
		end
	end)
:End()

do
	sam.permissions.add("see_admin_chat", nil, "admin")

	local reports_enabled = sam.config.get_updated("Reports", true)
	command.new("asay")
		:SetPermission("asay", "user")

		:AddArg("text", {hint = "message"})
		:GetRestArgs()

		:Help("asay_help")

		:OnExecute(function(ply, message)
			if reports_enabled.value and not ply:HasPermission("see_admin_chat") then
				local success, time = sam.player.report(ply, message)
				if success == false then
					ply:sam_send_message("You need to wait {S Red} seconds.", {
						S = time
					})
				else
					ply:sam_send_message("to_admins", {
						A = ply, V = message
					})
				end
				return
			end

			local targets = {ply}

			local players = player.GetHumans()
			for i = 1, #players do
				local v = players[i]
				if v:HasPermission("see_admin_chat") and v ~= ply then
					table.insert(targets, v)
				end
			end

			sam.player.send_message(targets, "to_admins", {
				A = ply, V = message
			})
		end)
	:End()
end

do
	command.new("mute")
		:SetPermission("mute", "admin")

		:AddArg("player")
		:AddArg("length", {optional = true, default = 0, min = 0})
		:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

		:GetRestArgs()

		:Help("mute_help")

		:OnExecute(function(ply, targets, length, reason)
			local current_time = SysTime()

			for i = 1, #targets do
				local target = targets[i]
				target:sam_set_pdata("unmute_time", length ~= 0 and (current_time + length * 60) or 0)
			end

			sam.player.send_message(nil, "mute", {
				A = ply, T = targets, V = sam.format_length(length), V_2 = reason
			})
		end)
	:End()

	command.new("unmute")
		:SetPermission("unmute", "admin")
		:AddArg("player", {optional = true})
		:Help("unmute_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				targets[i]:sam_set_pdata("unmute_time", nil)
			end

			sam.player.send_message(nil, "unmute", {
				A = ply, T = targets
			})
		end)
	:End()

	if SERVER then
		sam.hook_first("PlayerSay", "SAM.Chat.Mute", function(ply, text)
			local unmute_time = ply:sam_get_pdata("unmute_time")
			if not unmute_time then return end

			if text:sub(1, 1) == "!" and text:sub(2, 2):match("%S") ~= nil then
				local args = sam.parse_args(text:sub(2))

				local cmd_name = args[1]
				if not cmd_name then return end

				local cmd = command.get_command(cmd_name)
				if cmd then
					return
				end
			end

			if unmute_time == 0 or unmute_time > SysTime() then
				return ""
			else
				ply:sam_set_pdata("unmute_time", nil)
			end
		end)
	end
end

do
	command.new("gag")
		:SetPermission("gag", "admin")

		:AddArg("player")
		:AddArg("length", {optional = true, default = 0, min = 0})
		:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

		:GetRestArgs()

		:Help("gag_help")

		:OnExecute(function(ply, targets, length, reason)
			for i = 1, #targets do
				local target = targets[i]
				target.sam_gagged = true
				if length ~= 0 then
					timer.Create("SAM.UnGag" .. target:SteamID64(), length * 60, 1, function()
						RunConsoleCommand("sam", "ungag", "#" .. target:EntIndex())
					end)
				end
			end

			sam.player.send_message(nil, "gag", {
				A = ply, T = targets, V = sam.format_length(length), V_2 = reason
			})
		end)
	:End()

	command.new("ungag")
		:SetPermission("ungag", "admin")

		:AddArg("player", {optional = true})
		:Help("ungag_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				local target = targets[i]
				target.sam_gagged = nil
				timer.Remove("SAM.UnGag" .. target:SteamID64())
			end

			sam.player.send_message(nil, "ungag", {
				A = ply, T = targets
			})
		end)
	:End()

	if SERVER then
		hook.Add("PlayerCanHearPlayersVoice", "SAM.Chat.Gag", function(_, ply)
			if ply.sam_gagged then
				return false
			end
		end)

		hook.Add("PlayerInitialSpawn", "SAM.Gag", function(ply)
			local gag_time = ply:sam_get_pdata("gagged")
			if gag_time then
				ply:sam_set_pdata("gagged", nil)
				RunConsoleCommand("sam", "gag", "#" .. ply:EntIndex(), gag_time / 60, "LTAP")
			end
		end)

		hook.Add("PlayerDisconnected", "SAM.Gag", function(ply)
			if ply.sam_gagged then
				ply:sam_set_pdata("gagged", timer.TimeLeft("SAM.UnGag" .. ply:SteamID64()) or 0)
			end
		end)
	end
end
--addons/sam/lua/sam/modules/murder.lua:
if SAM_LOADED then return end

local add = not GAMEMODE and hook.Add or function(_, _, fn)
	fn()
end

-- Thanks to https://github.com/boxama/addons/blob/master/addons/ULX_Murder/lua/ulx/modules/sh/murder.lua
add("PostGamemodeLoaded", "SAM.Murder", function()
	if GAMEMODE.Author ~= "MechanicalMind" then return end
	if not isstring(GAMEMODE.Version) or GAMEMODE.Version < "28" then return end

	local sam, command = sam, sam.command

	command.set_category("Murder")

	local autoslain_players = {}

	command.new("slaynr")
		:SetPermission("slaynr", "admin")

		:AddArg("player")
		:AddArg("number", {hint = "rounds", optional = true, default = 1, min = 1, max = 100, round = true})

		:Help("Slays the target(s) at the beggining of the next round.")

		:OnExecute(function(ply, targets, rounds)
			for i = 1, #targets do
				local v = targets[i]
				v.MurdererChance = 0

				if not v:IsBot() then
					autoslain_players[v:AccountID()] = rounds
				end
			end

			sam.player.send_message(nil, "{A} set {T} to be autoslain for {V} round(s)", {
				A = ply, T = targets, V = rounds
			})
		end)
	:End()

	command.new("unslaynr")
		:SetPermission("unslaynr", "admin")

		:AddArg("player")

		:Help("Remove target(s) autoslays.")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				local v = targets[i]
				v.MurdererChance = 1

				if not v:IsBot() then
					autoslain_players[v:AccountID()] = nil
				end
			end

			sam.player.send_message(nil, "Removed all autoslays for {T} ", {
				A = ply, T = targets
			})
		end)
	:End()

	hook.Add("OnStartRound", "SAM.Murder", function()
		timer.Simple(3, function()
			local players = team.GetPlayers(2)
			local targets = {admin = sam.console}
			for i = 1, #players do
				local v = players[i]
				if not v:IsBot() then continue end

				local slays = autoslain_players[v:AccountID()]
				if not slays then continue end

				v:Kill()

				slays = slays - 1

				targets[1] = v
				sam.player.send_message(nil, "{A} autoslayed {T}, autoslays left: {V}.", {
					A = sam.console, T = targets, V = slays
				})

				autoslain_players[v:AccountID()] = slays > 0 and slays or nil
			end
		end)
	end)

	hook.Add("PlayerInitialSpawn", "SAM.Murder", function(ply)
		if autoslain_players[ply:AccountID()] then
			ply.MurdererChance = 0
		end
	end)

	command.new("respawn")
		:SetPermission("respawn", "admin")

		:AddArg("player", {single_target = true})

		:Help("Respawn a target.")

		:OnExecute(function(ply, targets)
			local target = targets[1]

			if target:Team() ~= 2 then
				return ply:sam_add_text("You cannot respawn a spectator!")
			end

			target:Spectate(OBS_MODE_NONE)
			target:Spawn()

			sam.player.send_message(nil, "respawn", {
				A = ply, T = targets
			})
		end)
	:End()

	local get_admins = function()
		local admins = {}

		local players = player.GetHumans()
		for i = 1, #players do
			local v = players[i]
			if v:IsAdmin() then
				table.insert(admins, v)
			end
		end

		return admins
	end

	command.new("givemagnum")
		:SetPermission("givemagnum", "superadmin")

		:AddArg("player", {single_target = true, optional = true})

		:Help("Give the target a magnum.")

		:OnExecute(function(ply, targets)
			local target = targets[1]

			if target:Team() ~= 2 then
				return ply:sam_add_text("You cannot give spectator a magnum!")
			end

			target:Give("weapon_mu_magnum")

			sam.player.send_message(get_admins(), "{A} gave {T} a {V}", {
				A = ply, T = targets, V = "magnum"
			})
		end)
	:End()

	command.new("giveknife")
		:SetPermission("giveknife", "superadmin")

		:AddArg("player", {single_target = true, optional = true})

		:Help("Give the target a knife.")

		:OnExecute(function(ply, targets)
			local target = targets[1]

			if target:Team() ~= 2 then
				return ply:sam_add_text("You cannot give spectator a knife!")
			end

			target:Give("weapon_mu_knife")

			sam.player.send_message(get_admins(), "{A} gave {T} a {V}", {
				A = ply, T = targets, V = "knife"
			})
		end)
	:End()

	command.new("forcemurderer")
		:SetPermission("forcemurderer", "admin")

		:AddArg("player", {single_target = true, optional = true})

		:Help("Force the target to me a murderer next round.")

		:OnExecute(function(ply, targets)
			GAMEMODE.ForceNextMurderer = targets[1]

			sam.player.send_message(get_admins(), "{A} set {T} to be the Murderer next round!", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("getmurderers")
		:SetPermission("getmurderers", "admin")

		:Help("Print all murderers in chat.")

		:OnExecute(function(ply)
			local murderers = {admin = ply}

			local players = team.GetPlayers(2)
			for i = 1, #players do
				local v = players[i]
				if v:GetMurderer() then
					table.insert(murderers, v)
				end
			end

			sam.player.send_message(ply, "Murderers are: {T}", {
				T = murderers
			})
		end)
	:End()
end)
--addons/sam/lua/sam/modules/support_cami.lua:
if SAM_LOADED then return end

local ranks_loaded
if SERVER then
	ranks_loaded = sam.ranks.ranks_loaded()
else
	ranks_loaded = sam.ranks.get_ranks() ~= nil
end

do
	local load_ranks = function()
		for name, rank in pairs(sam.ranks.get_ranks()) do
			if not sam.ranks.is_default_rank(name) then
				CAMI.RegisterUsergroup({Name = name, Inherits = rank.inherit}, "SAM")
			end
		end
	end

	if ranks_loaded then
		load_ranks()
	else
		hook.Add("SAM.LoadedRanks", "SAM.CAMI.LoadRanksToCAMI", load_ranks)
	end
end

hook.Add("SAM.AddedRank", "SAM.CAMI.AddedRank", function(name, rank)
	if not sam.ranks.is_default_rank(name) then
		CAMI.RegisterUsergroup({Name = name, Inherits = rank.inherit}, "SAM")
	end
end)

hook.Add("SAM.RemovedRank", "SAM.CAMI.RemovedRank", function(name)
	CAMI.UnregisterUsergroup(name, "SAM")
end)

hook.Add("SAM.RankNameChanged", "SAM.CAMI.RankNameChanged", function(old, new)
	CAMI.UnregisterUsergroup(old, "SAM")
	CAMI.RegisterUsergroup({Name = new, Inherits = sam.ranks.get_rank(new).inherit}, "SAM")
end)

hook.Add("SAM.ChangedPlayerRank", "SAM.CAMI.ChangedPlayerRank", function(ply, new_rank, old_rank)
	CAMI.SignalUserGroupChanged(ply, old_rank, new_rank, "SAM")
end)

hook.Add("SAM.ChangedSteamIDRank", "SAM.CAMI.ChangedSteamIDRank", function(steamid, new_rank, old_rank)
	CAMI.SignalSteamIDUserGroupChanged(steamid, old_rank, new_rank, "SAM")
end)

----------------------------------------------------------------------------------------------------------------------------------------------------------

if SERVER then
	do
		local on_user_group_registered = function(rank, source)
			if source ~= "SAM" then
				sam.ranks.add_rank(rank.Name, sam.ranks.is_rank(rank.Inherits) and rank.Inherits or "user")
			end
		end

		local load_ranks = function()
			for _, rank in pairs(CAMI.GetUsergroups()) do
				on_user_group_registered(rank, "CAMI")
			end
			hook.Add("CAMI.OnUsergroupRegistered", "SAM.CAMI.OnUsergroupRegistered", on_user_group_registered)
		end

		if ranks_loaded then
			load_ranks()
		else
			hook.Add("SAM.LoadedRanks", "SAM.CAMI.LoadRanksFromCAMI", load_ranks)
		end
	end

	hook.Add("CAMI.OnUsergroupUnregistered", "SAM.CAMI.OnUsergroupUnregistered", function(rank, source)
		if source ~= "SAM" then
			sam.ranks.remove_rank(rank.Name)
		end
	end)

	hook.Add("CAMI.PlayerUsergroupChanged", "SAM.CAMI.PlayerUsergroupChanged", function(ply, _, new_rank, source)
		if ply and IsValid(ply) and source ~= "SAM" then
			sam.player.set_rank(ply, new_rank)
		end
	end)

	hook.Add("CAMI.SteamIDUsergroupChanged", "SAM.CAMI.SteamIDUsergroupChanged", function(steamid, _, new_rank, source)
		if sam.is_steamid(steamid) and source ~= "SAM" then
			sam.player.set_rank_id(steamid, new_rank)
		end
	end)
end

do
	local on_privilege_registered = function(privilege)
		sam.permissions.add(privilege.Name, "CAMI", privilege.MinAccess)
	end

	local load_privileges = function()
		for _, privilege in pairs(CAMI.GetPrivileges()) do
			on_privilege_registered(privilege)
		end
		hook.Add("CAMI.OnPrivilegeRegistered", "SAM.CAMI.OnPrivilegeRegistered", on_privilege_registered)
	end

	if ranks_loaded then
		load_privileges()
	else
		hook.Add("SAM.LoadedRanks", "SAM.CAMI.LoadPrivileges", load_privileges)
	end
end

hook.Add("CAMI.OnPrivilegeUnregistered", "SAM.CAMI.OnPrivilegeUnregistered", function(privilege)
	sam.permissions.remove(privilege.Name)
end)

hook.Add("CAMI.PlayerHasAccess", "SAM.CAMI.PlayerHasAccess", function(ply, privilege, callback, target)
	if sam.type(ply) ~= "Player" then return end

	local has_permission = ply:HasPermission(privilege)
	if sam.type(target) == "Player" then
		callback(has_permission and ply:CanTarget(target))
	else
		callback(has_permission)
	end

	return true
end)
--addons/sam/lua/sam/modules/teleport.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("Teleport")

local find_empty_pos -- https://github.com/FPtje/DarkRP/blob/b147d6fa32799136665a9fd52d35c2fe87cf7f78/gamemode/modules/base/sv_util.lua#L149
do
	local is_empty = function(vector, ignore)
		local point = util.PointContents(vector)
		local a = point ~= CONTENTS_SOLID
			and point ~= CONTENTS_MOVEABLE
			and point ~= CONTENTS_LADDER
			and point ~= CONTENTS_PLAYERCLIP
			and point ~= CONTENTS_MONSTERCLIP
		if not a then return false end

		local ents_found = ents.FindInSphere(vector, 35)
		for i = 1, #ents_found do
			local v = ents_found[i]
			if (v:IsNPC() or v:IsPlayer() or v:GetClass() == "prop_physics" or v.NotEmptyPos) and v ~= ignore then
				return false
			end
		end

		return true
	end

	local distance, step, area = 600, 30, Vector(16, 16, 64)
	local north_vec, east_vec, up_vec = Vector(0, 0, 0), Vector(0, 0, 0), Vector(0, 0, 0)

	find_empty_pos = function(pos, ignore)
		if is_empty(pos, ignore) and is_empty(pos + area, ignore) then
			return pos
		end

		for j = step, distance, step do
			for i = -1, 1, 2 do
				local k = j * i

				-- North/South
				north_vec.x = k
				if is_empty(pos + north_vec, ignore) and is_empty(pos + north_vec + area, ignore) then
					return pos + north_vec
				end

				-- East/West
				east_vec.y = k
				if is_empty(pos + east_vec, ignore) and is_empty(pos + east_vec + area, ignore) then
					return pos + east_vec
				end

				-- Up/Down
				up_vec.z = k
				if is_empty(pos + up_vec, ignore) and is_empty(pos + up_vec + area, ignore) then
					return pos + up_vec
				end
			end
		end

		return pos
	end
end

command.new("bring")
	:DisallowConsole()
	:SetPermission("bring", "admin")

	:AddArg("player", {cant_target_self = true})

	:Help("bring_help")

	:OnExecute(function(ply, targets)
		if not ply:Alive() then
			return ply:sam_send_message("dead")
		end

		if ply:InVehicle() then
			return ply:sam_send_message("leave_car")
		end

		if ply:sam_get_exclusive(ply) then
			return ply:sam_send_message(ply:sam_get_exclusive(ply))
		end

		local teleported = {admin = ply}
		local all = targets.input == "*"

		for i = 1, #targets do
			local target = targets[i]

			if target:sam_get_exclusive(ply) then
				if not all then
					ply:sam_send_message(target:sam_get_exclusive(ply))
				end
				continue
			end

			if not target:Alive() then
				target:Spawn()
			end

			target.sam_tele_pos, target.sam_tele_ang = target:GetPos(), target:EyeAngles()

			target:ExitVehicle()
			target:SetVelocity(Vector(0, 0, 0))
			target:SetPos(find_empty_pos(ply:GetPos(), target))
			target:SetEyeAngles((ply:EyePos() - target:EyePos()):Angle())

			table.insert(teleported, target)
		end

		if #teleported > 0 then
			sam.player.send_message(ply, "bring", {
				A = ply, T = teleported
			})
		end
	end)
:End()

command.new("goto")
	:DisallowConsole()
	:SetPermission("goto", "admin")

	:AddArg("player", {single_target = true, allow_higher_target = true, cant_target_self = true})

	:Help("goto_help")

	:OnExecute(function(ply, targets)
		if ply:sam_get_exclusive(ply) then
			return ply:sam_send_message(ply:sam_get_exclusive(ply))
		end

		if not ply:Alive() then
			ply:Spawn()
		end

		local target = targets[1]
		ply.sam_tele_pos, ply.sam_tele_ang = ply:GetPos(), ply:EyeAngles()

		ply:ExitVehicle()
		ply:SetVelocity(Vector(0, 0, 0))
		ply:SetPos(find_empty_pos(target:GetPos(), ply))
		ply:SetEyeAngles((target:EyePos() - ply:EyePos()):Angle())

		sam.player.send_message(ply, "goto", {
			A = ply, T = targets
		})
	end)
:End()

command.new("return")
	:SetPermission("return", "admin")

	:AddArg("player", {single_target = true, optional = true})

	:Help("return_help")

	:OnExecute(function(ply, targets)
		local target = targets[1]

		local last_pos, last_ang = target.sam_tele_pos, target.sam_tele_ang
		if not last_pos then
			return sam.player.send_message(ply, "no_location", {
				T = targets
			})
		end

		if target:sam_get_exclusive(ply) then
			return ply:sam_send_message(target:sam_get_exclusive(ply))
		end

		if not target:Alive() then
			return ply:sam_send_message(target:Name() .. " is dead!")
		end

		target:ExitVehicle()
		target:SetVelocity(Vector(0, 0, 0))
		target:SetPos(last_pos)
		target:SetEyeAngles(last_ang)

		target.sam_tele_pos, target.sam_tele_ang = nil, nil

		sam.player.send_message(ply, "returned", {
			A = ply, T = targets
		})
	end)
:End()
--addons/sam/lua/sam/modules/util.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("Utility")

command.new("map")
	:SetPermission("map", "admin")

	:AddArg("map")
	:AddArg("text", {hint = "gamemode", optional = true, check = sam.is_valid_gamemode})

	:Help("map_help")

	:OnExecute(function(ply, map, gamemode)
		if not gamemode then
			sam.player.send_message(nil, "map_change", {
				A = ply, V = map
			})
		else
			sam.player.send_message(nil, "map_change2", {
				A = ply, V = map, V_2 = gamemode
			})
			RunConsoleCommand("gamemode", gamemode)
		end

		if #player.GetHumans() == 0 then
			RunConsoleCommand("changelevel", map)
		else
			timer.Create("SAM.Command.Map", 10, 1, function()
				RunConsoleCommand("changelevel", map)
			end)
		end
	end)
:End()

command.new("maprestart")
	:SetPermission("maprestart", "admin")

	:Help("map_restart_help")

	:OnExecute(function(ply)
		if #player.GetHumans() == 0 then
			RunConsoleCommand("changelevel", game.GetMap())
		else
			timer.Create("SAM.Command.MapRestart", 10, 1, function()
				RunConsoleCommand("changelevel", game.GetMap())
			end)

			sam.player.send_message(nil, "map_restart", {
				A = ply
			})
		end
	end)
:End()

command.new("mapreset")
	:SetPermission("mapreset", "admin")

	:Help("mapreset_help")

	:OnExecute(function(ply)
		game.CleanUpMap()

		sam.player.send_message(nil, "mapreset", {
			A = ply
		})
	end)
:End()

command.new("kick")
	:SetPermission("kick", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

	:GetRestArgs()

	:Help("kick_help")

	:OnExecute(function(ply, targets, reason)
		local target = targets[1]
		target:Kick(reason)

		sam.player.send_message(ply, "kick", {
			A = ply, T = target:Name(), V = reason
		})
	end)
:End()

command.new("ban")
	:SetPermission("ban", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("length", {optional = true, default = 0})
	:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

	:GetRestArgs()

	:Help("ban_help")

	:OnExecute(function(ply, targets, length, reason)
		local target = targets[1]
		if ply:GetBanLimit() ~= 0 then
			if length == 0 then
				length = ply:GetBanLimit()
			else
				length = math.Clamp(length, 1, ply:GetBanLimit())
			end
		end
		target:sam_ban(length, reason, ply:SteamID())

		sam.player.send_message(ply, "ban", {
			A = ply, T = target:Name(), V = sam.format_length(length), V_2 = reason
		})
	end)
:End()

command.new("banid")
	:SetPermission("banid", "admin")

	:AddArg("steamid")
	:AddArg("length", {optional = true, default = 0})
	:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

	:GetRestArgs()

	:Help("banid_help")

	:OnExecute(function(ply, promise, length, reason)
		local a_steamid, a_name, a_ban_limit = ply:SteamID(), ply:Name(), ply:GetBanLimit()

		promise:done(function(data)
			local steamid, target = data[1], data[2]

			if a_ban_limit ~= 0 then
				if length == 0 then
					length = a_ban_limit
				else
					length = math.Clamp(length, 1, a_ban_limit)
				end
			end

			if target then
				target:sam_ban(length, reason, a_steamid)

				sam.player.send_message(ply, "ban", {
					A = a_name, T = target:Name(), V = sam.format_length(length), V_2 = reason
				})
			else
				sam.player.ban_id(steamid, length, reason, a_steamid)

				sam.player.send_message(ply, "banid", {
					A = a_name, T = steamid, V = sam.format_length(length), V_2 = reason
				})
			end
		end)
	end)
:End()

command.new("unban")
	:SetPermission("unban", "admin")

	:AddArg("steamid", {allow_higher_target = true})

	:Help("unban_help")

	:OnExecute(function(ply, steamid, reason)
		sam.player.unban(steamid, ply:SteamID())

		sam.player.send_message(ply, "unban", {
			A = ply, T = steamid
		})
	end)
:End()

do
	command.new("noclip")
		:SetPermission("noclip", "admin")

		:AddArg("player", {optional = true})

		:Help("noclip_help")

		:OnExecute(function(ply, targets)
			local id
			for i = 1, #targets do
				local v = targets[i]
				v:SetMoveType(v:GetMoveType() == MOVETYPE_WALK and MOVETYPE_NOCLIP or MOVETYPE_WALK)
				if v == ply then
					id = i
				end
			end

			if id then
				table.remove(targets, id)
				if #targets == 0 then return end
			end

			sam.player.send_message(ply, "noclip", {
				A = ply, T = targets
			})
		end)
	:End()

	sam.permissions.add("can_noclip", nil, "admin")

	hook.Add("PlayerNoClip", "SAM.CanNoClip", function(ply)
		if ply:HasPermission("can_noclip") then
			return true
		end
	end)
end

do
	local config = sam.config

	sam.permissions.add("can_physgun_players", nil, "admin")

	if CLIENT then
		local add_setting = function(body, title, key)
			local setting = body:Add("SAM.LabelPanel")
			setting:Dock(TOP)
			setting:SetLabel(title)

			local enable = setting:Add("SAM.ToggleButton")
			enable:SetConfig(key, true)

			return setting
		end

		config.add_menu_setting("Physgun", function(body)
			local setting_body

			do
				local p = add_setting(body, "Physgun (Enable/Disable all physgun features except picking up players)", "Physgun.Enabled")
				p:DockMargin(8, 6, 8, 0)
			end

			setting_body = body:Add("Panel")
			setting_body:Dock(TOP)
			setting_body:DockMargin(8, 6, 8, 0)
			setting_body:DockPadding(8, 0, 8, 0)

			add_setting(setting_body, "No fall damage on drop", "Physgun.NoFallDamageOnDrop")
			add_setting(setting_body, "Right click to freeze players", "Physgun.RightClickToFreeze")
			add_setting(setting_body, "Reset Velocity to fix some issues when players fall", "Physgun.ResetVelocity")

			function setting_body:PerformLayout()
				setting_body:SizeToChildren(false, true)
			end
		end)
	end

	local freeze_player = function(ply)
		if SERVER then
			ply:Lock()
		end
		ply:SetMoveType(MOVETYPE_NONE)
		ply:SetCollisionGroup(COLLISION_GROUP_WORLD)
	end

	sam.hook_first("PhysgunPickup", "SAM.CanPhysgunPlayer", function(ply, target)
		if sam.type(target) == "Player" and ply:HasPermission("can_physgun_players") and ply:CanTarget(target) then
			freeze_player(target)
			return true
		end
	end)

	local load_phygun_settings = function()
		hook.Remove("PhysgunDrop", "SAM.PhysgunDrop")
		hook.Remove("OnPlayerHitGround", "SAM.PhysgunDropOnPlayerHitGround")

		if config.get("Physgun.Enabled", true) == false then
			return
		end

		local right_click_to_freeze = config.get("Physgun.RightClickToFreeze", true)
		local reset_velocity = config.get("Physgun.ResetVelocity", true)
		hook.Add("PhysgunDrop", "SAM.PhysgunDrop", function(ply, target)
			if sam.type(target) ~= "Player" then return end

			if right_click_to_freeze and ply:KeyPressed(IN_ATTACK2) then
				freeze_player(target)

				if SERVER then
					target:sam_set_nwvar("frozen", true)
					target:sam_set_exclusive("frozen")
				end
			else
				if reset_velocity then
					target:SetLocalVelocity(Vector(0, 0, 0))
				end

				if SERVER then
					target:UnLock()
					target:sam_set_nwvar("frozen", false)
					target:sam_set_exclusive(nil)

					if target.sam_has_god_mode then
						target:GodEnable()
					end

					target.sam_physgun_drop_was_frozen = not target:IsOnGround()
				end

				target:SetMoveType(MOVETYPE_WALK)
				target:SetCollisionGroup(COLLISION_GROUP_PLAYER)
			end
		end)

		if config.get("Physgun.NoFallDamageOnDrop", true) then
			hook.Add("OnPlayerHitGround", "SAM.PhysgunDropOnPlayerHitGround", function(ply)
				if ply.sam_physgun_drop_was_frozen then
					ply.sam_physgun_drop_was_frozen = false
					return true
				end
			end)
		end
	end

	config.hook({"Physgun.Enabled", "Physgun.RightClickToFreeze", "Physgun.ResetVelocity", "Physgun.NoFallDamageOnDrop"}, load_phygun_settings)
end

do
	command.new("cleardecals")
		:SetPermission("cleardecals", "admin")
		:Help("cleardecals_help")

		:OnExecute(function(ply)
			sam.netstream.Start(nil, "cleardecals")

			sam.player.send_message(nil, "cleardecals", {
				A = ply
			})
		end)
	:End()

	if CLIENT then
		sam.netstream.Hook("cleardecals", function()
			game.RemoveRagdolls()
			RunConsoleCommand("r_cleardecals")
		end)
	end
end

do
	command.new("stopsound")
		:SetPermission("stopsound", "admin")
		:Help("stopsound_help")

		:OnExecute(function(ply)
			sam.netstream.Start(nil, "stopsound")

			sam.player.send_message(nil, "stopsound", {
				A = ply
			})
		end)
	:End()

	if CLIENT then
		sam.netstream.Hook("stopsound", function()
			RunConsoleCommand("stopsound")
		end)
	end
end

command.new("exit")
	:SetPermission("exit_vehicle", "admin")

	:AddArg("player", {single_target = true})

	:Help("exit_vehicle_help")

	:OnExecute(function(ply, targets)
		local target = targets[1]

		if not target:InVehicle() then
			if ply == target then
				return ply:sam_send_message("not_in_vehicle")
			else
				return ply:sam_send_message("not_in_vehicle2", {
					S = target:Name()
				})
			end
		end

		target:ExitVehicle()

		sam.player.send_message(ply, "exit_vehicle", {
			A = ply, T = targets
		})
	end)
:End()

command.new("time")
	:SetPermission("time", "user")

	:AddArg("player", {single_target = true, optional = true})

	:Help("time_help")

	:OnExecute(function(ply, targets)
		if ply == targets[1] then
			sam.player.send_message(ply, "time_your", {
				V = sam.reverse_parse_length(targets[1]:sam_get_play_time() / 60)
			})
		else
			sam.player.send_message(ply, "time_player", {
				T = targets, V = sam.reverse_parse_length(targets[1]:sam_get_play_time() / 60)
			})
		end
	end)
:End()

command.new("admin")
	:SetPermission("admin_mode", "admin")

	:Help("admin_help")

	:OnExecute(function(ply)
		ply:sam_cloak()
		ply:GodEnable()
		ply:SetMoveType(MOVETYPE_NOCLIP)
	end)
:End()

command.new("unadmin")
	:SetPermission("admin_mode", "admin")

	:Help("unadmin_help")

	:OnExecute(function(ply)
		ply:sam_uncloak()
		ply:GodDisable()
		ply:SetMoveType(MOVETYPE_WALK)
	end)
:End()

do
	command.new("buddha")
		:SetPermission("buddha", "admin")

		:AddArg("player", {optional = true})

		:Help("buddha_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				targets[i].sam_buddha = true
			end

			sam.player.send_message(ply, "buddha", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("unbuddha")
		:SetPermission("buddha", "admin")

		:AddArg("player", {optional = true})

		:Help("unbuddha_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				targets[i].sam_buddha = nil
			end

			sam.player.send_message(ply, "unbuddha", {
				A = ply, T = targets
			})
		end)
	:End()

	if SERVER then
		hook.Add("EntityTakeDamage", "SAM.BuddhaMode", function(ply, info)
			if ply.sam_buddha and ply:Health() - info:GetDamage() <= 0 then
				ply:SetHealth(1)
				return true
			end
		end)
	end
end

command.new("give")
	:SetPermission("give", "superadmin")

	:AddArg("player")
	:AddArg("text", {hint = "weapon/entity"})

	:Help("give_help")

	:OnExecute(function(ply, targets, weapon)
		for i = 1, #targets do
			targets[i]:Give(weapon)
		end

		sam.player.send_message(ply, "give", {
			A = ply, T = targets, V = weapon
		})
	end)
:End()

-- do
-- 	if CLIENT then
-- 		sam.netstream.Hook("GetFriends", function()
-- 			local friends = {}
-- 			local humans = player.GetHumans()
-- 			for i = 1, #humans do
-- 				local human = humans[i]
-- 				if human:GetFriendStatus() == "friend" then
-- 					table.insert(friends, human)
-- 				end
-- 			end
-- 			netstream.Start("GetFriends", friends)
-- 		end)
-- 	else
-- 		hook.Add("SAM.AuthedPlayer", "GetPlayerFriends", function(ply)
-- 			timer.Simple(0, function()
-- 				ply.sam_requesting_friends = true
-- 				netstream.Start(ply, "GetFriends")
-- 			end)
-- 		end)

-- 		local invalid_friends = function(ply, friends, new_list)
-- 			if not sam.istable(friends) then return true end

-- 			local count = #friends
-- 			local max_players = game.MaxPlayers()
-- 			for k, friend in pairs(friends) do
-- 				if not sam.isnumber(k) then return true end
-- 				if not sam.isentity(friend) then return true end
-- 				if k > max_players then return true end
-- 				if k > count then return true end

-- 				if IsValid(friend) then
-- 					table.insert(new_list, friend)
-- 				end
-- 			end
-- 		end

-- 		sam.netstream.Hook("GetFriends", function(ply, friends)
-- 			local new_list = {}
-- 			if invalid_friends(ply, friends, new_list) then
-- 				ply.sam_friends_invalid = true
-- 				return
-- 			end
-- 			ply.sam_friends = new_list
-- 		end, function()
-- 			return ply.sam_requesting_friends
-- 		end)
-- 	end

-- 	command.new("friends")
-- 		:SetPermission("friends", "superadmin")

-- 		:AddArg("player", {single_target = true})

-- 		:Help(language.get("friends_help"))

-- 		:OnExecute(function(ply, targets)
-- 			local target = targets[1]
-- 			target.sam_friends_requests = target.sam_friends_requests or {}
-- 			target.sam_friends_requests[ply] = true
-- 		end)
-- 	:End()
-- end
--addons/sam/lua/sam/modules/vote.lua:
if SAM_LOADED then return end

-- DONT EVER TALK TO ME ABOUT THIS CODE

local sam, command = sam, sam.command

command.set_category("Voting")

local start_vote, end_vote
if SERVER then
	local vote_on = false
	local options, players_voted

	local shuffle = function(tbl) -- https://gist.github.com/Uradamus/10323382
		for i = #tbl, 2, -1 do
			local j = math.random(i)
			tbl[i], tbl[j] = tbl[j], tbl[i]
		end
		return tbl
	end

	end_vote = function(ply, callback)
		if not vote_on then
			return ply:sam_add_text(color_white, "There is no vote to end.")
		end

		vote_on = false

		sam.set_global("Vote", nil)

		if callback then
			local tbl = {}
			local total_count = 0

			for i = 1, #options do
				local count = sam.get_global("Votings" .. i)
				total_count = total_count + count
				table.insert(tbl, {i, count})
				sam.set_global("Votings" .. i, nil)
			end

			if total_count == 0 then
				return sam.player.add_text(nil, color_white, "The vote have been canceled because nobody voted.")
			end

			table.sort(shuffle(tbl), function(a,b) return a[2] > b[2] end)

			local v = tbl[1]
			local winner, count = v[1], v[2]

			callback(winner, options[winner], count, total_count)
		else
			for i = 1, #options do
				sam.set_global("Votings" .. i, nil)
			end
		end

		options, players_voted = nil, nil

		timer.Remove("SAM.Vote")
	end

	start_vote = function(ply, callback, title, ...)
		if vote_on then
			return ply:sam_add_text(color_white, "There is an active vote, wait for it to finish.")
		end

		vote_on = true

		options, players_voted = {}, {}

		local args, n = {...}, select("#", ...)
		for i = 1, n do
			local v = args[i]
			if v then
				table.insert(options, v)
			end
		end

		sam.set_global("Vote", {title, options, CurTime()})

		for k in ipairs(options) do
			sam.set_global("Votings" .. k, 0)
		end

		timer.Create("SAM.Vote", 25, 1, function()
			end_vote(ply, callback)
		end)

		return true
	end

	sam.netstream.Hook("Vote", function(ply, index)
		if not sam.isnumber(index) or index > 5 then return end

		local votings = sam.get_global("Votings" .. index)
		if not votings then return end

		local old_index = players_voted[ply:AccountID()]
		if old_index == index then return end

		if old_index then
			sam.set_global("Votings" .. old_index, sam.get_global("Votings" .. old_index) - 1)
		end

		sam.set_global("Votings" .. index, votings + 1)

		players_voted[ply:AccountID()] = index
	end)
end

if CLIENT then
	local SUI = sam.SUI
	-- https://github.com/Facepunch/garrysmod/blob/master/garrysmod/lua/includes/extensions/client/player.lua

	local VOTING_TITLE = SUI.CreateFont("VotingTitle", "Roboto Bold", 15)
	local VOTING_OPTION = SUI.CreateFont("VotingTitle", "Roboto Medium", 14)

	local bind_translation = {}
	for i = 0, 9 do
		bind_translation["slot" .. i] = i
	end

	local voting_frame

	end_vote = function()
		if IsValid(voting_frame) then
			voting_frame:Remove()
		end
		hook.Remove("PlayerBindPress", "SAM.Voting")
		hook.Remove("SAM.ChangedGlobalVar", "SAM.VotingCount")
	end

	hook.Add("SAM.ChangedGlobalVar", "Voting", function(key, value)
		if key ~= "Vote" then return end

		if not value then
			end_vote()
			return
		end

		local title, options, start_time = value[1], value[2], value[3]

		sui.TDLib.Start()

		voting_frame = vgui.Create("EditablePanel")
		voting_frame:SetSize(SUI.Scale(165), SUI.Scale(230))
		voting_frame:SetPos(5, ScrH() * 0.25)
		voting_frame:DockPadding(4, 4, 4, 4)
		voting_frame:Blur()
			:Background(Color(30, 30, 30, 240))

		local voting_title = voting_frame:Add("SAM.Label")
		voting_title:Dock(TOP)
		voting_title:SetFont(VOTING_TITLE)
		voting_title:TextColor(Color(220, 220, 220))
		voting_title:SetText(title)
		voting_title:SetWrap(true)
		voting_title:SetAutoStretchVertical(true)

		local line = voting_frame:Add("SAM.Label")
		line:Dock(TOP)
		line:TextColor(Color(220, 220, 220))
		line:SetText("-")

		local options_added = {}
		for i, v in ipairs(options) do
			local option = voting_frame:Add("SAM.Label")
			option:Dock(TOP)
			option:SetFont(VOTING_OPTION)
			option:TextColor(Color(220, 220, 220), true)
			option:SetText(i .. ". " .. v .. " (0)")
			option:SetWrap(true)
			option:SetAutoStretchVertical(true)

			options_added[i] = option
		end

		function voting_frame:Think() -- fucking gmod
			self:SizeToChildren(false, true)

			local time_left = math.floor(25 - (CurTime() - start_time))
			if time_left <= 0 then
				end_vote()
				voting_frame.Think = nil
				return
			end

			voting_title:SetText(title .. " (" .. time_left .. ")")
		end

		line = voting_frame:Add("SAM.Label")
		line:Dock(TOP)
		line:TextColor(Color(220, 220, 220))
		line:SetText("-")

		local option = voting_frame:Add("SAM.Label")
		option:Dock(TOP)
		option:SetFont(VOTING_OPTION)
		option:TextColor(Color(220, 220, 220), true)
		option:SetText("0. Close")
		option:SetWrap(true)
		option:SetAutoStretchVertical(true)

		sui.TDLib.End()

		local current_index
		hook.Add("PlayerBindPress", "SAM.Voting", function(_, bind, down)
			if not down then return end

			local index = bind_translation[bind]
			if not index then return end

			if index == 0 then
				end_vote()
				return true
			end

			if not options[index] then return true end

			if current_index then
				options_added[current_index]:TextColor(Color(220, 220, 220), true)
			end

			options_added[index]:TextColor(Color(65, 185, 255), true)
			current_index = index

			sam.netstream.Start("Vote", index)

			return true
		end)

		hook.Add("SAM.ChangedGlobalVar", "SAM.VotingCount", function(key2, count)
			if key2:sub(1, 7) ~= "Votings" then return end
			if not count then return end

			local index = tonumber(key2:sub(8))
			options_added[index]:SetText(index .. ". " .. options[index] .. " (" .. count .. ")")
		end)
	end)
end

local vote_check = function(str)
	return str:match("%S") ~= nil
end

command.new("vote")
	:SetPermission("vote", "admin")

	:AddArg("text", {hint = "title", check = vote_check})
	:AddArg("text", {hint = "option", check = vote_check})
	:AddArg("text", {hint = "option", check = vote_check})
	:AddArg("text", {hint = "option", optional = true, check = vote_check})
	:AddArg("text", {hint = "option", optional = true, check = vote_check})
	:AddArg("text", {hint = "option", optional = true, check = vote_check})

	:Help("Start a vote!")

	:OnExecute(function(ply, title, ...)
		local callback = function(_, option, count, total_count)
			sam.player.send_message(nil, "Vote {V} for {V_2} has been passed. ({V_3}/{V_4})", {
				V = title, V_2 = option, V_3 = count, V_4 = total_count
			})
		end

		if start_vote(ply, callback, title, ...) then
			sam.player.send_message(nil, "{A} started a vote with title {V}.", {
				A = ply, V = title
			})
		end
	end)
:End()

command.new("endvote")
	:SetPermission("endvote", "admin")

	:Help("End current vote.")

	:OnExecute(function(ply)
		end_vote(ply)
	end)
:End()

command.new("votekick")
	:SetPermission("votekick", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("text", {hint = "reason", optional = true})

	:GetRestArgs()

	:Help("Start a vote to kick a player.")

	:OnExecute(function(ply, targets, reason)
		local target = targets[1]
		local target_name = target:Name()

		local callback = function(index, option, count, total_count)
			if not IsValid(ply) then
				sam.player.send_message(nil, "Vote was canceled because {T} left.", {
					T = target_name
				})
				return
			end

			if index == 1 then
				target:Kick("Vote was successful (" .. (reason or "none") .. ")")

				sam.player.send_message(nil, "Vote was successful, {T} has been kicked. ({V})", {
					T = targets, V = reason
				})
			else
				sam.player.send_message(nil, "Vote was unsuccessful, {T} won't be kicked.", {
					T = target_name
				})
			end
		end

		local title = "Kick " .. target_name .. "?"
		if reason then
			title = title .. " (" .. reason .. ")"
		end

		if start_vote(ply, callback, title, "Yes", "No") then
			if reason then
				sam.player.send_message(nil, "{A} started a votekick against {T} ({V})", {
					A = ply, T = targets, V = reason
				})
			else
				sam.player.send_message(nil, "{A} started a votekick against {T}", {
					A = ply, T = targets
				})
			end
		end
	end)
:End()

command.new("voteban")
	:SetPermission("voteban", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("length", {optional = true, default = 60, min = 30, max = 120})
	:AddArg("text", {hint = "reason", optional = true})

	:GetRestArgs()

	:Help("Start a vote to ban a player.")

	:OnExecute(function(ply, targets, length, reason)
		local target = targets[1]
		local target_steamid, target_name = target:SteamID(), target:Name()
		local ply_steamid = ply:SteamID()

		local callback = function(index, option, count, total_count)
			if index == 1 then
				sam.player.ban_id(target_steamid, length, "Vote was successful (" .. (reason or "none") .. ")", ply_steamid)

				sam.player.send_message(nil, "Vote was successful, {T} has been banned. ({V})", {
					T = target_name, V = reason
				})
			else
				sam.player.send_message(nil, "Vote was unsuccessful, {T} won't be banned.", {
					T = target_name
				})
			end
		end

		local title = "Ban " .. target_name .. "?"
		if reason then
			title = title .. " (" .. reason .. ")"
		end

		if start_vote(ply, callback, title, "Yes", "No") then
			if reason then
				sam.player.send_message(nil, "{A} started a voteban against {T} for {V} ({V_2})", {
					A = ply, T = targets, V = sam.format_length(length), V_2 = reason
				})
			else
				sam.player.send_message(nil, "{A} started a voteban against {T} for {V}", {
					A = ply, T = targets, V = sam.format_length(length)
				})
			end
		end
	end)
:End()

command.new("votemute")
	:SetPermission("votemute", "admin")

	:AddArg("player", {single_target = true})
	:AddArg("text", {hint = "reason", optional = true})

	:GetRestArgs()

	:Help("Start a vote to mute and gag a player.")

	:OnExecute(function(ply, targets, reason)
		local _reason = reason and (" (" .. reason .. ")") or ""

		local target = targets[1]
		local target_name = target:Name()

		local callback = function(index, option, count, total_count)
			if not IsValid(target) then
				sam.player.send_message(nil, "Vote was canceled because {T} left.", {
					T = target_name
				})
				return
			end

			if index == 1 then
				RunConsoleCommand("sam", "mute", "#" .. target:EntIndex(), 0, "votemute" .. _reason)
				RunConsoleCommand("sam", "gag", "#" .. target:EntIndex(), 0, "votemute" .. _reason)

				sam.player.send_message(nil, "Vote was successful, {T} has been muted. ({V})", {
					T = target_name, V = reason
				})
			else
				sam.player.send_message(nil, "Vote was unsuccessful, {T} won't be muted.", {
					T = target_name
				})
			end
		end

		local title = "Mute " .. target_name .. "?" .. _reason
		if start_vote(ply, callback, title, "Yes", "No") then
			if reason then
				sam.player.send_message(nil, "{A} started a votemute against {T} ({V}).", {
					A = ply, T = targets, V = reason
				})
			else
				sam.player.send_message(nil, "{A} started a votemute against {T}.", {
					A = ply, T = targets
				})
			end
		end
	end)
:End()

command.new("votemap")
	:SetPermission("votemap", "admin")

	:AddArg("map", {exclude_current = true})
	:AddArg("map", {optional =  true, exclude_current = true})
	:AddArg("map", {optional =  true, exclude_current = true})

	:GetRestArgs()

	:Help("Start a vote to change map.")

	:OnExecute(function(ply, ...)
		local callback = function(_, option, count, total_count)
			sam.player.send_message(nil, "Map vote for {V} has been passed. ({V_2}/{V_3})", {
				V = option, V_2 = count, V_3 = total_count
			})

			if sam.is_valid_map(option) then
				RunConsoleCommand("sam", "map", option)
			end
		end

		local args = {...}
		for i = select("#", ...), 1, -1 do
			if args[i] == "None" then
				args[i] = nil
			end
		end
		table.insert(args, "Extend Current Map")

		if start_vote(ply, callback, "Vote for the next map!", unpack(args)) then
			sam.player.send_message(nil, "{A} started a map change vote.", {
				A = ply
			})
		end
	end)
:End()
--addons/sui/lua/sui/vgui/sui_frame.lua:
local math = math
local gui = gui
local draw = draw
local surface = surface

local ScrW = ScrW
local ScrH = ScrH
local IsValid = IsValid
local ipairs = ipairs

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local FRAME_FONT = SUI.CreateFont("Frame", "Roboto", 18)

local Panel = FindMetaTable("Panel")

local PANEL = {}

AccessorFunc(PANEL, "m_bHeaderHeight", "HeaderHeight", FORCE_NUMBER)
AccessorFunc(PANEL, "m_bTitleFont", "TitleFont", FORCE_STRING)
AccessorFunc(PANEL, "m_bSizable", "Sizable", FORCE_BOOL)
AccessorFunc(PANEL, "m_iMinWidth", "MinWidth", FORCE_NUMBER)
AccessorFunc(PANEL, "m_iMinHeight", "MinHeight", FORCE_NUMBER)

local header_Think = function(s)
	local parent = s.parent
	local sw, sh = ScrW(), ScrH()

	if s.dragging then
		local x, y = input.GetCursorPos()
		x, y = math.Clamp(x, 1, sw - 1), math.Clamp(y, 1, sh - 1)
		x, y = x - s.dragging[1], y - s.dragging[2]

		parent:SetPos(x, y)
		parent:InvalidateLayout(true)
		parent:OnPosChanged()
	else
		local x, y, w, h = parent:GetBounds()
		parent:SetPos(math.Clamp(x, 5, sw - w - 5), math.Clamp(y, 5, sh - h - 5))
	end
end

local header_OnMousePressed = function(s)
	local parent = s.parent
	s.dragging = {gui.MouseX() - parent.x, gui.MouseY() - parent.y}
	s:MouseCapture(true)
end

local header_OnMouseReleased = function(s)
	s.dragging = nil
	s:MouseCapture(false)
end

local title_SetBGColor = function(s, c)
	s:SetVisible(c and true or false)
end

local title_update_color = function(s)
	s:SetTextColor(SUI.GetColor("title"))
end

local close_DoClick = function(s)
	s.frame:Remove()
end

function PANEL:Init()
	local header_buttons = {}
	self.header_buttons = header_buttons

	self:Center()
	self:SetHeaderHeight(28)

	local header = self:Add("PANEL")
	header:Dock(TOP)
	header.Paint = self.HeaderPaint
	header:SetCursor("sizeall")

	header.parent = self
	header.Think = header_Think
	header.OnMousePressed = header_OnMousePressed
	header.OnMouseReleased = header_OnMouseReleased
	self.header = header

	local title = header:Add(NAME .. ".Label")
	title:Dock(LEFT)
	title:DockMargin(6, 2, 0, 2)
	title:SetText("")
	title:SetTextColor(SUI.GetColor("title"))
	title:SizeToContents()
	title.SetBGColor = title_SetBGColor
	hook.Add(NAME .. ".ThemeChanged", title, title_update_color)
	self.title = title

	self.close = self:AddHeaderButton("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/close.png", "close", close_DoClick)
	self.close.frame = self

	self:SetSize(SUI.Scale(520), SUI.Scale(364))
	self:SetTitleFont(FRAME_FONT)
	SUI.OnScaleChanged(self, self.ScaleChanged)

	function self:PerformLayout(w, h)
		if IsValid(title) then
			title:SizeToContents()
		end

		if IsValid(header) then
			header:SetTall(SUI.Scale(self:GetHeaderHeight()))
		end

		for k, v in ipairs(header_buttons) do
			if IsValid(v) then
				v:SetWide(v:GetTall())
				local margin = SUI.Scale(4)
				v.image:DockMargin(margin, margin, margin, margin)
			end
		end
	end
end

function PANEL:SetSize(w, h)
	self.real_w, self.real_h = w, h
	self:ScaleChanged()
end

function PANEL:HeaderPaint(w, h)
	draw.RoundedBoxEx(3, 0, 0, w, h, SUI.GetColor("header"), true, true)
end

local SetSize = Panel.SetSize
PANEL.RealSetSize = SetSize
function PANEL:ScaleChanged()
	if self.sizing then return end

	local new_w, new_h = SUI.Scale(self.real_w), SUI.Scale(self.real_h)
	self.x, self.y = self.x + (self:GetWide() / 2 - new_w / 2), self.y + (self:GetTall() / 2 - new_h / 2)
	SetSize(self, new_w, new_h)
	self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
	if SUI.GetColor("frame_blur") then
		TDLib.BlurPanel(self)
	end

	self:RoundedBox("Background", 3, 0, 0, w, h, SUI.GetColor("frame"))
end

function PANEL:SetTitleFont(font)
	self.m_bTitleFont = font
	self.title:SetFont(font)
end

function PANEL:SetTitle(text)
	self.title:SetText(text)
	self.title:SizeToContents()
end

function PANEL:AddHeaderButton(image_name, name, callback)
	local button = self.header:Add("DButton")
	button:SetText("")
	button:Dock(RIGHT)
	button:DockMargin(0, 2, #self.header:GetChildren() == 1 and 4 or 2, 2)

	local hover = name .. "_hover"
	local press = name .. "_press"
	local circle = {}
	button.Paint = function(s, w, h)
		if s:IsHovered() then
			TDLib.DrawCircle(circle, w / 2, h / 2, w / 2, SUI.GetColor(hover))
		end

		if s.Depressed then
			TDLib.DrawCircle(circle, w / 2, h / 2, w / 2, SUI.GetColor(press))
		end
	end
	button.DoClick = callback

	local image = button:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetMouseInputEnabled(false)
	image:SetImage(image_name)

	button.image = image

	table.insert(self.header_buttons, button)

	return button
end

function PANEL:OnMousePressed(_, checking)
	if not self.m_bSizable then return end

	local x, y = self:LocalToScreen(0, 0)
	local w, h = self:GetSize()
	if gui.MouseX() > (x + w - 20) and gui.MouseY() > (y + h - 20) then
		if not checking then
			self.sizing = {gui.MouseX() - w, gui.MouseY() - h}
			self:MouseCapture(true)
		end

		self:SetCursor("sizenwse")

		return
	end

	if checking then
		self:SetCursor("arrow")
	end
end

function PANEL:OnMouseReleased()
	if not self.m_bSizable then return end

	self:MouseCapture(false)
	SUI.CallScaleChanged()
	self.sizing = nil
end

function PANEL:Think()
	if not self.m_bSizable then return end

	self:OnMousePressed(nil, true)

	if not self.sizing then return end

	local sw, sh = ScrW(), ScrH()

	local cx, cy = input.GetCursorPos()
	local mousex = math.Clamp(cx, 1, sw - 1)
	local mousey = math.Clamp(cy, 1, sh - 1)

	local x = mousex - self.sizing[1]
	x = math.Clamp(x, self.m_iMinWidth, sw - 10)

	local y = mousey - self.sizing[2]
	y = math.Clamp(y, self.m_iMinHeight, sh - 10)

	self.real_w, self.real_h = x, y
	SetSize(self, x, y)
	self:InvalidateLayout(true)
	self:SetCursor("sizenwse")
end

function PANEL:OnPosChanged()
end

local SetVisible = Panel.SetVisible
local Remove = Panel.Remove

local anim_speed = 0.2

local show = function(s)
	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	SetVisible(s, true)

	SetSize(s, w * 1.1, h * 1.1)
	s:Center()

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() / 2) - (w / 2), (ScrH() / 2) - (h / 2), anim_speed, 0, -1)
	s:AlphaTo(255, anim_speed + 0.02, 0)
	s:MakePopup()
end

local remove = function(s, hide)
	if not hide and not s:IsVisible() then
		Remove(s)
		return
	end

	local w, h = s.real_w, s.real_h

	if s.anim_scale then
		w, h = SUI.Scale(w), SUI.Scale(h)
	end

	w, h = w * 1.1, h * 1.1

	s:Stop()
	s:SizeTo(w, h, anim_speed, 0, -1)
	s:MoveTo((ScrW() / 2) - (w / 2), (ScrH() / 2) - (h / 2), anim_speed, 0, -1)
	s:SetMouseInputEnabled(false)
	s:SetKeyboardInputEnabled(false)
	s:AlphaTo(0, anim_speed + 0.02, 0, function()
		if hide then
			SetVisible(s, false)
		else
			Remove(s)
		end
	end)
end

local hide = function(s)
	remove(s, true)
end

function PANEL:AddAnimations(w, h, no_scale)
	self.anim_scale = not no_scale
	self.real_w, self.real_h = w, h

	self:SetAlpha(0)
	show(self)

	self.Remove = remove
	self.Hide = hide
	self.Show = show
end

sui.register("Frame", PANEL, "EditablePanel")
--addons/sui/lua/sui/vgui/sui_toggle_button.lua:
local Lerp = Lerp
local FrameTime = FrameTime

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

function Panel:Init()
	self:ScaleInit()

	local rounded_box = {}
	local switch_circle = {}
	function self:Paint(w, h)
		local is_checked = self:GetChecked()

		local _h = SUI.Scale(14)
		TDLib.RoundedBox(rounded_box, _h, 0, h / 2 - _h / 2, w, _h, is_checked and SUI.GetColor("toggle_button_active") or SUI.GetColor("toggle_button"))

		local size = h - 2
		do
			local pos = is_checked and (w - (size / 2)) or (h / 2 - 1)
			if self.pos then
				self.pos = Lerp(FrameTime() * 12, self.pos, pos)
			else
				self.pos = pos
			end
		end

		TDLib.DrawCircle(switch_circle, self.pos, h / 2, size / 2, is_checked and SUI.GetColor("toggle_button_switch_active") or SUI.GetColor("toggle_button_switch"))
	end

	self:SetSize(34, 20)
end

sui.register("ToggleButton", Panel, "DCheckBox")
--addons/sui/lua/sui/vgui/sui_zcolumn_sheet.lua:
local IsValid = IsValid

local TDLib_Classes = sui.TDLib.LibClasses
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local Panel = {}

function Panel:Init()
	self.tabs = {}

	local tab_scroller = self:Add(NAME .. ".ScrollPanel")
	tab_scroller:Dock(LEFT)

	function tab_scroller:Paint(w, h)
		self:RoundedBox("Background", 1, 0, 0, w, h, GetColor("column_sheet_bar"))
	end

	self.tabs_wide = 48
	self.tab_scroller = tab_scroller

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function Panel:ScaleChanged()
	local tabs_wide = SUI.Scale(self.tabs_wide)
	self.tab_scroller:SetWide(tabs_wide)

	self:InvalidateLayout(true)

	local tabs = self.tabs
	for i = 1, #self.tabs do
		tabs[i].img:SetMinus(SUI.Scale(20))
	end
end

function Panel:Paint(w, h)
	self:RoundedBox("Background", 1, 0, 0, w, h, GetColor("column_sheet"))
end

local tab_DoClick = function(s)
	s.parent:SetActiveTab(s)
end

local tab_Paint = function(s, w, h)
	local cur_col
	if s.active then
		cur_col = GetColor("column_sheet_tab_active")
	elseif s.Hovered then
		cur_col = GetColor("column_sheet_tab_hover")
	else
		cur_col = GetColor("column_sheet_tab")
	end

	s:RoundedBox("Backgrounds", 0, 0, 0, w, h, cur_col)
end

local tab_OnRemove = function(s)
	table.RemoveByValue(s.parent.tabs, s)
end

function Panel:AddSheet(mat, load_func)
	local tab = self.tab_scroller:Add(NAME .. ".Button")
	tab:Dock(TOP)
	tab:SetText("")
	tab:SetTall(self.tabs_wide)

	tab.On = TDLib_Classes.On

	tab.DoClick = tab_DoClick
	tab.Paint = tab_Paint
	tab:On("OnRemove", tab_OnRemove)

	tab.parent = self
	tab.load_func = load_func

	local img = tab:Add(NAME .. ".Image")
	img:Dock(FILL)
	img:SetImage(mat)
	img:SetMinus(SUI.Scale(20))

	tab.img = img

	self.tab_scroller:AddItem(tab)

	if not self:GetActiveTab() then
		self:SetActiveTab(tab)
	end

	table.insert(self.tabs, tab)

	return tab
end

function Panel:GetActiveTab()
	return self.active_tab
end

function Panel:SetActiveTab(new_tab)
	if new_tab == self.active_tab then return end

	if not IsValid(new_tab.panel) then
		local panel = new_tab.load_func(self)
		panel:SetParent(self)
		panel:SetVisible(false)
		panel:SetAlpha(0)

		panel.tab = new_tab
		new_tab.panel = panel
	end

	local old_active_tab = self.active_tab
	local delay = 0
	if old_active_tab and IsValid(old_active_tab.panel) then
		old_active_tab.active = false
		delay = 0.2
		old_active_tab.panel:AlphaTo(0, delay, 0, function(_, p)
			if p:IsValid() then
				p:SetVisible(false)
			end
		end)
	end

	new_tab.active = true
	new_tab.panel:SetVisible(true)
	new_tab.panel:AlphaTo(255, 0.2, delay)
	self.active_tab = new_tab
end

sui.register("ColumnSheet", Panel, "EditablePanel")
--addons/scb_chatbox/lua/scb/cl_util.lua:
if SCB_LOADED then return end

local tonumber = tonumber
local Color = Color
local bit = bit
local file = file
local SortedPairs = SortedPairs
local table = table
local util = util
local math = math

local scb = scb

function scb.hex_rgb(hex)
	hex = tonumber(hex:gsub("^([%w])([%w])([%w])$", "%1%1%2%2%3%3", 1), 16)

	return Color(
		bit.band(bit.rshift(hex, 16), 0xFF),
		bit.band(bit.rshift(hex, 8), 0xFF),
		bit.band(hex, 0xFF)
	)
end

function scb.rgb_hex(color)
	return ("%x%x%x"):format(color.r, color.g, color.b)
end

function scb.get_extension(path)
	return path:GetExtensionFromFilename():match("(%w+)")
end

function scb.to_new_range(x, old_min, old_max, new_min, new_max)
	return (x - old_min) * (new_max - new_min) / (old_max - old_min) + new_min
end

function scb.is_letter_digit(c)
	return
		(c >= "a" and c <= "z") or
		(c >= "A" and c <= "Z") or
		(c >= "0" and c <= "9")
end

function scb.is_custom_emoji(info)
	return info:sub(1, 4) == "http"
end

do
	local escape_replacements = {
		["\\"] = "\\\\",
		["{"] = "\\{" ,
		["}"] = "\\}"
	}

	function scb.escape(text)
		text = text:gsub(".", escape_replacements)

		local pos = 0
		while true do
			local start, url, _end = scb.find_url(text, pos + 1)
			if not start then break end
			pos = _end + 1
			text = text:sub(1, start - 1) .. "\\" .. url .. text:sub(_end + 1)
		end

		return text
	end
end

do
	-- i feel disgusted

	if not file.Exists("scb/emojis_used.txt", "DATA") then
		file.Write("scb/emojis_used.txt", "{}")
	end
	local emojis_times_used = util.JSONToTable(file.Read("scb/emojis_used.txt", "DATA"))

	function scb.search_emojis(text)
		local emojis = {}
		for name in SortedPairs(scb.emojis) do
			name = name:lower()
			local start = name:find(text, 1, true)
			if start then
				if name:sub(start - 1, start - 1) == "_" then
					start = 1
				elseif name == text then
					start = math.huge
				end
				local used_times = emojis_times_used[name]
				if start == 1 then
					if used_times then
						used_times = used_times + (9999999999 + (start ^ 4))
					else
						used_times = 9999999999
					end
				elseif used_times then
					used_times = used_times + (999999999 + (start ^ 4))
				else
					used_times = start
				end
				table.insert(emojis, {name = name, pos = -used_times})
			end
		end
		table.SortByMember(emojis, "pos", true)

		return emojis
	end

	function scb.emoji_set_used(emoji)
		emojis_times_used[emoji] = (emojis_times_used[emoji] or 0) + 1
		file.Write("scb/emojis_used.txt", util.TableToJSON(emojis_times_used))
	end
end

do
	-- https://stackoverflow.com/questions/23590304/finding-a-url-in-a-string-lua-pattern?rq=1

	-- https://raw.githubusercontent.com/incognico/list-of-top-level-domains/master/formats/json/tld-list.json
	local domains = [==[["aaa","aarp","abarth","abb","abbott","abbvie","abc","able","abogado","abudhabi","ac","academy","accenture","accountant","accountants","aco","active","actor","ad","adac","ads","adult","ae","aeg","aero","aetna","af","afamilycompany","afl","africa","ag","agakhan","agency","ai","aig","aigo","airbus","airforce","airtel","akdn","al","alfaromeo","alibaba","alipay","allfinanz","allstate","ally","alsace","alstom","am","americanexpress","americanfamily","amex","amfam","amica","amsterdam","an","analytics","android","anquan","anz","ao","aol","apartments","app","apple","aq","aquarelle","ar","arab","aramco","archi","army","arpa","art","arte","as","asda","asia","associates","at","athleta","attorney","au","auction","audi","audible","audio","auspost","author","auto","autos","avianca","aw","aws","ax","axa","az","azure","ba","baby","baidu","banamex","bananarepublic","band","bank","bar","barcelona","barclaycard","barclays","barefoot","bargains","baseball","basketball","bauhaus","bayern","bb","bbc","bbt","bbva","bcg","bcn","bd","be","beats","beauty","beer","bentley","berlin","best","bestbuy","bet","bf","bg","bh","bharti","bi","bible","bid","bike","bing","bingo","bio","biz","bj","bl","black","blackfriday","blanco","blockbuster","blog","bloomberg","blue","bm","bms","bmw","bn","bnl","bnpparibas","bo","boats","boehringer","bofa","bom","bond","boo","book","booking","boots","bosch","bostik","boston","bot","boutique","box","bq","br","bradesco","bridgestone","broadway","broker","brother","brussels","bs","bt","budapest","bugatti","build","builders","business","buy","buzz","bv","bw","by","bz","bzh","ca","cab","cafe","cal","call","calvinklein","cam","camera","camp","cancerresearch","canon","capetown","capital","capitalone","car","caravan","cards","care","career","careers","cars","cartier","casa","case","caseih","cash","casino","cat","catering","catholic","cba","cbn","cbre","cbs","cc","cd","ceb","center","ceo","cern","cf","cfa","cfd","cg","ch","chanel","channel","charity","chase","chat","cheap","chintai","chloe","christmas","chrome","chrysler","church","ci","cipriani","circle","cisco","citadel","citi","citic","city","cityeats","ck","cl","claims","cleaning","click","clinic","clinique","clothing","cloud","club","clubmed","cm","cn","co","coach","codes","coffee","college","cologne","com","comcast","commbank","community","company","compare","computer","comsec","condos","construction","consulting","contact","contractors","cooking","cookingchannel","cool","coop","corsica","country","coupon","coupons","courses","cr","credit","creditcard","creditunion","cricket","crown","crs","cruise","cruises","csc","cu","cuisinella","cv","cw","cx","cy","cymru","cyou","cz","dabur","dad","dance","data","date","dating","datsun","day","dclk","dds","de","deal","dealer","deals","degree","delivery","dell","deloitte","delta","democrat","dental","dentist","desi","design","dev","dhl","diamonds","diet","digital","direct","directory","discount","discover","dish","diy","dj","dk","dm","dnp","do","docs","doctor","dodge","dog","doha","domains","doosan","dot","download","drive","dtv","dubai","duck","dunlop","duns","dupont","durban","dvag","dvr","dz","earth","eat","ec","eco","edeka","edu","education","ee","eg","eh","email","emerck","energy","engineer","engineering","enterprises","epost","epson","equipment","er","ericsson","erni","es","esq","estate","esurance","et","etisalat","eu","eurovision","eus","events","everbank","exchange","expert","exposed","express","extraspace","fage","fail","fairwinds","faith","family","fan","fans","farm","farmers","fashion","fast","fedex","feedback","ferrari","ferrero","fi","fiat","fidelity","fido","film","final","finance","financial","fire","firestone","firmdale","fish","fishing","fit","fitness","fj","fk","flickr","flights","flir","florist","flowers","flsmidth","fly","fm","fo","foo","food","foodnetwork","football","ford","forex","forsale","forum","foundation","fox","fr","free","fresenius","frl","frogans","frontdoor","frontier","ftr","fujitsu","fujixerox","fun","fund","furniture","futbol","fyi","ga","gal","gallery","gallo","gallup","game","games","gap","garden","gb","gbiz","gd","gdn","ge","gea","gent","genting","george","gf","gg","ggee","gh","gi","gift","gifts","gives","giving","gl","glade","glass","gle","global","globo","gm","gmail","gmbh","gmo","gmx","gn","godaddy","gold","goldpoint","golf","goo","goodhands","goodyear","goog","google","gop","got","gov","gp","gq","gr","grainger","graphics","gratis","green","gripe","grocery","group","gs","gt","gu","guardian","gucci","guge","guide","guitars","guru","gw","gy","hair","hamburg","hangout","haus","hbo","hdfc","hdfcbank","health","healthcare","help","helsinki","here","hermes","hgtv","hiphop","hisamitsu","hitachi","hiv","hk","hkt","hm","hn","hockey","holdings","holiday","homedepot","homegoods","homes","homesense","honda","honeywell","horse","hospital","host","hosting","hot","hoteles","hotels","hotmail","house","how","hr","hsbc","ht","htc","hu","hughes","hyatt","hyundai","ibm","icbc","ice","icu","id","ie","ieee","ifm","iinet","ikano","il","im","imamat","imdb","immo","immobilien","in","industries","infiniti","info","ing","ink","institute","insurance","insure","int","intel","international","intuit","investments","io","ipiranga","iq","ir","irish","is","iselect","ismaili","ist","istanbul","it","itau","itv","iveco","iwc","jaguar","java","jcb","jcp","je","jeep","jetzt","jewelry","jio","jlc","jll","jm","jmp","jnj","jo","jobs","joburg","jot","joy","jp","jpmorgan","jprs","juegos","juniper","kaufen","kddi","ke","kerryhotels","kerrylogistics","kerryproperties","kfh","kg","kh","ki","kia","kim","kinder","kindle","kitchen","kiwi","km","kn","koeln","komatsu","kosher","kp","kpmg","kpn","kr","krd","kred","kuokgroup","kw","ky","kyoto","kz","la","lacaixa","ladbrokes","lamborghini","lamer","lancaster","lancia","lancome","land","landrover","lanxess","lasalle","lat","latino","latrobe","law","lawyer","lb","lc","lds","lease","leclerc","lefrak","legal","lego","lexus","lgbt","li","liaison","lidl","life","lifeinsurance","lifestyle","lighting","like","lilly","limited","limo","lincoln","linde","link","lipsy","live","living","lixil","lk","llc","loan","loans","locker","locus","loft","lol","london","lotte","lotto","love","lpl","lplfinancial","lr","ls","lt","ltd","ltda","lu","lundbeck","lupin","luxe","luxury","lv","ly","ma","macys","madrid","maif","maison","makeup","man","management","mango","map","market","marketing","markets","marriott","marshalls","maserati","mattel","mba","mc","mcd","mcdonalds","mckinsey","md","me","med","media","meet","melbourne","meme","memorial","men","menu","meo","merckmsd","metlife","mf","mg","mh","miami","microsoft","mil","mini","mint","mit","mitsubishi","mk","ml","mlb","mls","mm","mma","mn","mo","mobi","mobile","mobily","moda","moe","moi","mom","monash","money","monster","montblanc","mopar","mormon","mortgage","moscow","moto","motorcycles","mov","movie","movistar","mp","mq","mr","ms","msd","mt","mtn","mtpc","mtr","mu","museum","mutual","mutuelle","mv","mw","mx","my","mz","na","nab","nadex","nagoya","name","nationwide","natura","navy","nba","nc","ne","nec","net","netbank","netflix","network","neustar","new","newholland","news","next","nextdirect","nexus","nf","nfl","ng","ngo","nhk","ni","nico","nike","nikon","ninja","nissan","nissay","nl","no","nokia","northwesternmutual","norton","now","nowruz","nowtv","np","nr","nra","nrw","ntt","nu","nyc","nz","obi","observer","off","office","okinawa","olayan","olayangroup","oldnavy","ollo","om","omega","one","ong","onl","online","onyourside","ooo","open","oracle","orange","org","organic","orientexpress","origins","osaka","otsuka","ott","ovh","pa","page","pamperedchef","panasonic","panerai","paris","pars","partners","parts","party","passagens","pay","pccw","pe","pet","pf","pfizer","pg","ph","pharmacy","phd","philips","phone","photo","photography","photos","physio","piaget","pics","pictet","pictures","pid","pin","ping","pink","pioneer","pizza","pk","pl","place","play","playstation","plumbing","plus","pm","pn","pnc","pohl","poker","politie","porn","post","pr","pramerica","praxi","press","prime","pro","prod","productions","prof","progressive","promo","properties","property","protection","pru","prudential","ps","pt","pub","pw","pwc","py","qa","qpon","quebec","quest","qvc","racing","radio","raid","re","read","realestate","realtor","realty","recipes","red","redstone","redumbrella","rehab","reise","reisen","reit","reliance","ren","rent","rentals","repair","report","republican","rest","restaurant","review","reviews","rexroth","rich","richardli","ricoh","rightathome","ril","rio","rip","rmit","ro","rocher","rocks","rodeo","rogers","room","rs","rsvp","ru","rugby","ruhr","run","rw","rwe","ryukyu","sa","saarland","safe","safety","sakura","sale","salon","samsclub","samsung","sandvik","sandvikcoromant","sanofi","sap","sapo","sarl","sas","save","saxo","sb","sbi","sbs","sc","sca","scb","schaeffler","schmidt","scholarships","school","schule","schwarz","science","scjohnson","scor","scot","sd","se","search","seat","secure","security","seek","select","sener","services","ses","seven","sew","sex","sexy","sfr","sg","sh","shangrila","sharp","shaw","shell","shia","shiksha","shoes","shop","shopping","shouji","show","showtime","shriram","si","silk","sina","singles","site","sj","sk","ski","skin","sky","skype","sl","sling","sm","smart","smile","sn","sncf","so","soccer","social","softbank","software","sohu","solar","solutions","song","sony","soy","space","spiegel","sport","spot","spreadbetting","sr","srl","srt","ss","st","stada","staples","star","starhub","statebank","statefarm","statoil","stc","stcgroup","stockholm","storage","store","stream","studio","study","style","su","sucks","supplies","supply","support","surf","surgery","suzuki","sv","swatch","swiftcover","swiss","sx","sy","sydney","symantec","systems","sz","tab","taipei","talk","taobao","target","tatamotors","tatar","tattoo","tax","taxi","tc","tci","td","tdk","team","tech","technology","tel","telecity","telefonica","temasek","tennis","teva","tf","tg","th","thd","theater","theatre","tiaa","tickets","tienda","tiffany","tips","tires","tirol","tj","tjmaxx","tjx","tk","tkmaxx","tl","tm","tmall","tn","to","today","tokyo","tools","top","toray","toshiba","total","tours","town","toyota","toys","tp","tr","trade","trading","training","travel","travelchannel","travelers","travelersinsurance","trust","trv","tt","tube","tui","tunes","tushu","tv","tvs","tw","tz","ua","ubank","ubs","uconnect","ug","uk","um","unicom","university","uno","uol","ups","us","uy","uz","va","vacations","vana","vanguard","vc","ve","vegas","ventures","verisign","versicherung","vet","vg","vi","viajes","video","vig","viking","villas","vin","vip","virgin","visa","vision","vista","vistaprint","viva","vivo","vlaanderen","vn","vodka","volkswagen","volvo","vote","voting","voto","voyage","vu","vuelos","wales","walmart","walter","wang","wanggou","warman","watch","watches","weather","weatherchannel","webcam","weber","website","wed","wedding","weibo","weir","wf","whoswho","wien","wiki","williamhill","win","windows","wine","winners","wme","wolterskluwer","woodside","work","works","world","wow","ws","wtc","wtf","xbox","xerox","xfinity","xihuan","xin","测试","कॉम","परीक्षा","セール","佛山","ಭಾರತ","慈善","集团","在线","한국","ଭାରତ","大众汽车","点看","คอม","ভাৰত","ভারত","八卦","‏موقع‎","বাংলা","公益","公司","香格里拉","网站","移动","我爱你","москва","испытание","қаз","католик","онлайн","сайт","联通","срб","бг","бел","‏קום‎","时尚","微博","테스트","淡马锡","ファッション","орг","नेट","ストア","삼성","சிங்கப்பூர்","商标","商店","商城","дети","мкд","‏טעסט‎","ею","ポイント","新闻","工行","家電","‏كوم‎","中文网","中信","中国","中國","娱乐","谷歌","భారత్","ලංකා","電訊盈科","购物","測試","クラウド","ભારત","通販","भारतम्","भारत","भारोत","‏آزمایشی‎","பரிட்சை","网店","संगठन","餐厅","网络","ком","укр","香港","诺基亚","食品","δοκιμή","飞利浦","‏إختبار‎","台湾","台灣","手表","手机","мон","‏الجزائر‎","‏عمان‎","‏ارامكو‎","‏ایران‎","‏العليان‎","‏اتصالات‎","‏امارات‎","‏بازار‎","‏موريتانيا‎","‏پاکستان‎","‏الاردن‎","‏موبايلي‎","‏بارت‎","‏بھارت‎","‏المغرب‎","‏ابوظبي‎","‏السعودية‎","‏ڀارت‎","‏كاثوليك‎","‏سودان‎","‏همراه‎","‏عراق‎","‏مليسيا‎","澳門","닷컴","政府","‏شبكة‎","‏بيتك‎","‏عرب‎","გე","机构","组织机构","健康","ไทย","‏سورية‎","招聘","рус","рф","珠宝","‏تونس‎","大拿","みんな","グーグル","ελ","世界","書籍","ഭാരതം","ਭਾਰਤ","网址","닷넷","コム","天主教","游戏","vermögensberater","vermögensberatung","企业","信息","嘉里大酒店","嘉里","‏مصر‎","‏قطر‎","广东","இலங்கை","இந்தியா","հայ","新加坡","‏فلسطين‎","テスト","政务","xperia","xxx","xyz","yachts","yahoo","yamaxun","yandex","ye","yodobashi","yoga","yokohama","you","youtube","yt","yun","za","zappos","zara","zero","zip","zippo","zm","zone","zuerich","zw"]]==]
	domains = util.JSONToTable(domains)

	local tlds = {}
	for i = 1, #domains do
		tlds[domains[i]], domains[i] = true, nil
	end

	local protocols = {["http://"] = 0, ["https://"] = 0}
	local pattern = "(([%w_.~!*:@&+$/?%%#-]-)(%w[-.%w]*%.)(%w+)(:?)(%d*)(/?)([%w_.~!*:@&+$/?%%#=-]*))"

	function scb.find_url(text, start)
		local pos = start
		while true do
			local pos_start, pos_end, url, prot, subd, tld, colon, port, slash, path = text:find(pattern, pos)
			if not pos_start then break end

			if protocols[prot:lower()] == (1 - #slash) * #path and not subd:find("%W%W")
				and (colon == "" or port ~= "" and port + 0 < 65536)
				and (tlds[tld:lower()] or tld:find("^%d+$") and subd:find("^%d+%.%d+%.%d+%.$")
				and math.max(tld, subd:match("^(%d+)%.(%d+)%.(%d+)%.$")) < 256)
			then
				return pos_start, url, pos_end
			end

			pos = pos_end + 1
		end
	end
end
--addons/scb_chatbox/lua/scb/settings/tabs/emojis.lua:
if SCB_LOADED then return end

local scb = scb
local SUI = scb.SUI
local language = scb.language

scb.emojis = include("scb/cl_emojis_data.lua")

do
	local set_material = surface.SetMaterial
	local i = 0
	for name in pairs(scb.emojis) do
		timer.Simple(i * 0.001, function()
			set_material(SUI.Material("scb/emojis/" .. name .. ".png"))
		end)
		i = i + 1
	end
end

net.Receive("SCB.SendEmojis", function()
	local emojis = net.ReadData(net.ReadUInt(17))
	emojis = util.Decompress(emojis)

	for k, v in pairs(scb.mp.unpack(emojis)) do
		scb.emojis[k] = v
	end

	hook.Call("SCB.EmojisModified")
end)

net.Receive("SCB.AddEmoji", function()
	local emoji = net.ReadString()
	local url = net.ReadString()
	scb.emojis[emoji] = url

	local old = net.ReadString()
	if old ~= "" then
		scb.emojis[old] = nil
	end

	hook.Call("SCB.EmojisModified")
end)

net.Receive("SCB.RemoveEmoji", function()
	scb.emojis[net.ReadString()] = nil
	hook.Call("SCB.EmojisModified")
end)

local emoji_menu = function(title, emoji_name, emoji_url)
	emoji_name = emoji_name or ""

	local options = sui.valid_options()

	local querybox = vgui.Create("SCB.QueryBox")
	querybox:SetTitle(title)
	querybox:SetWide(300)

	local name = querybox:Add("SCB.TextEntry")
	name:Dock(TOP)
	name:SetPlaceholder(language.emoji_name)
	name:SetValue(emoji_name)
	name:SetCheck(function(_name)
		if _name == "" or (scb.emojis[_name] and emoji_name ~= _name) then
			return false
		end
	end)

	function name:AllowInput(c)
		return not c:find("[%w_]")
	end

	options.Add(name)

	local url = querybox:Add("SCB.TextEntry")
	url:Dock(TOP)
	url:DockMargin(0, 4, 0, 0)
	url:SetPlaceholder(language.emoji_url)
	url:SetValue(emoji_url or "")
	url:SetCheck(function(_url)
		if not _url:find("^https?://") then
			_url = "http://" .. _url
		end

		if scb.find_url(_url) ~= 1 then
			return false
		end
	end)

	function url:AllowInput(c)
		return c:find("%s") and true or false
	end

	options.Add(url)

	querybox:SetCallback(function()
		local _name = name:GetText():lower()
		local _url = url:GetText()

		if not _url:find("^https?://") then
			_url = "http://" .. _url
		end

		net.Start("SCB.AddEmoji")
			net.WriteString(_name)
			net.WriteString(_url)
			net.WriteString(_name ~= emoji_name and emoji_name or "")
		net.SendToServer()
	end)

	querybox:Done()
	querybox.save:SetEnabled(true)

	function querybox.save:Think()
		self:SetEnabled(options.IsValid())
	end
end

return {
	title = language.emojis_title,
	pos = 3,
	func = function(parent)
		local body = parent:Add("Panel")
		body:Dock(FILL)
		body:DockMargin(0, 1, 0, 0)
		body:InvalidateParent(true)

		SUI.OnScaleChanged(body, function()
			body:Remove()
		end)

		local top_body = body:Add("Panel")
		top_body:Dock(FILL)
		top_body:InvalidateParent(true)

		local search_field = top_body:Add("SCB.TextEntry")
		search_field:Dock(TOP)
		search_field:SetPlaceholder(language.search)

		local emojis_list = top_body:Add("SCB.ThreeGrid")
		emojis_list:Dock(FILL)
		emojis_list:DockMargin(3, 3, 3, 3)
		emojis_list:InvalidateLayout(true)
		emojis_list:InvalidateParent(true)

		emojis_list:SetColumns(3)
		emojis_list:SetHorizontalMargin(2)
		emojis_list:SetVerticalMargin(2)

		top_body.Paint, emojis_list.Paint = emojis_list.Paint, nil

		local load_emojis = function(search_key)
			emojis_list:Clear()

			search_key = search_key:lower()

			for emoji_name, v in pairs(scb.emojis) do
				if not scb.is_custom_emoji(v) then
					continue
				end

				if not string.find(emoji_name:lower(), search_key, 1, true) then
					continue
				end

				local pnl = vgui.Create("DButton")
				pnl:SetText("")
				pnl:SetTall(SUI.Scale(30))
				pnl:SUI_TDLib()
					:ClearPaint()
					:FadeHover()

				function pnl:DoClick()
					emoji_menu(language.edit .. " '" .. emoji_name .. "'", emoji_name, v)
				end

				function pnl:DoRightClick()
					local d_menu = DermaMenu()

					d_menu:AddOption(language.remove, function()
						net.Start("SCB.RemoveEmoji")
							net.WriteString(emoji_name:lower())
						net.SendToServer()
					end)

					d_menu:Open()
					d_menu:MakePopup()

					function pnl:OnRemove()
						d_menu:Remove()
					end
				end

				local emoji = pnl:Add("SCB.ChatLine")
				emoji:Dock(NODOCK)
				emoji.x = 2

				emoji:NewEmoji(emoji_name, v, 26)
				emoji:Center()
				emoji:SetMouseInputEnabled(false)

				local name = pnl:Add("SCB.Label")
				name:Dock(FILL)
				name:DockMargin(SUI.ScaleEven(26) + 8, 0, 0, 0)
				name:SetFont(SCB_16)
				name:SetText(emoji_name)

				emojis_list:AddCell(pnl)
			end
		end
		load_emojis("")

		hook.Add("SCB.EmojisModified", emojis_list, function()
			load_emojis(search_field:GetValue())
		end)

		function search_field:OnValueChange(v)
			load_emojis(v)
		end

		local add_emoji = body:Add("SCB.Button")
		add_emoji:Dock(BOTTOM)
		add_emoji:DockMargin(0, 4, 0, 0)
		add_emoji:SetText(language.add_emoji:upper())

		add_emoji:On("DoClick", function()
			emoji_menu(language.add_emoji)
		end)

		return body
	end
}
--addons/scb_chatbox/lua/scb/vgui/scb_chat_line.lua:
if SCB_LOADED then return end

local timer = timer
local draw = draw
local surface = surface
local math = math
local table = table
local vgui = vgui

local Lerp = Lerp
local Color = Color
local DermaMenu = DermaMenu
local unpack = unpack
local IsValid = IsValid
local UnPredictedCurTime = UnPredictedCurTime
local RoundedBox = draw.RoundedBox
local sub = string.sub
local find = string.find
local gsub = string.gsub
local lower = string.lower

local scb = scb
local sui = sui
local SUI = scb.SUI
local config = scb.config
local language = scb.language

scb.chat_parsers = {}
local add_parser_example = function(title, example, output)
	table.insert(scb.chat_parsers, {title, example, output:format("change_me")})
end

do
	local available_colors = "\n\nAvailable Colors:\n"
	for k in pairs(config.colors) do
		available_colors = available_colors .. k .. " - "
	end
	available_colors = available_colors:sub(1, -4) .. "\n"

	add_parser_example("{cyan This text will be in cyan.}" .. available_colors, "{cyan What is this?}", "{cyan %s}")
end
add_parser_example("{#d4af37 This text will be in gold.}\nUsage: {#hex text}\n", "{#d4af37 Gold is my favourite color UwU}", "{#d4af37 %s}")
add_parser_example("{*This text will be in rainbow.}", "{*Nice rainbow text OwO}", "{*%s}")
add_parser_example("{!This text will be flashing in red.}", "{!OwO I like it ^-^}", "{!%s}")
add_parser_example("{!blue This text will be flashing in blue.}", "{!blue I love flashing blue ^~^}", "{!blue %s}")
add_parser_example("{!#d4af37 This text will be flashing in gold.}", "{!#d4af37 flashing & gold?}", "{!#d4af37 %s}")
add_parser_example("\\{*This text will be escaped.}", "\\{*This text will be escaped.}", "\\{*%s}")

local ESCAPE_CHAR = "\\"

local created_panels = {}

local Panel = {}

AccessorFunc(Panel, "m_bFont", "Font", FORCE_STRING)
AccessorFunc(Panel, "m_bPlayer", "Player")

local current_x
local current_line
local current_y, line_h
function Panel:Init()
	self:Dock(TOP)
	self:SetFont(SCB_18)

	self:InvalidateParent(true)

	self:SetAlpha(0)
	self:AlphaTo(255, 0.5)

	self:SetCursor("hand")

	self.text_color = SUI.GetColor("text_entry")

	self.added = {}

	-- Methods
	local children = {}
	function self:Add(pnl)
		pnl = vgui.Create(pnl, self)
		pnl.line = current_line
		table.insert(children, pnl)
		return pnl
	end
	function self:OnChildRemoved(child)
		for i = 1, #children do
			local v = children[i]
			if v == child then
				table.remove(children, i)
				return
			end
		end
	end
	function self:GetChildren()
		return children
	end
	--

	-- self.next_pos = 427482418

	self:ScaleChanged()
	table.insert(created_panels, self)
end

function Panel:ScaleChanged()
	self:Clear()
	self:InvalidateParent(true)
	self:InvalidateLayout(true)

	current_x = 0
	current_line = 0
	current_y, line_h = 0, 0

	self.max_w = -1
	self.max_h = {0}
	self.text = ""

	self.emoji_size = 24

	self.parsing = true

	local added = self.added
	self.added = {}
	for i = 1, #added do
		local v = added[i]
		local v_1 = v[1]

		local func = (v_1 == 1 and self.NewLabel) or (v_1 == 2 and self.NewEmoji) or (v_1 == 3 and self.NewAvatar)
		func(self, unpack(v, 2, table.maxn(v)))

		added[i] = nil
	end

	self.parsing = nil
	self:SizeToChildren(false, true)
end

local hovered = Color(50, 50, 50, 150)
function Panel:Paint(w, h)
	if self.Hovered then
		RoundedBox(3, 0, 0, w, h, hovered)
	end
end

function Panel:DoRightClick()
	local d_menu = DermaMenu()
	local text = self.text
	d_menu:AddOption(language.copy_text, function()
		SetClipboardText(text)
	end)
	d_menu:Open()
	d_menu:MakePopup()
end

function Panel:OnMouseReleased(mousecode)
	if self.Hovered and mousecode == MOUSE_RIGHT then
		self:DoRightClick()
	end
end

function Panel:IncrementLine()
	current_x = 0
	current_line = current_line + 1
	current_y, line_h = current_y + line_h, 0
	self.max_h[current_line + 1] = 0
end

function Panel:SetLineH(h)
	if h > line_h then
		line_h = h
		self.max_h[current_line + 1] = h

		local childs = self:GetChildren()
		for i = #childs, 1, -1 do
			local v = childs[i]
			if v.line ~= current_line then break end
			v.y = self:GetCurrentY(v:GetTall())
		end
	end
end

function Panel:SizeToChildren(width, height)
	if self.parsing then return end

	if width then
		self:SetWide(self.max_w)
	end

	if height then
		self:SetTall(self:GetTotalH())
	end
end

function Panel:GetTotalH()
	local h = 0
	local max_h = self.max_h
	if max_h then
		for i = 1, #max_h do
			h = h + max_h[i]
		end
	end
	return h
end

function Panel:GetCurrentY(_h)
	local y = current_y
	if _h == line_h then return y end
	return math.floor((y + ((line_h / 2) - (_h / 2))) + 0.5)
end

function Panel:AddW(w)
	current_x = current_x + w

	if current_x > self.max_w then
		self.max_w = current_x
	end

	if current_x >= self:GetWide() then
		self:IncrementLine()
	end
end

function Panel:GetMessageW()
	return self.max_w
end

do
	local label_time

	local underline_color = Color(23, 115, 196)
	local url_underline = function(s, w, h)
		if s:IsHovered() then
			s:SetTextColor(underline_color)
		else
			s:SetTextColor(s.text_color)
		end
		RoundedBox(0, 0, h - 1, w, 1, s:GetTextColor())
	end

	local url_click = function(s)
		gui.OpenURL(s.url)
	end

	local url_right_click = function(s)
		local d_menu = DermaMenu()
		local url = s.url
		d_menu:AddOption(language.copy_url, function()
			SetClipboardText(url)
		end)
		d_menu:Open()
		d_menu:MakePopup()
	end

	local disable_rainbow_colors = GetConVar("scb_disable_rainbow_colors"):GetBool()
	cvars.AddChangeCallback("scb_disable_rainbow_colors", function(_, _, value_new)
		disable_rainbow_colors = tobool(value_new)
	end)
	local label_rainbow = function(s)
		if disable_rainbow_colors then
			s:SetTextColor(s.text_color)
			return
		end

		local r, g, b = sui.hsv_to_rgb((s.time + UnPredictedCurTime()) % 360 * 0.6, 1, 1)
		s:SetFGColor(r, g, b, s.text_color_obj.a)
	end

	local disable_flashing_texts = GetConVar("scb_disable_flashing_texts"):GetBool()
	cvars.AddChangeCallback("scb_disable_flashing_texts", function(_, _, value_new)
		disable_flashing_texts = tobool(value_new)
	end)
	local label_flash = function(s)
		if disable_flashing_texts then
			s:SetTextColor(s.text_color)
			return
		end

		local col = s.text_color_obj
		s:SetFGColor(col.r, col.g, col.b, (s.time + UnPredictedCurTime()) * 300 % 255)
	end

	function Panel:AddLabel(text, color, url, is_hovered, font)
		if text == "" then return end

		local w, h = surface.GetTextSize(text)
		self:SetLineH(h)

		local label = self:Add("SCB.Label")
		label:SetFont(font)
		label:SetText(text:sub(1, 1) == "#" and ("#" .. text) or text)
		label:SetExpensiveShadow(1, color_black)
		label:SetSize(w, h)
		label:SetPos(current_x, self:GetCurrentY(h))

		label.text_color = scb.type(color) == "Color" and color or self.text_color

		if color == "rainbow" or self.flashing then
			label.text_color_obj = Color(label.text_color:Unpack())
			label.time = label_time
			label.Paint = color == "rainbow" and label_rainbow or label_flash
		else
			label:SetTextColor(label.text_color)
		end

		if url then
			label:SetMouseInputEnabled(true)
			label:SetCursor("hand")
			label.Paint = url_underline
			label.DoClick = url_click
			label.DoRightClick = url_right_click
			label.url = url
			label.IsHovered = is_hovered
		end

		self.text = self.text .. text
		self:AddW(w)

		-- if scb.type(color) ~= "Color" then
			-- hook.Add("SCB.ThemeChanged", label, function(s)
			-- 	s.text_color = SUI.GetColor("text_entry")
			-- 	s:SetTextColor(s.text_color)
			-- end)
		-- end

		return label
	end

	local AddLabel = Panel.AddLabel
	local IncrementLine = Panel.IncrementLine
	function Panel:NewLabel(text, color, is_url, font)
		if text == "" then return end

		font = font or self:GetFont()
		table.insert(self.added, {1, text, color, is_url, flashing, font})

		local url
		if is_url then
			url = text
		end

		local wide = self:GetWide()
		text = sui.wrap_text(text, font, wide, wide - current_x)

		local urls, is_hovered
		if is_url then
			urls, is_hovered = {}, function()
				for k, v in ipairs(urls) do
					if v.Hovered then
						return true
					end
				end
			end
		end

		label_time = math.sin(UnPredictedCurTime()) + math.random()

		local lines = text:Split("\n")
		local lines_n = #lines
		for i = 1, lines_n do
			local v = lines[i]

			local line = current_line

			local label = AddLabel(self, v, color, url, is_hovered, font)
			if urls then
				table.insert(urls, label)
			end

			if i ~= lines_n and line == current_line then
				IncrementLine(self)
			end
		end

		self:SizeToChildren(false, true)
	end
end

function Panel:NewEmoji(name, info, size)
	local _size = size or self.emoji_size
	table.insert(self.added, {2, name, info, _size})

	if scb.isnumber(_size) then
		size = SUI.ScaleEven(_size)
	else
		size = tonumber(_size)
	end

	if size >= self:GetWide() - current_x then
		self:IncrementLine()
	end

	self:SetLineH(size)

	local image = self:Add("SCB.Image")
	image:SetImage(scb.is_custom_emoji(info) and info or ("scb/emojis/" .. name .. ".png"))
	image:SetSize(size, size)
	image:SetPos(current_x, self:GetCurrentY(size))

	if size == SUI.ScaleEven(24) then
		image:SetMinus(2)
	end

	self:AddW(size)

	self.text = self.text .. (":" .. name .. ":")

	self:SizeToChildren(false, true)

	return image
end

function Panel:NewAvatar(ply, size)
	table.insert(self.added, {3, ply, size})

	size = SUI.ScaleEven(size or 26)

	self:SetLineH(size)

	local avatar = self:Add("Panel")
	avatar:SetSize(size, size)
	avatar:SetPos(current_x, self:GetCurrentY(size))
	avatar:SetMouseInputEnabled(false)
	avatar:SUI_TDLib()
		:CircleAvatar()

	if scb.isentity(ply) then
		avatar:SetPlayer(ply, size)
	else
		avatar:SetSteamID(ply, size)
	end

	surface.SetFont(self:GetFont())
	self:AddW(size + surface.GetTextSize(" "))
end

function Panel:HideAfterTime(time)
	self.can_hide = false
	timer.Simple(time, function()
		if not IsValid(self) then return end
		self.can_hide = nil
		if scb.chatbox.hidden then
			self:AlphaTo(0, 0.5)
		end
	end)
end

do
	local NewLabel = Panel.NewLabel

	local trim = function(s)
		return s:match("^%s*(.-)%s*$") or s
	end

	local parse_arg = function(text)
		local arg = ""
		local i, n = 1, #text
		while i <= n do
			local c = sub(text, i, i)
			if c == " " then break end
			if c == "}" then break end
			arg = arg .. c

			i = i + 1
		end
		return lower(arg), i + 1
	end

	local color_parsers = {}
	for k, v in pairs(config.colors) do
		color_parsers[k] = {
			permission = "colored_texts",
			callback = function(self, text, arg)
				text = trim(text)
				if text == "" then return false end
				NewLabel(self, text, scb.hex_rgb(v))
			end
		}
	end

	local parsers; parsers = {
		["$"] = {
			callback = function(self, emoji, ply, color)
				emoji = lower(emoji)

				local emoji_info = scb.emojis[emoji]
				if emoji_info and not (scb.is_custom_emoji(emoji_info) and not scb.has_permission(ply, "custom_emojis")) then
					self:NewEmoji(emoji, emoji_info)
				else
					return false, ":" .. emoji .. ":"
				end
			end
		},
		["#"] = {
			permission = "colored_texts",
			callback = function(self, text, _, color)
				local hex_col, start = parse_arg(text)
				if #hex_col < 3 or not find(hex_col, "^[%da-fA-F]+$") then
					return false
				end
				text = trim(sub(text, start))
				if text == "" then return false end
				NewLabel(self, text, scb.hex_rgb(hex_col), nil, flashing)
			end
		},
		["*"] = {
			permission = "rainbow",
			callback = function(self, text, ...)
				text = trim(text)
				if text == "" then return false end
				NewLabel(self, text, "rainbow")
			end
		},
		["@"] = {
			callback = function(self, text)
				if scb.find_url(text) then
					NewLabel(self, text, nil, true)
				else
					return false
				end
			end
		},
		["!"] = {
			permission = "flashing",
			callback = function(self, text, ply)
				local ret

				self.flashing = true

				local arg, start = parse_arg(text)
				if scb.has_permission(ply, "colored_texts") then
					if sub(arg, 1, 1) == "#" then
						ret = parsers["#"].callback(self, sub(text, 2))
						goto skip
					elseif color_parsers[arg] then
						color_parsers[arg].callback(self, sub(text, start), "flash")
						goto skip
					end
				end

				text = trim(text)
				if text == "" then
					ret = false
					goto skip
				end
				NewLabel(self, text, Color(255, 0, 0))
				::skip::

				self.flashing = false

				return ret
			end
		}
	}

	local parse_between_braces = function(text, pos, len)
		local tmp_text = ""
		local end_pos = pos
		local closed = false
		local escape = false
		for i = pos, len do
			end_pos = i
			local c = sub(text, i, i)
			if escape then
				tmp_text = tmp_text .. c
				escape = false
				continue
			end
			if c == ESCAPE_CHAR then
				escape = true
			elseif c == "}" then
				closed = true
				break
			else
				tmp_text = tmp_text .. c
			end
		end
		return tmp_text, closed, end_pos
	end

	function Panel:Parse(text, color)
		self.parsing = true

		text = gsub(text, "()%:([%w_]+)%:", function(start, found)
			if text[start - 1] ~= ESCAPE_CHAR then
				return "{$" .. found .. "}"
			end
		end)

		do
			local pos = 0
			while true do
				local start, url, _end = scb.find_url(text, pos + 1)
				if not start then break end
				if text:sub(start - 1, start - 1) ~= ESCAPE_CHAR then
					text = text:sub(1, start - 1) .. ("{@" .. url .. "}") .. text:sub(_end + 1)
				end
				pos = _end + 1
			end
		end

		local ply = self:GetPlayer()

		local len = #text
		local tmp_text = ""
		local i = 0
		while true do
			i = i + 1
			if i > len then break end

			local c = sub(text, i, i)
			if c == ESCAPE_CHAR then
				tmp_text = tmp_text .. sub(text, i + 1, i + 1)
				i = i + 1
				continue
			end

			if c ~= "{" then
				tmp_text = tmp_text .. c
				continue
			end

			local ret_text, closed, end_pos = parse_between_braces(text, i + 1, len)
			if not closed then
				tmp_text = tmp_text .. sub(text, i, end_pos)
				break
			end

			local tag, tag_end = sub(ret_text, 1 , 1), 1
			if not scb.is_letter_digit(tag) then
				tag = parsers[tag]
			else
				for i2 = 2, #ret_text do
					local c2 = sub(ret_text, i2, i2)
					if not scb.is_letter_digit(c2) then break end
					tag = tag .. c2
					tag_end = tag_end + 1
				end
				tag_end = tag_end + 1
				tag = color_parsers[tag]
			end

			i = end_pos

			local failed_text = "{" .. ret_text .. "}"

			if tag == nil then
				tmp_text = tmp_text .. failed_text
				continue
			end

			local permission = tag.permission
			if permission and not scb.has_permission(ply, permission) then
				tmp_text = tmp_text .. failed_text
				continue
			end

			ret_text = sub(ret_text, tag_end + 1)

			NewLabel(self, tmp_text, color)
			local done, ret = tag.callback(self, ret_text, ply, color)
			if done == false then
				if ret then
					NewLabel(self, ret, color)
				else
					NewLabel(self, failed_text, color)
				end
			end
			tmp_text = ""
		end

		NewLabel(self, tmp_text, color)
		self.parsing = nil
		self:SizeToChildren(false, true)
	end
end

do
	local AnimationThink = function(s)
		local anim = s.anim
		if not anim then return end

		local time = UnPredictedCurTime()
		if time >= anim.start_time then
			local frac = math.TimeFraction(anim.start_time, anim.end_time, time)
			frac = math.Clamp(frac, 0, 1)

			s:SetAlpha(Lerp(frac ^ (1 - (frac - 0.5)), s:GetAlpha(), anim.alpha))

			if frac == 1 then
				s.anim = nil
				s.AnimationThink = nil
			end
		end
	end

	function Panel:AlphaTo(alpha, length)
		local time = UnPredictedCurTime()

		self.anim = {
			start_time = time,
			end_time = time + length,

			alpha = alpha
		}

		self.AnimationThink = AnimationThink
	end

	function Panel:Stop()
		self.anim = nil
	end
end

function Panel:OnRemove()
	for i = 1, #created_panels do
		if created_panels[i] == self then
			table.remove(created_panels, i)
			break
		end
	end
end

SUI.OnScaleChanged("ChatLines", function()
	timer.Simple(0, function()
		for i = 1, #created_panels do
			local v = created_panels[i]
			if v:IsValid() then
				v:ScaleChanged()
			end
		end
	end)
end)

sui.register("ChatLine", Panel, "Panel")
--addons/lvs_turret/lua/autorun/sh_joe_turret_base.lua:
Joe_Turret_Base = Joe_Turret_Base or {}
--addons/starwars_universe/lua/libs/advanceddraw.lua:
--    Advanced Draw:
--    - IMGUI Source Code: https://github.com/wyozi-gmod/imgui
--    - Draw Precache Arc
--    - Draw Line with thickness

local adraw = {}

adraw.skin = {
    background = Color(0, 0, 0, 0),
    backgroundHover = Color(0, 0, 0, 0),
    border = Color(255, 255, 255),
    borderHover = Color(255, 127, 0),
    borderPress = Color(255, 80, 0),
    foreground = Color(255, 255, 255),
    foregroundHover = Color(255, 127, 0),
    foregroundPress = Color(255, 80, 0),
}

local devCvar = GetConVar("developer")

function adraw.IsDeveloperMode()
    return not adraw.DisableDeveloperMode and devCvar:GetInt() > 0
end

local _devMode = false -- cached local variable updated once in a while

function adraw.Hook(name, id, callback)
    local hookUniqifier = debug.getinfo(4).short_src
    hook.Add(name, "adraw / " .. id .. " / " .. hookUniqifier, callback)
end

local local_player
local gState = {}

local function shouldAcceptInput()
    -- don't process input during non-main renderpass
    if render.GetRenderTarget() ~= nil then return false end
    -- don't process input if we're doing VGUI stuff (and not in context menu)
    if vgui.CursorVisible() and vgui.GetHoveredPanel() ~= g_ContextMenu then return false end

    return true
end

adraw.Hook("PreRender", "adraw / Input", function()
    -- calculate mouse state
    if shouldAcceptInput() then
        local useBind = input.LookupBinding("+use", true)
        local attackBind = input.LookupBinding("+attack", true)
        local USE = useBind and input.GetKeyCode(useBind)
        local ATTACK = attackBind and input.GetKeyCode(attackBind)
        local wasPressing = gState.pressing
        gState.pressing = (USE and input.IsButtonDown(USE)) or (ATTACK and input.IsButtonDown(ATTACK))
        gState.pressed = not wasPressing and gState.pressing
    end
end)

hook.Add("NotifyShouldTransmit", "adraw / ClearRenderBounds", function(ent, shouldTransmit)
    if not shouldTransmit then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    tb._adrawRBExpansion = nil
end)

local traceResultTable = {}

local traceQueryTable = {
    output = traceResultTable,
    filter = {}
}

local function isObstructed(eyePos, hitPos, ignoredEntity)
    local q = traceQueryTable
    q.start = eyePos
    q.endpos = hitPos
    q.filter[1] = local_player
    q.filter[2] = ignoredEntity
    local tr = util.TraceLine(q)

    if tr.Hit then
        return true, tr.Entity
    else
        return false
    end
end

function adraw.Start3D2D(pos, angles, scale, distanceHide, distanceFadeStart)
    local_player = local_player or LocalPlayer()

    if gState.shutdown == true then return end

    if gState.rendering == true then
        print("[AdvancedDraw] Starting a new adraw context when previous one is still rendering" .. "Shutting down rendering pipeline to prevent crashes..")
        gState.shutdown = true

        return false
    end

    _devMode = adraw.IsDeveloperMode()
    local eyePos = local_player:EyePos()
    local eyePosToPos = pos - eyePos

    -- OPTIMIZATION: Test that we are in front of the UI
    do
        local normal = angles:Up()
        local dot = eyePosToPos:Dot(normal)

        if _devMode then
            gState._devDot = dot
        end

        -- since normal is pointing away from surface towards viewer, dot<0 is visible
        if dot >= 0 then return false end
    end

    -- OPTIMIZATION: Distance based fade/hide
    if distanceHide then
        local distance = eyePosToPos:Length()
        if distance > distanceHide then return false end

        if _devMode then
            gState._devDist = distance
            gState._devHideDist = distanceHide
        end

        if distanceHide and distanceFadeStart and distance > distanceFadeStart then
            local blend = math.min(math.Remap(distance, distanceFadeStart, distanceHide, 1, 0), 1)
            render.SetBlend(blend)
            surface.SetAlphaMultiplier(blend)
        end
    end

    gState.rendering = true
    gState.pos = pos
    gState.angles = angles
    gState.scale = scale
    cam.Start3D2D(pos, angles, scale)

    -- calculate mousepos
    if not vgui.CursorVisible() or vgui.IsHoveringWorld() then
        local tr = local_player:GetEyeTrace()
        local eyepos = tr.StartPos
        local eyenormal

        if vgui.CursorVisible() and vgui.IsHoveringWorld() then
            eyenormal = gui.ScreenToVector(gui.MousePos())
        else
            eyenormal = tr.Normal
        end

        local planeNormal = angles:Up()
        local hitPos = util.IntersectRayWithPlane(eyepos, eyenormal, pos, planeNormal)

        if hitPos then
            local obstructed, obstructer = isObstructed(eyepos, hitPos, gState.entity)

            if obstructed then
                gState.mx = nil
                gState.my = nil

                if _devMode then
                    gState._devInputBlocker = "collision " .. obstructer:GetClass() .. "/" .. obstructer:EntIndex()
                end
            else
                local diff = pos - hitPos
                -- This cool code is from Willox's keypad CalculateCursorPos
                local x = diff:Dot(-angles:Forward()) / scale
                local y = diff:Dot(-angles:Right()) / scale
                gState.mx = x
                gState.my = y
            end
        else
            gState.mx = nil
            gState.my = nil

            if _devMode then
                gState._devInputBlocker = "not looking at plane"
            end
        end
    else
        gState.mx = nil
        gState.my = nil

        if _devMode then
            gState._devInputBlocker = "not hovering world"
        end
    end

    if _devMode then
        gState._renderStarted = SysTime()
    end

    return true
end

function adraw.Entity3D2D(ent, lpos, lang, scale, ...)
    gState.entity = ent
    local ret = adraw.Start3D2D(ent:LocalToWorld(lpos), ent:LocalToWorldAngles(lang), scale, ...)

    if not ret then
        gState.entity = nil
    end

    return ret
end

local function calculateRenderBounds(x, y, w, h)
    local pos = gState.pos
    local fwd, right = gState.angles:Forward(), gState.angles:Right()
    local scale = gState.scale
    local firstCorner, secondCorner = pos + fwd * x * scale + right * y * scale, pos + fwd * (x + w) * scale + right * (y + h) * scale
    local minrb, maxrb = Vector(math.huge, math.huge, math.huge), Vector(-math.huge, -math.huge, -math.huge)
    minrb.x = math.min(minrb.x, firstCorner.x, secondCorner.x)
    minrb.y = math.min(minrb.y, firstCorner.y, secondCorner.y)
    minrb.z = math.min(minrb.z, firstCorner.z, secondCorner.z)
    maxrb.x = math.max(maxrb.x, firstCorner.x, secondCorner.x)
    maxrb.y = math.max(maxrb.y, firstCorner.y, secondCorner.y)
    maxrb.z = math.max(maxrb.z, firstCorner.z, secondCorner.z)

    return minrb, maxrb
end

function adraw.ExpandRenderBoundsFromRect(x, y, w, h)
    local ent = gState.entity

    if IsValid(ent) then
        local tb = ent:GetTable()
        -- make sure we're not applying same expansion twice
        local expansion = tb._adrawRBExpansion

        if expansion then
            local ex, ey, ew, eh = unpack(expansion)
            if ex == x and ey == y and ew == w and eh == h then return end
        end

        local minrb, maxrb = calculateRenderBounds(x, y, w, h)
        ent:SetRenderBoundsWS(minrb, maxrb)

        if _devMode then
            print("[adraw] Updated renderbounds of ", ent, " to ", minrb, "x", maxrb)
        end

        tb._adrawRBExpansion = {x, y, w, h}
    else
        if _devMode then
            print("[adraw] Attempted to update renderbounds when entity is not valid!! ", debug.traceback())
        end
    end
end

local devOffset = Vector(0, 0, 30)

local devColours = {
    background = Color(0, 0, 0, 200),
    title = Color(78, 205, 196),
    mouseHovered = Color(0, 255, 0),
    mouseUnhovered = Color(255, 0, 0),
    pos = Color(255, 255, 255),
    distance = Color(200, 200, 200, 200),
    ang = Color(255, 255, 255),
    dot = Color(200, 200, 200, 200),
    angleToEye = Color(200, 200, 200, 200),
    renderTime = Color(255, 255, 255),
    renderBounds = Color(0, 0, 255)
}

local function developerText(str, x, y, clr)
    draw.SimpleText(str, "DefaultFixedDropShadow", x, y, clr, TEXT_ALIGN_CENTER, nil)
end

local function drawDeveloperInfo()
    local camAng = local_player:EyeAngles()
    camAng:RotateAroundAxis(camAng:Right(), 90)
    camAng:RotateAroundAxis(camAng:Up(), -90)
    cam.IgnoreZ(true)
    cam.Start3D2D(gState.pos + devOffset, camAng, 0.15)
        local bgCol = devColours["background"]
        surface.SetDrawColor(bgCol.r, bgCol.g, bgCol.b, bgCol.a)
        surface.DrawRect(-100, 0, 200, 140)
        local titleCol = devColours["title"]
        developerText("adraw developer", 0, 5, titleCol)
        surface.SetDrawColor(titleCol.r, titleCol.g, titleCol.b)
        surface.DrawLine(-50, 16, 50, 16)
        local mx, my = gState.mx, gState.my
    
        if mx and my then
            developerText(string.format("mouse: hovering %d x %d", mx, my), 0, 20, devColours["mouseHovered"])
        else
            developerText(string.format("mouse: %s", gState._devInputBlocker or ""), 0, 20, devColours["mouseUnhovered"])
        end
    
        local pos = gState.pos
        developerText(string.format("pos: %.2f %.2f %.2f", pos.x, pos.y, pos.z), 0, 40, devColours["pos"])
        developerText(string.format("distance %.2f / %.2f", gState._devDist or 0, gState._devHideDist or 0), 0, 53, devColours["distance"])
        local ang = gState.angles
        developerText(string.format("ang: %.2f %.2f %.2f", ang.p, ang.y, ang.r), 0, 75, devColours["ang"])
        developerText(string.format("dot %d", gState._devDot or 0), 0, 88, devColours["dot"])
        local angToEye = (pos - local_player:EyePos()):Angle()
        angToEye:RotateAroundAxis(ang:Up(), -90)
        angToEye:RotateAroundAxis(ang:Right(), 90)
        developerText(string.format("angle to eye (%d,%d,%d)", angToEye.p, angToEye.y, angToEye.r), 0, 100, devColours["angleToEye"])
        developerText(string.format("rendertime avg: %.2fms", (gState._devBenchAveraged or 0) * 1000), 0, 120, devColours["renderTime"])
    cam.End3D2D()
    cam.IgnoreZ(false)
    local ent = gState.entity

    if not IsValid(ent) then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    local ex, ey, ew, eh = unpack(tb._adrawRBExpansion)
    local minrb, maxrb = calculateRenderBounds(ex, ey, ew, eh)
    render.DrawWireframeBox(vector_origin, angle_zero, minrb, maxrb, devColours["renderBounds"])
end

function adraw.End3D2D()
    if gState then
        if _devMode then
            local renderTook = SysTime() - gState._renderStarted
            gState._devBenchTests = (gState._devBenchTests or 0) + 1
            gState._devBenchTaken = (gState._devBenchTaken or 0) + renderTook

            if gState._devBenchTests == 100 then
                gState._devBenchAveraged = gState._devBenchTaken / 100
                gState._devBenchTests = 0
                gState._devBenchTaken = 0
            end
        end

        gState.rendering = false
        cam.End3D2D()
        render.SetBlend(1)
        surface.SetAlphaMultiplier(1)

        if _devMode then
            drawDeveloperInfo()
        end

        gState.entity = nil
    end
end

function adraw.CursorPos()
    local mx, my = gState.mx, gState.my

    return mx, my
end

function adraw.IsHovering(x, y, w, h)
    local mx, my = gState.mx, gState.my

    return mx and my and mx >= x and mx <= (x + w) and my >= y and my <= (y + h)
end

function adraw.IsPressing()
    return shouldAcceptInput() and gState.pressing
end

function adraw.IsPressed()
    return shouldAcceptInput() and gState.pressed
end

local _createdFonts = {}
local _adrawFontToGmodFont = {}
local EXCLAMATION_BYTE = string.byte("!")

function adraw.xFont(font, defaultSize)
    -- special font
    if string.byte(font, 1) == EXCLAMATION_BYTE then
        local existingGFont = _adrawFontToGmodFont[font]
        if existingGFont then return existingGFont end
        -- Font not cached; parse the font
        local name, size = font:match("!([^@]+)@(.+)")

        if size then
            size = tonumber(size)
        end

        if not size and defaultSize then
            name = font:match("^!([^@]+)$")
            size = defaultSize
        end

        local fontName = string.format("adraw_%s_%d", name, size)
        _adrawFontToGmodFont[font] = fontName

        if not _createdFonts[fontName] then
            surface.CreateFont(fontName, {
                font = name,
                size = size
            })

            _createdFonts[fontName] = true
        end

        return fontName
    end

    return font
end

function adraw.DrawBox(x,y,w,h,borderWidth, borderColor)
    if borderWidth > 0 then
        surface.SetDrawColor(borderColor)
        surface.DrawRect(x, y, w, borderWidth)
        surface.DrawRect(x, y + borderWidth, borderWidth, h - borderWidth * 2)
        surface.DrawRect(x, y + h - borderWidth, w, borderWidth)
        surface.DrawRect(x + w - borderWidth + 1, y, borderWidth, h)
    end
end

function adraw.xButton(x, y, w, h, borderWidth, borderClr, hoverClr, pressColor)
    local bw = borderWidth or 1
    local bgColor = adraw.IsHovering(x, y, w, h) and adraw.skin.backgroundHover or adraw.skin.background
    local borderColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.borderPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.borderHover)) or (borderClr or adraw.skin.border)
    surface.SetDrawColor(bgColor)
    surface.DrawRect(x, y, w, h)

    adraw.DrawBox(x,y,w,h,bw,borderColor)

    local isHovering = adraw.IsHovering(x, y, w, h)
    return shouldAcceptInput() and isHovering and gState.pressed, isHovering
end

function adraw.xOneColorButton(x, y, w, h, borderWidth, clr)
    local bw = borderWidth or 1
    surface.SetDrawColor(clr)
    surface.DrawRect(x, y, w, h)

    if bw > 0 then
        surface.SetDrawColor(clr)
        surface.DrawRect(x, y, w, bw)
        surface.DrawRect(x, y + bw, bw, h - bw * 2)
        surface.DrawRect(x, y + h - bw, w, bw)
        surface.DrawRect(x + w - bw + 1, y, bw, h)
    end

    return shouldAcceptInput() and adraw.IsHovering(x, y, w, h) and gState.pressed
end

function adraw.xCursor(x, y, w, h)
    local fgColor = adraw.IsPressing() and adraw.skin.foregroundPress or adraw.skin.foreground
    local mx, my = gState.mx, gState.my
    if not mx or not my then return end
    if x and w and (mx < x or mx > x + w) then return end
    if y and h and (my < y or my > y + h) then return end
    local cursorSize = math.ceil(0.3 / gState.scale)
    surface.SetDrawColor(fgColor)
    surface.DrawLine(mx - cursorSize, my, mx + cursorSize, my)
    surface.DrawLine(mx, my - cursorSize, mx, my + cursorSize)
end

function adraw.xTextButton(text, font, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    font = adraw.xFont(font, math.floor(h * 0.618))
    draw.SimpleText(text, font, x + w / 2, y + h / 2, fgColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

    return clicked
end

function adraw.xConButton(x, y, w, h, borderWidth, color, hoverClr, pressColor, conColor, condition)
    local fgColor
    local clicked
    if condition then
        fgColor = conColor
        clicked = adraw.xOneColorButton(x, y, w, h, borderWidth, conColor)
    else
        fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
        clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    end

    return clicked
end

function adraw.xSymbolButton(symbol, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    surface.SetMaterial(symbol)
    surface.SetDrawColor(fgColor)
    surface.DrawTexturedRect(x, y, w, h)

    return clicked
end

function adraw.xDrawLine(x, y, x2, y2, sz)
    local midX = (x + x2) / 2
    local midY = (y + y2) / 2

    local dx = x2 - x
    local dy = y2 - y
    local ang = -math.deg(math.atan2(dy, dx))

    local len = math.sqrt((x2 - x) ^ 2 + (y2 - y) ^ 2)
    draw.NoTexture()
    surface.DrawTexturedRectRotated(midX, midY, len, sz, ang)
end

local cached = {}

function adraw.Arc(cx, cy, radius, thickness, startang, endang, roughness, color)
    local arc = tostring(cx) .. tostring(cy) .. tostring(radius) .. tostring(thickness) .. tostring(startang) .. tostring(endang) .. tostring(roughness)
    surface.SetDrawColor(color)
    draw.NoTexture()

    if (cached[arc] == nil) then
        cached[arc] = adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    end

    adraw.DrawArc(cached[arc])
end

function adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    local triarc = {}
    local roughness = math.max(roughness or 1, 1)
    local step = roughness
    local startang, endang = startang or 0, endang or 0

    if startang > endang then
        step = math.abs(step) * -1
    end

    local inner = {}
    local r = radius - thickness

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * r), cy + (-math.sin(rad) * r)

        table.insert(inner, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    local outer = {}

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * radius), cy + (-math.sin(rad) * radius)

        table.insert(outer, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    for tri = 1, #inner * 2 do
        local p1, p2, p3
        p1 = outer[math.floor(tri / 2) + 1]
        p3 = inner[math.floor((tri + 1) / 2) + 1]

        if tri % 2 == 0 then
            p2 = outer[math.floor((tri + 1) / 2)]
        else
            p2 = inner[math.floor((tri + 1) / 2)]
        end

        table.insert(triarc, {p1, p2, p3})
    end

    return triarc
end

function adraw.DrawArc(arc)
    for _, v in ipairs(arc) do
        surface.DrawPoly(v)
    end
end

function adraw.DrawTexturedRectRotatedPoint( x, y, w, h, rot, x0, y0 )
    local c = math.cos( math.rad( rot ) )
    local s = math.sin( math.rad( rot ) )

    local newx = y0 * s - x0 * c
    local newy = y0 * c + x0 * s

    surface.DrawTexturedRectRotated( x + newx, y + newy, w, h, rot )
end

local matBlurScreen = Material("pp/blurscreen")
function adraw.Derma_DrawPanelBlur(panel, color)
    color = color or Color(10,10,10,100)
    local x, y = panel:LocalToScreen( 0, 0 )

    -- Menu cannot do blur
    if ( not MENU_DLL ) then
        surface.SetMaterial( matBlurScreen )
        surface.SetDrawColor( 255, 255, 255, 255 )

        for i = 0.33, 1, 0.33 do
            matBlurScreen:SetFloat( "$blur", 5 * i )
            matBlurScreen:Recompute()
            if ( render ) then
                render.UpdateScreenEffectTexture()
            end
            surface.DrawTexturedRect( x * -1, y * -1, ScrW(), ScrH() )
        end
    end

    surface.SetDrawColor(color)
    surface.DrawRect( x * -1, y * -1, ScrW(), ScrH() )
end

return adraw

--addons/starwars_universe/lua/star-wars-universe/client/cl_swu_render.lua:
function SWU:SetupRenderers()
    self:SetupSkyboxRotation()
end

function SWU:SetupSkyboxRotation()
    hook.Add("PreDrawSkyBox", "SWU_RotateSkybox", function ()
        if (IsValid(self.Controller)) then
            local matrix = Matrix()
            matrix:Rotate(Angle(0, self.Controller:GetInternalShipAngles().y, 0))

            cam.PushModelMatrix(matrix)
        end
    end)

    hook.Add("PostDrawSkyBox", "SWU_ResetSkyboxRotation", function ()
        if (IsValid(self.Controller)) then
            cam.PopModelMatrix()
        end
    end)
end

--addons/starwars_universe/lua/star-wars-universe/client/vgui/cl_swu_multiselector.lua:
local PANEL = {}

surface.CreateFont("SwuMultiSelectorText", {
    font = "Saira",
    size = 25,
    weight = 250,
    antialias = true,
    shadow = false
})

function PANEL:Init()
    self:SetPaintBackground(false)

    self:DockPadding(0,5,0,5)
end

function PANEL:SetOptions(options)
    self:Clear()

    local totalWidth = 0

    self.Buttons = {}
    for i, v in ipairs(options) do
        local btn = self:Add("swu_basepanel")
        btn:Dock(LEFT)
        btn:DockMargin(0,0,5,0)
        btn.IsActive = function (self) return self.Active end
        btn.SetActive = function (self, active)
            self.Active = active
            self:SetBackgroundColor(active and SWU.Colors.Default.accent or Color(10,10,10,200))
        end
        btn.PaintOver = function (self, w, h)
            local color = self:IsHovered() and SWU.Colors.Default.primary or Color(255,255,255)

            if (self:IsActive()) then
                color = SWU.Colors.Default.black
            end

            draw.SimpleText(v.text, "SwuMultiSelectorText", w * 0.5, h * 0.5, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
        btn.OnMouseReleased = function (_, keyCode)
            if (keyCode ~= MOUSE_LEFT) then return end

            self:SetValue(v.value)
        end
        btn:SetCursor("hand")
        btn:SetSize(ScrW() * 0.025)
        btn:SetBackgroundColor(Color(10,10,10,200))
        totalWidth = totalWidth + btn:GetWide() + 5

        self.Buttons[tostring(v.value)] = btn
    end

    self:SetSize(totalWidth - 5, 0)
end

function PANEL:OnChange(newValue)
end

function PANEL:SetValue(value)
    for i, v in pairs(self.Buttons) do
        v:SetActive(i == tostring(value))
    end

    self.Value = value
    self:OnChange(value)
end

function PANEL:SetConVar(conVarName)
    if (not ConVarExists(conVarName)) then return end

    self.ConVar = conVarName

    self:SetValue(SWU.Configuration:GetConVar(self.ConVar):GetFloat())
end

vgui.Register("swu_multiselector", PANEL, "swu_basepanel")
--addons/starwars_universe/lua/star-wars-universe/client/vgui/cl_swu_planetsearch.lua:
local PANEL = {}

function PANEL:Init()
    self.Page = 1
    self.maxPages = 1

    self:SetBackgroundColor(Color(50,50,50,100))
    local padding = self:GetParent():GetWide() * 0.02
    self:DockPadding(padding, padding * 0.5, padding, padding * 0.5)

    self.searchField = self:Add("swu_inputfield")
    self.searchField:Dock(TOP)
    self.searchField:SetIconRight("the-coding-ducks/swu/icons/search-icon.png", nil, function ()
        self:Search()
    end, SWU.Colors.Default.primary, SWU.Colors.Default.accent)
    self.searchField:SetOnEnter(function () self:Search() end)
    self.searchField:SetSize(0, self:GetParent():GetTall() * 0.1)

    self.planetList = self:Add("swu_basepanel")
    self.planetList:Dock(FILL)
    self.planetList:SetPaintBackground(false)
    self.planetList:DockMargin(0,padding * 0.5,0,padding * 0.5)

    self.pageBar = self:Add("swu_basepanel")
    self.pageBar:SetPaintBackground(false)
    self.pageBar:Dock(BOTTOM)

    local left = self.pageBar:Add("swu_button")
    left:Dock(LEFT)
    left:SetText("<")
    left:SetCentered(true)
    left.OnClick = function ()
        if (self.Page <= 1) then return end

        self:GetPlanetPage(self.Page - 1, self.searchField:GetValue())
    end

    self.pageDisplay = self.pageBar:Add("DLabel")
    self.pageDisplay:SetFont("SwuRowText")
    self.pageDisplay:SetText("Page 0 of 0")
    self.pageDisplay:SetContentAlignment(5)
    self.pageDisplay:Dock(FILL)
    self.pageDisplay:SetColor(Color(255,255,255))

    local right = self.pageBar:Add("swu_button")
    right:Dock(RIGHT)
    right:SetText(">")
    right:SetCentered(true)
    right.OnClick = function ()
        if (self.Page >= self.maxPages) then return end

        self:GetPlanetPage(self.Page + 1, self.searchField:GetValue())
    end

    net.Receive("swu_search_getPlanetPage", function ()
        local planets = net.ReadTable()
        self.maxPages = net.ReadInt(11)
        self:SetPlanets(planets)
        self.pageDisplay:SetText("Page " .. self.Page .. " of " .. self.maxPages)
    end)

    self:GetPlanetPage(1)
end

function PANEL:GetPlanetPage(page, filter)
    self.Page = page

    if (filter == "") then
        filter = nil
    end

    net.Start("swu_search_getPlanetPage")
    net.WriteInt(page, 11)
    net.WriteInt(10, 6)
    if (filter) then
        net.WriteString(filter)
    end
    net.SendToServer()
end

function PANEL:SetPlanets(planets)
    self.planetList:Clear()

    for i, v in ipairs(planets) do
        local button = self.planetList:Add("swu_button")
        button.Planet = v
        button:SetText(v.name)
        button:Dock(TOP)
        button:SetSize(0, self:GetParent():GetTall() / 12)
        function button:OnClick()
            self:GetParent():GetParent():GetParent().info:LoadPlanet(self.Planet)
        end
    end
end

function PANEL:Search()
    self:GetPlanetPage(1, self.searchField:GetValue())
end

vgui.Register("swu_planetsearch_panel", PANEL, "swu_basepanel")

--addons/starwars_universe/lua/star-wars-universe/client/vgui/tabs/cl_swu_position.lua:
local PANEL = {}

function PANEL:Init()
    self:SetPaintBackground(false)
    self:DockMargin(0,0,0,0)
    self:DockPadding(0,0,0,0)

    self.search = self:Add("swu_planetsearch_panel")
    self.search:Dock(LEFT)
    self.search:SetSize(self:GetWide() * 0.65 - self:GetParent():GetParent().PanelDist, 0)

    self.info = self:Add("swu_planetinfo_panel")
    self.info:Dock(RIGHT)
    self.info:SetSize(self:GetWide() * 0.35, 0)
end

vgui.Register("swu_position", PANEL, "swu_basetab")

--addons/starwars_universe/lua/star-wars-universe/shared/sh_swu_configurations.lua:
SWU.Configuration = SWU.Configuration or {}

SWU.Configuration.ConVars = {
    ["swu_enable_planet_collision"] = CreateConVar("swu_enable_planet_collision", 1, FCVAR_ARCHIVE, "Enables or disables that a planet can get destroyed by flying into it", 0, 1),
    ["swu_hyperspace_speed_modifier"] = CreateConVar("swu_hyperspace_speed_modifier", 1, FCVAR_ARCHIVE, "The number the hyperspace speed should be multiplied with", 0, 10),
    ["swu_enable_deathstar"] = CreateConVar("swu_enable_deathstar", 0, FCVAR_ARCHIVE, "Should there be the death star in the galaxy", 0, 1),
    ["swu_enable_changelog"] = CreateClientConVar("swu_enable_changelog", 1, true, false, "Should the changelog be shown to you", 0, 1),
    ["swu_enable_interaction"] = CreateClientConVar("swu_enable_interaction", 1, true, false, "Should keyboard interaction with console be activated", 0, 1),
    ["swu_external_hyperspace_speed_modifier"] = CreateConVar("swu_external_hyperspace_speed_modifier", 1, FCVAR_ARCHIVE, "The number the hyperspace speed should be multiplied with, used by external addons", 0, 10),
}

if (CLIENT) then
    SWU.Configuration.Tabs = {}

    function SWU.Configuration:RegisterTab(priority, tab)
        if (not isnumber(priority)) then return end
        self.Tabs[priority] = tab
    end

    function SWU.Configuration:GetTabs()
        local tabs = {}

        for i, v in pairs(self.Tabs) do
            if (not isfunction(v.shouldShow) or v.shouldShow()) then
                table.insert(tabs, v)
            end
        end

        return tabs
    end

    function SWU.Configuration:Open()
        if (IsValid(self.Frame)) then
            self.Frame:Remove()
        end

        self.Frame = vgui.Create("swu_configruationframe")
    end

    concommand.Add("swu_open_configuration", function ()
        SWU.Configuration:Open()
    end)

    list.Set("DesktopWindows", "SwuConfigurations", {
        title = "[SWU] Config",
        icon = "the-coding-ducks/swu/icons/swu-icon.png",
        init = function(icon, window)
            SWU.Configuration:Open()
        end
    })

    SWU.Configuration:RegisterTab(1, {
        title = "Server Config",
        shouldShow = function ()
            return LocalPlayer():IsSuperAdmin()
        end,
        open = function (content)
            content:Add("swu_serverconfig")
        end
    })

    SWU.Configuration:RegisterTab(2, {
        title = "Ship Position",
        shouldShow = function ()
            return LocalPlayer():IsAdmin() or LocalPlayer():IsSuperAdmin()
        end,
        open = function (content)
            content:Add("swu_position")
        end
    })

    SWU.Configuration:RegisterTab(3, {
        title = "Client Config",
        open = function (content)
            content:Add("swu_clientconfig")
        end
    })

    SWU.Configuration:RegisterTab(100, {
        title = "Credits",
        open = function (content)
            content:Add("swu_credits")
        end
    })
else
    util.AddNetworkString("swu_modify_server_settings")

    net.Receive("swu_modify_server_settings", function (len, ply)
        if (not ply:IsSuperAdmin()) then return end

        local conVarName = net.ReadString()
        local value = net.ReadString()

        local conVar = SWU.Configuration:GetConVar(conVarName)
        if (not conVar) then return end

        local oldValue = conVar:GetString()
        conVar:SetString(value)

        hook.Run("SWU_OnConfigurationChange", conVarName, oldValue, value)
    end)
end

function SWU.Configuration:GetConVar(cvar)
    return SWU.Configuration.ConVars[cvar] or false
end

--addons/starwars_universe/lua/star-wars-universe/shared/sh_swu_initializer.lua:
SWU = SWU or {}
SWU.Terminals = SWU.Terminals or {}

SWU.Version = 2.2
SWU.Changelog = {
    title = "Version 2.2",
    changes = {
        {
            type = "+",
            text = "Direct Keyboard Input for Controllers"
        },
        {
            type = "+",
            text = "Keypad Input for Rotation Controller"
        },
        {
            type = "+",
            text = "Arrow Input for Speed Controller"
        },
        {
            type = "+",
            text = "Arrow Input for Navigation Computer"
        },
        {
            type = "#",
            text = "New Console Instructions on Workshop page"
        },
        {
            type = "#",
            text = "Minor UX adjustments"
        },
    }
}
SWU.Hyperspace = {
    OUT = 1,
    TRANSITIONING = 2,
    IN = 3,
}

SWU.GlobalConfig = {
    chunkSize = 25,
    chunkRange = 1,
    maxAcceleration = Vector(0.03,0.03,0.03),
    baseHyperspaceAcceleration = Vector(2,2,2),
    hyperspaceAcceleration = Vector(2,2,2)
}

local ISD_TeleporterConfiguration = {
    {
        -- Forward facing teleporter
        min = Vector(15744, 15744, 9792),
        max = Vector(15744 - 500, -15692, -15616),
        tDir = 0,
    },
    {
        -- Backwards facing teleporter
        min = Vector(-15744, 15744, 9792),
        max = Vector(-15744 + 500, -15692, -15616),
        tDir = 180,
    },
    {
        -- Right facing teleporter
        min = Vector(15744, -15692, 9792),
        max = Vector(-15744, -15692 + 500, -15616),
        tDir = 90,
    },
    {
        -- Left facing teleporter
        min = Vector(15744, 15692, 9792),
        max = Vector(-15744, 15692 - 500, -15616),
        tDir = 270,
    }
}

local ISD_Desert = {
    pos = Vector(-5344, 5880, 14124),
    angle = Angle()
}
local ISD_Snow = {
    pos = Vector(-5031, 12830, 14124),
    angle = Angle()
}
local ISD_SpaceStation = {
    pos = Vector(-14800, 3295, 13960),
    angle = Angle()
}
local ISD_DeathStar = {
    pos = Vector(-15003, 10611, 14156),
    angle = Angle()
}
local ISD_TeleportLocationConfiguration = {
    ["the-coding-ducks/swu/planets/city/"] = ISD_Desert,
    ["the-coding-ducks/swu/planets/clouds/"] = ISD_Snow,
    ["the-coding-ducks/swu/planets/desert/"] = ISD_Desert,
    ["the-coding-ducks/swu/planets/forest/"] = ISD_Desert,
    ["the-coding-ducks/swu/planets/fungal/"] = ISD_Snow,
    ["the-coding-ducks/swu/planets/gas/"] = ISD_Snow,
    ["the-coding-ducks/swu/planets/ice/"] = ISD_Snow,
    ["the-coding-ducks/swu/planets/magma/"] = ISD_Desert,
    ["the-coding-ducks/swu/planets/moon/"] = ISD_Desert,
    ["the-coding-ducks/swu/planets/water/"] = ISD_Snow,
    ["deathstar"] = ISD_DeathStar,
    ["spacestation"] = ISD_SpaceStation,
}

local LordTrilobites_ISD = {
    skyboxReference = Vector(1833, -6591, 13789),
    controllerPos = Vector(1833, -6591, 13789),
    disableFog = true,
    disableSun = true,
    scale = 500,
    collisionRange = 115,
    hyperspace = {
        tunnel = "models/kingpommes/venator/hypertunnel.mdl",
        stars = "models/kingpommes/venator/lightspeed_stars.mdl"
    },
    skyboxBoundaries = {
        min = Vector(),
        max = Vector(),
        center = Vector()
    },
    controls = {
        {
            ent = "swu_navigation_computer",
            pos = Vector(-8612, -391, 720),
            ang = Angle(0, -90, 0)
        },
        {
            ent = "swu_rotation_controller",
            pos = Vector(-8106, 187, 640),
            ang = Angle(0, -90, 0)
        },
        {
            ent = "swu_speed_controller",
            pos = Vector(-8106, -187, 640),
            ang = Angle(0, 90, 0)
        },
        {
            ent = "swu_map",
            pos = Vector(-9057.2, -374, 808),
            ang = Angle(90, 0, 0),
            scale = 0.8
        }
    },
    teleports = ISD_TeleporterConfiguration,
    teleportLocations = ISD_TeleportLocationConfiguration,
    blockPos = {
        Vector(-8751, -386, 737),
        Vector(-8739, -356, 782)
    }
}

SWU.MapConfig = {
    ["rp_venator_extensive_v1_4"] = {
        skyboxReference = Vector(0, 0, 15500),
        controllerPos = Vector(-48, -0, 15500),
        disableFog = true,
        disableSun = true,
        shipOffsetRotation = Angle(0,90,0),
        scale = 500,
        collisionRange = 101,
        hyperspace = {
            tunnel = "models/kingpommes/starwars/venator/hypertunnel.mdl",
            stars = "models/kingpommes/starwars/venator/lightspeed_stars.mdl"
        },
        skyboxBoundaries = {
            min = Vector(),
            max = Vector(),
            center = Vector()
        },
        controls = {
            {
                ent = "swu_navigation_computer",
                pos = Vector(-7272, -4552, 1088),
                ang = Angle()
            },
            {
                ent = "swu_rotation_controller",
                pos = Vector(-7176, -3725, 1016),
                ang = Angle(0, -20, 0)
            },
            {
                ent = "swu_speed_controller",
                pos = Vector(-6711, -3725, 1016),
                ang = Angle(0, -160, 0)
            },
            {
                ent = "swu_map",
                pos = Vector(-7120, -4552, 1160),
                ang = Angle(90, 0, 0),
                scale = 1
            }
        },
        blockPos = {
            Vector(-5565, -4544, 1113),
            Vector(-5315, -3456, 1099)
        }
    },
    ["rp_stardestroyer_v2_7"] = LordTrilobites_ISD,
    ["rp_stardestroyer_v2_7_inf"] = LordTrilobites_ISD
}

SWU.config = SWU.config or SWU.MapConfig[game.GetMap()] or {
    skyboxBoundaries = {
        min = Vector(),
        max = Vector(),
        center = Vector()
    },
    skyboxReference = Vector(),
    controllerPos = Vector(),
    disableFog = true,
    disableSun = true,
    shipOffsetRotation = Angle(),
    scale = 1,
    collisionRange = 1,
    hyperspace = {},
    controls = {},
    blockPos = {}
}

SWU.Colors = {}

SWU.Colors.Default = {
    primary = Color(252, 206, 109),
    passive = Color(255, 255, 255),
    accent = Color(255, 153, 0),
    con = Color(124, 124, 124),
    dark = Color(26, 26, 26),
    black = Color(0, 0, 0),
    none = Color(0, 0, 0, 0),
    error = Color(255, 62, 36),
}

if (SERVER) then
    AddCSLuaFile("libs/advanceddraw.lua")
    AddCSLuaFile("libs/netdata.lua")
    include("libs/netdata.lua")
end

if (CLIENT) then
    SWU.Map = SWU.Map or {}
    SWU.Fonts = SWU.Fonts or {}

    SWU.Fonts.TechAurabeshSpeed = "SwuSpeedFont"
    SWU.Fonts.AurabeshRotation = "SwuRotationFont"
    SWU.Fonts.PlainRotation = "SwuRotationText"
    SWU.Fonts.AurabeshNavComputer = "SwuNavigationFont"
    SWU.Fonts.PlainText = "SwuBaseText"
    SWU.Fonts.PlainMapPlanet = "SwuMapPlanetText"
    SWU.Fonts.AurabeshNavComputer2 = "SwuNavFont" -- TODO: Configure to use only one Aurabesh Nav Computer font
    SWU.Fonts.PlainNavComputer = "SwuNavText"

    surface.CreateFont(SWU.Fonts.TechAurabeshSpeed, {
        font = "Aurebesh AF",
        size = 120,
        weight = 200,
        antialias = true,
        shadow = false
    })
    surface.CreateFont(SWU.Fonts.AurabeshRotation, {
        font = "Aurebesh",
        size = 60,
        weight = 200,
        antialias = true,
        shadow = false
    })
    surface.CreateFont(SWU.Fonts.PlainRotation, {
        font = "Saira",
        size = 84,
        weight = 200,
        antialias = true,
        shadow = false
    })
    surface.CreateFont(SWU.Fonts.AurabeshNavComputer, {
        font = "Aurebesh",
        size = 100,
        weight = 200,
        antialias = true,
        shadow = false
    })
    surface.CreateFont(SWU.Fonts.PlainText, {
        font = "Saira",
        size = 168,
        weight = 200,
        antialias = true,
        shadow = false
    })
    surface.CreateFont(SWU.Fonts.PlainMapPlanet, {
        font = "Saira",
        size = 224,
        weight = 800,
        antialias = true,
        shadow = false
    })
    surface.CreateFont(SWU.Fonts.AurabeshNavComputer2, {
        font = "Aurebesh",
        size = 170,
        weight = 200,
        antialias = true,
        shadow = false
    })
    surface.CreateFont(SWU.Fonts.PlainNavComputer, {
        font = "Saira",
        size = 238,
        weight = 200,
        antialias = true,
        shadow = false
    })
    include("libs/netdata.lua")
end

hook.Add("SWU_LoadCustomMapConfig", "SWU_AddOptionalDeathStarToMap", function ()
    if (CLIENT or not SWU.Configuration:GetConVar("swu_enable_deathstar"):GetBool()) then return end

    local deathStarPos = Vector(646.96, -678.297, 0)
    local deathStarChunk = SWU.Util:VectorToChunk(deathStarPos)

    SWU.Universe[deathStarChunk] = SWU.Universe[deathStarChunk] or {}

    table.insert(SWU.Universe[deathStarChunk], {
        id = "6465617",
        name = "Death Star",
        pos = deathStarPos,
        terrain = "deathstar",
        type = "model_object",
        baseScale = 0.08,
        model = "models/lordtrilobite/starwars/props/deathstar128.mdl"
    })
end)

hook.Add("SWU_LoadCustomMapConfig", "SWU_AddISDSpaceStation", function (mapName)
    if (CLIENT or (mapName ~= "rp_stardestroyer_v2_7" and mapName ~= "rp_stardestroyer_v2_7_inf")) then return end

    local destroyedISDPos = Vector(-784.41, 674.58, 0)
    local destroyedISDChunk = SWU.Util:VectorToChunk(destroyedISDPos)

    SWU.Universe[destroyedISDChunk] = SWU.Universe[destroyedISDChunk] or {}

    table.insert(SWU.Universe[destroyedISDChunk], {
        id = "974548184557525",
        name = "Destroyed ISD",
        pos = destroyedISDPos,
        terrain = "destroyed_isd",
        type = "model_object",
        baseScale = 1,
        model = "models/lordtrilobite/starwars/isd/isd_wreck2_128.mdl"
    })
end)

function SWU:LoadMap(mapName)
    if (SERVER) then
        self:LoadUniverse()
    end
    self.ActiveChunks = {}
    hook.Run("SWU_LoadCustomMapConfig", mapName, self.MapConfig)
    local config = self.MapConfig[mapName]

    if (not istable(config)) then
        return
    end

    local hyperspaceSpeedModifier = (SWU.Configuration:GetConVar("swu_hyperspace_speed_modifier"):GetFloat() or 1)
    local externalHyperspaceSpeedModifier = (SWU.Configuration:GetConVar("swu_external_hyperspace_speed_modifier"):GetFloat() or 1)

    SWU.GlobalConfig.hyperspaceAcceleration = SWU.GlobalConfig.baseHyperspaceAcceleration * hyperspaceSpeedModifier * externalHyperspaceSpeedModifier
    for i, v in ipairs(self.Terminals) do
        if (IsValid(v)) then
            v:Remove()
        end
    end
    self.Terminals = {}

    local min, max, center = self.Util:MeasureSkybox(config.skyboxReference)
    config.skyboxBoundaries = {
        min = min,
        max = max,
        center = center
    }
    self.config = config

    if (config.disableFog) then
        self.Util:DisableFog()
    end

    if (config.disableSun) then
        self.Util:DisableSun()
    end

    if (SERVER) then
        self:InitializeController(config)
        self:SpawnControls()
        self:BlockMapHyperspace()
        self:ReadShipData()

        self:SpawnTeleports()
        self:IndexPlanets()
    end

    if (CLIENT) then
        self:SetupRenderers()
    end

    hook.Run("SWU.MapLoaded")
end

function SWU:InitializeController(config)
    SWU.Controller = ents.Create("swu_controller")
    SWU.Controller:Load(config)
    SWU.Controller:Spawn()
end

if (SERVER) then
    util.AddNetworkString("SWU_ChangeHyperspaceAcceleration")

    hook.Add("InitPostEntity", "SWU_InitializeStarWarsUniverse", function ()
        SWU:LoadMap(game.GetMap())
    end)

    hook.Add("SWU_OnConfigurationChange", "SWU_UpdateHyperspaceAcceleration", function (conVarName, oldValue, newValue)
        if (conVarName ~= "swu_hyperspace_speed_modifier") then return end

        local oldAcceleration = SWU.GlobalConfig.hyperspaceAcceleration
        SWU.GlobalConfig.hyperspaceAcceleration = SWU.GlobalConfig.hyperspaceAcceleration / oldValue * newValue

        net.Start("SWU_ChangeHyperspaceAcceleration")
        net.WriteVector(SWU.GlobalConfig.hyperspaceAcceleration)
        net.Broadcast()

        hook.Run("SWU_RecalculateFlightTime", oldAcceleration, SWU.GlobalConfig.hyperspaceAcceleration)
    end)
else
    net.Receive("SWU_ChangeHyperspaceAcceleration", function ()
        SWU.GlobalConfig.hyperspaceAcceleration = net.ReadVector()
    end)

    hook.Add("ClientSignOnStateChanged", "SWU_InitializeStarWarsUniverseClientSide", function (uid, oldState, newState)
        if (newState == SIGNONSTATE_FULL) then
            hook.Add("SetupMove", "SWU_CheckWhenPlayerIsHere", function (ply)
                hook.Remove("SetupMove", "SWU_CheckWhenPlayerIsHere")

                SWU:LoadMap(game.GetMap())
                net.Start("swu_sendInteractionConfiguration")
                net.WriteBool(SWU.Configuration:GetConVar("swu_enable_interaction"):GetBool())
                net.SendToServer()
            end)
        end
    end)
end

hook.Add("PostCleanupMap", "SWU_ReInitializeStarWarsUniverse", function ()
    SWU:LoadMap(game.GetMap())
end)

--lua/autorun/sh_vmenu_legs.lua:
--[[
	   ______                    __   __                   
	  / ____/___ ___  ____  ____/ /  / /   ___  ____ ______
	 / / __/ __ `__ \/ __ \/ __  /  / /   / _ \/ __ `/ ___/
	/ /_/ / / / / / / /_/ / /_/ /  / /___/  __/ /_/ (__  ) 
	\____/_/ /_/ /_/\____/\__,_/  /_____/\___/\__, /____/  
	                                         /____/        
	@Valkyrie, @blackops7799
]]--

if (SERVER) then
	AddCSLuaFile( "sh_vmenu_legs.lua" )
end

if (CLIENT) then
	local function AddText(font, color, text)		 
		local label = vgui.Create("DLabel", g_GMLOptions)
		label:Dock( TOP )	
		label:SetFont(font)
		label:SetText(text)
		label:SetTextColor(color)
		label:SizeToContents()

		return label
	end

	local function AddOptions( text, cvar )	 
		local option = vgui.Create("DCheckBoxLabel", g_GMLOptions)
		option:SetText(text)
		option:SetTextColor(Color(194,194,194))
		option:SetConVar( cvar )
		option:Dock( TOP )
		option:DockMargin(30, 0, 0, 0)
		option:SizeToContents()

		return label
	end

	local function AddHeader( text )
		AddText("VAddonsHeader", Color(194,194,194), text):DockMargin(12, 0, 0, 0)
	end

	hook.Add( "GetVMenuTabs", "GMLTabs", function(parent, tabs) 
		g_GMLOptions = vgui.Create( "DScrollPanel", parent )
		g_GMLOptions.Paint = function(this, w, h)
			draw.RoundedBox(0, 0, 0, w, h, Color( 30, 30, 30 ) )
		end

		AddHeader(string.format("\nWhats new in Gmod Legs %s?", g_LegsVer))
		AddText("VAddonsCredits", Color(194,194,194), g_LegsLog):DockMargin(30, 0, 0, 0)

		AddHeader("Settings")
		AddOptions( "Enable rendering of Legs?", "cl_legs" )
		AddOptions( "Enable rendering of Legs in vehicles?", "cl_vehlegs" )

		AddHeader("\nCredits")
		AddText("VAddonsCredits", Color(194,194,194), "Valkyrie\n\tblackops7799"):DockMargin(30, 0, 0, 0)
		
		tabs:AddSheet(string.format("Gmod Legs %s", g_LegsVer), g_GMLOptions, "icon16/user.png")
	end)
end
--lua/autorun/sh_zelevators.lua:
if (SERVER) then
	timer.Create("elevator_SaveData", 180, 0, function()
		file.CreateDir("elevators");

		local win, msg = pcall(SaveElevators);
		if (!win) then
			ErrorNoHalt("[ELEVATOR TOOL] Something happened while saving elevators!")
			print(msg);
		end;
	end);

	hook.Add("ShutDown", "zlevator_ShutDown", function()
		local win, msg = pcall(SaveElevators);
		if (!win) then
			ErrorNoHalt("[ELEVATOR TOOL] Something happened while saving elevators!")
			print(msg);
		end;
	end);

	hook.Add("InitPostEntity", "zelevator_SaveElevators", function()
		timer.Simple(5, function()
			local win, msg = pcall(LoadElevators);
			if (!win) then
				ErrorNoHalt("[ELEVATOR TOOL] Something happened while loading elevators!")
				print(msg);
			end;
		end);
	end);

	function SaveElevators()
		file.CreateDir("elevators");
		local buffer = {};

		for k, v in pairs(ents.FindByClass("func_movelinear")) do
			if (v:GetNWBool("saved", false) and v:GetName():find("zelevator")) then
				local props = v:GetChildren();
				local parts = {};
				local buttonList = {};

				for k, button in pairs(ents.FindByClass("elevator_button")) do
					if (button:GetElevator() == v) then
						table.insert(buttonList, {
							origin = button:GetPos(),
							angles = button:GetAngles(),
							bIsSender = button:GetSender(),
							material = button:GetMaterial(),
							model = button:GetModel(),
							color = button:GetColor()
						});
					end;
				end;

				for k, prop in pairs(props) do
					if (IsValid(prop) and prop:GetClass() != "prop_dynamic" and prop:GetClass() != "elevator" and prop != v) then
						table.insert(parts, {
							origin = v:WorldToLocal(prop:GetPos()),
							angles = v:WorldToLocalAngles(prop:GetAngles()),
							material = prop:GetMaterial(),
							model = prop:GetModel(),
							rendermode = prop:GetRenderMode(),
							color = prop:GetColor()
						});
					end;
				end;

				buffer[#buffer + 1] = {
					origin = v:GetPos(),
					angles = v:GetAngles(),
					model = v:GetModel(),
					material = v:GetMaterial(),
					color = v:GetColor(),
					rendermode = v:GetRenderMode(),
					startPos = v.worldStartPos,
					endPos = v.worldEndPos,
					moveSpeed = v.movespeed,
					moveSound = v.movesound,
					stopSound = v.stopsound,
					blockDamage = v.blockdamage,
					shake = v.shake,
					parts = parts,
					buttons = buttonList
				};
			end;
		end;

		local JSON = util.TableToJSON(buffer);

		file.Write("elevators/" .. game.GetMap() .. ".txt", JSON);
	end;

	function LoadElevators()
		if (!file.Exists("elevators/" .. game.GetMap() .. ".txt", "DATA")) then return; end;

		local buffer = file.Read("elevators/" .. game.GetMap() .. ".txt", "DATA");

		if (buffer and buffer:len() > 1) then
			buffer = util.JSONToTable(buffer);

			for k, v in pairs(buffer) do
				local elevator = ents.Create("elevator");
				elevator:SetPos(v.origin);
				elevator:SetAngles(v.angles);
				elevator.Model = v.model;
				elevator:Spawn();
				elevator:GetDoor():SetMaterial(v.material);
				elevator:GetDoor().child:SetMaterial(v.material);

				elevator:GetDoor():SetNWBool("saved", true);

				elevator:SetStart(v.startPos);
				elevator:SetEnd(v.endPos);

				elevator:SetMoveSpeed(v.moveSpeed);
				elevator:SetMoveSound(v.moveSound);
				elevator:SetStopSound(v.stopSound);

				elevator:SetBlockDamage(v.blockDamage);
				elevator:SetAllowUse(true);

				elevator:SetShake(v.shake);

				if (v.parts and table.Count(v.parts) > 0) then
					for k, info in pairs(v.parts) do
						local prop = ents.Create("prop_physics");
						prop:SetPos(elevator:GetDoor():LocalToWorld(info.origin));
						prop:SetAngles(elevator:GetDoor():LocalToWorldAngles(info.angles));
						prop:SetModel(info.model);
						prop:SetMaterial(info.material);
						prop:SetRenderMode(info.rendermode);
						prop:SetColor(info.color);
						prop:Spawn();
						prop:SetParent(elevator:GetDoor());
						prop:GetPhysicsObject():EnableMotion(false);
					end;
				end;

				if (v.buttons and table.Count(v.buttons) > 0) then
					for k, info in pairs(v.buttons) do
						local button = ents.Create("elevator_button");
						button:SetPos(info.origin);
						button.Model = info.model;
						button:SetAngles(info.angles);
						button:Spawn();
						button:SetElevator(elevator:GetDoor());
						button:SetSender(info.bIsSender);
						button:GetPhysicsObject():EnableMotion(false);
						button:PhysicsDestroy();
						button:SetColor(info.color);
						button:SetMaterial(info.material);
					end;
				end;
			end;
		end;
	end;
end;

hook.Add("PhysgunPickup", "zelevator_NoPickup", function(player, ent)
	if (ent:GetClass() == "func_movelinear") then
		if (ent:GetNWBool("saved", false)) then
			return false;
		end;
	elseif (IsValid(ent:GetParent()) and ent:GetParent():GetClass() == "func_movelinear") then
		return false;
	end;
end);

properties.Add("elevator_persist", {
	MenuLabel = "Save Elevator",
	MenuIcon = "icon16/disk.png",
	Order = 1,

	Filter = function(self, ent, player)
		if (!IsValid(ent)) then return false; end;
		if (!player:IsSuperAdmin()) then return false; end;
		if (ent:GetClass() != "func_movelinear") then return false; end;
		if (SERVER and !ent:GetName():find("zelevator")) then player:ChatPrint("That elevator cannot be saved"); return false; end;

		return !ent:GetNWBool("saved", false);
	end,

	Action = function(self, ent)
		self:MsgStart();
		net.WriteEntity(ent);
		self:MsgEnd();
	end,

	Receive = function(self, length, player)
		local ent = net.ReadEntity();

		if (!self:Filter(ent, player)) then return; end;

		ent:SetNWBool("saved", true);
		SaveElevators();
	end,
});

properties.Add("elevator_persist_end", {
	MenuLabel = "Un-Save Elevator",
	MenuIcon = "icon16/arrow_undo.png",
	Order = 1,

	Filter = function(self, ent, player)
		if (!IsValid(ent)) then return false; end;
		if (!player:IsSuperAdmin()) then return false; end;
		if (ent:GetClass() != "func_movelinear") then return false; end;
		if (SERVER and !ent:GetName():find("zelevator")) then player:ChatPrint("That elevator cannot be saved"); return false; end;

		return ent:GetNWBool("saved", false);
	end,

	Action = function(self, ent)
		self:MsgStart();
		net.WriteEntity(ent);
		self:MsgEnd();
	end,

	Receive = function(self, length, player)
		local ent = net.ReadEntity();

		if (!self:Filter(ent, player)) then return; end;

		ent:SetNWBool("saved", false);
		SaveElevators();
	end,
});
--addons/shieldgenerator/lua/autorun/shield.lua:
if CLIENT then
	local CDRAW1 = include('shield2.lua')

	surface.CreateFont('SHLACK',{font='Trebuchet MS',size=32,weight=400})

	local MSW, MSH = ScrW(), ScrH()
	local off_h = MSH/2-32
	local col_bg = Color(0,0,0,192)
	local col_fill = Color(64,128,192,255)
	local col_txt = Color(255,255,255)
	local sqshtab1 = {}

	timer.Create('CSquadShield1', 1, 0,function()
		sqshtab1 = {}
		for k,v in pairs(ents.FindByClass('portable_shield_gen')) do
			sqshtab1[#sqshtab1+1] = v
		end
	end)

	surface.CreateFont('cents_ss',{font='Trebuchet MS',size=200})
	surface.CreateFont('cents_ss_blur',{font='Trebuchet MS',size=200,blursize=4})

	local rendmat = Material('models/props_combine/stasisshield_sheet')
	local rendmat2 = Material('models/props_combine/portalball001_sheet')
	local beammat = Material('cable/physbeam')
	local ringmat = Material('cable/blue_elec')
	local solvemat = Material('effects/tool_tracer')
	local text_col = Color(64,192,255)
	local beamcol = Color(0,192,255)
	local blue_shg = Color(0,0,255,64)
	local quality = 100
	local beamcount = 5
	local beam_width = 20
	local ring_width = 8
	local spr = 128
	local spr_rime = 0.1
	local step = .02

	local function qc(t,p0,p1,p2)
		return (1-t)^2*p0+2*(1-t)*t*p1+t^2*p2
	end

	hook.Add('PostDrawTranslucentRenderables','CSquadShield',function(bDepth,bSkybox)
		if bSkybox then return end
		for k,v in pairs(sqshtab1) do
			if !IsValid(v) then continue end
			local vpos = v:GetPos()
			local qq1 = Vector(0,0,1)
			local qq2 = qq1:Dot(vpos)
			render.SetMaterial(beammat)
			local startpos = vpos
			local radius = v.Radius*v.SphereScale
			local act_endpos = vpos+Vector(0,0,radius+16+math.sin(SysTime()*0.6)*32)
			for pee = 0, beamcount-1 do
				local haha = math.pi*2*pee/beamcount
				local endpos = startpos+Vector(math.sin(haha+CurTime()*spr_rime)*spr,math.cos(haha+CurTime()*spr_rime)*spr,radius-60)
				local normal = (endpos-startpos):GetNormalized()
				local dist = startpos:Distance(endpos)
				local mt = Matrix()
				mt:SetAngles(normal:Angle()+Angle(90,0,0))
				local oldpos
				for i = 0, 1, step do
					local p = qc(i,startpos,act_endpos,endpos)
					if oldpos then
						--render.DrawBeam(oldpos,p,beam_width,1,1,beamcol)
					end
					oldpos = p
				end
			end
			render.SetMaterial(ringmat)
			for i = 1, quality do
				local p1 = vpos+Vector(math.sin((i/quality)*math.pi*2)*radius,math.cos((i/quality)*math.pi*2)*radius,0)
				local p2 = vpos+Vector(math.sin(((i+1)/quality)*math.pi*2)*radius,math.cos(((i+1)/quality)*math.pi*2)*radius,0)
				render.DrawBeam(p1,p2,ring_width,1,1,beamcol)
			end
			render.SetMaterial(solvemat)
			render.DrawBeam(vpos+Vector(0,0,8),vpos+Vector(0,0,16),8,CurTime()*2,CurTime()*2-1,beamcol)
			local oldEC = render.EnableClipping(true)
			render.PushCustomClipPlane(qq1,qq2)
			render.SetColorMaterial()
			render.DrawSphere(vpos,radius,quality,quality,blue_shg)
			render.SetMaterial(rendmat)
			render.OverrideBlend(true,3,1,BLENDFUNC_ADD)
			render.DrawSphere(vpos,radius,quality,quality)
			render.OverrideBlend(false,3,1,BLENDFUNC_ADD)
			render.SetMaterial(rendmat2)
			render.OverrideBlend(true,2,1,BLENDFUNC_ADD)
			render.DrawSphere(vpos,radius,quality,quality)
			render.OverrideBlend(false,2,1,BLENDFUNC_ADD)
			render.PopCustomClipPlane()
			render.EnableClipping(oldEC)

		end
	end)

end
--lua/autorun/sitanywhere.lua:
if SERVER then
	AddCSLuaFile("sitanywhere/client/sit.lua")
	AddCSLuaFile("sitanywhere/helpers.lua")
	include("sitanywhere/helpers.lua")
	include("sitanywhere/server/sit.lua")

	AddCSLuaFile("sitanywhere/ground_sit.lua")
	include("sitanywhere/server/unstuck.lua")
	include("sitanywhere/ground_sit.lua")
else
	include("sitanywhere/helpers.lua")
	include("sitanywhere/client/sit.lua")

	include("sitanywhere/ground_sit.lua")
end
--lua/sitanywhere/client/sit.lua:
local TAG = "SitAny_"
local useAlt = CreateClientConVar("sitting_use_walk", "1.00", true, true, "Makes sitting require the use of walk, disable this to sit simply by using use", 0, 1)
local forceBinds = CreateClientConVar("sitting_force_left_alt", "0", true, true, "Forces left alt to always act as a walk key for sitting", 0, 1)
local SittingNoAltServer = CreateConVar("sitting_force_no_walk", "0", {FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Disables the need for using walk to sit anywhere on the server", 0, 1)

CreateClientConVar("sitting_allow_on_me", "1.00", true, true, "Allows people to sit on you", 0, 1)

local function ShouldSit(ply)
	return hook.Run("ShouldSit", ply)
end

local arrow, drawScale, traceDist = Material("widgets/arrow.png"), 0.1, 20
local traceScaled = traceDist / drawScale

local function StartSit(trace)
	local wantedAng = nil
	local cancelled = false
	local start = CurTime()
	local ply = LocalPlayer()

	hook.Add("PostDrawOpaqueRenderables", TAG .. "PostDrawOpaqueRenderables", function(depth, skybox)
		if CurTime() - start <= 0.25 then return end
		if trace.StartPos:Distance(ply:EyePos()) > 10 then
			cancelled, wantedAng = true, nil
			hook.Remove("PostDrawOpaqueRenderables", TAG .. "PostDrawOpaqueRenderables")
			return
		end

		local vec = util.IntersectRayWithPlane(ply:EyePos(), ply:EyeAngles():Forward(), trace.HitPos, Vector(0, 0, 1))
		if not vec then
			return
		end

		local posOnPlane = WorldToLocal(vec, Angle(0, 90, 0), trace.HitPos, Angle(0, 0, 0))
		local testVec = posOnPlane:GetNormal() * traceScaled
		local currentAng = (trace.HitPos - vec):Angle()
		wantedAng = currentAng

		if posOnPlane:Length() < 2 then
			wantedAng = nil
			return
		end

		if wantedAng then
			local goodSit = SitAnywhere.CheckValidAngForSit(trace.HitPos, trace.HitNormal:Angle(), wantedAng.y)
			if not goodSit then wantedAng = nil end
			cam.Start3D2D(trace.HitPos + Vector(0, 0, 1), Angle(0, 0, 0), drawScale)
				surface.SetDrawColor(goodSit and Color(255, 255, 255, 255) or Color(255, 0, 0, 255))
				surface.SetMaterial(arrow)
				surface.DrawTexturedRectRotated(testVec.x * 0.5, testVec.y * -0.5, 2 / drawScale, traceScaled, currentAng.y + 90)
			cam.End3D2D()
		end
	end)

	return function()
		hook.Remove("PostDrawOpaqueRenderables", TAG .. "PostDrawOpaqueRenderables")
		if cancelled then return end

		if CurTime() - start < 0.25 then
			RunConsoleCommand("sit")
			return
		end

		if wantedAng then
			net.Start("SitAnywhere")
				net.WriteInt(SitAnywhere.NET.SitWantedAng, 4)
				net.WriteFloat(wantedAng.y)
				net.WriteVector(trace.StartPos)
				net.WriteVector(trace.Normal)
			net.SendToServer()
			wantedAng = nil
		end
	end
end

local function DoSit(trace)
	if not trace.Hit then return end

	local surfaceAng = trace.HitNormal:Angle() + Angle(-270, 0, 0)

	local playerTrace = not trace.HitWorld and IsValid(trace.Entity) and trace.Entity:IsPlayer()

	local goodSit = SitAnywhere.GetAreaProfile(trace.HitPos + Vector(0, 0, 0.1), 24, true)
	if math.abs(surfaceAng.pitch) >= 15 or not goodSit or playerTrace then
		RunConsoleCommand"sit"
		return
	end

	local valid = SitAnywhere.ValidSitTrace(LocalPlayer(), trace)
	if not valid then
		return
	end

	return StartSit(trace)
end

local currSit
concommand.Add("+sit", function(ply, cmd, args)
	if currSit then return end
	if not IsValid(ply) or not ply.GetEyeTrace then return end
	currSit = DoSit(ply:GetEyeTrace())
end)

concommand.Add("-sit", function(ply, cmd, args)
	if currSit then
		currSit()
		currSit = nil
	end
end)


hook.Add("KeyPress", TAG .. "KeyPress", function(ply, key)
	if not IsFirstTimePredicted() and not game.SinglePlayer() then return end
	if currSit then return end

	if key ~= IN_USE then return end
	local good = not useAlt:GetBool()
	local alwaysSit = ShouldSit(ply)

	if forceBinds:GetBool() then
		if useAlt:GetBool() and input.IsKeyDown(KEY_LALT) then
			good = true
		end
	else
		if useAlt:GetBool() and ply:KeyDown(IN_WALK) then
			good = true
		end
	end

	if SittingNoAltServer:GetBool() then
		good = true
	end

	if alwaysSit == true then
		good = true
	elseif alwaysSit == false then
		good = false
	end

	if not good then return end
	local trace = LocalPlayer():GetEyeTrace()

	if trace.Hit then
		currSit = DoSit(trace)
		hook.Add("KeyRelease", TAG .. "KeyRelease", function(releasePly, releaseKey)
			if not IsFirstTimePredicted() and not game.SinglePlayer() then return end
			if ply ~= releasePly or releaseKey ~= IN_USE then return end
			hook.Remove("KeyRelease", TAG .. "KeyRelease")
			if not currSit then return end

			currSit()
			currSit = nil
		end)
	end
end)
--lua/autorun/snowashoka.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )
	
end

AddPlayerModel( "Ashoka Tano in Snow costume", 				"models/artel/snowashoka/snowashoka.mdl" )


--lua/autorun/strasser_sw2017_wookie_warrior.lua:
list.Set( "strasser_wookie_warrior", "models/player/strasser/wookie_warrior/wookie_warrior.mdl" )
player_manager.AddValidModel( "strasser_wookie_warrior", "models/player/strasser/wookie_warrior/wookie_warrior.mdl" )
player_manager.AddValidHands( "strasser_wookie_warrior", "models/player/strasser/wookie_warrior/wookie_warrior_hands.mdl", 0, "00000000" )
--addons/handschellen/lua/autorun/sv_handcuffs.lua:
---------------------------------------
--   		 SV | Handcuffs          --
---------------------------------------

if CLIENT then return end

util.AddNetworkString( "Cuffs_GagPlayer" )
util.AddNetworkString( "Cuffs_BlindPlayer" )
util.AddNetworkString( "Cuffs_FreePlayer" )
util.AddNetworkString( "Cuffs_DragPlayer" )
util.AddNetworkString( "Cuffs_TiePlayers" )
util.AddNetworkString( "Cuffs_UntiePlayers" )

local function GetTrace( ply )
	local tr = util.TraceLine( {start = ply:EyePos(), endpos = ply:EyePos() + (ply:GetAimVector() * 100), filter = ply} )

	if IsValid(tr.Entity) and tr.Entity:IsPlayer() then
		local cuffed, wep = tr.Entity:IsHandcuffed()

		if cuffed then return tr,wep end
	end
end

-- Default hooks
hook.Add( "PlayerCanSeePlayersChat", "Cuffs ChatGag", function( _,_,_, ply )
	if not IsValid(ply) then return end

	local cuffed,wep = ply:IsHandcuffed()
	if cuffed and wep:GetIsGagged() then return false end
end)

-- Think
local NextTieHookCleanup
hook.Add( "Think", "Cuffs ForceJump CleanupTieHooks", function()
	for _, v in pairs(player.GetAll()) do
		if v.Cuff_ForceJump then
			if not v:OnGround() then return end

			local tr = util.TraceLine( {start = v:GetPos(), endpos = v:GetPos() + Vector(0,0,20), filter = v} )

			if tr.Hit then return end

			v:SetPos(v:GetPos() + Vector(0,0,5) )

			v.Cuff_ForceJump = nil
		end
	end

	if CurTime() >= (NextTieHookCleanup or 0) then
		NextTieHookCleanup = CurTime() + 0.5

		for _,v in pairs(ents.GetAll()) do
			if v.IsHandcuffHook and v.TiedHandcuffs then
				for i = #v.TiedHandcuffs,0,-1 do
					if not IsValid(v.TiedHandcuffs[i]) then
						table.remove( v.TiedHandcuffs, i )
					end
				end

				if #v.TiedHandcuffs <= 0 then
					v:Remove()

					continue
				end
			end
		end
	end
end)


-- Cuffed player interaction
net.Receive( "Cuffs_GagPlayer", function(_, ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end

	local target = net.ReadEntity()

	if not IsValid(target) or target == ply then return end

	local cuffed, cuffs = target:IsHandcuffed()
	local tr = GetTrace(ply)
	local shouldGag = net.ReadBit() == 1

	if not (cuffed and IsValid(cuffs) and cuffs:GetCanGag()) then return end
	if not (tr and tr.Entity == target) then return end

	cuffs:SetIsGagged( shouldGag )

	--hook.Run( shouldGag and "OnHandcuffGag" or "OnHandcuffUnGag", GAMEMODE, ply, target, cuffs )
end)

net.Receive( "Cuffs_BlindPlayer", function(_, ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end

	local target = net.ReadEntity()

	if (not IsValid(target)) or target == ply then return end

	local cuffed, cuffs = target:IsHandcuffed()
	local tr = GetTrace(ply)
	local shouldBlind = net.ReadBit() == 1

	if not (cuffed and IsValid(cuffs) and cuffs:GetCanBlind()) then return end

	if not (tr and tr.Entity == target) then return end

	cuffs:SetIsBlind( shouldBlind )

	--hook.Call( shouldBlind and "OnHandcuffBlindfold" or "OnHandcuffUnBlindfold", GAMEMODE, ply, target, cuffs )
end)

net.Receive( "Cuffs_FreePlayer", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end

	local target = net.ReadEntity()

	if (not IsValid(target)) or target == ply then return end

	local cuffed, cuffs = target:IsHandcuffed()
	local tr = GetTrace(ply)

	if not (cuffed and IsValid(cuffs)) then return end
	if IsValid(cuffs:GetFriendBreaking()) then return end
	if not (tr and tr.Entity == target) then return end

	cuffs:SetFriendBreaking( ply )
end)

net.Receive( "Cuffs_DragPlayer", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end

	local target = net.ReadEntity()

	if (not IsValid(target)) or target == ply then return end

	local cuffed, cuffs = target:IsHandcuffed()
	local tr = GetTrace(ply)

	if not (cuffed and IsValid(cuffs) and cuffs:GetRopeLength() > 0) then return end
	if not (tr and tr.Entity == target) then return end

	local shouldDrag = net.ReadBit() == 1

	if shouldDrag then
		if not (IsValid(cuffs:GetKidnapper())) then
			cuffs:SetKidnapper( ply )

			hook.Call( "OnHandcuffStartDragging", GAMEMODE, ply, target, cuffs )
		end
	else
		if ply == cuffs:GetKidnapper() then
			cuffs:SetKidnapper( nil )

			hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, target, cuffs )
		end
	end
end)

local HookModel = Model("models/props_c17/TrapPropeller_Lever.mdl")

net.Receive( "Cuffs_TiePlayers", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end

	local DraggedCuffs = {}

	for _,c in pairs(ents.FindByClass("weapon_handcuffed")) do
		if c:GetRopeLength() > 0 and c:GetKidnapper() == ply then
			table.insert( DraggedCuffs, c )
		end
	end

	if #DraggedCuffs <= 0 then return end

	local tr = util.TraceLine( {start = ply:EyePos(), endpos = ply:EyePos() + (ply:GetAimVector() * 100), filter = ply} )

	if not tr.Hit then return end

	if IsValid(tr.Entity) then
		if tr.Entity:IsPlayer() then
			for i = 1,#DraggedCuffs do
				if DraggedCuffs[i].Owner == tr.Entity then
					DraggedCuffs[i]:SetKidnapper(nil)

					hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i] )
				else
					DraggedCuffs[i]:SetKidnapper(tr.Entity)

					hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i] )
					hook.Call( "OnHandcuffStartDragging", GAMEMODE, tr.Entity, DraggedCuffs[i].Owner, DraggedCuffs[i] )
				end
			end

			return
		elseif tr.Entity.IsHandcuffHook and tr.Entity.TiedHandcuffs then
			for i = 1,#DraggedCuffs do
				DraggedCuffs[i]:SetKidnapper(tr.Entity)

				table.insert( tr.Entity.TiedHandcuffs, DraggedCuffs[i] )

				hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i] )
				hook.Call( "OnHandcuffTied", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i], tr.Entity )
			end

			return
		end
	end

	local hk = ents.Create("prop_physics")
	hk:SetPos( tr.HitPos + tr.HitNormal )

	local ang = tr.HitNormal:Angle()
	ang:RotateAroundAxis( ang:Up(), -90 )

	hk:SetAngles( ang )
	hk:SetModel( HookModel )
	hk:Spawn()

	if IsValid(tr.Entity) then
		hk:SetParent( tr.Entity )
		hk:SetMoveType( MOVETYPE_VPHYSICS )
	else
		hk:SetMoveType( MOVETYPE_NONE )
	end

	hk:SetCollisionGroup( COLLISION_GROUP_WEAPON )

	hk:SetNWBool("Cuffs_TieHook", true)
	hk.IsHandcuffHook = true
	hk.TiedHandcuffs = {}

	for i = 1,#DraggedCuffs do
		DraggedCuffs[i]:SetKidnapper( hk )

		table.insert( hk.TiedHandcuffs, DraggedCuffs[i] )

		hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i] )
		hook.Call( "OnHandcuffTied", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i], hk )
	end
end)

local function DoUntie( ply, ent )
	for i = 1,#ent.TiedHandcuffs do
		if not IsValid(ent.TiedHandcuffs[i]) then continue end

		ent.TiedHandcuffs[i]:SetKidnapper( ply )

		hook.Call( "OnHandcuffUnTied", GAMEMODE, ply, ent.TiedHandcuffs[i].Owner, ent.TiedHandcuffs[i], ent )
		hook.Call( "OnHandcuffStartDragging", GAMEMODE, ply, ent.TiedHandcuffs[i].Owner, ent.TiedHandcuffs[i] )
	end

	ent:Remove()
end

net.Receive( "Cuffs_UntiePlayers", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end

	local tr = util.TraceLine({start = ply:EyePos(), endpos = ply:EyePos() + (ply:GetAimVector() * 100), filter = ply})

	if IsValid(tr.Entity) and tr.Entity.IsHandcuffHook and tr.Entity.TiedHandcuffs then
		DoUntie( ply, tr.Entity )
	end
end)

hook.Add( "AllowPlayerPickup", "Cuffs UntieHook", function(ply,ent)
	if IsValid(ent) and ent.IsHandcuffHook and ent.TiedHandcuffs then
		if (not IsValid(ply)) or ply:IsHandcuffed() then return end

		DoUntie( ply, ent )

		return false
	end
end)


-- Admin Uncuff 

-- local UncuffCommands = {
-- 	["!uncuff"] = true, ["/uncuff"] = true,
-- }
-- hook.Add( "PlayerSay", "Cuffs AdminUncuff", function( ply, str )
-- 	if not (IsValid(ply) and ply:IsTeamMember()) then return end

-- 	if UncuffCommands[ str:lower():Trim() ] then
-- 		local isCuffed, cuffs = ply:IsHandcuffed()
-- 		if not IsValid(cuffs) then return end

-- 		ServerLog( "[Cuffs] Player '" .. tostring( ply:Nick() ) .. "' ["..tostring(ply:SteamID()).."] used the Uncuff command.\n" )

-- 		cuffs:Uncuff()
-- 	end
-- end)

-- Anti-Physgun
hook.Add( "PhysgunPickup", "Cuffs AntiPhysgunTies", function( ply, ent )
	if not IsValid(ent) then return end

	local ties = {}

	for _, ent in pairs(ents.GetAll()) do
		if IsValid(ent) and ent.IsHandcuffHook then
			table.insert( ties, ent )
		end
	end

	if #ties == 0 then return end

	local const = constraint.GetAllConstrainedEntities( ent )

	for _,v in pairs( ties ) do
		if const[ v:GetParent() ] then
			local eff = EffectData()
			eff:SetOrigin( v:GetPos() )
			eff:SetStart( v:GetPos() )
			eff:SetScale( 1 )
			eff:SetRadius( 1 )
			eff:SetMagnitude( 1 )
			eff:SetNormal( v:GetRight() )

			util.Effect( "Sparks", eff, true, true )

			v:Remove()
		end
	end
end)

hook.Add("DoPlayerDeath", "Handcuffs.SaveCuffs", function(ply)
	local cuffs = ply:GetWeapon("weapon_handcuffed")
	if not IsValid(cuffs) then return end

	local cuffsTable = {}
	cuffsTable.Strength = cuffs:GetCuffStrength()
	cuffsTable.Regen = cuffs:GetCuffRegen()
	cuffsTable.Material = cuffs:GetCuffMaterial()
	cuffsTable.RopeMaterial = cuffs:GetRopeMaterial()
	cuffsTable.RopeLength = cuffs:GetRopeLength()
	cuffsTable.CanBlind = cuffs:GetCanBlind()
	cuffsTable.CanGag = cuffs:GetCanGag()
	cuffsTable.IsLeash = cuffs:GetIsLeash()
	cuffsTable.CuffType = cuffs:GetClass() or ""
	cuffsTable.Kidnapper = cuffs:GetKidnapper()

	ply.cuffed = cuffsTable
end)

-- Handcuff player if respawn
hook.Add("DeathSystem.Revive", "Handcuffs:CuffPlayer", function(ply)
	if ply.corpse then
		ply:SetNWEntity("Deathsystem.Corpse", NULL)
	end

	if ply.cuffed and istable(ply.cuffed) then
		local cuffTable = ply.cuffed

		local cuff
		if not ply:HasWeapon("weapon_handcuffed") then
			cuff = ply:Give("weapon_handcuffed")
		else
			cuff = ply:GetWeapon("weapon_handcuffed")
		end

		cuff:SetCuffStrength(cuffTable.Strength or 1)
		cuff:SetCuffRegen(cuffTable.Regen or 1)
		cuff:SetCuffMaterial(cuffTable.Material or "phoenix_storms/metalfloor_2-3")
		cuff:SetRopeMaterial(cuffTable.RopeMaterial or "cable/cable2")
		cuff:SetRopeLength(cuffTable.RopeLength or 0)
		cuff:SetCanBlind(cuffTable.CanBlind or false)
		cuff:SetCanGag(cuffTable.IsLeash or false)

		cuff.CuffType = cuffTable.CuffType

		if cuff.IsLeash then
			cuff:SetIsLeash( true )

			timer.Simple( 0, function()
				if IsValid(cuff) then
					cuff:SetHoldType( "normal" )
					cuff.HoldType = "normal"
				end
			end)
		end

		ply.cuffed = false
	end
end)

hook.Add("PlayerSpawn", "DeathSystem.ClearCuff", function(ply)
	if ply.cuffed then
		timer.Simple(1, function()
			ply.cuffed = false
		end)
	end
end)

hook.Add("DeathSystem.ProcessDeath", "Death:NWVar", function(ply, stun)
	if ply.corpse then
		ply:SetNWEntity("Deathsystem.Corpse", ply.corpse)

		if ply.cuffed then
			local cuffsTable = ply.cuffed
			ply.corpse:SetNWEntity("Cuff.Kidnapper", cuffsTable.Kidnapper)
			ply.corpse:SetNWFloat("Cuff.RopeLength", cuffsTable.RopeLength)
			ply.corpse:SetNWString("Cuff.CuffMaterial", cuffsTable.Material)
			ply.corpse:SetNWString("Cuff.CuffRope", cuffsTable.RopeMaterial)
		end
	end
end)
--lua/autorun/swjs_csf.lua:
player_manager.AddValidModel( "Corusant Security Force Lead",						"models/nada/CSF_Leader.mdl" ) 
list.Set( "PlayerOptionsModel",  "Corusant Security Force Lead",						"models/nada/CSF_Leader.mdl" )
player_manager.AddValidHands( "Corusant Security Force Lead", "models/nada/hands/CSF_arms.mdl", 0, "00000000" )

player_manager.AddValidModel( "Corusant Security Force",						"models/nada/CSF.mdl" ) 
list.Set( "PlayerOptionsModel",  "Corusant Security Force",						"models/nada/CSF.mdl" )
player_manager.AddValidHands( "Corusant Security Force", "models/nada/hands/CSF_arms.mdl", 0, "00000000" )

player_manager.AddValidModel( "Corusant Security Variant",						"models/nada/CSF_Variant.mdl" ) 
list.Set( "PlayerOptionsModel",  "Corusant Security Variant",						"models/nada/CSF_Variant.mdl" )
player_manager.AddValidHands( "Corusant Security Variant", "models/nada/hands/CSF_arms.mdl", 0, "00000000" )
--addons/mortar/lua/autorun/swm_mortar_runner.lua:
if SERVER then
    resource.AddFile("resource/fonts/Starjhol.ttf")
end

hook.Add("CalcMainActivity", "SWMortarSeatAnimOverride", function (ply, vel)
    local seat = ply:GetVehicle()

    if (not IsValid(seat) or not IsValid(seat:GetParent()) or seat:GetParent():GetClass() ~= "mortar") then return end

    ply.CalcIdeal = ACT_CROUCH
    ply.CalcSeqOverride = ply:LookupSequence("pose_ducking_01")

    return ply.CalcIdeal, ply.CalcSeqOverride
end)

if CLIENT then
	hook.Add("CalcView", "SWMortarCalcViewMortarSeat", function (ply, pos, angles, fov)
		local seat = LocalPlayer():GetVehicle()
		if (IsValid(seat) and IsValid(seat:GetParent()) and seat:GetParent():GetClass() == "mortar") then
			local view = {
				origin = pos + angles:Up() * 50 - angles:Forward() * 100,
				angles = angles,
				fov = fov,
				drawviewer = true
			}

			return view
		end
	end)

	local visorMaterial = Material("models/dolunity/starwars/visor-final.png")

	hook.Add("HUDPaint", "SWMortarHUD", function ()
		local seat = LocalPlayer():GetVehicle()

		if (IsValid(seat) and IsValid(seat:GetParent()) and seat:GetParent():GetClass() == "mortar") then
			local mortar = seat:GetParent()
			local barrelId = mortar:LookupBone("Barrel")
			local barrelAngle = mortar:GetManipulateBoneAngles(barrelId) + Angle(rot,0,ang)

			barrelAngle.z = math.Clamp(barrelAngle.z, mortar.AnglingMin, mortar.AnglingMax)

			surface.SetDrawColor(255,255,255)
			surface.SetMaterial(visorMaterial)

			local height = ScrH() * 0.25
			local width = height * 1.27
			surface.DrawTexturedRect((ScrW() - width) / 2, ScrH() - height * 0.9, width, height)

			surface.SetFont("swmFont")
			surface.SetTextColor(255, 255, 0)

			local rText
			local bax = math.abs((barrelAngle.x + mortar:GetLocalAngles().y) % 360 - 360)
			if (math.Round(bax, 2) >= 0) then
				rText = "R   >  " .. math.Round(bax, 2) .. "°"
			else
				rText = "R   >  " .. math.Round(bax, 2) .. "°"
			end

			local rWidth, rHeight = surface.GetTextSize(rText)
			surface.SetTextPos((ScrW() - width) / 2 + width * 0.1, ScrH() - height + rHeight + height * 0.11)
			surface.DrawText(rText)

			local aText = "Mil >  " .. (math.abs(math.Round(barrelAngle.z, 2) - mortar.AnglingMax) * 25 + 800)
			local aWidth, aHeight = surface.GetTextSize(aText)
			surface.SetTextPos((ScrW() - width) / 2 + width * 0.1, ScrH() - height + rHeight + aHeight + height * 0.16)
			surface.DrawText(aText)

			local fPosX = (ScrW() - width) / 2 + width * 0.7
			local fPosY = ScrH() - height + height * 0.23

			if (mortar:GetNWInt("NextFire") > CurTime()) then
				surface.SetDrawColor(100,0,0,255)
			else
				surface.SetDrawColor(255,0,0,255)
			end

			draw.NoTexture()
			surface.DrawPoly({
				{x = fPosX + 0,y = fPosY + 100},
				{x = fPosX + 30,y = fPosY + 0},
				{x = fPosX + 60,y = fPosY + 100}
			})
		end
	end)

	surface.CreateFont("swmFont", {
		font = "Star Jedi Hollow", --  Use the font-name which is shown to you by your operating system Font Viewer, not the file name
		extended = false,
		size = 36,
		weight = 500,
		blursize = 0,
		scanlines = 0,
		antialias = true,
		underline = false,
		italic = false,
		strikeout = false,
		symbol = false,
		rotary = false,
		shadow = false,
		additive = false,
		outline = true,
	})
end

--addons/tfa_base/lua/tfa/enums/animation.lua:
-- luacheck: globals ACT_VM_FIDGET_EMPTY ACT_VM_FIDGET_SILENCED ACT_VM_BLOWBACK ACT_VM_HOLSTER_SILENCED
TFA.Enum.ANIMATION_ACT = 0
TFA.Enum.ANIMATION_SEQ = 1
ACT_VM_FIDGET_EMPTY = ACT_VM_FIDGET_EMPTY or ACT_CROSSBOW_FIDGET_UNLOADED
ACT_VM_FIDGET_SILENCED = ACT_VM_FIDGET_SILENCED or ACT_RPG_FIDGET_UNLOADED
ACT_VM_HOLSTER_SILENCED = ACT_VM_HOLSTER_SILENCED or ACT_CROSSBOW_HOLSTER_UNLOADED
ACT_VM_BLOWBACK = ACT_VM_BLOWBACK or -2

-- luacheck: globals ACT_VM_RELOAD_ADS ACT_VM_RELOAD_EMPTY_ADS ACT_VM_RELOAD_SILENCED_ADS ACT_SHOTGUN_RELOAD_START_ADS ACT_SHOTGUN_RELOAD_FINISH_ADS
ACT_VM_RELOAD_ADS = ACT_VM_RELOAD_ADS or ACT_IDLE_AIM_RIFLE_STIMULATED
ACT_VM_RELOAD_EMPTY_ADS = ACT_VM_RELOAD_EMPTY_ADS or ACT_WALK_AIM_RIFLE_STIMULATED
ACT_VM_RELOAD_SILENCED_ADS = ACT_VM_RELOAD_SILENCED_ADS or ACT_RUN_AIM_RIFLE_STIMULATED
ACT_SHOTGUN_RELOAD_START_ADS = ACT_SHOTGUN_RELOAD_START_ADS or ACT_IDLE_SHOTGUN_RELAXED
ACT_SHOTGUN_RELOAD_FINISH_ADS = ACT_SHOTGUN_RELOAD_FINISH_ADS or ACT_IDLE_SHOTGUN_STIMULATED

--addons/tfa_base/lua/tfa/modules/tfa_commands.lua:
local function CreateReplConVar(cvarname, cvarvalue, description, ...)
	return CreateConVar(cvarname, cvarvalue, CLIENT and {FCVAR_REPLICATED} or {FCVAR_REPLICATED, FCVAR_ARCHIVE, FCVAR_NOTIFY}, description, ...)
end -- replicated only on clients, archive/notify on server

-- Shared Convars

if GetConVar("sv_tfa_changelog") == nil then
	CreateReplConVar("sv_tfa_changelog", "1", "Enable changelog?")
end

if GetConVar("sv_tfa_soundscale") == nil then
	CreateReplConVar("sv_tfa_soundscale", "1", "Scale sound pitch in accordance to timescale?")
end

if GetConVar("sv_tfa_weapon_strip") == nil then
	CreateReplConVar("sv_tfa_weapon_strip", "0", "Allow the removal of empty weapons?")
end

if GetConVar("sv_tfa_spread_legacy") == nil then
	CreateReplConVar("sv_tfa_spread_legacy", "0", "Use legacy spread algorithms?")
end

if GetConVar("sv_tfa_cmenu") == nil then
	CreateReplConVar("sv_tfa_cmenu", "1", "Allow custom context menu?")
end

if GetConVar("sv_tfa_cmenu_key") == nil then
	CreateReplConVar("sv_tfa_cmenu_key", "-1", "Override the inspection menu key?  Uses the KEY enum available on the gmod wiki. -1 to not.")
end

if GetConVar("sv_tfa_range_modifier") == nil then
	CreateReplConVar("sv_tfa_range_modifier", "0.5", "This controls how much the range affects damage.  0.5 means the maximum loss of damage is 0.5.")
end

if GetConVar("sv_tfa_allow_dryfire") == nil then
	CreateReplConVar("sv_tfa_allow_dryfire", "1", "Allow dryfire?")
end

if GetConVar("sv_tfa_penetration_hardlimit") == nil then
	CreateReplConVar("sv_tfa_penetration_hardlimit", "100", "Max number of objects we can penetrate through.")
end

if GetConVar("sv_tfa_bullet_penetration_power_mul") == nil then
	CreateReplConVar("sv_tfa_bullet_penetration_power_mul", "1", "Power multiplier. 1 or 1.5 for CS 1.6 experience, 0.25 for semi-realistic behavior")
end

if GetConVar("sv_tfa_penetration_hitmarker") == nil then
	CreateReplConVar("sv_tfa_penetration_hitmarker", "1", "Should penetrating bullet send hitmarker to attacker?")
end

if GetConVar("sv_tfa_damage_multiplier") == nil then
	CreateReplConVar("sv_tfa_damage_multiplier", "1", "Multiplier for TFA base projectile damage.")
end

if GetConVar("sv_tfa_damage_multiplier_npc") == nil then
	CreateReplConVar("sv_tfa_damage_multiplier_npc", "1", "Multiplier for TFA base projectile damage for NPCs.")
end

if GetConVar("sv_tfa_damage_mult_min") == nil then
	CreateReplConVar("sv_tfa_damage_mult_min", "0.95", "This is the lower range of a random damage factor.")
end

if GetConVar("sv_tfa_damage_mult_max") == nil then
	CreateReplConVar("sv_tfa_damage_mult_max", "1.05", "This is the higher range of a random damage factor.")
end

if GetConVar("sv_tfa_melee_damage_npc") == nil then
	CreateReplConVar("sv_tfa_melee_damage_npc", "1", "Damage multiplier against NPCs using TFA Melees.")
end

if GetConVar("sv_tfa_melee_damage_ply") == nil then
	CreateReplConVar("sv_tfa_melee_damage_ply", "0.65", "Damage multiplier against players using TFA Melees.")
end

if GetConVar("sv_tfa_melee_blocking_timed") == nil then
	CreateReplConVar("sv_tfa_melee_blocking_timed", "1", "Enable timed blocking?")
end

if GetConVar("sv_tfa_melee_blocking_anglemult") == nil then
	CreateReplConVar("sv_tfa_melee_blocking_anglemult", "1", "Players can block attacks in an angle around their view.  This multiplies that angle.")
end

if GetConVar("sv_tfa_melee_blocking_deflection") == nil then
	CreateReplConVar("sv_tfa_melee_blocking_deflection", "1", "For weapons that can deflect bullets ( e.g. certain katans ), can you deflect bullets?  Set to 1 to enable for parries, or 2 for all blocks.")
end

if GetConVar("sv_tfa_melee_blocking_timed") == nil then
	CreateReplConVar("sv_tfa_melee_blocking_timed", "1", "Enable timed blocking?")
end

if GetConVar("sv_tfa_melee_blocking_stun_enabled") == nil then
	CreateReplConVar("sv_tfa_melee_blocking_stun_enabled", "1", "Stun NPCs on block?")
end

if GetConVar("sv_tfa_melee_blocking_stun_time") == nil then
	CreateReplConVar("sv_tfa_melee_blocking_stun_time", "0.65", "How long to stun NPCs on block.")
end

if GetConVar("sv_tfa_melee_doordestruction") == nil then
	CreateReplConVar("sv_tfa_melee_doordestruction", "1", "Allow players to bash open doors?")
end

if GetConVar("sv_tfa_door_respawn") == nil then
	CreateReplConVar("sv_tfa_door_respawn", "-1", "Time for doors to respawn; -1 for never.")
end

if GetConVar("sv_tfa_npc_randomize_atts") == nil then
	CreateReplConVar("sv_tfa_npc_randomize_atts", "1", "Randomize NPC's weapons attachments.")
end

local cv_dfc
if GetConVar("sv_tfa_default_clip") == nil then
	cv_dfc = CreateReplConVar("sv_tfa_default_clip", "-1", "How many clips will a weapon spawn with? Negative reverts to default values.")
else
	cv_dfc = GetConVar("sv_tfa_default_clip")
end

local function TFAUpdateDefaultClip()
	local dfc = cv_dfc:GetInt()
	local weplist = weapons.GetList()
	if not weplist or #weplist <= 0 then return end

	for _, v in pairs(weplist) do
		local cl = v.ClassName and v.ClassName or v
		local wep = weapons.GetStored(cl)

		if wep and (wep.IsTFAWeapon or string.find(string.lower(wep.Base and wep.Base or ""), "tfa")) then
			if not wep.Primary then
				wep.Primary = {}
			end

			if not wep.Primary.TrueDefaultClip then
				wep.Primary.TrueDefaultClip = wep.Primary.DefaultClip
			end

			if not wep.Primary.TrueDefaultClip then
				wep.Primary.TrueDefaultClip = 0
			end

			if dfc < 0 then
				wep.Primary.DefaultClip = wep.Primary.TrueDefaultClip
			else
				if wep.Primary.ClipSize and wep.Primary.ClipSize > 0 then
					wep.Primary.DefaultClip = wep.Primary.ClipSize * dfc
				else
					wep.Primary.DefaultClip = wep.Primary.TrueDefaultClip * 1
				end
			end
		end
	end
end

hook.Add("InitPostEntity", "TFADefaultClipPE", TFAUpdateDefaultClip)

if TFAUpdateDefaultClip then
	TFAUpdateDefaultClip()
end

--if GetConVar("sv_tfa_default_clip") == nil then

cvars.AddChangeCallback("sv_tfa_default_clip", function(convar_name, value_old, value_new)
	TFAUpdateDefaultClip()
end, "TFAUpdateDefaultClip")

local function sv_tfa_range_modifier()
	for k, v in ipairs(ents.GetAll()) do
		if v.IsTFAWeapon and v.Primary_TFA.RangeFalloffLUT_IsConverted then
			v.Primary_TFA.RangeFalloffLUT = nil
			v:AutoDetectRange()
		end
	end
end

cvars.AddChangeCallback("sv_tfa_range_modifier", sv_tfa_range_modifier, "TFA")

sv_tfa_range_modifier()

if CLIENT then
	hook.Add("InitPostEntity", "sv_tfa_range_modifier", sv_tfa_range_modifier)
end

--end
if GetConVar("sv_tfa_unique_slots") == nil then
	CreateReplConVar("sv_tfa_unique_slots", "1", "Give TFA-based Weapons unique slots? 1 for true, 0 for false. RESTART AFTER CHANGING.")
end

if GetConVar("sv_tfa_spread_multiplier") == nil then
	CreateReplConVar("sv_tfa_spread_multiplier", "1", "Increase for more spread, decrease for less.")
end

if GetConVar("sv_tfa_force_multiplier") == nil then
	CreateReplConVar("sv_tfa_force_multiplier", "1", "Arrow force multiplier (not arrow velocity, but how much force they give on impact).")
end

if GetConVar("sv_tfa_dynamicaccuracy") == nil then
	CreateReplConVar("sv_tfa_dynamicaccuracy", "1", "Dynamic acuracy?  (e.g.more accurate on crouch, less accurate on jumping.")
end

if GetConVar("sv_tfa_ammo_detonation") == nil then
	CreateReplConVar("sv_tfa_ammo_detonation", "1", "Ammo Detonation?  (e.g. shoot ammo until it explodes) ")
end

if GetConVar("sv_tfa_ammo_detonation_mode") == nil then
	CreateReplConVar("sv_tfa_ammo_detonation_mode", "2", "Ammo Detonation Mode?  (0=Bullets,1=Blast,2=Mix) ")
end

if GetConVar("sv_tfa_ammo_detonation_chain") == nil then
	CreateReplConVar("sv_tfa_ammo_detonation_chain", "1", "Ammo Detonation Chain?  (0=Ammo boxes don't detonate other ammo boxes, 1 you can chain them together) ")
end

if GetConVar("sv_tfa_scope_gun_speed_scale") == nil then
	CreateReplConVar("sv_tfa_scope_gun_speed_scale", "0", "Scale player sensitivity based on player move speed?")
end

if GetConVar("sv_tfa_bullet_penetration") == nil then
	CreateReplConVar("sv_tfa_bullet_penetration", "1", "Allow bullet penetration?")
end

if GetConVar("sv_tfa_bullet_doordestruction") == nil then
	CreateReplConVar("sv_tfa_bullet_doordestruction", "1", "Allow to shoot down doors?")
end

if GetConVar("sv_tfa_bullet_doordestruction_keep") == nil then
	CreateReplConVar("sv_tfa_bullet_doordestruction_keep", "0", "Don't shoot door off hinges")
end

if GetConVar("sv_tfa_npc_burst") == nil then
	CreateReplConVar("sv_tfa_npc_burst", "0", "Whenever NPCs should fire in bursts like they do with HL2 weapons.")
end

if GetConVar("sv_tfa_bullet_ricochet") == nil then
	CreateReplConVar("sv_tfa_bullet_ricochet", "0", "Allow bullet ricochet?")
end

if GetConVar("sv_tfa_bullet_randomseed") == nil then
	CreateReplConVar("sv_tfa_bullet_randomseed", "0", "Populate extra seed serverside? This will cause spread to be out of sync with server!")
end

if GetConVar("sv_tfa_debug") == nil then
	CreateReplConVar("sv_tfa_debug", "0", "Enable debug mode?")
end

if GetConVar("sv_tfa_holdtype_dynamic") == nil then
	CreateReplConVar("sv_tfa_holdtype_dynamic", "1", "Allow dynamic holdtype?")
end

if GetConVar("sv_tfa_arrow_lifetime") == nil then
	CreateReplConVar("sv_tfa_arrow_lifetime", "30", "Arrow lifetime.")
end

if GetConVar("sv_tfa_worldmodel_culldistance") == nil then
	CreateReplConVar("sv_tfa_worldmodel_culldistance", "-1", "-1 to leave unculled.  Anything else is feet*16.")
end

if GetConVar("sv_tfa_reloads_legacy") == nil then
	CreateReplConVar("sv_tfa_reloads_legacy", "0", "Enable legacy-style reloading?")
end

if GetConVar("sv_tfa_recoil_legacy") == nil then
	CreateReplConVar("sv_tfa_recoil_legacy", "0", "Enable legacy-style recoil? This will cause prediction issues in multiplayer. Always disabled for NPCs!")
end

if GetConVar("sv_tfa_recoil_mul_p") == nil then
	CreateReplConVar("sv_tfa_recoil_mul_p", "1", "Pitch kick multiplier for recoil")
end

if GetConVar("sv_tfa_recoil_mul_y") == nil then
	CreateReplConVar("sv_tfa_recoil_mul_y", "1", "Yaw kick multiplier for recoil")
end

if GetConVar("sv_tfa_recoil_mul_p_npc") == nil then
	CreateReplConVar("sv_tfa_recoil_mul_p_npc", "1", "Pitch kick multiplier for recoil for NPCs")
end

if GetConVar("sv_tfa_recoil_mul_y_npc") == nil then
	CreateReplConVar("sv_tfa_recoil_mul_y_npc", "1", "Yaw kick multiplier for recoil for NPCs")
end

if GetConVar("sv_tfa_recoil_viewpunch_mul") == nil then
	CreateReplConVar("sv_tfa_recoil_viewpunch_mul", "1", "Multiplier for viewpunch recoil (visual viewmodel recoil)")
end

if GetConVar("sv_tfa_recoil_eyeangles_mul") == nil then
	CreateReplConVar("sv_tfa_recoil_eyeangles_mul", "1", "Multiplier for eye angles recoil (real angle change recoil)")
end

if GetConVar("sv_tfa_fx_penetration_decal") == nil then
	CreateReplConVar("sv_tfa_fx_penetration_decal", "1", "Enable decals on the other side of a penetrated object?")
end

local cv_ironsights = GetConVar("sv_tfa_ironsights_enabled")

if cv_ironsights == nil then
	cv_ironsights = CreateReplConVar("sv_tfa_ironsights_enabled", "1", "Enable ironsights? Disabling this still allows scopes.")
end

local is_stats = {
	["data.ironsights"] = 0,
	["Secondary.IronSightsEnabled"] = false,
}

hook.Add("TFA_GetStat", "TFA_IronsightsConVarToggle", function(wep, stat, val)
	if not IsValid(wep) or is_stats[stat] == nil then return end

	if not cv_ironsights:GetBool() and not wep:GetStatRawL("Scoped") and not wep:GetStatRawL("Scoped_3D") then
		return is_stats[stat]
	end
end)

if GetConVar("sv_tfa_sprint_enabled") == nil then
	CreateReplConVar("sv_tfa_sprint_enabled", "1", "Enable sprinting? Disabling this allows shooting while IN_SPEED.")
end

if GetConVar("sv_tfa_reloads_enabled") == nil then
	CreateReplConVar("sv_tfa_reloads_enabled", "1", "Enable reloading? Disabling this allows shooting from ammo pool.")
end

if GetConVar("sv_tfa_attachments_enabled") == nil then
	CreateReplConVar("sv_tfa_attachments_enabled", "1", "Display attachment picker?")
end

if GetConVar("sv_tfa_attachments_alphabetical") == nil then
	CreateReplConVar("sv_tfa_attachments_alphabetical", "0", "Override weapon attachment order to be alphabetical.")
end

if GetConVar("sv_tfa_jamming") == nil then
	CreateReplConVar("sv_tfa_jamming", "1", "Enable jamming mechanics?")
end

if GetConVar("sv_tfa_jamming_mult") == nil then
	CreateReplConVar("sv_tfa_jamming_mult", "1", "Multiply jam chance by this value. You really should modify sv_tfa_jamming_factor_inc rather than this.")
end

if GetConVar("sv_tfa_jamming_factor") == nil then
	CreateReplConVar("sv_tfa_jamming_factor", "1", "Multiply jam factor by this value")
end

if GetConVar("sv_tfa_jamming_factor_inc") == nil then
	CreateReplConVar("sv_tfa_jamming_factor_inc", "1", "Multiply jam factor gain by this value")
end

if GetConVar("sv_tfa_nearlyempty") == nil then
	CreateReplConVar("sv_tfa_nearlyempty", "1", "Enable nearly-empty sounds")
end

if GetConVar("sv_tfa_fixed_crosshair") == nil then
	CreateReplConVar("sv_tfa_fixed_crosshair", "0", "Fix crosshair position on center of the screen (CS:GO style)")
end

if GetConVar("sv_tfa_crosshair_showplayer") == nil then
	CreateReplConVar("sv_tfa_crosshair_showplayer", "1", "Crosshair team color option reveals players")
end

if GetConVar("sv_tfa_crosshair_showplayerteam") == nil then
	CreateReplConVar("sv_tfa_crosshair_showplayerteam", engine.ActiveGamemode() == "terrortown" and "0" or "1", "Crosshair team color option reveals players's team")
end

if GetConVar("sv_tfa_weapon_weight") == nil then
	CreateReplConVar("sv_tfa_weapon_weight", "1", "Disabling this WILL break certain SWEPs and Mechanics. You were warned.")
end

--addons/tfa_base/lua/tfa/modules/tfa_data.lua:
-- This file is holding seamless translation of older versions of data to newer
-- versions of data

TFA.LatestDataVersion = 1

TFA.DataVersionMapping = {
	[0] = {
		{
			old_path = "DrawCrosshairIS",
			new_path = "DrawCrosshairIronSights",
		},

		{
			old_path = "FiresUnderwater",
			new_path = "Primary.FiresUnderwater",
		},

		{
			old_path = "PenetrationMaterials",
			new_path = "Primary.PenetrationMaterials",
		},

		{
			old_path = "MaxPenetrationCounter",
			new_path = "Primary.MaxSurfacePenetrationCount",
		},

		{
			old_path = "MaxPenetration",
			new_path = "Primary.MaxSurfacePenetrationCount",
		},

		{
			old_path = "IronRecoilMultiplier",
			new_path = "Primary.IronRecoilMultiplier",
		},

		{
			old_path = "MoveSpeed",
			new_path = "RegularMoveSpeedMultiplier",
		},

		{
			old_path = "IronSightsMoveSpeed",
			new_path = "AimingDownSightsSpeedMultiplier",
		},

		{
			old_path = "Shotgun",
			new_path = "LoopedReload",
		},

		{
			old_path = "ShellTime",
			new_path = "LoopedReloadInsertTime",
		},

		{
			old_path = "CrouchPos",
			new_path = "CrouchViewModelPosition",
		},

		{
			old_path = "CrouchAng",
			new_path = "CrouchViewModelAngle",
		},

		{
			old_path = "data.ironsights",
			new_path = "Secondary.IronSightsEnabled",
			upgrade = function(value) return value == 1 end,
			downgrade = function(value) return value and 1 or 0 end,
		},

		{
			old_path = "Secondary.IronFOV",
			new_path = "Secondary.OwnerFOV",
		},

		{
			old_path = "IronViewModelFOV",
			new_path = "Secondary.ViewModelFOV",
		},

		{
			old_path = "DoProceduralReload",
			new_path = "IsProceduralReloadBased",
		},

		{
			old_path = "ProceduralReloadEnabled",
			new_path = "IsProceduralReloadBased",
		},

		{
			old_path = "Akimbo",
			new_path = "IsAkimbo",
		},

		{
			old_path = "AkimboHUD",
			new_path = "EnableAkimboHUD",
		},

		{
			old_path = "IronInSound",
			new_path = "Secondary.IronSightsInSound",
		},

		{
			old_path = "IronOutSound",
			new_path = "Secondary.IronSightsOutSound",
		},

		{
			old_path = "DisableChambering",
			new_path = "Primary.DisableChambering",
		},

		{
			old_path = "DisplayFalloff",
			new_path = "Primary.DisplayFalloff",
		},

		{
			old_path = "SpreadBiasYaw",
			new_path = "Primary.SpreadBiasYaw",
		},

		{
			old_path = "SpreadBiasPitch",
			new_path = "Primary.SpreadBiasPitch",
		},

		{
			old_path = "VMPos",
			new_path = "ViewModelPosition",
		},

		{
			old_path = "VMAng",
			new_path = "ViewModelAngle",
		},

		{
			old_path = "VMPos_Additive",
			new_path = "AdditiveViewModelPosition",
		},

		{
			old_path = "RunSightsPos",
			new_path = "SprintViewModelPosition",
		},

		{
			old_path = "RunSightsAng",
			new_path = "SprintViewModelAngle",
		},

		{
			old_path = "IronSightsPos",
			new_path = "IronSightsPosition",
		},

		{
			old_path = "IronSightsAng",
			new_path = "IronSightsAngle",
		},

		{
			old_path = "Bodygroups_V",
			new_path = "ViewModelBodygroups",
		},

		{
			old_path = "Bodygroups_W",
			new_path = "WorldModelBodygroups",
		},

		{
			old_path = "CenteredPos",
			new_path = "CenteredViewModelPosition",
		},

		{
			old_path = "CenteredAng",
			new_path = "CenteredViewModelAngle",
		},

		{
			old_path = "Offset",
			new_path = "WorldModelOffset",
		},

		{
			old_path = "ProceduralHolsterPos",
			new_path = "ProceduralHolsterPosition",
		},

		{
			old_path = "ProceduralHolsterAng",
			new_path = "ProceduralHolsterAngle",
		},

		{
			old_path = "VElements",
			new_path = "ViewModelElements",
		},

		{
			old_path = "WElements",
			new_path = "WorldModelElements",
		},
	}
}

local function identity(...) return ... end

for version = 0, #TFA.DataVersionMapping do
	for i, data in ipairs(TFA.DataVersionMapping[version]) do
		if not isfunction(data.upgrade) then data.upgrade = identity end
		if not isfunction(data.downgrade) then data.downgrade = identity end
	end
end

TFA.PathParseCache = {}
TFA.PathParseCacheTR = {}
TFA.StatPathRemapCache = {}
TFA.PathParseCacheDirect = {}
TFA.PathParseChildren = {}

local PathParseCache = TFA.PathParseCache
local PathParseCacheTR = TFA.PathParseCacheTR
local PathParseCacheDirect = TFA.PathParseCacheDirect
local StatPathRemapCache = TFA.StatPathRemapCache
local PathParseChildren = TFA.PathParseChildren
local string_Explode = string.Explode
local ipairs = ipairs
local pairs = pairs
local string_sub = string.sub
local tonumber = tonumber
local table_Copy = table.Copy
local table_concat = table.concat
local istable = istable
local string_format = string.format

local function doDowngrade(path, migrations)
	for i, data in ipairs(migrations) do
		if data.new_path == path then
			return data.old_path, data.upgrade
		elseif path:StartWith(data.new_path) and path[#data.new_path + 1] == '.' then
			return data.old_path .. path:sub(#data.new_path + 1), data.upgrade
		end
	end

	return path
end

local function doUpgrade(path, migrations)
	for i, data in ipairs(migrations) do
		if data.old_path == path then
			return data.new_path, data.downgrade
		elseif path:StartWith(data.old_path) and path[#data.old_path + 1] == '.' then
			return data.new_path .. path:sub(#data.old_path + 1), data.downgrade
		end
	end

	return path
end

function TFA.RemapStatPath(path, path_version, structure_version)
	local cache_path = path

	if path_version == nil then path_version = 0 end
	if structure_version == nil then structure_version = 0 end

	-- version do not match
	if path_version ~= structure_version then
		cache_path = string_format("%d_%d_%s", path_version, structure_version, path)
	end

	local get_cache = StatPathRemapCache[cache_path]
	if get_cache ~= nil then return get_cache end

	if cache_path ~= path then
		-- downgrade path
		if path_version > structure_version then
			for version = path_version, structure_version, -1 do
				local mapping = TFA.DataVersionMapping[version]

				if istable(mapping) then
					path = doDowngrade(path, mapping)
				end
			end
		else -- upgrade path
			for version = path_version, structure_version do
				local mapping = TFA.DataVersionMapping[version]

				if istable(mapping) then
					path = doUpgrade(path, mapping)
				end
			end
		end
	end

	StatPathRemapCache[cache_path] = path
	return StatPathRemapCache[cache_path]
end

function TFA.GetStatPathChildren(path, path_version, structure_version)
	-- version do not match
	if path_version ~= structure_version then
		path = TFA.RemapStatPath(path, path_version, structure_version)
	end

	if not PathParseChildren[path] then
		TFA.GetStatPath(path, path_version, structure_version)
	end

	return PathParseChildren[path].list
end

local function concat_to(tab, to)
	local str = tab[1]

	for i = 2, to do
		str = str .. '.' .. tab[i]
	end

	return str
end

local function concat_from(tab, from)
	local str = tab[from]

	for i = from + 1, #tab do
		str = str .. '.' .. tab[i]
	end

	return str
end

function TFA.GetStatPath(path, path_version, structure_version, no_translate)
	local cache_path = path

	if path_version == nil then path_version = 0 end
	if structure_version == nil then structure_version = 0 end

	-- version do not match
	if path_version ~= structure_version then
		cache_path = string_format("%d_%d_%s", path_version, structure_version, path)
	end

	local _PathParseCache = no_translate and PathParseCacheTR or PathParseCache
	local get_cache = _PathParseCache[cache_path]
	if get_cache ~= nil then return get_cache[1], get_cache[2], get_cache[3] end

	local fn, fnGet

	if cache_path ~= path then
		-- downgrade
		if path_version > structure_version then
			for version = path_version, structure_version, -1 do
				local mapping = TFA.DataVersionMapping[version]

				if istable(mapping) then
					path, fnGet = doDowngrade(path, mapping)

					if fnGet and fnGet ~= identity then
						if not fn then
							fn = fnGet
						else
							local _fn = fn
							function fn(...) return fnGet(_fn(...)) end
						end
					end
				end
			end
		else -- upgrade
			for version = path_version, structure_version do
				local mapping = TFA.DataVersionMapping[version]

				if istable(mapping) then
					path, fnGet = doUpgrade(path, mapping)

					if fnGet and fnGet ~= identity then
						if not fn then
							fn = fnGet
						else
							local _fn = fn
							function fn(...) return fnGet(_fn(...)) end
						end
					end
				end
			end
		end
	end

	get_cache = string_Explode(".", path, false)

	do
		local children = PathParseChildren[get_cache[1]]

		if not children then
			children = {
				list = {get_cache[1]},
				children = {}
			}

			PathParseChildren[get_cache[1]] = children
		end

		local childrens = {children}

		for i = 2, #get_cache do
			local obj = get_cache[i]
			local path2 = concat_to(get_cache, i)

			for i3 = 1, #childrens do
				local list = childrens[i3].list
				local hit = false

				for i2 = 1, #list do
					if list[i2] == path2 then
						hit = true
						break
					end
				end

				if not hit then
					table.insert(list, path2)
				end
			end

			if not children.children[obj] then
				children.children[obj] = {
					list = {path2},
					children = {}
				}
			end

			if not PathParseChildren[path2] then
				PathParseChildren[path2] = {
					list = {path2},
					children = {}
				}
			end

			children = children.children[obj]
			table.insert(childrens, children)
			table.insert(childrens, PathParseChildren[path2])
		end
	end

	if not no_translate then
		if get_cache[1] == "Primary" then
			get_cache[1] = "Primary_TFA"
		elseif get_cache[1] == "Secondary" then
			get_cache[1] = "Secondary_TFA"
		end
	end

	for k, v in ipairs(get_cache) do
		get_cache[k] = tonumber(v) or v
	end

	_PathParseCache[cache_path] = {get_cache, path, fn or identity}
	return get_cache, path, fn or identity
end

function TFA.GetStatPathRaw(path)
	local get_cache = PathParseCacheDirect[path]
	if get_cache ~= nil then return get_cache end

	local t_stbl = string_Explode(".", path, false)

	for k, v in ipairs(t_stbl) do
		t_stbl[k] = tonumber(v) or v
	end

	PathParseCacheDirect[path] = t_stbl
	return t_stbl
end

local GetStatPathRaw = TFA.GetStatPathRaw

do
	local function get(self, path)
		local value = self[path[1]]

		for i = 2, #path do
			if not istable(value) then return end
			value = value[path[i]]
		end

		return value
	end

	local function set(self, path, val)
		if #path == 1 then
			if self[path[1]] == nil then
				self[path[1]] = val
			end

			return
		end

		local value = self[path[1]]

		if value == nil then
			self[path[1]] = {}
			value = self[path[1]]
		end

		for i = 2, #path - 1 do
			if not istable(value) then return end
			if value[path[i]] == nil then value[path[i]] = {} end
			value = value[path[i]]
		end

		if istable(value) and value[path[#path]] == nil then
			value[path[#path]] = val
		elseif not istable(value) then
			print('[TFA Base] unable to fill gap for older version in meta structure of ' .. table_concat(path, '.'))
		end
	end

	function TFA.FillMissingMetaValues(SWEP)
		for version = TFA.LatestDataVersion, 0, -1 do
			local mapping = TFA.DataVersionMapping[version]

			if istable(mapping) then
				for i, data in ipairs(mapping) do
					local getVal = get(SWEP, GetStatPathRaw(data.new_path))

					if getVal ~= nil then
						set(SWEP, GetStatPathRaw(data.old_path), data.downgrade(getVal))
					end
				end
			end
		end
	end
end

if CLIENT then
	concommand.Add("cl_tfa_data_translatestat", function(ply, cmd, args, argStr)
		if #args <= 0 then
			print("Usage: " .. cmd .. " <stat name>")

			return
		end

		for _, arg in ipairs(args) do
			if string.StartsWith(arg, "SWEP.") or string.StartsWith(arg, "self.") then
				arg = string.sub(arg, 6)
			end

			local _, path, _ = TFA.GetStatPath(arg, 0, TFA.LatestDataVersion)
			if path then
				print("SWEP." .. arg .. " => SWEP." .. path .. " (at data version " .. TFA.LatestDataVersion .. ")")
			else
				print("Unable to lookup updated stat path for " .. arg)
			end
		end
	end)
end

--addons/tfa_base/lua/tfa/modules/tfa_ballistics.lua:
-- Degrees to accuracy vector, Valve's formula from SDK 2013
TFA.DegreesToAccuracy = math.sin((math.pi / 180) / 2) -- approx. 0.00873

--default cvar integration
local cv_gravity = GetConVar("sv_gravity")

--[[local function TimeScale(v)
	return v * game.GetTimeScale() / TFA.Ballistics.SubSteps
end]]

--init code
TFA.Ballistics = TFA.Ballistics or {}
TFA.Ballistics.Enabled = false
TFA.Ballistics.Gravity = Vector(0, 0, -cv_gravity:GetFloat())
TFA.Ballistics.Bullets = TFA.Ballistics.Bullets or {}
TFA.Ballistics.Bullets.bullet_registry = TFA.Ballistics.Bullets.bullet_registry or {}
TFA.Ballistics.BulletLife = 10
TFA.Ballistics.UnitScale = TFA.UnitScale or 39.3701 --meters to inches
TFA.Ballistics.AirResistance = 1
TFA.Ballistics.WaterResistance = 3
TFA.Ballistics.WaterEntranceResistance = 6

TFA.Ballistics.DamageVelocityLUT = {
	[13] = 350, --shotgun
	[25] = 425, --mp5k etc.
	[35] = 900, --ak-12
	[65] = 830, --SVD
	[120] = 1100 --sniper cap
}

TFA.Ballistics.VelocityMultiplier = 1
TFA.Ballistics.SubSteps = 1
TFA.Ballistics.BulletCreationNetString = "TFABallisticsBullet"

TFA.Ballistics.TracerStyles = {
	[0] = "",
	[1] = "tfa_bullet_smoke_tracer",
	[2] = "tfa_bullet_fire_tracer"
}

setmetatable(TFA.Ballistics.TracerStyles, {
	["__index"] = function(t, k) return t[math.Round(tonumber(k) or 1)] or t[1] end
})

if SERVER then
	util.AddNetworkString(TFA.Ballistics.BulletCreationNetString)
end

--bullet class
local function IncludeClass(fn)
	include("tfa/ballistics/" .. fn .. ".lua")
	AddCSLuaFile("tfa/ballistics/" .. fn .. ".lua")
end

IncludeClass("bullet")
--cvar code
local function CreateReplConVar(cvarname, cvarvalue, description, ...)
	return CreateConVar(cvarname, cvarvalue, CLIENT and {FCVAR_REPLICATED} or {FCVAR_REPLICATED, FCVAR_ARCHIVE, FCVAR_NOTIFY}, description, ...)
end -- replicated only on clients, archive/notify on server

local cv_enabled = CreateReplConVar("sv_tfa_ballistics_enabled", "0", "Enable TFA Ballistics?")
local cv_bulletlife = CreateReplConVar("sv_tfa_ballistics_bullet_life", 10, "Time to process bullets before removing.")
local cv_res_air = CreateReplConVar("sv_tfa_ballistics_bullet_damping_air", 1, "Air resistance, which makes bullets arc faster.")
local cv_res_water = CreateReplConVar("sv_tfa_ballistics_bullet_damping_water", 3, "Water resistance, which makes bullets arc faster in water.")
local cv_vel = CreateReplConVar("sv_tfa_ballistics_bullet_velocity", 1, "Global velocity multiplier for TFA ballistics bullets.")
local cv_substep = CreateReplConVar("sv_tfa_ballistics_substeps", 1, "Substeps for ballistics; more is more precise, at the cost of performance.")
local sv_tfa_ballistics_custom_gravity = CreateReplConVar("sv_tfa_ballistics_custom_gravity", 0, "Enable sv_gravity override for ballistics")
local sv_tfa_ballistics_custom_gravity_value = CreateReplConVar("sv_tfa_ballistics_custom_gravity_value", 0, "Z velocity down of custom gravity")
CreateReplConVar("sv_tfa_ballistics_mindist", -1, "Minimum distance to activate; -1 for always.")

local function updateCVars()
	TFA.Ballistics.BulletLife = cv_bulletlife:GetFloat()
	TFA.Ballistics.AirResistance = cv_res_air:GetFloat()
	TFA.Ballistics.WaterResistance = cv_res_water:GetFloat()
	TFA.Ballistics.WaterEntranceResistance = TFA.Ballistics.WaterResistance * 2
	TFA.Ballistics.VelocityMultiplier = cv_vel:GetFloat()

	if sv_tfa_ballistics_custom_gravity:GetBool() then
		TFA.Ballistics.Gravity.z = -sv_tfa_ballistics_custom_gravity_value:GetFloat()
	else
		TFA.Ballistics.Gravity.z = -cv_gravity:GetFloat()
	end

	TFA.Ballistics.Enabled = cv_enabled:GetBool()
	TFA.Ballistics.SubSteps = cv_substep:GetInt()
end

cvars.AddChangeCallback("sv_tfa_ballistics_enabled", updateCVars, "TFA")
cvars.AddChangeCallback("sv_tfa_ballistics_bullet_life", updateCVars, "TFA")
cvars.AddChangeCallback("sv_tfa_ballistics_bullet_damping_air", updateCVars, "TFA")
cvars.AddChangeCallback("sv_tfa_ballistics_bullet_damping_water", updateCVars, "TFA")
cvars.AddChangeCallback("sv_tfa_ballistics_bullet_velocity", updateCVars, "TFA")
cvars.AddChangeCallback("sv_tfa_ballistics_substeps", updateCVars, "TFA")
cvars.AddChangeCallback("sv_tfa_ballistics_mindist", updateCVars, "TFA")
cvars.AddChangeCallback("sv_tfa_ballistics_custom_gravity", updateCVars, "TFA")
cvars.AddChangeCallback("sv_tfa_ballistics_custom_gravity_value", updateCVars, "TFA")
cvars.AddChangeCallback("sv_gravity", updateCVars, "TFA Ballistics")
updateCVars()

--client cvar code
local cv_receive, cv_tracers_style, cv_tracers_mp

if CLIENT then
	cv_receive = CreateClientConVar("cl_tfa_ballistics_mp", "1", true, false, "Receive bullet data from other players?")
	CreateClientConVar("cl_tfa_ballistics_fx_bullet", "1", true, false, "Display bullet models for each TFA ballistics bullet?")
	cv_tracers_style = CreateClientConVar("cl_tfa_ballistics_fx_tracers_style", "1", true, false, "Style of tracers for TFA ballistics? 0=disable,1=smoke")
	cv_tracers_mp = CreateClientConVar("cl_tfa_ballistics_fx_tracers_mp", "1", true, false, "Enable tracers for other TFA ballistics users?")
	CreateClientConVar("cl_tfa_ballistics_fx_tracers_adv", "1", true, false, "Enable advanced tracer calculations for other users? This corrects smoke trail to their barrel")
end

--utility func
local function Remap(inp, u, v, x, y)
	return (inp - u) / (v - u) * (y - x) + x
end

--Accessors
local CopyTable = table.Copy

function TFA.Ballistics.Bullets:Add(bulletStruct, originalBulletData)
	local bullet = TFA.Ballistics:Bullet(bulletStruct)
	bullet.bul = CopyTable(originalBulletData or bullet.bul)
	bullet.last_update = CurTime() - TFA.FrameTime()

	table.insert(self.bullet_registry, bullet)

	bullet:_setup()

	if SERVER and game.GetTimeScale() > 0.99 then
		-- always update bullet since they are being added from predicted hook
		bullet:Update(CurTime())
	end
end

function TFA.Ballistics.Bullets:Update(ply)
	--local delta = TimeScale(SysTime() - (self.lastUpdate or (SysTime() - FrameTime())))
	local delta = CurTime()

	--self.lastUpdate = SysTime()
	local toremove
	local lply = CLIENT and LocalPlayer()

	for i, bullet in ipairs(self.bullet_registry) do
		if bullet.delete then
			if not toremove then
				toremove = {}
			end

			table.insert(toremove, i)
		elseif not ply and not bullet.playerOwned or CLIENT and bullet.owner ~= lply or ply == bullet.owner then
			for _ = 1, TFA.Ballistics.SubSteps do
				bullet:Update(delta)
			end
		end
	end

	if toremove then
		for i = #toremove, 1, -1 do
			table.remove(self.bullet_registry, toremove[i])
		end
	end
end

function TFA.Ballistics:AutoDetectVelocity(damage)
	local lutMin, lutMax, LUT, DMGs
	LUT = self.DamageVelocityLUT
	DMGs = table.GetKeys(LUT)
	table.sort(DMGs)

	for _, v in ipairs(DMGs) do
		if v < damage then
			lutMin = v
		elseif lutMin then
			lutMax = v
			break
		end
	end

	if not lutMax then
		lutMax = DMGs[#DMGs]
		lutMin = DMGs[#DMGs - 1]
	elseif not lutMin then
		lutMin = DMGs[1]
		lutMax = DMGs[2]
	end

	return Remap(damage, lutMin, lutMax, LUT[lutMin], LUT[lutMax])
end

function TFA.Ballistics:ShouldUse(wep)
	if not IsValid(wep) or not wep.IsTFAWeapon then
		return false
	end

	local shouldUse = wep:GetStatL("UseBallistics")

	if shouldUse == nil then
		if wep:GetStatL("TracerPCF") then
			return false
		end

		return self.Enabled
	else
		return shouldUse
	end
end

local sv_tfa_recoil_legacy = GetConVar("sv_tfa_recoil_legacy")

function TFA.Ballistics:FireBullets(wep, bulletStruct, angIn, bulletOverride)
	if not IsValid(wep) then return end
	if not IsValid(wep:GetOwner()) then return end

	local vel

	if bulletStruct.Velocity then
		vel = bulletStruct.Velocity
	elseif wep.GetStat and wep:GetStatL("Primary.Velocity") then
		vel = wep:GetStatL("Primary.Velocity") * TFA.Ballistics.UnitScale
	elseif wep.Primary and wep.Primary.Velocity then
		vel = wep.Primary.Velocity * TFA.Ballistics.UnitScale
	elseif wep.Velocity then
		vel = wep.Velocity * TFA.Ballistics.UnitScale
	else
		local dmg

		if wep.GetStat and wep:GetStatL("Primary.Damage") then
			dmg = wep:GetStatL("Primary.Damage")
		else
			dmg = wep.Primary.Damage or wep.Damage or 30
		end

		vel = TFA.Ballistics:AutoDetectVelocity(dmg) * TFA.Ballistics.UnitScale
	end

	vel = vel * (TFA.Ballistics.VelocityMultiplier or 1)

	local oldNum = bulletStruct.Num
	bulletStruct.Num = 1
	bulletStruct.IsBallistics = true

	local owner = wep:GetOwner()
	local isnpc = owner:IsNPC()
	local ac = bulletStruct.Spread
	local sharedRandomSeed = "Ballistics" .. CurTime()

	for i = 1, oldNum do
		local ang

		if angIn then
			ang = angIn
		else
			ang = owner:GetAimVector():Angle()

			if sv_tfa_recoil_legacy:GetBool() and not isnpc then
				ang:Add(owner:GetViewPunchAngles())
			else
				ang.p = ang.p + wep:GetViewPunchP()
				ang.y = ang.y + wep:GetViewPunchY()
			end
		end

		if not angIn then
			ang:RotateAroundAxis(ang:Up(), util.SharedRandom(sharedRandomSeed, -ac.x * 45, ac.x * 45, 0 + i))
			ang:RotateAroundAxis(ang:Right(), util.SharedRandom(sharedRandomSeed, -ac.y * 45, ac.y * 45, 1 + i))
		end

		local struct = {
			owner = owner, --used for dmginfo SetAttacker
			inflictor = wep, --used for dmginfo SetInflictor
			damage = bulletStruct.Damage, --floating point number representing inflicted damage
			force = bulletStruct.Force,
			pos = bulletOverride and bulletStruct.Src or owner:GetShootPos(), --b.Src, --vector representing current position
			velocity = (bulletOverride and bulletStruct.Dir or ang:Forward()) * vel, --b.Dir * vel, --vector representing movement velocity
			model = wep.BulletModel or bulletStruct.Model, --optional variable representing the given model
			smokeparticle = bulletStruct.SmokeParticle,
			customPosition = bulletStruct.CustomPosition or bulletOverride,
			IgnoreEntity = bulletStruct.IgnoreEntity
		}

		if CLIENT then
			if not struct.smokeparticle then
				struct.smokeparticle = TFA.Ballistics.TracerStyles[cv_tracers_style:GetInt()]
			end
		end

		self.Bullets:Add(struct, bulletStruct)

		if SERVER then
			net.Start(TFA.Ballistics.BulletCreationNetString)

			net.WriteEntity(struct.owner)
			net.WriteEntity(struct.inflictor)
			net.WriteFloat(struct.damage)
			net.WriteFloat(struct.force)
			net.WriteVector(struct.pos)

			net.WriteDouble(struct.velocity.x)
			net.WriteDouble(struct.velocity.y)
			net.WriteDouble(struct.velocity.z)

			net.WriteString(struct.model or '')
			net.WriteString(struct.smokeparticle or '')
			net.WriteBool(struct.customPosition == true)
			net.WriteEntity(struct.IgnoreEntity or NULL)

			net.WriteVector(bulletStruct.Src)
			net.WriteNormal(bulletStruct.Dir)
			net.WriteEntity(bulletStruct.Attacker)
			net.WriteVector(bulletStruct.Spread)
			net.WriteFloat(vel)

			if game.SinglePlayer() or isnpc then
				net.SendPVS(struct.pos)
			else
				net.SendOmit(owner)
			end
		end
	end
end

function TFA.Ballistics.Bullets:Render()
	for i = 1, #self.bullet_registry do
		self.bullet_registry[i]:Render()
	end
end

local sp = game.SinglePlayer()

--Netcode and Hooks
if CLIENT then
	net.Receive(TFA.Ballistics.BulletCreationNetString, function()
		if not sp and not cv_receive:GetBool() then return end

		local owner =           net.ReadEntity()
		local inflictor =       net.ReadEntity()
		local damage =          net.ReadFloat()
		local force =           net.ReadFloat()
		local pos =             net.ReadVector()
		local velocity =        Vector(net.ReadDouble(), net.ReadDouble(), net.ReadDouble())
		local model =           net.ReadString()
		local smokeparticle =   net.ReadString()
		local customPosition =  net.ReadBool()
		local IgnoreEntity =    net.ReadEntity()


		local Src =             net.ReadVector()
		local Dir =             net.ReadNormal()
		local Attacker =        net.ReadEntity()
		local Spread =          net.ReadVector()
		local Velocity =        net.ReadFloat()

		if not IsValid(owner) or not IsValid(inflictor) then return end

		if not cv_tracers_mp:GetBool() and owner ~= LocalPlayer() then
			smokeparticle = ""
		elseif smokeparticle == "" then
			smokeparticle = TFA.Ballistics.TracerStyles[cv_tracers_style:GetInt()]
		end

		local struct = {
			owner = owner,
			inflictor = inflictor,
			damage = damage,
			force = force,
			pos = pos,
			velocity = velocity,
			model = model ~= "" and model or nil,
			smokeparticle = smokeparticle,
			customPosition = customPosition,
			IgnoreEntity = IgnoreEntity,
		}

		local bulletStruct = {
			Damage = damage,
			Force = force,
			Num = 1,
			Src = Src,
			Dir = Dir,
			Attacker = Attacker,
			Spread = Spread,
			SmokeParticle = smokeparticle,
			CustomPosition = customPosition,
			Model = model ~= "" and model or nil,
			Velocity = Velocity,
			IsBallistics = true,
		}

		TFA.Ballistics.Bullets:Add(struct, bulletStruct)
	end)
end

if CLIENT then
	hook.Add("FinishMove", "TFABallisticsTick", function(self)
		if IsFirstTimePredicted() then
			TFA.Ballistics.Bullets:Update(self)
		end
	end)
else
	hook.Add("PlayerPostThink", "TFABallisticsTick", function(self)
		TFA.Ballistics.Bullets:Update(self)
	end)
end

hook.Add("Tick", "TFABallisticsTick", function()
	TFA.Ballistics.Bullets:Update()

	if CLIENT and sp then
		TFA.Ballistics.Bullets:Update(LocalPlayer())
	end
end)

--Rendering
hook.Add("PostDrawOpaqueRenderables", "TFABallisticsRender", function()
	TFA.Ballistics.Bullets:Render()
end)

--addons/tfa_base/lua/tfa/modules/tfa_keyvalues.lua:
local CHAR_STRING = {
	["\""] = true,
	["'"] = true
}

local CHAR_TABLE_OPEN = {
	["{"] = true,
	["["] = true
}

local CHAR_TABLE_CLOSE = {
	["}"] = true,
	["]"] = true
}

local CHAR_WHITESPACE = {
	[" "] = true,
	["\t"] = true,
	["\r"] = true,
	["\n"] = true
}

local CHAR_NEWLINE = {
	["\r"] = true,
	["\n"] = true
}

local CHAR_COMMENT = {
	["/"] = true,
	["-"] = true
}

local KEY_CASE = true
local ORDERED = false

local buffer = ""
local tbl = {}
local tbl_focus
local tbl_tmp
local value, lastvalue
local ignore_next_pop
local escape
local stringtype
local is_comment = false
local f

local strsub = string.sub
local strlow = string.lower

local fread = file.Read

local function strchar( strv, ind )
	return strsub( strv, ind, ind)
end

local function ResetValues()
	lastvalue = nil
	value = nil
end

local function FlushBuffer(write)
	if buffer ~= "" or stringtype then
		lastvalue = value
		if lastvalue and not KEY_CASE then
			lastvalue = strlow(lastvalue)
		end
		value = buffer
		buffer = ""

		if tbl_focus and (write == nil or write) and lastvalue and value then
			if ORDERED then
				tbl_focus[ #tbl_focus + 1 ] = { ["key"] = lastvalue, ["value"] = value }
			else
				tbl_focus[lastvalue] = value
			end
			ResetValues()
		end
	end
end

local function PushTable()
	FlushBuffer(true)
	if value and not KEY_CASE then
		value = strlow(value)
	end
	if value and value ~= "" then
		if ORDERED then
			tbl_focus[ #tbl_focus + 1 ] = { ["key"] = value, ["value"] = {} }
			tbl_focus[ #tbl_focus ].value.__par = tbl_focus
			tbl_focus = tbl_focus[ #tbl_focus ].value
		else
			tbl_focus[value] = istable(tbl_focus[value]) and tbl_focus[value] or {}
			tbl_focus[value].__par = tbl_focus
			tbl_focus = tbl_focus[value]
		end
		ignore_next_pop = false
	else
		ignore_next_pop = true
	end

	ResetValues()
end

local function PopTable()
	if not ignore_next_pop then
		FlushBuffer(true)

		if tbl_focus.__par then
			tbl_tmp = tbl_focus.__par
			tbl_focus.__par = nil
			tbl_focus = tbl_tmp
		end
	end

	ignore_next_pop = false
	ResetValues()
end

function TFA.ParseKeyValues(fn, path, use_escape, keep_key_case, invalid_escape_addslash, ordered )
	if use_escape == nil then
		use_escape = true
	end
	if keep_key_case == nil then
		keep_key_case = true
	end
	KEY_CASE = keep_key_case
	if invalid_escape_addslash == nil then
		invalid_escape_addslash = true
	end
	if ordered then
		ORDERED = true
	else
		ORDERED = false
	end
	tbl = {}
	tbl_focus = tbl
	tbl_tmp = nil
	value = nil
	lastvalue = nil
	escape = false
	is_comment = false
	stringtype = nil
	f = fread(fn, path)
	if not f then return tbl end
	for i = 1, #f do
		local char = strchar(f,i)

		if not char then
			FlushBuffer()
			break
		end

		if is_comment then
			if CHAR_NEWLINE[char] then
				is_comment = false
			end
		elseif escape then
			if char == "t" then
				buffer = buffer .. "\t"
			elseif char == "n" then
				buffer = buffer .. "\n"
			elseif char == "r" then
				buffer = buffer
			else
				if invalid_escape_addslash then
					buffer = buffer .. "\\"
				end
				buffer = buffer .. char
			end

			escape = false
		elseif char == "\\" and use_escape then
			escape = true
		elseif CHAR_STRING[char] then
			if not stringtype then
				FlushBuffer()
				stringtype = char
			elseif stringtype == char then
				FlushBuffer()
				stringtype = nil
			elseif stringtype then
				buffer = buffer .. char
			end
		elseif stringtype then
			buffer = buffer .. char
		elseif CHAR_COMMENT[char] then
			if CHAR_COMMENT[ strchar(f,i + 1,i + 1 ) ] then
				is_comment = true
			else
				buffer = buffer .. char
			end
		elseif CHAR_WHITESPACE[char] then
			if buffer ~= "" then
				FlushBuffer()
			end
		elseif CHAR_TABLE_OPEN[char] then
			PushTable()
		elseif CHAR_TABLE_CLOSE[char] then
			PopTable()
		else
			buffer = buffer .. char
		end
	end
	return tbl
end
--addons/tfa_base/lua/tfa/modules/tfa_matproxies.lua:
local nvec = Vector()

local function SetPlayerColors(ply)
	if not IsValid(ply) then return end

	local _SetNWVector = ply.SetNW2Vector or ply.SetNWVector

	nvec.x = ply:GetInfoNum("cl_tfa_laser_color_r", 255)
	nvec.y = ply:GetInfoNum("cl_tfa_laser_color_g", 0)
	nvec.z = ply:GetInfoNum("cl_tfa_laser_color_b", 0)
	_SetNWVector(ply, "TFALaserColor", nvec)

	nvec.x = ply:GetInfoNum("cl_tfa_reticule_color_r", 255)
	nvec.y = ply:GetInfoNum("cl_tfa_reticule_color_g", 0)
	nvec.z = ply:GetInfoNum("cl_tfa_reticule_color_b", 0)
	_SetNWVector(ply, "TFAReticuleColor", nvec)
end

hook.Add("PlayerSpawn", "TFANetworkColors_Spawn", SetPlayerColors)
concommand.Add("sv_tfa_apply_player_colors", SetPlayerColors)

if not matproxy then return end

matproxy.Add({
	name = "PlayerWeaponColorStatic",
	init = function(self, mat, values)
		self.ResultTo = values.resultvar
	end,
	bind = function(self, mat, ent)
		if (not IsValid(ent)) then return end
		local owner = ent:GetOwner()
		if (not IsValid(owner) or not owner:IsPlayer()) then return end
		local col = owner:GetWeaponColor()
		if (not isvector(col)) then return end
		mat:SetVector(self.ResultTo, col * 1)
	end
})

local cvec = Vector()

matproxy.Add({
	name = "TFALaserColor",
	init = function(self, mat, values)
		self.ResultTo = values.resultvar
	end,
	bind = function(self, mat, ent)
		local owner

		if (IsValid(ent)) then
			owner = ent:GetOwner()

			if not IsValid(owner) then
				owner = ent:GetParent()
			end

			if IsValid(owner) and owner:IsWeapon() then
				owner = owner:GetOwner() or owner:GetOwner()
			end

			if not (IsValid(owner) and owner:IsPlayer()) then
				owner = GetViewEntity()
			end
		else
			owner = GetViewEntity()
		end

		if (not IsValid(owner) or not owner:IsPlayer()) then return end
		local c

		if owner.GetNW2Vector then
			c = owner:GetNW2Vector("TFALaserColor") or cvec
		else
			c = owner:GetNWVector("TFALaserColor") or cvec
		end

		cvec.x = math.sqrt(c.r / 255) --sqrt for gamma
		cvec.y = math.sqrt(c.g / 255)
		cvec.z = math.sqrt(c.b / 255)
		mat:SetVector(self.ResultTo, cvec)
	end
})

local cvec_r = Vector()

matproxy.Add({
	name = "TFAReticuleColor",
	init = function(self, mat, values)
		self.ResultTo = values.resultvar
	end,
	bind = function(self, mat, ent)
		local owner

		if (IsValid(ent)) then
			owner = ent:GetOwner()

			if not IsValid(owner) then
				owner = ent:GetParent()
			end

			if IsValid(owner) and owner:IsWeapon() then
				owner = owner:GetOwner() or owner:GetOwner()
			end

			if not (IsValid(owner) and owner:IsPlayer()) then
				owner = GetViewEntity()
			end
		else
			owner = GetViewEntity()
		end

		if (not IsValid(owner) or not owner:IsPlayer()) then return end
		local c

		if owner.GetNW2Vector then
			c = owner:GetNW2Vector("TFAReticuleColor") or cvec_r
		else
			c = owner:GetNWVector("TFAReticuleColor") or cvec_r
		end

		cvec_r.x = c.r / 255
		cvec_r.y = c.g / 255
		cvec_r.z = c.b / 255
		mat:SetVector(self.ResultTo, cvec_r)
	end
})

matproxy.Add({
	name = "TFA_RTScope",
	init = function(self, mat, values)
		self.RTMaterial = Material("!tfa_rtmaterial")
	end,
	bind = function(self, mat, ent)
		if not self.RTMaterial then
			self.RTMaterial = Material("!tfa_rtmaterial")
		end

		mat:SetTexture("$basetexture", self.RTMaterial:GetTexture("$basetexture"))
	end
})

local Lerp = Lerp
local RealFrameTime = RealFrameTime

local vector_one = Vector(1, 1, 1)

matproxy.Add({
	name = "TFA_CubemapTint",
	init = function(self, mat, values)
		self.ResultVar = values.resultvar or "$envmaptint"
		self.MultVar = values.multiplier
	end,
	bind = function(self, mat, ent)
		local tint = vector_one

		if IsValid(ent) then
			local mult = self.MultVar and mat:GetVector(self.MultVar) or vector_one

			tint = Lerp(RealFrameTime() * 10, mat:GetVector(self.ResultVar), mult * render.GetLightColor(ent:GetPos()))
		end

		mat:SetVector(self.ResultVar, tint)
	end
})

-- VMT Example:
--[[
	$envmapmultiplier	"[1 1 1]" // Lighting will be multiplied by this value

	Proxies
	{
		TFA_CubemapTint
		{
			resultvar	$envmaptint // Write final output to $envmaptint
			multiplier	$envmapmultiplier // Use our value for default envmap tint
		}
	}
]]

--addons/tfa_base/lua/tfa/modules/tfa_melee_autorun.lua:
local vector_origin = Vector()

local timed_blocking_cv = GetConVar("sv_tfa_melee_blocking_timed")
local angle_mult_cv = GetConVar("sv_tfa_melee_blocking_anglemult")
local deflect_cv = GetConVar("sv_tfa_melee_blocking_deflection")
local stun_cv = GetConVar("sv_tfa_melee_blocking_stun_enabled")
local stuntime_cv = GetConVar("sv_tfa_melee_blocking_stun_time")

local bul = {
	HullSize = 5,
	Num = 1,
	Tracer = 1,
	AmmoType = "",
	TracerName = "Tracer",
	Spread = Vector(0.05,0.05,0),
	Distance = 56756
}

local function CanDeflect()
	return true
end

local function DeflectBullet( ent, dmginfo, olddmg )
	if dmginfo:IsDamageType( DMG_BULLET ) and CanDeflect() and ent.FireBullets then
		bul.Src = ent:GetShootPos()
		bul.Dir = ent:EyeAngles():Forward()
		bul.Damage = olddmg
		bul.Force = olddmg / 10
		local atk = dmginfo:GetAttacker()
		if IsValid( atk ) and atk.TFALastTracer then
			bul.Tracer = atk.TFALastTracer
		end
		ent:FireBullets( bul, false )
		dmginfo:ScaleDamage(0)
	end
end

local stuntime = 0.65

local function StunNPC( npc, ply )
	if stun_cv and not stun_cv:GetBool() then return end
	if ( not IsValid( npc ) ) or ( not npc:IsNPC() ) then
		return
	end
	if npc.ClearSchedule then
		npc:ClearSchedule()
	end
	if npc.SetEnemy then
		npc:SetEnemy(nil)
	end
	if npc.AddEntityRelationship and IsValid(ply) then
		local oldrel = npc.GetRelationship and npc:GetRelationship(ply) or D_HT
		npc:AddEntityRelationship( ply, D_NU, 99)
		stuntime = stuntime_cv:GetFloat()
		timer.Simple( stuntime , function()
			if IsValid(npc) and npc:IsNPC() and IsValid(ply) then
				npc:AddEntityRelationship( ply, oldrel, 99)
			end
		end)
	end
	if npc.ClearEnemyMemory then
		npc:ClearEnemyMemory()
	end
end

local function BlockDamageNew( ent, dmginfo )
	if not ent:IsPlayer() then return end
	if dmginfo:IsDamageType( DMG_DROWNRECOVER ) or dmginfo:IsDamageType(DMG_DIRECT) then return end
	local wep
	wep = ent:GetActiveWeapon()

	if (wep.IsTFAWeapon and wep.BlockDamageTypes and wep:GetStatus() == TFA.Enum.STATUS_BLOCKING) then
		local canblock = false
		for _,v in ipairs(wep.BlockDamageTypes) do
			if dmginfo:IsDamageType(v) then canblock = true end
		end

		local retVal = hook.Run("TFA_MeleeCanBlockDamage", wep, ent, dmginfo, canblock)
		if retVal ~= nil then
			canblock = retVal
		end

		if canblock then
			local damageinflictor, blockthreshold
			damageinflictor = dmginfo:GetInflictor()

			if (not IsValid(damageinflictor)) then
				damageinflictor = dmginfo:GetAttacker()
			end

			blockthreshold = ( wep.BlockCone or 135 ) / 2
			if angle_mult_cv then
				blockthreshold = blockthreshold * angle_mult_cv:GetFloat()
			end
			if ( IsValid(damageinflictor) and ( math.abs(math.AngleDifference( ent:EyeAngles().y, ( damageinflictor:GetPos() - ent:GetPos() ):Angle().y )) <= blockthreshold)) then
				local fac = math.Clamp( ( CurTime() - wep:GetBlockStart() - wep.BlockTimeWindow ) / wep.BlockTimeFade, 0, 1)
				local dmgscale
				if ( not timed_blocking_cv ) or timed_blocking_cv:GetBool() then
					dmgscale = Lerp(fac, wep.BlockDamageMaximum, wep.BlockDamageMinimum)
				else
					dmgscale = wep.BlockDamageMaximum
				end
				local olddmg = dmginfo:GetDamage()
				dmgscale = math.min( dmgscale, wep.BlockDamageCap / dmginfo:GetDamage() )
				--print(fac)
				dmginfo:ScaleDamage(dmgscale)
				dmginfo:SetDamagePosition(vector_origin)
				dmginfo:SetDamageType( bit.bor( dmginfo:GetDamageType(), DMG_DROWNRECOVER ) )
				wep:EmitSound(wep.BlockSound or "")

				if wep.ChooseBlockAnimation then
					wep:ChooseBlockAnimation()
				end

				if deflect_cv and deflect_cv:GetInt() == 2 then
					DeflectBullet( ent, dmginfo, olddmg )
				end

				if dmginfo:GetDamage() < 1 then
					if deflect_cv and deflect_cv:GetInt() == 1 and wep.BlockCanDeflect then
						DeflectBullet( ent, dmginfo, olddmg )
					end
					StunNPC( dmginfo:GetAttacker(), ent )
					return true
				end
				return
			end
		end
	end
end


hook.Add("EntityFireBullets","TFA_Melee_LogTracer",function(ent,bulv) --Record tracer for blocking
	ent.TFALastTracer = bulv.TracerName or ""
end)

local npc_dmg_scale_cv = GetConVar("sv_tfa_melee_damage_npc")
local ply_dmg_scale_cv = GetConVar("sv_tfa_melee_damage_ply")

hook.Add("EntityTakeDamage", "TFA_Melee_Scaling", function( ent, dmginfo )
	local wep = dmginfo:GetInflictor()
	if not IsValid(wep) then return end

	if wep:IsPlayer() then wep = wep:GetActiveWeapon() end
	if not IsValid(wep) or not wep:IsWeapon() or not wep.IsTFAWeapon or not wep.IsMelee then return end

	if ent:IsNPC() then
		dmginfo:ScaleDamage( npc_dmg_scale_cv:GetFloat() )
	elseif ent:IsPlayer() then
		dmginfo:ScaleDamage( ply_dmg_scale_cv:GetFloat() )
	end
end) --Cancel
hook.Add("EntityTakeDamage", "aaa_TFA_Melee_Block", function( ent, dmginfo )
	return BlockDamageNew( ent, dmginfo )
end) --Cancel
hook.Add("ScalePlayerDamage", "aaa_TFA_Melee_Block", function( ent, _, dmginfo ) --Cancel
	return BlockDamageNew( ent, dmginfo )
end)

game.AddAmmoType({
	name = "TFMSwordHitGenericSlash",
	dmgtype = DMG_SLASH,
	tracer = TRACER_NONE
})

local function TFMPlayerSpawn(ply)
	ply:SetNW2Vector("TFM_SwordPosition", Vector(1, 1, 1))
	ply:SetNW2Vector("TFM_SwordNormal", Vector(1, 1, 1))
	ply:SetNW2Bool("TFM_IsSprinting", false)
	ply:SetNW2Bool("TFM_IsBlocking", false)
	ply:SetNW2Bool("TFM_IsSwinging", false)
	ply:SetNW2Float("TFM_SwingStart", CurTime())
end

hook.Add("PlayerSpawn", "TFM_PlayerSpawn", TFMPlayerSpawn)

hook.Add("EntityTakeDamage", "TFM_Block", function(ent, dmginfo) --Legacy
	if ent:IsPlayer() then
		local wep
		wep = ent:GetActiveWeapon()

		if (wep.IsTFAWeapon and wep.BlockAngle) and (dmginfo:IsDamageType(DMG_SLASH) or dmginfo:IsDamageType(DMG_CLUB) or (wep.NinjaMode and wep.NinjaMode == true and (dmginfo:IsDamageType(DMG_CRUSH) or dmginfo:IsDamageType(DMG_BULLET)))) and wep:GetIronSights() then
			local damageinflictor, blockthreshold
			damageinflictor = dmginfo:GetInflictor()

			if (not IsValid(damageinflictor)) then
				damageinflictor = dmginfo:GetAttacker()
			end

			blockthreshold = wep.BlockAngle / 2 or 90

			if (IsValid(damageinflictor) and (math.abs((ent:GetAimVector():Angle() - (damageinflictor:GetPos() - ent:GetPos()):Angle()).y) <= blockthreshold)) or (math.abs((ent:GetAimVector():Angle() - (dmginfo:GetDamagePosition() - ent:GetPos()):Angle()).y) <= blockthreshold) then
				local fac = math.Clamp((CurTime() - wep:GetBlockStart() - wep.BlockWindow) / wep.BlockFadeTime, 0, 1)
				local dmgscale
				if ( not timed_blocking_cv ) or timed_blocking_cv:GetBool() then
					dmgscale = Lerp(fac, wep.BlockMaximum, wep.BlockMinimum)
				else
					dmgscale = wep.BlockMaximum
				end
				--print(fac)
				dmginfo:ScaleDamage(dmgscale)
				dmginfo:SetDamagePosition(vector_origin)
				wep:EmitSound(wep.Primary.Sound_Impact_Metal)

				if wep.BlockAnim then
					wep:BlockAnim()
				end
			end
		end
	end
end)
--Getting the position and angle of an attachment and sending it back to the server is wayyy too laggy.  Must be pre-coded.
--[[
if SERVER then
	util.AddNetworkString( "TFM_SAPacket" )
	net.Receive("TFM_SAPacket", function()
		local ply;
		ply = net.ReadEntity()
		local pos;
		pos = net.ReadVector()
		local norm;
		norm = net.ReadNormal()
		if IsValid(ply) then
			if pos and norm then
				ply:SetNW2Vector("TFM_SwordPosition",pos)
				ply:SetNW2Vector("TFM_SwordNormal",norm)
			end
		end
	end)
end
]]
--
--addons/tfa_base/lua/tfa/modules/tfa_meta.lua:
local WEAPON = FindMetaTable("Weapon")

if WEAPON then
	function WEAPON:IsTFA() -- please do not use, just check for IsTFAWeapon directly
		return self.IsTFAWeapon
	end
else
	print("[TFA Base] Can't find weapon metatable!")
end

local PLAYER = FindMetaTable("Player")

if PLAYER then
	function PLAYER:TFA_ZoomKeyDown()
		if not IsValid(self) then return false end

		return self:GetNW2Bool("TFA_ZoomKeyDown", false)
	end

	function PLAYER:TFA_SetZoomKeyDown(isdown)
		if not IsValid(self) then return end

		self:SetNW2Bool("TFA_ZoomKeyDown", isdown)
	end
else
	print("[TFA Base] Can't find player metatable!")
end

--addons/tfa_base/lua/tfa/modules/tfa_netcode.lua:
if SERVER then
	--Pool netstrings
	util.AddNetworkString("tfaSoundEvent")
	util.AddNetworkString("tfaSoundEventStop")
	util.AddNetworkString("tfa_base_muzzle_mp")
	util.AddNetworkString("tfaShotgunInterrupt")
	util.AddNetworkString("tfaRequestFidget")
	util.AddNetworkString("tfaSDLP")
	util.AddNetworkString("tfaArrowFollow")
	util.AddNetworkString("tfaTracerSP")
	util.AddNetworkString("tfaBaseShellSV")
	--util.AddNetworkString("tfaAltAttack")

	util.AddNetworkString("tfaHitmarker")
	util.AddNetworkString("tfaHitmarker3D")
	util.AddNetworkString("tfa_friendly_encounter")

	do
		local old_state = false

		timer.Create("tfa_friendly_encounter", 2, 0, function()
			local new_state = game.GetGlobalState("friendly_encounter") == GLOBAL_ON

			if old_state ~= new_state then
				net.Start("tfa_friendly_encounter")
				net.WriteBool(new_state)
				net.Broadcast()

				old_state = new_state
			end
		end)

		hook.Add("PlayerAuthed", "tfa_friendly_encounter", function()
			old_state = false
		end)
	end

	--Enable CKey Inspection

	net.Receive("tfaRequestFidget",function(length,client)
		local wep = client:GetActiveWeapon()
		if IsValid(wep) and wep.CheckAmmo then wep:CheckAmmo() end
	end)

	--Enable shotgun interruption
	net.Receive("tfaShotgunInterrupt", function(length, client)
		if IsValid(client) and client:IsPlayer() and client:Alive() then
			local ply = client
			local wep = ply:GetActiveWeapon()

			if IsValid(wep) and wep.ShotgunInterrupt then
				wep:ShotgunInterrupt()
			end
		end
	end)

	if game.SinglePlayer() then
		net.Receive("tfaSDLP",function(length,client)
			local bool = net.ReadBool()
			client.TFASDLP = bool
		end)
	end

	--Enable alternate attacks
	--[[
	net.Receive("tfaAltAttack", function(length, client)
		if IsValid(client) and client:IsPlayer() and client:Alive() then
			local ply = client
			wep = ply:GetActiveWeapon()

			if IsValid(wep) and wep.AltAttack then
				wep:AltAttack()
			end
		end
	end)
	]]--
else
	TFA.FriendlyEncounter = false

	net.Receive("tfa_friendly_encounter", function()
		TFA.FriendlyEncounter = net.ReadBool()
	end)

	--Arrow can follow entities clientside too
	net.Receive("tfaArrowFollow",function()
		local ent = net.ReadEntity()
		ent.targent = net.ReadEntity()
		ent.targbone = net.ReadInt( 8 )
		ent.posoff = net.ReadVector(  )
		ent.angoff = net.ReadAngle(  )
		ent:TargetEnt( false )
	end)

	--Receive sound events on client
	net.Receive("tfaSoundEvent", function(length, ply)
		local wep = net.ReadEntity()
		local snd = net.ReadString()
		local shouldPause = net.ReadBool()

		if IsValid(wep) and snd and snd ~= "" then
			wep:EmitSound(snd, nil, nil, nil, nil, shouldPause and SND_SHOULDPAUSE or SND_NOFLAGS)
		end
	end)

	net.Receive("tfaSoundEventStop", function(length, ply)
		local wep = net.ReadEntity()
		local snd = net.ReadString()

		if IsValid(wep) and snd and snd ~= "" then
			wep:StopSound(snd)
		end
	end)

	--Receive muzzleflashes on client
	net.Receive("tfa_base_muzzle_mp", function(length, ply)
		local wep = net.ReadEntity()

		if IsValid(wep) and wep.ShootEffectsCustom then
			wep:ShootEffectsCustom(true)
		end
	end)

	net.Receive("tfaBaseShellSV", function(length, ply)
		local wep = net.ReadEntity()

		if IsValid(wep) and wep.MakeShellBridge then
			wep:MakeShellBridge()
		end
	end)

	net.Receive( "tfaTracerSP", function( length, ply )
		local part = net.ReadString()
		local startPos = net.ReadVector()
		local endPos = net.ReadVector()
		local woosh = net.ReadBool()
		local vent = net.ReadEntity()
		local att = net.ReadInt( 8 )
		if IsValid( vent ) then
			local aP = vent:GetAttachment( att or 1 )
			if aP then
				startPos = aP.Pos
			end
		end
		TFA.ParticleTracer( part, startPos, endPos, woosh, vent, att )
	end)
end

--addons/tfa_base/lua/tfa/modules/tfa_npc_weaponmenu.lua:
-- AI Options
if CLIENT then
	hook.Add("PopulateMenuBar", "NPCOptions_MenuBar_TFA", function(menubarV)
		local m = menubarV:AddOrGetMenu("#menubar.npcs")
		local wpns = m:AddSubMenu("#tfa.menubar.npcs.weapon")
		wpns:SetDeleteSelf(false)

		wpns:AddCVar("#menubar.npcs.defaultweapon", "gmod_npcweapon", "")
		wpns:AddCVar("#menubar.npcs.noweapon", "gmod_npcweapon", "none")
		wpns:AddSpacer()

		local weaponCats = {}

		for _, wep in pairs(weapons.GetList()) do
			if wep and wep.Spawnable and weapons.IsBasedOn(wep.ClassName, "tfa_gun_base") then
				local cat = wep.Category or "Other"
				weaponCats[cat] = weaponCats[cat] or {}

				table.insert(weaponCats[cat], {
					["class"] = wep.ClassName,
					["title"] = wep.PrintName or wep.ClassName
				})
			end
		end

		local catKeys = table.GetKeys(weaponCats)
		table.sort(catKeys, function(a, b) return a < b end)

		for _, k in ipairs(catKeys) do
			local v = weaponCats[k]
			local wpnSub = wpns:AddSubMenu(k)
			wpnSub:SetDeleteSelf(false)
			table.SortByMember(v, "title", true)

			for _, b in ipairs(v) do
				wpnSub:AddCVar(b.title, "gmod_npcweapon", b.class)
			end
		end
	end)
else
	local npcWepList = list.GetForEdit("NPCUsableWeapons")

	hook.Add("PlayerSpawnNPC", "TFACheckNPCWeapon", function(plyv, npcclassv, wepclassv)
		if type(wepclassv) ~= "string" or wepclassv == "" then return end

		if not npcWepList[wepclassv] then -- do not copy the table
			local wep = weapons.GetStored(wepclassv)

			if wep and (wep.Spawnable and not wep.AdminOnly) and weapons.IsBasedOn(wep.ClassName, "tfa_gun_base") then
				npcWepList[wepclassv] = {
					["class"] = wep.ClassName,
					["title"] = wep.PrintName or wep.ClassName
				}
			end
		end
	end)
end

--addons/tfa_base/lua/tfa/modules/tfa_nzombies.lua:
TFA.NZombies = TFA.NZombies or {}

if TFA.NZombies.Patch == nil then
	TFA.NZombies.Patch = true --Change this if you need to
end

local cv_melee_scaling, cv_melee_basefactor, cv_melee_berserkscale
local nzombies = string.lower(engine.ActiveGamemode() or "") == "nzombies"

if nZombies or NZombies or NZ then
	nzombies = true
end

if nzombies then
	cv_melee_scaling = CreateConVar("sv_tfa_nz_melee_scaling", "1", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_REPLICATED}, "0.5x means if zombies have 4x health, melee does 2x damage")
	cv_melee_basefactor = CreateConVar("sv_tfa_nz_melee_multiplier", "0.65", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_REPLICATED}, "Base damage scale for TFA Melees.")
	cv_melee_berserkscale = CreateConVar("sv_tfa_nz_melee_immunity", "0.67", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_REPLICATED}, "Take X% damage from zombies while you're melee.")
	--cv_melee_juggscale = CreateConVar("sv_tfa_nz_melee_juggernaut", "1.5", {FCVAR_SERVER_CAN_EXECUTE, FCVAR_REPLICATED}, "Do X% damage to zombies while you're jug.")
	hook.Add("TFA_AnimationRate","NZBase",function(wep,act,rate)
		if wep:OwnerIsValid() and wep:GetOwner().HasPerk and wep:GetOwner():HasPerk("speed") and wep.SpeedColaActivities[ act ] then
			rate = rate * wep.SpeedColaFactor
		end
		if wep:OwnerIsValid() and wep:GetOwner().HasPerk and wep:GetOwner():HasPerk("dtap") and wep.DTapActivities[ act ] then
			rate = rate * wep.DTapSpeed
		end
		if wep:OwnerIsValid() and wep:GetOwner().HasPerk and wep:GetOwner():HasPerk("dtap2") and wep.DTapActivities[ act ] then
			rate = rate * wep.DTap2Speed
		end
		return rate
	end)
	hook.Add("TFA_Deploy","NZBase",function(wep)
		local pap = wep:GetPaP()
		wep.OldPaP = pap
		local spd2 = wep:OwnerIsValid() and wep:GetOwner().HasPerk and wep:GetOwner():HasPerk("speed")
		if pap and pap ~= wep.OldPaP then
			if AddPackAPunchName and wep.NZPaPName and not wep.HasAddedNZName then
				AddPackAPunchName( wep.ClassName, wep.NZPaPName )
				wep.HasAddedNZName = true
			end
			if wep.NZPaPName and wep:GetPaP() then
				wep.PrintName = wep.NZPaPName
				wep:SetNW2String("PrintName",wep.NZPaPName)
			end
			local pn = wep:GetNW2String("PrintName")
			if pn and pn ~= "" then
				wep.PrintName = pn
			end
			wep:ClearStatCache()
			timer.Simple(0.1,function()
				if IsValid(wep) then
					wep:ClearStatCache()
				end
			end)
		end
		if spd2 ~= wep.OldSpCola then
			wep:ClearStatCache()
		end
		wep.OldSpCola = spd2
	end)
	hook.Add("TFA_Initialize", "NZBase", function(wep)
		timer.Simple(0.1, function() -- timers for everything YAY
			if not IsValid(wep) then return end

			wep.Primary_TFA.Ammo = game.GetAmmoName(wep:GetPrimaryAmmoType())
			wep:ClearStatCache("Primary.Ammo")
		end)
	end)
end
--[[
local function SpreadFix()

	local GAMEMODE = gmod.GetGamemode() or GAMEMODE
	if not GAMEMODE then return end

	print("[TFA] Patching NZombies")
	if TFA.NZombies.Patch then return end

	local ghosttraceentities = {
		["wall_block"] = true,
		["invis_wall"] = true,
		["player"] = true
	}

	function GAMEMODE:EntityFireBullets(ent, data)
		-- Fire the PaP shooting sound if the weapon is PaP'd
		--print(wep, wep.pap)
		if ent:IsPlayer() and IsValid(ent:GetActiveWeapon()) then
			local wep = ent:GetActiveWeapon()
			if wep.pap and ( not wep.IsMelee ) and ( not wep.IsKnife ) then
				wep:EmitSound("nz/effects/pap_shoot_glock20.wav", 105, 100)
			end
		end

		if ent:IsPlayer() and ent:HasPerk("dtap2") then
			data.Num = data.Num * 2
		end

		-- Perform a trace that filters out entities from the table above
		local tr = util.TraceLine({
			start = data.Src,
			endpos = data.Src + (data.Dir * data.Distance),
			filter = function(entv)
				if ghosttraceentities[entv:GetClass()] and not entv:IsPlayer() then
					return true
				else
					return false
				end
			end
		})

		--PrintTable(tr)
		-- If we hit anything, move the source of the bullets up to that point
		if IsValid(tr.Entity) and tr.Fraction < 1 then
			local tr2 = util.TraceLine({
				start = data.Src,
				endpos = data.Src + (data.Dir * data.Distance),
				filter = function(entv)
					if ghosttraceentities[entv:GetClass()] then
						return false
					else
						return true
					end
				end
			})

			data.Src = tr2.HitPos - data.Dir * 5

			return true
		end

		if ent:IsPlayer() and ent:HasPerk("dtap2") then return true end
	end
end
]]
--
local function MeleeFix()
	hook.Add("EntityTakeDamage", "TFA_MeleeScaling", function(target, dmg)
		if not TFA.NZombies.Patch then return end
		if not nzRound then return end
		local ent = dmg:GetInflictor()

		if not ent:IsWeapon() and ent:IsPlayer() then
			ent = ent:GetActiveWeapon()
		end

		if not IsValid(ent) or not ent:IsWeapon() then return end

		if ent.IsTFAWeapon and (dmg:IsDamageType(DMG_CRUSH) or dmg:IsDamageType(DMG_CLUB) or dmg:IsDamageType(DMG_SLASH)) then
			local scalefactor = cv_melee_scaling:GetFloat()
			local basefactor = cv_melee_basefactor:GetFloat()
			dmg:ScaleDamage(((nzRound:GetZombieHealth() - 75) / 75 * scalefactor + 1) * basefactor)
			--if IsValid(ent:GetOwner()) and ent:GetOwner():IsPlayer() and ent:GetOwner():HasPerk("jugg") then
			--	dmg:ScaleDamage(cv_melee_juggscale:GetFloat())
			--end
		end
	end)

	hook.Add("EntityTakeDamage", "TFA_MeleeReceiveLess", function(target, dmg)
		if not TFA.NZombies.Patch then return end

		if target:IsPlayer() and target.GetActiveWeapon then
			local wep = target:GetActiveWeapon()

			if IsValid(wep) and wep.IsTFAWeapon and (wep.IsKnife or wep.IsMelee or wep.Primary.Reach) then
				dmg:ScaleDamage(cv_melee_berserkscale:GetFloat())
			end
		end
	end)

	hook.Add("EntityTakeDamage", "TFA_MeleePaP", function(target, dmg)
		if not TFA.NZombies.Patch then return end
		local ent = dmg:GetInflictor()

		if IsValid(ent) then
			local wep

			if ent:IsPlayer() then
				wep = ent:GetActiveWeapon()
			elseif ent:IsWeapon() then
				wep = ent
			end

			if IsValid(wep) and wep.IsTFAWeapon and (wep.Primary.Attacks or wep.IsMelee or wep.Primary.Reach) and wep:GetPaP() then
				dmg:ScaleDamage(2)
			end
		end
	end)
end

local function NZPatch()
	if not TFA.NZombies.Patch then return end
	nzombies = string.lower(engine.ActiveGamemode() or "") == "nzombies"

	if nZombies or NZombies or NZ or NZombies then
		nzombies = true
	end

	if nzombies then
		--SpreadFix()
		MeleeFix()
	end
end

hook.Add("InitPostEntity", "TFA_NZPatch", NZPatch)
NZPatch()
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1		end
	
--tfa_dev_tools:
		local rshift = bit.rshift
		local band = bit.band
		return function(state)
			return band(rshift(state, 0), 1) == 0 and 0 or 1, band(rshift(state, 1), 1) == 0 and 0 or 1, band(rshift(state, 2), 1) == 0 and 0 or 1, band(rshift(state, 3), 1) == 0 and 0 or 1, band(rshift(state, 4), 1) == 0 and 0 or 1, band(rshift(state, 5), 1) == 0 and 0 or 1, band(rshift(state, 6), 1) == 0 and 0 or 1, band(rshift(state, 7), 1) == 0 and 0 or 1, band(rshift(state, 8), 1) == 0 and 0 or 1, band(rshift(state, 9), 1) == 0 and 0 or 1, band(rshift(state, 10), 1) == 0 and 0 or 1, band(rshift(state, 11), 1) == 0 and 0 or 1, band(rshift(state, 12), 1) == 0 and 0 or 1, band(rshift(state, 13), 1) == 0 and 0 or 1, band(rshift(state, 14), 1) == 0 and 0 or 1, band(rshift(state, 15), 1) == 0 and 0 or 1, band(rshift(state, 16), 1) == 0 and 0 or 1, band(rshift(state, 17), 1) == 0 and 0 or 1, band(rshift(state, 18), 1) == 0 and 0 or 1, band(rshift(state, 19), 1) == 0 and 0 or 1, band(rshift(state, 20), 1) == 0 and 0 or 1, band(rshift(state, 21), 1) == 0 and 0 or 1, band(rshift(state, 22), 1) == 0 and 0 or 1, band(rshift(state, 23), 1) == 0 and 0 or 1, band(rshift(state, 24), 1) == 0 and 0 or 1, band(rshift(state, 25), 1) == 0 and 0 or 1, band(rshift(state, 26), 1) == 0 and 0 or 1, band(rshift(state, 27), 1) == 0 and 0 or 1, band(rshift(state, 28), 1) == 0 and 0 or 1, band(rshift(state, 29), 1) == 0 and 0 or 1, band(rshift(state, 30), 1) == 0 and 0 or 1		end
	
--addons/tfa_base/lua/tfa/modules/cl_tfa_fonts.lua:
TFA.Fonts = TFA.Fonts or {}

local ScaleH = TFA.ScaleH

local function GetFontHeight(fontname) -- UNCACHED!
	surface.SetFont(fontname)

	local _, h = surface.GetTextSize("W")

	return h
end

local function CreateFonts()
	local fontdata = {}

	fontdata.font = "Inter"
	fontdata.shadow = false
	fontdata.extended = true
	fontdata.weight = 400
	fontdata.size = ScaleH(36)
	surface.CreateFont("TFASleek", fontdata)
	TFA.Fonts.SleekHeight = GetFontHeight("TFASleek")

	fontdata.size = ScaleH(30)
	surface.CreateFont("TFASleekMedium", fontdata)
	TFA.Fonts.SleekHeightMedium = GetFontHeight("TFASleekMedium")

	fontdata.size = ScaleH(24)
	surface.CreateFont("TFASleekSmall", fontdata)
	TFA.Fonts.SleekHeightSmall = GetFontHeight("TFASleekSmall")

	fontdata.size = ScaleH(18)
	surface.CreateFont("TFASleekTiny", fontdata)
	TFA.Fonts.SleekHeightTiny = GetFontHeight("TFASleekTiny")

	fontdata = {}

	fontdata.font = "Inter"
	fontdata.extended = true
	fontdata.weight = 500
	fontdata.size = ScaleH(64)
	surface.CreateFont("TFA_INSPECTION_TITLE", fontdata)
	TFA.Fonts.InspectionHeightTitle = GetFontHeight("TFA_INSPECTION_TITLE")

	fontdata.size = ScaleH(32)
	surface.CreateFont("TFA_INSPECTION_DESCR", fontdata)
	TFA.Fonts.InspectionHeightDescription = GetFontHeight("TFA_INSPECTION_DESCR")

	fontdata.size = ScaleH(24)
	fontdata.weight = 400
	surface.CreateFont("TFA_INSPECTION_SMALL", fontdata)
	TFA.Fonts.InspectionHeightSmall = GetFontHeight("TFA_INSPECTION_SMALL")

	fontdata = {}
	fontdata.extended = true
	fontdata.weight = 400

	fontdata.font = "Inter"
	fontdata.size = ScaleH(12)
	surface.CreateFont("TFAAttachmentIconFont", fontdata)
	fontdata.size = ScaleH(10)
	surface.CreateFont("TFAAttachmentIconFontTiny", fontdata)

	fontdata.font = "Inter"
	fontdata.weight = 500
	fontdata.size = ScaleH(24)
	surface.CreateFont("TFAAttachmentTTHeader", fontdata)

	fontdata.font = "Inter"
	fontdata.weight = 300
	fontdata.size = ScaleH(18)
	surface.CreateFont("TFAAttachmentTTBody", fontdata)

	surface.CreateFont("TFASleekDebug", { font = "Roboto", size = 24, extended = true })
	TFA.Fonts.SleekHeightDebug = 24

	hook.Run("TFA_FontsLoaded")
end

CreateFonts()

hook.Add("OnScreenSizeChanged", "TFA_Fonts_Regenerate", CreateFonts)
cvars.AddChangeCallback("cl_tfa_hud_scale", CreateFonts, "TFA_RecreateFonts")
--addons/tfa_base/lua/tfa/modules/cl_tfa_inspection.lua:
if CLIENT then
	local doblur = GetConVar("cl_tfa_inspection_bokeh")
	local blurdist = GetConVar("cl_tfa_inspection_bokeh_radius")
	local tfablurintensity = 0
	local blur_mat = Material("pp/bokehblur")
	local tab = {}
	tab["$pp_colour_addr"] = 0
	tab["$pp_colour_addg"] = 0
	tab["$pp_colour_addb"] = 0
	tab["$pp_colour_brightness"] = 0
	tab["$pp_colour_contrast"] = 1
	tab["$pp_colour_colour"] = 1
	tab["$pp_colour_mulr"] = 0
	tab["$pp_colour_mulg"] = 0
	tab["$pp_colour_mulb"] = 0

	local function MyDrawBokehDOF()
		render.UpdateScreenEffectTexture()
		render.UpdateFullScreenDepthTexture()
		blur_mat:SetTexture("$BASETEXTURE", render.GetScreenEffectTexture())
		blur_mat:SetTexture("$DEPTHTEXTURE", render.GetResolvedFullFrameDepth())
		blur_mat:SetFloat("$size", tfablurintensity * 6)
		blur_mat:SetFloat("$focus", 0)
		blur_mat:SetFloat("$focusradius", blurdist:GetFloat())
		render.SetMaterial(blur_mat)
		render.DrawScreenQuad()
	end

	local cv_dxlevel = GetConVar("mat_dxlevel")

	local function Render()
		tfablurintensity = 0

		if cv_dxlevel:GetInt() < 90 then return end
		if TFA.DrawingRenderTarget then return end

		local ply = LocalPlayer()
		if not IsValid(ply) then return end

		local wep = ply:GetActiveWeapon()
		if not IsValid(wep) or not wep.IsTFAWeapon then return end

		tfablurintensity = wep:GetInspectingProgress()

		if tfablurintensity > 0.01 then
			if doblur and doblur:GetBool() then
				MyDrawBokehDOF()
			end

			tab["$pp_colour_brightness"] = -tfablurintensity * 0.02
			tab["$pp_colour_contrast"] = 1 - tfablurintensity * 0.1

			DrawColorModify(tab)
		end
	end

	local function InitTFABlur()
		hook.Add("PreDrawViewModels", "PreDrawViewModels_TFA_INSPECT", Render)

		local pp_bokeh = GetConVar( "pp_bokeh" )
		hook.Remove("NeedsDepthPass","NeedsDepthPass_Bokeh")
		hook.Add("NeedsDepthPass", "aaaaaaaaaaaaaaaaaaNeedsDepthPass_TFA_Inspect", function()
			if not ( doblur and doblur:GetBool() ) then return end

			if tfablurintensity > 0.01 or ( pp_bokeh and pp_bokeh:GetBool() ) then
				DOFModeHack(true)

				return true
			end
		end)
	end

	hook.Add("InitPostEntity","InitTFABlur",InitTFABlur)

	InitTFABlur()
end
--lua/tfa/att/mod_stun20_servius.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

ATTACHMENT.Name = "Charge Round Delta"
ATTACHMENT.ShortName = "20s" --Abbreviation, 5 chars or less please
--ATTACHMENT.ID = "base" -- normally this is just your filename
ATTACHMENT.Description = { 
	TFA.AttachmentColors["+"],"Stunned for 20 Seconds",
}
ATTACHMENT.Icon = "entities/icon/mod_stun20.png" --Revers to label, please give it an icon though!  This should be the path to a png, like "entities/tfa_ammo_match.png"

ATTACHMENT.WeaponTable = {
	["Primary"] = {
		["AmmoConsumption"] = 7,
		["StatusEffect"] = "stun",
		["StatusEffectDmg"] = 60,
		["StatusEffectDur"] = 20,
		["StatusEffectParticle"] = true,
	},
	["TracerName"] = "effect_sw_laser_blue_stun",
}

function ATTACHMENT:Attach(wep)
	wep.CustomBulletCallbackOld = wep.CustomBulletCallbackOld or wep.CustomBulletCallback
	wep.CustomBulletCallback = function(a, tr, dmg)
		local wep = dmg:GetInflictor()
		if wep:GetStat("Primary.StatusEffect") then
			GMSERV:AddStatus(tr.Entity, wep:GetOwner(), wep:GetStat("Primary.StatusEffect"), wep:GetStat("Primary.StatusEffectDur"), wep:GetStat("Primary.StatusEffectDmg"), wep:GetStat("Primary.StatusEffectParticle"))
			--util.Effect("BGOLightning", ED_Stun, true, true)
		end
	end
end

function ATTACHMENT:Detach(wep)
	wep.CustomBulletCallback = wep.CustomBulletCallbackOld
	wep.CustomBulletCallbackOld = nil
end

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end
--addons/egm_tfa_weapons/lua/tfa/att/rocket_mod_pointing.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

ATTACHMENT.Name = "Pointing Mod"
ATTACHMENT.ShortName = "P.M"
ATTACHMENT.Icon = "entities/atts/rctm_point.png"
ATTACHMENT.Description = {
	TFA.AttachmentColors["="], "Die Rakete wird dorthin fliegen, wo du hinschaust.",
	TFA.AttachmentColors["="], "10 Sekunden Lebensdauer.",
	TFA.AttachmentColors["="], "Geschwindigkeit von 128 m/s.",
}

ATTACHMENT.WeaponTable = {
	["VElements"] = {},
	["WElements"] = {
		["laser_beam"] = {["active"] = false},
		["laser_beam_pointing"] = {["active"] = true},
	},
	["Primary"] = {},
}

function ATTACHMENT:Attach(wep)
	wep:Unload()
end

function ATTACHMENT:Detach(wep)
	wep:Unload()
end

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end

--addons/egm_tfa_weapons/lua/tfa/att/swrp_am_stun.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

ATTACHMENT.Name = "Stun Charge"
ATTACHMENT.ShortName = "Stun" --Abbreviation, 5 chars or less please
ATTACHMENT.Description = {
	TFA.AttachmentColors["+"], "Betäubt Gegner",
	TFA.Attachments.Colors["-"], "Niedrigere Schussrate",
}
ATTACHMENT.Icon = "entities/icon/mod_stun20.png" -- Revers to label, please give it an icon though!  This should be the path to a png, like "entities/tfa_ammo_match.png"

ATTACHMENT.WeaponTable = {
	["Primary"] = {
		["Damage"] = function( wep, stat ) return 100 end,
		["RPM"] = function( wep, stat ) return 120 end,
		["RPM_Semi"] = function( wep, stat ) return 150 end,
		["Range"] = function( wep, stat ) return 750 end,
		["NumShots"] = 1,
		["Spread"] = 0.022,
		["IronAccuracy"] = 0.02,
		["AmmoConsumption"] = 20,
		["Sound"] = "cwrp/weapons/taser.wav"
	},

	["TracerCount"] = 1,
	["TracerName"] = function( wep, stat ) return "effect_sw_stun_blue" end,
}

local function ApplyStun(trace, dmgInfo)
	local target = trace.Entity
	if IsValid(target) and target:IsPlayer() then
		target.LastDeathStunned = true
		target.LastDeathDuration = 30

		-- Removes the stun override
		timer.Create("DeathSystem.Revive." .. target:SteamID64(), 1, 1, function()
			if not IsValid(target) then return end
			if not target:Alive() then return end

			target.LastDeathStunned = nil
			target.LastDeathDuration = nil
		end)
	end
end

hook.Add("wOS.ALCS.Combat.PreProjectileDeflect", "Lightsaber.StunReflect", function(wep, ply, bullet, dmgInfo)
	local inflictor = dmgInfo:GetInflictor()
	if IsValid(inflictor) and isfunction(inflictor.IsAttached) and inflictor:IsAttached("swrp_am_stun") then
		bullet.Dir = Vector(0,0,0)
		bullet.Callback = function(attacker, trace, dmgInfo2)
			ApplyStun(trace, dmgInfo2)
		end
	end
end)

ATTACHMENT.CustomBulletCallback = function(att, wpn, ply, trace, dmgInfo)
	if not SERVER then return end

	if IsValid(trace.Entity) then
		if trace.Entity:IsNextBot() then
			dmgInfo:SetDamage(0)
			return
		elseif trace.Entity:IsPlayer() then
			local damage = math.max(100, trace.Entity:GetMaxHealth() * 0.25)

			dmgInfo:SetDamage(damage)
		end
	end

	ApplyStun(trace, dmgInfo)
end

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end
--addons/egm_tfa_weapons/lua/tfa/att/swrp_am_swt.lua:
if not ATTACHMENT then
	ATTACHMENT = {}
end

ATTACHMENT.Name = "Unsichtbar"
ATTACHMENT.ShortName = "INV" --Abbreviation, 5 chars or less please
ATTACHMENT.Description = { TFA.Attachments.Colors["+"], "Unsichtbar", TFA.Attachments.Colors["-"], "20% weniger Schaden"}
ATTACHMENT.Icon = "entities/tfa_ammo_match.png" --Revers to label, please give it an icon though!  This should be the path to a png, like "entities/tfa_ammo_match.png"

ATTACHMENT.WeaponTable = {
	["Primary"] = {
		["Damage"] = function( wep, stat ) return stat * 0.8 end,
		["RPM"] = 285,
		["AmmoConsumption"] = 5
	},

	["TracerName"] = function( wep, stat ) return "BoostIstDoof" end,
}

if not TFA_ATTACHMENT_ISUPDATING then
	TFAUpdateAttachments()
end

--lua/autorun/tills.lua:
local function AddPlayerModel( name, model )

	list.Set( "PlayerOptionsModel", name, model )
	player_manager.AddValidModel( name, model )

end


AddPlayerModel( "Senator Tills",		"models/player/tiki/tills.mdl" )

--lua/autorun/venator_colorchange.lua:
// Created by Airfox aka. Konsti
// Huge thanks to him!

if game.GetMap() ~= "rp_venator_extensive_v1_4" then return end

local nextTick = nextTick or 0
local materialHull = Material("kingpommes/starwars/venator/hull_red")
local materialHullPanel = Material("kingpommes/starwars/venator/hull_panels_red")
local materialPropperHull = Material("kingpommes/starwars/venator/hull_red")
local materialPropperHullPanel = Material("models/kingpommes/starwars/venator/propper/hull_red")
local materialPropperInsignia = Material("models/kingpommes/starwars/venator/propper/venator_insignia")
local republicLook = true

materialHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_red")
materialHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels_red")
materialPropperHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_red")
materialPropperHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels_red")
materialPropperInsignia:SetTexture("$basetexture", "kingpommes/starwars/venator/venator_insignia")

if SERVER then
	util.AddNetworkString("Venator_Ext_ColorNet")

	-- Networks current state to every new player that joins the server.
	hook.Add("PlayerInitialSpawn", "Venator_Ext_ColorConnectSync", function(ply)
		net.Start("Venator_Ext_ColorNet")
			net.WriteBool(republicLook)
		net.Send(ply)
	end)
end

hook.Add("Think", "Venator_Ext_ColorThink", function()
	if nextTick > CurTime() then return end

	nextTick = CurTime() + 1
	
	if SERVER then
		-- Finds all entities with this name.
		local entities = ents.FindByName("colorchange_target")

		-- Checks if an entity has been found and alarm is on. Also if the network has already been sent.
		if #entities >= 1 and republicLook then
			republicLook = false
			net.Start("Venator_Ext_ColorNet")
				net.WriteBool(republicLook)
			net.Broadcast()

			if materialHull:GetTexture("$basetexture"):GetName() == "kingpommes/starwars/venator/hull_red" then
				materialHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull")
				materialHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels")
				materialPropperHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull")
				materialPropperHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels")
				materialPropperInsignia:SetTexture("$basetexture", "kingpommes/starwars/venator/invis")
			end
		elseif #entities == 0 and not republicLook then
			republicLook = true
			net.Start("Venator_Ext_ColorNet")
				net.WriteBool(republicLook)
			net.Broadcast()

			if materialHull:GetTexture("$basetexture"):GetName() == "kingpommes/starwars/venator/hull" then
				materialHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_red")
				materialHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels_red")
				materialPropperHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_red")
				materialPropperHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels_red")
				materialPropperInsignia:SetTexture("$basetexture", "kingpommes/starwars/venator/venator_insignia")
			end
		end
	elseif CLIENT then
		-- Checks if alarm is on. 
		if not republicLook then
			-- Changes between textured.
			if materialHull:GetTexture("$basetexture"):GetName() == "kingpommes/starwars/venator/hull_red" then
				materialHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull")
				materialHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels")
				materialPropperHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull")
				materialPropperHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels")
				materialPropperInsignia:SetTexture("$basetexture", "kingpommes/starwars/venator/invis")
			end
		else
			-- Resets the texture to default, when the border should be visible.
			if materialHull:GetTexture("$basetexture"):GetName() == "kingpommes/starwars/venator/hull" then
				materialHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_red")
				materialHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels_red")
				materialPropperHull:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_red")
				materialPropperHullPanel:SetTexture("$basetexture", "kingpommes/starwars/venator/hull_panels_red")
				materialPropperInsignia:SetTexture("$basetexture", "kingpommes/starwars/venator/venator_insignia")
			end
		end
	end
end)

if CLIENT then
	-- Receives current state.
	net.Receive("Venator_Ext_ColorNet", function(len)
		republicLook = net.ReadBool()
	end)
end
--addons/vyhub-gmod/lua/vyhub/lib/date.lua:
VyHub.Lib.date = VyHub.Lib.date or {}

---------------------------------------------------------------------------------------
-- Module for date and time calculations
--
-- Version 2.2
-- Copyright (C) 2005-2006, by Jas Latrix (jastejada@yahoo.com)
-- Copyright (C) 2013-2021, by Thijs Schreijer
-- Licensed under MIT, http://opensource.org/licenses/MIT

-- https://github.com/Tieske/date

-- Changes by Matbyte: New function setbias

--[[ CONSTANTS ]]--
local HOURPERDAY  = 24
local MINPERHOUR  = 60
local MINPERDAY    = 1440  -- 24*60
local SECPERMIN   = 60
local SECPERHOUR  = 3600  -- 60*60
local SECPERDAY   = 86400 -- 24*60*60
local TICKSPERSEC = 1000000
local TICKSPERDAY = 86400000000
local TICKSPERHOUR = 3600000000
local TICKSPERMIN = 60000000
local DAYNUM_MAX =  365242500 -- Sat Jan 01 1000000 00:00:00
local DAYNUM_MIN = -365242500 -- Mon Jan 01 1000000 BCE 00:00:00
local DAYNUM_DEF =  0 -- Mon Jan 01 0001 00:00:00
local _;
--[[ GLOBAL SETTINGS ]]--
local centuryflip = 0 -- year >= centuryflip == 1900, < centuryflip == 2000
--[[ LOCAL ARE FASTER ]]--
local type     = type
local pairs    = pairs
local error    = error
local assert   = assert
local tonumber = tonumber
local tostring = tostring
local string   = string
local math     = math
local os       = os
local unpack   = unpack or table.unpack
local setmetatable = setmetatable
local getmetatable = getmetatable
--[[ EXTRA FUNCTIONS ]]--
local fmt  = string.format
local lwr  = string.lower
local rep  = string.rep
local len  = string.len  -- luacheck: ignore
local sub  = string.sub
local gsub = string.gsub
local gmatch = string.gmatch or string.gfind
local find = string.find
local ostime = os.time
local osdate = os.date
local floor = math.floor
local ceil  = math.ceil
local abs   = math.abs
-- removes the decimal part of a number
local function fix(n) n = tonumber(n) return n and ((n > 0 and floor or ceil)(n)) end
-- returns the modulo n % d;
local function mod(n,d) return n - d*floor(n/d) end
-- is `str` in string list `tbl`, `ml` is the minimun len
local function inlist(str, tbl, ml, tn)
  local sl = len(str)
  if sl < (ml or 0) then return nil end
  str = lwr(str)
  for k, v in pairs(tbl) do
    if str == lwr(sub(v, 1, sl)) then
      if tn then tn[0] = k end
      return k
    end
  end
end
local function fnil() end
--[[ DATE FUNCTIONS ]]--
local DATE_EPOCH -- to be set later
local sl_weekdays = {
  [0]="Sunday",[1]="Monday",[2]="Tuesday",[3]="Wednesday",[4]="Thursday",[5]="Friday",[6]="Saturday",
  [7]="Sun",[8]="Mon",[9]="Tue",[10]="Wed",[11]="Thu",[12]="Fri",[13]="Sat",
}
local sl_meridian = {[-1]="AM", [1]="PM"}
local sl_months = {
  [00]="January", [01]="February", [02]="March",
  [03]="April",   [04]="May",      [05]="June",
  [06]="July",    [07]="August",   [08]="September",
  [09]="October", [10]="November", [11]="December",
  [12]="Jan", [13]="Feb", [14]="Mar",
  [15]="Apr", [16]="May", [17]="Jun",
  [18]="Jul", [19]="Aug", [20]="Sep",
  [21]="Oct", [22]="Nov", [23]="Dec",
}
-- added the '.2'  to avoid collision, use `fix` to remove
local sl_timezone = {
  [000]="utc",    [0.2]="gmt",
  [300]="est",    [240]="edt",
  [360]="cst",  [300.2]="cdt",
  [420]="mst",  [360.2]="mdt",
  [480]="pst",  [420.2]="pdt",
}
-- set the day fraction resolution
local function setticks(t)
  TICKSPERSEC = t;
  TICKSPERDAY = SECPERDAY*TICKSPERSEC
  TICKSPERHOUR= SECPERHOUR*TICKSPERSEC
  TICKSPERMIN = SECPERMIN*TICKSPERSEC
end
-- is year y leap year?
local function isleapyear(y) -- y must be int!
  return (mod(y, 4) == 0 and (mod(y, 100) ~= 0 or mod(y, 400) == 0))
end
-- day since year 0
local function dayfromyear(y) -- y must be int!
  return 365*y + floor(y/4) - floor(y/100) + floor(y/400)
end
-- day number from date, month is zero base
local function makedaynum(y, m, d)
  local mm = mod(mod(m,12) + 10, 12)
  return dayfromyear(y + floor(m/12) - floor(mm/10)) + floor((mm*306 + 5)/10) + d - 307
  --local yy = y + floor(m/12) - floor(mm/10)
  --return dayfromyear(yy) + floor((mm*306 + 5)/10) + (d - 1)
end
-- date from day number, month is zero base
local function breakdaynum(g)
  local g = g + 306
  local y = floor((10000*g + 14780)/3652425)
  local d = g - dayfromyear(y)
  if d < 0 then y = y - 1; d = g - dayfromyear(y) end
  local mi = floor((100*d + 52)/3060)
  return (floor((mi + 2)/12) + y), mod(mi + 2,12), (d - floor((mi*306 + 5)/10) + 1)
end
--[[ for floats or int32 Lua Number data type
local function breakdaynum2(g)
  local g, n = g + 306;
  local n400 = floor(g/DI400Y);n = mod(g,DI400Y);
  local n100 = floor(n/DI100Y);n = mod(n,DI100Y);
  local n004 = floor(n/DI4Y);   n = mod(n,DI4Y);
  local n001 = floor(n/365);   n = mod(n,365);
  local y = (n400*400) + (n100*100) + (n004*4) + n001  - ((n001 == 4 or n100 == 4) and 1 or 0)
  local d = g - dayfromyear(y)
  local mi = floor((100*d + 52)/3060)
  return (floor((mi + 2)/12) + y), mod(mi + 2,12), (d - floor((mi*306 + 5)/10) + 1)
end
]]
-- day fraction from time
local function makedayfrc(h,r,s,t)
  return ((h*60 + r)*60 + s)*TICKSPERSEC + t
end
-- time from day fraction
local function breakdayfrc(df)
  return
    mod(floor(df/TICKSPERHOUR),HOURPERDAY),
    mod(floor(df/TICKSPERMIN ),MINPERHOUR),
    mod(floor(df/TICKSPERSEC ),SECPERMIN),
    mod(df,TICKSPERSEC)
end
-- weekday sunday = 0, monday = 1 ...
local function weekday(dn) return mod(dn + 1, 7) end
-- yearday 0 based ...
local function yearday(dn)
   return dn - dayfromyear((breakdaynum(dn))-1)
end
-- parse v as a month
local function getmontharg(v)
  local m = tonumber(v);
  return (m and fix(m - 1)) or inlist(tostring(v) or "", sl_months, 2)
end
-- get daynum of isoweek one of year y
local function isow1(y)
  local f = makedaynum(y, 0, 4) -- get the date for the 4-Jan of year `y`
  local d = weekday(f)
  d = d == 0 and 7 or d -- get the ISO day number, 1 == Monday, 7 == Sunday
  return f + (1 - d)
end
local function isowy(dn)
  local w1;
  local y = (breakdaynum(dn))
  if dn >= makedaynum(y, 11, 29) then
    w1 = isow1(y + 1);
    if dn < w1 then
      w1 = isow1(y);
    else
        y = y + 1;
    end
  else
    w1 = isow1(y);
    if dn < w1 then
      w1 = isow1(y-1)
      y = y - 1
    end
  end
  return floor((dn-w1)/7)+1, y
end
local function isoy(dn)
  local y = (breakdaynum(dn))
  return y + (((dn >= makedaynum(y, 11, 29)) and (dn >= isow1(y + 1))) and 1 or (dn < isow1(y) and -1 or 0))
end
local function makedaynum_isoywd(y,w,d)
  return isow1(y) + 7*w + d - 8 -- simplified: isow1(y) + ((w-1)*7) + (d-1)
end
--[[ THE DATE MODULE ]]--
local fmtstr  = "%x %X";
--#if not DATE_OBJECT_AFX then
local date = {}
setmetatable(date, date)
-- Version:  VMMMRRRR; V-Major, M-Minor, R-Revision;  e.g. 5.45.321 == 50450321
do
  local major = 2
  local minor = 2
  local revision = 0
  date.version = major * 10000000 + minor * 10000 + revision
end
--#end -- not DATE_OBJECT_AFX
--[[ THE DATE OBJECT ]]--
local dobj = {}
dobj.__index = dobj
dobj.__metatable = dobj
-- shout invalid arg
local function date_error_arg() return error("invalid argument(s)",0) end
-- create new date object
local function date_new(dn, df)
  return setmetatable({daynum=dn, dayfrc=df}, dobj)
end

--#if not NO_LOCAL_TIME_SUPPORT then
-- magic year table
local date_epoch, yt;
local function getequivyear(y)
  assert(not yt)
  yt = {}
  local de = date_epoch:copy()
  local dw, dy
  for _ = 0, 3000 do
    de:setyear(de:getyear() + 1, 1, 1)
    dy = de:getyear()
    dw = de:getweekday() * (isleapyear(dy) and  -1 or 1)
    if not yt[dw] then yt[dw] = dy end  --print(de)
    if yt[1] and yt[2] and yt[3] and yt[4] and yt[5] and yt[6] and yt[7] and yt[-1] and yt[-2] and yt[-3] and yt[-4] and yt[-5] and yt[-6] and yt[-7] then
      getequivyear = function(y)  return yt[ (weekday(makedaynum(y, 0, 1)) + 1) * (isleapyear(y) and  -1 or 1) ]  end
      return getequivyear(y)
    end
  end
end
-- TimeValue from date and time
local function totv(y,m,d,h,r,s)
  return (makedaynum(y, m, d) - DATE_EPOCH) * SECPERDAY  + ((h*60 + r)*60 + s)
end
-- TimeValue from TimeTable
local function tmtotv(tm)
  return tm and totv(tm.year, tm.month - 1, tm.day, tm.hour, tm.min, tm.sec)
end
-- Returns the bias in seconds of utc time daynum and dayfrc
local function getbiasutc2(self)
  local y,m,d = breakdaynum(self.daynum)
  local h,r,s = breakdayfrc(self.dayfrc)
  local tvu = totv(y,m,d,h,r,s) -- get the utc TimeValue of date and time
  local tml = osdate("*t", tvu) -- get the local TimeTable of tvu
  if (not tml) or (tml.year > (y+1) or tml.year < (y-1)) then -- failed try the magic
    y = getequivyear(y)
    tvu = totv(y,m,d,h,r,s)
    tml = osdate("*t", tvu)
  end
  local tvl = tmtotv(tml)
  if tvu and tvl then
    return tvu - tvl, tvu, tvl
  else
    return error("failed to get bias from utc time")
  end
end
-- Returns the bias in seconds of local time daynum and dayfrc
local function getbiasloc2(daynum, dayfrc)
  local tvu
  -- extract date and time
  local y,m,d = breakdaynum(daynum)
  local h,r,s = breakdayfrc(dayfrc)
  -- get equivalent TimeTable
  local tml = {year=y, month=m+1, day=d, hour=h, min=r, sec=s}
  -- get equivalent TimeValue
  local tvl = tmtotv(tml)

  local function chkutc()
    tml.isdst =  nil; local tvug = ostime(tml) if tvug and (tvl == tmtotv(osdate("*t", tvug))) then tvu = tvug return end
    tml.isdst = true; local tvud = ostime(tml) if tvud and (tvl == tmtotv(osdate("*t", tvud))) then tvu = tvud return end
    tvu = tvud or tvug
  end
  chkutc()
  if not tvu then
    tml.year = getequivyear(y)
    tvl = tmtotv(tml)
    chkutc()
  end
  return ((tvu and tvl) and (tvu - tvl)) or error("failed to get bias from local time"), tvu, tvl
end
--#end -- not NO_LOCAL_TIME_SUPPORT

--#if not DATE_OBJECT_AFX then
-- the date parser
local strwalker = {} -- ^Lua regular expression is not as powerful as Perl$
strwalker.__index = strwalker
local function newstrwalker(s)return setmetatable({s=s, i=1, e=1, c=len(s)}, strwalker) end
function strwalker:aimchr() return "\n" .. self.s .. "\n" .. rep(".",self.e-1) .. "^" end
function strwalker:finish() return self.i > self.c  end
function strwalker:back()  self.i = self.e return self  end
function strwalker:restart() self.i, self.e = 1, 1 return self end
function strwalker:match(s)  return (find(self.s, s, self.i)) end
function strwalker:__call(s, f)-- print("strwalker:__call "..s..self:aimchr())
  local is, ie; is, ie, self[1], self[2], self[3], self[4], self[5] = find(self.s, s, self.i)
  if is then self.e, self.i = self.i, 1+ie; if f then f(unpack(self)) end return self end
end
 local function date_parse(str)
  local y,m,d, h,r,s,  z,  w,u, j,  e,  x,c,  dn,df
  local sw = newstrwalker(gsub(gsub(str, "(%b())", ""),"^(%s*)","")) -- remove comment, trim leading space
  --local function error_out() print(y,m,d,h,r,s) end
  local function error_dup(q) --[[error_out()]] error("duplicate value: " .. (q or "") .. sw:aimchr()) end
  local function error_syn(q) --[[error_out()]] error("syntax error: " .. (q or "") .. sw:aimchr()) end
  local function error_inv(q) --[[error_out()]] error("invalid date: " .. (q or "") .. sw:aimchr()) end
  local function sety(q) y = y and error_dup() or tonumber(q); end
  local function setm(q) m = (m or w or j) and error_dup(m or w or j) or tonumber(q) end
  local function setd(q) d = d and error_dup() or tonumber(q) end
  local function seth(q) h = h and error_dup() or tonumber(q) end
  local function setr(q) r = r and error_dup() or tonumber(q) end
  local function sets(q) s = s and error_dup() or tonumber(q) end
  local function adds(q) s = s + tonumber(q) end
  local function setj(q) j = (m or w or j) and error_dup() or tonumber(q); end
  local function setz(q) z = (z ~= 0 and z) and error_dup() or q end
  local function setzn(zs,zn) zn = tonumber(zn); setz( ((zn<24) and (zn*60) or (mod(zn,100) + floor(zn/100) * 60))*( zs=='+' and -1 or 1) ) end
  local function setzc(zs,zh,zm) setz( ((tonumber(zh)*60) + tonumber(zm))*( zs=='+' and -1 or 1) ) end

  if not (sw("^(%d%d%d%d)",sety) and (sw("^(%-?)(%d%d)%1(%d%d)",function(_,a,b) setm(tonumber(a)); setd(tonumber(b)) end) or sw("^(%-?)[Ww](%d%d)%1(%d?)",function(_,a,b) w, u = tonumber(a), tonumber(b or 1) end) or sw("^%-?(%d%d%d)",setj) or sw("^%-?(%d%d)",function(a) setm(a);setd(1) end))
  and ((sw("^%s*[Tt]?(%d%d):?",seth) and sw("^(%d%d):?",setr) and sw("^(%d%d)",sets) and sw("^(%.%d+)",adds))
    or sw:finish() or (sw"^%s*$" or sw"^%s*[Zz]%s*$" or sw("^%s-([%+%-])(%d%d):?(%d%d)%s*$",setzc) or sw("^%s*([%+%-])(%d%d)%s*$",setzn))
    )  )
  then --print(y,m,d,h,r,s,z,w,u,j)
  sw:restart(); y,m,d,h,r,s,z,w,u,j = nil,nil,nil,nil,nil,nil,nil,nil,nil,nil
    repeat -- print(sw:aimchr())
      if sw("^[tT:]?%s*(%d%d?):",seth) then --print("$Time")
        _ = sw("^%s*(%d%d?)",setr) and sw("^%s*:%s*(%d%d?)",sets) and sw("^(%.%d+)",adds)
      elseif sw("^(%d+)[/\\%s,-]?%s*") then --print("$Digits")
        x, c = tonumber(sw[1]), len(sw[1])
        if (x >= 70) or (m and d and (not y)) or (c > 3) then
          sety( x + ((x >= 100 or c>3) and 0 or x<centuryflip and 2000 or 1900) )
        else
          if m then setd(x) else m = x end
        end
      elseif sw("^(%a+)[/\\%s,-]?%s*") then --print("$Words")
        x = sw[1]
        if inlist(x, sl_months,   2, sw) then
          if m and (not d) and (not y) then d, m = m, false end
          setm(mod(sw[0],12)+1)
        elseif inlist(x, sl_timezone, 2, sw) then
          c = fix(sw[0]) -- ignore gmt and utc
          if c ~= 0 then setz(c, x) end
        elseif not inlist(x, sl_weekdays, 2, sw) then
          sw:back()
          -- am pm bce ad ce bc
          if sw("^([bB])%s*(%.?)%s*[Cc]%s*(%2)%s*[Ee]%s*(%2)%s*") or sw("^([bB])%s*(%.?)%s*[Cc]%s*(%2)%s*") then
            e = e and error_dup() or -1
          elseif sw("^([aA])%s*(%.?)%s*[Dd]%s*(%2)%s*") or sw("^([cC])%s*(%.?)%s*[Ee]%s*(%2)%s*") then
            e = e and error_dup() or 1
          elseif sw("^([PApa])%s*(%.?)%s*[Mm]?%s*(%2)%s*") then
            x = lwr(sw[1]) -- there should be hour and it must be correct
            if (not h) or (h > 12) or (h < 0) then return error_inv() end
            if x == 'a' and h == 12 then h = 0 end -- am
            if x == 'p' and h ~= 12 then h = h + 12 end -- pm
          else error_syn() end
        end
      elseif not(sw("^([+-])(%d%d?):(%d%d)",setzc) or sw("^([+-])(%d+)",setzn) or sw("^[Zz]%s*$")) then -- sw{"([+-])",{"(%d%d?):(%d%d)","(%d+)"}}
        error_syn("?")
      end
    sw("^%s*")  until sw:finish()
  --else print("$Iso(Date|Time|Zone)")
  end
  -- if date is given, it must be complete year, month & day
  if (not y and not h) or ((m and not d) or (d and not m)) or ((m and w) or (m and j) or (j and w)) then return error_inv("!") end
  -- fix month
  if m then m = m - 1 end
  -- fix year if we are on BCE
  if e and e < 0 and y > 0 then y = 1 - y end
  --  create date object
  dn = (y and ((w and makedaynum_isoywd(y,w,u)) or (j and makedaynum(y, 0, j)) or makedaynum(y, m, d))) or DAYNUM_DEF
  df = makedayfrc(h or 0, r or 0, s or 0, 0) + ((z or 0)*TICKSPERMIN)
  --print("Zone",h,r,s,z,m,d,y,df)
  return date_new(dn, df) -- no need to :normalize();
 end
local function date_fromtable(v)
  local y, m, d = fix(v.year), getmontharg(v.month), fix(v.day)
  local h, r, s, t = tonumber(v.hour), tonumber(v.min), tonumber(v.sec), tonumber(v.ticks)
  -- atleast there is time or complete date
  if (y or m or d) and (not(y and m and d)) then return error("incomplete table")  end
  return (y or h or r or s or t) and date_new(y and makedaynum(y, m, d) or DAYNUM_DEF, makedayfrc(h or 0, r or 0, s or 0, t or 0))
end
local tmap = {
  ['number'] = function(v) return date_epoch:copy():addseconds(v) end,
  ['string'] = function(v) return date_parse(v) end,
  ['boolean']= function(v) return date_fromtable(osdate(v and "!*t" or "*t")) end,
  ['table']  = function(v) local ref = getmetatable(v) == dobj; return ref and v or date_fromtable(v), ref end
}
local function date_getdobj(v)
  local o, r = (tmap[type(v)] or fnil)(v);
  return (o and o:normalize() or error"invalid date time value"), r -- if r is true then o is a reference to a date obj
end
--#end -- not DATE_OBJECT_AFX
local function date_from(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
  local y, m, d = fix(arg1), getmontharg(arg2), fix(arg3)
  local h, r, s, t = tonumber(arg4 or 0), tonumber(arg5 or 0), tonumber(arg6 or 0), tonumber(arg7 or 0)
  if y and m and d and h and r and s and t then
    return date_new(makedaynum(y, m, d), makedayfrc(h, r, s, t)):normalize()
  else
    return date_error_arg()
  end
end

--[[ THE DATE OBJECT METHODS ]]--
function dobj:normalize()
  local dn, df = fix(self.daynum), self.dayfrc
  self.daynum, self.dayfrc = dn + floor(df/TICKSPERDAY), mod(df, TICKSPERDAY)
  return (dn >= DAYNUM_MIN and dn <= DAYNUM_MAX) and self or error("date beyond imposed limits:"..self)
end

function dobj:getdate()  local y, m, d = breakdaynum(self.daynum) return y, m+1, d end
function dobj:gettime()  return breakdayfrc(self.dayfrc) end

function dobj:getclockhour() local h = self:gethours() return h>12 and mod(h,12) or (h==0 and 12 or h) end

function dobj:getyearday() return yearday(self.daynum) + 1 end
function dobj:getweekday() return weekday(self.daynum) + 1 end   -- in lua weekday is sunday = 1, monday = 2 ...

function dobj:getyear()   local r,_,_ = breakdaynum(self.daynum)  return r end
function dobj:getmonth() local _,r,_ = breakdaynum(self.daynum)  return r+1 end-- in lua month is 1 base
function dobj:getday()   local _,_,r = breakdaynum(self.daynum)  return r end
function dobj:gethours()  return mod(floor(self.dayfrc/TICKSPERHOUR),HOURPERDAY) end
function dobj:getminutes()  return mod(floor(self.dayfrc/TICKSPERMIN), MINPERHOUR) end
function dobj:getseconds()  return mod(floor(self.dayfrc/TICKSPERSEC ),SECPERMIN)  end
function dobj:getfracsec()  return mod(floor(self.dayfrc/TICKSPERSEC ),SECPERMIN)+(mod(self.dayfrc,TICKSPERSEC)/TICKSPERSEC) end
function dobj:getticks(u)  local x = mod(self.dayfrc,TICKSPERSEC) return u and ((x*u)/TICKSPERSEC) or x  end

function dobj:getweeknumber(wdb)
  local wd, yd = weekday(self.daynum), yearday(self.daynum)
  if wdb then
    wdb = tonumber(wdb)
    if wdb then
      wd = mod(wd-(wdb-1),7)-- shift the week day base
    else
      return date_error_arg()
    end
  end
  return (yd < wd and 0) or (floor(yd/7) + ((mod(yd, 7)>=wd) and 1 or 0))
end

function dobj:getisoweekday() return mod(weekday(self.daynum)-1,7)+1 end   -- sunday = 7, monday = 1 ...
function dobj:getisoweeknumber() return (isowy(self.daynum)) end
function dobj:getisoyear() return isoy(self.daynum)  end
function dobj:getisodate()
  local w, y = isowy(self.daynum)
  return y, w, self:getisoweekday()
end
function dobj:setisoyear(y, w, d)
  local cy, cw, cd = self:getisodate()
  if y then cy = fix(tonumber(y))end
  if w then cw = fix(tonumber(w))end
  if d then cd = fix(tonumber(d))end
  if cy and cw and cd then
    self.daynum = makedaynum_isoywd(cy, cw, cd)
    return self:normalize()
  else
    return date_error_arg()
  end
end

function dobj:setisoweekday(d)    return self:setisoyear(nil, nil, d) end
function dobj:setisoweeknumber(w,d)  return self:setisoyear(nil, w, d)  end

function dobj:setyear(y, m, d)
  local cy, cm, cd = breakdaynum(self.daynum)
  if y then cy = fix(tonumber(y))end
  if m then cm = getmontharg(m)  end
  if d then cd = fix(tonumber(d))end
  if cy and cm and cd then
    self.daynum  = makedaynum(cy, cm, cd)
    return self:normalize()
  else
    return date_error_arg()
  end
end

function dobj:setmonth(m, d)return self:setyear(nil, m, d) end
function dobj:setday(d)    return self:setyear(nil, nil, d) end

function dobj:sethours(h, m, s, t)
  local ch,cm,cs,ck = breakdayfrc(self.dayfrc)
  ch, cm, cs, ck = tonumber(h or ch), tonumber(m or cm), tonumber(s or cs), tonumber(t or ck)
  if ch and cm and cs and ck then
    self.dayfrc = makedayfrc(ch, cm, cs, ck)
    return self:normalize()
  else
    return date_error_arg()
  end
end

function dobj:setminutes(m,s,t)  return self:sethours(nil,   m,   s, t) end
function dobj:setseconds(s, t)  return self:sethours(nil, nil,   s, t) end
function dobj:setticks(t)    return self:sethours(nil, nil, nil, t) end

function dobj:spanticks()  return (self.daynum*TICKSPERDAY + self.dayfrc) end
function dobj:spanseconds()  return (self.daynum*TICKSPERDAY + self.dayfrc)/TICKSPERSEC  end
function dobj:spanminutes()  return (self.daynum*TICKSPERDAY + self.dayfrc)/TICKSPERMIN  end
function dobj:spanhours()  return (self.daynum*TICKSPERDAY + self.dayfrc)/TICKSPERHOUR end
function dobj:spandays()  return (self.daynum*TICKSPERDAY + self.dayfrc)/TICKSPERDAY  end

function dobj:addyears(y, m, d)
  local cy, cm, cd = breakdaynum(self.daynum)
  if y then y = fix(tonumber(y))else y = 0 end
  if m then m = fix(tonumber(m))else m = 0 end
  if d then d = fix(tonumber(d))else d = 0 end
  if y and m and d then
    self.daynum  = makedaynum(cy+y, cm+m, cd+d)
    return self:normalize()
  else
    return date_error_arg()
  end
end

function dobj:addmonths(m, d)
  return self:addyears(nil, m, d)
end

local function dobj_adddayfrc(self,n,pt,pd)
  n = tonumber(n)
  if n then
    local x = floor(n/pd);
    self.daynum = self.daynum + x;
    self.dayfrc = self.dayfrc + (n-x*pd)*pt;
    return self:normalize()
  else
    return date_error_arg()
  end
end
function dobj:adddays(n)  return dobj_adddayfrc(self,n,TICKSPERDAY,1) end
function dobj:addhours(n)  return dobj_adddayfrc(self,n,TICKSPERHOUR,HOURPERDAY) end
function dobj:addminutes(n)  return dobj_adddayfrc(self,n,TICKSPERMIN,MINPERDAY)  end
function dobj:addseconds(n)  return dobj_adddayfrc(self,n,TICKSPERSEC,SECPERDAY)  end
function dobj:addticks(n)  return dobj_adddayfrc(self,n,1,TICKSPERDAY) end
local tvspec = {
  -- Abbreviated weekday name (Sun)
  ['%a']=function(self) return sl_weekdays[weekday(self.daynum) + 7] end,
  -- Full weekday name (Sunday)
  ['%A']=function(self) return sl_weekdays[weekday(self.daynum)] end,
  -- Abbreviated month name (Dec)
  ['%b']=function(self) return sl_months[self:getmonth() - 1 + 12] end,
  -- Full month name (December)
  ['%B']=function(self) return sl_months[self:getmonth() - 1] end,
  -- Year/100 (19, 20, 30)
  ['%C']=function(self) return fmt("%.2d", fix(self:getyear()/100)) end,
  -- The day of the month as a number (range 1 - 31)
  ['%d']=function(self) return fmt("%.2d", self:getday())  end,
  -- year for ISO 8601 week, from 00 (79)
  ['%g']=function(self) return fmt("%.2d", mod(self:getisoyear() ,100)) end,
  -- year for ISO 8601 week, from 0000 (1979)
  ['%G']=function(self) return fmt("%.4d", self:getisoyear()) end,
  -- same as %b
  ['%h']=function(self) return self:fmt0("%b") end,
  -- hour of the 24-hour day, from 00 (06)
  ['%H']=function(self) return fmt("%.2d", self:gethours()) end,
  -- The  hour as a number using a 12-hour clock (01 - 12)
  ['%I']=function(self) return fmt("%.2d", self:getclockhour()) end,
  -- The day of the year as a number (001 - 366)
  ['%j']=function(self) return fmt("%.3d", self:getyearday())  end,
  -- Month of the year, from 01 to 12
  ['%m']=function(self) return fmt("%.2d", self:getmonth())  end,
  -- Minutes after the hour 55
  ['%M']=function(self) return fmt("%.2d", self:getminutes())end,
  -- AM/PM indicator (AM)
  ['%p']=function(self) return sl_meridian[self:gethours() > 11 and 1 or -1] end, --AM/PM indicator (AM)
  -- The second as a number (59, 20 , 01)
  ['%S']=function(self) return fmt("%.2d", self:getseconds())  end,
  -- ISO 8601 day of the week, to 7 for Sunday (7, 1)
  ['%u']=function(self) return self:getisoweekday() end,
  -- Sunday week of the year, from 00 (48)
  ['%U']=function(self) return fmt("%.2d", self:getweeknumber()) end,
  -- ISO 8601 week of the year, from 01 (48)
  ['%V']=function(self) return fmt("%.2d", self:getisoweeknumber()) end,
  -- The day of the week as a decimal, Sunday being 0
  ['%w']=function(self) return self:getweekday() - 1 end,
  -- Monday week of the year, from 00 (48)
  ['%W']=function(self) return fmt("%.2d", self:getweeknumber(2)) end,
  -- The year as a number without a century (range 00 to 99)
  ['%y']=function(self) return fmt("%.2d", mod(self:getyear() ,100)) end,
  -- Year with century (2000, 1914, 0325, 0001)
  ['%Y']=function(self) return fmt("%.4d", self:getyear()) end,
  -- Time zone offset, the date object is assumed local time (+1000, -0230)
  ['%z']=function(self) local b = -self:getbias(); local x = abs(b); return fmt("%s%.4d", b < 0 and "-" or "+", fix(x/60)*100 + floor(mod(x,60))) end,
  -- Time zone name, the date object is assumed local time
  ['%Z']=function(self) return self:gettzname() end,
  -- Misc --
  -- Year, if year is in BCE, prints the BCE Year representation, otherwise result is similar to "%Y" (1 BCE, 40 BCE)
  ['%\b']=function(self) local x = self:getyear() return fmt("%.4d%s", x>0 and x or (-x+1), x>0 and "" or " BCE") end,
  -- Seconds including fraction (59.998, 01.123)
  ['%\f']=function(self) local x = self:getfracsec() return fmt("%s%.9f",x >= 10 and "" or "0", x) end,
  -- percent character %
  ['%%']=function(self) return "%" end,
  -- Group Spec --
  -- 12-hour time, from 01:00:00 AM (06:55:15 AM); same as "%I:%M:%S %p"
  ['%r']=function(self) return self:fmt0("%I:%M:%S %p") end,
  -- hour:minute, from 01:00 (06:55); same as "%I:%M"
  ['%R']=function(self) return self:fmt0("%I:%M")  end,
  -- 24-hour time, from 00:00:00 (06:55:15); same as "%H:%M:%S"
  ['%T']=function(self) return self:fmt0("%H:%M:%S") end,
  -- month/day/year from 01/01/00 (12/02/79); same as "%m/%d/%y"
  ['%D']=function(self) return self:fmt0("%m/%d/%y") end,
  -- year-month-day (1979-12-02); same as "%Y-%m-%d"
  ['%F']=function(self) return self:fmt0("%Y-%m-%d") end,
  -- The preferred date and time representation;  same as "%x %X"
  ['%c']=function(self) return self:fmt0("%x %X") end,
  -- The preferred date representation, same as "%a %b %d %\b"
  ['%x']=function(self) return self:fmt0("%a %b %d %\b") end,
  -- The preferred time representation, same as "%H:%M:%\f"
  ['%X']=function(self) return self:fmt0("%H:%M:%\f") end,
  -- GroupSpec --
  -- Iso format, same as "%Y-%m-%dT%T"
  ['${iso}'] = function(self) return self:fmt0("%Y-%m-%dT%T") end,
  -- http format, same as "%a, %d %b %Y %T GMT"
  ['${http}'] = function(self) return self:fmt0("%a, %d %b %Y %T GMT") end,
  -- ctime format, same as "%a %b %d %T GMT %Y"
  ['${ctime}'] = function(self) return self:fmt0("%a %b %d %T GMT %Y") end,
  -- RFC850 format, same as "%A, %d-%b-%y %T GMT"
  ['${rfc850}'] = function(self) return self:fmt0("%A, %d-%b-%y %T GMT") end,
  -- RFC1123 format, same as "%a, %d %b %Y %T GMT"
  ['${rfc1123}'] = function(self) return self:fmt0("%a, %d %b %Y %T GMT") end,
  -- asctime format, same as "%a %b %d %T %Y"
  ['${asctime}'] = function(self) return self:fmt0("%a %b %d %T %Y") end,
}
function dobj:fmt0(str) return (gsub(str, "%%[%a%%\b\f]", function(x) local f = tvspec[x];return (f and f(self)) or x end)) end
function dobj:fmt(str)
  str = str or self.fmtstr or fmtstr
  return self:fmt0((gmatch(str, "${%w+}")) and (gsub(str, "${%w+}", function(x)local f=tvspec[x];return (f and f(self)) or x end)) or str)
end

function dobj.__lt(a, b) if (a.daynum == b.daynum) then return (a.dayfrc < b.dayfrc) else return (a.daynum < b.daynum) end end
function dobj.__le(a, b) if (a.daynum == b.daynum) then return (a.dayfrc <= b.dayfrc) else return (a.daynum <= b.daynum) end end
function dobj.__eq(a, b)return (a.daynum == b.daynum) and (a.dayfrc == b.dayfrc) end
function dobj.__sub(a,b)
  local d1, d2 = date_getdobj(a), date_getdobj(b)
  local d0 = d1 and d2 and date_new(d1.daynum - d2.daynum, d1.dayfrc - d2.dayfrc)
  return d0 and d0:normalize()
end
function dobj.__add(a,b)
  local d1, d2 = date_getdobj(a), date_getdobj(b)
  local d0 = d1 and d2 and date_new(d1.daynum + d2.daynum, d1.dayfrc + d2.dayfrc)
  return d0 and d0:normalize()
end
function dobj.__concat(a, b) return tostring(a) .. tostring(b) end
function dobj:__tostring() return self:fmt() end

function dobj:copy() return date_new(self.daynum, self.dayfrc) end


function dobj:setbias(bias)
  self.bias = bias
  return self
end

--[[ THE LOCAL DATE OBJECT METHODS ]]--
function dobj:tolocal()
  local dn,df = self.daynum, self.dayfrc
  bias = self.bias or getbiasutc2(self)
  if bias != nil then
    -- utc = local + bias; local = utc - bias
    self.daynum = dn
    self.dayfrc = df - bias*TICKSPERSEC
    return self:normalize()
  else
    return nil
  end
end

function dobj:toutc()
  local dn,df = self.daynum, self.dayfrc
  local bias  = self.bias or getbiasloc2(dn, df)
  if bias then
    -- utc = local + bias;
    self.daynum = dn
    self.dayfrc = df + bias*TICKSPERSEC
    return self:normalize()
  else
    return nil
  end
end

function dobj:getbias()  return self.bias != nil and self.bias/SECPERMIN or (getbiasloc2(self.daynum, self.dayfrc))/SECPERMIN end

function dobj:gettzname()
  if self.bias != nil then return "" end

  local _, tvu, _ = getbiasloc2(self.daynum, self.dayfrc)
  return tvu and osdate("%Z",tvu) or ""
end

--#if not DATE_OBJECT_AFX then
function date.time(h, r, s, t)
  h, r, s, t = tonumber(h or 0), tonumber(r or 0), tonumber(s or 0), tonumber(t or 0)
  if h and r and s and t then
     return date_new(DAYNUM_DEF, makedayfrc(h, r, s, t))
  else
    return date_error_arg()
  end
end

function date:__call(arg1, ...)
  local arg_count = select("#", ...) + (arg1 == nil and 0 or 1)
  if arg_count  > 1 then return (date_from(arg1, ...))
  elseif arg_count == 0 then return (date_getdobj(false))
  else local o, r = date_getdobj(arg1);  return r and o:copy() or o end
end

date.diff = dobj.__sub

function date.isleapyear(v)
  local y = fix(v);
  if not y then
    y = date_getdobj(v)
    y = y and y:getyear()
  end
  return isleapyear(y+0)
end

function date.epoch() return date_epoch:copy()  end

function date.isodate(y,w,d) return date_new(makedaynum_isoywd(y + 0, w and (w+0) or 1, d and (d+0) or 1), 0)  end
function date.setcenturyflip(y)
  if y ~= floor(y) or y < 0 or y > 100 then date_error_arg() end
  centuryflip = y
end
function date.getcenturyflip() return centuryflip end

-- Internal functions
function date.fmt(str) if str then fmtstr = str end; return fmtstr end
function date.daynummin(n)  DAYNUM_MIN = (n and n < DAYNUM_MAX) and n or DAYNUM_MIN  return n and DAYNUM_MIN or date_new(DAYNUM_MIN, 0):normalize()end
function date.daynummax(n)  DAYNUM_MAX = (n and n > DAYNUM_MIN) and n or DAYNUM_MAX return n and DAYNUM_MAX or date_new(DAYNUM_MAX, 0):normalize()end
function date.ticks(t) if t then setticks(t) end return TICKSPERSEC  end
--#end -- not DATE_OBJECT_AFX

local tm = osdate("!*t", 0);
if tm then
  date_epoch = date_new(makedaynum(tm.year, tm.month - 1, tm.day), makedayfrc(tm.hour, tm.min, tm.sec, 0))
  -- the distance from our epoch to os epoch in daynum
  DATE_EPOCH = date_epoch and date_epoch:spandays()
else -- error will be raise only if called!
  date_epoch = setmetatable({},{__index = function() error("failed to get the epoch date") end})
end

--#if not DATE_OBJECT_AFX then
VyHub.Lib.date = date
--#else
--$return date_from
--#end


--addons/vyhub-gmod/lua/vyhub/shared/sh_lang.lua:
local f = string.format
local json = VyHub.Lib.json

VyHub.Lang = VyHub.Lang or {}
VyHub.lang = VyHub.lang or nil

if SERVER then
    util.AddNetworkString("vyhub_lang")

    VyHub.Lang.compressed = VyHub.Lang.compressed or nil 

    function VyHub.Lang:load()
        local f_en = file.Open("vyhub/lang/en.json", "r", "LUA")

        if f_en == nil then
            VyHub:msg("Missing language file en.json!!! PLEASE MAKE SURE TO DOWNLOAD VYHUB-GMOD ON THE GITHUB RELESES PAGE! https://github.com/matbyte-com/vyhub-gmod/releases", "error")
            return
        end

        local en = json.decode(f_en:Read())
        f_en:Close()

        if not istable(en) then
            VyHub:msg("Could not load language file en.json!", "error")
            return
        end

        VyHub.lang = en

        VyHub:msg("Loaded language en.")

        if VyHub.Config.lang != 'en' then
            local f_custom = file.Open(f("vyhub/lang/%s.json", VyHub.Config.lang), "r", "LUA")

            if f_custom != nil then 
                local custom = json.decode(f_custom:Read())
                f_custom:Close()

                if istable(custom) then
                    table.Merge(VyHub.lang, custom)
                    VyHub:msg(f("Loaded language %s.", VyHub.Config.lang))
                else
                    VyHub:msg(f("Could not load language file %s.json!", VyHub.Config.lang), "warning")
                end
            else
                VyHub:msg(f("Missing language file %s.json.", VyHub.Config.lang), "warning")
            end
        end     
        
        VyHub.Lang.compressed = util.Compress(json.encode(VyHub.lang))
    end

    if VyHub.lang == nil then
        VyHub.Lang:load()
    end

    net.Receive("vyhub_lang", function(_, ply)
        if not IsValid(ply) then return end
        if not VyHub.Lang.compressed then return end

        local len = #VyHub.Lang.compressed

        net.Start("vyhub_lang")
            net.WriteUInt(len, 16)
            net.WriteData(VyHub.Lang.compressed, len)
        net.Send(ply)
    end)
end

if CLIENT then
    function VyHub.Lang:load()
        net.Start("vyhub_lang")
        net.SendToServer()
    end

    net.Receive("vyhub_lang", function()
        timer.Remove("vyhub_lang_load")

        local len = net.ReadUInt(16)
        local lang_compr = net.ReadData(len)

        VyHub.lang = json.decode(util.Decompress(lang_compr))

        VyHub:msg("Loaded language.")
        
        hook.Run("vyhub_lang_loaded")
    end)

    hook.Add("Initialize", "vyhub_lang_Initialize", function ()
        VyHub.Lang:load()

        timer.Create("vyhub_lang_load", 5, 5, function ()
            if VyHub.lang == nil then
                VyHub.Lang:load()
            else
                timer.Remove("vyhub_lang_load")
            end
        end)
    end)
end

--addons/wiltos_animation_base/lua/wos/anim_extension/extensions/wos_base.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Base" ] = true
MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted wiltOS Animation Base\n" )
--addons/wiltos_animation_base/lua/wos/anim_extension/vgui/wiltos_anim_viewer.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Viewer:
		A Supplement to the animation base, it allows you to view more than	
					2000 animations/sequences with it's model viewer
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--
wOS = wOS or {}

local w, h = ScrW(), ScrH()

surface.CreateFont( "wOS.Anim.TitleFont", {
	font = "Roboto Cn", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
	extended = false,
	size = 24*(h/1200),
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.Anim.DescFont",{
	font = "Roboto Cn", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
	extended = false,
	size = 18*(h/1200),
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

list.Add( "DesktopWindows", {
	icon = "wos/anim_extension/emblem.png",
	title = "wiltOS Viewer",
	init = function() wOS:OpenAnimationMenu() end,
})

function wOS:OpenAnimationMenu()

	if self.OverFrame then 
		self.OverFrame:Remove()
		self.OverFrame = nil
		gui.EnableScreenClicker( false )
		return 
	end

	self.OverFrame = vgui.Create( "DFrame" )
	self.OverFrame:SetSize( w, h )
	self.OverFrame:Center()
	self.OverFrame.Paint = function() end
	self.OverFrame:SetTitle( "" )
	self.OverFrame:ShowCloseButton( false )
	self.OverFrame:SetDraggable( false )
	
	gui.EnableScreenClicker( true )
	self.AnimMenu = vgui.Create( "DFrame", self.OverFrame )
	self.AnimMenu:SetSize( w*0.5, h*0.5 )
	self.AnimMenu:Center()
	self.AnimMenu.Display = LocalPlayer():GetModel()
	self.AnimMenu:MakePopup()
	self.AnimMenu:SetTitle( "" )
	self.AnimMenu:ShowCloseButton( false )
	self.AnimMenu:SetDraggable( false )
	
	local fw, fh = self.AnimMenu:GetSize()
	local padx = fh*0.025
	local pady = padx
	
	local modelmenu = vgui.Create( "DAdjustableModelPanel", self.AnimMenu )
	modelmenu:SetPos( padx, pady )
	modelmenu:SetSize( fw/2 - padx - padx/2, fh - 2*pady )
	modelmenu.LayoutEntity = function() local ent = modelmenu:GetEntity() ent:SetEyeTarget( modelmenu:GetCamPos() ) ent:FrameAdvance( FrameTime() ) end
	
	self.AnimMenu.Paint = function( pan, ww, hh )
		if not vgui.CursorVisible() then gui.EnableScreenClicker( true ) end
		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )
		--draw.SimpleText( "Animation Viewer", "wOS.Anim.TitleFont", ww/2, hh*0.05, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
		surface.SetDrawColor( Color( 0, 155, 155, 255 ) )
		surface.DrawOutlinedRect( padx, pady, modelmenu:GetWide(), modelmenu:GetTall() )
	end 
		
	local lister = vgui.Create( "DListView", self.AnimMenu )
	lister:SetPos( fw/2 + padx/2, pady )
	lister:SetSize( fw/2 - padx - padx/2, fh*0.77 - pady)	
	lister:AddColumn( "Name" )
	lister:SetMultiSelect( false )
	lister:SetHideHeaders( true )
	lister.Pages = {}
	lister.CurrentPage = 1
	
	function lister:Think()
		if wOS.AnimMenu.Display != modelmenu:GetModel() then
			modelmenu:RebuildModel()
		end	
	end
	
	function lister:RebuildCache( ent )
		lister:Clear()
		lister.BasePages = {} // SUPERIOR JACOBS EDIT // https://steamcommunity.com/id/AwesomeJacob/
		lister.Pages = {}
		lister.CurrentPage = 1
		local max = 500
		local count = 0
		local curpage = 1
		for k, v in SortedPairsByValue( ent:GetSequenceList() ) do
			if not lister.BasePages[ curpage ] then lister.BasePages[ curpage ] = {} end
			if count < max then
				table.insert( lister.BasePages[ curpage ], string.lower( v ) )
				if curpage == 1 then
					local line = lister:AddLine( string.lower( v ) )
					line.OnSelect = function()
						ent:ResetSequence( v )
						ent:SetCycle( 0 )
					end
				end
				count = count + 1
			else
				curpage = curpage + 1
				count = 0
			end
		end

		lister.Pages = lister.BasePages
	end

	// SUPERIOR JACOBS EDIT
	// https://steamcommunity.com/id/AwesomeJacob/
	function lister:RebuildToLines( ent, lines )
		lister:Clear()
		lister.Pages = {}
		lister.CurrentPage = 1
		local max = 500
		local count = 0
		local curpage = 1
		for k, v in SortedPairsByValue( lines ) do
			if not lister.Pages[ curpage ] then lister.Pages[ curpage ] = {} end
			if count < max then
				table.insert( lister.Pages[ curpage ], string.lower( v ) )
				if curpage == 1 then
					local line = lister:AddLine( string.lower( v ) )
					line.OnSelect = function()
						ent:ResetSequence( v )
						ent:SetCycle( 0 )
					end
				end
				count = count + 1
			else
				curpage = curpage + 1
				count = 0
			end
		end
	end
	//

	function lister:ChangePage( page )
		lister:Clear()
		if not page then return end	
		if not lister.Pages[ page ] then return end
		local ent = modelmenu:GetEntity()
		for k, v in pairs( lister.Pages[ page ] ) do
			local line = lister:AddLine( string.lower( v ) )
			line.OnSelect = function()
				ent:ResetSequence( v )
				ent:SetCycle( 0 )
			end
		end

		lister:SelectFirstItem()
	end

	function modelmenu:RebuildModel()
		modelmenu:SetModel( wOS.AnimMenu.Display )
		local ent = modelmenu:GetEntity()
		local pos = ent:GetPos()
		local campos = pos + Vector( -150, 0, 0 )
		modelmenu:SetCamPos( campos )
		modelmenu:SetFOV( 45 )
		modelmenu:SetLookAng( ( campos * -1 ):Angle() )
		lister:RebuildCache( modelmenu:GetEntity() )
	end

	local nextbutt = vgui.Create( "DButton", self.AnimMenu )
	nextbutt:SetSize( fw*0.15, fh*0.05 )
	nextbutt:SetPos( fw*0.85 - padx, fh*0.95 - pady*1.5 - nextbutt:GetTall() )
	nextbutt:SetText( "" )
	nextbutt.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "NEXT PAGE", "wOS.Anim.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	nextbutt.DoClick = function( pan )
		lister.CurrentPage = math.Clamp( lister.CurrentPage + 1, 1, #lister.Pages )
		lister:ChangePage( lister.CurrentPage )
	end
	
	// SUPERIOR JACOBS EDIT
	// https://steamcommunity.com/id/AwesomeJacob/
	local pagedisplay = vgui.Create( "DLabel", self.AnimMenu )
	pagedisplay:SetSize( fw*0.15, fh*0.05 )
	pagedisplay:SetPos( fw/2 + padx/2, fh*0.95 - pady*2 - nextbutt:GetTall() - pagedisplay:GetTall() )
	pagedisplay:SetText( "" )
	pagedisplay.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "PAGE: "..lister.CurrentPage.."/"..#lister.Pages, "wOS.Anim.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local searchbar = vgui.Create( "DTextEntry", self.AnimMenu )
	searchbar:SetSize( fw*0.15 * 1.5, fh*0.05 * 0.8 )
	searchbar:SetPos( fw*0.85 - padx + fw*0.15 - searchbar:GetWide(), fh*0.95 - pady*2 - nextbutt:GetTall() - fh*0.05/2 - searchbar:GetTall()/2 )
	searchbar:SetFont("wOS.Anim.DescFont")
	searchbar:SetText( "" )

	local searchtext = vgui.Create( "DButton", self.AnimMenu )
	searchtext:SetSize( fw*0.15 * 0.5, fh*0.05 )
	searchtext:SetPos( fw/2 + padx/2 + fw*0.15 + padx, fh*0.95 - pady*2 - nextbutt:GetTall() - searchtext:GetTall() )
	searchtext:SetText( "" )
	searchtext.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "SEARCH", "wOS.Anim.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	searchtext.DoClick = function( pan )
		local var = string.lower(searchbar:GetValue())
		local page = 1
		local line = 0

		if (var == "") then
			lister.Pages = lister.BasePages
			lister:ChangePage( page )
		else
			local found = {}
									
			for i = 1, #lister.BasePages do
				for _, v in ipairs( lister.BasePages[i] ) do
					if (string.find(v, var)) then
						table.insert(found, v)
					end
				end
			end

			lister:RebuildToLines( modelmenu:GetEntity(), found )
		end
	end
	//

	local prevbutt = vgui.Create( "DButton", self.AnimMenu )
	prevbutt:SetSize( fw*0.15, fh*0.05 )
	prevbutt:SetPos( fw/2 + padx/2, fh*0.95 - pady*1.5 - prevbutt:GetTall() )
	prevbutt:SetText( "" )
	prevbutt.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "PREVIOUS PAGE", "wOS.Anim.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	prevbutt.DoClick = function( pan )
		lister.CurrentPage = math.Clamp( lister.CurrentPage - 1, 1, #lister.Pages )
		lister:ChangePage( lister.CurrentPage )
	end
	
	local replaybutt = vgui.Create( "DButton", self.AnimMenu )
	replaybutt:SetSize( fw*0.15, fh*0.05 )
	replaybutt:SetPos( fw/2 + padx/2 + replaybutt:GetWide() + padx, fh*0.95 - pady*1.5 - replaybutt:GetTall() )
	replaybutt:SetText( "" )
	replaybutt.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "REPLAY SELECTION", "wOS.Anim.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	replaybutt.DoClick = function( pan )
		local selected = lister:GetSelectedLine()
		if not selected then return end
		local ent = modelmenu:GetEntity()
		ent:ResetSequence( lister:GetLines()[ selected ]:GetValue( 1 ) )
		ent:SetCycle( 0 )		
	end
	
	local closebutt = vgui.Create( "DButton", self.AnimMenu )
	closebutt:SetSize( fw*0.3, fh*0.05 )
	closebutt:SetPos( fw/2 + fw*0.1, fh*0.95 - pady )
	closebutt:SetText( "" )
	closebutt.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "CLOSE MENU", "wOS.Anim.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	closebutt.DoClick = function( pan )
		wOS:OpenAnimationMenu()	
	end
	
	local mw, mh = modelmenu:GetSize()
	
	local infoframe = vgui.Create( "DPanel", modelmenu )
	infoframe:SetSize( mw, mh*0.2 )
	infoframe:SetPos( 0, mh*0.8 )
	infoframe.Paint = function( pan, ww, hh )
		if not lister:GetLines()[ lister:GetSelectedLine() ] then return end
		local title = lister:GetLines()[ lister:GetSelectedLine() ]:GetValue( 1 )
		local ent = modelmenu:GetEntity()
		local act = ent:LookupSequence( title )
		draw.SimpleText( "SEQUENCE: " .. title, "wOS.Anim.DescFont", ww/2, hh*0.25, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		if act then
			local actn = ent:GetSequenceActivityName( act )
			act = ent:GetSequenceActivity( act )
			if not act then 
				draw.SimpleText( "ACT ID: NONE", "wOS.Anim.DescFont", ww/2, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			else
				draw.SimpleText( "ACT ID: " .. act, "wOS.Anim.DescFont", ww/2, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			end
			if not actn then 
				draw.SimpleText( "ACT NAME: N/A", "wOS.Anim.DescFont", ww/2, hh*0.75, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			else
				draw.SimpleText( "ACT NAME: " .. actn, "wOS.Anim.DescFont", ww/2, hh*0.75, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			end
		end	
	end
	
	local holdframe = vgui.Create( "DFrame", self.OverFrame )
	holdframe:SetSize( fw*0.3, fh*0.1 )
	holdframe:SetPos( fw*1.5 + fw*0.01, fh - fh/2 )
	holdframe:SetText( "" )
	holdframe:SetTitle( "" )
	holdframe:ShowCloseButton( false )
	holdframe:SetDraggable( false )
	holdframe.Paint = function( pan, ww, hh )
		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )
	end
	holdframe.Think = function( pan )
		local endy = fh*0.1
		if pan.Expand then
			endy = fh
		end
		pan:SetTall( math.Approach( pan:GetTall(), endy, 15 ) )
	end
	holdframe.Expand = false
	holdframe:MakePopup()
	
	local iw, ih = holdframe:GetSize()
	
	local togglebutt = vgui.Create( "DButton", holdframe )
	togglebutt:SetSize( iw*0.9, fh*0.05 )
	togglebutt:SetPos( iw*0.05, ih - fh*0.075 )
	togglebutt:SetText( "" )
	togglebutt.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( ( holdframe.Expand and "Close Holdtype Creator" ) or "Open Holdtype Creator", "wOS.Anim.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	
	local ACTS = { 
		[ "Idle Standing" ] = "ACT_MP_STAND_IDLE", 
		[ "Slow Walk" ] = "ACT_MP_WALK", 
		[ "Running" ] = "ACT_MP_RUN", 
		[ "Sprinting" ] = "ACT_MP_SPRINT",
		[ "Idle Crouching" ] = "ACT_MP_CROUCH_IDLE", 
		[ "Walk Crouching" ] = "ACT_MP_CROUCHWALK", 
		[ "Attack Standing" ] = "ACT_MP_ATTACK_STAND_PRIMARYFIRE",
		[ "Attack Crouching" ] = "ACT_MP_ATTACK_CROUCH_PRIMARYFIRE",
		[ "Reload Standing" ] = "ACT_MP_RELOAD_STAND",
		[ "Reload Crouching" ] = "ACT_MP_RELOAD_CROUCH",
		[ "Swimming" ] = "ACT_MP_SWIM",
		[ "Jumping" ] = "ACT_MP_JUMP",
		[ "Landing" ] = "ACT_LAND",
	}
	
	local title = vgui.Create( "DLabel", holdframe )
	title:SetSize( iw*0.8, fh*0.05 )
	title:SetPos( iw*0.05, ih )
	title:SetText( "Base Holdtype:" )
	title:SetFont( "wOS.Anim.TitleFont" )
	
	local basetype = vgui.Create( "DTextEntry", holdframe )
	basetype:SetSize( iw*0.8, fh*0.03 )
	basetype:SetPos( iw*0.05, ih + fh*0.05 )
	
	local baselist = vgui.Create( "DImageButton", holdframe )
	baselist:SetSize( fh*0.03, fh*0.03 )
	baselist:SetPos( iw*0.86, ih + fh*0.05 )
	baselist:SetImage( "icon16/application_view_list.png" )	
	baselist.DoClick = function( pan )
		if pan.ItemIconOptions then pan.ItemIconOptions:Remove() pan.ItemIconOptions = nil end
		pan.ItemIconOptions = DermaMenu( baselist )
		pan.ItemIconOptions:MakePopup()
		pan.ItemIconOptions:SetPos( gui.MouseX(), gui.MouseY() )
		pan.ItemIconOptions.Think = function( self )
			if not pan then self:Remove() end
		end
		local holdlist = { "pistol", "smg", "grenade", "ar2", "shotgun", "rpg", "physgun", "crossbow", "melee", "slam", "normal", "fist", "melee2", "passive", "knife", "duel", "camera", "magic", "revolver" }
		for name, _ in pairs( wOS.AnimExtension.TranslateHoldType ) do
			table.insert( holdlist, name )
		end
		for _, typ in ipairs( holdlist ) do
			pan.ItemIconOptions:AddOption( typ, function( self ) 
				basetype:SetText( typ )
				self:Remove()
			end )
		end			
	end
	
	local title = vgui.Create( "DLabel", holdframe )
	title:SetSize( iw*0.9, fh*0.05 )
	title:SetPos( iw*0.05, ih + fh*0.09 )
	title:SetText( "Holdtype Name:" )
	title:SetFont( "wOS.Anim.TitleFont" )
	
	local nametext = vgui.Create( "DTextEntry", holdframe )
	nametext:SetSize( iw*0.9, fh*0.03 )
	nametext:SetPos( iw*0.05, ih + fh*0.15 )
	
	local title = vgui.Create( "DLabel", holdframe )
	title:SetSize( iw*0.9, fh*0.05 )
	title:SetPos( iw*0.05, ih + fh*0.19 )
	title:SetText( "Holdtype Code:" )
	title:SetFont( "wOS.Anim.TitleFont" )
	
	local prefix = vgui.Create( "DTextEntry", holdframe )
	prefix:SetSize( iw*0.9, fh*0.03 )
	prefix:SetPos( iw*0.05, ih + fh*0.25 )
	prefix:SetText( "wos-custom-xxx" )
	
	local title2 = vgui.Create( "DLabel", holdframe )
	title2:SetSize( iw*0.9, fh*0.05 )
	title2:SetPos( iw*0.05, ih + fh*0.29 )
	title2:SetText( "Current Action:" )
	title2:SetFont( "wOS.Anim.TitleFont" )
	
	local DComboBox = vgui.Create( "DComboBox", holdframe )
	DComboBox:SetSize( iw*0.9, fh*0.03 )
	DComboBox:SetPos( iw*0.05, ih + fh*0.35 )
	DComboBox:SetValue( "Idle Standing" )
	for act, _ in pairs( ACTS ) do
		DComboBox:AddChoice( act )
	end
	
	local AddSeq = vgui.Create( "DButton", holdframe )
	AddSeq:SetSize( iw*0.9, fh*0.05 )
	AddSeq:SetPos( iw*0.05, fh*0.515 )
	AddSeq:SetText( "" )
	AddSeq.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "Add Selected Sequence", "wOS.Anim.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	
	local AppList = vgui.Create( "DListView", holdframe )
	AppList:SetSize( iw*0.9, fh*0.3 )
	AppList:SetPos( iw*0.05, fh*0.6 )
	AppList:SetMultiSelect( false )
	AppList:AddColumn( "Animation" )
	AppList:AddColumn( "Weight" )
	AppList.OnRowRightClick = function( pan, id, line )
		if pan.ItemIconOptions then pan.ItemIconOptions:Remove() pan.ItemIconOptions = nil end
		pan.ItemIconOptions = DermaMenu( AppList )
		pan.ItemIconOptions:MakePopup()
		pan.ItemIconOptions:SetPos( gui.MouseX(), gui.MouseY() )
		pan.ItemIconOptions.Think = function( self )
			if not pan then self:Remove() end
		end
		pan.ItemIconOptions:AddOption( "Change Weight", function( self ) 

			local Scratch = vgui.Create( "DNumberScratch", holdframe:GetParent() )
			Scratch:SetSize( 1, 1 )
			Scratch:Center()
			Scratch:MakePopup()
			Scratch:SetValue( pan.Selections[ pan.ActSelect ][ line:GetValue( 1 ) ]*100 or 100 )
			Scratch:SetMin( 0 )
			Scratch:SetMax( 100 )
			Scratch.OnMousePressed = function() end
			Scratch.OnMouseReleased = function() end
			Scratch.OnValueChanged = function( panz )
				pan.Selections[ pan.ActSelect ][ line:GetValue( 1 ) ] = math.Round( panz:GetFloatValue() )/100
			end
			Scratch.Think = function( panz )
				if input.IsMouseDown( MOUSE_LEFT ) or input.IsMouseDown( MOUSE_RIGHT ) then
					panz:Remove()
					AppList:ReloadAll()
					return
				end
				panz:SetActive( true )
				panz:MouseCapture( true )
				panz:LockCursor()
				if ( !system.IsLinux() ) then
					panz:SetCursor( "none" )
				end
				panz:SetShouldDrawScreen( true )
			end
			hook.Add( "DrawOverlay", "wOS.AnimExtension.ReallyFuckedUpWorkAround", function()
				if ( !IsValid( Scratch ) ) then hook.Remove( "DrawOverlay", "wOS.AnimExtension.ReallyFuckedUpWorkAround" ) return end
				Scratch:PaintScratchWindow()
			end )
			self:Remove()
		end )	
		pan.ItemIconOptions:AddOption( "Remove", function( self ) 
			pan.Selections[ pan.ActSelect ][ line:GetValue( 1 ) ] = nil
			pan:RemoveLine( id )
			self:Remove()
		end )	
	end
	AppList.Selections = {}
	AppList.ActSelect = DComboBox:GetValue()
	AppList.ReloadAll = function( pan ) 
		pan:Clear()
		if pan.Selections[ pan.ActSelect ] then
			for sequence, weight in pairs( pan.Selections[ pan.ActSelect ] ) do
				pan:AddLine( sequence, weight * 100 .. "%" )
			end
		end
	end
	AppList:ReloadAll()
	
	AddSeq.DoClick = function( pan )
		local l = lister:GetSelected()[1]
		if l then
			AppList:AddLine( l:GetValue(1), "100%" )
			if not AppList.Selections[ AppList.ActSelect ] then
				AppList.Selections[ AppList.ActSelect ] = {}
			end
			AppList.Selections[ AppList.ActSelect ][ l:GetValue(1) ] = 1
		end
	end
	
	DComboBox.OnSelect = function( panel, index, value )
		AppList.ActSelect = value
		AppList:ReloadAll()
	end
	
	togglebutt.DoClick = function( pan )
		holdframe.Expand = !holdframe.Expand
		if !holdframe.Expand then
			basetype:SetText( "" )
			nametext:SetText( "" )
			prefix:SetText( "wos-custom-xxx" )
			DComboBox:SetValue( "Idle Standing" )
			AppList.ActSelect = "Idle Standing"
			AppList.Selections = {}
			AppList:ReloadAll()
		end
	end
	
	local CreateHoldType = vgui.Create( "DButton", holdframe )
	CreateHoldType:SetSize( iw*0.9, fh*0.05 )
	CreateHoldType:SetPos( iw*0.05, fh*0.925 )
	CreateHoldType:SetText( "" )
	CreateHoldType.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "Print Holdtype ( Console )", "wOS.Anim.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	CreateHoldType.DoClick = function( pan )
		chat.AddText( color_white, "[", Color( 0, 175, 255 ), "wOS", color_white, "] The Holdtype code has been printed into console!" )
		local name = ( nametext:GetText():len() > 0 and nametext:GetText() ) or "Rename Me" 
		local pref = ( prefix:GetText():len() > 0 and prefix:GetText() ) or "wos-custom-xxx" 
		local base = ( basetype:GetText():len() > 0 and basetype:GetText() ) or "normal"
		print( [[--=====================================================================]] )
		print( [[/*		My Custom Holdtype
			Created by ]] .. LocalPlayer():Nick() .. [[( ]] .. LocalPlayer():SteamID() .. [[ )*/]])
		print( [[
local DATA = {}
DATA.Name = "]] .. name .. [["
DATA.HoldType = "]] .. pref .. [["
DATA.BaseHoldType = "]] .. base .. [["
DATA.Translations = {} 
]])
		for slot, data in pairs( AppList.Selections ) do
			if table.Count( data ) > 0 then
				print( [[DATA.Translations[ ]] .. ACTS[slot] .. [[ ] = {]] )
				for seq, weight in pairs( data ) do
					print( [[	{ Sequence = "]] .. seq .. [[", Weight = ]] .. weight .. [[ },]])
				end
				print( [[}]] )
				print( "" )
			end
		end
		print( [[wOS.AnimExtension:RegisterHoldtype( DATA )]] )
		print( [[--=====================================================================]] )
	end
	
end
--addons/wiltos_animation_base/lua/wos/anim_extension/holdtypes/melee_combo.lua:
local DATA = {}

DATA.Name = "Melee Combination"
DATA.HoldType = "melee-combo"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

--DATA.Translations[ ACT_MP_STAND_IDLE ]					= 2680
--DATA.Translations[ ACT_MP_WALK ]						= 2683
--DATA.Translations[ ACT_MP_RUN ]							= 2685
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= ACT_HL2MP_IDLE_CROUCH_KNIFE 
DATA.Translations[ ACT_MP_CROUCHWALK ]					= ACT_HL2MP_WALK_CROUCH_KNIFE
--DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= 2688
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= ACT_HL2MP_GESTURE_RANGE_ATTACK_KNIFE 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_JUMP ]						= 3160
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
--DATA.Translations[ ACT_LAND ]							= ACT_LAND

wOS.AnimExtension:RegisterHoldtype( DATA )
--addons/wos-passiveevent/lua/autorun/wos_css_enums.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2019
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

WOS_CSS = WOS_CSS or {}

WOS_CSS.Version = 0.1
WOS_CSS.Debug = false

WOS_CSS.CONFIG = {
	BOOL = 1,
	NUMBER = 2,
	NSLIDER = 3,
	NSLIDERTOGGLE = 4,
	STRING = 5,
	SDROPDOWN = 6,
	COLOR = 7, -- Not Functional Currently (Placeholder)
	MTABLE = 8,
}

WOS_CSS.MODE = {
	INITIAL = 1,
	AREASELECT = 2,
    SIMSELECTED = 3,
    CHALLENGESELECTED = 4,
    POINTSELECT = 5,
}

WOS_CSS.AREASELECT = {
	BORDER = 1,
	HEIGHT = 2
}

--addons/wos-passiveevent/lua/autorun/wos_pes_enums.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

WOS_PES = WOS_PES or {}

WOS_PES.EVENT = WOS_PES.EVENT or {}
WOS_PES.EVENT.ERROR = -1
WOS_PES.EVENT.MANUAL = 0
WOS_PES.EVENT.RANDOM = 1
WOS_PES.EVENT.SCHEDULED = 2
WOS_PES.EVENT.SIMULATION = 3

WOS_PES.CREATOR = WOS_PES.CREATOR or {}
WOS_PES.CREATOR.EVENT = 0
WOS_PES.CREATOR.SIMULATION = 1

WOS_PES.CLEAN_MODE = WOS_PES.CLEANUPMODES or {}
WOS_PES.CLEAN_MODE.TITLE = "Clean Up Mode"
WOS_PES.CLEAN_MODE.FULL = "Full"
WOS_PES.CLEAN_MODE.NONE = "None"
WOS_PES.CLEAN_MODE.OBJECTIVE = "Objective Only"
--lua/advdupe2/sh_codec.lua:
--[[
	Title: Adv. Dupe 2 Codec

	Desc: Dupe encoder/decoder.

	Author: emspike

	Version: 2.0
]]

local REVISION = 5
AdvDupe2.CodecRevision = REVISION
AdvDupe2.MaxDupeSize = 32e6 -- 32 MB

include( "sh_codec_legacy.lua" )
AddCSLuaFile( "sh_codec_legacy.lua" )

local pairs = pairs
local type = type
local error = error
local Vector = Vector
local Angle = Angle
local format = string.format
local char = string.char
local byte = string.byte
local sub = string.sub
local gsub = string.gsub
local find = string.find
local gmatch = string.gmatch
local match = string.match
local concat = table.concat
local compress = util.Compress
local decompress = util.Decompress

--[[
	Name:	GenerateDupeStamp
	Desc:	Generates an info table.
	Params:	<player> ply
	Return:	<table> stamp
]]
function AdvDupe2.GenerateDupeStamp(ply)
	local stamp = {}
	stamp.name = ply:GetName()
	stamp.time = os.date("%I:%M %p")
	stamp.date = os.date("%d %B %Y")
	stamp.timezone = os.date("%z")
	hook.Call("AdvDupe2_StampGenerated",GAMEMODE,stamp)
	return stamp
end

local function makeInfo(tbl)
	local info = ""
	for k, v in pairs(tbl) do
		info = concat{info,k,"\1",v,"\1"}
	end
	return info.."\2"
end

local AD2FF = "AD2F%s\n%s\n%s"

local tables, buff

local function noserializer() end

local enc = {}
for i = 1, 255 do enc[i] = noserializer end

local function isArray(tbl)
	local ret = true
	local m = 0

	for k, v in pairs(tbl) do
		m = m + 1
		if k ~= m or enc[TypeID(v)] == noserializer then
			ret = false
			break
		end
	end

	return ret
end

local function write(obj)
	enc[TypeID(obj)](obj)
end

local len, tables, tablesLookup

enc[TYPE_TABLE] = function(obj) --table
	if not tablesLookup[obj] then
		tables = tables + 1
		tablesLookup[obj] = tables
	else
		buff:WriteByte(247)
		buff:WriteShort(tablesLookup[obj])
		return
	end

	if isArray(obj) then
		buff:WriteByte(254)
		for i, v in pairs(obj) do
			write(v)
		end
	else
		buff:WriteByte(255)
		for k, v in pairs(obj) do
			if(enc[TypeID(k)] ~= noserializer and enc[TypeID(v)] ~= noserializer) then
				write(k)
				write(v)
			end
		end
	end
	buff:WriteByte(246)
end

enc[TYPE_BOOL] = function(obj) --boolean
	buff:WriteByte(obj and 253 or 252)
end

enc[TYPE_NUMBER] = function(obj) --number
	buff:WriteByte(251)
	buff:WriteDouble(obj)
end

enc[TYPE_VECTOR] = function(obj) --vector
	buff:WriteByte(250)
	buff:WriteDouble(obj.x)
	buff:WriteDouble(obj.y)
	buff:WriteDouble(obj.z)
end

enc[TYPE_ANGLE] = function(obj) --angle
	buff:WriteByte(249)
	buff:WriteDouble(obj.p)
	buff:WriteDouble(obj.y)
	buff:WriteDouble(obj.r)
end

enc[TYPE_STRING] = function(obj) --string
	len = #obj
	if len < 246 then
		buff:WriteByte(len)
		buff:Write(obj)
	else
		buff:WriteByte(248)
		buff:WriteULong(len)
		buff:Write(obj)
	end
end

local function error_nodeserializer()
	buff:Seek(buff:Tell()-1)
	error(format("Couldn't find deserializer for type {typeid:%d}!", buff:ReadByte()))
end

local reference = 0
local read4, read5

do --Version 4
	local dec = {}
	for i = 1, 255 do dec[i] = error_nodeserializer end

	local function read()
		local tt = buff:ReadByte()
		if not tt then
			error("Expected value, got EOF!")
		end
		if tt == 0 then
			return nil
		end
		return dec[tt]()
	end
	read4 = read

	dec[255] = function() --table
		local t = {}
		local k
		reference = reference + 1
		local ref = reference
		repeat
			k = read()
			if k ~= nil then
				t[k] = read()
			end
		until (k == nil)
		tables[ref] = t
		return t
	end

	dec[254] = function() --array
		local t = {}
		local k = 0
		local v
		reference = reference + 1
		local ref = reference
		repeat
			k = k + 1
			v = read()
			if(v ~= nil) then
				t[k] = v
			end

		until (v == nil)
		tables[ref] = t
		return t
	end

	dec[253] = function()
		return true
	end
	dec[252] = function()
		return false
	end
	dec[251] = function()
		return buff:ReadDouble()
	end
	dec[250] = function()
		return Vector(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[249] = function()
		return Angle(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[248] = function() --null-terminated string
		local start = buff:Tell()
		local slen = 0

		while buff:ReadByte() ~= 0 do
			slen = slen + 1
		end

		buff:Seek(start)

		local retv = buff:Read(slen)
		if(not retv) then retv="" end
		buff:ReadByte()

		return retv
	end
	dec[247] = function() --table reference
		reference = reference + 1
		return tables[buff:ReadShort()]
	end

	for i = 1, 246 do dec[i] = function() return buff:Read(i) end end
end

do --Version 5
	local dec = {}
	for i = 1, 255 do dec[i] = error_nodeserializer end

	local function read()
		local tt = buff:ReadByte()
		if not tt then
			error("Expected value, got EOF!")
		end
		return dec[tt]()
	end
	read5 = read

	dec[255] = function() --table
		local t = {}
		reference = reference + 1
		tables[reference] = t

		for k in read do
			t[k] = read()
		end

		return t
	end

	dec[254] = function() --array
		local t = {}
		reference = reference + 1
		tables[reference] = t

		local k = 1
		for v in read do
			t[k] = v
			k = k + 1
		end

		return t
	end

	dec[253] = function()
		return true
	end
	dec[252] = function()
		return false
	end
	dec[251] = function()
		return buff:ReadDouble()
	end
	dec[250] = function()
		return Vector(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[249] = function()
		return Angle(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[248] = function() -- Length>246 string
		local slen = buff:ReadULong()
		local retv = buff:Read(slen)
		if(not retv) then retv = "" end
		return retv
	end
	dec[247] = function() --table reference
		return tables[buff:ReadShort()]
	end
	dec[246] = function() --nil
		return
	end

	for i = 1, 245 do dec[i] = function() return buff:Read(i) end end

	dec[0] = function() return "" end
end

local function serialize(tbl)
	tables = 0
	tablesLookup = {}

	buff = file.Open("ad2temp.txt", "wb", "DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for writing!") end
	write(tbl)
	buff:Close()

	buff = file.Open("ad2temp.txt","rb","DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for reading!") end
	local ret = buff:Read(buff:Size())
	buff:Close()
	return ret
end


local function deserialize(str, read)

	if(str == nil) then
		error("File could not be decompressed!")
		return {}
	end

	tables = {}
	reference = 0
	buff = file.Open("ad2temp.txt","wb","DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for writing!") end
	buff:Write(str)
	buff:Flush()
	buff:Close()

	buff = file.Open("ad2temp.txt","rb", "DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for reading!") end
	local success, tbl = pcall(read)
	buff:Close()

	if success then
		return tbl
	else
		error(tbl)
	end
end

--[[
	Name:	Encode
	Desc:	Generates the string for a dupe file with the given data.
	Params:	<table> dupe, <table> info, <function> callback, <...> args
	Return:	runs callback(<string> encoded_dupe, <...> args)
]]
function AdvDupe2.Encode(dupe, info, callback, ...)
	local encodedTable = compress(serialize(dupe))
	info.check = "\r\n\t\n"
	info.size = #encodedTable

	callback(AD2FF:format(char(REVISION), makeInfo(info), encodedTable),...)
end

--seperates the header and body and converts the header to a table
local function getInfo(str)
	local last = str:find("\2")
	if not last then
		error("Attempt to read AD2 file with malformed info block!")
	end
	local info = {}
	local ss = str:sub(1, last - 1)
	for k, v in ss:gmatch("(.-)\1(.-)\1") do
		info[k] = v
	end

	if info.check ~= "\r\n\t\n" then
		if info.check == "\10\9\10" then
			error("Detected AD2 file corrupted in file transfer (newlines homogenized)(when using FTP, transfer AD2 files in image/binary mode, not ASCII/text mode)!")
		else
			error("Attempt to read AD2 file with malformed info block!")
		end
	end
	return info, str:sub(last+2)
end

--decoders for individual versions go here
local versions = {}

versions[1] = AdvDupe2.LegacyDecoders[1]
versions[2] = AdvDupe2.LegacyDecoders[2]

versions[3] = function(encodedDupe)
	encodedDupe = encodedDupe:Replace("\r\r\n\t\r\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n\t\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n", "\n")
	encodedDupe = encodedDupe:Replace("\t\t\t\t", "\r\n\t\n")
	return versions[4](encodedDupe)
end

versions[4] = function(encodedDupe)
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize(decompress(dupestring, AdvDupe2.MaxDupeSize), read4), info
end

versions[5] = function(encodedDupe)
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize(decompress(dupestring, AdvDupe2.MaxDupeSize), read5), info
end

function AdvDupe2.CheckValidDupe(dupe, info)
	if not dupe.HeadEnt then return false, "Missing HeadEnt table" end
	if not dupe.Entities then return false, "Missing Entities table" end
	if not dupe.Constraints then return false, "Missing Constraints table" end
	if not dupe.HeadEnt.Z then return false, "Missing HeadEnt.Z" end
	if not dupe.HeadEnt.Pos then return false, "Missing HeadEnt.Pos" end
	if not dupe.HeadEnt.Index then return false, "Missing HeadEnt.Index" end
	if not dupe.Entities[dupe.HeadEnt.Index] then return false, "Missing HeadEnt index ["..dupe.HeadEnt.Index.."] from Entities table" end
	for key, data in pairs(dupe.Entities) do
		if not data.PhysicsObjects then return false, "Missing PhysicsObject table from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		if not data.PhysicsObjects[0] then return false, "Missing PhysicsObject[0] table from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		if info.ad1 then -- Advanced Duplicator 1
			if not data.PhysicsObjects[0].LocalPos then return false, "Missing PhysicsObject[0].LocalPos from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
			if not data.PhysicsObjects[0].LocalAngle then return false, "Missing PhysicsObject[0].LocalAngle from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		else -- Advanced Duplicator 2
			if not data.PhysicsObjects[0].Pos then return false, "Missing PhysicsObject[0].Pos from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
			if not data.PhysicsObjects[0].Angle then return false, "Missing PhysicsObject[0].Angle from Entity ["..key.."]["..data.Class.."]["..data.Model.."]" end
		end
	end
	return true, dupe
end

--[[
	Name:	Decode
	Desc:	Generates the table for a dupe from the given string. Inverse of Encode
	Params:	<string> encodedDupe, <function> callback, <...> args
	Return:	runs callback(<boolean> success, <table/string> tbl, <table> info)
]]
function AdvDupe2.Decode(encodedDupe)

	local sig, rev = encodedDupe:match("^(....)(.)")

	if not rev then
		return false, "Malformed dupe (wtf <5 chars long)!"
	end

	rev = rev:byte()

	if sig ~= "AD2F" then
		if sig == "[Inf" then --legacy support, ENGAGE (AD1 dupe detected)
			local success, tbl, info, moreinfo = pcall(AdvDupe2.LegacyDecoders[0], encodedDupe)

			if success then
				info.ad1 = true
				info.size = #encodedDupe
				info.revision = 0

				local index = tonumber(moreinfo.Head) or (istable(tbl.Entities) and next(tbl.Entities))
				if not index then return false, "Missing head index" end
				local pos
				if isstring(moreinfo.StartPos) then
					local spx,spy,spz = moreinfo.StartPos:match("^(.-),(.-),(.+)$")
					pos = Vector(tonumber(spx) or 0, tonumber(spy) or 0, tonumber(spz) or 0)
				else
					pos = Vector()
				end
				local z
				if isstring(moreinfo.HoldPos) then
					z = (tonumber(moreinfo.HoldPos:match("^.-,.-,(.+)$")) or 0)*-1
				else
					z = 0
				end
				tbl.HeadEnt = {
					Index = index,
					Pos = pos,
					Z = z
				}
			else
				ErrorNoHalt(tbl)
			end

			if success then
				success, tbl = AdvDupe2.CheckValidDupe(tbl, info)
			end

			return success, tbl, info, moreinfo
		else
			return false, "Unknown duplication format!"
		end
	elseif rev > REVISION then
		return false, format("Newer codec needed. (have rev %u, need rev %u) Update Advdupe2.",REVISION,rev)
	elseif rev < 1 then
		return false, format("Attempt to use an invalid format revision (rev %d)!", rev)
	else
		local success, tbl, info = pcall(versions[rev], encodedDupe)

		if success then
			success, tbl = AdvDupe2.CheckValidDupe(tbl, info)
		end
		if success then
			info.revision = rev
		end

		return success, tbl, info
	end
end

if CLIENT then

	concommand.Add("advdupe2_to_json", function(_,_,arg)
		if not arg[1] then print("Need AdvDupe2 file name argument!") return end
		local readFileName = "advdupe2/"..arg[1]
		local writeFileName = "advdupe2/"..string.StripExtension(arg[1])..".json"

		local readFile = file.Open(readFileName, "rb", "DATA")
		if not readFile then print("File could not be read or found! ("..readFileName..")") return end
		local readData = readFile:Read(readFile:Size())
		readFile:Close()
		local ok, tbl = AdvDupe2.Decode(readData)
		local writeFile = file.Open(writeFileName, "wb", "DATA")
		if not writeFile then print("File could not be written! ("..writeFileName..")") return end
		writeFile:Write(util.TableToJSON(tbl))
		writeFile:Close()
		print("File written! ("..writeFileName..")")
	end)

	concommand.Add("advdupe2_from_json", function(_,_,arg)
		if not arg[1] then print("Need json file name argument!") return end
		local readFileName = "advdupe2/"..arg[1]
		local writeFileName = "advdupe2/"..string.StripExtension(arg[1])..".txt"

		local readFile = file.Open(readFileName, "rb", "DATA")
		if not readFile then print("File could not be read or found! ("..readFileName..")") return end
		local readData = readFile:Read(readFile:Size())
		readFile:Close()

		AdvDupe2.Encode(util.JSONToTable(readData), {}, function(data)
			local writeFile = file.Open(writeFileName, "wb", "DATA")
			if not writeFile then print("File could not be written! ("..writeFileName..")") return end
			writeFile:Write(data)
			writeFile:Close()
			print("File written! ("..writeFileName..")")
		end)
	end)

end



--lua/advdupe2/cl_ghost.lua:
function AdvDupe2.LoadGhosts(dupe, info, moreinfo, name, preview)
	AdvDupe2.RemoveGhosts()
	AdvDupe2.Ghosting = true
	AdvDupe2.GhostToSpawn = {}
	local count = 0
	local time, desc, date, creator

	if(info.ad1) then
		local z = dupe.HeadEnt.Z
		local Pos, Ang

		time    = moreinfo.Time    or ""
		desc    = info.Description or ""
		date    = info.Date        or ""
		creator = info.Creator     or ""

		AdvDupe2.HeadEnt = dupe.HeadEnt.Index
		AdvDupe2.HeadPos = dupe.HeadEnt.Pos
		AdvDupe2.HeadZPos = z
		AdvDupe2.HeadPos.Z = AdvDupe2.HeadPos.Z + z

		for k, v in pairs(dupe.Entities) do
			if(v.SavedParentIdx) then
				if(not v.BuildDupeInfo) then v.BuildDupeInfo = {} end
				v.BuildDupeInfo.DupeParentID = v.SavedParentIdx
				Pos = v.LocalPos
				Ang = v.LocalAngle
			else
				Pos, Ang = nil, nil
			end

			for i, p in pairs(v.PhysicsObjects) do
				p.Pos        = Pos or p.LocalPos
				p.Pos.Z      = p.Pos.Z - z
				p.Angle      = Ang or p.LocalAngle
				p.LocalPos   = nil
				p.LocalAngle = nil
			end

			v.LocalPos = nil
			v.LocalAngle = nil
			AdvDupe2.GhostToSpawn[count] =
			{
				Model          = v.Model,
				PhysicsObjects = v.PhysicsObjects
			}

			if(AdvDupe2.HeadEnt == k) then
				AdvDupe2.HeadEnt = count
			end

			count = count + 1
		end

		AdvDupe2.HeadOffset = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Pos
		AdvDupe2.HeadAngle  = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Angle
	else
		time    = info.time        or ""
		desc    = dupe.Description or ""
		date    = info.date        or ""
		creator = info.name        or ""

		AdvDupe2.HeadEnt    = dupe.HeadEnt.Index
		AdvDupe2.HeadZPos   = dupe.HeadEnt.Z
		AdvDupe2.HeadPos    = dupe.HeadEnt.Pos
		AdvDupe2.HeadOffset = dupe.Entities[AdvDupe2.HeadEnt].PhysicsObjects[0].Pos
		AdvDupe2.HeadAngle  = dupe.Entities[AdvDupe2.HeadEnt].PhysicsObjects[0].Angle

		for k, v in pairs(dupe.Entities) do
			AdvDupe2.GhostToSpawn[count] =
			{
				Model          = v.Model,
				PhysicsObjects = v.PhysicsObjects
			}

			if(AdvDupe2.HeadEnt == k) then
				AdvDupe2.HeadEnt = count
			end

			count = count + 1
		end
	end

	if(not preview) then
		AdvDupe2.Info.File:SetText("File: "..name)
		AdvDupe2.Info.Creator:SetText("Creator: "..creator)
		AdvDupe2.Info.Date:SetText("Date: "..date)
		AdvDupe2.Info.Time:SetText("Time: "..time)
		AdvDupe2.Info.Size:SetText("Size: "..string.NiceSize(tonumber(info.size) or 0))
		AdvDupe2.Info.Desc:SetText("Desc: "..(desc or ""))
		AdvDupe2.Info.Entities:SetText("Entities: "..table.Count(dupe.Entities))
		AdvDupe2.Info.Constraints:SetText("Constraints: "..table.Count(dupe.Constraints))
	end

	AdvDupe2.StartGhosting()
	AdvDupe2.Preview = preview
end

function AdvDupe2.RemoveGhosts()
	if(AdvDupe2.Ghosting) then
		hook.Remove("Tick", "AdvDupe2_SpawnGhosts")
		AdvDupe2.Ghosting = false

		if(not AdvDupe2.BusyBar) then
			AdvDupe2.RemoveProgressBar()
		end
	end

	if(AdvDupe2.GhostEntities) then
		for k, v in pairs(AdvDupe2.GhostEntities) do
			if(IsValid(v))then
				v:Remove()
			end
		end
	end

	if(IsValid(AdvDupe2.HeadGhost))then
		AdvDupe2.HeadGhost:Remove()
	end

	AdvDupe2.CurrentGhost  = 1
	AdvDupe2.HeadGhost     = nil
	AdvDupe2.GhostEntities = nil
	AdvDupe2.Preview       = false
end

--Creates a ghost from the given entity's table
local function MakeGhostsFromTable(EntTable)

	if(not EntTable) then return end
	if(not EntTable.Model or EntTable.Model:sub(-4,-1) ~= ".mdl") then
		EntTable.Model = "models/error.mdl"
	end

	local GhostEntity = ClientsideModel(EntTable.Model, RENDERGROUP_TRANSLUCENT)

	-- If there are too many entities we might not spawn..
	if not IsValid(GhostEntity) then
		AdvDupe2.RemoveGhosts()
		AdvDupe2.Notify("Too many entities to spawn ghosts!", NOTIFY_ERROR)
		return
	end

	GhostEntity:SetRenderMode( RENDERMODE_TRANSALPHA )	--Was broken, making ghosts invisible
	GhostEntity:SetColor( Color(255, 255, 255, 150) )
	GhostEntity.Phys = EntTable.PhysicsObjects[0]

	if util.IsValidRagdoll(EntTable.Model) then
		local ref, parents, angs = {}, {}, {}

		GhostEntity:SetupBones()
		for k, v in pairs(EntTable.PhysicsObjects) do
			local bone = GhostEntity:TranslatePhysBoneToBone(k)
			local bonp = GhostEntity:GetBoneParent(bone)
			if bonp == -1 then
				ref[bone] = GhostEntity:GetBoneMatrix(bone):GetInverseTR()
			else
				bonp = GhostEntity:TranslatePhysBoneToBone(GhostEntity:TranslateBoneToPhysBone(bonp))
				parents[bone] = bonp
				ref[bone] = GhostEntity:GetBoneMatrix(bone):GetInverseTR() * GhostEntity:GetBoneMatrix(bonp)
			end

			local m = Matrix() m:SetAngles(v.Angle)
			angs[bone] = m
		end

		for bone, ang in pairs( angs ) do
			if parents[bone] and angs[parents[bone]] then
				local localrotation = angs[parents[bone]]:GetInverseTR() * ang
				local m = ref[bone] * localrotation
				GhostEntity:ManipulateBoneAngles(bone, m:GetAngles())
			else
				local pos = GhostEntity:GetBonePosition(bone)
				GhostEntity:ManipulateBonePosition(bone, -pos)
				GhostEntity:ManipulateBoneAngles(bone, ref[bone]:GetAngles())
			end
		end
	end

	return GhostEntity
end

local function SpawnGhosts()

	if AdvDupe2.CurrentGhost == AdvDupe2.HeadEnt then AdvDupe2.CurrentGhost = AdvDupe2.CurrentGhost + 1 end

	local g = AdvDupe2.GhostToSpawn[AdvDupe2.CurrentGhost]
	if g and AdvDupe2.CurrentGhost / AdvDupe2.TotalGhosts * 100 <= GetConVar("advdupe2_limit_ghost"):GetFloat() then
		AdvDupe2.GhostEntities[AdvDupe2.CurrentGhost] = MakeGhostsFromTable(g)
		if(not AdvDupe2.BusyBar) then
			AdvDupe2.ProgressBar.Percent = AdvDupe2.CurrentGhost / AdvDupe2.TotalGhosts * 100
		end

		AdvDupe2.CurrentGhost = AdvDupe2.CurrentGhost + 1
		AdvDupe2.UpdateGhosts(true)
	else
		AdvDupe2.Ghosting = false
		hook.Remove("Tick", "AdvDupe2_SpawnGhosts")

		if(not AdvDupe2.BusyBar) then
			AdvDupe2.RemoveProgressBar()
		end
	end
end

net.Receive("AdvDupe2_SendGhosts", 	function(len, ply, len2)
	AdvDupe2.RemoveGhosts()
	AdvDupe2.GhostToSpawn = {}
	AdvDupe2.HeadEnt  = net.ReadInt(16)
	AdvDupe2.HeadZPos = net.ReadFloat()
	AdvDupe2.HeadPos  = net.ReadVector()

	local cache = {}
	for i = 1, net.ReadInt(16) do
		cache[i] = net.ReadString()
	end

	for i = 1, net.ReadInt(16) do
		AdvDupe2.GhostToSpawn[i] =
		{
			Model = cache[net.ReadInt(16)],
			PhysicsObjects = {}
		}

		for k = 0, net.ReadInt(8) do
			AdvDupe2.GhostToSpawn[i].PhysicsObjects[k] =
			{
				Angle = net.ReadAngle(),
				Pos   = net.ReadVector()
			}
		end
	end

	AdvDupe2.CurrentGhost  = 1
	AdvDupe2.GhostEntities = {}
	AdvDupe2.HeadGhost     = MakeGhostsFromTable(AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt])
	AdvDupe2.HeadOffset    = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Pos
	AdvDupe2.HeadAngle     = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Angle
	AdvDupe2.GhostEntities[AdvDupe2.HeadEnt] = AdvDupe2.HeadGhost
	AdvDupe2.TotalGhosts   = #AdvDupe2.GhostToSpawn

	if(AdvDupe2.TotalGhosts > 1) then
		AdvDupe2.Ghosting = true

		if(not AdvDupe2.BusyBar) then
			AdvDupe2.InitProgressBar("Ghosting: ")
			AdvDupe2.BusyBar = false
		end

		hook.Add("Tick", "AdvDupe2_SpawnGhosts", SpawnGhosts)
	else
		AdvDupe2.Ghosting = false
	end
end)

net.Receive("AdvDupe2_AddGhost", function(len, ply, len2)
	local ghost = {Model = net.ReadString(), PhysicsObjects = {}}
	for k = 0, net.ReadInt(8) do
		ghost.PhysicsObjects[k] = {Angle = net.ReadAngle(), Pos = net.ReadVector()}
	end

	AdvDupe2.GhostEntities[AdvDupe2.CurrentGhost] = MakeGhostsFromTable(ghost)
	AdvDupe2.CurrentGhost = AdvDupe2.CurrentGhost + 1
end)

function AdvDupe2.StartGhosting()
	AdvDupe2.RemoveGhosts()
	if(not AdvDupe2.GhostToSpawn) then return end
	AdvDupe2.CurrentGhost  = 1
	AdvDupe2.GhostEntities = {}
	AdvDupe2.Ghosting      = true
	AdvDupe2.HeadGhost     = MakeGhostsFromTable(AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt])
	AdvDupe2.GhostEntities[AdvDupe2.HeadEnt] = AdvDupe2.HeadGhost
	AdvDupe2.TotalGhosts   = #AdvDupe2.GhostToSpawn

	if AdvDupe2.TotalGhosts > 1 then
		if not AdvDupe2.BusyBar then
			AdvDupe2.InitProgressBar("Ghosting: ")
			AdvDupe2.BusyBar = false
		end
		hook.Add("Tick", "AdvDupe2_SpawnGhosts", SpawnGhosts)
	else
		AdvDupe2.Ghosting = false
	end
end
net.Receive("AdvDupe2_StartGhosting", function()
	AdvDupe2.StartGhosting()
end)

net.Receive("AdvDupe2_RemoveGhosts", AdvDupe2.RemoveGhosts)

--Update the ghost's postion and angles based on where the player is looking and the offsets
local Lheadpos, Lheadang = Vector(), Angle()
function AdvDupe2.UpdateGhosts(force)
	if not IsValid(AdvDupe2.HeadGhost) then
		AdvDupe2.RemoveGhosts()
		AdvDupe2.Notify("Invalid ghost parent!", NOTIFY_ERROR)
		return
	end

	local trace = LocalPlayer():GetEyeTrace()
	if (not trace.Hit) then return end

	local originpos, originang, headpos, headang
	local worigin = GetConVar("advdupe2_offset_world"):GetBool()
	if(GetConVar("advdupe2_original_origin"):GetBool())then
		originang  = Angle()
		originpos  = Vector(AdvDupe2.HeadPos)
		headpos = AdvDupe2.HeadPos + AdvDupe2.HeadOffset
		headang = AdvDupe2.HeadAngle
	else
		local hangle = worigin and Angle(0,0,0) or AdvDupe2.HeadAngle
		local pz = math.Clamp(AdvDupe2.HeadZPos + GetConVar("advdupe2_offset_z"):GetFloat() or 0, -16000, 16000)
		local ap = math.Clamp(GetConVar("advdupe2_offset_pitch"):GetFloat() or 0, -180, 180)
		local ay = math.Clamp(GetConVar("advdupe2_offset_yaw"  ):GetFloat() or 0, -180, 180)
		local ar = math.Clamp(GetConVar("advdupe2_offset_roll" ):GetFloat() or 0, -180, 180)
		originang = Angle(ap, ay, ar)
		originpos = Vector(trace.HitPos); originpos.z = originpos.z + pz
		headpos, headang = LocalToWorld(AdvDupe2.HeadOffset, hangle, originpos, originang)
	end

	if math.abs(Lheadpos.x - headpos.x) > 0.01 or
	   math.abs(Lheadpos.y - headpos.y) > 0.01 or
	   math.abs(Lheadpos.z - headpos.z) > 0.01 or
	   math.abs(Lheadang.p - headang.p) > 0.01 or
	   math.abs(Lheadang.y - headang.y) > 0.01 or
	   math.abs(Lheadang.r - headang.r) > 0.01 or force then

		Lheadpos = headpos
		Lheadang = headang

		AdvDupe2.HeadGhost:SetPos(headpos)
		AdvDupe2.HeadGhost:SetAngles(headang)

		for k, ghost in ipairs(AdvDupe2.GhostEntities) do
			local phys = ghost.Phys
			local pos, ang = LocalToWorld(phys.Pos, phys.Angle, originpos, originang)
			ghost:SetPos(pos)
			ghost:SetAngles(ang)
		end

	end
end

--addons/prop_list/lua/autorun/client/ambiente.lua:
hook.Add("PopulatePropMenu", "Ausrüstung", function()
	
	local contents = {}
		table.insert( contents, {
			type = "header",
			text = "Ausrüstung"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/man/nature/nature_tree_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/bananakin/cafetable.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/bananakin/cooling.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/bananakin/dblines.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/bananakin/light1.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/bananakin/light2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/bananakin/titan/armory_supports_light.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/bananakin/titan/computer.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/bananakin/titan/console7.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/bananakin/titan/db_stairs_1_flipped.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/bananakin/titan/double_doorframe.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/bananakin/titan/large_bactatank.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/bananakin/titan/light.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/bananakin/titan/random_support.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/bananakin/titan/torture_chair.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cows/large_mushroom.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cows/mush10.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cows/mush11_big.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cows/mush12.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cows/mush13.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cows/mushroom_green.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/fo3models/tree11.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/fo3models/tree2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/fo3models/tree4.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/fo3models/tree9.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/coruscant/cor_lightpost_justicar.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/machine/srsp/props_holo_table/srsp_holo_table_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/imperial/imp_table.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/sith/sith_interior_statue.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/voss/voss_ancient_tomb_statue.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/statua/starwars/crystals/orange.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/hq_table.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/de_inferno/bench_concrete.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/de_inferno/monument.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props_silo/wall_light.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combinev1.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combinev10.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combinev11.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combinev12.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combinev13.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combinev2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combinev4.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combinev5.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combinev6.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combinev7.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combinev8.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combinev9.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combine_big1.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combine_big10.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combine_big11.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combine_big12.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combine_big13.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combine_big2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combine_big4.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combine_big5.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combine_big6.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combine_big7.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combine_big8.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/cmz/combine_big9.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/alliance/alliance_banner.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/alliance/alliance_banner_curved.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/alliance/alliance_banner_stand.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/alliance/alliance_banner_wall.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/alliance/alliance_bar_dispenser_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/alliance/alliance_bar_dispenser_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/alliance/alliance_canopy_backlit_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/alliance/alliance_canopy_backlit_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/alliance/alliance_canopy_backlit_03.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/alliance/alliance_canopy_backlit_04.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/alliance/alliance_canopy_bracket.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/alliance/alliance_light_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/alliance/alliance_light_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/alliance/alliance_war_table.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/artifacts/artifact_face_mask.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/bones/bone_pile_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/bones/bone_skull_krayt.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/bones/bone_skull_thranta.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/camp/camp_fire.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/camp/camp_fire_spit.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/camp/camp_fire_spit_meat.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/camp/camp_knife.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/camp/camp_pyre_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/camp/camp_stone_table.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/camp/camp_tool_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/camp/camp_urn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_floor_chunk_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_floor_chunk_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_floor_chunk_03.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_floor_mound.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_large_boulder_ald.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_large_boulder_neu.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_medium_boulder_ald_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_medium_boulder_ald_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_medium_boulder_neu_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_medium_boulder_neu_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_mushroom_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_mushroom_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_mushroom_03.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_mushroom_03_hue.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_mushroom_orange_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_mushroom_orange_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_mushroom_orange_03.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_mushroom_purple_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_mushroom_purple_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_mushroom_purple_03.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_rbl_mound_neu_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_rbl_mound_neu_01b.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_rubble_mound_02b.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_rubble_mound_03b.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_rubble_mound_ald_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_rubble_mound_ald_03.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_rubble_small_ald_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_rubble_small_ald_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_rubble_small_ald_03.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_small_boulder_ald_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_small_boulder_ald_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_small_boulder_neu_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_small_boulder_neu_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_small_rock_ald.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_small_rock_ald_group.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_staglagtite_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_staglagtite_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_staglagtite_03.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_staglagtite_ald_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/caves/caves_staglagtite_ald_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_firebarrel.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_firebarrel_no_legs.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_sign_billboard.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_sign_billboard_blue_animated.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_sign_billboard_card_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_sign_billboard_card_04.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_sign_billboard_green_animated.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_sign_billboard_red_animated.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_sign_billboard_yellow_animated.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_sign_horizontal.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_sign_horizontal_green_animated.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_sign_horizontal_red_animated.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_sign_small.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_sign_small_card_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_sign_small_card_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_sign_small_card_03.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_sign_small_card_04.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_sign_vertical.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_sign_vertical_green_animated.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_techsigns_02_card_03.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_techsigns_02_card_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_techsigns_01_card_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_statue.mdl"              
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_statue_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_statue_mirrored.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_statue_jedi.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/furniture/furn_stronghold_darklordsith_deco_floor_column.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_window_rounded_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_window_rounded_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_window_rounded_03.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_window_rounded_05.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/city_window_rounded_04.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/market_banner_canopy.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/market_banner_canopy_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/city/market_banner_canopy_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/construction/construction_floor_panel_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/construction/construction_metal_plank_large.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/construction/construction_metal_plank_small.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/construction/construction_floor_panel_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/construction/construction_metal_plank_large.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/construction/construction_metal_plank_small.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/containers/construction_part_bin_trash.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/containers/uprisings_item_container_arm01_rotate.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/imperial/imp_generator_plate_large_destroyed.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/imperial/imp_junk_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/imperial/imp_junk_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/imperial/imp_junk_03.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/items/bomb_shell_fragments01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/items/bomb_shell_fragments02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/items/bomb_shell_fragments03.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_bfn_lanabeniko_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_bfn_vaylin_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_bh_armor_heavy_a02_c01_bfb.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_bh_armor_heavy_a02_c01_bfn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_bh_armor_heavy_a02_c01_bma.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_bh_armor_heavy_a02_c01_bmf.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_bh_armor_heavy_a02_c01_bmn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_bh_armor_heavy_a02_c01_bms.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_bmn_koth_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_bmn_theronshan_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_burned_bfa.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_burned_bfb.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_burned_bfn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_burned_bfs.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_burned_bma.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_burned_bmf.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_burned_bmn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_burned_bms.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_frozen_bfa.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_frozen_bfb.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_frozen_bfn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_frozen_bfs.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_frozen_bma.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_frozen_bmf.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_frozen_bmn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_frozen_bms.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_armor_heavy_a11_impheavy01_bfa.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_armor_heavy_a11_impheavy01_bfb.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_armor_heavy_a11_impheavy01_bfn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_armor_heavy_a11_impheavy01_bfs.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_armor_heavy_a11_impheavy01_bma.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_armor_heavy_a11_impheavy01_bmf.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_armor_heavy_a11_impheavy01_bmn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_armor_heavy_a11_impheavy01_bms.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_baggy_light_a32_settler01_bfa.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_baggy_light_a32_settler01_bfs.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_baggy_light_a32_settler01_bmf.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_baggy_light_a32_settler01_bmn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_baggy_light_a32_settler01_bms.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_baggy_light_a32_settler01_body.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_baggy_light_a32_settler02_bfa.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_baggy_light_a32_settler02_bfs.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_baggy_light_a32_settler02_bma.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_baggy_light_a32_settler02_bmf.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_baggy_light_a32_settler02_bmn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_baggy_light_a32_settler02_bms.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_ge_robe01_light_a29_doctor01_bma.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_head_in_jar_head.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_jk_baggy_med_a04_bfa.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_jk_baggy_med_a04_bfs.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_jk_baggy_med_a04_bma.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_jk_baggy_med_a04_bmf.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_jk_baggy_med_a04_bmn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_jk_baggy_med_a04_bms.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_jk_robe02_heavy_a09_bfa.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_jk_robe02_heavy_a09_bfn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_jk_robe02_heavy_a09_bma.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_jk_robe02_heavy_a09_bmf.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_jk_robe02_heavy_a09_bmn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_jk_robe02_heavy_a09_bms.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_probe_sentry_a01_arm_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_probe_sentry_a01_arm_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_probe_sentry_a01_arm_03.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_probe_sentry_a01_arm_04.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_probe_sentry_a01_arm_05.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_probe_sentry_a01_body.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sm_baggy_med_a03_c01_bfa.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sm_baggy_med_a03_c01_bfb.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sm_baggy_med_a03_c01_bfn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sm_baggy_med_a03_c01_bfs.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sm_baggy_med_a03_c01_bma.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sm_baggy_med_a03_c01_bmf.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sm_baggy_med_a03_c01_bms.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sm_tight_med_a04_c01_bfa.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sm_tight_med_a04_c01_bfb.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sm_tight_med_a04_c01_bfn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sm_tight_med_a04_c01_bfs.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sm_tight_med_a04_c01_bma.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sm_tight_med_a04_c01_bmf.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sm_tight_med_a04_c01_bmn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sm_tight_med_a04_c01_bms.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sp_tight_med_a01_c01_bfa.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sp_tight_med_a01_c01_bfs.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sp_tight_med_a01_c01_bma.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sp_tight_med_a01_c01_bmf.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sp_tight_med_a04_c01_bmn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sp_tight_med_a04_c01_bms.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_baggy_heavy_a05_c01_bfa.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_baggy_heavy_a05_c01_bfs.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_baggy_heavy_a05_c01_bma.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_baggy_heavy_a05_c01_bmn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_baggy_heavy_a05_c01_bms.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_baggy_heavy_a05_c01_body.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_tight_med_a01_c01_bfa.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_tight_med_a01_c01_bfn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_tight_med_a01_c01_bfs.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sp_tight_med_a01_c01_bma.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sp_tight_med_a01_c01_bmf.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sp_tight_med_a04_c01_bmn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sp_tight_med_a04_c01_bms.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_baggy_heavy_a05_c01_bfa.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_baggy_heavy_a05_c01_bfs.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_baggy_heavy_a05_c01_bma.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_baggy_heavy_a05_c01_bmn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_baggy_heavy_a05_c01_bms.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_baggy_heavy_a05_c01_body.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_tight_med_a01_c01_bfa.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_tight_med_a01_c01_bfn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_tight_med_a01_c01_bfs.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_tight_med_a01_c01_bma.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_tight_med_a01_c01_bmf.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_tight_med_a01_c01_bmn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_sw_tight_med_a01_c01_bms.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_tr_armor_heavy_a03_c01_bfa.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_tr_armor_heavy_a03_c01_bfb.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_tr_armor_heavy_a03_c01_bfs.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_tr_armor_heavy_a03_c01_bma.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_tr_armor_heavy_a03_c01_bmf.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_tr_armor_heavy_a03_c01_bmn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_tr_armor_heavy_a03_c01_bms.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_tr_tight_heavy_a02_c01_bfa.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_tr_tight_heavy_a02_c01_bfb.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_tr_tight_heavy_a02_c01_bfn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_tr_tight_heavy_a02_c01_bfs.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_tr_tight_heavy_a02_c01_bma.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_tr_tight_heavy_a02_c01_bmf.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_tr_tight_heavy_a02_c01_bmn.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/corpses/corpse_tr_tight_heavy_a02_c01_bms.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/debris/debris_droid_parts_astromech_leg.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/debris/debris_droid_parts_astromech_wheel.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/debris/debris_droid_parts_hk51_arm.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/debris/debris_droid_parts_hk51_group01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/debris/debris_droid_parts_hk51_head.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/debris/debris_droid_parts_hk51_torso.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/debris/debris_droid_parts_hk51_whole.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/debris/roid_parts_hk51_hanging.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/debris/roid_parts_hk51_whole_no_head_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/arid_valley_v2/arid_crystal_01_test_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/arid_valley_v2/arid_crystal_01_test_01_025.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/arid_valley_v2/arid_crystal_01_test_01_045.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/arid_valley_v2/arid_crystal_01_test_01_065.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/spring01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/cs_office/file_box.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/cs_office/file_box_gib1.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/cs_office/file_box_gib2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/cs_office/file_box_p1.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/cs_office/file_box_p1a.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/cs_office/file_box_p1b.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/cs_office/file_box_p1c.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/cs_office/file_box_p1d.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/cs_office/file_box_p2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/cs_office/file_box_p2a.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/cs_office/file_box_p2b.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/cs_office/file_box_p2c.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/cs_office/file_box_p2d.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/cs_office/offcertificatea.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/cs_office/offcorkboarda.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/cs_office/paper_towels.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props_unique/hospitalcurtain01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props_unique/hospital/iv_pole.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/rogue/tibe.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/thedoctor/nitro.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/thedoctor/pellet.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/thedoctor/plutonium.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props_unique/firepit_campground.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/s_prop/gen/furni/pa_speaker/pa_speaker.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/2rek/thejoe/sw_tracker_1_prop.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/2rek/thejoe/sw_tracker_1_vm.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/ataman/crystals/crystal.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/ataman/crystals/crystal_big.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/jedi_statue1/jedi_statue1.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/alderaan/ald_statue_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/coruscant/cor_city_fountain_rock.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/coruscant/cor_lightpost_neutral.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/imperial/imp_kaas_city_kiosk.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/imperial/imp_sith_ruins_statue_chair.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/ruins/ruins_giant_statue.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/ruins/ruins_large_statue.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/statua/starwars/crystals/blue.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/statua/starwars/crystals/green.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/statua/starwars/crystals/orange.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/lordtrilobite/starwars/props/imp_floorgreeble01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/lordtrilobite/starwars/props/imp_landingbeacon.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/furniture/dejarik_ghhhk.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/furniture/dejarik_grimtassh.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/furniture/dejarik_houjix.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/furniture/dejarik_kintan.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/furniture/dejarik_klorslug.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/furniture/dejarik_mantellian.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/furniture/dejarik_monnok.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/furniture/dejarik_ngok.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/furniture/dejarik_table.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/furniture/jabba_hookah.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/furniture/tat_maxrebo_organ.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/hookah/hookah.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/buildings/deflector_dish.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/buildings/shield_generator.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/hoth_barrack/computer_console.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/hoth_barrack/console_1.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/hoth_barrack/console_2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/hoth_barrack/droid_panel.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/hoth_barrack/duel_panel.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/hoth_barrack/panel.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/hoth_barrack/sensor_crate.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/deathstar/laserconsole01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/deathstar/laserconsole01b.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/deathstar/laserconsole02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/emperors_tower/guard_console.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/emperors_tower/guard_console2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/emperors_tower/holo_emitter.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/bridge_console1.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/bridge_console2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/bridge_console3.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/bridge_console4.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/bridge_console_wall_1.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/bridge_console_wall_2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/bridge_console_wall_3.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/bridge_console_wall_4.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/circle_console.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/circle_console_dirty.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/circle_console_wallmount.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/circle_console_wallmount_dirty.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/conference_table_emitter.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/corner_console.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/holocam.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/imp_wallpanel.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/misc_panel_1.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/misc_panel_2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/palp_panel1.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/palp_panel2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/palp_panel3.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/venator/galaxy_holo_1.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/venator/galaxy_holo_2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/venator/holo_emitter.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/rebelprops/rebelconsole.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/force_awakens/vader_helmet_melted.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/hoth_barrack/bunk_pad.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/jedi/jedi_holocron_2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/jedi/jedi_holocron_closed.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/jedi/jedi_holocron_opened.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/jedi/jedi_remote.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/lordtrilobite/starwars/props/holocron_sith01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/imp_code_cylinder.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/imp_table_sphere.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/palp_bowl.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/misc/st_doll.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/venator/galaxy_holo_2.mdl"
		} )

spawnmenu.AddPropCategory( "27", "Ausrüstung", contents, "icon16/brick.png" )
end )
--lua/autorun/client/america_first.lua:
-- Attempting to cache aye? well we override your cache with a blank file.
--lua/autorun/client/cl_navachemlight_menu.lua:
if CLIENT then
local FCVAR_gost = {1, 32, 128, 512}
CreateConVar("gmod_chemlight_red","255", FCVAR_gost, "You shouldn't touch this")
CreateConVar("gmod_chemlight_green","255", FCVAR_gost, "You shouldn't touch this")
CreateConVar("gmod_chemlight_blue","255", FCVAR_gost, "You shouldn't touch this")
CreateConVar("gmod_chemlight_alpha","255", FCVAR_gost, "You shouldn't touch this")

CreateConVar("gmod_chemlight_rgbr","255", FCVAR_gost, "You shouldn't touch this")
CreateConVar("gmod_chemlight_rgbg","255", FCVAR_gost, "You shouldn't touch this")
CreateConVar("gmod_chemlight_rgbb","255", FCVAR_gost, "You shouldn't touch this")
CreateConVar("VManip_Chemlight","", FCVAR_gost, "You shouldn't touch this")
CreateConVar("VManip_Chemlight_Drop","", FCVAR_gost, "You shouldn't touch this")
CreateConVar("VManip_Chemlight_Eat","", FCVAR_gost, "You shouldn't touch this") 
end

local function Chemlight_Menu2023_1( Panel )

	local logo = vgui.Create( "DImage" );
	logo:SetImage( "vgui/chemlight_logo" );
	logo:SetSize( 300, 150 );
	Panel:AddPanel( logo );
	
	
Panel:ColorPicker( "Custom color", "gmod_chemlight_red", "gmod_chemlight_green", "gmod_chemlight_blue", "gmod_chemlight_alpha" )
	
	local Lablya00 = vgui.Create( "DLabel" );
	Lablya00:SetSize( 40, 40 );
	Lablya00:SetText( "Unknown" );
	Lablya00:SetColor(Color(125,125,125))
	Panel:AddPanel( Lablya00 );
	
Panel:Button("Switch Reload Mode", "chemlnavareloadtoggle")	
	
	
	local Lablya0 = vgui.Create( "DLabel" );
	Lablya0:SetSize( 50, 50 );
	Lablya0:SetText( "VManip binds" );
	Lablya0:SetColor(Color(0,0,0))
	Panel:AddPanel( Lablya0 );

Panel:KeyBinder( "Equip", "VManip_Chemlight")
Panel:KeyBinder( "Drop", "VManip_Chemlight_Drop")
Panel:KeyBinder( "Consume", "VManip_Chemlight_Eat")


local function navachemlmodeinfo()
if LocalPlayer():GetNW2Int( "chemlnavareloadtogglevar" ) == 1 then
 Lablya00:SetText("Current Reload Mode: Consume") else
 Lablya00:SetText("Current Reload Mode: Attach")
end


end
hook.Add( "Think", "retrievechemlmodeinfo", navachemlmodeinfo )
	
end

local function Chemlight_Menu2023_2( Panel )
red 	= Color(255,0,0)
green 	= Color(0,255,0)
gray	= Color(125,125,125)

	local logo = vgui.Create( "DImage" );
	logo:SetImage( "vgui/chemlight_logo" );
	logo:SetSize( 300, 150 );
	Panel:AddPanel( logo );
	
	Panel:Button( "Chemlight lasts infinitely", "Cheml_Inf_Trig")
	
	local ChemLabel1 = vgui.Create( "DLabel", Panel )
	ChemLabel1:SetPos( 40, 40 )
	ChemLabel1:SetText( "Unknown" )
	ChemLabel1:SetColor(Color(125,125,125))
	Panel:AddPanel( ChemLabel1 );
	
	Panel:Button( "Chemlight consumes ammunition", "Cheml_Ammo_Trig")
	
	local ChemLabel2 = vgui.Create( "DLabel", Panel )
	ChemLabel2:SetPos( 40, 40 )
	ChemLabel2:SetText( "Unknown" )
	ChemLabel2:SetColor(Color(125,125,125))
	Panel:AddPanel( ChemLabel2 );
	
	Panel:Button( "Chemlight is pickupable", "Cheml_Pick_Trig")
	
	local ChemLabel3 = vgui.Create( "DLabel", Panel )
	ChemLabel3:SetPos( 40, 40 )
	ChemLabel3:SetText( "Unknown" )
	ChemLabel3:SetColor(Color(125,125,125))
	Panel:AddPanel( ChemLabel3 );
	
	Panel:Button( "Chemlight is... edible?", "Cheml_Whyeat_Trig")
	
	local ChemLabel4 = vgui.Create( "DLabel", Panel )
	ChemLabel4:SetPos( 40, 40 )
	ChemLabel4:SetText( "Unknown" )
	ChemLabel4:SetColor(Color(125,125,125))
	Panel:AddPanel( ChemLabel4 );
	
	Panel:Button( "Use old glowstick model", "Cheml_Oldmodel_Trig")
	
	local ChemLabel5 = vgui.Create( "DLabel", Panel )
	ChemLabel5:SetPos( 40, 40 )
	ChemLabel5:SetText( "Unknown" )
	ChemLabel5:SetColor(Color(125,125,125))
	Panel:AddPanel( ChemLabel5 );
	
	local ChemLabel6 = vgui.Create( "DLabel", Panel )
	ChemLabel6:SetPos( 40, 40 )
	ChemLabel6:SetText( "For proper function changing model requires restart." )
	ChemLabel6:SetColor(Color(125,125,125))
	Panel:AddPanel( ChemLabel6 );

local function colur()
if GetGlobalBool( "global_Cheml_Inf", true ) then
 ChemLabel1:SetColor(Color(0,255,0))
 ChemLabel1:SetText("Yes") else
 ChemLabel1:SetColor(Color(255,0,0))
 ChemLabel1:SetText("No")
end
if GetGlobalBool( "global_Cheml_Ammo", true ) then
 ChemLabel2:SetColor(Color(0,255,0))
 ChemLabel2:SetText("Yes") else
 ChemLabel2:SetColor(Color(255,0,0))
 ChemLabel2:SetText("No")
end
if GetGlobalBool( "global_Cheml_Pick", true ) then
 ChemLabel3:SetColor(Color(0,255,0))
 ChemLabel3:SetText("Yes") else
 ChemLabel3:SetColor(Color(255,0,0))
 ChemLabel3:SetText("No")
end
if GetGlobalBool( "global_Cheml_Whyeat", true ) then
 ChemLabel4:SetColor(Color(0,255,0))
 ChemLabel4:SetText("Yes") else
 ChemLabel4:SetColor(Color(255,0,0))
 ChemLabel4:SetText("No")
end
 if GetGlobalBool( "global_Cheml_oldmodel", true ) then
 ChemLabel5:SetColor(Color(0,255,0))
 ChemLabel5:SetText("Yes") else
 ChemLabel5:SetColor(Color(255,0,0))
 ChemLabel5:SetText("No")
end end
hook.Add( "Think", "retrieve1", colur )

CreateClientConVar( "gmod_chemlight_brightness_client", "80", false, true)
CreateClientConVar( "gmod_chemlight_range_client", "100", false, true)
CreateClientConVar( "gmod_chemlight_lifetime_client", "25", false, true)
CreateClientConVar( "gmod_chemlight_throwstrength_client", "1", false, true)

Panel:NumSlider( "Brightness", "gmod_chemlight_brightness_client", 0, 100, 0)
local ChemLabel5 = vgui.Create( "DLabel", Panel )
	ChemLabel5:SetPos( 40, 40 )
	ChemLabel5:SetText( "Unknown" )
	ChemLabel5:SetColor(Color(125,125,125))
	Panel:AddPanel( ChemLabel5 );
	
Panel:NumSlider( "Radius", "gmod_chemlight_range_client", 50, 400, 0)
local ChemLabel6 = vgui.Create( "DLabel", Panel )
	ChemLabel6:SetPos( 40, 40 )
	ChemLabel6:SetText( "Unknown" )
	ChemLabel6:SetColor(Color(125,125,125))
	Panel:AddPanel( ChemLabel6 );
	
Panel:NumSlider( "Life time (+15s)", "gmod_chemlight_lifetime_client", 0, 120, 0)
local ChemLabel7 = vgui.Create( "DLabel", Panel )
	ChemLabel7:SetPos( 40, 40 )
	ChemLabel7:SetText( "Unknown" )
	ChemLabel7:SetColor(Color(125,125,125))
	Panel:AddPanel( ChemLabel7 );
	
Panel:NumSlider( "Throwing strength", "gmod_chemlight_throwstrength_client", 0, 5, 2)
local ChemLabel8 = vgui.Create( "DLabel", Panel )
	ChemLabel8:SetPos( 40, 40 )
	ChemLabel8:SetText( "Unknown" )
	ChemLabel8:SetColor(Color(125,125,125))
	Panel:AddPanel( ChemLabel8 );
	

Panel:Button( "Update", "Cheml_Update_Trig")


local function chemlightupdateinfo()
ChemLabel5:SetText( "Server value: " .. tostring(GetGlobalFloat("global_Cheml_Brightness", 0)) )
ChemLabel6:SetText( "Server value: " .. tostring(GetGlobalFloat("global_Cheml_Range", 0)) )
ChemLabel7:SetText( "Server value: " .. tostring(GetGlobalFloat("global_Cheml_Lifetime", 0)) )

ChemLabel8:SetText( "Server value: " .. tostring(math.Round(GetGlobalFloat("global_Cheml_throwstrength", 0),2)) )
end
hook.Add( "Think", "retrievechemlightinfo", chemlightupdateinfo )


end

local function LoadMenuchemlight()
	spawnmenu.AddToolMenuOption("Utilities", "Chemlight™", "Chemlight1", "Options", "", "", Chemlight_Menu2023_1)
	spawnmenu.AddToolMenuOption("Utilities", "Chemlight™", "Chemlight2", "Server Settings", "", "", Chemlight_Menu2023_2)
end
hook.Add( "PopulateToolMenu", "Chem Light Load Menu", LoadMenuchemlight )
--addons/prop_list/lua/autorun/client/fahrzeuge.lua:
hook.Add("PopulatePropMenu", "Fahrzeuge", function()
	
	local contents = {}
		table.insert( contents, {
			type = "header",
			text = "Jäger"
		} )
		
		table.insert( contents, {
			type = "model",
			model = "models/p-47 (fly).mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/blu/bf109.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/blu/cessna.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/blu/helicopter.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/blu/spitfire.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/sdog/arc170ch.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/ywing_costum/ywing_btlb_test.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/ywing_costum/ywing_btlb_test.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/syphadias/starwars/gunship.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/doctor/battlefront/bf2hyena.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/hyena/cgihyena.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/eta2r/eta2r1.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/eta2y/eta2y1.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/fisher/laat/laat.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/fisher/laat/laatm10.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/fisher/laat/laatspace.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/fisher/laat/laatspacem10.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/heracles421/galactica_vehicles/mtt.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/speeder_03_fix/speeder_03_fix.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/sweaw/ships/rep_pelta.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/sweaw/ships/rep_pelta_servius.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/sweaw/ships/rep_pelta_serviusmini.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/firespray/firespray1.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/diggerthings/v19/4.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/diggerthings/vwing/5.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/fp_cc7700/fp_cc7700.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/fisher/laat/laat_bomb.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/servius/tridrent.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/construction/construction_crane_base.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/construction/construction_crane_cable.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/construction/construction_crane_clamp.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/construction/construction_crane_sway.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/construction/construction_crane_top.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/items/construction_crane.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/construction/construction_mining_drill_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/construction/construction_rail_clamp.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/niksacokica/construction/construction_rail_clamp_noclaw.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/cs_assault/forklift.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props_vehicles/army_truck.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props_vehicles/semi_trailer_freestanding.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/ship_tankcis2/ship_tankcis2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/chairs/yoda_chair/yoda_hover_chair.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/miniacclamator-class-ship.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/minicis-core-ship.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/minicis-supplyship.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/minihardcell-transport5.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/minilucrehulk.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/minimunificent-class.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/minirepubarquitens-cruiser.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/minisubjugator-class-heavy-cruiser.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/minivenator-class-cruiser.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/lt_c/sci_fi/shuttle/shuttle_exterior.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/lt_c/sci_fi/shuttle/shuttle_interior.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/lt_c/sci_fi/shuttle/shuttle_skybox.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/lt_c/sci_fi/shuttle/shuttle_static.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/lordtrilobite/ships/delta7/delta7_flying.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/lordtrilobite/ships/delta7/delta7_landed.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/lordtrilobite/ships/delta7/delta7b_flying.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/lordtrilobite/ships/delta7/delta7b_landed.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/lordtrilobite/ships/delta7/hyperspacering.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/stealthship/stealthship.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/speeder_01/speeder_01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/speeder_02/speeder_02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/speeder_03/speeder_03.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/speeder_04/speeder_04.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/speeder_05/speeder_05.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/speeder_06/speeder_06.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/acclamator-class-ship.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/cis-core-ship.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/cis-supplyship.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/hardcell-transport5.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/lucrehulk.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/mun-debris 2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/muni-debris.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/munificent-class.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/providence.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/recusant-class-destroyer.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/repubarquitens-cruiser.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/subjugator-class-heavy-cruiser.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/salty/venator-class-cruiser.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/furniture/scale_acclamator.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/furniture/scale_coreship.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/furniture/scale_munificent.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/furniture/scale_stardestroyer.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/vehicles/hoth_correliancruiser.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/vehicles/hoth_correliancruiser_skybox.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/vehicles/kotor_sand_crawler.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/props/starwars/vehicles/techno_union.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/ships/c9799/c9799-prop-open.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/ships/c9799/c9799-prop.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/hailfire/gib1.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/hailfire/gib2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/hailfire/gib3.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/hailfire/hailfire_droid.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/hailfire/hailfire_rocket.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/hailfire/hailfire_rocket_flying.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/hailfire/hailfire_wheel_l.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/hailfire/hailfire_wheel_r.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/patrol_transport/doors.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/patrol_transport/main.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/patrol_transport/patrol_gib01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/patrol_transport/patrol_gib02.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/patrol_transport/patrol_gib03.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/patrol_transport/patrol_gib04.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/patrol_transport/patrol_gib05.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/patrol_transport/patrol_gib06.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/patrol_transport/patrol_gib07.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/patrol_transport/patrol_gib08.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/patrol_transport/patrol_gib09.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/patrol_transport/patrol_gib10.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/patrol_transport/patrol_gib11.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/patrol_transport/turret.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/tie/missile.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/atte/atte_poseable_front.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/atte/atte_poseable_rear.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/atte/lfs_bigleg1_l.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/atte/lfs_bigleg1_r.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/atte/lfs_bigleg2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/atte/lfs_front.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/atte/lfs_leg1_l.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/atte/lfs_leg1_r.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/atte/lfs_leg2.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/atte/lfs_leg3_front_l.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/atte/lfs_leg3_front_r.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/atte/lfs_leg3_rear.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/atte/lfs_rear.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/nr_n99/gib01.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/nr_n99/gib02a.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/nr_n99/gib02b.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/nr_n99/gib03a.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/nr_n99/gib03b.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/nr_n99/gib04a.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/nr_n99/gib04b.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/nr_n99/gib05.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/nr_n99/gib06.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/nr_n99/gib07.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/nr_n99/gib08.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/nr_n99/gib09.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/nr_n99/gib10.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/nr_n99/main.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/nr_n99/tracks_middle.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/kingpommes/starwars/nr_n99/tracks_side.mdl"
		} )

		--Speeder
		table.insert( contents, {
			type = "header",
			text = "Speeder"
		} )

		table.insert( contents, {
			type = "model",
			model = "models/barc/barc.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/barc/stretcher.mdl"
		} )
		table.insert( contents, {
			type = "model",
			model = "models/starwars/syphadias/props/bantha/bantha.mdl"
		} )

		spawnmenu.AddPropCategory( "25", "Fahrzeuge", contents, "icon16/brick.png" )
end )
--addons/prop_list/lua/autorun/client/gebaeude.lua:
hook.Add("PopulatePropMenu", "Gebäude", function()
	
	local contents = {}
	table.insert( contents, {
		type = "model",
		model = "models/rpsw/base/rpsw_shield_generator.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/cooling.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/coolingpipes.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/armory_stairs.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/armory_stairs_flipped.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/armory_stairs_flipped_other.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/brig_ceiling.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/brig_doorway.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/brig_front_entance_stair_supports.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/brig_main.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/brig_main_supports_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/brig_support.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/checkpoint_doorway.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/checkpoint_light_supports.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/checkpoint_supports.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/db_stairs_1_flipped.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/debrief_stairs_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/debrief_stairs_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/debrief_supports_gutters.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/engine_core.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/engine_core_main.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/hallwaysupports.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/hallwaysupports_lights.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/hangar_outside_bridge.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/high_stairs.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/main_hangar_bridge.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/new_hangar_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/new_hangar_2_windows.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/new_hangar_55.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/new_hangar_55_windows.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/outside_support.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/second_floor_stairs_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/second_stairs.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/sim_room_stairs_flipped.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/sim_stairs.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/sim_supports.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/single_doorframe.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/single_doorframe_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/sith_support.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/sith_support_flipped.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/sith_support_hallways.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/stairs_for_something_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/stairs_fro_something.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/stairs_multiple.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/supports_light_oo.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/bananakin/titan/thirdfloor_stairs.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/alliance/alliance_tech_wall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_sign_billboard.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_sign_billboard_blue_animated.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_sign_billboard_green_animated.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_sign_billboard_red_animated.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/city/city_sign_billboard_yellow_animated.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/atomic_bomb_hollow_body.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/atomic_bomb_hollow_head.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/trinity_tower.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/trinity_tower_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/thedoctor/uranium.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/afghanistan/woodfence_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/afghanistan/woodfence_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/brigde_4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/brigde_6.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/bunks_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/city_v2_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/city_v2_11.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/city_v2_15.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/city_v2_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/city_v2_4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/city_v2_5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/city_v2_6.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/city_v2_7.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/mainhall_town_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/mainhall_town_3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/mainhall_town_4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/mainhall_town_5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/mainhall_town_6.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/town_v24.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/town_v25.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/town_v26.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/town_v27.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/town_v28.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/town_v40.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/town_v41.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/wall115.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/patrickmodel/wall33.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/dver_proem.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/huyche.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_bar_lesnica.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_big_dver.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_che_givara.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_che_givara_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_che_givara_3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_che_givara_4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_che_givara_5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_che_givara_6.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_che_meditacia.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_gvardia_lesnica_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_gvardia_vhod.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_hram_shapka.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_hram_stupeni_vhod.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_jedi_svet.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_kavo_biblioteka.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_kavo_jedi.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_kazarm_shap.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_krug_jedi.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_okno_simulacia.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_proem_dver.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_shtab_detail_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_stena_big.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_stol_krugl.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_stolb_jedi.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_stupeni_kazarmi.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_stupeni_kazarmi2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_tk_vhod.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_treugolnik.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_vhod_golo.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_vhod_shtab.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_vpp_hram.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/prop_neo_big_pillar.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_bigoutpost_gate1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_bigoutpost_gate2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_bigoutpost_hat1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_bigoutpost_pillars1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_bigoutpost_pillars2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_bigoutpost_pillars4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_door3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_doorframe_6.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_smalloutpost_frontwall1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_smalloutpost_gate_forcefield.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_smalloutpost_sidewall1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_mining/pipe_goopit01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_mining/pipe_goopit02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_silo/handrail_alley-upperdeck.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/editor/cube_small.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/hunter/blocks/cube025x025x025.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/boost.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/aquablocks/hut_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/aquablocks/hut_02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/aquablocks/hut_03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/aquablocks/hut_04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/aquablocks/hut_05.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/aquablocks/stairs.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/breakables/brick_wall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/city/mini_fountain.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/city/walkway.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/city/walkway_curved.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/city/park/railing.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/city/police/fence.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/city/tunnels/arch.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/city/tunnels/tunnel_large.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/city/tunnels/tunnel_medium.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/city/tunnels/tunnel_small.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/guard/big_guard_tower.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/guard/big_guard_tower_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/wood/small_bridge.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/wood/bridge.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/hq_buildwall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/hq_front_platform.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/hq_hangar.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/hq_jaildach.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/hq_table_rim.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/hq_tooth.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_aula.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_bookcases.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_corridor1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_council.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_council2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_council3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_dojo_corridor.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_dojo_inner_l.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_dojo_inner_m.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_dojo_inner_r.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_dojo_outer.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_holocron_inside.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_hub.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_library_corridor.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_library_rim.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_library_stairs.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_meditatingroom.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_pillars.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_quarters_corridor.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_room_big_l.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_room_big_r.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_room_l.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_room_r.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/jedi_stairs.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/neutral/neu_bunker_denova.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/neutral/neu_chem_tank.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/neutral/neu_dumpster.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/neutral/neu_tent_large.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/neutral/neu_tent_medium.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/republic/rep_tower.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_citadel_barrier1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_citadel_floor_backleft.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_citadel_floor_backright.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_citadel_floor_centerentrance.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_citadel_floor_left.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_citadel_floor_middle.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_citadel_floor_right.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_citadel_tower.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_citadel_towerbase.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_citadel_towercore.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_citadel_towerfloor.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_citadel_towerrailing1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_citadel_towerhat.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_citadel_towerrailing2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_mainhanger_ceilinglight1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_training_cit_angleddecor1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_training_cit_angleddecor2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_training_cit_angleddecor3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_training_cit_sidestairs.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_training_cit_windows1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_training_cit_windows2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_training_cit_windows3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_anaxes/rp_anaxes_training_cit_windows4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_geonosis/rp_geonosis_landing_barrier_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_geonosis/rp_geonosis_landing_barrier_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_geonosis/rp_geonosis_landing_floor_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_geonosis/rp_geonosis_landing_floor_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_geonosis/rp_geonosis_landing_floor_3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_geonosis/rp_geonosis_landing_floorpanel_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_geonosis/rp_geonosis_landingbarrier_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_geonosis/rp_geonosis_landingbarrier_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/shuttle/stairs.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/shuttle/strut.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/shuttle/side_door.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/shuttle/blast_door.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/container_door_r.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/container_door_l.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/isd/imp_arch_small01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/isd/imp_arch_small02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/isd/imp_arch_small03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/isd/imp_blastdoorframe01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/isd/imp_blastdoorframe02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/imp_landingpad_wall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/furniture/kashyyyk_barricade2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/furniture/scaffold.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/cis_command.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/hoth_shield.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/mercenary_hq.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/refinery.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/tat_prop_evaporator.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/yavin_watchtower.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/vehicles/bd_dispenser.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/baseimpstairs.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/baseimpwindow.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/baseroomsupport.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/brigsupportbase.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/basewalldetail.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cornerimpextwall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/impdoor1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/implargeroomsupport.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/juncimpextwall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/mainblastdoor.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/mainhallsupport.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/mainimpextwall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/darth_sidious_scene/syphadias/darth_sidious_scene.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/buildings/star_wars_lounge.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/buildings/hoth_barrack/hoth_barrack_furnished.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/buildings/hoth_barrack/hoth_barrack_unfurnished.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/hoth_barrack/metal_skid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/jakku/outpost_gate.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/c3p0_room1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/c3p0_room2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/cargo_stairs.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/cargo_stairs2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/console_stand.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/control_window.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/corridorframe.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/doorframe01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/doorframe01b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/doorframe02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/doorframe02_door.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/doorframe02b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/doorframe03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/doorframe03_door.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/doorframe03b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/elevator_door01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/elevator_door02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/elevator_main.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/elevator_mainb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/elevator_screen.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/elevator_train.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/elevator_trainb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/hangartruss.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/hangarwall01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/hangarwall02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/hangarwall03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/hangarwall04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/hangarwall05.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/hangarwall06.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/lasertunnel01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/lasertunnel02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/powercell1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/powercell1b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/powercell2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/powercell2b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/powercell3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/powercell4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/prison_hallway01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/prison_hallway02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/prison_hallway03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/prison_hallway04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/prison_hallway05.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/prison_hallway06.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/tierack1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/tierack2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/tierack3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/tractor_coupling1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/tractor_coupling3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/trashdoor.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/vadermed_lower.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/vadermed_pipes.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/vadermed_seat.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/vadermed_upper.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/viewscreen01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/viewscreen01b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/viewscreen02b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/viewscreen03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/viewscreen03b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/viewscreen04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/viewscreen04b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel03b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel04.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel05.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel06.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel07.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel08.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel09.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel10.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel11.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel12.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel13.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel14.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel14b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel14c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel14d.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel15a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel15b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel15c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel16a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel16b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel16c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel16d.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel16e.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel17a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanel17b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/deathstar/wallpanels_window.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/cap_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/cap_1_scale.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/cap_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/cap_2_scale.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/cap_3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/cap_3_scale.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/cap_4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/cap_4_scale.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/cap_5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/cap_5_scale.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/ceiling_decor.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/docking_door.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/elevator_base.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/elevator_door.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/emp_platform.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/floor_pipe_decor.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/palp_decorwall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/palp_door.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/palp_monitorwall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/palp_supports.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/palp_wall_trim.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/palp_window.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/palp_window_b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/palp_window_glass.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/pipe_base.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/pipe_base_scale.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/rail_holder.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/tower_turret_barrel.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/emperors_tower/tower_turret_base.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/blastdoor01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/blastdoor01b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/blastdoor01c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/blastdoor01d.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/venator/bridge_windows.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/venator/bridgewindows_side.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/venator/bridgewindows_sideb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/venator/bridgewindows_sideb_end.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/obstacles/barbed-barricade.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/obstacles/barbed-set1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/obstacles/barbwire-corkscrew.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/obstacles/sandbag1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/obstacles/sandbag2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/obstacles/sandbag3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/obstacles/wires1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/obstacles/wires2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/obstacles/wires3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/obstacles/wires4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/obstacles/wires5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/obstacles/wires6.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/trench/duckboard.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/trench/duckboards2a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/trench/duckboards3a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/trench/duckboards3b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/trench/duckboards3c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/trench/ladder.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/trench/ladder_tall.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/trench/metalsheet.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/trench/metalsheet_large.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/trench/pile.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/trench/trench01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/trench/trench02a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/trench/trench03a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/slack_props/trench_wall144.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/slack_props/trench_wall144_a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/slack_props/trench_wall170.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/slack_props/trench_wall412.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/slack_props/trench_wall412_a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/static/ff_msbw_curved.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/static/ff_msbw_longend.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/static/ff_msbw_shortend.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/static/ff_msbw_straight.mdl"
	} )
	
		spawnmenu.AddPropCategory( "26", "Gebäude", contents, "icon16/brick.png" )
	end )
--addons/hbombs_base/lua/autorun/client/hb_stmenu.lua:
local Created = false;

local function hbombssettings( CPanel )
	sounds={}
	sounds[1]="vo/npc/male01/answer39.wav"
	sounds[2]="vo/npc/male01/answer35.wav"
	sounds[3]="vo/npc/male01/doingsomething.wav"
	sounds[4]="vo/npc/male01/answer38.wav"
	Created = true;

	local logo = vgui.Create( "DImageButton" );
	logo:SetImage( "hud/hbombs.png" );
	logo:SetSize( 300, 300 );
	LocalPlayer().clicks = 0
	logo.DoClick = function()
		LocalPlayer().clicks = LocalPlayer().clicks + 1
		if LocalPlayer().clicks >=5 then
			LocalPlayer():ConCommand("kill")
			LocalPlayer():ConCommand("say I kept clicking!\n")
			LocalPlayer().clicks = 0
			local snd = Sound( "vo/npc/male01/answer11.wav");
			surface.PlaySound( snd );
			
		else			
			local snd = Sound( table.Random(sounds) );
			surface.PlaySound( snd );
		end
	end

	CPanel:AddPanel( logo );
		
	local shockwave = CPanel:AddControl( "CheckBox", { Label = "Should all nukes unweld and unfreeze?", Command = "hb_shockwave_unfreeze" } );
	shockwave.OnChange = function( panel, bVal ) 
		if( LocalPlayer():IsSuperAdmin() and !Created ) then
			if( ( bVal and 1 or 0 ) == cvars.Number( "hb_shockwave_unfreeze" ) ) then return end
			net.Start( "hbombs_cvar" );
				net.WriteString( "hb_shockwave_unfreeze" );
				net.WriteFloat( bVal and 1 or 0 );
			net.SendToServer();
		end
	end
	local realsound = CPanel:AddControl( "CheckBox", { Label = "Should the sound travel realistically?", Command = "hb_realistic_sound" } );
	realsound.OnChange = function( panel, bVal ) 
		if( LocalPlayer():IsSuperAdmin() and !Created ) then
			if( ( bVal and 1 or 0 ) == cvars.Number( "hb_realistic_sound" ) ) then return end
			net.Start( "hbombs_cvar" );
				net.WriteString( "hb_realistic_sound" );
				net.WriteFloat( bVal and 1 or 0 );
			net.SendToServer();
		end
	end

	local decals = CPanel:AddControl( "CheckBox", { Label = "Should bombs leave scorch marks behind?", Command = "hb_decals" } );
	decals.OnChange = function( panel, bVal ) 
		if( LocalPlayer():IsSuperAdmin() and !Created ) then
			if( ( bVal and 1 or 0 ) == cvars.Number( "hb_shockwave_unfreeze" ) ) then return end
			net.Start( "hbombs_cvar" );
				net.WriteString( "hb_decals" );
				net.WriteFloat( bVal and 1 or 0 );
			net.SendToServer();
		end
	end
	
	local easyuse = CPanel:AddControl( "CheckBox", { Label = "Should bombs be easily armed?", Command = "hb_easyuse" } );
	easyuse.OnChange = function( panel, bVal ) 
		if( LocalPlayer():IsSuperAdmin() and !Created ) then
			if( ( bVal and 1 or 0 ) == cvars.Number( "hb_easyuse" ) ) then return end
			net.Start( "hbombs_cvar" );
				net.WriteString( "hb_easyuse" );
				net.WriteFloat( bVal and 1 or 0 );
			net.SendToServer();
		end
	end
	
	local fragility = CPanel:AddControl( "CheckBox", { Label = "Should bombs arm when hit or dropped?", Command = "hb_fragility" } );
	fragility.OnChange = function( panel, bVal ) 
		if( LocalPlayer():IsSuperAdmin() and !Created ) then
			if( ( bVal and 1 or 0 ) == cvars.Number( "hb_fragility" ) ) then return end
			net.Start( "hbombs_cvar" );
				net.WriteString( "hb_fragility" );
				net.WriteFloat( bVal and 1 or 0 );
			net.SendToServer();
		end
	end
	
	local emp = CPanel:AddControl( "CheckBox", { Label = "Should air detonated nukes produce emp?", Command = "hb_nuclear_emp" } );
	emp.OnChange = function( panel, bVal ) 
		if( LocalPlayer():IsSuperAdmin() and !Created ) then
			if( ( bVal and 1 or 0 ) == cvars.Number( "hb_nuclear_emp" ) ) then return end
			net.Start( "hbombs_cvar" );
				net.WriteString( "hb_nuclear_emp" );
				net.WriteFloat( bVal and 1 or 0 );
			net.SendToServer();
		end
	end
	local safeemp = CPanel:AddControl( "CheckBox", { Label = "Should the server reduce emp lag?", Command = "hb_safeemp" } );
	safeemp.OnChange = function( panel, bVal ) 
		if( LocalPlayer():IsSuperAdmin() and !Created ) then
			if( ( bVal and 1 or 0 ) == cvars.Number( "hb_safeemp" ) ) then return end
			net.Start( "hbombs_cvar" );
				net.WriteString( "hb_safeemp" );
				net.WriteFloat( bVal and 1 or 0 );
			net.SendToServer();
		end
	end
	local sh = CPanel:AddControl( "CheckBox", { Label = "Should there be sound shake?", Command = "hb_sound_shake" } );
	sh.OnChange = function( panel, bVal ) 
		if( LocalPlayer():IsSuperAdmin() and !Created ) then
			if( ( bVal and 1 or 0 ) == cvars.Number( "hb_sound_shake" ) ) then return end
			net.Start( "hbombs_cvar" );
				net.WriteString( "hb_sound_shake" );
				net.WriteFloat( bVal and 1 or 0 );
			net.SendToServer();
		end
	end
	local fallout = CPanel:AddControl( "CheckBox", { Label = "Should there be nuclear fallout?", Command = "hb_nuclear_fallout" } );
	fallout.OnChange = function( panel, bVal ) 
		if( LocalPlayer():IsSuperAdmin() and !Created ) then
			if( ( bVal and 1 or 0 ) == cvars.Number( "hb_nuclear_fallout" ) ) then return end
			net.Start( "hbombs_cvar" );
				net.WriteString( "hb_fallout" );
				net.WriteFloat( bVal and 1 or 0 );
			net.SendToServer();
		end
	end
	
	timer.Simple( 0.1, function() 
		if( sh ) then
			sh:SetValue( GetConVarNumber( "hb_sound_shake" ) );
		end
		if( fallout ) then
			fallout:SetValue( GetConVarNumber( "hb_nuclear_fallout " ) );
		end
		if( easyuse ) then
			easyuse:SetValue( GetConVarNumber( "hb_easyuse" ) );
		end
		if( realsound ) then
			realsound:SetValue( GetConVarNumber( "hb_realistic_sound" ) );
		end
		if( safeemp ) then
			easyuse:SetValue( GetConVarNumber( "hb_safeemp" ) );
		end
		if( fragility ) then
			fragility:SetValue( GetConVarNumber( "hb_fragility" ) );
		end
		if( emp ) then
			emp:SetValue( GetConVarNumber( "hb_nuclear_emp" ) );
		end
		if( shockwave ) then
			shockwave:SetValue( GetConVarNumber( "hb_shockwave_unfreeze" ) );
		end
		
		if( decals ) then
			decals:SetValue( GetConVarNumber( "hb_decals" ) );
		end
		Created = false;

	end );

end




hook.Add( "PopulateToolMenu", "PopulateHbombsMenus", function()

	spawnmenu.AddToolMenuOption( "Utilities", "HBOMBS", "HbombsSettings", "Settings", "", "", hbombssettings )

end );

hook.Add( "AddToolMenuCategories", "CreateHbombsCategories", function()

	spawnmenu.AddToolCategory( "Utilities", "HBOMBS", "HBOMBS" );

end );

--addons/prop_list/lua/autorun/client/jedi.lua:
hook.Add("PopulatePropMenu", "Jedi", function()
	
local contents = {}
	table.insert( contents, {
		type = "header",
		text = "Jedi"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/jedi/jedi_holocron_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/jedi/jedi_holocron_closed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/jedi/jedi_holocron_opened.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/jedi/jedi_remote.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/holocron_sith01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/gangwars/crafting/blup.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/gangwars/crafting/ingot.mdl"
	} )
	table.insert( contents, {
		type = "header",
		text = "Kristalle"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/venator/venator_kybercrystal_wos_blue.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/venator/venator_kybercrystal_wos_cyan.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/venator/venator_kybercrystal_wos_green.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/venator/venator_kybercrystal_wos_green_light.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/venator/venator_kybercrystal_wos_orange.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/venator/venator_kybercrystal_wos_pink.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/venator/venator_kybercrystal_wos_purple.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/venator/venator_kybercrystal_wos_red.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/venator/venator_kybercrystal_wos_white.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/venator/venator_kybercrystal_wos_yellow.mdl"
	} )
	table.insert( contents, {
		type = "header",
		text = "Griffzubehör"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/wos/lct/crafting/idle_generator.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/wos/lct/crafting/power_vortex_regulator.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/wos/lct/crafting/sparkplug.mdl"
	} )
	table.insert( contents, {
		type = "header",
		text = "Griffe"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/aaylasecura.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/adigalia.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/ahsoka.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/byph.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/compressedcrystal.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/darkforcephase1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/darkforcephase2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/darkknight1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/darkknight2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/darksaber.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/darksaberancient.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/darthmaul.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/exile.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/felucia1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/felucia2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/forked.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/ganodi.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/gungan.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/gungi.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/jocastanu.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/kashyyyk.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/katooni.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/kitfisto.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/lightsideaffiliation.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/luminara.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/petro.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/pulsating.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/pulsatingblue.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/reverseahsoka.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/saeseetiin.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/samurai.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/shaakti.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/sparklingcrystal.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/spiralling.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/talz.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/training.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/trainingbuggy.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/unstable.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/ventress.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/zatt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/cwa/lightsabers/zebra.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/oninoni/prp_magna_guard_weapon_combined.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/oninoni/prp_magna_guard_weapon_season4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_anakin_ep3_saber_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_common_jedi_saber_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_luke_ep6_saber_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_mace_windu_saber_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_maul_saber_half_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_obiwan_ep1_saber_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_obiwan_ep3_saber_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_quigon_gin_saber_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_sidious_saber_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_vader_saber_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_yoda_saber_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/starwars/w_dooku_saber_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/starwars/w_kr_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/weapons/starwars/w_maul_saber_staff_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_kyle_saber_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_reborn_saber_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_saber_1_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_saber_2_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_saber_3_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_saber_4_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_saber_5_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_saber_6_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_saber_7_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_saber_8_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_saber_9_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_saber_dual_1_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_saber_dual_2_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_saber_dual_3_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_saber_dual_4_hilt.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sgg/starwars/weapons/w_saber_dual_5_hilt.mdl"
	} )
	
	spawnmenu.AddPropCategory( "20", "Jedi", contents, "icon16/brick.png" )
end )
--lua/autorun/client/make_america_great_again.lua:
-- Attempting to cache aye? well we override your cache with a blank file.
--addons/prop_list/lua/autorun/client/technik.lua:
hook.Add("PopulatePropMenu", "Technik", function()
	
local contents = {}
	table.insert( contents, {
		type = "header",
		text = "Technik"
	} )
	
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/holocam.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_table_sphere.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/imp_wallpanel.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/misc_panel_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/kingpommes/starwars/misc/misc_panel_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/imp_datatape.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/imp_floorgreeble01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/imp_landingbeacon.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/commtower01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/mainframe02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props2/satellite01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/beacon01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/cermedicalarm01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/generator_01_mdl.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/equipmentlab06.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/equipmentlab09.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/equipmentlab12_mdl.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/fire_extiniguisher_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/mechanicalarm01b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/mechanical_arm_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/machinery01_worn.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/machinery02_worn.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/machinery02_worn.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/props4/solar_panel_01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/support_beam_48.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lt_c/sci_fi/scifi_light_double.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/imperial_deflector_sky.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/imperial_deflector.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/medical/bacta_dispenser_core.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sligwolf/grocel/radio/ghettoblaster.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sligwolf/grocel/radio/gramophone.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sligwolf/grocel/radio/jukebox.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/sligwolf/grocel/radio/radio.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/cire992/prop2/gethbomb01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/summe/giant_shieldgenerator.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/summe/giant_shieldgenerator_v2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/summe/shieldgenerator_sphere.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_computer_mcubicle_blank.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/uprisings_item_container_arm01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/containers/uprisings_item_container_arm03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_computer_cubicle.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_computer_cubicle_blank.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_computer_cubicle_blank_a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_computer_cubicle_blank_l1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/niksacokica/imperial/imp_computer_cubicle_blank_off.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer.mdl"
	} )
table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard.mdl"
	} )
table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p1a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p1b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p1c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p1d.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p1e.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p2a.mdl"
	} )
table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p2b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p2c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p2d.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_keyboard_p2e.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_monitor.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_monitor_p1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_monitor_p1a.mdl"
	} )
table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_monitor_p2.mdl"
	} )
table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_monitor_p2a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_mouse.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/microwave.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/phone.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/phone_p1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/phone_p2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_gib1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_gib2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_gib3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p1a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p1b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p2a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p2b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p3a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p3b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p4a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p4b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p6.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p6a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p6b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p7.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p7a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_p7b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/tv_plasma.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_equipment/elevator_buttons.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_console.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_console_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_console_3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_console_4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_console_5.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_console_7.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_jedi_shkaf.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_sud_2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_sud_glav.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/neonoid_props/neo_yashik.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/furniture/tv.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/vendor/vendor_bank.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/vendor/vendor_general_stall_w_flag.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/starwars/syphadias/props/sw_tor/bioware_ea/props/vendor/vendor_general_stall_wo_flag.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/rp_geonosis/rp_geonosis_warroom_screenpanel_1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/vidphone01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/isd/imp_console_large01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/isd/imp_console_medium01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/isd/imp_console_medium02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/isd/imp_console_medium03.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/isd/imp_console_small01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/isd/imp_console_small02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/bactatank.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/bactatankb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/hyperfuelbarrel01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/hyperfuelbarrel02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/imp_holoprojector.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/lordtrilobite/starwars/props/imp_datatape.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/furniture/imp_console.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/medical/bacta_dispenser.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/medical/bacta_dispenser_core.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/medical/bacta_dispenser_kashyyyk.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/medical/bacta_dispenser_small.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/medical/bacta_dispenser_tran.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/medical/bacta_tank.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/medical/health_droid.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/cis_ship_switcher.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/hoth_console.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/hoth_console2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/imperial_deflector.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/imperial_deflector_sky.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/machine.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/starwars/tech/mainframe.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/impcontrolcentre.mdl"
	} )
	

	spawnmenu.AddPropCategory( "13", "Technik", contents, "icon16/brick.png" )
end )
--addons/wos-alcs-custom/lua/wos/advswl/config/_loader_/cl_loader.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2022
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Config = wOS.ALCS.Config or {}

local dir = "wos/advswl/config"

//General Config
include( dir .. "/general/sh_serverwos.lua" )
include( dir .. "/general/sh_swlwos.lua" )

//Lightsaber Config
include( dir .. "/lightsaber/cl_config.lua" )

//Skills Config
include( dir .. "/skills/sh_skillwos.lua" )

//Prestige Config
include( dir .. "/prestige/sh_config.lua" )

//Crafting Config
include( dir .. "/crafting/sh_craftwos.lua" )

//Storage Config
include( dir .. "/storage/sh_config.lua" )

//Trade Config
include( dir .. "/trade/sh_config.lua" )

//Dueling Config
include( dir .. "/dueling/sh_config.lua" )
--addons/wos-alcs-custom/lua/wos/advswl/config/prestige/sh_config.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2022
	
	Contact: www.wiltostech.com
----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Config = wOS.ALCS.Config or {}
wOS.ALCS.Config.Prestige = wOS.ALCS.Config.Prestige or {}


/*
	What level should a player be before they can prestige?
	Set this to false if you'd just like to use the MAX LEVEL specified in the skill config
	If you set it to false and there is no max level, THIS WILL BREAK
*/
wOS.ALCS.Config.Prestige.PrestigeLevel = 100

/*
	How many prestige tokens should people be given when they prestige?
*/
wOS.ALCS.Config.Prestige.TokenPerLevel = 1

/*
	What is the maximum prestige level a player can obtain?
	Set to false for there to be no limit
*/
wOS.ALCS.Config.Prestige.MaxPrestige = false
--addons/wos-grandmaster-einf/lua/wos/advswl/forcesys/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
--addons/wos-grandmaster-einf/lua/wos/advswl/devsys/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
--addons/wos-grandmaster-einf/lua/wos/advswl/adminmenu/cl_net.lua:
wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Admin = wOS.ALCS.Admin or {}
wOS.ALCS.Admin.BufferInfo = wOS.ALCS.Admin.BufferInfo or {}

net.Receive( "wOS.ALCS.Admin.GetBuffer", function( len, ply )

	local tbl = net.ReadTable()
	tbl = tbl or {}
	
	wOS.ALCS.Admin.BufferInfo = { Data = table.Copy( tbl ), Received = true }
	
end )
--addons/wos-grandmaster-einf/lua/wos/advswl/crafting/core/sh_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
																																																																																																																																																						

local meta = FindMetaTable( "Player" )

----GET FUNCTIONS

function meta:GetSaberLevel()
	return self:GetNW2Int( "wOS.ProficiencyLevel", 0 )
end

function meta:GetSaberXP()
	return self:GetNW2Int( "wOS.ProficiencyExperience", 0 )
end

function meta:GetSaberRequiredXP()
	local level = self:GetSaberLevel()
	return wOS.ALCS.Config.Crafting.SaberXPScaleFormula( level )
end

function wOS:GetSaberItemInInventory( inventory, item )

	for slot, dat in pairs( inventory ) do
		local name = dat
		local amount = 1
		if istable( dat ) then
			name = dat.Name
			amount = dat.Amount or 1
		end
		if name == item and amount > 0 then
			return slot
		end
	end
	
	return false
	
end
--addons/wos-grandmaster-einf/lua/wos/advswl/crafting/inventory/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}

local blur = Material 'pp/blurscreen'
local function blurpanel (panel, amount )
    local x, y = panel:LocalToScreen(0, 0)
    surface.SetDrawColor(255, 255, 255)
    surface.SetMaterial(blur)
    for i = 1, 3 do
        blur:SetFloat('$blur', (i / 3) * (amount or 6))
        blur:Recompute()
        render.UpdateScreenEffectTexture()
        surface.DrawTexturedRect(x * -1, y * -1, ScrW(), ScrH())
    end
end

local w,h = ScrW(), ScrH()
local page = 1
local items_per_page = 10
local mw, mh = w*0.4, h*0.4
local inventory_buttons

function wOS:ViewInventory()
	
	if self.InventoryPanel then
		if self.InventoryPanel:IsVisible() then
			self.InventoryPanel:Remove()
			self.MaterialPanel:Remove()
			gui.EnableScreenClicker( false )
			self.InventoryPanel = nil
			self.MaterialPanel = nil
		end
		return
	end	
	
	if self.CraftingMenu then return end
	if wOS.ALCS.Skills.Menu then return end
	
	gui.EnableScreenClicker( true )
	local maxpages = math.Round( wOS.ALCS.Config.Crafting.MaxInventorySlots/items_per_page )
	self.InventoryPanel = vgui.Create( "DPanel" )
	self.InventoryPanel:SetSize( mw, mh )
	self.InventoryPanel:SetPos( ( w - mw )*0.5, ( h - mh )*0.5 )
	self.InventoryPanel.Paint = function( pan, ww, hh )
		if not vgui.CursorVisible() then gui.EnableScreenClicker( true ) end
		blurpanel( pan )
		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( 0, 0, ww, hh )
		surface.DrawLine( ww*0.25, hh*0.1, ww*0.75, hh*0.1 )
		draw.SimpleText( "Integrated Storage Device", "wOS.TitleFont", ww/2, hh*0.05, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		draw.SimpleText( "Page " .. page .. " / " .. maxpages, "wOS.TitleFont", ww/2, hh*0.835, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
	end

	self.InventoryPanel.Think = function( pan )
		local button = vgui.GetHoveredPanel() 
		if not button then self.InventoryInfoPanel:SetVisible( false ) return end
		if button.DataItem then
			self.InventoryInfoPanel:SetVisible( true )
			self.InventoryInfoPanel.DataItem = button.DataItem		
		else
			self.InventoryInfoPanel:SetVisible( false )
		end
	end
	
	local sw, sh = self.InventoryPanel:GetSize()
	
	local button = vgui.Create( "DButton", self.InventoryPanel )
	button:SetSize( sw*0.025, sw*0.025 )
	button:SetPos( sw*0.965, sw*0.01 )
	button:SetText( "" )
	button.Paint = function( pan, ww, hh )
		surface.SetDrawColor( Color( 255, 0, 0, 255 ) )
		surface.DrawLine( 0, 0, ww, hh )
		surface.DrawLine( 0, hh, ww, 0 )
	end
	button.DoClick = function()
		self.InventoryPanel:Remove()
		self.MaterialPanel:Remove()
		gui.EnableScreenClicker( false )
		self.InventoryPanel = nil
		self.MaterialPanel = nil
	end	
	
	wOS:BuildMaterialPanel()
	
	self.InventoryInfoPanel = vgui.Create( "DPanel" )
	self.InventoryInfoPanel:SetSize( mw*0.5, mh*0.15 )
	self.InventoryInfoPanel:SetPos( w, h )
	self.InventoryInfoPanel.DataItem = false
	self.InventoryInfoPanel.Paint = function( pan, ww, hh )	
		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 255 ) )
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( 0, 0, ww, hh )
		if self.InventoryInfoPanel.DataItem then
			draw.SimpleText( pan.DataItem.Name, "wOS.TitleFont", ww*0.04, hh*0.25, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			draw.SimpleText( pan.DataItem.Description, "wOS.DescriptionFont", ww*0.04, hh*0.62, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			if pan.DataItem.Amount and pan.DataItem.Amount > 1 then
				draw.SimpleText( "x" .. pan.DataItem.Amount, "wOS.TitleFont", ww*0.96, hh*0.5, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
			end
		end
	end
	
	self.InventoryInfoPanel.Think = function( pan )
		pan:SetPos( gui.MouseX() + 15, gui.MouseY() + 15 )
		if not self.InventoryPanel then
			pan:Remove()
		end
	end
	
	self.InventoryInfoPanel:SetVisible( false )
	
	local button1 = vgui.Create( "DButton", self.InventoryPanel )
	button1:SetSize( sw, sh*0.1 )
	button1:SetPos( 0, sh*0.9 )
	button1:SetText( "" )
	button1.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			draw.SimpleText( "Powered by wiltOS Technologies", "wOS.TitleFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
		else
			draw.SimpleText( "Powered by wiltOS Technologies", "wOS.TitleFont", ww/2, hh/2, Color( 75, 75, 75, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
	end
	button1.DoClick = function()
		gui.OpenURL( "www.wiltostech.com" )
	end	
	
	local button_left = vgui.Create( "DImageButton", self.InventoryPanel )
	button_left:SetSize( sw*0.15, sh*0.1 )
	button_left:SetPos( sw*0.15, sh*0.785 )
	button_left:SetImage( "wos/crafting/gui/left.png" )
	button_left.DoClick = function( pan )
		if page <= 1 then return end
		surface.PlaySound( "buttons/lightswitch2.wav" )
		page = math.max( page - 1, 1 )
		wOS:BuildItemsOnPage()
	end
	
	local button_right = vgui.Create( "DImageButton", self.InventoryPanel )
	button_right:SetSize( sw*0.15, sh*0.1 )
	button_right:SetPos( sw*0.7, sh*0.785 )
	button_right:SetImage( "wos/crafting/gui/right.png" )
	button_right.DoClick = function( pan )
		if page >= maxpages then return end
		surface.PlaySound( "buttons/lightswitch2.wav" )
		page = math.min( page + 1, maxpages )
		wOS:BuildItemsOnPage()
	end
	
	wOS:BuildItemsOnPage()
end

function wOS:BuildMaterialPanel()
	self.MaterialPanel = vgui.Create( "DPanel" )
	self.MaterialPanel:SetSize( mw*0.33, mh )
	self.MaterialPanel:SetPos( ( w + mw )*0.5 + mw*0.005, ( h - mh )*0.5 )
	self.MaterialPanel.Paint = function( pan, ww, hh )
		if not vgui.CursorVisible() then gui.EnableScreenClicker( true ) end
		blurpanel( pan )
		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( 0, 0, ww, hh )
		surface.DrawLine( ww*0.25, hh*0.1, ww*0.75, hh*0.1 )
		draw.SimpleText( "Raw Materials", "wOS.TitleFont", ww/2, hh*0.05, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
	end
	
	local pw, ph = self.MaterialPanel:GetSize()
	local padx, pady = pw*0.04, ph*0.05
	
	local MaterialBox = vgui.Create( "DComboBox", self.MaterialPanel )
	MaterialBox:SetPos( padx, ph*0.15 )
	MaterialBox:SetSize( pw - 2*padx, ph*0.07 )
	MaterialBox:SetValue( "Select Raw Material" )
	for material, data in pairs( wOS.SortedItemList[ WOSTYPE.RAWMATERIAL ] ) do
		MaterialBox:AddChoice( material )
	end
	local infobox
	MaterialBox.OnSelect = function( panel, index, value )
		if infobox then infobox:Remove() end
		infobox = vgui.Create( "DPanel", self.MaterialPanel )
		infobox:SetSize( pw - 2*padx, ph*0.78 - 2*pady )
		infobox:SetPos( padx, ph*0.22 + pady )
		
		local ww, hh = infobox:GetSize()
		local posx, posy = infobox:GetPos()
		local possx, possy = wOS.MaterialPanel:GetPos()
		posx = possx + posx
		posy = possy + posy
		local data = wOS.ItemList[ value ]
		infobox.Paint = function( pan, ww, hh )
			draw.SimpleText( "Amount: " .. wOS.RawMaterials[ value ], "wOS.TitleFont", 0, hh*0.7, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
			draw.SimpleText( "Rarity: " .. ( 100 - data.Rarity ) .. "%", "wOS.TitleFont", 0, hh*0.8, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		end
		if data.Model then
			local base_slot = vgui.Create( "DPanel", infobox )
			base_slot:SetSize( ww*0.7, ww*0.7 )
			base_slot:SetPos( ww*0.15, 0 )
			base_slot:SetText( "" )
			base_slot.Paint = function( pan, ww, hh )
				surface.SetDrawColor( Color( 255, 255, 255, 25 ) )
				local SlotFrame = {
					{ x = 0, y = hh*0.1 },
					{ x = ww*0.1, y = 0 },
					{ x = ww, y = 0 },		
					{ x = ww, y = hh*0.9 },
					{ x = ww*0.9, y = hh },	
					{ x = 0, y = hh},						
				}
				draw.NoTexture()
				surface.DrawPoly( SlotFrame )
			end	
			local Iconent = ClientsideModel("borealis/barrel.mdl")
			Iconent:SetAngles(Angle(0,0,0))
			Iconent:SetPos(Vector(0,0,0))
			Iconent:Spawn()
			Iconent:Activate()	
			Iconent:SetModel( data.Model )
			local center = Iconent:OBBCenter()
			local dist = Iconent:BoundingRadius()*1.6			
			local modelpanel = vgui.Create( "DModelPanel", base_slot )
			modelpanel:SetSize( ww*0.7, ww*0.7 )		
			modelpanel:SetModel( data.Model )
			modelpanel:SetLookAt( center )
			modelpanel:SetCamPos( center + Vector( dist, dist, 0 ) )				
			Iconent:Remove()
		end
		
		local DropMat = vgui.Create( "DButton", infobox )
		DropMat:SetPos( ww*0.4 + 2*padx, hh*0.9 )
		DropMat:SetSize( ww*0.6 - 3*padx, hh*0.1 )
		DropMat:SetText( "" )
		DropMat.Paint = function( pan, ww, hh )
			draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 155, 255, 155 ) ) or Color( 155, 155, 155, 155 ) )
			draw.SimpleText( "DROP", "wOS.DescriptionFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		local DropMatEntry = vgui.Create( "DTextEntry", infobox )
		DropMatEntry:MakePopup()
		DropMatEntry:SetPos( posx + padx, posy + hh*0.9 )
		DropMatEntry:SetSize( ww*0.4, hh*0.1 )
		DropMatEntry:SetText( 0 )
		DropMatEntry:SetNumeric( true )
		DropMat.DoClick = function()
			net.Start( "wOS.Crafting.DropMaterial" )
				net.WriteString( data.Name )
				net.WriteInt( tonumber( DropMatEntry:GetValue() ), 32 )
			net.SendToServer()
		end
		
	end
	

end

function wOS:BuildItemsOnPage()
	
	local sw, sh = self.InventoryPanel:GetSize()
		
	if not IsValid( inventory_buttons ) then
		inventory_buttons = vgui.Create( "DPanel", self.InventoryPanel )
		inventory_buttons:SetPos( sw*0.05, sh*0.12 )
		inventory_buttons:SetSize( sw*0.9, sh*0.65 )
		inventory_buttons.Paint = function( pan, ww, hh )
		end
	else
		inventory_buttons:Clear()
	end
	
	local min = items_per_page*(page - 1 )
	local max = math.min( items_per_page*page, wOS.ALCS.Config.Crafting.MaxInventorySlots )
	local iw, ih = inventory_buttons:GetSize()	
	local padx, pady = iw*0.01, ih*0.05
	local bw, bh = ( iw*0.2 - padx ), ( ih*0.5 - 1.5*pady )	
	local offsetx = padx
	local offsety = pady
	local items_per_row = 5
	local rows = items_per_page/items_per_row
	local rmin = min + 1
	local rmax = min + items_per_row
	local function dragdropfunc( pan, panels, dropped, _, _ )
		if not dropped then return end
		local oldpanel = panels[1]
		local oldpanx, oldpany = oldpanel.PosX, oldpanel.PosY
		local newpanx, newpany = pan.PosX, pan.PosY
		local oldslot = pan.Slot
		local newslot = oldpanel.Slot
		local data = table.Copy( oldpanel.DataItem )
		wOS.SaberInventory[ oldslot ] = wOS.SaberInventory[ newslot ]
		wOS.SaberInventory[ newslot ] = { Name = "Empty", Amount = 0 }
		net.Start( "wOS.Crafting.ChangeSlot" )
			net.WriteInt( oldslot, 32 )
			net.WriteInt( newslot, 32 )
		net.SendToServer()
		
		pan:Remove()
		oldpanel:GetParent():Remove()
		
		local empty_slot = vgui.Create( "DPanel", inventory_buttons )
		empty_slot:SetSize( bw, bh )
		empty_slot:SetPos( oldpanx, oldpany )
		empty_slot.PosX = oldpanx
		empty_slot.PosY = oldpany
		empty_slot.Slot = newslot
		empty_slot.Paint = function( pan, ww, hh )
			surface.SetDrawColor( Color( 255, 255, 255, 5 ) )
			local SlotFrame = {
				{ x = 0, y = hh*0.1 },
				{ x = ww*0.1, y = 0 },
				{ x = ww, y = 0 },		
				{ x = ww, y = hh*0.9 },
				{ x = ww*0.9, y = hh },	
				{ x = 0, y = hh},						
			}
			draw.NoTexture()
			surface.DrawPoly( SlotFrame )
		end
		empty_slot:Receiver( "InventorySlot", dragdropfunc, {} )		
		
		local base_slot = vgui.Create( "DPanel", inventory_buttons )
		base_slot:SetSize( bw, bh )
		base_slot:SetPos( newpanx, newpany )
		base_slot:SetText( "" )
		base_slot.Paint = function( pan, ww, hh )
			surface.SetDrawColor( Color( 255, 255, 255, 25 ) )
			local SlotFrame = {
				{ x = 0, y = hh*0.1 },
				{ x = ww*0.1, y = 0 },
				{ x = ww, y = 0 },		
				{ x = ww, y = hh*0.9 },
				{ x = ww*0.9, y = hh },	
				{ x = 0, y = hh},						
			}
			draw.NoTexture()
			surface.DrawPoly( SlotFrame )
		end	
		
		if data.Model then
			local Iconent = ClientsideModel("borealis/barrel.mdl")
			Iconent:SetAngles(Angle(0,0,0))
			Iconent:SetPos(Vector(0,0,0))
			Iconent:Spawn()
			Iconent:Activate()	
			Iconent:SetModel( data.Model )
			local center = Iconent:OBBCenter()
			local dist = Iconent:BoundingRadius()*1.6			
			local modelpanel = vgui.Create( "DModelPanel", base_slot )
			modelpanel:SetSize( bw, bh )		
			modelpanel:SetModel( data.Model )
			modelpanel:SetLookAt( center )
			modelpanel:SetCamPos( center + Vector( dist, dist, 0 ) )				
			Iconent:Remove()
		end
		
		local full_slot = vgui.Create( "DButton", base_slot )
		full_slot:SetSize( bw, bh )
		full_slot.PosX = newpanx
		full_slot.PosY = newpany
		full_slot.DataItem = table.Copy( data )
		full_slot.Slot = oldslot
		full_slot:SetText( "" )
		full_slot.Paint = function( pan, ww, hh )
			surface.SetDrawColor( Color( 0, 0, 0, 255 ) )
			local SlotFrame = {
				{ x = 0, y = hh*0.1 },
				{ x = ww*0.1, y = 0 },
				{ x = ww, y = 0 },		
				{ x = ww, y = hh*0.9 },
				{ x = ww*0.9, y = hh },	
				{ x = 0, y = hh },
				{ x = 0, y = hh*0.1 },						
			}				
			for i=1, 6 do
				local startpos = SlotFrame[ i ]
				local endpos = SlotFrame[ i + 1 ]
				surface.DrawLine( startpos.x, startpos.y, endpos.x, endpos.y )
			end
		end	
		full_slot:Droppable( "InventorySlot" )	
	end
	
	for row = 1, rows do
		for slot = rmin, rmax do
			local data = self.SaberInventory[ slot ]
			local item = self.SaberInventory[ slot ]
			local amount = 1
			if istable( data ) then
				item = data.Name
				amount = data.Amount or amount
			end
			if item == "Empty" then
				local empty_slot = vgui.Create( "DPanel", inventory_buttons )
				empty_slot:SetSize( bw, bh )
				empty_slot:SetPos( offsetx, offsety )
				empty_slot.PosX = offsetx
				empty_slot.PosY = offsety
				empty_slot.Slot = slot
				empty_slot.Paint = function( pan, ww, hh )
					surface.SetDrawColor( Color( 255, 255, 255, 5 ) )
					local SlotFrame = {
						{ x = 0, y = hh*0.1 },
						{ x = ww*0.1, y = 0 },
						{ x = ww, y = 0 },		
						{ x = ww, y = hh*0.9 },
						{ x = ww*0.9, y = hh },	
						{ x = 0, y = hh},						
					}
					draw.NoTexture()
					surface.DrawPoly( SlotFrame )
				end
				empty_slot:Receiver( "InventorySlot", dragdropfunc, {} )
			else
				local itemdata = self.ItemList[ item ]
				if not itemdata then itemdata = { Name = "ERROR", Description = "THIS ITEM IS CORRUPTED", Model = "" } end
				
				local base_slot = vgui.Create( "DPanel", inventory_buttons )
				base_slot:SetSize( bw, bh )
				base_slot:SetPos( offsetx, offsety )
				base_slot:SetText( "" )
				base_slot.Paint = function( pan, ww, hh )
					surface.SetDrawColor( Color( 255, 255, 255, 25 ) )
					local SlotFrame = {
						{ x = 0, y = hh*0.1 },
						{ x = ww*0.1, y = 0 },
						{ x = ww, y = 0 },		
						{ x = ww, y = hh*0.9 },
						{ x = ww*0.9, y = hh },	
						{ x = 0, y = hh},						
					}
					draw.NoTexture()
					surface.DrawPoly( SlotFrame )
				end	
				
				if itemdata.Model then
					local Iconent = ClientsideModel("borealis/barrel.mdl")
					Iconent:SetAngles(Angle(0,0,0))
					Iconent:SetPos(Vector(0,0,0))
					Iconent:Spawn()
					Iconent:Activate()	
					Iconent:SetModel( itemdata.Model )
					local center = Iconent:OBBCenter()
					local dist = Iconent:BoundingRadius()*1.6			
					local modelpanel = vgui.Create( "DModelPanel", base_slot )
					modelpanel:SetSize( bw, bh )		
					modelpanel:SetModel( itemdata.Model )
					modelpanel:SetLookAt( center )
					modelpanel:SetCamPos( center + Vector( dist, dist, 0 ) )				
					Iconent:Remove()
				end
				
				local full_slot = vgui.Create( "DButton", base_slot )
				full_slot:SetSize( bw, bh )
				full_slot.PosX = offsetx
				full_slot.PosY = offsety
				full_slot.DataItem = itemdata
				full_slot.Slot = slot
				full_slot:SetText( "" )
				full_slot.Paint = function( pan, ww, hh )
					surface.SetDrawColor( Color( 0, 0, 0, 255 ) )
					local SlotFrame = {
						{ x = 0, y = hh*0.1 },
						{ x = ww*0.1, y = 0 },
						{ x = ww, y = 0 },
						{ x = ww, y = hh*0.9 },
						{ x = ww*0.9, y = hh },
						{ x = 0, y = hh },
						{ x = 0, y = hh*0.1 },				
					}
					for i=1, 6 do
						local startpos = SlotFrame[ i ]
						local endpos = SlotFrame[ i + 1 ]
						surface.DrawLine( startpos.x, startpos.y, endpos.x, endpos.y )
					end
					if amount > 1 then
						draw.SimpleText( "x" .. amount, "wOS.TitleFont", ww*0.98, hh*0.02, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP )
					end
				end
				full_slot.DoClick = function( pan )
					if pan.ItemIconOptions then pan.ItemIconOptions:Remove() pan.ItemIconOptions = nil end
					pan.ItemIconOptions = DermaMenu( base_slot )
					pan.ItemIconOptions:SetPos( gui.MouseX(), gui.MouseY() )
					pan.ItemIconOptions.Think = function( self )
						if not pan then self:Remove() end
					end
					pan.ItemIconOptions:AddOption( "Drop", function( self ) 
						net.Start( "wOS.Crafting.DropItem" )
							net.WriteInt( slot, 32 )
						net.SendToServer()
						self:Remove()
					end )				
				end
				full_slot:Droppable( "InventorySlot" )
			end
			offsetx = offsetx + bw + padx
		end
		rmin = rmin + items_per_row
		rmax = rmax + items_per_row
		offsetx = padx
		offsety = offsety + bh + pady
	end
end
--addons/wos-grandmaster-einf/lua/wos/advswl/dueling/loader/cl_loader.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Dueling = wOS.ALCS.Dueling or {}

local dir = "wos/advswl/dueling"

include( dir .. "/core/cl_core.lua" )
include( dir .. "/core/cl_player_funcs.lua" )
include( dir .. "/core/cl_net.lua" )

include( dir .. "/core/cl_menu_library.lua" )

include( dir .. "/artsys/cl_net.lua" )

--addons/wos-grandmaster-einf/lua/wos/advswl/dueling/core/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Dueling = wOS.ALCS.Dueling or {}

local w,h = ScrW(), ScrH()
local Tex_white = surface.GetTextureID( "vgui/white" )

surface.CreateFont( "wOS.MegaDuelFont", { font = "Roboto Cn", size = h*(48/1200), weight = 1000, antialias = true } )
surface.CreateFont( "wOS.MainDuelFont", { font = "Roboto Cn", size = h*(32/1200), weight = 1000, antialias = true } )
surface.CreateFont( "wOS.MinorDuelFont", { font = "Roboto Cn", size = h*(24/1200), weight = 1000, antialias = true } )
surface.CreateFont( "wOS.InfoDuelFont", { font = "Roboto Cn", size = h*(18/1200), weight = 1000, antialias = true } )

surface.CreateFont( "wOS.3D2D.MainDuel", { font = "Roboto Cn", size = 100, weight = 1000, antialias = true } )
surface.CreateFont( "wOS.3D2D.MinorDuel", { font = "Roboto Cn", size = 80, weight = 800, antialias = true } )
surface.CreateFont( "wOS.3D2D.InfoDuel", { font = "Roboto Cn", size = 60, weight = 500, antialias = true } )

local BGColor = Color( 35, 36, 38, 255 )
local BarColor = Color( 44, 45, 49, 255 )
local ButtonColor = Color( 44, 186, 105, 235 )

local mw, mh = w*0.15, h*0.4

local bw, bh = mw, mh*0.1
local butw, buth = bw*0.4, bh*0.80
local mat_orb = Material("sprites/rollermine_shock")

function wOS.ALCS.Dueling:OpenDuelingMenu() 

	if wOS.ALCS.Dueling.StationMenu then
		wOS.ALCS.Dueling.StationMenu:Remove()
		wOS.ALCS.Dueling.StationMenu = nil
	end
	
	gui.EnableScreenClicker( true )
	self.StationMenu = vgui.Create( "DPanel" )
	self.StationMenu:SetSize( w*0.33, h*0.5 )
	self.StationMenu:SetPos( w*0.5 - w*0.33/2, h*0.25 )

	local fw, fh = self.StationMenu:GetSize()
	
	local mw, mh = fw*0.9, fh*0.8
	
	local formlist = vgui.Create("DScrollPanel", self.StationMenu )
	formlist:SetPos( fw*0.05, fh*0.1 )
	formlist:SetSize( mw, mh )
	formlist.Paint = function( pan, ww, hh ) 
	end
	formlist.VBar.Paint = function() end
	formlist.VBar.btnUp.Paint = function() end
	formlist.VBar.btnDown.Paint = function() end
	formlist.VBar.btnGrip.Paint = function() end
	
	local offsety = 0
	local pady = mh*0.01
	
	local buttonc = vgui.Create( "DButton", self.StationMenu )
	buttonc:SetSize( fw*0.05, fw*0.05 )
	buttonc:SetPos( fw*0.94, fw*0.01 )
	buttonc:SetText( "" )
	buttonc.Paint = function( pan, ww, hh )
		surface.SetDrawColor( Color( 255, 0, 0, 255 ) )
		surface.DrawLine( 0, 0, ww, hh )
		surface.DrawLine( 0, hh, ww, 0 )
	end
	buttonc.DoClick = function()
		self.StationMenu:Remove()
		self.StationMenu = nil
		gui.EnableScreenClicker( false )
	end	
	
	local button1 = vgui.Create( "DButton", self.StationMenu )
	button1:SetSize( fw, fh*0.1 )
	button1:SetPos( 0, fh*0.9 )
	button1:SetText( "" )
	button1.Paint = function( pan, ww, hh )
		if pan:IsHovered() then
			draw.SimpleText( "Refresh Roster", "wOS.TitleFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
		else
			draw.SimpleText( "Refresh Roster", "wOS.TitleFont", ww/2, hh/2, Color( 75, 75, 75, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
	end
	button1.DoClick = function()
		 wOS.ALCS.Dueling:OpenDuelingMenu()
	end	
	
	local roster = {}
	if not wOS.ALCS.Config.Dueling.StationDistance then
		roster = player.GetAll()
	else
		local maxdist = wOS.ALCS.Config.Dueling.StationDistance^2
		for _, ply in ipairs( player.GetAll() ) do
			if not IsValid( ply ) then continue end
			if !ply:Alive() then continue end
			if ply == LocalPlayer() then continue end
			if ply:GetPos():DistToSqr( LocalPlayer():GetPos() ) > maxdist then continue end
			table.insert( roster, ply )
		end
	end

	for _, ply in ipairs( roster ) do
		if ply == LocalPlayer() then continue end
		local button = vgui.Create( "DButton", formlist )
		button:SetSize( mw, mh*0.1 )
		button:SetPos( 0, offsety )
		button:SetText( "" )
		button.Data = data
		button.User = ply
		button.Paint = function( pan, ww, hh )
			draw.RoundedBox( 0, 0, 0, ww, hh, Color( 175, 175, 175, 255 ) )
			draw.SimpleText( button.User:GetName(), "wOS.TitleFont", hh, hh*0.5, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )			
		end
		button.DoClick = function( pan )
			net.Start( "properties" )
				net.WriteString( "challenge to duel" )
				net.WriteEntity( pan.User )
			net.SendToServer()
			buttonc:DoClick()
		end
		offsety = offsety + mh*0.1 + pady
	end

	self.StationMenu.Paint = function( pan, ww, hh )
		if not vgui.CursorVisible() then gui.EnableScreenClicker( true ) end
		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )
		draw.SimpleText( "Duel Station Roster", "wOS.TitleFont", ww/2, hh*0.05, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
		if #roster < 1 then
			draw.SimpleText( "NO DUELISTS IN YOUR AREA", "wOS.TitleFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
		end
	end 
	

end

function wOS.ALCS.Dueling:OpenConfigurationMenu()

	local wep = LocalPlayer():GetActiveWeapon()
	if not IsValid( wep ) then return end
	if wep:GetClass() != "wos_alcs_duelplacer" then return end
	if self.ConfigPanel then return end
	
	local ent = wep:GetSelected()
	if not IsValid( ent ) then return end
	
	gui.EnableScreenClicker( true )
	self.ConfigPanel = vgui.Create( "DFrame" )
	self.ConfigPanel:SetSize( 400, 200)
	self.ConfigPanel:SetTitle( "Duel Dome Config" )
	self.ConfigPanel.Title = ent:GetTitle()
	self.ConfigPanel.Radius = ent:GetRadius()
	self.ConfigPanel:Center()
	local posx, posy = ScrW()*0.2*0.05, ScrH()*0.2*0.13

	local TextEntry = vgui.Create( "DTextEntry", self.ConfigPanel )
	TextEntry:SetPos( 100, 50 )
	TextEntry:SetSize( 200, 50 )
	TextEntry:SetText( self.ConfigPanel.Title )
	TextEntry.OnEnter = function( pan )
		self.ConfigPanel.Title = pan:GetValue()
	end
	
	local TextEntry2 = vgui.Create( "DTextEntry", self.ConfigPanel )
	TextEntry2:SetPos( 100, 125 )
	TextEntry2:SetSize( 200, 50 )
	TextEntry2:SetText( self.ConfigPanel.Radius )
	TextEntry2.OnEnter = function( pan )
	end
	TextEntry2:SetNumeric( true )
	
	self.ConfigPanel.OnClose = function( pan )
		if IsValid( ent ) then
			net.Start( "wOS.ALCS.Dueling.ChangeDome" )
				net.WriteString( TextEntry:GetValue() )
				net.WriteFloat( tonumber( TextEntry2:GetValue() ) )
			net.SendToServer()
			gui.EnableScreenClicker( false )
		end
		self.ConfigPanel:Remove()
		self.ConfigPanel = nil
	end
	
	self.ConfigPanel:MakePopup()

end

function wOS.ALCS.Dueling:CreateChallengeMenu( data )

	if self.MainFrame then
		self.MainFrame:Remove()
		self.MainFrame = nil
		gui.EnableScreenClicker( false )
		return
	end
	
	if not data then return end
	
	local arenas = ents.FindByClass( "wos_duel_dome" )
	local page = 1
	
	local settings = {}
	
	settings.CreditWager = 0
	settings.FightingSpirit = false
	settings.BladesOnly = false
	settings.SpecificWeapon = ""
	settings.TimeLimit = 120
	
	self.MainFrame = vgui.Create( "DPanel" )
	self.MainFrame:SetSize( w, h )
	self.MainFrame.Think = function( pan )
		gui.EnableScreenClicker( true )
	end
	self.MainFrame.Item = wOS.ALCS.Dueling.Spirits[ data.DuelSpirit ] or wOS.ALCS.Dueling.Spirits[ "Spirit of the Duelist" ]
	
	local viewport = vgui.Create( "DPanel", self.MainFrame )
	viewport:SetSize( w*0.4, h*0.3 )
	viewport:SetPos( w*0.05, h*0.6 )
	viewport.Dome = arenas[1]
	viewport.Paint = function( pan, ww, hh )
	
		local x, y = pan:GetPos()
		local ent = pan.Dome
		if not IsValid( ent ) then return end
		local rx, ry = math.sin( CurTime()%360*0.5 ), math.cos( CurTime()%360*0.5 )
		local radius = ent:GetRadius()
		local pos = ent:GetPos()
		local origin = pos - Vector( radius*rx, radius*ry, 0 ) + ent:GetUp()*radius*0.4
		render.RenderView({
			origin = origin,
			angles = ( pos - origin ):Angle(),
			x = x, y = y,
			w = ww, h = hh
		})	
		
		if pan.Dome:GetStarted() then
			draw.RoundedBox( 0, 0, 0, ww, hh, Color( 0, 0, 0, 200 ) )
			draw.SimpleText( "UNAVAILABLE", "wOS.MainDuelFont", ww/2, hh/2, Color( 255, 0, 0 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( 0, 0, ww, hh )
		
	end
	
	local posx, posy = viewport:GetPos()
	local sw, sh = viewport:GetSize()
	
	local button_left = vgui.Create( "DImageButton", self.MainFrame )
	button_left:SetSize( sw*0.1, sh*0.1 )
	button_left:SetPos( posx, posy + sh/2 - sh*0.05 )
	button_left:SetImage( "wos/crafting/gui/left.png" )
	button_left.DoClick = function( pan )
		if page <= 1 then return end
		surface.PlaySound( "buttons/lightswitch2.wav" )
		page = math.max( page - 1, 1 )
		if not arenas[page] then return end
		viewport.Dome = arenas[page]
	end
	
	local button_right = vgui.Create( "DImageButton", self.MainFrame )
	button_right:SetSize( sw*0.1, sh*0.1 )
	button_right:SetPos( posx + sw - sw*0.1, posy + sh/2 - sh*0.05 )
	button_right:SetImage( "wos/crafting/gui/right.png" )
	button_right.DoClick = function( pan )
		if page >= #arenas then return end
		surface.PlaySound( "buttons/lightswitch2.wav" )
		page = math.min( page + 1, #arenas )
		if not arenas[page] then return end
		viewport.Dome = arenas[page]
	end
	
	local challengebutt = vgui.Create( "DButton", self.MainFrame )
	challengebutt:SetSize( sw*0.25, sh*0.1 )
	challengebutt:SetPos( w*0.75 - sw*0.125, posy + sh - sh*0.18 )
	challengebutt:SetText( "" )
	challengebutt.DoClick = function( pan )
		settings.Dome = viewport.Dome
		net.Start( "wOS.ALCS.Dueling.DuelRequest" )
			net.WriteEntity( data.Defender )
			net.WriteTable( settings )
		net.SendToServer()
		wOS.ALCS.Dueling:CreateChallengeMenu()
	end
	challengebutt.Paint = function( pan, ww, hh )
		local col = color_white
		if pan:IsHovered() then
			col = Color( 0, 125, 175 )
		end
		draw.SimpleText( "CHALLENGE", "wOS.MegaDuelFont", ww/2, hh/2, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	
	local cancelbutt = vgui.Create( "DButton", self.MainFrame )
	cancelbutt:SetSize( sw*0.15, sh*0.1 )
	cancelbutt:SetPos( w*0.75 - sw*0.075, posy + sh - sh*0.05 )
	cancelbutt:SetText( "" )
	cancelbutt.DoClick = function( pan )
		wOS.ALCS.Dueling:CreateChallengeMenu()
	end
	cancelbutt.Paint = function( pan, ww, hh )
		local col = color_white
		if pan:IsHovered() then
			col = Color( 175, 0, 0 )
		end
		draw.SimpleText( "CANCEL", "wOS.MainDuelFont", ww/2, hh/2, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	
	local modelpanel = vgui.Create( "DModelPanel", self.MainFrame )
	modelpanel:SetPos( w*0.55, posy + sh - sh*0.25 - w*0.4 )
	modelpanel:SetSize( w*0.4, w*0.4 )
	modelpanel:SetModel( data.Defender:GetModel() )
	if self.MainFrame.Item then
		modelpanel.Entity:SetSequence( self.MainFrame.Item.Sequence )
	end
	modelpanel.LayoutEntity = function( pan, Entity )
		pan:RunAnimation()
		if Entity:GetCycle() >= 0.99 then
			Entity:SetCycle( 0 )
		end
		Entity:SetAngles( Angle( 0, 90, 0 ) )
	end
	
	local mposx, mposy = modelpanel:GetPos()
	local mw, mh = modelpanel:GetSize()
	
	local fsbutt = vgui.Create( "DButton", self.MainFrame )
	fsbutt:SetSize( sw*0.1, sh*0.1 )
	fsbutt:SetPos( w*0.5 - sw*0.15, h*0.1 - sh*0.05 )
	fsbutt:SetText( "" )
	fsbutt.DoClick = function( pan )
		settings.FightingSpirit = !settings.FightingSpirit
	end
	fsbutt.Paint = function( pan, ww, hh )
		local col = color_white
		if pan:IsHovered() then
			col = Color( 0, 125, 175 )
		end
		draw.SimpleText( "[    ]", "wOS.MegaDuelFont", ww/2, hh/2, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		if settings.FightingSpirit then
			draw.SimpleText( "X", "wOS.MegaDuelFont", ww/2, hh/2, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
		end
	end
	
	local hsbutt = vgui.Create( "DButton", self.MainFrame )
	hsbutt:SetSize( sw*0.1, sh*0.1 )
	hsbutt:SetPos( w*0.5 - sw*0.15, h*0.175 - sh*0.05 )
	hsbutt:SetText( "" )
	hsbutt.DoClick = function( pan )
		settings.BladesOnly = !settings.BladesOnly 
	end
	hsbutt.Paint = function( pan, ww, hh )
		local col = color_white
		if pan:IsHovered() then
			col = Color( 0, 125, 175 )
		end
		draw.SimpleText( "[    ]", "wOS.MegaDuelFont", ww/2, hh/2, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		if settings.BladesOnly then
			draw.SimpleText( "X", "wOS.MegaDuelFont", ww/2, hh/2, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
		end
	end
	
	local inputBox = vgui.Create("DTextEntry", self.MainFrame )
	inputBox:SetSize( sw*0.25, sh*0.1 )
	inputBox:SetPos( w*0.5 - sw*0.3, h*0.25 - sh*0.05 )
	inputBox:SetText( settings.CreditWager )
	inputBox:SetFont( "wOS.MegaDuelFont" )
	inputBox:SetUpdateOnType( true )
	inputBox:SetNumeric( true )
	inputBox.Flash = 0
	inputBox.Colors = {
		Background = Color(65, 64, 69),
		Highlight = Color(58, 99, 144),
		Text = color_white
	}
	inputBox.Colors.Focus = {
		Outline = Color( 0, 125, 175, 255 )
	}
	inputBox.Paint = function( self, ww, hh )
		if inputBox.Flash < CurTime() then
			surface.SetDrawColor( color_white )
		else
			surface.SetDrawColor( Color( 255, 255*math.cos( CurTime()*20 ), 255*math.cos( CurTime()*20 ), 255 ) )
		end
		surface.DrawLine( 0, hh*0.98, ww, hh*0.98 )
		self:DrawTextEntryText(self.Colors.Text, self.Colors.Highlight, self.Colors.Text)
		if (self:HasFocus()) then
			surface.SetDrawColor(self.Colors.Focus.Outline)
			surface.DrawLine( 0, hh*0.98, ww, hh*0.98 )
		end
	end
	inputBox.OnValueChange = function( pan, val )
		local num = tonumber( val )
		if not num then return end
		if num < 0 then return end
		settings.CreditWager = num
	end
	inputBox:MakePopup()
	
	local inputBox2 = vgui.Create("DTextEntry", self.MainFrame )
	inputBox2:SetSize( sw*0.25, sh*0.1 )
	inputBox2:SetPos( w*0.5 - sw*0.3, h*0.325 - sh*0.05 )
	inputBox2:SetText( settings.TimeLimit )
	inputBox2:SetFont( "wOS.MegaDuelFont" )
	inputBox2:SetUpdateOnType( true )
	inputBox2:SetNumeric( true )
	inputBox2.Flash = 0
	inputBox2.Colors = {
		Background = Color(65, 64, 69),
		Highlight = Color(58, 99, 144),
		Text = color_white
	}
	inputBox2.Colors.Focus = {
		Outline = Color( 0, 125, 175, 255 )
	}
	inputBox2.Paint = function( self, ww, hh )
		if inputBox2.Flash < CurTime() then
			surface.SetDrawColor( color_white )
		else
			surface.SetDrawColor( Color( 255, 255*math.cos( CurTime()*20 ), 255*math.cos( CurTime()*20 ), 255 ) )
		end
		surface.DrawLine( 0, hh*0.98, ww, hh*0.98 )
		self:DrawTextEntryText(self.Colors.Text, self.Colors.Highlight, self.Colors.Text)
		if (self:HasFocus()) then
			surface.SetDrawColor(self.Colors.Focus.Outline)
			surface.DrawLine( 0, hh*0.98, ww, hh*0.98 )
		end
	end
	inputBox2.OnValueChange = function( pan, val )
		local num = tonumber( val )
		if not num then return end
		if num < 0 then return end
		settings.TimeLimit = num
	end
	inputBox2:MakePopup()
	
	self.MainFrame.Paint = function( pan, ww, hh )
		draw.RoundedBox( 0, 0, 0, ww, hh, color_black )
		
		local padx = ww*0.03
		
		local tx, ty = draw.SimpleText( "FIGHTING SPIRIT", "wOS.MegaDuelFont", posx, hh*0.1, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )		
		local lasty = hh*0.1 + ty
		
		local ftext = "FIGHTING SPIRIT IS DISABLED! NO BONUSES OR ENERGY GAINED"
		if settings.FightingSpirit then
			ftext = "FIGHTING SPIRIT IS ENABLED! BONUS EXPERIENCE AND SPIRIT DRAIN WILL APPLY"
		end
		tx, ty = draw.SimpleText( ftext, "wOS.InfoDuelFont", posx, lasty, ( settings.FightingSpirit and Color( 255, 0, 0 ) ) or Color( 0, 255, 0 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		
		tx, ty = draw.SimpleText( "HONOR BOUND", "wOS.MegaDuelFont", posx, hh*0.175, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )		
		lasty = hh*0.175 + ty
		
		local ftext = "HONOR BOUND IS DISABLED! FORCE POWERS AND DEVESTATORS MAY BE USED"
		if settings.BladesOnly then
			ftext = "HONOR BOUND IS ENABLED! NOTHING MORE THAN YOUR WEAPON MAY BE USED"
		end
		tx, ty = draw.SimpleText( ftext, "wOS.InfoDuelFont", posx, lasty, ( settings.BladesOnly and Color( 255, 0, 0 ) ) or Color( 0, 255, 0 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

		tx, ty = draw.SimpleText( "CREDIT WAGER", "wOS.MegaDuelFont", posx, hh*0.25, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )		
		lasty = hh*0.25 + ty
		tx, ty = draw.SimpleText( "HOW MUCH CREDITS ARE YOU WILLING TO LOSE?", "wOS.InfoDuelFont", posx, lasty, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		
		tx, ty = draw.SimpleText( "DUEL TIME", "wOS.MegaDuelFont", posx, hh*0.325, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )		
		lasty = hh*0.325 + ty
		tx, ty = draw.SimpleText( "HOW LONG BEFORE THE DUEL ENDS IN STALEMATE? ( IN SECONDS )", "wOS.InfoDuelFont", posx, lasty, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

		
		lasty = lasty + ty			
		
		draw.SimpleText( "CHOOSE YOUR ARENA", "wOS.MainDuelFont", posx + sw/2, posy - hh*0.015, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		if viewport.Dome then
			draw.SimpleText( string.upper( viewport.Dome:GetTitle() ), "wOS.MainDuelFont", posx + sw/2, posy + sh + hh*0.015, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
			draw.SimpleText( "RADIUS: " .. viewport.Dome:GetRadius() .. " UNITS", "wOS.InfoDuelFont", posx + sw/2, posy + sh + hh*0.033, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		else
			draw.SimpleText( "NO ARENAS AVAILABLE", "wOS.MainDuelFont", posx + sw/2, posy + sh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
		end
		
		surface.SetDrawColor( color_white )
		surface.DrawLine( ww/2, h*0.08, ww/2, hh*0.92 )
		
		draw.SimpleText( "Combat Level: " .. data.CombatLevel, "wOS.MegaDuelFont", mposx, mposy + mh - mh*0.12, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )	
		draw.SimpleText( "Proficiency Level: " .. data.Proficiency, "wOS.MainDuelFont", mposx, mposy + mh - mh*0.07, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )	

		tx, ty = draw.SimpleText( data.Defender:Nick(), "wOS.MegaDuelFont", mposx + mw/2, hh*0.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		lasty = hh*0.1 + ty
		local item = pan.Item
		if not item then return end
		
		tx, ty = draw.SimpleText( item.DuelTitle, "wOS.MainDuelFont", mposx + mw/2, lasty, item.RarityColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		lasty = lasty + ty		
		tx, ty = draw.SimpleText( "[ " .. item.Name .. " ]", "wOS.MinorDuelFont", mposx + mw/2, lasty, item.RarityColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )	
		lasty = lasty + ty	
		tx, ty = draw.SimpleText( "WON: " .. data.DuelWins .. "      |      LOST: " .. data.DuelLosses, "wOS.MegaDuelFont", mposx + mw/2, lasty + mh*0.03, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		
	end
	
end

function wOS.ALCS.Dueling:CreateDefendMenu( data, settings )

	if self.DMainFrame then
		self.DMainFrame:Remove()
		self.DMainFrame = nil
		gui.EnableScreenClicker( false )
		return
	end
	
	if not data then return end
	
	self.DMainFrame = vgui.Create( "DPanel" )
	self.DMainFrame:SetSize( w, h )
	self.DMainFrame.Think = function( pan )
		gui.EnableScreenClicker( true )
	end
	self.DMainFrame.Item = wOS.ALCS.Dueling.Spirits[ data.DuelSpirit ] or wOS.ALCS.Dueling.Spirits[ "Spirit of the Duelist" ]
	
	local viewport = vgui.Create( "DPanel", self.DMainFrame )
	viewport:SetSize( w*0.4, h*0.3 )
	viewport:SetPos( w*0.05, h*0.6 )
	viewport.Dome = settings.Dome
	viewport.Paint = function( pan, ww, hh )
	
		local x, y = pan:GetPos()
		local ent = pan.Dome
		if not IsValid( ent ) then return end
		local rx, ry = math.sin( CurTime()%360*0.5 ), math.cos( CurTime()%360*0.5 )
		local radius = ent:GetRadius()
		local pos = ent:GetPos()
		local origin = pos - Vector( radius*rx, radius*ry, 0 ) + ent:GetUp()*radius*0.4
		render.RenderView({
			origin = origin,
			angles = ( pos - origin ):Angle(),
			x = x, y = y,
			w = ww, h = hh
		})	
		
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( 0, 0, ww, hh )
		
	end
	
	local posx, posy = viewport:GetPos()
	local sw, sh = viewport:GetSize()

	local challengebutt = vgui.Create( "DButton", self.DMainFrame )
	challengebutt:SetSize( sw*0.5, sh*0.1 )
	challengebutt:SetPos( w*0.75 - sw*0.25, posy + sh - sh*0.18 )
	challengebutt:SetText( "" )
	challengebutt.DoClick = function( pan )
		if not IsValid( self.ChallengeQueue ) then return end
		if not self.ChallengeQueue.List[1] then return end
		net.Start( "wOS.ALCS.Dueling.DuelAccept" )
			net.WriteEntity( data.Challenger )
			net.WriteTable( settings )
		net.SendToServer()
		wOS.ALCS.Dueling:CreateDefendMenu()
	end
	challengebutt.Paint = function( pan, ww, hh )
		local col = color_white
		if pan:IsHovered() then
			col = Color( 0, 125, 175 )
		end
		draw.SimpleText( "ACCEPT CHALLENGE", "wOS.MegaDuelFont", ww/2, hh/2, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	
	local cancelbutt = vgui.Create( "DButton", self.DMainFrame )
	cancelbutt:SetSize( sw*0.15, sh*0.1 )
	cancelbutt:SetPos( w*0.75 - sw*0.075, posy + sh - sh*0.05 )
	cancelbutt:SetText( "" )
	cancelbutt.DoClick = function( pan )
		wOS.ALCS.Dueling:CreateDefendMenu()
	end
	cancelbutt.Paint = function( pan, ww, hh )
		local col = color_white
		if pan:IsHovered() then
			col = Color( 175, 0, 0 )
		end
		draw.SimpleText( "REJECT", "wOS.MainDuelFont", ww/2, hh/2, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	
	local modelpanel = vgui.Create( "DModelPanel", self.DMainFrame )
	modelpanel:SetPos( w*0.55, posy + sh - sh*0.25 - w*0.4 )
	modelpanel:SetSize( w*0.4, w*0.4 )
	modelpanel:SetModel( data.Challenger:GetModel() )
	modelpanel.Entity:SetSequence( self.DMainFrame.Item.Sequence )
	modelpanel.LayoutEntity = function( pan, Entity )
		pan:RunAnimation()
		if Entity:GetCycle() >= 0.99 then
			Entity:SetCycle( 0 )
		end
		Entity:SetAngles( Angle( 0, 90, 0 ) )
	end
	
	local mposx, mposy = modelpanel:GetPos()
	local mw, mh = modelpanel:GetSize()
	
	local fsbutt = vgui.Create( "DLabel", self.DMainFrame )
	fsbutt:SetSize( sw*0.1, sh*0.1 )
	fsbutt:SetPos( w*0.5 - sw*0.15, h*0.1 - sh*0.05 )
	fsbutt:SetText( "" )
	fsbutt.Paint = function( pan, ww, hh )
		local col = color_white
		draw.SimpleText( "[    ]", "wOS.MegaDuelFont", ww/2, hh/2, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		if settings.FightingSpirit then
			draw.SimpleText( "X", "wOS.MegaDuelFont", ww/2, hh/2, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
		end
	end
	
	local hsbutt = vgui.Create( "DLabel", self.DMainFrame )
	hsbutt:SetSize( sw*0.1, sh*0.1 )
	hsbutt:SetPos( w*0.5 - sw*0.15, h*0.175 - sh*0.05 )
	hsbutt:SetText( "" )
	hsbutt.Paint = function( pan, ww, hh )
		local col = color_white
		draw.SimpleText( "[    ]", "wOS.MegaDuelFont", ww/2, hh/2, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		if settings.BladesOnly then
			draw.SimpleText( "X", "wOS.MegaDuelFont", ww/2, hh/2, col, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
		end
	end
	
	local hsbutt = vgui.Create( "DLabel", self.DMainFrame )
	hsbutt:SetSize( sw*0.4, sh*0.1 )
	hsbutt:SetPos( w*0.5 - sw*0.45, h*0.25 - sh*0.05 )
	hsbutt:SetText( "" )
	hsbutt.Paint = function( pan, ww, hh )
		draw.SimpleText( settings.CreditWager, "wOS.MegaDuelFont", ww, hh/2, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
	end
	
	local hsbutt = vgui.Create( "DLabel", self.DMainFrame )
	hsbutt:SetSize( sw*0.4, sh*0.1 )
	hsbutt:SetPos( w*0.5 - sw*0.45, h*0.325 - sh*0.05 )
	hsbutt:SetText( "" )
	hsbutt.Paint = function( pan, ww, hh )
		draw.SimpleText( settings.TimeLimit, "wOS.MegaDuelFont", ww, hh/2, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
	end
	
	self.DMainFrame.Paint = function( pan, ww, hh )
		draw.RoundedBox( 0, 0, 0, ww, hh, color_black )
		
		local padx = ww*0.03
		
		local tx, ty = draw.SimpleText( "FIGHTING SPIRIT", "wOS.MegaDuelFont", posx, hh*0.1, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )		
		local lasty = hh*0.1 + ty
		
		local ftext = "FIGHTING SPIRIT IS DISABLED! NO BONUSES OR ENERGY GAINED"
		if settings.FightingSpirit then
			ftext = "FIGHTING SPIRIT IS ENABLED! BONUS EXPERIENCE AND SPIRIT DRAIN WILL APPLY"
		end
		tx, ty = draw.SimpleText( ftext, "wOS.InfoDuelFont", posx, lasty, ( settings.FightingSpirit and Color( 255, 0, 0 ) ) or Color( 0, 255, 0 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		
		tx, ty = draw.SimpleText( "HONOR BOUND", "wOS.MegaDuelFont", posx, hh*0.175, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )		
		lasty = hh*0.175 + ty
		
		local ftext = "HONOR BOUND IS DISABLED! FORCE POWERS AND DEVESTATORS MAY BE USED"
		if settings.BladesOnly then
			ftext = "HONOR BOUND IS ENABLED! NOTHING MORE THAN YOUR WEAPON MAY BE USED"
		end
		tx, ty = draw.SimpleText( ftext, "wOS.InfoDuelFont", posx, lasty, ( settings.BladesOnly and Color( 255, 0, 0 ) ) or Color( 0, 255, 0 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

		tx, ty = draw.SimpleText( "CREDIT WAGER", "wOS.MegaDuelFont", posx, hh*0.25, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )		
		lasty = hh*0.25 + ty
		tx, ty = draw.SimpleText( "YOU WILL BE GAMBLING THIS MANY CREDITS", "wOS.InfoDuelFont", posx, lasty, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
		
		tx, ty = draw.SimpleText( "DUEL TIME", "wOS.MegaDuelFont", posx, hh*0.325, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )		
		lasty = hh*0.325 + ty
		tx, ty = draw.SimpleText( "THE DUEL WILL LAST THIS MANY SECONDS", "wOS.InfoDuelFont", posx, lasty, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

		
		lasty = lasty + ty			
		
		draw.SimpleText( "SELECTED ARENA", "wOS.MainDuelFont", posx + sw/2, posy - hh*0.015, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		if viewport.Dome then
			draw.SimpleText( string.upper( viewport.Dome:GetTitle() ), "wOS.MainDuelFont", posx + sw/2, posy + sh + hh*0.015, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
			draw.SimpleText( "RADIUS: " .. viewport.Dome:GetRadius() .. " UNITS", "wOS.InfoDuelFont", posx + sw/2, posy + sh + hh*0.033, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		else
			draw.SimpleText( "ARENA CAM UNAVAILABLE", "wOS.MainDuelFont", posx + sw/2, posy + sh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )		
		end
		
		surface.SetDrawColor( color_white )
		surface.DrawLine( ww/2, h*0.08, ww/2, hh*0.92 )
		
		draw.SimpleText( "Combat Level: " .. data.CombatLevel, "wOS.MegaDuelFont", mposx, mposy + mh - mh*0.12, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )	
		draw.SimpleText( "Proficiency Level: " .. data.Proficiency, "wOS.MainDuelFont", mposx, mposy + mh - mh*0.07, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP )	

		tx, ty = draw.SimpleText( data.Challenger:Nick(), "wOS.MegaDuelFont", mposx + mw/2, hh*0.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		lasty = hh*0.1 + ty
		local item = pan.Item
		if not item then return end
		
		tx, ty = draw.SimpleText( item.DuelTitle, "wOS.MainDuelFont", mposx + mw/2, lasty, item.RarityColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		lasty = lasty + ty		
		tx, ty = draw.SimpleText( "[ " .. item.Name .. " ]", "wOS.MinorDuelFont", mposx + mw/2, lasty, item.RarityColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )	
		lasty = lasty + ty	
		tx, ty = draw.SimpleText( "WON: " .. data.DuelWins .. "      |      LOST: " .. data.DuelLosses, "wOS.MegaDuelFont", mposx + mw/2, lasty + mh*0.03, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		
	end
	
end

function wOS.ALCS.Dueling:AddChallenge( data, settings )

	local item = wOS.ALCS.Dueling.Spirits[ data.DuelSpirit ] or wOS.ALCS.Dueling.Spirits[ "Spirit of the Duelist" ]

	if IsValid( self.ChallengeQueue ) then
		table.insert( self.ChallengeQueue.List, { data = data, settings = settings, time = CurTime() } )
		surface.PlaySound( item.ChallengeSound )	
		return
	end

	self.ChallengeQueue = vgui.Create( "DFrame" )

	self.ChallengeQueue:SetSize( w*0.23, h*0.18 )
	self.ChallengeQueue:SetTitle( "" )
	self.ChallengeQueue:ShowCloseButton( false )
	self.ChallengeQueue:SetDraggable( false )
	self.ChallengeQueue:SetPos( 0, h/2 - h*0.09 )
	function self.ChallengeQueue:NextChallenge()
		if not self.List[1] then return end
		for i=1, #self.List do
			self.List[i] = self.List[i+1]
		end
		if not self.List[1] then return end
		self.List[1].time = CurTime()
	end
	self.ChallengeQueue.List = {}
	table.insert( self.ChallengeQueue.List, { data = data, settings = settings, time = CurTime() } )
	
	self.ChallengeQueue.Think = function( pan )
		if self.DMainFrame then
			pan:MoveToBack()
			return
		elseif vgui.CursorVisible() or g_ContextMenu:IsVisible() then
			gui.EnableScreenClicker( true )
			pan:MoveToFront()
		end
		if not pan.List[1] or LocalPlayer():GetNWEntity( "wOS.DuelDome", NULL ):IsValid() then
			self.ChallengeQueue = nil
			pan:Remove()
			gui.EnableScreenClicker( false )
			return
		end
		if pan.List[1].time + wOS.ALCS.Config.Dueling.DuelExpirationTime <= CurTime() then
			pan:NextChallenge()
		end
	end

	local mw, mh = self.ChallengeQueue:GetSize()
	local bw, bh = mw, mh*0.2
	local butw, buth = bw*0.4, bh*0.80

	self.ChallengeQueue.Paint = function( pan, ww, hh )
		local challenge = pan.List[1]
		if not challenge then return end
		draw.RoundedBox( 0, 0, 0, ww, hh, Color( 0, 0, 0, 175 ) ) 
		draw.SimpleText( challenge.data.Challenger:Nick(), "wOS.MainDuelFont", ww/2, hh*0.3, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		draw.SimpleText( "CHALLENGES YOU", "wOS.MainDuelFont", ww/2, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		
		local rat = math.max( 0, ( challenge.time + wOS.ALCS.Config.Dueling.DuelExpirationTime - CurTime() ) )/wOS.ALCS.Config.Dueling.DuelExpirationTime
		draw.RoundedBox( 0, 0, 0, ww*rat, hh*0.1, Color( 255, 255, 255, 175 ) ) 
		
		if #pan.List > 1 then
			local lim = #pan.List - 1
			local ext = ( lim > 1 and "S" ) or ""
			draw.SimpleText( "[ " .. lim .. " OTHER CHALLENGE" .. ext .. " ]", "wOS.InfoDuelFont", ww/2, hh*0.7, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		
	end
	
	local lowerbar = vgui.Create( "DPanel", self.ChallengeQueue )
	lowerbar:SetSize( bw, bh )
	lowerbar:SetPos( 0, mh - bh )
	lowerbar.Paint = function( panel, ppw, pph )
	  draw.RoundedBox( 0, 0, 0, ppw, pph, Color( 0, 0, 0, 175 ) ) 	
	end
	
	local button = vgui.Create( "DButton", lowerbar )
	button:SetSize( butw, buth )
	button:SetPos( bw*0.05, bh*0.1 )	
	button:SetTextColor( color_white )
	button:SetFont( "wOS.MainDuelFont" )
	button:SetText( "DECLINE" )
	button.Paint = function( panel, pppw, ppph )
	  draw.RoundedBox( 0, 0, 0, pppw, ppph, Color( 175, 0, 0 ) ) 	
	end
	button.DoClick = function( pan )	
		self.ChallengeQueue:NextChallenge()
	end
	
	local button1 = vgui.Create( "DButton", lowerbar )
	button1:SetSize( butw, buth )
	button1:SetPos( bw*0.55, bh*0.1 )
	button1:SetTextColor( color_white )
	button1:SetFont( "wOS.MainDuelFont" )
	button1:SetText( "VIEW INFO" )
	button1.Paint = function( panel, pppw, ppph )
	  draw.RoundedBox( 0, 0, 0, pppw, ppph, Color( 0, 125, 175 ) ) 	
	end
	button1.DoClick = function( pan )
		if not self.ChallengeQueue.List[1] then return end
		wOS.ALCS.Dueling:CreateDefendMenu( self.ChallengeQueue.List[1].data, self.ChallengeQueue.List[1].settings )	
	end
	
	surface.PlaySound( item.ChallengeSound )
	
end

hook.Add( "PostDrawOpaqueRenderables", "wOS.ALCS.Dueling.DuelWireFrames", function()

	if not wOS.ALCS.Dueling.Opponent then return end
	if not wOS.ALCS.Dueling.Opponent.DuelData then return end
	if not wOS.ALCS.Dueling.FadeThrough then return end

	local self = LocalPlayer():GetNWEntity( "wOS.DuelDome", NULL )
	
	if self:IsValid() then
		render.SetColorMaterial( mat_orb )
		render.DrawSphere( self:GetPos(), -1*self:GetRadius(), 75, 75, Color( 0, 125, 175, 175 ) )
		render.DrawSphere( self:GetPos(), self:GetRadius(), 75, 75, Color( 0, 125, 175, 175 ) )
	end
	
end )

hook.Add( "HUDPaint", "wOS.DuelHUD", function()

	if not wOS.ALCS.Dueling.Opponent then return end
	if not wOS.ALCS.Dueling.Opponent.DuelData then return end
	if not wOS.ALCS.Dueling.FadeThrough then return end

	local self = LocalPlayer():GetNWEntity( "wOS.DuelDome", NULL )
	
	if self:IsValid() then
		if not self:GetHasStarted() then return end
		local time = self:GetTimeLimit() - CurTime()
		if not time then return end
		draw.SimpleText( "TIME LEFT: " .. string.FormattedTime( time, "%02i:%02i:%02i" ) , "wOS.MegaDuelFont", w/2, h*0.03, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	
end )

local pi = math.pi
hook.Add( "HUDPaint", "wOS.ALCS.Dueling.FadeThrough", function()

	if not wOS.ALCS.Dueling.FadeThrough then return end
	if wOS.ALCS.Dueling.FadeThrough < CurTime() then return end
	
	local tim = math.Clamp( wOS.ALCS.Dueling.FadeThrough - CurTime(), 0, 2 )
	local rat = math.sin( pi*tim*0.5 )
	
	draw.RoundedBox( 0, 0, 0, w, h, Color( 0, 0, 0, 255*rat ) )
	
end )

hook.Add( "PostDrawOpaqueRenderables", "wOS.ALCS.Dueling.TitleCards", function()
	if not wOS.ALCS.Dueling.FadeThrough then return end
	if not wOS.ALCS.Dueling.Opponent then return end
	if not wOS.ALCS.Dueling.Opponent.DuelData then return end
	if not wOS.ALCS.Dueling.IntroSlot then return end
	if not wOS.ALCS.Dueling.IntroTime then return end
	local dome = LocalPlayer():GetNWEntity( "wOS.DuelDome", NULL )
	if !dome:IsValid() then return end
	if wOS.ALCS.Dueling.IntroSlot > 2 then return end
	
	local target = LocalPlayer()
	local data = wOS.ALCS.Dueling.DuelData
	local dat = 1
	if wOS.ALCS.Dueling.IntroSlot > 1 then
		target = wOS.ALCS.Dueling.Opponent
		data = wOS.ALCS.Dueling.Opponent.DuelData
		dat = -1
	end
	 
	local diff = ( dome:GetPos() - target:GetPos() )
	local dir = diff:GetNormalized()
	local dang = diff:Angle()
	
	local scale = 0.1
	local item = wOS.ALCS.Dueling.Spirits[ data.DuelSpirit ] or wOS.ALCS.Dueling.Spirits[ "Spirit of the Duelist" ]
	if not item then return end
	
     cam.Start3D2D(target:GetPos() + Vector( 0, 0, 60 ) + dang:Right()*50*dat, dang + Angle( 0, 90, 80 ), scale )
          draw.DrawText( target:Nick(), "wOS.3D2D.MainDuel", 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		  draw.DrawText( item.DuelTitle, "wOS.3D2D.MinorDuel", 0, 900*scale, item.RarityColor or color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		  draw.DrawText( item.TagLine, "wOS.3D2D.InfoDuel", 0, 1600*scale, item.RarityColor or color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
     cam.End3D2D()
	 
end )

local slot = 0
hook.Add( "CalcView", "wOS.ALCS.Dueling.IntroCam", function( ply, pos, ang )
	if ( !IsValid( ply ) or !ply:Alive() or ply:InVehicle() or ply:GetViewEntity() != ply ) then return end
	
	if not wOS.ALCS.Dueling.FadeThrough then return end
	if not wOS.ALCS.Dueling.Opponent then return end
	if not wOS.ALCS.Dueling.Opponent.DuelData then return end
	if not wOS.ALCS.Dueling.IntroSlot then return end
	if not wOS.ALCS.Dueling.IntroTime then return end
	local dome = LocalPlayer():GetNWEntity( "wOS.DuelDome", NULL )
	if !dome:IsValid() then return end
	if wOS.ALCS.Dueling.IntroSlot > 2 then return end
	
	if wOS.ALCS.Dueling.IntroTime <= CurTime() + 1 and slot != wOS.ALCS.Dueling.IntroSlot then
		wOS.ALCS.Dueling.FadeThrough = CurTime() + 2
		slot = wOS.ALCS.Dueling.IntroSlot
	end
	if wOS.ALCS.Dueling.IntroTime < CurTime() then
		wOS.ALCS.Dueling.IntroSlot = wOS.ALCS.Dueling.IntroSlot + 1
		wOS.ALCS.Dueling.IntroTime = CurTime() + 6
		return
	end
	
	local target = LocalPlayer()
	local data = wOS.ALCS.Dueling.DuelData
	if wOS.ALCS.Dueling.IntroSlot > 1 then
		target = wOS.ALCS.Dueling.Opponent
		data = wOS.ALCS.Dueling.Opponent.DuelData
	end
	
	local rat = math.max( wOS.ALCS.Dueling.IntroTime - CurTime(), 0 )
	local diff = ( dome:GetPos() - target:GetPos() )
	local dang = diff:Angle()
	local dir = diff:GetNormalized()
	local origin = target:GetPos() + Vector( 0, 0, 60 )
	local pos = origin + dir*40 + dang:Forward()*5 + dang:Forward()*rat*10
	local ang = origin - pos
	 
	return {
		origin = pos,
		angles = ang,
		drawviewer = true
	}

end )

hook.Add( "wOS.ALCS.ShouldDisableCam", "wOS.ALCS.Dueling.Prevent3rdPerson", function()

	if not wOS.ALCS.Dueling.FadeThrough then return end
	if not wOS.ALCS.Dueling.Opponent then return end
	if not wOS.ALCS.Dueling.Opponent.DuelData then return end
	if not wOS.ALCS.Dueling.IntroSlot then return end
	if not wOS.ALCS.Dueling.IntroTime then return end
	if wOS.ALCS.Dueling.IntroSlot > 2 then return end

	return true
	
end )	

--addons/wos-grandmaster-einf/lua/wos/advswl/execsys/core/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.ExecSys = wOS.ALCS.ExecSys or {}
wOS.ALCS.ExecSys.Executions = wOS.ALCS.ExecSys.Executions or {}

wOS.ALCS.ExecSys.SmallGibTable = {
"models/gibs/HGIBS_scapula.mdl",
"models/props_phx/misc/potato.mdl",
"models/gibs/antlion_gib_small_1.mdl",
"models/gibs/antlion_gib_small_2.mdl",
"models/gibs/shield_scanner_gib1.mdl",
"models/props_wasteland/prison_sinkchunk001h.mdl",
"models/props_wasteland/prison_toiletchunk01f.mdl",
"models/props_wasteland/prison_toiletchunk01i.mdl",
"models/props_wasteland/prison_toiletchunk01l.mdl",
"models/props_combine/breenbust_chunk02.mdl",
"models/props_combine/breenbust_chunk04.mdl",
"models/props_combine/breenbust_chunk05.mdl",
"models/props_combine/breenbust_chunk06.mdl",
"models/props_combine/breenbust_chunk07.mdl",
"models/props_junk/watermelon01_chunk02a.mdl",
"models/props_junk/watermelon01_chunk02b.mdl",
"models/props_junk/watermelon01_chunk02c.mdl",
}
wOS.ALCS.ExecSys.BigGibTable = {
"models/gibs/HGIBS.mdl",
"models/gibs/HGIBS_spine.mdl",
"models/weapons/w_bugbait.mdl",
"models/gibs/antlion_gib_medium_1.mdl",
"models/gibs/antlion_gib_medium_2.mdl",
"models/gibs/shield_scanner_gib5.mdl",
"models/gibs/shield_scanner_gib6.mdl",
"models/props_junk/shoe001a.mdl",
"models/props_junk/Rock001a.mdl",
"models/props_junk/garbage_bag001a.mdl",
"models/props_debris/concrete_spawnchunk001g.mdl",
"models/props_combine/breenbust_chunk03.mdl",
"models/props_wasteland/prison_sinkchunk001c.mdl",
"models/props_wasteland/prison_toiletchunk01j.mdl",
"models/props_wasteland/prison_toiletchunk01k.mdl",
"models/props_junk/watermelon01_chunk01b.mdl",
"models/props_junk/watermelon01_chunk01c.mdl", 
}

wOS.ALCS.ExecSys.SplatSounds = { 
"physics/flesh/flesh_squishy_impact_hard1.wav",
"physics/flesh/flesh_squishy_impact_hard2.wav",
"physics/flesh/flesh_squishy_impact_hard3.wav",
"physics/flesh/flesh_squishy_impact_hard4.wav",
"physics/flesh/flesh_bloody_impact_hard1.wav",
"physics/body/body_medium_break2.wav",
"physics/body/body_medium_break3.wav",
"physics/body/body_medium_break4.wav",
"ambient/levels/canals/toxic_slime_sizzle1.wav",
"ambient/levels/canals/toxic_slime_sizzle2.wav",
"ambient/levels/canals/toxic_slime_gurgle3.wav",
"ambient/levels/canals/toxic_slime_gurgle5.wav",
"ambient/levels/canals/toxic_slime_gurgle8.wav"
}

wOS.ALCS.ExecSys.LastPos = nil
wOS.ALCS.ExecSys.LastAng = nil

function wOS.ALCS.ExecSys:CanUseExecution( exec )
	if not exec then return false end
	if not wOS.ALCS.ExecSys.Executions[ exec ] then return false end
	if not wOS.ALCS.Dueling.DuelData then return false end
	local dat = wOS.ALCS.ExecSys.Executions[ exec ]
	if wOS.ALCS.ExecSys.Whitelists and wOS.ALCS.ExecSys.Whitelists[ exec ] then return true end
	if dat.Milestone then
		local wins = wOS.ALCS.Dueling.DuelData.Wins or 0
		local losses = wOS.ALCS.Dueling.DuelData.Losses or 0
		local total = wins + losses
		if dat.Milestone.Wins and dat.Milestone.Wins > wins then return false end
		if dat.Milestone.Losses and dat.Milestone.Losses > losses then return false end		
		if dat.Milestone.Total and dat.Milestone.Total > total then return false end		
	end
	
	return true
end

hook.Add( "wOS.ALCS.ShouldDisableCam", "wOS.ALCS.Executions.DisableCam", function()  

	if LocalPlayer():GetExecuted() then return true end

end )

hook.Add( "FinishMove", "wOS.ALCS.Executions.StopMove", function( ply, mv ) 
	if !ply:GetExecuted() then return end
	mv:SetForwardSpeed( 0.1 )
	mv:SetSideSpeed( 0.1 )
	mv:SetUpSpeed( 0.1 )
	return true
end )

hook.Add( "CalcView", "wOS.ALCS.Executions.FinishHim", function( ply, pos, ang )

	if !LocalPlayer():GetExecuted() then return end
	local dat = wOS.ALCS.ExecSys.ExecutionData
	if not dat then return end
	if dat.endtime < CurTime() then return end
	if dat.stagetime < CurTime() then
		if dat.camdata[ dat.stage + 1 ] then
			dat.stagetime = CurTime() + dat.camdata[ dat.stage + 1 ].time
			dat.stage = dat.stage + 1
			return
		end
	end
	
	if not wOS.ALCS.ExecSys.LastPos or not wOS.ALCS.ExecSys.LastAng then
		wOS.ALCS.ExecSys.LastPos = pos
		wOS.ALCS.ExecSys.LastAng = ang
	end

	local npos, nang = vector_origin, Angle( 0, 0, 0 )
	if dat.camdata.target != WOS_ALCS.EXECUTE.NO_TARGET then
		local target = ( dat.camdata.target == WOS_ALCS.EXECUTE.VICTIM and dat.victim ) or dat.attacker
		local angles = target:GetAngles()
		angles.p = 0
		angles.r = 0
		local offset = dat.camdata[ dat.stage ].OffsetPos
		npos = target:GetPos() + angles:Right()*offset.x + angles:Forward()*offset.y + angles:Up()*offset.z
		nang = angles + dat.camdata[ dat.stage ].OffsetAng
	else
		npos = dat.camdata[ dat.stage ].OffsetPos
		nang = dat.camdata[ dat.stage ].OffsetAng
		wOS.ALCS.ExecSys.LastPos = npos
		wOS.ALCS.ExecSys.LastAng = nang
	end
	
	
	wOS.ALCS.ExecSys.LastPos = ( wOS.ALCS.ExecSys.LastPos == npos and npos ) or Lerp( FrameTime()*3, wOS.ALCS.ExecSys.LastPos, npos )
	wOS.ALCS.ExecSys.LastAng = ( wOS.ALCS.ExecSys.LastAng == nang and nang ) or Lerp( FrameTime()*3, wOS.ALCS.ExecSys.LastAng, nang )	
	 
	return {
		origin = wOS.ALCS.ExecSys.LastPos,
		angles = wOS.ALCS.ExecSys.LastAng,
		drawviewer = true
	}
	
end )

hook.Add( "StartCommand", "wOS.ALCS.Executions.StopAll", function( ply, cmd )
	if !ply:GetExecuted() then return end

	cmd:ClearButtons()
	cmd:ClearMovement()
	
end )

hook.Add( "InputMouseApply", "wOS.ALCS.Executions.StopTurning", function( cmd )
	if !LocalPlayer():GetExecuted() then return end
	
	cmd:SetMouseX( 0 )
	cmd:SetMouseY( 0 )
	cmd:SetMouseWheel( 0 )

	return true
end )
--addons/wos-grandmaster-einf/lua/wos/advswl/execsys/core/cl_player_funcs.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

local meta = FindMetaTable( "Player" )

function meta:GetExecuted()
	return self:GetNW2Bool( "wOS.ALCS.ExecSys.Executed", false )
end


--addons/wos-grandmaster-einf/lua/wos/advswl/character/core/cl_net.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--








































































wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}

net.Receive( "wOS.ALCS.GetSaberPreferences", function( len )

	wOS.ALCS.LightsaberPreferences = net.ReadTable()
	
end )
--addons/wos-grandmaster-einf/lua/wos/advswl/prestige/core/sh_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2020
	
	Contact: www.wiltostech.com
		----------------------------------------]]--

wOS = wOS or {}
wOS.ALCS = wOS.ALCS or {}
wOS.ALCS.Prestige = wOS.ALCS.Prestige or {}

local meta = FindMetaTable( "Player" )

function meta:WOS_GetSkillPrestigeLevel()
	return self:GetNW2Int( "wOS.ALCS.Prestige.Level", 0 )
end

function meta:WOS_GetSkillPrestigeIcon()
	return self:GetNW2String( "wOS.ALCS.Prestige.Icon", "" )
end
--addons/wos-alcs-icefusepp/lua/wos/advswl/addon-loader/icefuse_loader.lua:

--Icefuse LODA

if SERVER then
	AddCSLuaFile( "wos/advswl/icefuse/wos_blink_extension.lua" )
	AddCSLuaFile( "wos/advswl/icefuse/cl_core.lua" )
	include( "wos/advswl/icefuse/sv_core.lua" )
else
	include( "wos/advswl/icefuse/cl_core.lua" )
	include( "wos/advswl/icefuse/wos_blink_extension.lua" )
end
--addons/wos-passiveevent/lua/autorun/client/wos_pes_loader.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

hook.Add("EGMRP.Loaded", "wOS.PES.Load", function()
	wOS = wOS or {}
	wOS.PES = wOS.PES or {}

	include("wos/pes/loader/loader.lua")
	include("wos/css/loader/loader.lua")
end)
--addons/bkeypads/lua/vgui/bkeypads_matrix.lua:
local MatrixChars = {"█","░","▓","▒","男","甸","甹","町","画","甼","甽","甾","甿","畀","畁","畂","畃","畄","畅","畆","畇","畈","畉","畊","畋","界","畍","畎","畏","畐","畑"}

local function bKeypads_Matrix_Instance_SetSize(self, w, h)
	local recompute = self.w ~= w or self.h ~= h
	self.w = w
	self.h = h
	if recompute then
		self:Recompute()
	end
end
local function bKeypads_Matrix_Instance_SetRainSize(self, CharSize)
	self.CharSize = CharSize
	self:Recompute()
end
local function bKeypads_Matrix_Instance_Recompute(self)
	self.ResolutionW = math.ceil(self.w / self.CharSize)
	self.ResolutionH = math.ceil(self.h / self.CharSize)

	self.ColumnHeights = {}
	self.Drops = {}
	self.RainStep = 0
	for i=1,self.ResolutionW do
		self.ColumnHeights[i] = math.random(0, self.ResolutionH * 2)
		self.Drops[i] = {}
		for j=1,math.min(self.ColumnHeights[i], self.ResolutionH) do
			self.Drops[i][j] = MatrixChars[math.random(1,#MatrixChars)]
		end
	end

	surface.CreateFont("bKeypadsMatrix_" .. self.CharSize, {
		size = self.CharSize,
		font = "Roboto",
		extended = true
	})
end
local function bKeypads_Matrix_Instance_SetRainColor(self, col)
	self.RainColor = col
end
local function bKeypads_Matrix_Instance_ContrastRainColor(self, col)
	local luminance = bKeypads:GetLuminance(col)
	if luminance > .35 then
		bKeypads_Matrix_Instance_SetRainColor(self, bKeypads.COLOR.BLACK)
	else
		self.ContrastRainWhite = self.ContrastRainWhite or Color(255,255,255)
		self.ContrastRainWhite.a = ((255 - 25) * luminance) + 25
		bKeypads_Matrix_Instance_SetRainColor(self, self.ContrastRainWhite)
	end
end
local function bKeypads_Matrix_Instance_SetBGColor(self, col)
	self.BGColor = col
end
local function bKeypads_Matrix_Instance_Draw(self, w, h)
	self:SetSize(w,h)

	if self.BGColor then
		surface.SetDrawColor(self.BGColor)
		surface.DrawRect(0,0,w,h)
	end

	if not bKeypads.Performance:Optimizing() then
		local step = SysTime() >= self.RainStep
		if step then self.RainStep = SysTime() + .033 end

		local alpha = surface.GetAlphaMultiplier()

		local font = "bKeypadsMatrix_" .. self.CharSize

		for i=1,self.ResolutionW do
			if step then
				self.ColumnHeights[i] = self.ColumnHeights[i] + 1
				if self.ColumnHeights[i] > self.ResolutionH * 2 then
					self.ColumnHeights[i] = math.random(-self.ResolutionH, 0)
				end
			end
			if self.ColumnHeights[i] > 0 then
				self.Drops[i][self.ColumnHeights[i]] = MatrixChars[math.random(1,#MatrixChars)]
				for j=1,math.min(self.ColumnHeights[i], self.ResolutionH) do
					surface.SetAlphaMultiplier(alpha * ((j / self.ColumnHeights[i]) * (1 - (math.max(0, self.ColumnHeights[i] - self.ResolutionH) / self.ResolutionH))))
					draw.SimpleText(self.Drops[i][j], font, (i - 1) * self.CharSize, (j - 1) * self.CharSize, self.RainColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
				end
			end
		end

		surface.SetAlphaMultiplier(alpha)
	end
end

local bKeypads_Matrix_Instance = {
	RainColor = Color(0,0,0),
	CharSize = 12,
	SetSize = bKeypads_Matrix_Instance_SetSize,
	SetRainSize = bKeypads_Matrix_Instance_SetRainSize,
	SetRainColor = bKeypads_Matrix_Instance_SetRainColor,
	SetBGColor = bKeypads_Matrix_Instance_SetBGColor,
	Recompute = bKeypads_Matrix_Instance_Recompute,
	Draw = bKeypads_Matrix_Instance_Draw,
	ContrastRainColor = bKeypads_Matrix_Instance_ContrastRainColor
}

local function bKeypads_Matrix__construct(self, id, w, h, RainColor)
	if not self.Instances[id] then
		self.Instances[id] = table.Copy(bKeypads_Matrix_Instance)
		self.Instances[id].ID = id
		self.Instances[id]:SetSize(w,h)
		self.Instances[id].RainColor = RainColor or self.Instances[id].RainColor
	end
	return self.Instances[id]
end

bKeypads_Matrix = {
	Instances = {},
	__construct = bKeypads_Matrix__construct
}

setmetatable(bKeypads_Matrix, {__call = bKeypads_Matrix.__construct})

--#########################################--

local PANEL = {}

function PANEL:SetMatrixID(id)
	if self.Instance == nil or self.Instance.ID ~= id then
		self.Instance = bKeypads_Matrix(id, self:GetWide(), self:GetTall())
	end
end

function PANEL:SetRainColor(col)
	self.Instance:SetRainColor(col)
end

function PANEL:SetRainSize(size)
	self.Instance:SetRainSize(size)
end

function PANEL:SetBGColor(col)
	self.Instance.BGColor = col
end

function PANEL:PerformLayout(w,h)
	self.Instance:SetSize(w,h)
end

local drawnMatrices, frame = 0
function PANEL:Paint(w,h)
	if not self.Instance then
		error("attempt to index field 'Instance' (a nil value)")
		self:Remove()
		return
	end
	if render.GetRenderTarget() ~= nil then return end
	if frame ~= FrameNumber() then
		drawnMatrices = 1
	else
		drawnMatrices = drawnMatrices + 1
	end
	if drawnMatrices >= 3 then return end
	self.Instance:Draw(w,h)
end

hook.Add("PostRender", "bKeypads.Matrix.Optimizations", function() drawnMatrices = 0 end)

derma.DefineControl("bKeypads.Matrix", nil, PANEL, "DPanel")
--addons/openpermissions/lua/vgui/openpermissions_checkbox.lua:
local PANEL = {}

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")
	self:SetSize(16,16)

	self.Crossable = false
	self.Checked = false
end

function PANEL:SetCrossable(crossable)
	self.Crossable = crossable == true
	if (crossable) then
		self.Checked = 0
	else
		self.Checked = false
	end
end
function PANEL:IsCrossable()
	return self.Crossable
end

function PANEL:DoClick()
	self:SetAmbigious(false)
	if (self.Crossable) then
		self.Checked = self.Checked + 1
		if (self.Checked == 3) then
			self.Checked = 0
		end
	else
		self.Checked = not self.Checked
	end
	if (self.OnChange) then
		self:OnChange()
	end
end
function PANEL:DoRightClick()
	if (self.Crossable) then
		self:SetAmbigious(false)
		self.Checked = self.Checked - 1
		if (self.Checked == -1) then
			self.Checked = 2
		end
		if (self.OnChange) then
			self:OnChange()
		end
	end
end

function PANEL:OnMousePressed(m)
	if (m == MOUSE_LEFT) then
		self.Debounce_LEFT = true
	elseif (m == MOUSE_RIGHT) then
		self.Debounce_RIGHT = true
	end
end
function PANEL:OnMouseReleased(m)
	if (m == MOUSE_LEFT) then
		if (self.Debounce_LEFT) then
			self:DoClick()
		end
		self.Debounce_LEFT = nil
	elseif (m == MOUSE_RIGHT) then
		if (self.Debounce_RIGHT) then
			self:DoRightClick()
		end
		self.Debounce_RIGHT = nil
	end
end

function PANEL:GetChecked()
	return self.Checked
end
function PANEL:SetChecked(checked)
	self:SetAmbigious(false)
	self.Checked = checked
end

function PANEL:SetAmbigious(ambigious)
	self.Ambigious = ambigious
end
function PANEL:IsAmbigious()
	return self.Ambigious
end

local mat_checked = Material("openpermissions/checked.vtf")
local mat_crossed = Material("openpermissions/crossed.vtf")
local darker_soft_green = Color(52,145,52)
function PANEL:Paint(w,h)
	surface.SetDrawColor(OpenPermissions.COLOR_WHITE)
	surface.DrawRect(0,0,w,h)

	if (self.Crossable and self.Ambigious) then
		surface.SetDrawColor(OpenPermissions.COLOR_BLACK)
	elseif (self.Checked == true or self.Checked == 1) then
		surface.SetDrawColor(darker_soft_green)
	elseif (self.Checked == 2) then
		surface.SetDrawColor(OpenPermissions.COLOR_SOFT_RED)
	else
		surface.SetDrawColor(OpenPermissions.COLOR_BLACK)
	end
	surface.DrawOutlinedRect(0,0,w,h)

	if (self.Crossable and self.Ambigious) then
		surface.SetDrawColor(OpenPermissions.COLOR_SOFT_GREEN)
		surface.DrawRect(3,3,w - 6, h - 6)
	elseif (self.Checked == true or self.Checked == 1) then
		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(mat_checked)
		surface.DrawTexturedRect(0,0,w,h)
	elseif (self.Checked == 2) then
		surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(mat_crossed)
		surface.DrawTexturedRect(0,0,w,h)
	end
end

derma.DefineControl("OpenPermissions.Checkbox", nil, PANEL, "DPanel")
--addons/openpermissions/lua/vgui/openpermissions_scrollpanel.lua:
local PANEL = {}

function PANEL:Init()
	self.CurrentOffset = 0
	self.TargetOffset = 0
	self.StartTime = 0
	self.EndTime = 0

	self.VBar:SetHideButtons(true)
	self.VBar:SetWide(5)
	self.VBar:DockMargin(3,3,3,3)

	function self.VBar:Paint() end
	function self.VBar.btnGrip:Paint(w,h)
		surface.SetDrawColor(0,0,0,150)
		surface.DrawRect(0,0,w,h)
	end

	self.VBar.CurrentY = 0
	self.VBar.TargetY = 0
	function self.VBar:PerformLayout()

		local Wide = self:GetWide()
		local BtnHeight = Wide
		if ( self:GetHideButtons() ) then BtnHeight = 0 end
		local Scroll = self:GetScroll() / self.CanvasSize
		local BarSize = math.max( self:BarScale() * ( self:GetTall() - ( BtnHeight * 2 ) ), 10 )
		local Track = self:GetTall() - ( BtnHeight * 2 ) - BarSize
		Track = Track + 1

		Scroll = Scroll * Track

		self.TargetY = BtnHeight + Scroll
		self.btnGrip:SetSize( Wide, BarSize )

		if ( BtnHeight > 0 ) then
			self.btnUp:SetPos( 0, 0, Wide, Wide )
			self.btnUp:SetSize( Wide, BtnHeight )

			self.btnDown:SetPos( 0, self:GetTall() - BtnHeight )
			self.btnDown:SetSize( Wide, BtnHeight )
			
			self.btnUp:SetVisible( true )
			self.btnDown:SetVisible( true )
		else
			self.btnUp:SetVisible( false )
			self.btnDown:SetVisible( false )
			self.btnDown:SetSize( Wide, BtnHeight )
			self.btnUp:SetSize( Wide, BtnHeight )
		end

	end

	function self.VBar:Think()
		self.CurrentY = Lerp(FrameTime() * 10, self.CurrentY, self.TargetY)
		self.btnGrip:SetPos(0, math.Round(self.CurrentY))
	end

	self.pnlCanvas.CurrentOffset = 0
	self.pnlCanvas.TargetOffset = 0
	function self.pnlCanvas:Think()
		self.CurrentOffset = Lerp(FrameTime() * 10, self.CurrentOffset, self.TargetOffset)
		self:SetPos(0, math.Round(self.CurrentOffset))
	end
end

function PANEL:OnVScroll(offset)
	self.pnlCanvas.TargetOffset = offset
end

function PANEL:PerformLayoutInternal()

	local Tall = self.pnlCanvas:GetTall()
	local Wide = self:GetWide()
	local YPos = 0

	self:Rebuild()

	self.VBar:SetUp( self:GetTall(), self.pnlCanvas:GetTall() )
	YPos = self.VBar:GetOffset()

	if ( self.VBar.Enabled ) then Wide = Wide - self.VBar:GetWide() end

	self.pnlCanvas:SetPos( 0, YPos )
	self.pnlCanvas:SetWide( Wide + self.VBar:GetWide() )

	self:Rebuild()

	if ( Tall != self.pnlCanvas:GetTall() ) then
		self.VBar:SetScroll( self.VBar:GetScroll() ) -- Make sure we are not too far down!
	end

end

derma.DefineControl("OpenPermissions.ScrollPanel", nil, PANEL, "DScrollPanel")
--addons/openpermissions/lua/vgui/openpermissions_tooltip.lua:
local bg_color = Color(43,48,58,255)

local PANEL = {}

function PANEL:Init()
	self:SetDrawOnTop(true)

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_CIRCULAR, "REGULAR", 14))
	self.Label:SetText("Tooltip")
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:SetContentAlignment(5)
	self.Label:SetWrap(true)

	self.Arrow = {
		{x = 0, y = 0},
		{x = 0, y = 0},
		{x = 0, y = 0}
	}
end

function PANEL:Paint(w,h)
	draw.RoundedBox(4, 0, 0, w, h, self.BackgroundColor or bg_color)
	surface.DisableClipping(true)

	surface.SetDrawColor(self.BackgroundColor or bg_color)
	draw.NoTexture()

	self.Arrow[1].x = w / 2 - 7
	self.Arrow[1].y = h

	self.Arrow[2].x = w / 2 + 7
	self.Arrow[2].y = h

	self.Arrow[3].x = w / 2
	self.Arrow[3].y = h + 7

	surface.DrawPoly(self.Arrow)

	surface.DisableClipping(false)
end

function PANEL:Think()
	local x,y = self.Label:GetSize()
	self:SetSize(x + 15, y + 7)
	self.Label:Center()
	local x,y = gui.MousePos()
	self:SetPos(x - self:GetWide() / 2, y - self:GetTall() - 14 - 5)

	if (not system.HasFocus()) then
		self:Remove()
	elseif (self.VGUI_Element) then
		if (not IsValid(self.VGUI_Element)) then
			self:Remove()
		elseif (vgui.GetHoveredPanel() ~= self.VGUI_Element) then
			if (self.HoverFrameNumber) then
				if (FrameNumber() > self.HoverFrameNumber) then
					self:Remove()
				end
			else
				self.HoverFrameNumber = FrameNumber() + 1
			end
		end
	end
end

function PANEL:SetText(text)
	self.Label:SetText(text)
	self.Label:SetWrap(false)
	self.Label:SizeToContentsX()
	if (self.Label:GetWide() >= 200) then
		self.Label:SetWide(200)
		self.Label:SetWrap(true)
		self.Label:SetAutoStretchVertical(true)
	end
end

derma.DefineControl("OpenPermissions.Tooltip", nil, PANEL, "DPanel")
--lua/vgui/stackerdnumslider.lua:
--[[--------------------------------------------------------------------------
-- 	Namespace Tables
--------------------------------------------------------------------------]]--

local PANEL = {}

--[[--------------------------------------------------------------------------
-- 	Localized Functions & Variables
--------------------------------------------------------------------------]]--

local math = math
local vgui = vgui
local tonumber = tonumber

--[[--------------------------------------------------------------------------
--	Namespace Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
--	PANEL:SetValue( string, boolean )
--
--]]--
function PANEL:SetValue( val, bSuppress )
	val = math.Clamp( tonumber( val ) or 0, self:GetMin(), self:GetMax() )

	if ( val == nil ) then return end
	if ( self:GetValue() == val ) then return end

	self.Scratch:SetFloatValue( val )
	self:ValueChanged( self:GetValue(), bSuppress )
end

--[[--------------------------------------------------------------------------
--
--	PANEL:ValueChanged( string, value)
--
--]]--
function PANEL:ValueChanged( val, bSuppress )
	val = math.Clamp( tonumber( val ) or 0, self:GetMin(), self:GetMax() )
	self.Slider:SetSlideX( self.Scratch:GetFraction( val ) )	
	if ( self.TextArea ~= vgui.GetKeyboardFocus() ) then
		self.TextArea:SetValue( self.Scratch:GetTextValue() )
	end
	if ( not bSuppress ) then
		self:OnValueChanged( val )
	end
end

vgui.Register( "StackerDNumSlider", PANEL, "DNumSlider" )
--addons/bkeypads/lua/matproxy/bkeypads.lua:
local IsValid = IsValid
local vec_black = Vector(0, 0, 0)

matproxy.Add({
	name = "KeycardColor",
	init = function(self, mat, values)
		self.ResultTo = values.resultvar
	end,
	bind = function(self, mat, ent)
		if IsValid(ent) and (ent.bKeypad or ent.bKeycard) then
			if ent.KeycardColor then
				mat:SetVector(self.ResultTo, ent.KeycardColor:ToVector())
			elseif ent.GetKeycardColor and ent:GetKeycardColor() then
				mat:SetVector(self.ResultTo, ent:GetKeycardColor():ToVector())
			end
		end
	end
})

matproxy.Add({
	name = "LEDColor",
	init = function(self, mat, values)
		self.ResultTo = values.resultvar
	end,
	bind = function(self, mat, ent)
		if IsValid(ent) and ent.bKeypad then
			if ent.GetLEDColor and ent:GetLEDColor() then
				mat:SetVector(self.ResultTo, ent:GetLEDColor():ToVector())
			else
				mat:SetVector(self.ResultTo, vec_black)
			end
		end
	end
})

matproxy.Add({
	name = "ScreenColor",
	init = function(self, mat, values)
		self.ResultTo = values.resultvar
	end,
	bind = function(self, mat, ent)
		if IsValid(ent) and (ent.bKeypad or ent.bKeypadOff) then
			if ent.GetScreenColor and ent:GetScreenColor() and not ent.m_bTVAnimation then
				mat:SetVector(self.ResultTo, ent:GetScreenColor():ToVector())
			else
				mat:SetVector(self.ResultTo, vec_black)
			end
		end
	end
})
--gamemodes/starwarsrp/gamemode/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Initialization      --
---------------------------------------

DeriveGamemode("egmrp")

GM.Name = "CW:RP"
GM.Version = "4.0.11"
--gamemodes/egmrp/gamemode/sh_utils.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
---------------------------------------
--         Shared | Utilities        --
---------------------------------------

-- Console Logging.

function LogMessage(color, message)
    MsgC(color, "[" .. Config.Prefix .. "] " .. message .. "\n")
end

function LogDebug(message)
    if Config.LogLevel <= 0 then
        LogMessage(Color(255, 255, 255), message)
    end
end

function LogInfo(message)
    if Config.LogLevel <= 1 then
        LogMessage(Color(0, 255, 0), message)
    end
end

function LogWarning(message)
    if Config.LogLevel <= 2 then
        LogMessage(Color(255, 255, 0), message)
    end
end

function LogError(message)
    if Config.LogLevel <= 3 then
        LogMessage(Color(255, 0, 0), message)
    end
end

-- Stool Loading.

stools = {}

function stools.GetList()
    return weapons.Get("gmod_tool").Tool
end

function stools.Get(toolmode)
    return stools.GetList()[toolmode]
end

function stools.Register(tool, toolmode)
    local ToolObj = getmetatable(stools.Get("remover"))

    local TOOL = ToolObj:Create()
    TOOL.Mode = toolmode

    for v, k in pairs(tool) do
        TOOL[v] = k
    end

    TOOL:CreateConVars()

    weapons.GetStored("gmod_tool").Tool[toolmode] = TOOL

    if CLIENT then
        timer.Create("EGM:RP.ReloadSpawnmenu", 1, 1, function()
            RunConsoleCommand("spawnmenu_reload")
        end)
    end
end

-- Module Loading.

function IsModuleLoaded(module)
    return table.HasValue(GAMEMODE.LoadedModules, module)
end

local function loadObject(path)
    if string.EndsWith(path, ".lua") then
        -- Single File Style Object.
        AddCSLuaFile(path)
        include(path)
    else
        -- Folder Style Object.
        if file.Exists(path .. "/init.lua", "LUA") or file.Exists(path .. "/cl_init.lua", "LUA") then
            if SERVER then
                AddCSLuaFile(path .. "/cl_init.lua")
                include(path .. "/init.lua")
            end

            if CLIENT then
                include(path .. "/cl_init.lua")
            end
        elseif file.Exists(path .. "/shared.lua", "LUA") then
            AddCSLuaFile(path .. "/shared.lua")
            include(path .. "/shared.lua")
        end
    end
end

local function loadObjects(path, callback)
    local fileNames, folderNames = file.Find(path .. "*", "LUA")

    for _, fileName in pairs(fileNames) do
        callback(string.sub(fileName, 0, #fileName - 4), path .. fileName)
    end

    for _, folderName in pairs(folderNames) do
        callback(folderName, path .. folderName)
    end
end

local function loadModuleEntities(folderPath)
    loadObjects(folderPath .. "entities/", function(name, path)
        local oldEnt = ENT
        ENT = {
            ClassName = name,
            Folder = "entities/" .. name,
            Spawnable = false,
            Editable = false,
            AdminOnly = false,
        }

        if CLIENT then
            ENT.AutomaticFrameAdvance = false
            ENT.Category = "Other"
            ENT.RenderGroup = RENDERGROUP_OPAQUE
            ENT.IconOverride = "materials/entities/" .. name .. ".png"
        end

        if SERVER then
            ENT.DisableDuplicator  = false
            ENT.DoNotDuplicate = false
        end

        loadObject(path)

        scripted_ents.Register(ENT, name)
        ENT = oldEnt
    end)
end

local function loadModuleWeapons(folderPath)
    loadObjects(folderPath .. "weapons/", function(name, path)
        local oldSWEP = SWEP
        SWEP = {
            ClassName = name,
            Folder = "weapons/" .. name,
            Spawnable = false,
            AdminOnly = false,
            PrintName = "Scripted Weapon",
            Base = "weapon_base",
            m_WeaponDeploySpeed  = 1,
            ViewModel = "models/weapons/v_pistol.mdl",
            WorldModel = "models/weapons/w_357.mdl",
            Slot = 0,
            SlotPos = 10,
            Primary = {},
            Secondary = {},
            DisableDuplicator = false,
            m_bPlayPickupSound = true,
        }

        if CLIENT then
            SWEP.Category = "Other"
            SWEP.Author = ""
            SWEP.Contact = ""
            SWEP.Purpose = ""
            SWEP.Instructions = ""
            SWEP.ViewModelFlip = false
            SWEP.ViewModelFlip1 = false
            SWEP.ViewModelFlip2 = false
            SWEP.ViewModelFOV = 62
            SWEP.BobScale = 1
            SWEP.SwayScale = 1
            SWEP.BounceWeaponIcon = true
            SWEP.DrawWeaponInfoBox = true
            SWEP.DrawAmmo = true
            SWEP.DrawCrosshair = true
            SWEP.RenderGroup = RENDERGROUP_OPAQUE
            SWEP.SpeechBubbleLid = surface.GetTextureID("gui/speech_lid")
            SWEP.WepSelectIcon = surface.GetTextureID("weapons/swep")
            SWEP.CSMuzzleFlashes = false
            SWEP.CSMuzzleX = false
            SWEP.UseHands = false
            SWEP.AccurateCrosshair = false
            SWEP.ScriptedEntityType = "weapon"
            SWEP.IconOverride = "materials/entities/" .. name .. ".png"
        end

        if SERVER then
            SWEP.AutoSwitchFrom = true
            SWEP.AutoSwitchTo = true
            SWEP.Weight = 5
        end

        loadObject(path)

        weapons.Register(SWEP, name)
        SWEP = oldSWEP
    end)
end

local function loadModuleTools(folderPath)
    loadObjects(folderPath .. "stools/", function(name, path)
        local oldTool = TOOL
        TOOL = {
            ClassName = name,
        }

        loadObject(path)

        stools.Register(TOOL, name)
        TOOL = oldTool
    end)
end

-- Loads the module after loading all required modules.
--
-- @param String module
-- @param? Boolean core - whether this is a core module, defaults to false
function LoadModule(module, core)
    if IsModuleLoaded(module) then
        return true
    else
        local subPath = core and "core" or "modules"

        -- Search for the module in the currently active gamemode first.
        local folderPath = GAMEMODE.FolderName .. "/gamemode/" .. subPath .. "/" .. module .. "/"
        local indexFile = folderPath .. "sh_index.lua"

        -- Check, if the module exists in the deriving gamemode, if not use the EGM:RP gamemode module.
        -- This allows module overriding and stuff.
        if not file.Exists(indexFile, "LUA") then
            folderPath = GAMEMODE.BaseClass.FolderName .. "/gamemode/" .. subPath .. "/" .. module .. "/"
            indexFile = folderPath .. "sh_index.lua"
        end

        if file.Exists(indexFile, "LUA") then
            LogInfo("Loading " .. subPath .. "/" .. module .. " ...")

            if SERVER then
                AddCSLuaFile(indexFile)
            end

            local loaded = include(indexFile)
            if loaded ~= false then
                table.insert(GAMEMODE.LoadedModules, module)

                loadModuleEntities(folderPath)
                loadModuleWeapons(folderPath)
                loadModuleTools(folderPath)

                hook.Run("EGMRP.ModuleLoaded", module, folderPath)

                return true
            else
                LogError("Failed to load " .. subPath .. "/" .. module)
            end
        else
            LogWarning(subPath .. "/" .. module .. " not found")
        end
    end

    return false
end

-- Helper function for loading required modules.
--
-- @param Table modules
-- @return Boolean success
function RequireModules(modules)
    for k, module in pairs(modules) do
        if not LoadModule(module) then
            return false
        end
    end

    return true
end
--addons/climb_swep_2/lua/weapons/climb_swep2/cl_init.lua:
include("shared.lua")

CreateClientConVar("climbswep2_showhud", 1, true, false)
SWEP.PrintName       = "Climb SWEP 2"
SWEP.Slot             = 3
SWEP.SlotPos         = 1
SWEP.DrawAmmo         = false
SWEP.DrawCrosshair     = false

local flags = {FCVAR_REPLICATED, FCVAR_ARCHIVE};
CreateConVar("climbswep2_necksnaps", "0", flags);
CreateConVar("climbswep2_wallrun_minheight", "250", flags);
CreateConVar("climbswep2_roll_allweps", "0", flags);
CreateConVar("climbswep2_slide_allweps", "0", flags);
CreateConVar("climbswep2_maxjumps", "3", flags);
--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/bkeypads/lua/weapons/gmod_tool/stools/bkeypads_fading_door.lua:
TOOL.Category = "Billy's Keypads"
TOOL.Name = "#bKeypads_FadingDoor"

TOOL.ClientConVar["toggle"] = 0
TOOL.ClientConVar["reversed"] = 0
TOOL.ClientConVar["mat"] = "sprites/heatwave"
TOOL.ClientConVar["opensound"] = ""
TOOL.ClientConVar["activesound"] = ""
TOOL.ClientConVar["closesound"] = ""
TOOL.ClientConVar["key"] = 0

local function ListMerge(dict, listName, mergeTbl)
	for _, v in ipairs(mergeTbl) do
		if not dict[v] then
			list.Add(listName, v)
		end
	end
end
local function InitLists()
	table.Empty(list.GetForEdit("bKeypads_FDoorMaterials"))
	table.Empty(list.GetForEdit("bKeypads_FDoorSounds"))
	table.Empty(list.GetForEdit("bKeypads_FDoorLoopSounds"))

	local dict = {}
	for _, mat in ipairs(bKeypads.Config.FadingDoors.Materials) do
		list.Add("bKeypads_FDoorMaterials", mat)
		dict[mat] = true
	end
	ListMerge(dict, "bKeypads_FDoorMaterials", list.Get("FDoorMaterials"))

	local dict = {}
	for _, snd in ipairs(bKeypads.Config.FadingDoors.Sounds) do
		if file.Exists("sound/" .. snd, "GAME") then
			util.PrecacheSound(snd)
			list.Add("bKeypads_FDoorSounds", snd)
			dict[snd] = true
		end
	end
	ListMerge(dict, "bKeypads_FDoorSounds", list.Get("FDoorSounds"))

	local dict = {}
	for _, snd in ipairs(bKeypads.Config.FadingDoors.LoopSounds) do
		if file.Exists("sound/" .. snd, "GAME") then
			util.PrecacheSound(snd)
			list.Add("bKeypads_FDoorLoopSounds", snd)
			dict[snd] = true
		end
	end
	ListMerge(dict, "bKeypads_FDoorLoopSounds", list.Get("FDoorLoopSounds"))
end
if bKeypads and bKeypads.Config then
	InitLists()
else
	hook.Add("bKeypads.Config", "bKeypads.FadingDoors.InitLists", InitLists)
end

if CLIENT then
	TOOL.Information = nil
	TOOL.Information = {
		{ name = "info1", icon = "gui/info"},
		{ name = "info2", icon = "gui/info" },
		{ name = "info3", icon = "gui/info" },
		
		{ name = "door", icon = "gui/lmb.png"},
		{ name = "copy", icon = "gui/rmb.png" },
		{ name = "remove", icon = "gui/r.png" },
	}
end

function TOOL:LeftClick(tr)
	return bKeypads.FadingDoors.STOOL.LeftClick(self, tr)
end

function TOOL:RightClick(tr)
	return bKeypads.FadingDoors.STOOL.RightClick(self, tr)
end

function TOOL:Reload(tr)
	return bKeypads.FadingDoors.STOOL.Reload(self, tr)
end

function TOOL:Deployed()
	if CLIENT then bKeypads.ESP:Activate() end
	bKeypads.FadingDoors.STOOL.Reset(self)
end
function TOOL:Holstered()
	if CLIENT then bKeypads.ESP:Deactivate() end
	bKeypads.FadingDoors.STOOL.Reset(self)
end
bKeypads_Prediction(TOOL)

if CLIENT then
	function TOOL.BuildCPanel(CPanel)
		return bKeypads.FadingDoors.STOOL.BuildCPanel(CPanel)
	end

	local matFadingDoorTool = Material("bkeypads/fading_door")
	function TOOL:DrawToolScreen(w,h)
		surface.SetDrawColor(0,150,255)
		surface.DrawRect(0,0,w,h)

		if not self.Matrix then
			self.Matrix = bKeypads_Matrix("STOOL_Screen", w, h)
		end
		self.Matrix:Draw(w,h)

		surface.SetMaterial(matFadingDoorTool)
		surface.DrawTexturedRect(0, 0, w, h)

		if not bKeypads.Permissions:Cached(LocalPlayer(), "fading_doors/create") then
			bKeypads:ToolScreenNoPermission(w,h)
		elseif not bKeypads.STOOL:CheckLimit(LocalPlayer(), bKeypads.STOOL.LIMIT_FADING_DOORS) then
			bKeypads:ToolScreenWarning(bKeypads.L("SBoxLimit__bkeypads_fading_doors"), w, h)
		end
	end
end
--gamemodes/starwarsrp/entities/weapons/gmod_tool/stools/item_ammo_crate.lua:

TOOL.Category = "EGM:RP Util"
TOOL.Name = "#tool.item_ammo_crate"

TOOL.ClientConVar[ "type" ] = "0"

local ToolModels = {}
ToolModels[ 2 ] = "models/items/ammocrate_ar2.mdl"
ToolModels[ 3 ] = "models/items/ammocrate_rockets.mdl"

--ToolModels[ 0 ] = "models/items/ammocrate_pistol.mdl"
--ToolModels[ 1 ] = "models/items/ammocrate_smg1.mdl"
--ToolModels[ 2 ] = "models/items/ammocrate_ar2.mdl"
--ToolModels[ 3 ] = "models/items/ammocrate_rockets.mdl"
--ToolModels[ 4 ] = "models/items/ammocrate_buckshot.mdl"
--ToolModels[ 5 ] = "models/items/ammocrate_grenade.mdl"
--ToolModels[ 6 ] = "models/items/ammocrate_357.mdl"
--ToolModels[ 7 ] = "models/items/ammocrate_crossbow.mdl"
--ToolModels[ 8 ] = "models/items/ammocrate_ar2.mdl"
--ToolModels[ 9 ] = "models/items/ammocrate_smg2.mdl"
--ToolModels[ 10 ] = "models/items/ammocrate_smg1.mdl"

cleanup.Register( "item_ammo_crates" )

if ( SERVER ) then

	CreateConVar( "rb655_force_downloads", "0", FCVAR_ARCHIVE )

	if ( GetConVarNumber( "rb655_force_downloads" ) > 0 ) then

		resource.AddFile( "models/items/ammocrate_357.mdl" )
		resource.AddFile( "models/items/ammocrate_crossbow.mdl" )

	end

	CreateConVar( "sbox_maxitem_ammo_crates", 10 )

	function MakeAmmoCrate( ply, model, pos, ang, type )
		if ( IsValid( ply ) and !ply:CheckLimit( "item_ammo_crates" ) ) then return end

		type = tonumber( type ) or 0

		local item_ammo_crate = ents.Create( "item_ammo_crate" )
		if ( !IsValid( item_ammo_crate ) ) then return end
		item_ammo_crate:SetPos( pos )
		item_ammo_crate:SetAngles( ang )
		item_ammo_crate:SetKeyValue( "AmmoType", math.Clamp( type, 0, 9 ) )
		item_ammo_crate:Spawn()
		item_ammo_crate:Activate()
		item_ammo_crate:SetModel( model )

		table.Merge( item_ammo_crate:GetTable(), {
			ply = ply,
			type = type
		} )

		if ( IsValid( ply ) ) then
			ply:AddCount( "item_ammo_crates", item_ammo_crate )
			ply:AddCleanup( "item_ammo_crates", item_ammo_crate )
		end

		DoPropSpawnedEffect( item_ammo_crate )

		return item_ammo_crate
	end

	duplicator.RegisterEntityClass( "item_ammo_crate", MakeAmmoCrate, "model", "pos", "ang", "type" )
end

function TOOL:LeftClick( trace )
	if ( trace.HitSky or !trace.HitPos or trace.HitNormal.z < 0.7 ) then return false end
	if ( IsValid( trace.Entity ) and ( trace.Entity:GetClass() == "item_ammo_crate" or trace.Entity:IsPlayer() or trace.Entity:IsNPC() ) ) then return false end
	if ( CLIENT ) then return true end

	local ply = self:GetOwner()

	local ang = trace.HitNormal:Angle()
	ang.p = ang.p - 270
	if ( trace.HitNormal.z > 0.9999 ) then ang.y = ply:GetAngles().y + 180 end

	local type = self:GetClientNumber( "type" )
	if ( type == 10 ) then type = math.random( 0, 9 ) end

	local item_ammo_crate = MakeAmmoCrate( ply, ToolModels[ type ], trace.HitPos + trace.HitNormal * 16, ang, type )

	undo.Create( "item_ammo_crate" )
		undo.AddEntity( item_ammo_crate )
		undo.SetPlayer( ply )
	undo.Finish()

	return true
end

function TOOL:UpdateGhostEntity( ent, ply )
	if ( !IsValid( ent ) ) then return end

	local trace = ply:GetEyeTrace()

	if ( !trace.Hit or trace.HitNormal.z < 0.7 ) then ent:SetNoDraw( true ) return end
	if ( trace.Entity and ( trace.Entity:GetClass() == "item_ammo_crate" or trace.Entity:IsPlayer() ) ) then ent:SetNoDraw( true ) return end

	local ang = trace.HitNormal:Angle()
	ang.p = ang.p - 270
	if ( trace.HitNormal.z > 0.9999 ) then ang.y = ply:GetAngles().y + 180 end

	local min = ent:OBBMins()
	ent:SetPos( trace.HitPos - trace.HitNormal * min.z )

	ent:SetAngles( ang )
	ent:SetNoDraw( false )
end

function TOOL:Think()
	if ( !IsValid( self.GhostEntity ) or self.GhostEntity:GetModel() != ToolModels[ self:GetClientNumber( "type" ) ] ) then
		local model = ToolModels[ self:GetClientNumber( "type" ) ]
		if model then
			self:MakeGhostEntity(model , Vector( 0, 0, 0 ), Angle( 0, 0, 0 ) )
		end
	end
	self:UpdateGhostEntity( self.GhostEntity, self:GetOwner() )
end

list.Set( "AmmoCrateTypes", "#AR2_ammo", { item_ammo_crate_type = "2" } )
list.Set( "AmmoCrateTypes", "#RPG_round_ammo", { item_ammo_crate_type = "3" } )

--list.Set( "AmmoCrateTypes", "#Pistol_ammo", { item_ammo_crate_type = "0" } )
--list.Set( "AmmoCrateTypes", "#Buckshot_ammo", { item_ammo_crate_type = "4" } )
--list.Set( "AmmoCrateTypes", "#SMG1_grenade_ammo", { item_ammo_crate_type = "9" } )
--
--list.Set( "AmmoCrateTypes", "#SMG1_ammo", { item_ammo_crate_type = "1" } )
--list.Set( "AmmoCrateTypes", "#AR2_ammo", { item_ammo_crate_type = "2" } )
--list.Set( "AmmoCrateTypes", "#RPG_round_ammo", { item_ammo_crate_type = "3" } )
--list.Set( "AmmoCrateTypes", "#Buckshot_ammo", { item_ammo_crate_type = "4" } )
--list.Set( "AmmoCrateTypes", "#Grenade_ammo", { item_ammo_crate_type = "5" } )
--list.Set( "AmmoCrateTypes", "#357_ammo", { item_ammo_crate_type = "6" } )
--list.Set( "AmmoCrateTypes", "#XBowBolt_ammo", { item_ammo_crate_type = "7" } )
--list.Set( "AmmoCrateTypes", "#AR2AltFire_ammo", { item_ammo_crate_type = "8" } )
--list.Set( "AmmoCrateTypes", "#SMG1_grenade_ammo", { item_ammo_crate_type = "9" } )
--list.Set( "AmmoCrateTypes", "#tool.item_ammo_crate.random", { item_ammo_crate_type = "10" } )

if ( SERVER ) then return end

TOOL.Information = { { name = "left" } }

language.Add( "#AR2_ammo", "Blaster Ammo")
language.Add( "#RPG_round_ammo", "Explosives")

language.Add( "tool.item_ammo_crate", "Ammo Crates" )
language.Add( "tool.item_ammo_crate.name", "Ammo Crate Tool" )
language.Add( "tool.item_ammo_crate.desc", "Spawn crates full of ammo for resupply" )
language.Add( "tool.item_ammo_crate.left", "Spawn an ammo crate" )

language.Add( "tool.item_ammo_crate.type", "Ammo Crate Type" )
language.Add( "tool.item_ammo_crate.random", "Random" )

language.Add( "Cleanup_item_ammo_crates", "Ammo Crates" )
language.Add( "Cleaned_item_ammo_crates", "Cleaned up all Ammo Crates" )
language.Add( "SBoxLimit_item_ammo_crates", "You've hit the Ammo Crate limit!" )
language.Add( "Undone_item_ammo_crate", "Ammo Crate undone" )

language.Add( "max_item_ammo_crates", "Max Ammo Crates:" )

function TOOL.BuildCPanel( panel )
	panel:AddControl( "ListBox", { Label = "#tool.item_ammo_crate.type", Options = list.Get( "AmmoCrateTypes" ), Height = 204 } )
end

--lua/weapons/gmod_tool/stools/ladder.lua:
AddCSLuaFile();

TOOL.Category = "Construction"
TOOL.Name = "Ladders"
TOOL.ClientConVar["laddername"] = "";
TOOL.ClientConVar["model"] = "models/props_c17/metalladder001.mdl";
TOOL.Information = {
	{name = "left", stage = 0},
	{name = "right", stage = 0},
	{name = "left_next", stage = 1, icon = "gui/lmb.png"}
};

/*
	ladderOptions is a list of approved models that can be used in the tool.
	Prevents people from using console to set the model to something that won't work.

	Parameters:
		- origin: Where is the origin of the ladder in relation to the bottom? If the ladder's :GetPos() is in the center, find the unit distance between the bottom and center.
			See the third ladder in the table.
		- height: How many units tall is this ladder?
		- ladderOffset: How many units away from the wall should the ladder entity be placed?
		- propOffset: How many units away from the wall should the ladder props be placed?
*/

local ladderOptions = {
	["models/props_c17/metalladder001.mdl"] = {
		origin = vector_origin,
		height = 127.5,
		ladderOffset = 25,
		propOffset = 2.5
	},

	["models/props_c17/metalladder002.mdl"] = {
		origin = vector_origin,
		height = 127.5,
		ladderOffset = 30
	},

	["models/props/cs_militia/ladderrung.mdl"] = {
		origin = Vector(0, 0, 63.75),
		height = 127.5,
		ladderOffset = 25
	},

	["models/props/cs_militia/ladderwood.mdl"] = {
		origin = Vector(0, 0, 74),
		height = 147,
		ladderOffset = 20,
		propOffset = 1
	},
};

cleanup.Register("ladders");
cleanup.Register("ladder_dismounts");

if (SERVER) then
	if (!ConVarExists("sbox_maxladders")) then
		CreateConVar("sbox_maxladders", 5, {FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Maximum number of ladders which can be created by users.");
	end;

	if (!ConVarExists("sbox_maxladder_dismounts")) then
		CreateConVar("sbox_maxladder_dismounts", 10, {FCVAR_ARCHIVE, FCVAR_REPLICATED}, "Maximum number of dismount points which can be created by users. Recommended to be double the number of ladders (two for each ladder).");
	end;
end;

/*
	Helper function to get segments on a line.
*/

local function GetSegments(p1, p2, segLength, bInclusive)
	local points = {};
	local distance = p1:Distance(p2);
	local norm = (p2 - p1):GetNormalized();

	local total = math.floor(distance / segLength);
	local nextPos = p1;

	if (bInclusive) then
		table.insert(points, p1);
	end;

	for i = 1, total do
		nextPos = nextPos + norm * segLength;
		table.insert(points, nextPos);
	end;

	if (bInclusive) then
		table.insert(points, p2);
	end;

	return points;
end;

/*
	Ladder Creation
*/
do
	local dismountHull = {
		mins = Vector(-16, -16, 0),
		maxs = Vector(16, 16, 4)
	};

	function TOOL:LeftClick(trace)
		if (IsValid(trace.Entity) and trace.Entity:IsPlayer()) then return false; end;
		if (CLIENT) then return true; end;
		if (!self:GetOwner():CheckLimit("ladders")) then return false; end;

		-- If we haven't selected a first point...
		if (self:GetStage() == 0) then
			-- Retrieve the physics object of any hit entity. Made useless by previous code, but /something/ needs to go into SetObject...
			-- As well, retrieve a modified version of the surface normal. This normal is always horizontal and only rotates around the Y axis. Yay straight ladders.
			local physObj = trace.Entity:GetPhysicsObjectNum(trace.PhysicsBone);
			local normal = Angle(0, trace.HitNormal:Angle().y, 0):Forward();

			-- Clear out any junk that could possibly be left over, and store our data.
			self:ClearObjects();
			self:SetObject(1, trace.Entity, trace.HitPos, physObj, trace.PhysicsBone, normal);

			-- Move to the next stage.
			self:SetStage(1);
		else
			-- Same as before, and check how far away the ladder entity needs to be created, based on which model we're using.
			local physObj = trace.Entity:GetPhysicsObjectNum(trace.PhysicsBone);
			local normal = Angle(0, trace.HitNormal:Angle().y, 0):Forward();
			local model = self:GetClientInfo("model");

			-- If the user is being maLICIOUS and trying to use a model not on the list, default to the standard ladder.
			if (!ladderOptions[model]) then
				model = "models/props_c17/metalladder001.mdl";
			end;

			local options = ladderOptions[model];
			local offset = options.ladderOffset;

			-- Store the data of our second click.
			self:SetObject(2, trace.Entity, trace.HitPos, physObj, trace.PhysicsBone, normal);

			-- Define the top and bottom points of our func_useableladder.
			local top = self:GetPos(1) + self:GetNormal(1) * offset;
			local bottom = Vector(self:GetPos(1).x, self:GetPos(1).y, self:GetPos(2).z + 5) + self:GetNormal(1) * offset;

			-- Create a table to hold all of the created prop_physics. This is used later for undo.AddEntity, and for dismount parenting.
			-- Then, retrieve all of the segment points in a straight line from top to bottom of the ladder.
			local ladderProps = {};
			local fixOffset = options.height - options.origin.z;
			local topPos = self:GetPos(1) - Vector(0, 0, fixOffset);
			local bottomPos = Vector(self:GetPos(1).x, self:GetPos(1).y, self:GetPos(2).z) + options.origin + Vector(0, 0, 1);
			local points = GetSegments(topPos, bottomPos, options.height, true);

			-- If our bottom point manages to be higher than our top, remove it.
			if (topPos.z < bottomPos.z) then
				table.remove(points);
			end;

			-- Start our undo stack.
			undo.Create("Ladder");

			-- If a point is too close for whatever reason, remove it.
			for i = 1, #points do
				if (points[i - 1]) then
					if (points[i - 1]:Distance(points[i]) < 30) then
						table.remove(points, i);
					end;
				end;
			end;

			-- For every point in our table of segments, create a prop_physics, destroy its physics object, and add it to the undo stack.
			for k, pos in pairs(points) do
				local ladder = ents.Create("prop_physics");
				ladder:SetPos(pos + self:GetNormal(1) * (options.propOffset or 0));
				ladder:SetAngles(self:GetNormal(1):Angle());
				ladder:SetModel(model);
				ladder:Spawn();

				ladder:GetPhysicsObject():EnableMotion(false);
				ladder:PhysicsDestroy();

				table.insert(ladderProps, ladder);
				undo.AddEntity(ladder);
			end;

			-- Create the actual ladder entity.
			local ladderEnt = ents.Create("func_useableladder");
			ladderEnt:SetPos(LerpVector(0.5, top, bottom));
			ladderEnt:SetKeyValue("point0", tostring(bottom));
			ladderEnt:SetKeyValue("point1", tostring(top));

			local targetName = self:GetClientInfo("laddername");

			if (!targetName or targetName == "") then
				targetName = ladderEnt:EntIndex();
			end;

			ladderEnt:SetKeyValue("targetname", "zladder_" .. targetName);
			ladderEnt:SetParent(ladderProps[1]);
			ladderEnt:Spawn();

			ladderEnt:CallOnRemove("cleanup", function(ladder)
				if (!ladder.props) then return; end;

				for k, v in pairs(ladder.props) do
					SafeRemoveEntity(v);
				end;
			end);

			-- Store all the props on the ladder entity.
			ladderEnt.propTable = {};
			ladderEnt.props = {};
			ladderEnt.model = model;

			-- Store our normal on the ladder.
			ladderEnt.normal = self:GetNormal(1);

			-- Let our hook inside lua/autorun know that the props here have a ladder attached, so disallow +USE on them.
			for k, v in pairs(ladderProps) do
				v.ladder = ladderEnt;

				v:DrawShadow(false);
				v:SetCollisionGroup(COLLISION_GROUP_WORLD);

				table.insert(ladderEnt.propTable, {
					origin = v:GetPos(),
					angles = v:GetAngles()
				});

				table.insert(ladderEnt.props, v);

				v:SetNWEntity("ladder", ladderEnt);
			end;

			local topTrace = util.TraceHull({
				start = self:GetPos(1) - self:GetNormal(1) * 17 + Vector(0, 0, 5),
				endpos = self:GetPos(1) - self:GetNormal(1) * 17 - Vector(0, 0, 15),
				mins = dismountHull.mins,
				maxs = dismountHull.maxs,
				filter = function(ent) if (ent:IsPlayer() or ent:IsNPC()) then return false; else return true; end; end;
			});

			if (topTrace.Hit and !topTrace.AllSolid and !topTrace.StartSolid) then
				local topDismount = ents.Create("info_ladder_dismount");
				topDismount:SetPos(topTrace.HitPos);
				topDismount:Spawn();
				topDismount:SetParent(ladderEnt);
				topDismount:SetName("zdismount_" .. topDismount:EntIndex());
			end;

			local bottomTrace = util.TraceHull({
				start = bottom + self:GetNormal(1) * 34 + Vector(0, 0, 5),
				endpos = bottom + self:GetNormal(1) * 34 - Vector(0, 0, 15),
				mins = dismountHull.mins,
				maxs = dismountHull.maxs,
				filter = function(ent) if (ent:IsPlayer() or ent:IsNPC()) then return false; else return true; end; end;
			});

			if (bottomTrace.Hit and !bottomTrace.AllSolid and !bottomTrace.StartSolid) then
				local bottomDismount = ents.Create("info_ladder_dismount");
				bottomDismount:SetPos(bottomTrace.HitPos);
				bottomDismount:Spawn();
				bottomDismount:SetParent(ladderEnt);
				bottomDismount:SetName("zdismount_" .. bottomDismount:EntIndex());
			end;

			-- Push the ladder entity onto our undo stack.
			undo.AddEntity(ladderEnt);

			-- Set the undo owner, the text, and close the stack.
			undo.SetPlayer(self:GetOwner());
			undo.SetCustomUndoText("Undone Ladder");
			undo.Finish();

			-- Calling CFuncLadder::Activate will force the ladder to search for dismount points near the top and bottom.
			ladderEnt:Activate();

			-- We've finished making our ladder, so go back to stage 0, clear any objects, and add 1 to our cleanup count.
			self:SetStage(0);
			self:ClearObjects();

			self:GetOwner():AddCount("ladders", ladderEnt);
			self:GetOwner():AddCleanup("ladders", ladderEnt);
		end;

		return true;
	end;

	/*
		Dismount Placing
	*/

	function TOOL:RightClick(trace)
		if (IsValid(trace.Entity) and trace.Entity:IsPlayer()) then return false; end;
		if (self:GetStage() > 0) then return false; end;
		if (CLIENT) then return true; end;
		if (!self:GetOwner():CheckLimit("ladder_dismounts")) then return false; end;

		-- Perform a hull trace the size of a dismount spot to determine a safe place to put it. If the dismount is intersecting with ANY geometry-
		-- the engine will consider it blocked, and the player cannot use it.
		local hullTrace = util.TraceHull({
			start = trace.HitPos + trace.HitNormal * 16,
			endpos = trace.HitPos - trace.HitNormal * 10,
			mins = dismountHull.mins,
			maxs = dismountHull.maxs
		});

		if (!hullTrace.Hit) then return false; end;

		-- targetName will be the name of the ladder this dismount is going to attach to.
		local targetName = self:GetClientInfo("laddername");
		local dismount = ents.Create("info_ladder_dismount");
		dismount:SetPos(hullTrace.HitPos);
		dismount:SetKeyValue("targetname", "zdismount_" .. dismount:EntIndex());

		-- If targetName was specified, set the key value. m_target tells the engine that this dismount spot only works for ladders whose names equal this.
		if (targetName and targetName != "") then
			dismount:SetKeyValue("target", "zladder_" .. targetName);
		end;

		dismount:Spawn();

		-- Loop through all entities on the map. If it's a ladder, and it has our custom prefix, then check if its entity name is equal to our current name.
		-- If so, parent it, so that when the ladder is removed, it cleans up the dismount.
		for k, v in pairs(ents.GetAll()) do
			if (v:GetClass() == "func_useableladder" and v:GetName():find("zladder_")) then
				if (targetName and targetName != "") then
					if (v:GetName() == "zladder_" .. targetName) then
						dismount:SetParent(v);
					end;
				end;

				-- CFuncLadder::Activate, so dismount points for ladders are updated.
				v:Activate();
			end;
		end;

		-- Create our undo stack, push the dismount point, assign ownership, then finish.
		undo.Create("Ladder Dismount");
			undo.AddEntity(dismount);
			undo.SetPlayer(self:GetOwner());
			undo.SetCustomUndoText("Undone Ladder Dismount");
		undo.Finish();

		-- Add the dismount point to our cleanup count.
		self:GetOwner():AddCount("ladder_dismounts", dismount);
		self:GetOwner():AddCleanup("ladder_dismounts", dismount);

		return true;
	end;
end;

function TOOL:Think()
end

/*
	Holster
	Clear stored objects and reset state
*/

function TOOL:Holster()
	self:ClearObjects();
	self:SetStage(0);
end;

/*
	Control Panel
*/

function TOOL.BuildCPanel(CPanel)
	local modelTable = {};

	for k, v in pairs(ladderOptions) do
		modelTable[k] = {};
	end;

	CPanel:AddControl("Header", {
		Description = "#tool.ladder.desc"
	});

	CPanel:AddControl("TextBox", {
		Label = "Ladder Name",
		Command = "ladder_laddername"
	});

	CPanel:AddControl("PropSelect", {
		Label = "Select a model to use",
		ConVar = "ladder_model",
		Height = 1,
		Width = 3,
		Models = modelTable
	});

end;

/*
	Language strings
*/

if (CLIENT) then
	language.Add("tool.ladder.name", "Ladders");
	language.Add("tool.ladder.left", "Select the top point for your ladder.");
	language.Add("tool.ladder.right", "Place a dismount point.");
	language.Add("tool.ladder.left_next", "Now left click anywhere lower than your first point to determine the height.");
	language.Add("tool.ladder.desc", "Create ladders, duh.");

	language.Add("Cleaned_ladders", "Cleaned up all Ladders");
	language.Add("Cleanup_ladders", "Ladders");

	language.Add("Cleaned_ladder_dismounts", "Cleaned up all Ladder Dismounts");
	language.Add("Cleanup_ladder_dismounts", "Ladder Dismounts");
end;
--lua/weapons/gmod_tool/stools/npctool_notarget.lua:
TOOL.Category = "NPC Control"
TOOL.Name = "NPC Notarget"
TOOL.Command = nil
TOOL.ConfigName = ""

if(CLIENT) then
	language.Add("tool.npctool_notarget.name","No Target")
	language.Add("tool.npctool_notarget.desc","Enable/Disable notarget for a NPC or yourself")
	language.Add("tool.npctool_notarget.0","Left-Click to enable/disable notarget for the NPC you're looking at. Right click to enable/disable notarget for yourself.")
	
	function TOOL.BuildCPanel(pnl)
		pnl:AddControl("Header",{Text = "Notarget",Description = [[Left-Click to enable/disable notarget for the NPC you're looking at.
		Right click to enable/disable notarget for yourself.
		]]})
	end
else
	local _R = debug.getregistry()
	local meta = _R.Player
	if(!meta.GetNoTarget) then
		local SetNoTarget = meta.SetNoTarget
		function meta:SetNoTarget(...)
			self.m_bNoTarget = ...
			return SetNoTarget(self,...)
		end
		function meta:GetNoTarget() return self.m_bNoTarget || false end
	end
	local meta = _R.NPC
	if(!meta.SetNoTarget) then
		local tbNPCsNoTarget = {}
		local AddEntityRelationship = meta.AddEntityRelationship
		function meta:AddEntityRelationship(...)
			local ent,disp = ...
			local dispCur = self:Disposition(ent)
			if(tbNPCsNoTarget[self]) then
				tbNPCsNoTarget[self][ent] = disp
				return
			end
			return AddEntityRelationship(self,...)
		end
		function meta:SetNoTarget(bNoTarget)
			if(bNoTarget) then
				if(!tbNPCsNoTarget[self]) then
					tbNPCsNoTarget[self] = {}
					for _,ent in ipairs(ents.GetAll()) do
						if(ent:IsNPC() && ent != self) then
							tbNPCsNoTarget[self][ent] = ent:Disposition(self)
							AddEntityRelationship(ent,self,D_NU,100)
						end
					end
				end
				return
			end
			for ent,disp in pairs(tbNPCsNoTarget[self]) do
				if(ent:IsValid()) then
					AddEntityRelationship(ent,self,disp,100)
				end
			end
			tbNPCsNoTarget[self] = nil
		end
		hook.Add("OnEntityCreated","ApplyNoTarget",function(ent)
			if(ent:IsValid() && ent:IsNPC()) then
				for entTgt,_ in pairs(tbNPCsNoTarget) do
					if(entTgt:IsValid()) then
						tbNPCsNoTarget[entTgt][ent] = ent:Disposition(entTgt)
						AddEntityRelationship(ent,entTgt,D_NU,100)
					else tbNPCsNoTarget[entTgt] = nil end
				end
			end
		end)
		function meta:GetNoTarget()
			return tbNPCsNoTarget[self] && true || false
		end
	end
end

function TOOL:LeftClick(tr)
	if(CLIENT) then return true end
	if(tr.Entity:IsValid() && tr.Entity:IsNPC()) then
		local bNoTarget = !tr.Entity:GetNoTarget()
		tr.Entity:SetNoTarget(bNoTarget)
		local l = "notification.AddLegacy(\"" .. (bNoTarget && "Enabled " || "Disabled ") .. "notarget for \" .. language.GetPhrase(\"#" .. tr.Entity:GetClass() .. "\") .. \".\",1,8);"
		l = l .. "surface.PlaySound(\"buttons/button14.wav\")"
		self:GetOwner():SendLua(l)
		return true
	end
end

function TOOL:RightClick(tr)
	if(CLIENT) then return true end
	local owner = self:GetOwner()
	local bNoTarget = !owner:GetNoTarget()
	owner:SetNoTarget(bNoTarget)
	local l = "notification.AddLegacy(\"" .. (bNoTarget && "Enabled " || "Disabled ") .. "notarget for " .. owner:GetName() .. ".\",1,8);"
	l = l .. "surface.PlaySound(\"buttons/button14.wav\")"
	owner:SendLua(l)
	return false
end
--lua/weapons/gmod_tool/stools/precision.lua:

TOOL.Category		= "Constraints"
TOOL.Name			= "#Precision"
TOOL.Command		= nil
TOOL.ConfigName		= ""

TOOL.ClientConVar[ "mode" ]	 			= "1"
TOOL.ClientConVar[ "user" ] 			= "1"

TOOL.ClientConVar[ "freeze" ]	 		= "1"
TOOL.ClientConVar[ "nocollide" ]		= "1"
TOOL.ClientConVar[ "nocollideall" ]		= "0"
TOOL.ClientConVar[ "rotation" ] 		= "15"
TOOL.ClientConVar[ "rotate" ] 			= "1"
TOOL.ClientConVar[ "offset" ]	 		= "0"
TOOL.ClientConVar[ "forcelimit" ]		= "0"
TOOL.ClientConVar[ "torquelimit" ] 		= "0"
TOOL.ClientConVar[ "friction" ]	 		= "0"
TOOL.ClientConVar[ "width" ]	 		= "1"
TOOL.ClientConVar[ "offsetpercent" ] 	= "1"
TOOL.ClientConVar[ "removal" ]	 		= "0"
TOOL.ClientConVar[ "move" ]	 			= "1"
TOOL.ClientConVar[ "physdisable" ]		= "0"
TOOL.ClientConVar[ "ShadowDisable" ]	= "0"
TOOL.ClientConVar[ "allowphysgun" ]		= "0"
TOOL.ClientConVar[ "autorotate" ]		= "0"
TOOL.ClientConVar[ "entirecontrap" ]	= "0"
TOOL.ClientConVar[ "nudge" ]			= "25"
TOOL.ClientConVar[ "nudgepercent" ]		= "1"
TOOL.ClientConVar[ "disablesliderfix" ]	= "0"

//adv ballsocket
TOOL.ClientConVar[ "XRotMin" ]		= "-180"
TOOL.ClientConVar[ "XRotMax" ]		= "180"
TOOL.ClientConVar[ "YRotMin" ]		= "-180"
TOOL.ClientConVar[ "YRotMax" ]		= "180"
TOOL.ClientConVar[ "ZRotMin" ]		= "-180"
TOOL.ClientConVar[ "ZRotMax" ]		= "180"
TOOL.ClientConVar[ "XRotFric" ]		= "0"
TOOL.ClientConVar[ "YRotFric" ]		= "0"
TOOL.ClientConVar[ "ZRotFric" ]		= "0"
TOOL.ClientConVar[ "FreeMov" ]		= "0"

//Removal
TOOL.ClientConVar[ "removal_nocollide" ]	= "1"
TOOL.ClientConVar[ "removal_weld" ]	 		= "1"
TOOL.ClientConVar[ "removal_axis" ]	 		= "1"
TOOL.ClientConVar[ "removal_ballsocket" ]	= "1"
TOOL.ClientConVar[ "removal_advballsocket" ]= "1"
TOOL.ClientConVar[ "removal_slider" ]	 	= "1"
TOOL.ClientConVar[ "removal_parent" ]	 	= "1"
TOOL.ClientConVar[ "removal_other" ]	 	= "1"


TOOL.ClientConVar[ "enablefeedback" ]	= "1"
TOOL.ClientConVar[ "chatfeedback" ]		= "1"
TOOL.ClientConVar[ "nudgeundo" ]		= "0"
TOOL.ClientConVar[ "moveundo" ]			= "1"
TOOL.ClientConVar[ "rotateundo" ]		= "1"

function TOOL:DoParent( Ent1, Ent2 )
	local TempEnt = Ent2
	if !(Ent1 && Ent1:IsValid() && Ent1:EntIndex() != 0) then
		self:SendMessage( "Oops, First Target was world or something invalid" )
		return
	end
	if !(Ent2 && Ent2:IsValid() && Ent2:EntIndex() != 0) then
		self:SendMessage( "Oops, Second Target was world or something invalid" )
		return
	end
	if ( Ent1 == Ent2 ) then
		self:SendMessage( "Oops, Can't parent something to itself" )
		return
	end
	Ent1:SetMoveType(MOVETYPE_NONE)
	local disablephysgun = self:GetClientNumber( "allowphysgun" ) == 0
	Ent1.PhysgunDisabled = disablephysgun
	Ent1:SetUnFreezable( disablephysgun )
	local Phys1 = Ent1:GetPhysicsObject()
	if Phys1:IsValid() then
		Phys1:EnableCollisions( false )
	end
	while true do
		if ( !TempEnt:GetParent():IsValid() ) then
			Ent1:SetParent( Ent2 )
			if self:GetClientNumber( "entirecontrap" ) == 0 then self:SendMessage( "Parent Set." ) end
			Phys1:Wake()
			break
		elseif ( TempEnt:GetParent() == Ent1 ) then
			UndoParent( TempEnt )
			timer.Simple( 0.1, function()//delay to stop crash
				Ent1.SetParent( Ent1, Ent2)
			end)
			self:SendMessage( "Oops, Closed Parent Loop Detected; Broken loop and set parent." )
			break
		else
			TempEnt = TempEnt:GetParent()
		end
	end
	Phys1:Wake()
	//Phys1:UpdateShadow(Ent1:GetAngles(),Ent1:GetAngles())
end

function TOOL:UndoParent( Ent1 )
	Ent1:SetParent( nil )
	Ent1:SetMoveType(MOVETYPE_VPHYSICS)
	Ent1.PhysgunDisabled = false
	Ent1:SetUnFreezable( false )
	local Phys1 = Ent1:GetPhysicsObject()
	if Phys1:IsValid() then
		Phys1:EnableCollisions( true )
		Phys1:Wake()
		//Phys1:UpdateShadow(Ent1:GetAngles(),Ent1:GetAngles())
	end
end

function TOOL:DoApply(CurrentEnt, FirstEnt, autorotate, nocollideall, ShadowDisable )
	local CurrentPhys = CurrentEnt:GetPhysicsObject()
	
	//local col = CurrentEnt:GetCollisionGroup()
	//col = 19
	//CurrentEnt:SetCollisionGroup(col)
	//self:SendMessage("New group: "..col)
	
	//if ( CurrentPhys:IsDragEnabled() ) then
	//end
	//CurrentPhys:SetAngleDragCoefficient(1.05)
	//CurrentPhys:SetDragCoefficient(1.05)
	
	if ( autorotate ) then
		if ( CurrentEnt == FirstEnt ) then//Snap-rotate original object first.  Rest needs to rotate around it.
			local angle = CurrentPhys:RotateAroundAxis( Vector( 0, 0, 1 ), 0 )
			self.anglechange = Vector( angle.p - (math.Round(angle.p/45))*45, angle.r - (math.Round(angle.r/45))*45, angle.y - (math.Round(angle.y/45))*45 )
			if ( table.Count(self.TaggedEnts) == 1 ) then
				angle.p = (math.Round(angle.p/45))*45
				angle.r = (math.Round(angle.r/45))*45//Only rotate on these axies if it's singular.
			end
			angle.y = (math.Round(angle.y/45))*45
			CurrentPhys:SetAngles( angle )
		else
			local distance = math.sqrt(math.pow((CurrentEnt:GetPos().X-FirstEnt:GetPos().X),2)+math.pow((CurrentEnt:GetPos().Y-FirstEnt:GetPos().Y),2))
			local theta = math.atan((CurrentEnt:GetPos().Y-FirstEnt:GetPos().Y) / (CurrentEnt:GetPos().X-FirstEnt:GetPos().X)) - math.rad(self.anglechange.Z)
			if (CurrentEnt:GetPos().X-FirstEnt:GetPos().X) < 0 then
				CurrentEnt:SetPos( Vector( FirstEnt:GetPos().X - (distance*(math.cos(theta))), FirstEnt:GetPos().Y - (distance*(math.sin(theta))), CurrentEnt:GetPos().Z ) )
			else
				CurrentEnt:SetPos( Vector( FirstEnt:GetPos().X + (distance*(math.cos(theta))), FirstEnt:GetPos().Y + (distance*(math.sin(theta))), CurrentEnt:GetPos().Z ) )
			end
			CurrentPhys:SetAngles( CurrentPhys:RotateAroundAxis( Vector( 0, 0, -1 ), self.anglechange.Z ) )
		end
	end

	CurrentPhys:EnableCollisions( !nocollideall )
	CurrentEnt:DrawShadow( !ShadowDisable )
	if physdis then
		CurrentEnt:SetMoveType(MOVETYPE_NONE)
		CurrentEnt.PhysgunDisabled = disablephysgun
		CurrentEnt:SetUnFreezable( disablephysgun )
	else
		CurrentEnt:SetMoveType(MOVETYPE_VPHYSICS)
		CurrentEnt.PhysgunDisabled = false
		CurrentEnt:SetUnFreezable( false )
	end
	CurrentPhys:Wake()
end

function TOOL:CreateUndo(constraint,undoname)
	if (constraint) then
		undo.Create(undoname)
		undo.AddEntity( constraint )
		undo.SetPlayer( self:GetOwner() )
		undo.Finish()
		self:GetOwner():AddCleanup( "constraints", constraint )
	end
end

function TOOL:UndoRepairToggle()
	for key,CurrentEnt in pairs(self.TaggedEnts) do
		if ( CurrentEnt and CurrentEnt:IsValid() ) then
			if !(CurrentEnt == Ent2 ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() && !CurrentEnt:GetParent():IsValid() ) then//parent?
					if ( CurrentEnt:GetPhysicsObjectCount() < 2 ) then //not a ragdoll
						if ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_WORLD ) then
							CurrentEnt:SetCollisionGroup( COLLISION_GROUP_NONE )
						elseif ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_NONE ) then
							CurrentEnt:SetCollisionGroup( COLLISION_GROUP_WORLD )
						end
						if ( speeddamp == 0 && angledamp == 0 ) then
							CurrentPhys:SetDamping( 5, 5 )
						elseif ( speeddamp == 5 && angledamp == 5 ) then
							CurrentPhys:SetDamping( 0, 0 )
						end
						CurrentPhys:Wake()
					end
				end
			end
		end
	end
	self.RepairTodo = false
end

function TOOL:DoConstraint(mode)
	self:SetStage(0)
	// Get information we're about to use
	local Ent1,  Ent2  = self:GetEnt(1),    self:GetEnt(2)

	if ( !Ent1:IsValid() || CLIENT ) then
		self:ClearObjects()
		return false//Something happened to original target, don't continue
	end
	// Get client's CVars
	local forcelimit 	= self:GetClientNumber( "forcelimit", 0 )
	local freeze		= util.tobool( self:GetClientNumber( "freeze", 1 ) )
	local nocollide		= self:GetClientNumber( "nocollide", 0 )
	local nocollideall	= util.tobool( self:GetClientNumber( "nocollideall", 0 ) )
	local torquelimit	= self:GetClientNumber( "torquelimit", 0 )
	local width			= self:GetClientNumber( "width", 1 )
	local friction		= self:GetClientNumber( "friction", 0 )
	local physdis		= util.tobool( self:GetClientNumber( "physdisable", 0 ) )
	local ShadowDisable = util.tobool( self:GetClientNumber( "ShadowDisable", 0 ) )
	local autorotate 	= util.tobool(self:GetClientNumber( "autorotate",1 ))
	local removal_nocollide 	= util.tobool(self:GetClientNumber( "removal_nocollide",1 ))
	local removal_weld 	= util.tobool(self:GetClientNumber( "removal_weld",1 ))
	local removal_axis 	= util.tobool(self:GetClientNumber( "removal_axis",1 ))
	local removal_ballsocket 	= util.tobool(self:GetClientNumber( "removal_ballsocket",1 ))
	local removal_advballsocket 	= util.tobool(self:GetClientNumber( "removal_advballsocket",1 ))
	local removal_slider 	= util.tobool(self:GetClientNumber( "removal_slider",1 ))
	local removal_parent 	= util.tobool(self:GetClientNumber( "removal_parent",1 ))
	local removal_other 	= util.tobool(self:GetClientNumber( "removal_other",1 ))
	local Bone1 = self:GetBone(1)
	local LPos1 = self:GetLocalPos(1)
	local Bone2 = nil
	local LPos2 = nil
	if ( Ent2 && (Ent2:IsValid() || Ent2:IsWorld()) ) then
		Bone2 = self:GetBone(2)
		LPos2 = self:GetLocalPos(2)
	end
	local Phys1 = self:GetPhys(1)
	
	local NumApp = 0
	

	for key,CurrentEnt in pairs(self.TaggedEnts) do
		if ( CurrentEnt and CurrentEnt:IsValid() ) then
			if !(CurrentEnt == Ent2 ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() && !CurrentEnt:GetParent():IsValid() ) then//parent?
					if ( CurrentEnt:GetPhysicsObjectCount() < 2 ) then //not a ragdoll
						if (  util.tobool( nocollide ) && (mode == 1 || mode == 3)) then // not weld/axis/ballsocket or single application
							local constraint = constraint.NoCollide(CurrentEnt, Ent2, 0, Bone2)
						end
						if ( mode == 1 ) then //Apply
							self:DoApply( CurrentEnt, Ent1, autorotate, nocollideall, ShadowDisable )
						elseif ( mode == 2 ) then //Rotate
							//self:SendMessage("Sorry, No entire contraption rotating... yet")
							//return false//TODO: Entire contrpation rotaton
						elseif ( mode == 3 ) then //move
							//self:SendMessage("Sorry, No entire contraption moving... yet")
							//return false//todo: entire contraption move/snap
						elseif ( mode == 4 ) then //weld
							local constr = constraint.Weld( CurrentEnt, Ent2, 0, Bone2, forcelimit,  util.tobool( nocollide ) )
							self:CreateUndo(constr,"Precision_Weld")
						elseif ( mode == 5 ) then //doaxis
							local constr = constraint.Axis( CurrentEnt, Ent2, Bone1, Bone2, LPos1, LPos2, forcelimit, torquelimit, friction, nocollide )
							self:CreateUndo(constr,"Precision_Axis")
						elseif ( mode == 6 ) then //ballsocket
							local constr = constraint.Ballsocket( CurrentEnt, Ent2, 0, Bone2, LPos2, forcelimit, torquelimit, nocollide )
							self:CreateUndo(constr,"Precision_Ballsocket")
						elseif ( mode == 7 ) then //adv ballsocket
							local constr = constraint.AdvBallsocket( CurrentEnt, Ent2, 0, Bone2, LPos1, LPos2, forcelimit, torquelimit, self:GetClientNumber( "XRotMin", -180 ), self:GetClientNumber( "YRotMin", -180 ), self:GetClientNumber( "ZRotMin", -180 ), self:GetClientNumber( "XRotMax", 180 ), self:GetClientNumber( "YRotMax", 180 ), self:GetClientNumber( "ZRotMax", 180 ), self:GetClientNumber( "XRotFric", 0 ), self:GetClientNumber( "YRotFric", 0 ), self:GetClientNumber( "ZRotFric", 0 ), self:GetClientNumber( "FreeMov", 0 ), nocollide )
							self:CreateUndo(constr,"Precision_Advanced_Ballsocket")
						elseif ( mode == 8 ) then //slider
							local constraint0 = constraint.Slider( CurrentEnt, Ent2, 0, Bone2, LPos1, LPos2, width )
							if (constraint0) then
								undo.Create("Precision_Slider")
								if ( self:GetClientNumber( "disablesliderfix" ) == 0 ) then
									local constraint2 = constraint.AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, 0, -180, -180, 0, 180, 180, 50, 0, 0, 1, 0 )
									if (constraint2) then
										undo.AddEntity( constraint2 )
									end
									local constraint3 = constraint.AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, -180, 0, -180, 180, 0, 180, 0, 50, 0, 1, 0 )
									if (constraint3) then
										undo.AddEntity( constraint3 )
									end
									local constraint4 = constraint.AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, -180, -180, 0, 180, 180, 0, 0, 0, 50, 1, 0 )
									if (constraint4) then
										undo.AddEntity( constraint4 )
									end
								end
								undo.AddEntity( constraint0 )
								undo.SetPlayer( self:GetOwner() )
								undo.Finish()
								self:GetOwner():AddCleanup( "constraints", constraint0 )
							end
						elseif ( mode == 9 ) then //Parent
							self:DoParent( CurrentEnt, Ent2 )
						elseif ( mode == 10 && !self.RepairTodo ) then//Repair spaz
							if ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_WORLD ) then
								CurrentEnt:SetCollisionGroup( COLLISION_GROUP_NONE )
							elseif ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_NONE ) then
								CurrentEnt:SetCollisionGroup( COLLISION_GROUP_WORLD )
							end
								//CurrentPhys:EnableGravity( !CurrentPhys:IsGravityEnabled() )//Can't disable gravity - sliders would go nuts and disappear.	
							local speeddamp,angledamp = CurrentPhys:GetDamping()
							if ( speeddamp == 0 && angledamp == 0 ) then
								CurrentPhys:SetDamping( 5, 5 )
							elseif ( speeddamp == 5 && angledamp == 5 ) then
								CurrentPhys:SetDamping( 0, 0 )
							end
							CurrentEnt:SetPos(CurrentEnt:GetPos())
							CurrentPhys:Wake()
						elseif ( mode == 11 ) then //Removal
							if ( CLIENT ) then return true end//? should probably be in more places
							if ( removal_nocollide ) then
								constraint.RemoveConstraints( CurrentEnt, "NoCollide" )
								CurrentPhys:EnableCollisions(true)
							end
							if ( removal_weld ) then
								constraint.RemoveConstraints( CurrentEnt, "Weld" )
							end
							if ( removal_axis ) then
								constraint.RemoveConstraints( CurrentEnt, "Axis" )
							end
							if ( removal_ballsocket ) then
								constraint.RemoveConstraints( CurrentEnt, "Ballsocket" )
							end
							if ( removal_advballsocket ) then
								constraint.RemoveConstraints( CurrentEnt, "AdvBallsocket" )
							end
							if ( removal_slider ) then
								constraint.RemoveConstraints( CurrentEnt, "Slider" )
							end
							if ( removal_parent) then
								if ( CurrentEnt:GetParent():IsValid() ) then
									self:UndoParent( CurrentEnt )
								end
							end
							if ( removal_other ) then
								constraint.RemoveConstraints( CurrentEnt, "Elastic" )
								constraint.RemoveConstraints( CurrentEnt, "Hydraulic" )
								constraint.RemoveConstraints( CurrentEnt, "Keepupright" )
								constraint.RemoveConstraints( CurrentEnt, "Motor" )
								constraint.RemoveConstraints( CurrentEnt, "Muscle" )
								constraint.RemoveConstraints( CurrentEnt, "Pulley" )
								constraint.RemoveConstraints( CurrentEnt, "Rope" )
								constraint.RemoveConstraints( CurrentEnt, "Winch" )
							end
						end
						if ( mode <= 8 ) then
							CurrentPhys:EnableMotion( !freeze )
							CurrentPhys:Wake()
						end
					end
				end
			end
		end
		NumApp = NumApp + 1
	end//Next
	if ( mode == 1 ) then
		self:SendMessage( NumApp .. " items targeted for apply." )
	elseif ( mode == 2 ) then
		self:SendMessage( NumApp .. " items targeted for rotate." )
	elseif ( mode == 3 ) then
		self:SendMessage( NumApp .. " items targeted for move." )
	elseif ( mode == 4 ) then
		self:SendMessage( NumApp .. " items targeted for weld." )
	elseif ( mode == 5 ) then
		self:SendMessage( NumApp .. " items targeted for axis." )
	elseif ( mode == 6 ) then
		self:SendMessage( NumApp .. " items targeted for ballsocket." )
	elseif ( mode == 7 ) then
		self:SendMessage( NumApp .. " items targeted for adv. ballsocket." )
	elseif ( mode == 8 ) then
		self:SendMessage( NumApp .. " items targeted for slider." )
	elseif ( mode == 9 ) then
		self:SendMessage( NumApp .. " items targeted for parenting." )
	elseif ( mode == 10 ) then
		self:SendMessage( NumApp .. " items targeted for repair." )
	elseif ( mode == 11 ) then
		self:SendMessage( NumApp .. " items targeted for constraint removal." )
	end
	
	
	if ( mode == 10 ) then
		self.RepairTodo = true
		timer.Simple( 1.0, function()
		self:ClearSelection()
		end)
	else
		self:ClearSelection()
	end
	// Clear the objects so we're ready to go again
	self:ClearObjects()
end

function TOOL:SendMessage( message )
	if ( self:GetClientNumber( "enablefeedback" ) == 0 ) then return end
	if ( self:GetClientNumber( "chatfeedback" ) == 1 ) then
		self:GetOwner():PrintMessage( HUD_PRINTTALK, "Tool: " .. message )
	else
		self:GetOwner():PrintMessage( HUD_PRINTCENTER, message )
	end
end

function TOOL:TargetValidity ( trace, Phys ) //TODO: Parented stuff should return 1
	if ( SERVER && (!util.IsValidPhysicsObject( trace.Entity, trace.PhysicsBone ) || !Phys:IsValid()) ) then
		local mode = self:GetClientNumber( "mode" )
		if ( trace.Entity:GetParent():IsValid() ) then
			return 2//Valid parent, but itself isn't
		else
			return 0//No valid phys
		end
	elseif ( trace.Entity:IsPlayer() ) then
		return 0// Don't attach players, or to players
	elseif ( trace.HitWorld ) then
		return 1// Only allow second click to be here...
	else
		return 3//Everything seems good
	end
end

function TOOL:StartRotate()
	local Ent = self:GetEnt(1)
	local Phys = self:GetPhys(1)
	local oldposu = Ent:GetPos()
	local oldangles = Ent:GetAngles()

	local function MoveUndo( Undo, Entity, oldposu, oldangles )
		if Entity:IsValid() then
			Entity:SetAngles( oldangles )
			Entity:SetPos( oldposu )
		end
	end
	
	if ( self:GetClientNumber( "rotateundo" )) then
		if SERVER then
			undo.Create("Precision_Rotate")
				undo.SetPlayer(self:GetOwner())
				undo.AddFunction( MoveUndo, Ent, oldposu, oldangles )
			undo.Finish()
		end
	end
	
	if IsValid( Phys ) then
		Phys:EnableMotion( false ) //else it drifts
	end
	
	local rotation = self:GetClientNumber( "rotation" )
	if ( rotation < 0.02 ) then rotation = 0.02 end
	self.axis = self:GetNormal(1)
	self.axisY = self.axis:Cross(Ent:GetUp())
	if self:WithinABit( self.axisY, Vector(0,0,0) ) then
		self.axisY = self.axis:Cross(Ent:GetForward())
	end
	self.axisZ = self.axisY:Cross(self.axis)
	self.realdegrees = 0
	self.lastdegrees = -((rotation/2) % rotation)
	self.realdegreesY = 0
	self.lastdegreesY = -((rotation/2) % rotation)
	self.realdegreesZ = 0
	self.lastdegreesZ = -((rotation/2) % rotation)
	self.OldPos = self:GetPos(1)//trace.HitPos
end

function TOOL:DoMove()
	// Get information we're about to use
	local Norm1, Norm2 = self:GetNormal(1),   self:GetNormal(2)
	local Phys1, Phys2 = self:GetPhys(1),     self:GetPhys(2)
	
	local Ang1, Ang2 = Norm1:Angle(), (Norm2 * -1):Angle()
	if self:GetClientNumber( "autorotate" ) == 1 then
		Ang2.p = (math.Round(Ang2.p/45))*45
		Ang2.r = (math.Round(Ang2.r/45))*45
		Ang2.y = (math.Round(Ang2.y/45))*45
		Norm2 = Ang2:Forward() * -1
	end


	local oldposu = self:GetEnt(1):GetPos()
	local oldangles = self:GetEnt(1):GetAngles()

	local function MoveUndo( Undo, Entity, oldposu, oldangles )
		if Entity:IsValid() then
			Entity:SetAngles( oldangles )
			Entity:SetPos( oldposu )
		end
	end
	if self:GetClientNumber( "moveundo" ) == 1 then
	undo.Create("Precision Move")
		undo.SetPlayer(self:GetOwner())
		undo.AddFunction( MoveUndo, self:GetEnt(1), oldposu, oldangles )
	undo.Finish()
	end

	local rotation = self:GetClientNumber( "rotation" )
	if ( rotation < 0.02 ) then rotation = 0.02 end
	if ( (self:GetClientNumber( "rotate" ) == 1 && mode != 1) || mode == 2) then//Set axies for rotation mode directions
		self.axis = Norm2
		self.axisY = self.axis:Cross(Vector(0,1,0))
		if self:WithinABit( self.axisY, Vector(0,0,0) ) then
			self.axisY = self.axis:Cross(Vector(0,0,1))
		end
		self.axisY:Normalize()
		self.axisZ = self.axisY:Cross(self.axis)
		self.axisZ:Normalize()
		self.realdegrees = 0
		self.lastdegrees = -((rotation/2) % rotation)
		self.realdegreesY = 0
		self.lastdegreesY = -((rotation/2) % rotation)
		self.realdegreesZ = 0
		self.lastdegreesZ = -((rotation/2) % rotation)
	else
		self.axis = Norm2
		self.axisY = self.axis:Cross(Vector(0,1,0))
		if self:WithinABit( self.axisY, Vector(0,0,0) ) then
			self.axisY = self.axis:Cross(Vector(0,0,1))
		end
		self.axisY:Normalize()
		self.axisZ = self.axisY:Cross(self.axis)
		self.axisZ:Normalize()
	end



	local TargetAngle = Phys1:AlignAngles( Ang1, Ang2 )//Get angle Phys1 would be at if difference between Ang1 and Ang2 was added


	if self:GetClientNumber( "autorotate" ) == 1 then
		TargetAngle.p = (math.Round(TargetAngle.p/45))*45
		TargetAngle.r = (math.Round(TargetAngle.r/45))*45
		TargetAngle.y = (math.Round(TargetAngle.y/45))*45
	end

	Phys1:SetAngles( TargetAngle )


	local NewOffset = math.Clamp( self:GetClientNumber( "offset" ), -5000, 5000 )
	local offsetpercent		= self:GetClientNumber( "offsetpercent" ) == 1
	if ( offsetpercent ) then
		local  Ent2  = self:GetEnt(2)
		local glower = Ent2:OBBMins()
		local gupper = Ent2:OBBMaxs()
		local height = math.abs(gupper.z - glower.z) -0.5
		if self:WithinABit(Norm2,Ent2:GetForward()) then
			height = math.abs(gupper.x - glower.x)-0.5
		elseif self:WithinABit(Norm2,Ent2:GetRight()) then
			height = math.abs(gupper.y - glower.y)-0.5
		end
		NewOffset = NewOffset / 100
		NewOffset = NewOffset * height
	end
	Norm2 = Norm2 * (-0.0625 + NewOffset)
	local TargetPos = self:GetPos(2) + (Phys1:GetPos() - self:GetPos(1)) + (Norm2)
	//self:SetPos(2)

	// Set the position

	Phys1:SetPos( TargetPos )
	Phys1:EnableMotion( false )

	// Wake up the physics object so that the entity updates
	Phys1:Wake()
end

function TOOL:ToggleColor( CurrentEnt )
	color = CurrentEnt:GetColor()
	color["a"] = color["a"] - 128
	if ( color["a"] < 0 ) then
		color["a"] = color["a"] + 256
	end
	color["r"] = color["r"] - 128
	if ( color["r"] < 0 ) then
		color["r"] = color["r"] + 256
	end
	color["g"] = color["g"] - 128
	if ( color["g"] < 0 ) then
		color["g"] = color["g"] + 256
	end
	color["b"] = color["b"] - 128
	if ( color["b"] < 0 ) then
		color["b"] = color["b"] + 256
	end
	CurrentEnt:SetColor( color )
	if ( color["a"] == 255 ) then
		CurrentEnt:SetRenderMode( 0 )
	else
		CurrentEnt:SetRenderMode( 1 )
	end
end

function TOOL:ClearSelection()
	if ( self.RepairTodo ) then
		self:UndoRepairToggle()
	end
	if ( self.TaggedEnts ) then
		local color
		for key,CurrentEnt in pairs(self.TaggedEnts) do
			if ( CurrentEnt and CurrentEnt:IsValid() ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() ) then
					self:ToggleColor(CurrentEnt)
				end
			end
		end
	end
	self.TaggedEnts = {}
end

function TOOL:SelectEnts(StartEnt, AllConnected)
	self:ClearSelection()
	if ( CLIENT ) then return end
	local color
	if ( AllConnected == 1 ) then
		local NumApp = 0
		EntsTab = {}
		ConstsTab = {}
		GetAllEnts(StartEnt, self.TaggedEnts, EntsTab, ConstsTab)
		for key,CurrentEnt in pairs(self.TaggedEnts) do
			if ( CurrentEnt and CurrentEnt:IsValid() ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() ) then
					self:ToggleColor(CurrentEnt)
				end
			end
			NumApp = NumApp + 1
		end
		self:SendMessage( NumApp .. " objects selected." )
	else
		if ( StartEnt and StartEnt:IsValid() ) then
			local CurrentPhys = StartEnt:GetPhysicsObject()
			if ( CurrentPhys:IsValid() ) then
				table.insert(self.TaggedEnts, StartEnt)
				self:ToggleColor(StartEnt)
			end
		end
	end
	
end

function TOOL:LeftClick( trace )
	local stage = self:GetStage()//0 = started, 1 = moving/second target, 2 = rotation?
	local mode = self:GetClientNumber( "mode" )
	local moving = ( mode == 3 || (self:GetClientNumber( "move" ) == 1 && mode >= 3 && mode <= 8 ) )
	local rotating = ( self:GetClientNumber( "rotate" ) == 1 )
	local Phys = trace.Entity:GetPhysicsObjectNum( trace.PhysicsBone )

	
	if ( stage == 0 ) then//first click - choose a target.
		if ( self:TargetValidity(trace, Phys) <= 1 ) then
			return false//No phys or hit world
		end
		self:SetObject( 1, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal )
		
		if (self:GetClientNumber( "entirecontrap" ) == 1 || mode == 10 ) then
			self:SelectEnts(trace.Entity,1)
		else
			self:SelectEnts(trace.Entity,0)
		end
		if ( mode == 1 || mode == 10 || mode == 11 ) then //Don't care about stage, always apply.
			self:DoConstraint(mode)
		else
			if ( mode == 9 ) then
				self:SetStage(1)
			else
				if ( moving ) then//Moving
					self:StartGhostEntity( trace.Entity )
					self:SetStage(1)
				elseif ( mode == 2 ) then//Straight to rotate
					self:StartRotate()
					self:SetStage(2)
				else
					self:SetStage(1)
				end
			end
		end
	elseif ( stage == 1 ) then//Second click
		self:SetObject( 2, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal )
		
		if ( self:GetEnt(1) == self:GetEnt(2) ) then
			SavedPos = self:GetPos(2)
		end
		if ( mode == 9 ) then
			self:DoConstraint(mode)
		else
			if ( moving ) then
				if ( CLIENT ) then
					self:ReleaseGhostEntity()
					return true
				end
				if ( SERVER && !game.SinglePlayer() ) then
					self:ReleaseGhostEntity()
					//return true
				end
				self:DoMove()
			end
			if ( rotating ) then
				self:StartRotate()
				self:SetStage(2)
			else
				self:DoConstraint(mode)
			end
		end
	elseif ( stage == 2 ) then//Done rotate
		self:DoConstraint(mode)
	end
	return true
end

function TOOL:WithinABit( v1, v2 )
	local tol = 0.1
	local da = v1.x-v2.x
	local db = v1.y-v2.y
	local dc = v1.z-v2.z
	if da < tol && da > -tol && db < tol && db > -tol && dc < tol && dc > -tol then
		return true
	else
		da = v1.x+v2.x
		db = v1.y+v2.y
		dc = v1.z+v2.z
		if da < tol && da > -tol && db < tol && db > -tol && dc < tol && dc > -tol then
			return true
		else
			return false
		end
	end
end

if ( SERVER ) then
	
	function GetAllEnts( Ent, OrderedEntList, EntsTab, ConstsTab )
		if ( Ent and Ent:IsValid() ) and ( !EntsTab[ Ent:EntIndex() ] ) then
			EntsTab[ Ent:EntIndex() ] = Ent
			table.insert(OrderedEntList, Ent)
			if ( !constraint.HasConstraints( Ent ) ) then return OrderedEntList end
			for key, ConstraintEntity in pairs( Ent.Constraints ) do
				if ( !ConstsTab[ ConstraintEntity ] ) then
					ConstsTab[ ConstraintEntity ] = true
					local ConstTable = ConstraintEntity:GetTable()
					for i=1, 6 do
						local e = ConstTable[ "Ent"..i ]
						if ( e and e:IsValid() ) and ( !EntsTab[ e:EntIndex() ] ) then
							GetAllEnts( e, OrderedEntList, EntsTab, ConstsTab )
						end
					end
				end
			end
		end
		return OrderedEntList
	end
	
	function GetAllConstraints( EntsTab )
		local ConstsTab = {}
		for key, Ent in pairs( EntsTab ) do
			if ( Ent and Ent:IsValid() ) then
				local MyTable = constraint.GetTable( Ent )
				for key, Constraint in pairs( MyTable ) do
					if ( !ConstsTab[ Constraint.Constraint ] ) then
						ConstsTab[ Constraint.Constraint ] = Constraint
					end
				end
			end
		end
		return ConstsTab
	end
end

function TOOL:UpdateCustomGhost( ghost, player, offset )
	
	// Ghost is identically buggy to that of easyweld...  welding two frozen props and two unfrozen props yields different ghosts even if identical allignment

	if (ghost == nil) then return end
	if (!ghost:IsValid()) then ghost = nil return end

	local tr = util.GetPlayerTrace( player, player:GetAimVector() )
	local trace = util.TraceLine( tr )
	if (!trace.Hit) then return end

	local Ang1, Ang2 = self:GetNormal(1):Angle(), (trace.HitNormal * -1):Angle()
	local TargetAngle = self:GetEnt(1):AlignAngles( Ang1, Ang2 )

	self.GhostEntity:SetPos( self:GetEnt(1):GetPos() )
	
	if self:GetClientNumber( "autorotate" ) == 1 then
		TargetAngle.p = (math.Round(TargetAngle.p/45))*45
		TargetAngle.r = (math.Round(TargetAngle.r/45))*45
		TargetAngle.y = (math.Round(TargetAngle.y/45))*45
	end
	self.GhostEntity:SetAngles( TargetAngle )

	local TraceNormal = trace.HitNormal

	local offsetpercent		= self:GetClientNumber( "offsetpercent" ) == 1
	local NewOffset = offset
	if ( offsetpercent ) then
		local glower = trace.Entity:OBBMins()
		local gupper = trace.Entity:OBBMaxs()
		local height = math.abs(gupper.z - glower.z) -0.5
		if self:WithinABit(TraceNormal,trace.Entity:GetForward()) then
			height = math.abs(gupper.x - glower.x) -0.5
		elseif self:WithinABit(TraceNormal,trace.Entity:GetRight()) then
			height = math.abs(gupper.y - glower.y) -0.5
		end
		NewOffset = NewOffset / 100
		NewOffset = NewOffset * height
	end

	local TranslatedPos = ghost:LocalToWorld( self:GetLocalPos(1) )
	local TargetPos = trace.HitPos + (self:GetEnt(1):GetPos() - TranslatedPos) + (TraceNormal*NewOffset)

	self.GhostEntity:SetPos( TargetPos )
end


function TOOL:Think()
	//if CLIENT then return end
	local pl = self:GetOwner()
	local wep = pl:GetActiveWeapon()
	if not wep:IsValid() or wep:GetClass() != "gmod_tool" or pl:GetInfo("gmod_toolmode") != "precision" then return end
		
	if (self:NumObjects() < 1) then return end
	local Ent1 = self:GetEnt(1)
	if ( SERVER ) then
		if ( !Ent1:IsValid() ) then
			self:ClearObjects()
			return
		end
	end
	local mode = self:GetClientNumber( "mode" )

	if self:NumObjects() == 1 && mode != 2 then
		if ( (self:GetClientNumber( "move" ) == 1 && mode >= 3) || mode == 3 ) then
			if ( mode <= 8 ) then//no move = no ghost in parent mode
				local offset = math.Clamp( self:GetClientNumber( "offset" ), -5000, 5000 )
				self:UpdateCustomGhost( self.GhostEntity, self:GetOwner(), offset )
			end
		end
	else
		local rotate = (self:GetClientNumber( "rotate" ) == 1 && mode != 1) || mode == 2
		if ( SERVER && rotate && mode <= 8 ) then
			local offset = math.Clamp( self:GetClientNumber( "offset" ), -5000, 5000 )

			local Phys1 = self:GetPhys(1)

			local cmd = self:GetOwner():GetCurrentCommand()

			local rotation		= self:GetClientNumber( "rotation" )
			if ( rotation < 0.02 ) then rotation = 0.02 end
			local degrees = cmd:GetMouseX() * 0.02

			local newdegrees = 0
			local changedegrees = 0

			local angle = 0
			if( self:GetOwner():KeyDown( IN_RELOAD ) ) then
				self.realdegreesY = self.realdegreesY + degrees
				newdegrees =  self.realdegreesY - ((self.realdegreesY + (rotation/2)) % rotation)
				changedegrees = self.lastdegreesY - newdegrees
				self.lastdegreesY = newdegrees
				angle = Phys1:RotateAroundAxis( self.axisY , changedegrees )
			elseif( self:GetOwner():KeyDown( IN_ATTACK2 ) ) then
				self.realdegreesZ = self.realdegreesZ + degrees
				newdegrees =  self.realdegreesZ - ((self.realdegreesZ + (rotation/2)) % rotation)
				changedegrees = self.lastdegreesZ - newdegrees
				self.lastdegreesZ = newdegrees
				angle = Phys1:RotateAroundAxis( self.axisZ , changedegrees )
			else
				self.realdegrees = self.realdegrees + degrees
				newdegrees =  self.realdegrees - ((self.realdegrees + (rotation/2)) % rotation)
				changedegrees = self.lastdegrees - newdegrees
				self.lastdegrees = newdegrees
				angle = Phys1:RotateAroundAxis( self.axis , changedegrees )
			end
			Phys1:SetAngles( angle )

			if ( ( self:GetClientNumber( "move" ) == 1 && mode >= 3) || mode == 3 ) then
				local WPos2 = self:GetPos(2)
				local Ent2 = self:GetEnt(2)
				// Move so spots join up
				local Norm2 = self:GetNormal(2)

				local NewOffset = offset
				local offsetpercent	= self:GetClientNumber( "offsetpercent" ) == 1
				if ( offsetpercent ) then
					local glower = Ent2:OBBMins()
					local gupper = Ent2:OBBMaxs()
					local height = math.abs(gupper.z - glower.z) -0.5
					if self:WithinABit(Norm2,Ent2:GetForward()) then
						height = math.abs(gupper.x - glower.x) -0.5
					elseif self:WithinABit(Norm2,Ent2:GetRight()) then
						height = math.abs(gupper.y - glower.y) -0.5
					end
					NewOffset = NewOffset / 100
					NewOffset = NewOffset * height
				end

				Norm2 = Norm2 * (-0.0625 + NewOffset)
				local TargetPos = Vector(0,0,0)
				if ( self:GetEnt(1) == self:GetEnt(2) ) then
	//////////////////////////////////////////
					TargetPos = SavedPos + (Phys1:GetPos() - self:GetPos(1)) + (Norm2)
				else
					TargetPos = WPos2 + (Phys1:GetPos() - self:GetPos(1)) + (Norm2)
				end
				Phys1:SetPos( TargetPos )
			else
				// Move so rotating on axis

				local TargetPos = (Phys1:GetPos() - self:GetPos(1)) + self.OldPos
				Phys1:SetPos( TargetPos )
			end
			Phys1:Wake()
		end
	end
end

function TOOL:Nudge( trace, direction )
	if (!trace.Entity:IsValid() || trace.Entity:IsPlayer() ) then return false end
	local Phys1 = trace.Entity:GetPhysicsObjectNum( trace.PhysicsBone )
	local offsetpercent		= self:GetClientNumber( "nudgepercent" ) == 1
	local offset		= self:GetClientNumber( "nudge", 100 )
	local max = 8192
	if ( offsetpercent != 1 ) then
		if ( offset > max ) then
			offset = max
		elseif ( offset < -max ) then
			offset = -max
		end
	end
	//if ( offset == 0 ) then offset = 1 end
	local NewOffset = offset
	if ( offsetpercent ) then
		local glower = trace.Entity:OBBMins()
		local gupper = trace.Entity:OBBMaxs()
		local height = math.abs(gupper.z - glower.z) -0.5
		if self:WithinABit(trace.HitNormal,trace.Entity:GetForward()) then
			height = math.abs(gupper.x - glower.x)-0.5
		elseif self:WithinABit(trace.HitNormal,trace.Entity:GetRight()) then
			height = math.abs(gupper.y - glower.y)-0.5
		end
		NewOffset = NewOffset / 100
		local cap = math.floor(max / height)//No more than max units.
		if ( NewOffset > cap ) then
			NewOffset = cap
		elseif ( NewOffset < -cap ) then
			NewOffset = -cap
		end
		NewOffset = NewOffset * height
	end

	if ( self:GetClientNumber( "entirecontrap" ) == 1 ) then
		local NumApp = 0
		local TargetEnts = {}
		local EntsTab = {}
		local ConstsTab = {}
		GetAllEnts(trace.Entity, TargetEnts, EntsTab, ConstsTab)
		for key,CurrentEnt in pairs(TargetEnts) do
			if ( CurrentEnt and CurrentEnt:IsValid() ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() ) then

					/*if ( self:GetClientNumber( "nudgeundo" ) == 1 ) then
						local oldpos = CurrentPhys:GetPos()
						local function NudgeUndo( Undo, Entity, oldpos )
							if CurrentEnt:IsValid() then
								CurrentEnt:SetPos( oldpos )
							end
						end
						undo.Create("Nrecision Nudge")
							undo.SetPlayer(self:GetOwner())
							undo.AddFunction( NudgeUndo, CurrentEnt, oldpos )
						undo.Finish()
					end*/// todo: all in 1 undo for mass nudging

					local TargetPos = CurrentPhys:GetPos() + trace.HitNormal * NewOffset * direction
					CurrentPhys:SetPos( TargetPos )
					CurrentPhys:Wake()
					if (CurrentEnt:GetMoveType() == 0 ) then //phys disabled, so move manually
						CurrentEnt:SetPos( TargetPos )
					end

				end
			end
			NumApp = NumApp + 1
		end
		if ( direction == -1 ) then
			self:SendMessage( NumApp .. " items pushed." )
		elseif ( direction == 1 ) then
			self:SendMessage( NumApp .. " items pulled." )
		else
			self:SendMessage( NumApp .. " items nudged." )
		end
	else
		if ( self:GetClientNumber( "nudgeundo" ) == 1 ) then
			local oldpos = Phys1:GetPos()
			local function NudgeUndo( Undo, Entity, oldpos )
				if trace.Entity:IsValid() then
					trace.Entity:SetPos( oldpos )
				end
			end
			undo.Create("Precision PushPull")
				undo.SetPlayer(self:GetOwner())
				undo.AddFunction( NudgeUndo, trace.Entity, oldpos )
			undo.Finish()
		end
		local TargetPos = Phys1:GetPos() + trace.HitNormal * NewOffset * direction
		Phys1:SetPos( TargetPos )
		Phys1:Wake()
		if ( trace.Entity:GetMoveType() == 0 ) then
			trace.Entity:SetPos( TargetPos )
		end
		if ( direction == -1 ) then
			self:SendMessage( "target pushed." )
		elseif ( direction == 1 ) then
			self:SendMessage( "target pulled." )
		else
			self:SendMessage( "target nudged." )
		end
	end
	return true
end

function TOOL:RightClick( trace )
	local rotate = self:GetClientNumber( "rotate" ) == 1
	local mode = self:GetClientNumber( "mode" )
	if ( (mode == 2 && self:NumObjects() == 1) || (rotate && self:NumObjects() == 2 ) ) then
		if ( CLIENT ) then return false end
	else
		if ( CLIENT ) then return true end
		return self:Nudge( trace, -1 )
	end
end

function TOOL:Reload( trace )
	local rotate = self:GetClientNumber( "rotate" ) == 1
	local mode = self:GetClientNumber( "mode" )
	if ( (mode == 2 && self:NumObjects() == 1) || (rotate && self:NumObjects() == 2 ) ) then
		if ( CLIENT ) then return false end
	else
		if ( CLIENT ) then return true end
		return self:Nudge( trace, 1 )
	end
end

if CLIENT then

	language.Add( "Tool.precision.name", "Precision Tool 0.98e" )
	language.Add( "Tool.precision.desc", "Accurately moves/constrains objects" )
	language.Add( "Tool.precision.0", "Primary: Move/Apply | Secondary: Push | Reload: Pull" )
	language.Add( "Tool.precision.1", "Target the second item. If enabled, this will move the first item.  (Swap weps to cancel)" )
	language.Add( "Tool.precision.2", "Rotate enabled: Turn left and right to rotate the object (Hold Reload or Secondary for other rotation directions!)" )


	language.Add("Undone.precision", "Undone Precision Constraint")
	language.Add("Undone.precision.nudge", "Undone Precision PushPull")
	language.Add("Undone.precision.rotate", "Undone Precision Rotate")
	language.Add("Undone.precision.move", "Undone Precision Move")
	language.Add("Undone.precision.weld", "Undone Precision Weld")
	language.Add("Undone.precision.axis", "Undone Precision Axis")
	language.Add("Undone.precision.ballsocket", "Undone Precision Ballsocket")
	language.Add("Undone.precision.advanced.ballsocket", "Undone Precision Advanced Ballsocket")
	language.Add("Undone.precision.slider", "Undone Precision Slider")

	local showgenmenu = 0//Seems to hide often, probably for the best

	local function AddDefControls( Panel )
		Panel:ClearControls()

		Panel:AddControl("ComboBox",
		{
			Label = "#Presets",
			MenuButton = 1,
			Folder = "precision",
			Options = {},
			CVars =
			{
				[0] = "precision_offset",
				[1] = "precision_forcelimit",
				[2] = "precision_freeze",
				[3] = "precision_nocollide",
				[4] = "precision_nocollideall",
				[5] = "precision_rotation",
				[6] = "precision_rotate",
				[7] = "precision_torquelimit",
				[8] = "precision_friction",
				[9] = "precision_mode",
				[10] = "precision_width",
				[11] = "precision_offsetpercent",
				[12] = "precision_removal",
				[13] = "precision_move",
				[14] = "precision_physdisable",
				[15] = "precision_advballsocket",
				[16] = "precision_XRotMin",
				[17] = "precision_XRotMax",
				[18] = "precision_YRotMin",
				[19] = "precision_YRotMax",
				[20] = "precision_ZRotMin",
				[21] = "precision_ZRotMax",
				[22] = "precision_XRotFric",
				[23] = "precision_YRotFric",
				[24] = "precision_ZRotFric",
				[25] = "precision_FreeMov",
				[26] = "precision_ShadowDisable",
				[27] = "precision_allowphysgun",
				[28] = "precision_autorotate",
				[29] = "precision_massmode",
				[30] = "precision_nudge",
				[31] = "precision_nudgepercent",
				[32] = "precision_disablesliderfix"
			}
		})

		//Panel:AddControl( "Label", { Text = "Secondary attack pushes, Reload pulls by this amount:", Description	= "Phx 1x is 47.45, Small tiled cube is 11.8625 and thin is 3 exact units" }  )
		Panel:AddControl( "Slider",  { Label	= "Push/Pull Amount",
					Type	= "Float",
					Min		= 1,
					Max		= 100,
					Command = "precision_nudge",
					Description = "Distance to push/pull props with altfire/reload"}	 ):SetDecimals( 4 )


		Panel:AddControl( "Checkbox", { Label = "Push/Pull as Percent (%) of target's depth", Command = "precision_nudgepercent", Description = "Unchecked = Exact units, Checked = takes % of width from target prop when pushing/pulling" } )


		local user = LocalPlayer():GetInfoNum( "precision_user", 0 )
		local mode = LocalPlayer():GetInfoNum( "precision_mode", 0 )
		//Panel:AddControl( "Label", { Text = "Primary attack uses the tool's main mode.", Description	= "Select a mode and configure the options, be sure to try new things out!" }  )

		local list = vgui.Create("DListView")

		//17 per item + 16 for title
		local height = 203 //All 11 shown
		if ( user < 2 ) then
			height = 135 //7 shown
		elseif ( user < 3 ) then
			height = 170 //9 shown
		end
		

		list:SetSize(30,height)
		//list:SizeToContents()
		list:AddColumn("Tool Mode")
		list:SetMultiSelect(false)
		function list:OnRowSelected(LineID, line)
			if not (mode == LineID) then
				RunConsoleCommand("precision_setmode", LineID)
			end
		end

		if ( mode == 1 ) then
			list:AddLine(" 1 ->Apply<- (Directly apply settings to target)")
		else
			list:AddLine(" 1   Apply   (Directly apply settings to target)")
		end
		if ( mode == 2 ) then
			list:AddLine(" 2 ->Rotate<- (Turn an object without moving it)")
		else
			list:AddLine(" 2   Rotate   (Turn an object without moving it)")
		end
		if ( mode == 3 ) then
			list:AddLine(" 3 ->Move<- (Snap objects together - Great for building!)")
		else
			list:AddLine(" 3   Move   (Snap objects together - Great for building!)")
		end
		if ( mode == 4 ) then
			list:AddLine(" 4 ->Weld<-")
		else
			list:AddLine(" 4   Weld")
		end
		if ( mode == 5 ) then
			list:AddLine(" 5 ->Axis<-")
		else
			list:AddLine(" 5   Axis")
		end
		if ( mode == 6 ) then
			list:AddLine(" 6 ->Ballsocket<-")
		else
			list:AddLine(" 6   Ballsocket")
		end
		if ( user >= 2 ) then
			if ( mode == 7 ) then
				list:AddLine(" 7 ->Adv Ballsocket<-")
			else
				list:AddLine(" 7   Adv Ballsocket")
			end
			if ( mode == 8 ) then
				list:AddLine(" 8 ->Slider<-")
			else
				list:AddLine(" 8   Slider")
			end
		end
		if ( user >= 3 ) then
			if ( mode == 9 ) then
				list:AddLine(" 9 ->Parent<- (Like a solid weld, but without object collision)")
			else
				list:AddLine(" 9   Parent   (Like a solid weld, but without object collision)")
			end
			if ( mode == 10 ) then
				list:AddLine("10 ->Repair<- (Attempts to fix a flailing contraption)")
			else
				list:AddLine("10   Repair   (Attempts to fix a flailing contraption)")
			end
		end
		if ( mode == 11 ) then
			list:AddLine("11 ->Removal<- (Undoes constraints from target)")
		else
			list:AddLine("11   Removal   (Undoes constraints from target)")
		end
		list:SortByColumn(1)
		Panel:AddItem(list)

		if ( mode >= 4 && mode <= 8 ) then
			Panel:AddControl( "Checkbox", { Label = "Move Target? ('Easy' constraint mode)", Command = "precision_move", Description = "Uncheck this to apply the constraint without altering positions." } )
		end
		if (  mode >= 3 && mode <= 8 ) then
			Panel:AddControl( "Checkbox", { Label = "Rotate Target? (Rotation after moving)", Command = "precision_rotate", Description = "Uncheck this to remove the extra click for rotation. Handy for speed building." } )
			//Panel:AddControl( "Label", { Text = "This is the distance from touching of the targeted props after moving:", Description	= "Use 0 mostly, % takes the second prop's width." }  )
			Panel:AddControl( "Slider",  { Label	= "Snap Distance",
					Type	= "Float",
					Min		= 0,
					Max		= 10,
					Command = "precision_offset",
					Description = "Distance offset between joined props.  Type in negative to inset when moving."}	 )
			Panel:AddControl( "Checkbox", { Label = "Snap distance as Percent (%) of target's depth", Command = "precision_offsetpercent", Description = "Unchecked = Exact units, Checked = takes % of width from second prop" } )
		end
		if ( mode >= 2 && mode <= 8 ) then
			Panel:AddControl( "Slider",  { Label	= "Rotation Snap (Degrees)",
					Type	= "Float",
					Min		= 0.02,
					Max		= 90,
					Command = "precision_rotation",
					Description = "Rotation rotates by this amount at a time. No more guesswork. Min: 0.02 degrees "}	 ):SetDecimals( 4 )
		end
		if ( mode <= 8 ) then
			Panel:AddControl( "Checkbox", { Label = "Freeze Target", Command = "precision_freeze", Description = "Freeze props when this tool is used" } )

			if ( mode >= 3 && mode <= 8 ) then
				Panel:AddControl( "Checkbox", { Label = "No Collide Targets", Command = "precision_nocollide", Description = "Nocollide pairs of props when this tool is used. Note: No current way to remove this constraint when used alone."  } )
			end
		end

		if ( user >= 2 || mode == 1 ) then
			if ( (mode >= 3 && mode <= 8) || mode == 1 ) then
				Panel:AddControl( "Checkbox", { Label = "Auto-align to world (nearest 45 degrees)", Command = "precision_autorotate", Description = "Rotates to the nearest world axis (similar to holding sprint and use with physgun)"  } )
			end

			if ( mode == 1 ) then
				Panel:AddControl( "Checkbox", { Label = "Disable target shadow", Command = "precision_ShadowDisable", Description = "Disables shadows cast from the prop"  } )
			end
		end

		if ( user >= 3 ) then
			if ( mode == 1 ) then //apply
				Panel:AddControl( "Checkbox", { Label = "Only Collide with Player", Command = "precision_nocollideall", Description = "Nocollides the first prop to everything and the world (except players collide with it). Warning: don't let it fall away through the world."  } )
				Panel:AddControl( "Checkbox", { Label = "Disable Physics on object", Command = "precision_physdisable", Description = "Disables physics on the first prop (gravity, being shot etc won't effect it)"  } )
				Panel:AddControl( "Checkbox", { Label = "Adv: Allow Physgun on PhysDisable objects", Command = "precision_allowphysgun", Description = "Disabled to stop accidents, use if you want to be able to manually move props after phyics disabling them (may break clipboxes)."  } )
				
				//Panel:AddControl( "Checkbox", { Label = "Drag", Command = "precision_drag", Description = ""  } )
			end
			if ( mode == 9 ) then //parent
				Panel:AddControl( "Checkbox", { Label = "Adv: Allow Physgun on Parented objects", Command = "precision_allowphysgun", Description = "Disabled to stop accidents, use this if you want to play with the parenting hierarchy etc."  } )
			end
		end
		if ( user >= 2 ) then
			if ( mode != 2 && mode != 3 && mode != 10 ) then //todo: entire contrap move/rotate support
				Panel:AddControl( "Checkbox", { Label = "Entire Contraption! (Everything connected to target)", Command = "precision_entirecontrap", Description = "For mass constraining or removal or nudging or applying of things. Yay generic."  } )
			end
		end

		if ( user >= 2 ) then
			if ( (mode >= 4 && mode <= 7) ) then //breakable constraint
				Panel:AddControl( "Slider",  { Label	= "Force Breakpoint",
						Type	= "Float",
						Min		= 0.0,
						Max		= 5000,
						Command = "precision_forcelimit",
						Description = "Applies to most constraint modes" }	 )
			end


			if ( mode == 5 || mode == 6 || mode == 7 ) then //axis or ballsocket
				Panel:AddControl( "Slider",  { Label	= "Torque Breakpoint",
						Type	= "Float",
						Min		= 0.0,
						Max		= 5000,
						Command = "precision_torquelimit",
						Description = "Breakpoint of turning/rotational force"}	 )
			end
		end

		if ( mode == 5 ) then //axis
			Panel:AddControl( "Slider",  { Label	= "Axis Friction",
					Type	= "Float",
					Min		= 0.0,
					Max		= 100,
					Command = "precision_friction",
					Description = "Turning resistance, this is best at 0 in most cases to conserve energy"}	 )
		end

		if ( mode ==7 ) then //adv ballsocket
			Panel:AddControl( "Slider",  { Label	= "X Rotation Minimum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_XRotMin",
					Description = "Rotation minimum of advanced ballsocket in X axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "X Rotation Maximum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_XRotMax",
					Description = "Rotation maximum of advanced ballsocket in X axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Y Rotation Minimum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_YRotMin",
					Description = "Rotation minimum of advanced ballsocket in Y axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Y Rotation Maximum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_YRotMax",
					Description = "Rotation maximum of advanced ballsocket in Y axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Z Rotation Minimum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_ZRotMin",
					Description = "Rotation minimum of advanced ballsocket in Z axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Z Rotation Maximum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_ZRotMax",
					Description = "Rotation maximum of advanced ballsocket in Z axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "X Rotation Friction",
					Type	= "Float",
					Min		= 0,
					Max		= 100,
					Command = "precision_XRotFric",
					Description = "Rotation friction of advanced ballsocket in X axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Y Rotation Friction",
					Type	= "Float",
					Min		= 0,
					Max		= 100,
					Command = "precision_YRotFric",
					Description = "Rotation friction of advanced ballsocket in Y axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Z Rotation Friction",
					Type	= "Float",
					Min		= 0,
					Max		= 100,
					Command = "precision_ZRotFric",
					Description = "Rotation friction of advanced ballsocket in Z axis"}	 )

			Panel:AddControl( "Checkbox", { Label = "Free Movement", Command = "precision_FreeMov", Description = "Only lock relative rotation, not position?"  } )
		end

		if ( mode == 8 ) then //slider
			Panel:AddControl( "Slider",  { Label	= "Slider Width",
					Type	= "Float",
					Min		= 0.0,
					Max		= 10,
					Command = "precision_width",
					Description = "Width of the slider black line (0 = invisible)"}	 )

			Panel:AddControl( "Checkbox", { Label = "Turn Off Minor Slider Stabilisation", Command = "precision_disablesliderfix", Description = "Fix being separate X/Y/Z advanced ballsocket locks between the props.  This stops most spaz caused by rotation, but not spaz caused by displacement." } )
			Panel:AddControl( "Label", { Text = "Stabilisation is separate X/Y/Z adv. ballsockets; it makes it far less prone to rotation triggered spaz, but the difference is only noticeable sometimes as it's still just as prone to spaz caused by drifting.", Description	= "Due to lack of working descriptions at time of coding" }  )
		end

		if ( mode == 9 ) then //parent
			Panel:AddControl( "Label", { Text = "Parenting Notes:", Description	= "Due to lack of working descriptions at time of coding" }  )
			Panel:AddControl( "Label", { Text = "Parenting objects is most similar to a very strong weld, but it stops most interaction on the first object when you attach it to the second.  Players can walk on it, but it will fall through players.  It will not collide with objects or the world.  It will also not cause any extra physics lag/spaz.  Try it out on a test object, and decide if it's useful to you!", Description	= "Due to lack of working descriptions at time of coding" }  )

			Panel:AddControl( "Label", { Text = "Parented objects are most useful for: Adding detail to moving objects without creating extra physics lag.  Things like houses that you want to move (though you can only safely walk on parented objects when they are still.)", Description	= "Due to lack of working descriptions at time of coding" }  )

			Panel:AddControl( "Label", { Text = "Possible issues:  Remove constraints first to avoid spaz. Duplicating or such may cause the collision model to become separated.  Best to test it if in doubt.", Description	= "Why must labels cause menu flicker? D:" }  )
		end
		
		if ( mode == 10 ) then //repair
			Panel:AddControl( "Label", { Text = "Repair mode", Description	= "" }  )
			Panel:AddControl( "Label", { Text = "Usage: When a contraption is going crazy, colliding, making rubbing noises.", Description	= "" }  )
			Panel:AddControl( "Label", { Text = "What it does: Temporarily toggles collisions, allowing things that are bent out of shape to pop back.", Description	= "" }  )
			Panel:AddControl( "Label", { Text = "Warning: No guarantees.  This may turn things inside-out or make things worse depending on the situation.", Description	= "" }  )
		end
		if ( mode == 11 ) then //removal
			Panel:AddControl( "Label", { Text = "This mode will remove:", Description	= "" }  )
			Panel:AddControl( "Checkbox", { Label = "Nocollide", Command = "precision_removal_nocollide", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Weld", Command = "precision_removal_weld", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Axis", Command = "precision_removal_axis", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Ballsocket", Command = "precision_removal_ballsocket", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Adv. Ballsocket", Command = "precision_removal_advballsocket", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Slider", Command = "precision_removal_slider", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Parent", Command = "precision_removal_parent", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Other", Command = "precision_removal_other", Description = "" } )
			Panel:AddControl( "Label", { Text = "(Other = Rope/slider variants like winch/hydraulic, also motor/keepupright)", Description	= "" }  )
			Panel:AddControl( "Button", { Label = "Select All", Command = "precision_removal_all", Description = ""  } )
			Panel:AddControl( "Button", { Label = "Select None", Command = "precision_removal_none", Description = ""  } )

		end
		if ( showgenmenu == 1 ) then
			Panel:AddControl( "Button", { Label = "\\/ General Tool Options \\/", Command = "precision_generalmenu", Description = "Collapse menu"  } )




		local params = {Label = "User Level",Description = "Shows options appropriate to user experience level", MenuButton = "0", Height = 67, Options = {}}
		if ( user == 1 ) then
			params.Options[" 1 ->Normal<-"] = { precision_setuser = "1" }
		else
			params.Options[" 1   Normal"] = { precision_setuser = "1" }
		end
		if ( user == 2 ) then
			params.Options[" 2 ->Advanced<-"] = { precision_setuser = "2" }
		else
			params.Options[" 2   Advanced"] = { precision_setuser = "2" }
		end
		if ( user == 3 ) then
			params.Options[" 3 ->Experimental<-"] = { precision_setuser = "3" }
		else
			params.Options[" 3   Experimental"] = { precision_setuser = "3" }
		end

		Panel:AddControl( "ListBox", params )

			//Panel:AddControl( "Label", { Text = "General Tool Options:", Description	= "Note: These don't save with presets." }  )
			Panel:AddControl( "Checkbox", { Label = "Enable tool feedback messages?", Command = "precision_enablefeedback", Description = "Toggle for feedback messages incase they get annoying"  } )
			Panel:AddControl( "Checkbox", { Label = "On = Feedback in Chat, Off = Centr Scrn", Command = "precision_chatfeedback", Description = "Chat too cluttered? Can have messages centre screen instead"  } )
			//Panel:AddControl( "Checkbox", { Label = "Hide Menu Tips?", Command = "precision_hidehints", Description = "Streamline the menu once you're happy with using the tool."  } )
			Panel:AddControl( "Checkbox", { Label = "Add Push/Pull to Undo List", Command = "precision_nudgeundo", Description = "For if you're in danger of nudging somthing to where you can't reach it"  } )
			Panel:AddControl( "Checkbox", { Label = "Add Movement to Undo List", Command = "precision_moveundo", Description = "So you don't have to secondary fire with nocollide to undo mistakes"  } )
			Panel:AddControl( "Checkbox", { Label = "Add Rotation to Undo List", Command = "precision_rotateundo", Description = "So you can find the exact rotation value easier"  } )
			Panel:AddControl( "Button", { Label = "Restore Current Mode Default", Command = "precision_defaultrestore", Description = "Collapse menu"  } )
		else
			Panel:AddControl( "Button", { Label = "-- General Tool Options --", Command = "precision_generalmenu", Description = "Expand menu"  } )
			if ( user == 1 ) then
				Panel:AddControl( "Label", { Text = "(Note: For more modes and options like slider, use this options button and change the user level)", Description = "" }  )
			end
		end
	end



	local function precision_defaults()
		local mode = LocalPlayer():GetInfoNum( "precision_mode", 3 )
		if mode  == 1 then
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_autorotate", "1")
			RunConsoleCommand("precision_ShadowDisable", "0")
			RunConsoleCommand("precision_nocollideall", "0")
			RunConsoleCommand("precision_physdisable", "0")
			RunConsoleCommand("precision_allowphysgun", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
		elseif mode == 2 then
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_entirecontrap", "0")
		elseif mode == 3 then
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "1")
			RunConsoleCommand("precision_entirecontrap", "0")
		elseif mode == 4 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
		elseif mode == 5 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
			RunConsoleCommand("precision_torquelimit", "0")
			RunConsoleCommand("precision_friction", "0")
		elseif mode == 6 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
			RunConsoleCommand("precision_torquelimit", "0")
		elseif mode == 7 then
			RunConsoleCommand("precision_move", "0")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
			RunConsoleCommand("precision_torquelimit", "0")
			RunConsoleCommand("precision_XRotMin", "0")
			RunConsoleCommand("precision_XRotMax", "0")
			RunConsoleCommand("precision_YRotMin", "0")
			RunConsoleCommand("precision_YRotMax", "0")
			RunConsoleCommand("precision_ZRotMin", "0")
			RunConsoleCommand("precision_ZRotMax", "0")
			RunConsoleCommand("precision_XRotFric", "0")
			RunConsoleCommand("precision_YRotFric", "0")
			RunConsoleCommand("precision_ZRotFric", "0")
			RunConsoleCommand("precision_FreeMov", "1")
		elseif mode == 8 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "0")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_width", "1")
			RunConsoleCommand("precision_disablesliderfix", "0")
		elseif mode == 9 then
			RunConsoleCommand("precision_allowphysgun", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
		end
		precision_updatecpanel()
	end
	concommand.Add( "precision_defaultrestore", precision_defaults )

	local function precision_genmenu()
		if ( showgenmenu == 1 ) then
			showgenmenu = 0
		else
			showgenmenu = 1
		end
		precision_updatecpanel()
	end
	concommand.Add( "precision_generalmenu", precision_genmenu )
	

	function precision_setmode( player, tool, args )
		if LocalPlayer():GetInfoNum( "precision_mode", 3 ) != args[1] then
			RunConsoleCommand("precision_mode", args[1])
			timer.Simple(0.05, function() precision_updatecpanel() end ) 
		end
	end
	concommand.Add( "precision_setmode", precision_setmode )


	function precision_setuser( player, tool, args )
		if LocalPlayer():GetInfoNum( "precision_user", 3 ) != args[1] then
			RunConsoleCommand("precision_user", args[1])
			timer.Simple(0.05, function() precision_updatecpanel() end ) 
		end
	end
	concommand.Add( "precision_setuser", precision_setuser )


	function precision_updatecpanel()
		local Panel = controlpanel.Get( "precision" )
		if (!Panel) then return end
		//custom panel building ( wtf does Panel:AddDefaultControls() get it's defaults from? )
		AddDefControls( Panel )
	end
	concommand.Add( "precision_updatecpanel", precision_updatecpanel )

	function TOOL.BuildCPanel( Panel )
		AddDefControls( Panel )
	end

	local function precision_removalall()
		RunConsoleCommand("precision_removal_nocollide", "1")
		RunConsoleCommand("precision_removal_weld", "1")
		RunConsoleCommand("precision_removal_axis", "1")
		RunConsoleCommand("precision_removal_ballsocket", "1")
		RunConsoleCommand("precision_removal_advballsocket", "1")
		RunConsoleCommand("precision_removal_slider", "1")
		RunConsoleCommand("precision_removal_parent", "1")
		RunConsoleCommand("precision_removal_other", "1")
		precision_updatecpanel()
	end
	concommand.Add( "precision_removal_all", precision_removalall )
	local function precision_removalnone()
		RunConsoleCommand("precision_removal_nocollide", "0")
		RunConsoleCommand("precision_removal_weld", "0")
		RunConsoleCommand("precision_removal_axis", "0")
		RunConsoleCommand("precision_removal_ballsocket", "0")
		RunConsoleCommand("precision_removal_advballsocket", "0")
		RunConsoleCommand("precision_removal_slider", "0")
		RunConsoleCommand("precision_removal_parent", "0")
		RunConsoleCommand("precision_removal_other", "0")
		precision_updatecpanel()
	end
	concommand.Add( "precision_removal_none", precision_removalnone )

	function TOOL:FreezeMovement()
		local stage = self:GetStage()
		if ( stage == 2 ) then
			return true
		//elseif ( iNum > 0 && self:GetClientNumber("mode") == 2 ) then
		//	return true
		end
		return false
	end
end

function TOOL:Holster()
	self:ClearObjects()
	self:SetStage(0)
	self:ClearSelection()
end
--addons/wos-alcs-custom/lua/weapons/gmod_tool/stools/rb655_lightsaber_dual.lua:
--[[-------------------------------------------------------------------
	Lightsaber Dual Wielding:
		One in each hand.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: www.wiltostech.com
	
-- Copyright 2017, David "King David" Wiltos ]]--


TOOL.Category = "Robotboy655"
TOOL.Name = "Dual Lightsaber"

TOOL.ClientConVar["model"] = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
TOOL.ClientConVar["red"] = "0"
TOOL.ClientConVar["green"] = "127"
TOOL.ClientConVar["blue"] = "255"
TOOL.ClientConVar["bladew"] = "2"
TOOL.ClientConVar["bladel"] = "42"

TOOL.ClientConVar["model_single"] = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
TOOL.ClientConVar["red_single"] = "0"
TOOL.ClientConVar["green_single"] = "127"
TOOL.ClientConVar["blue_single"] = "255"
TOOL.ClientConVar["dark_single"] = "0"
TOOL.ClientConVar["bladew_single"] = "2"
TOOL.ClientConVar["bladel_single"] = "42"


TOOL.ClientConVar["dark"] = "0"
TOOL.ClientConVar["starton"] = "1"

TOOL.ClientConVar["humsound"] = "lightsaber/saber_loop1.wav"
TOOL.ClientConVar["swingsound"] = "lightsaber/saber_swing1.wav"
TOOL.ClientConVar["onsound"] = "lightsaber/saber_on1.wav"
TOOL.ClientConVar["offsound"] = "lightsaber/saber_off1.wav"

cleanup.Register( "ent_lightsabers" )

if ( SERVER ) then
	CreateConVar( "sbox_maxent_lightsabers", 2 )

	function MakeLightsaber( ply, model, pos, ang, LoopSound, SwingSound, OnSound, OffSound )
		if ( IsValid( ply ) && !ply:CheckLimit( "ent_lightsabers" ) ) then return false end

		local ent_lightsaber = ents.Create( "ent_lightsaber" )
		if ( !IsValid( ent_lightsaber ) ) then return false end

		ent_lightsaber:SetModel( model )
		ent_lightsaber:SetAngles( ang )
		ent_lightsaber:SetPos( pos )
		--ent_lightsaber:SetCrystalColor( clr )
		--ent_lightsaber:SetColor( clr )
		--ent_lightsaber:SetEnabled( tobool( Enabled ) )

		table.Merge( ent_lightsaber:GetTable(), {
			Owner = ply,
			--clr = clr,
			--Enabled = tobool( Enabled ),
			LoopSound = LoopSound,
			SwingSound = SwingSound,
			OnSound = OnSound,
			OffSound = OffSound,
		} )

		ent_lightsaber:Spawn()
		ent_lightsaber:Activate()

		if ( IsValid( ply ) ) then
			ply:AddCount( "ent_lightsabers", ent_lightsaber )
			ply:AddCleanup( "ent_lightsabers", ent_lightsaber )
		end

		DoPropSpawnedEffect( ent_lightsaber )

		return ent_lightsaber
	end

	duplicator.RegisterEntityClass( "ent_lightsaber", MakeLightsaber, "model", "pos", "ang", "LoopSound", "SwingSound", "OnSound", "OffSound" )
end

function TOOL:LeftClick( trace )

	return true
end

function TOOL:RightClick( trace )
	if ( trace.HitSky || !trace.HitPos ) then return false end
	if ( IsValid( trace.Entity ) && ( trace.Entity:GetClass() == "ent_lightsaber" ) ) then return false end
	if ( CLIENT ) then return true end

	local ply = self:GetOwner()
	--[[if ( IsValid( ply:GetEyeTrace().Entity ) && ply:GetEyeTrace().Entity:IsPlayer() ) then
		ply = ply:GetEyeTrace().Entity
	end]]

	ply:StripWeapon( "weapon_lightsaber_wos_dual" )
	local w = ply:Give( "weapon_lightsaber_wos_dual" )

	w:SetMaxLength( math.Clamp( ply:GetInfoNum( "rb655_lightsaber_dual_bladel_single", 42 ), 32, 64 ) )
	w:SetSecMaxLength( math.Clamp( ply:GetInfoNum( "rb655_lightsaber_dual_bladel", 42 ), 32, 64 ) )
	w:SetCrystalColor( Vector( ply:GetInfo( "rb655_lightsaber_dual_red_single" ), ply:GetInfo( "rb655_lightsaber_dual_green_single" ), ply:GetInfo( "rb655_lightsaber_dual_blue_single" ) ) )
	w:SetDarkInner( ply:GetInfo( "rb655_lightsaber_dual_dark_single" ) == "1" )
	w:SetWorldModel( ply:GetInfo( "rb655_lightsaber_dual_model_single" ) )
	w:SetSecCrystalColor( Vector( ply:GetInfo( "rb655_lightsaber_dual_red" ), ply:GetInfo( "rb655_lightsaber_dual_green" ), ply:GetInfo( "rb655_lightsaber_dual_blue" ) ) )
	w:SetSecDarkInner( ply:GetInfo( "rb655_lightsaber_dual_dark" ) == "1" )
	w:SetSecWorldModel( ply:GetInfo( "rb655_lightsaber_dual_model" ) )
	w:SetBladeWidth( math.Clamp( ply:GetInfoNum( "rb655_lightsaber_dual_bladew_single", 2 ), 2, 4 ) )
	w:SetSecBladeWidth( math.Clamp( ply:GetInfoNum( "rb655_lightsaber_dual_bladew", 2 ), 2, 4 ) )
	
	w.LoopSound = ply:GetInfo( "rb655_lightsaber_dual_humsound" )
	w.SwingSound = ply:GetInfo( "rb655_lightsaber_dual_swingsound" )
	w:SetOnSound( ply:GetInfo( "rb655_lightsaber_dual_onsound" ) )
	w:SetOffSound( ply:GetInfo( "rb655_lightsaber_dual_offsound" ) )
	w:SetEnabled( tobool( ply:GetInfo( "rb655_lightsaber_dual_starton" ) ) )

	timer.Simple( 0.2, function() ply:SelectWeapon( "weapon_lightsaber_wos_dual" ) end )

	return true
end

function TOOL:Deploy()

	if CLIENT then return end
	if wOS.LegacyToolgun then return end
	local ply = self:GetOwner()
	if not IsValid( ply ) then return end
	
	local group = ply:GetUserGroup()
	local teamr = ply:Team()
	
end

function TOOL:UpdateGhostEntity( ent, ply )
	if ( !IsValid( ent ) ) then return end

	local trace = ply:GetEyeTrace()

	if ( !trace.Hit ) then ent:SetNoDraw( true ) return end
	if ( IsValid( trace.Entity ) && trace.Entity:GetClass() == "ent_lightsaber" || trace.Entity:IsPlayer() || trace.Entity:IsNPC() ) then ent:SetNoDraw( true ) return end

	local ang = trace.HitNormal:Angle()
	ang.p = ang.p - 90

	if ( trace.HitNormal.z > 0.99 ) then ang.y = ply:GetAngles().y end

	local min = ent:OBBMins()
	ent:SetPos( trace.HitPos - trace.HitNormal * min.z )

	ent:SetAngles( ang )
	ent:SetNoDraw( false )
end

function TOOL:Think()
	if ( !IsValid( self.GhostEntity ) || self.GhostEntity:GetModel() != self:GetClientInfo( "model" ) ) then
		self:MakeGhostEntity( self:GetClientInfo( "model" ), Vector( 0, 0, 0 ), Angle( 0, 0, 0 ) )
	end

	self:UpdateGhostEntity( self.GhostEntity, self:GetOwner() )
end

list.Set( "rb655_LightsaberHumSounds", "#tool.rb655_lightsaber.hum.1", { rb655_lightsaber_humsound = "lightsaber/saber_loop1.wav" } )
list.Set( "rb655_LightsaberHumSounds", "#tool.rb655_lightsaber.hum.2", { rb655_lightsaber_humsound = "lightsaber/saber_loop2.wav" } )
list.Set( "rb655_LightsaberHumSounds", "#tool.rb655_lightsaber.hum.3", { rb655_lightsaber_humsound = "lightsaber/saber_loop3.wav" } )
list.Set( "rb655_LightsaberHumSounds", "#tool.rb655_lightsaber.hum.4", { rb655_lightsaber_humsound = "lightsaber/saber_loop4.wav" } )
list.Set( "rb655_LightsaberHumSounds", "#tool.rb655_lightsaber.hum.5", { rb655_lightsaber_humsound = "lightsaber/saber_loop5.wav" } )
list.Set( "rb655_LightsaberHumSounds", "#tool.rb655_lightsaber.hum.6", { rb655_lightsaber_humsound = "lightsaber/saber_loop6.wav" } )
list.Set( "rb655_LightsaberHumSounds", "#tool.rb655_lightsaber.hum.7", { rb655_lightsaber_humsound = "lightsaber/saber_loop7.wav" } )
list.Set( "rb655_LightsaberHumSounds", "#tool.rb655_lightsaber.hum.8", { rb655_lightsaber_humsound = "lightsaber/saber_loop8.wav" } )
list.Set( "rb655_LightsaberHumSounds", "#tool.rb655_lightsaber.dark", { rb655_lightsaber_humsound = "lightsaber/darksaber_loop.wav" } )

list.Set( "rb655_LightsaberSwingSounds", "#tool.rb655_lightsaber.jedi", { rb655_lightsaber_swingsound = "lightsaber/saber_swing1.wav" } )
list.Set( "rb655_LightsaberSwingSounds", "#tool.rb655_lightsaber.sith", { rb655_lightsaber_swingsound = "lightsaber/saber_swing2.wav" } )
list.Set( "rb655_LightsaberSwingSounds", "#tool.rb655_lightsaber.dark", { rb655_lightsaber_swingsound = "lightsaber/darksaber_swing.wav" } )

list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.jedi", { rb655_lightsaber_onsound = "lightsaber/saber_on1.wav", rb655_lightsaber_offsound = "lightsaber/saber_off1.wav" } )
list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.jedi_fast", { rb655_lightsaber_onsound = "lightsaber/saber_on1_fast.wav", rb655_lightsaber_offsound = "lightsaber/saber_off1_fast.wav" } )
list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.sith", { rb655_lightsaber_onsound = "lightsaber/saber_on2.wav", rb655_lightsaber_offsound = "lightsaber/saber_off2.wav" } )
list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.sith_fast", { rb655_lightsaber_onsound = "lightsaber/saber_on2_fast.wav", rb655_lightsaber_offsound = "lightsaber/saber_off2_fast.wav" } )
list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.heavy", { rb655_lightsaber_onsound = "lightsaber/saber_on3.wav", rb655_lightsaber_offsound = "lightsaber/saber_off3.wav" } )
list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.heavy_fast", { rb655_lightsaber_onsound = "lightsaber/saber_on3_fast.wav", rb655_lightsaber_offsound = "lightsaber/saber_off3_fast.wav" } )
list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.jedi2", { rb655_lightsaber_onsound = "lightsaber/saber_on4.wav", rb655_lightsaber_offsound = "lightsaber/saber_off4.mp3" } )
list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.jedi2_fast", { rb655_lightsaber_onsound = "lightsaber/saber_on4_fast.wav", rb655_lightsaber_offsound = "lightsaber/saber_off4_fast.wav" } )
list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.dark", { rb655_lightsaber_onsound = "lightsaber/darksaber_on.wav", rb655_lightsaber_offsound = "lightsaber/darksaber_off.wav" } )
list.Set( "rb655_LightsaberIgniteSounds", "#tool.rb655_lightsaber.kylo", { rb655_lightsaber_onsound = "lightsaber/saber_on_kylo.wav", rb655_lightsaber_offsound = "lightsaber/saber_off_kylo.wav" } )

if ( SERVER ) then return end

TOOL.Information = {
	{ name = "left" },
	{ name = "right" }
}

language.Add( "tool.rb655_lightsaber_dual", "Lightsabers" )
language.Add( "tool.rb655_lightsaber_dual.name", "Lightsabers" )
language.Add( "tool.rb655_lightsaber_dual.desc", "Spawn customized lightsabers" )
language.Add( "tool.rb655_lightsaber_dual.0", "Right click to give yourself a Lightsaber" ) -- Not sure why I keep this
language.Add( "tool.rb655_lightsaber_dual.right", "Give yourself a Lightsaber Weapon" )

language.Add( "tool.rb655_lightsaber_dual.model", "Hilt" )
language.Add( "tool.rb655_lightsaber_dual.color", "Crystal Color" )
language.Add( "tool.rb655_lightsaber_dual.take", "Take this lightsaber" )

language.Add( "tool.rb655_lightsaber_dual.DarkInner", "Dark inner blade" )
language.Add( "tool.rb655_lightsaber_dual.StartEnabled", "Enabled on spawn" )

language.Add( "tool.rb655_lightsaber_dual.HumSound", "Hum Sound" )
language.Add( "tool.rb655_lightsaber_dual.SwingSound", "Swing Sound" )
language.Add( "tool.rb655_lightsaber_dual.IgniteSound", "Ignition Sound" )

language.Add( "tool.rb655_lightsaber_dual.HudBlur", "Enable HUD Blur ( may reduce performance )" )

language.Add( "tool.rb655_lightsaber_dual.bladew", "Blade Width" )
language.Add( "tool.rb655_lightsaber_dual.bladel", "Blade Length" )

language.Add( "tool.rb655_lightsaber_dual.jedi", "Jedi" )
language.Add( "tool.rb655_lightsaber_dual.jedi_fast", "Jedi - Fast" )
language.Add( "tool.rb655_lightsaber_dual.sith", "Sith" )
language.Add( "tool.rb655_lightsaber_dual.sith_fast", "Sith - Fast" )
language.Add( "tool.rb655_lightsaber_dual.heavy", "Heavy" )
language.Add( "tool.rb655_lightsaber_dual.heavy_fast", "Heavy - Fast" )
language.Add( "tool.rb655_lightsaber_dual.jedi2", "Jedi - Original" )
language.Add( "tool.rb655_lightsaber_dual.jedi2_fast", "Jedi - Original Fast" )
language.Add( "tool.rb655_lightsaber_dual.dark", "Dark Saber" )
language.Add( "tool.rb655_lightsaber_dual.kylo", "Kylo Ren" )

language.Add( "tool.rb655_lightsaber_dual.hum.1", "Default" )
language.Add( "tool.rb655_lightsaber_dual.hum.2", "Sith Heavy" )
language.Add( "tool.rb655_lightsaber_dual.hum.3", "Medium" )
language.Add( "tool.rb655_lightsaber_dual.hum.4", "Heavish" )
language.Add( "tool.rb655_lightsaber_dual.hum.5", "Sith Assassin Light" )
language.Add( "tool.rb655_lightsaber_dual.hum.6", "Darth Vader" )
language.Add( "tool.rb655_lightsaber_dual.hum.7", "Heavy" )
language.Add( "tool.rb655_lightsaber_dual.hum.8", "Dooku" )

language.Add( "Cleanup_ent_lightsabers", "Lightsabers" )
language.Add( "Cleaned_ent_lightsabers", "Cleaned up all Lightsabers" )
language.Add( "SBoxLimit_ent_lightsabers", "You've hit the Lightsaber limit!" )
language.Add( "Undone_ent_lightsaber", "Lightsaber undone" )
language.Add( "max_ent_lightsabers", "Max Lightsabers" )

language.Add( "tool.rb655_lightsaber_dual.preset1", "Darth Maul's Saberstaff" )
language.Add( "tool.rb655_lightsaber_dual.preset2", "Darth Maul's Lightsaber" )
language.Add( "tool.rb655_lightsaber_dual.preset3", "Darth Tyrannus's Lightsaber (Count Dooku)" )
language.Add( "tool.rb655_lightsaber_dual.preset4", "Darth Sidious's Lightsaber" )
language.Add( "tool.rb655_lightsaber_dual.preset5", "Darth Vader's Lightsaber" )

language.Add( "tool.rb655_lightsaber_dual.preset6", "Master Yoda's Lightsaber" )
language.Add( "tool.rb655_lightsaber_dual.preset7", "Qui-Gon Jinn's Lightsaber" )
language.Add( "tool.rb655_lightsaber_dual.preset8", "Mace Windu's Lightsaber" )
language.Add( "tool.rb655_lightsaber_dual.preset9", "[EP3] Obi-Wan Kenobi's Lightsaber" )
language.Add( "tool.rb655_lightsaber_dual.preset10", "[EP1] Obi-Wan Kenobi's Lightsaber" )
language.Add( "tool.rb655_lightsaber_dual.preset11", "[EP6] Luke Skywalker's Lightsaber" )
language.Add( "tool.rb655_lightsaber_dual.preset12", "[EP2] Anakin Skywalker's Lightsaber" )
language.Add( "tool.rb655_lightsaber_dual.preset13", "[EP3] Anakin Skywalker's Lightsaber" )
language.Add( "tool.rb655_lightsaber_dual.preset14", "Common Jedi Lightsaber" )
language.Add( "tool.rb655_lightsaber_dual.preset15", "Dark Saber" )
language.Add( "tool.rb655_lightsaber_dual.preset_kylo", "Kylo Ren's Crossguard Lightsaber" )

local ConVarsDefault = TOOL:BuildConVarList()

local PresetPresets = {
	[ "#preset.default" ] = ConVarsDefault,

	-- Sith
	[ "#tool.rb655_lightsaber_dual.preset1" ] = {
		rb655_lightsaber_dual_model = "models/weapons/starwars/w_maul_saber_staff_hilt.mdl",
		rb655_lightsaber_dual_red = "255",
		rb655_lightsaber_dual_green = "0",
		rb655_lightsaber_dual_blue = "0",
		rb655_lightsaber_dual_dark = "0",
		rb655_lightsaber_dual_bladew = "2.4",
		rb655_lightsaber_dual_bladel = "45",
		rb655_lightsaber_dual_humsound = "lightsaber/saber_loop7.wav",
		rb655_lightsaber_dual_swingsound = "lightsaber/saber_swing2.wav",
		rb655_lightsaber_dual_onsound = "lightsaber/saber_on2.wav",
		rb655_lightsaber_dual_offsound = "lightsaber/saber_off2.wav"
	},
	[ "#tool.rb655_lightsaber_dual.preset2" ] = {
		rb655_lightsaber_dual_model = "models/sgg/starwars/weapons/w_maul_saber_half_hilt.mdl",
		rb655_lightsaber_dual_red = "255",
		rb655_lightsaber_dual_green = "0",
		rb655_lightsaber_dual_blue = "0",
		rb655_lightsaber_dual_dark = "0",
		rb655_lightsaber_dual_bladew = "2.4",
		rb655_lightsaber_dual_bladel = "45",
		rb655_lightsaber_dual_humsound = "lightsaber/saber_loop7.wav",
		rb655_lightsaber_dual_swingsound = "lightsaber/saber_swing2.wav",
		rb655_lightsaber_dual_onsound = "lightsaber/saber_on2.wav",
		rb655_lightsaber_dual_offsound = "lightsaber/saber_off2.wav"
	},
	[ "#tool.rb655_lightsaber_dual.preset3" ] = {
		rb655_lightsaber_dual_model = "models/weapons/starwars/w_dooku_saber_hilt.mdl",
		rb655_lightsaber_dual_red = "255",
		rb655_lightsaber_dual_green = "0",
		rb655_lightsaber_dual_blue = "0",
		rb655_lightsaber_dual_dark = "0",
		rb655_lightsaber_dual_bladew = "2",
		rb655_lightsaber_dual_bladel = "42",
		rb655_lightsaber_dual_humsound = "lightsaber/saber_loop8.wav",
		rb655_lightsaber_dual_swingsound = "lightsaber/saber_swing2.wav",
		rb655_lightsaber_dual_onsound = "lightsaber/saber_on2.wav",
		rb655_lightsaber_dual_offsound = "lightsaber/saber_off2.wav"
	},
	[ "#tool.rb655_lightsaber_dual.preset4" ] = {
		rb655_lightsaber_dual_model = "models/sgg/starwars/weapons/w_sidious_saber_hilt.mdl",
		rb655_lightsaber_dual_red = "255",
		rb655_lightsaber_dual_green = "0",
		rb655_lightsaber_dual_blue = "0",
		rb655_lightsaber_dual_dark = "0",
		rb655_lightsaber_dual_bladew = "2.2",
		rb655_lightsaber_dual_bladel = "43",
		rb655_lightsaber_dual_humsound = "lightsaber/saber_loop5.wav",
		rb655_lightsaber_dual_swingsound = "lightsaber/saber_swing2.wav",
		rb655_lightsaber_dual_onsound = "lightsaber/saber_on2.wav",
		rb655_lightsaber_dual_offsound = "lightsaber/saber_off2.wav"
	},
	[ "#tool.rb655_lightsaber_dual.preset5" ] = {
		rb655_lightsaber_dual_model = "models/sgg/starwars/weapons/w_vader_saber_hilt.mdl",
		rb655_lightsaber_dual_red = "255",
		rb655_lightsaber_dual_green = "0",
		rb655_lightsaber_dual_blue = "0",
		rb655_lightsaber_dual_dark = "0",
		rb655_lightsaber_dual_bladew = "2.25",
		rb655_lightsaber_dual_bladel = "43",
		rb655_lightsaber_dual_humsound = "lightsaber/saber_loop6.wav",
		rb655_lightsaber_dual_swingsound = "lightsaber/saber_swing2.wav",
		rb655_lightsaber_dual_onsound = "lightsaber/saber_on2.wav",
		rb655_lightsaber_dual_offsound = "lightsaber/saber_off2.wav"
	},

	-- Jedi
	[ "#tool.rb655_lightsaber_dual.preset6" ] = {
		rb655_lightsaber_dual_model = "models/sgg/starwars/weapons/w_yoda_saber_hilt.mdl",
		rb655_lightsaber_dual_red = "64",
		rb655_lightsaber_dual_green = "255",
		rb655_lightsaber_dual_blue = "64",
		rb655_lightsaber_dual_dark = "0",
		rb655_lightsaber_dual_bladew = "2.3",
		rb655_lightsaber_dual_bladel = "40",
		rb655_lightsaber_dual_humsound = "lightsaber/saber_loop3.wav",
		rb655_lightsaber_dual_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_dual_onsound = "lightsaber/saber_on1.wav",
		rb655_lightsaber_dual_offsound = "lightsaber/saber_off1.wav"
	},
	[ "#tool.rb655_lightsaber_dual.preset7" ] = {
		rb655_lightsaber_dual_model = "models/sgg/starwars/weapons/w_quigon_gin_saber_hilt.mdl",
		rb655_lightsaber_dual_red = "32",
		rb655_lightsaber_dual_green = "255",
		rb655_lightsaber_dual_blue = "32",
		rb655_lightsaber_dual_dark = "0",
		rb655_lightsaber_dual_bladew = "2.2",
		rb655_lightsaber_dual_bladel = "42",
		rb655_lightsaber_dual_humsound = "lightsaber/saber_loop1.wav",
		rb655_lightsaber_dual_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_dual_onsound = "lightsaber/saber_on1.wav",
		rb655_lightsaber_dual_offsound = "lightsaber/saber_off1.wav"
	},
	[ "#tool.rb655_lightsaber_dual.preset8" ] = {
		rb655_lightsaber_dual_model = "models/sgg/starwars/weapons/w_mace_windu_saber_hilt.mdl",
		rb655_lightsaber_dual_red = "127",
		rb655_lightsaber_dual_green = "0",
		rb655_lightsaber_dual_blue = "255",
		rb655_lightsaber_dual_dark = "0",
		rb655_lightsaber_dual_bladew = "2",
		rb655_lightsaber_dual_bladel = "42",
		rb655_lightsaber_dual_humsound = "lightsaber/saber_loop1.wav",
		rb655_lightsaber_dual_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_dual_onsound = "lightsaber/saber_on1.wav",
		rb655_lightsaber_dual_offsound = "lightsaber/saber_off1.wav"
	},
	[ "#tool.rb655_lightsaber_dual.preset9" ] = {
		rb655_lightsaber_dual_model = "models/sgg/starwars/weapons/w_obiwan_ep3_saber_hilt.mdl",
		rb655_lightsaber_dual_red = "48",
		rb655_lightsaber_dual_green = "48",
		rb655_lightsaber_dual_blue = "255",
		rb655_lightsaber_dual_dark = "0",
		rb655_lightsaber_dual_bladew = "2.1",
		rb655_lightsaber_dual_bladel = "42",
		rb655_lightsaber_dual_humsound = "lightsaber/saber_loop1.wav",
		rb655_lightsaber_dual_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_dual_onsound = "lightsaber/saber_on1.wav",
		rb655_lightsaber_dual_offsound = "lightsaber/saber_off1.wav"
	},
	[ "#tool.rb655_lightsaber_dual.preset10" ] = {
		rb655_lightsaber_dual_model = "models/sgg/starwars/weapons/w_obiwan_ep1_saber_hilt.mdl",
		rb655_lightsaber_dual_red = "48",
		rb655_lightsaber_dual_green = "48",
		rb655_lightsaber_dual_blue = "255",
		rb655_lightsaber_dual_dark = "0",
		rb655_lightsaber_dual_bladew = "2.1",
		rb655_lightsaber_dual_bladel = "42",
		rb655_lightsaber_dual_humsound = "lightsaber/saber_loop1.wav",
		rb655_lightsaber_dual_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_dual_onsound = "lightsaber/saber_on1.wav",
		rb655_lightsaber_dual_offsound = "lightsaber/saber_off1.wav"
	},
	[ "#tool.rb655_lightsaber_dual.preset11" ] = {
		rb655_lightsaber_dual_model = "models/sgg/starwars/weapons/w_luke_ep6_saber_hilt.mdl",
		rb655_lightsaber_dual_red = "32",
		rb655_lightsaber_dual_green = "255",
		rb655_lightsaber_dual_blue = "32",
		rb655_lightsaber_dual_dark = "0",
		rb655_lightsaber_dual_bladew = "2.1",
		rb655_lightsaber_dual_bladel = "42",
		rb655_lightsaber_dual_humsound = "lightsaber/saber_loop1.wav",
		rb655_lightsaber_dual_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_dual_onsound = "lightsaber/saber_on1.wav",
		rb655_lightsaber_dual_offsound = "lightsaber/saber_off1.wav"
	},
	[ "#tool.rb655_lightsaber_dual.preset12" ] = {
		rb655_lightsaber_dual_model = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl",
		rb655_lightsaber_dual_red = "0",
		rb655_lightsaber_dual_green = "100",
		rb655_lightsaber_dual_blue = "255",
		rb655_lightsaber_dual_dark = "0",
		rb655_lightsaber_dual_bladew = "2.1",
		rb655_lightsaber_dual_bladel = "42",
		rb655_lightsaber_dual_humsound = "lightsaber/saber_loop1.wav",
		rb655_lightsaber_dual_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_dual_onsound = "lightsaber/saber_on1.wav",
		rb655_lightsaber_dual_offsound = "lightsaber/saber_off1.wav"
	},
	[ "#tool.rb655_lightsaber_dual.preset13" ] = {
		rb655_lightsaber_dual_model = "models/sgg/starwars/weapons/w_anakin_ep3_saber_hilt.mdl",
		rb655_lightsaber_dual_red = "0",
		rb655_lightsaber_dual_green = "100",
		rb655_lightsaber_dual_blue = "255",
		rb655_lightsaber_dual_dark = "0",
		rb655_lightsaber_dual_bladew = "2.1",
		rb655_lightsaber_dual_bladel = "42",
		rb655_lightsaber_dual_humsound = "lightsaber/saber_loop1.wav",
		rb655_lightsaber_dual_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_dual_onsound = "lightsaber/saber_on1.wav",
		rb655_lightsaber_dual_offsound = "lightsaber/saber_off1.wav"
	},
	[ "#tool.rb655_lightsaber_dual.preset14" ] = {
		rb655_lightsaber_dual_model = "models/sgg/starwars/weapons/w_common_jedi_saber_hilt.mdl",
		rb655_lightsaber_dual_dark = "0",
		rb655_lightsaber_dual_bladew = "2.2",
		rb655_lightsaber_dual_bladel = "42",
		rb655_lightsaber_dual_humsound = "lightsaber/saber_loop1.wav",
		rb655_lightsaber_dual_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_dual_onsound = "lightsaber/saber_on1.wav",
		rb655_lightsaber_dual_offsound = "lightsaber/saber_off1.wav"
	},

	[ "#tool.rb655_lightsaber_dual.preset_kylo" ] = {
		rb655_lightsaber_dual_model = "models/weapons/starwars/w_kr_hilt.mdl",
		rb655_lightsaber_dual_red = "255",
		rb655_lightsaber_dual_green = "0",
		rb655_lightsaber_dual_blue = "0",
		rb655_lightsaber_dual_dark = "0",
		rb655_lightsaber_dual_bladew = "2.1",
		rb655_lightsaber_dual_bladel = "40",
		rb655_lightsaber_dual_humsound = "lightsaber/saber_loop1.wav",
		rb655_lightsaber_dual_swingsound = "lightsaber/saber_swing1.wav",
		rb655_lightsaber_dual_onsound = "lightsaber/saber_on_kylo.wav",
		rb655_lightsaber_dual_offsound = "lightsaber/saber_off_kylo.wav"
	},

	-- The Pre Vizsla's darksaber from clone wars, I LOVE IT
	[ "#tool.rb655_lightsaber_dual.preset15" ] = {
		rb655_lightsaber_dual_red = "255",
		rb655_lightsaber_dual_green = "255",
		rb655_lightsaber_dual_blue = "255",
		rb655_lightsaber_dual_dark = "1",
		rb655_lightsaber_dual_humsound = "lightsaber/darksaber_loop.wav",
		rb655_lightsaber_dual_swingsound = "lightsaber/darksaber_swing.wav",
		rb655_lightsaber_dual_onsound = "lightsaber/darksaber_on.wav",
		rb655_lightsaber_dual_offsound = "lightsaber/darksaber_off.wav"
	},
}

function TOOL.BuildCPanel( panel )
	panel:AddControl( "ComboBox", { MenuButton = 1, Folder = "rb655_lightsabers", Options = PresetPresets, CVars = table.GetKeys( ConVarsDefault ) } )

	panel:AddControl( "PropSelect", {Label = "#tool.rb655_lightsaber_dual.model", Height = 4, ConVar = "rb655_lightsaber_dual_model_single", Models = list.Get( "LightsaberModels" )} )
	panel:AddControl( "PropSelect", {Label = "Second Saber Hilt", Height = 4, ConVar = "rb655_lightsaber_dual_model", Models = list.Get( "LightsaberModels" )} )
	
	panel:AddControl( "Color", { Label = "#tool.rb655_lightsaber_dual.color", Red = "rb655_lightsaber_dual_red_single", Green = "rb655_lightsaber_dual_green_single", Blue = "rb655_lightsaber_dual_blue_single", ShowAlpha = "0", ShowHSV = "1", ShowRGB = "1" } )
	panel:AddControl( "Color", { Label = "Second Saber Color", Red = "rb655_lightsaber_dual_red", Green = "rb655_lightsaber_dual_green", Blue = "rb655_lightsaber_dual_blue", ShowAlpha = "0", ShowHSV = "1", ShowRGB = "1" } )

	panel:AddControl( "Checkbox", { Label = "#tool.rb655_lightsaber_dual.DarkInner", Command = "rb655_lightsaber_dual_dark_single" } )
	panel:AddControl( "Checkbox", { Label = "Second Dark Inner", Command = "rb655_lightsaber_dual_dark" } )
	
	panel:AddControl( "Checkbox", { Label = "#tool.rb655_lightsaber_dual.StartEnabled", Command = "rb655_lightsaber_dual_starton" } )

	panel:AddControl( "Slider", {Label = "#tool.rb655_lightsaber_dual.bladeW", Type = "Float", Min = 2, Max = 4, Command = "rb655_lightsaber_dual_bladew_single"} )
	panel:AddControl( "Slider", {Label = "#tool.rb655_lightsaber_dual.bladeL", Type = "Float", Min = 32, Max = 64, Command = "rb655_lightsaber_dual_bladel_single"} )

	panel:AddControl( "Slider", {Label = "Second Blade Width", Type = "Float", Min = 2, Max = 4, Command = "rb655_lightsaber_dual_bladew"} )
	panel:AddControl( "Slider", {Label = "Second Blade Length", Type = "Float", Min = 32, Max = 64, Command = "rb655_lightsaber_dual_bladel"} )

	panel:AddControl( "ListBox", { Label = "#tool.rb655_lightsaber_dual.HumSound", Options = list.Get( "rb655_LightsaberHumSounds" ) } )
	panel:AddControl( "ListBox", { Label = "#tool.rb655_lightsaber_dual.SwingSound", Options = list.Get( "rb655_LightsaberSwingSounds" ) } )
	panel:AddControl( "ListBox", { Label = "#tool.rb655_lightsaber_dual.IgniteSound", Options = list.Get( "rb655_LightsaberIgniteSounds" ) } )

	panel:AddControl( "Checkbox", { Label = "#tool.rb655_lightsaber_dual.HudBlur", Command = "rb655_lightsaber_hud_blur" } )
	
	
	panel.Think = function( span )
		if LocalPlayer().wOSRefresh then
			span:Clear()
			span:AddControl( "ComboBox", { MenuButton = 1, Folder = "rb655_lightsabers", Options = PresetPresets, CVars = table.GetKeys( ConVarsDefault ) } )

			span:AddControl( "PropSelect", {Label = "#tool.rb655_lightsaber_dual.model", Height = 4, ConVar = "rb655_lightsaber_dual_model_single", Models = list.Get( "LightsaberModels" )} )
			span:AddControl( "PropSelect", {Label = "Second Saber Hilt", Height = 4, ConVar = "rb655_lightsaber_dual_model", Models = list.Get( "LightsaberModels" )} )
			
			span:AddControl( "Color", { Label = "#tool.rb655_lightsaber_dual.color", Red = "rb655_lightsaber_dual_red_single", Green = "rb655_lightsaber_dual_green_single", Blue = "rb655_lightsaber_dual_blue_single", ShowAlpha = "0", ShowHSV = "1", ShowRGB = "1" } )
			span:AddControl( "Color", { Label = "Second Saber Color", Red = "rb655_lightsaber_dual_red", Green = "rb655_lightsaber_dual_green", Blue = "rb655_lightsaber_dual_blue", ShowAlpha = "0", ShowHSV = "1", ShowRGB = "1" } )

			span:AddControl( "Checkbox", { Label = "#tool.rb655_lightsaber_dual.DarkInner", Command = "rb655_lightsaber_dual_dark_single" } )
			span:AddControl( "Checkbox", { Label = "Second Dark Inner", Command = "rb655_lightsaber_dual_dark" } )
			
			span:AddControl( "Checkbox", { Label = "#tool.rb655_lightsaber_dual.StartEnabled", Command = "rb655_lightsaber_dual_starton" } )

			span:AddControl( "Slider", {Label = "#tool.rb655_lightsaber_dual.bladeW", Type = "Float", Min = 2, Max = 4, Command = "rb655_lightsaber_dual_bladew_single"} )
			span:AddControl( "Slider", {Label = "#tool.rb655_lightsaber_dual.bladeL", Type = "Float", Min = 32, Max = 64, Command = "rb655_lightsaber_dual_bladel_single"} )

			span:AddControl( "Slider", {Label = "Second Blade Width", Type = "Float", Min = 2, Max = 4, Command = "rb655_lightsaber_dual_bladew"} )
			span:AddControl( "Slider", {Label = "Second Blade Length", Type = "Float", Min = 32, Max = 64, Command = "rb655_lightsaber_dual_bladel"} )

			span:AddControl( "ListBox", { Label = "#tool.rb655_lightsaber_dual.HumSound", Options = list.Get( "rb655_LightsaberHumSounds" ) } )
			span:AddControl( "ListBox", { Label = "#tool.rb655_lightsaber_dual.SwingSound", Options = list.Get( "rb655_LightsaberSwingSounds" ) } )
			span:AddControl( "ListBox", { Label = "#tool.rb655_lightsaber_dual.IgniteSound", Options = list.Get( "rb655_LightsaberIgniteSounds" ) } )

			span:AddControl( "Checkbox", { Label = "#tool.rb655_lightsaber_dual.HudBlur", Command = "rb655_lightsaber_hud_blur" } )
			LocalPlayer().wOSRefresh = false
		end
	end
	
end

--lua/weapons/gmod_tool/stools/removeradvanced.lua:
--[[
		Created by: M4n0Cr4zy
		Colaborator: Xalalau Xubilozo 
		Special thanks to: Nodge 
]]

TOOL.Category   = "Construction"
TOOL.Name       = "Remover - Advanced"
TOOL.Command    = nil
TOOL.ConfigName = ""

if CLIENT then
	TOOL.Information = {
		{ name = "left" },
		{ name = "right" },
		{ name = "reload" },
		{ name = "use" },
		{ name = "info" }
	}

    language.Add("tool.removeradvanced.name", "Remover - Advanced")
    language.Add("tool.removeradvanced.desc", "Selectively remove entities")
	language.Add("tool.removeradvanced.left", "Search entities within a spherical area")
	language.Add("tool.removeradvanced.right","List all entities")
	language.Add("tool.removeradvanced.reload", "Remove hit object ('single' mode) and all objects constraint to it ('constraint' mode)")
	language.Add("tool.removeradvanced.use", "Alternate between 'single' and 'constraint' hit objects removal modes")
	language.Add("tool.removeradvanced.0", "Right-click the listed entities to display the context menu")

	CreateClientConVar("advr_sphere_radius", "80", true, false)
	CreateClientConVar("advr_enable_area_search", "true", true, false)
	CreateClientConVar("advr_allow_no_model", "false", true, false)
	CreateClientConVar("advr_allow_weapons", "false", true, false)
else
	util.AddNetworkString("m4n0cr4zy.Receive_Table_Cl")
	util.AddNetworkString("m4n0cr4zy.Left_Click_1")
	util.AddNetworkString("m4n0cr4zy.Left_Click_2")
	util.AddNetworkString("m4n0cr4zy.Right_Click_1")
	util.AddNetworkString("m4n0cr4zy.Right_Click_2")
	util.AddNetworkString("m4n0cr4zy.Set_Blacklist")
	util.AddNetworkString("m4n0cr4zy.Reset_Blacklist")
	util.AddNetworkString("m4n0cr4zy.Tool_Swaped")
end


ADVRBlacklist = nil
local defaultBlacklist = {
	["player"] = true,
	["gmod_hands"] = true,
	["viewmodel"] = true,
	["worldspawn"] = true,
	["func_brush"] = true,
	["func_illusionary"] = true,
	["class C_BaseEntity"] = true,
	["class C_Sun"] = true,
	["predicted_viewmodel"] = true
}

local usingTool = false
local removalMode = 'single'

local checkBoxSphere
local blacklistMenu

local dataFolder = "advremover"
local blacklistFile = dataFolder .. "/blacklist.txt"

local lastSentChunksID

file.CreateDir(dataFolder)


-- Carregar blacklist
local function LoadBlacklist()
	ADVRBlacklist = file.Read(blacklistFile, "DATA")
	if ADVRBlacklist then
		ADVRBlacklist = util.JSONToTable(ADVRBlacklist)

		hook.Add("PlayerInitialSpawn", "ADVRFullLoadSetup", function(ply)
			hook.Add("SetupMove", ply, function(self, ply, _, cmd)
				if self == ply and not cmd:IsForced() then
					net.Start("m4n0cr4zy.Set_Blacklist")
					net.WriteTable(ADVRBlacklist)
					net.Send(ply)

					hook.Remove("SetupMove", self)
				end
			end)
		end)
	else
		ADVRBlacklist = table.Copy(defaultBlacklist)
	end
end


-- Modificar itens da blacklist e salvar alterações
if SERVER then
	function ADVR_BlacklistClass(class, isBlacklisted)
		ADVRBlacklist[class] = isBlacklisted

		net.Start("m4n0cr4zy.Set_Blacklist")
		net.WriteTable(ADVRBlacklist)
		net.Broadcast()

		file.Write(blacklistFile, util.TableToJSON(ADVRBlacklist, true))
	end
end

if CLIENT then
	net.Receive("m4n0cr4zy.Set_Blacklist", function()
	    ADVRBlacklist = net.ReadTable()

		if blacklistMenu then
			for index, foundLine in pairs(blacklistMenu:GetLines()) do
				blacklistMenu:RemoveLine(index)
			end

			for class, isBlacklisted in pairs(ADVRBlacklist) do
				if isBlacklisted then
					blacklistMenu:AddLine(class)
				end
			end

			blacklistMenu:SortByColumn(1, false)

			ADVR_RefreshMenu()
		end
	end)
end


-- Resetar a blacklist
local function ResetBlacklist()
	ADVRBlacklist = table.Copy(defaultBlacklist)

	net.Start("m4n0cr4zy.Reset_Blacklist")
	net.SendToServer()
end

if SERVER then
	net.Receive("m4n0cr4zy.Reset_Blacklist", function()
	    ADVRBlacklist = table.Copy(defaultBlacklist)

		file.Write(blacklistFile, util.TableToJSON(ADVRBlacklist, true))
	end)
end


-- Enviar tabela para o cliente
--   Portei essa função do meu gm_construct 13 beta :) - Xala
local function SendTable(sendTab, ply, clickType)
    if CLIENT then return end

	local currentChuncksID = tostring(sendTab)

	lastSentChunksID = currentChuncksID

	sendTab = util.Compress(util.TableToJSON(sendTab))
	local totalSize = string.len(sendTab)

	local chunkSize = 55000 -- 55KB
	local totalChunks = math.ceil(totalSize / chunkSize)

	for i = 1, totalChunks, 1 do
		local startByte = chunkSize * (i - 1) + 1
		local remaining = totalSize - (startByte - 1)
		local endByte = remaining < chunkSize and (startByte - 1) + remaining or chunkSize * i
		local chunk = string.sub(sendTab, startByte, endByte)

		timer.Simple(i * 0.05, function()
			if lastSentChunksID ~= currentChuncksID then return end

			local isLastChunk = i == totalChunks

			net.Start("m4n0cr4zy.Receive_Table_Cl")
			net.WriteString(clickType)
			net.WriteString(currentChuncksID)
			net.WriteUInt(#chunk, 16)
			net.WriteData(chunk, #chunk)
			net.WriteBool(isLastChunk)
			if ply then
				net.Send(ply)
			else
				net.Broadcast()
			end
		end)
	end
end


-- Botão esquerdo: Busca localizada (esfera)
function TOOL:LeftClick(trace)
	local owner = self:GetOwner()

	if not owner:IsAdmin() then
		owner:PrintMessage(HUD_PRINTTALK, "Admin only tool!")
		return false
	end

	if SERVER then
        net.Start("m4n0cr4zy.Left_Click_1")
        net.Send(owner)
    end	

	return false
end

if SERVER then
	net.Receive("m4n0cr4zy.Left_Click_2", function(_, ply)
		local radius = net.ReadInt(13)
		local pos = net.ReadVector()
		local allow_weapons = net.ReadBool()
		local allow_no_model = net.ReadBool()

		local sendTab = ADVR_GetAllEnts(pos, radius, allow_weapons, allow_no_model)
		local clickType = "LeftClick"

		SendTable(sendTab, ply, clickType)
	end)
end


-- Enviar tabela de entidades do servidor para o cliente (em partes) e abrir menu com todas as entidades dos dois lados
function TOOL:RightClick(trace)
	local owner = self:GetOwner()

	if not owner:IsAdmin() then
		owner:PrintMessage(HUD_PRINTTALK, "Admin only tool!")
		return false
	end
	if SERVER then
        net.Start("m4n0cr4zy.Right_Click_1")
        net.Send(owner)
    end	

	return false
end

if SERVER then
	net.Receive("m4n0cr4zy.Right_Click_2", function(_, ply)
		local allow_weapons = net.ReadBool()
		local allow_no_model = net.ReadBool()

		local sendTab = ADVR_GetAllEnts(nil, nil, allow_weapons, allow_no_model)
		local clickType = "RightClick"
	
		SendTable(sendTab, ply, clickType)
	end)
end


-- Remover entidade e constraints
-- Diretamente do remover tool do GMod
function TOOL:Reload(trace)
	local owner = self:GetOwner()

	if not owner:IsAdmin() then
		owner:PrintMessage(HUD_PRINTTALK, "Admin only tool!")
		return false
	end

	local ent = trace.Entity

	if removalMode == 'single' then
		return ADVR_RemoveEnt(ent)
	elseif removalMode == 'constraint' then
		return ADVR_RemoveEntWithConstraineds(ent)
	end

	return false
end

if SERVER then
	hook.Add("KeyPress", "ADVRKeyPressUse", function(ply, key)
		if key == IN_USE and usingTool then
			if removalMode == 'single' then
				removalMode = 'constraint'
			else
				removalMode = 'single'
			end

			ply:PrintMessage(HUD_PRINTCENTER, "'" .. removalMode .. "' mode selected")
		end
	end)
end


-- Remover a bolinha
local function RemoveSphere()
	if SERVER then return end

	hook.Remove("PostDrawTranslucentRenderables", "ADVRSphereHook")
end


-- Desenha a bola na tela ao clicar com o esquerdo e se o Checked estiver marcado
local function SetSphere(ply, value)
	if SERVER then return end
	if not IsValid(ply) or not ply.GetActiveWeapon then return end

	local isSphereEnabled = GetConVar("advr_enable_area_search"):GetBool()

	if isSphereEnabled then	
		local radius = value or GetConVar("advr_sphere_radius"):GetInt()
		local longitude = 10
		local altitude = 10

		hook.Add("PostDrawTranslucentRenderables", "ADVRSphereHook", function(isDrawingDepth, isDrawSkybox, isDraw3DSkybox)
			if isDrawingDepth or isDrawSkybox or isDraw3DSkybox then return end

			local currentWeapon = ply:GetActiveWeapon()

			if not IsValid(currentWeapon) or
			   not currentWeapon.GetClass or
			   not currentWeapon.GetTable
			then
				RemoveSphere()
				return
			end

			if currentWeapon:GetClass() ~= 'gmod_tool' or
			   currentWeapon:GetTable()['current_mode'] ~= 'removeradvanced'
			then
				return
			end

			if not usingTool then
				RemoveSphere()
				return
			end

			local pos = LocalPlayer():GetEyeTrace().HitPos			

			render.SetColorMaterial()
			render.DrawSphere(pos, radius, longitude, altitude, Color(0, 255, 0, 40), true)
			render.DrawWireframeSphere(pos, radius, longitude, altitude, Color(0, 0, 0, 255), true)	
		end)
	end
end


-- Identificar uso da ferramenta - Xala
--     Nota: Deploy e Holster são predicted, então no singleplayer eles só rodam no serverside
--           Deploy é chamado ao pegar ferramenta (às vezes mais de uma vez)
--				Bug: se o jogador tiver a ferramenta pré selecionada ao iniciar o game, o deploy não
--                   é chamado ao selecioná-la diretamente pela menu de armas, apenas a partir da
--                   segunda seleção. Isso é contornado com uma ativação extra da esfera durante a
--                   construção do menu e pela verificação da arma do jogador.
--           Holster é chamado ao tirar a ferramenta (às vezes mais de uma vez)
local function ToolSwaped(ply, state)
    if not ply:IsAdmin() then return end

	usingTool = state

	if CLIENT then
		if usingTool then
			SetSphere(ply)
		else
			RemoveSphere()
		end
	else
		net.Start("m4n0cr4zy.Tool_Swaped")
		net.WriteBool(state)
		net.Send(ply)
	end
end
net.Receive("m4n0cr4zy.Tool_Swaped", function(len, ply)
	local state = net.ReadBool()
	ply = CLIENT and LocalPlayer() or ply

	ToolSwaped(ply, state)
end)
function TOOL:Deploy()
	if SERVER then
		ToolSwaped(self:GetOwner(), true)
	end
end
function TOOL:Holster()
	if SERVER then
		ToolSwaped(self:GetOwner(), false)
	end
end

function TOOL.BuildCPanel(CPanel)
	local menuMargin = 5
	local initializedMenu = false

    if not LocalPlayer():IsAdmin() then
		local adminWarning = vgui.Create("DLabel", CPanel)
		adminWarning:SetPos(10, 25 + menuMargin)
		adminWarning:SetWide(210)
		adminWarning:SetText("Admin only tool!")
		adminWarning:SetDark(true)
		return
	end

	-- Checkbox	de ativação da busca por área
	-- -----------------------------------------------------------------------------------------------------------------

	checkBoxSphere = vgui.Create("DCheckBoxLabel", CPanel)
	checkBoxSphere:SetPos(10, 25 + menuMargin)
	checkBoxSphere:SetText("Search by area (sphere)")
	checkBoxSphere:SetConVar("advr_enable_area_search")
	checkBoxSphere:SetDark(true)
	
	function checkBoxSphere:OnChange(val)
		if not initializedMenu then return end

		if val then
			SetSphere(LocalPlayer())
		else
			RemoveSphere()
		end
	end

	checkBoxSphere:SetValue(true)

	-- Tamanho da esfera de busca
	-- -----------------------------------------------------------------------------------------------------------------

	-- NumSlider - 'Barra' - tamanho da bolinha
	local sphereSize = vgui.Create("DNumSlider", CPanel)
	sphereSize:SetPos(10, checkBoxSphere:GetY() + checkBoxSphere:GetTall() + menuMargin)
	sphereSize:SetSize(50, 25)
	sphereSize:SetMinMax(5, 3000)
	sphereSize:SetDecimals(0)
	sphereSize:SetConVar("advr_sphere_radius")
	sphereSize:SetDark(true)
	sphereSize:SetWide(210)
	sphereSize.Label:SetVisible(false) 	

	local sphereSizeLabel = vgui.Create ("DLabel", sphereSize)
	sphereSizeLabel:Dock(LEFT)
	sphereSizeLabel:SetText(" Radius:")
	sphereSizeLabel:SetDark(true)
    sphereSizeLabel:SetWide(40)

	-- Ativar o checkbox da busca automaticamente ao mover o slider
	local onMouseFunc = sphereSize.Slider.OnMousePressed
	sphereSize.Slider.OnMousePressed = function(self, keyCode)
		checkBoxSphere:SetValue(true)
		onMouseFunc(sphereSize.Slider)
	end

	-- Se alterar a bara atualizar o tamanho da bola
	sphereSize.OnValueChanged = function(self, value)
		if not initializedMenu then return end
		SetSphere(LocalPlayer(), value)
	end

	-- Foçar o slider para o valor certo ao criar o menu
	timer.Simple(0.3, function()
		if sphereSize:IsValid() then
			sphereSize:SetValue(GetConVar("advr_sphere_radius"):GetInt())
		end
	end)

	-- Controle das classes blacklisted
	-- -----------------------------------------------------------------------------------------------------------------

    blacklistMenu = vgui.Create("DListView", CPanel)
	blacklistMenu:SetPos(10, sphereSize:GetY() + sphereSize:GetTall() + menuMargin)
	blacklistMenu:SetSize(200, 300)
    blacklistMenu:AddColumn("Ignored Classes")

    for class, isBlacklisted in SortedPairs(ADVRBlacklist) do
		if isBlacklisted then
	        blacklistMenu:AddLine(class)
		end
    end

    blacklistMenu:SortByColumn(1, false)

	local removeFromBlacklistButton = vgui.Create("DButton", CPanel)
	removeFromBlacklistButton:SetText("Remove from the list")
	removeFromBlacklistButton:SetPos(10, blacklistMenu:GetY() + blacklistMenu:GetTall() + menuMargin)
	removeFromBlacklistButton:SetSize(145, 25)
	removeFromBlacklistButton.DoClick = function()
        local lines = blacklistMenu:GetSelected()

		for k, curLine in ipairs(lines) do
			net.Start("m4n0cr4zy.Change_Blacklist")
				net.WriteString(curLine:GetColumnText(1))
				net.WriteBool(false)
			net.SendToServer()
		end
	end

	local resetBlacklistButton = vgui.Create("DButton", CPanel)
	resetBlacklistButton:SetText("Reset")
	resetBlacklistButton:SetPos(10 + removeFromBlacklistButton:GetWide() + menuMargin, blacklistMenu:GetY() + blacklistMenu:GetTall() + menuMargin)
	resetBlacklistButton:SetSize(50, 25)
	resetBlacklistButton.DoClick = function()
		ResetBlacklist()

		blacklistMenu:Clear()

		for class, isBlacklisted in SortedPairs(ADVRBlacklist) do
			if isBlacklisted then
				blacklistMenu:AddLine(class)
			end
		end
	end

	-- Checkbox	para mostrar entidades sem modelo definido
	-- -----------------------------------------------------------------------------------------------------------------

	local checkBoxWeapons = vgui.Create("DCheckBoxLabel", CPanel)
	checkBoxWeapons:SetPos(10, removeFromBlacklistButton:GetY() + removeFromBlacklistButton:GetTall() + menuMargin)
	checkBoxWeapons:SetText("List weapons")
	checkBoxWeapons:SetConVar("advr_allow_weapons")
	checkBoxWeapons:SetDark(true)

	-- Checkbox	para permitir armas
	-- -----------------------------------------------------------------------------------------------------------------

	local checkBoxNoModel = vgui.Create("DCheckBoxLabel", CPanel)
	checkBoxNoModel:SetPos(10, checkBoxWeapons:GetY() + checkBoxWeapons:GetTall() + menuMargin)
	checkBoxNoModel:SetText("List entities without models")
	checkBoxNoModel:SetConVar("advr_allow_no_model")
	checkBoxNoModel:SetDark(true)

	-- Limpar todos os highlights
	-- -----------------------------------------------------------------------------------------------------------------

	local removeFromBlacklistButton = vgui.Create("DButton", CPanel)
	removeFromBlacklistButton:SetText("Cleanup Highlights")
	removeFromBlacklistButton:SetPos(10, checkBoxNoModel:GetY() + checkBoxNoModel:GetTall() * 3 + menuMargin)
	removeFromBlacklistButton:SetSize(200, 25)
	removeFromBlacklistButton.DoClick = ADVR_CleanupHighlights

	-- Algumas gambiarras para controlar a renderização da esfera
	timer.Simple(1, function()	
		initializedMenu = true -- evita que ToolSwaped seja chamado pelos menus
	end)
	if not usingTool then
		ToolSwaped(LocalPlayer(), true) -- Garanto que começo com a esfera ligada
	end
end

LoadBlacklist()
--gamemodes/starwarsrp/entities/weapons/gmod_tool/stools/selfmaterial.lua:

TOOL.Category = "CW:RP"
TOOL.Name = "Selbstmaterial"

TOOL.ClientConVar[ "override" ] = "debug/env_cubemap_model"

TOOL.Information = {
	{ name = "left" },
	{ name = "right" },
}

if (CLIENT) then
	language.Add("tool.selfmaterial.name", "Selbstmaterial")
	language.Add("tool.selfmaterial.desc", "Setze dir selbst ein Material")
	language.Add("tool.selfmaterial.left", "Setze dir selbst ein Material")
	language.Add("tool.selfmaterial.right", "Setze dein Material zurück")
end

--
-- Duplicator function
--
local function SetMaterial( Player, Entity, Data )

	if ( SERVER ) then

		--
		-- Make sure this is in the 'allowed' list in multiplayer - to stop people using exploits
		--
		if ( !game.SinglePlayer() && !list.Contains( "OverrideMaterials", Data.MaterialOverride ) && Data.MaterialOverride != "" ) then return end

		Entity:SetMaterial(Data.MaterialOverride)
		
		duplicator.StoreEntityModifier( Entity, "material", Data )	
		
	end

	return true

end
if ( SERVER ) then
	duplicator.RegisterEntityModifier( "material", SetMaterial )
end

-- Left click applies the current material
function TOOL:LeftClick( trace )

	local ent = self:GetOwner()
	if ( IsValid( ent.AttachedEntity ) ) then ent = ent.AttachedEntity end
	if ( !IsValid( ent )) then return false end -- The entity is valid and isn't worldspawn
	if ( CLIENT ) then return true end

	local mat = self:GetClientInfo( "override" )
	SetMaterial( self:GetOwner(), ent, { MaterialOverride = mat }, self_target)
	return true

end

-- Reload reverts the material
function TOOL:RightClick( trace )

	local ent = self:GetOwner()
	if ( IsValid( ent.AttachedEntity ) ) then ent = ent.AttachedEntity end
	if ( !IsValid( ent )) then return false end -- The entity is valid and isn't worldspawn
	if ( CLIENT ) then return true end

	SetMaterial( self:GetOwner(), ent, { MaterialOverride = "" })
	return true

end

list.Add( "OverrideMaterials", "models/wireframe" )
list.Add( "OverrideMaterials", "debug/env_cubemap_model" )
list.Add( "OverrideMaterials", "models/shadertest/shader3" )
list.Add( "OverrideMaterials", "models/shadertest/shader4" )
list.Add( "OverrideMaterials", "models/shadertest/shader5" )
list.Add( "OverrideMaterials", "models/shiny" )
list.Add( "OverrideMaterials", "models/debug/debugwhite" )
list.Add( "OverrideMaterials", "Models/effects/comball_sphere" )
list.Add( "OverrideMaterials", "Models/effects/comball_tape" )
list.Add( "OverrideMaterials", "Models/effects/splodearc_sheet" )
list.Add( "OverrideMaterials", "Models/effects/vol_light001" )
list.Add( "OverrideMaterials", "models/props_combine/stasisshield_sheet" )
list.Add( "OverrideMaterials", "models/props_combine/portalball001_sheet" )
list.Add( "OverrideMaterials", "models/props_combine/com_shield001a" )
list.Add( "OverrideMaterials", "models/props_c17/frostedglass_01a" )
list.Add( "OverrideMaterials", "models/props_lab/Tank_Glass001" )
list.Add( "OverrideMaterials", "models/props_combine/tprings_globe" )
list.Add( "OverrideMaterials", "models/rendertarget" )
list.Add( "OverrideMaterials", "models/screenspace" )
list.Add( "OverrideMaterials", "brick/brick_model" )
list.Add( "OverrideMaterials", "models/props_pipes/GutterMetal01a" )
list.Add( "OverrideMaterials", "models/props_pipes/Pipesystem01a_skin3" )
list.Add( "OverrideMaterials", "models/props_wasteland/wood_fence01a" )
list.Add( "OverrideMaterials", "models/props_foliage/tree_deciduous_01a_trunk" )
list.Add( "OverrideMaterials", "models/props_c17/FurnitureFabric003a" )
list.Add( "OverrideMaterials", "models/props_c17/FurnitureMetal001a" )
list.Add( "OverrideMaterials", "models/props_c17/paper01" )
list.Add( "OverrideMaterials", "models/flesh" )

-- phx
list.Add( "OverrideMaterials", "phoenix_storms/metalset_1-2" )
list.Add( "OverrideMaterials", "phoenix_storms/metalfloor_2-3" )
list.Add( "OverrideMaterials", "phoenix_storms/plastic" )
list.Add( "OverrideMaterials", "phoenix_storms/wood" )
list.Add( "OverrideMaterials", "phoenix_storms/bluemetal" )
list.Add( "OverrideMaterials", "phoenix_storms/cube" )
list.Add( "OverrideMaterials", "phoenix_storms/dome" )
list.Add( "OverrideMaterials", "phoenix_storms/gear" )
list.Add( "OverrideMaterials", "phoenix_storms/stripes" )
list.Add( "OverrideMaterials", "phoenix_storms/wire/pcb_green" )
list.Add( "OverrideMaterials", "phoenix_storms/wire/pcb_red" )
list.Add( "OverrideMaterials", "phoenix_storms/wire/pcb_blue" )

list.Add( "OverrideMaterials", "hunter/myplastic" )
list.Add( "OverrideMaterials", "models/XQM/LightLinesRed_tool" )

if ( IsMounted( "tf" ) ) then
	list.Add( "OverrideMaterials", "models/player/shared/gold_player" )
	list.Add( "OverrideMaterials", "models/player/shared/ice_player" )
end

function TOOL.BuildCPanel( CPanel )

	CPanel:AddControl( "Header", { Description = "#tool.material.help" } )

	local filter = CPanel:AddControl( "TextBox", { Label = "#spawnmenu.quick_filter_tool" } )
	filter:SetUpdateOnType( true )

	-- Remove duplicate materials. table.HasValue is used to preserve material order
	local materials = {}
	for id, str in ipairs( list.Get( "OverrideMaterials" ) ) do
		if ( !table.HasValue( materials, str ) ) then
			table.insert( materials, str )
		end
	end

	local matlist = CPanel:MatSelect( "selfmaterial_override", materials, true, 0.25, 0.25 )

	filter.OnValueChange = function( s, txt )
		for id, pnl in ipairs( matlist.Controls ) do
			if ( !pnl.Value:lower():find( txt:lower(), nil, true ) ) then
				pnl:SetVisible( false )
			else
				pnl:SetVisible( true )
			end
		end
		matlist:InvalidateChildren()
		CPanel:InvalidateChildren()
	end
end

--addons/vanilla-tools/lua/weapons/gmod_tool/stools/shipdestruction.lua:
-- Why hello there!

TOOL.Category		= "CW:RP"
TOOL.Name			= "Ship-Destruction"
TOOL.Command		= nil
TOOL.ConfigName		= ""

TOOL.AdminOnly		= true

if ( CLIENT ) then
    language.Add( "Tool.shipdestruction.name", "Ship-Destruction Tool" )
    language.Add( "Tool.shipdestruction.desc", "Zerstöre Schiffe!" )
    language.Add( "Tool.shipdestruction.left", "Wähle einen Prop oder Entity aus.")
end

TOOL.Information = {

    { name = "left" }

}

TOOL.ClientConVar[ "length" ] = "16"
TOOL.ClientConVar[ "explosize" ] = "1"
TOOL.ClientConVar[ "finalsize" ] = "5"
TOOL.ClientConVar[ "turnrate" ] = "0.06"
TOOL.ClientConVar[ "fallrate" ] = "5"
TOOL.ClientConVar[ "forwardrate" ] = "5"
TOOL.ClientConVar[ "flip" ] = "0"

function TOOL:LeftClick( trace )
    if (!trace.Entity) then return false end
    if (CLIENT) then return true end
    local ent = trace.Entity

    local ship = ents.Create("shipdestruction")
    ship:SetPos(ent:GetPos())
    ship:SetAngles(ent:GetAngles())
    ship:SetModel(ent:GetModel())
    ship:SetKeyValue("Length",self:GetClientInfo("length"))
    ship:SetKeyValue("ExplosionSize",self:GetClientInfo("explosize"))
    ship:SetKeyValue("FinalSize",self:GetClientInfo("finalsize"))
    ship:SetKeyValue("Flip",self:GetClientInfo("flip"))
    ship:SetKeyValue("TurnRate",self:GetClientInfo("turnrate"))
    ship:SetKeyValue("FallRate",self:GetClientInfo("fallrate"))
    ship:SetKeyValue("ForwardRate",self:GetClientInfo("forwardrate"))
    if ! util.IsValidModel(ent:GetModel()) then return end
    ship:Spawn()
    ent:Remove()

    undo.Create("Destruction")
        undo.AddEntity(ship)
        undo.SetCustomUndoText("Undone Ship Destruction")
        undo.SetPlayer(self:GetOwner())
    undo.Finish()

    return true
end

function TOOL:RightClick( trace )
end

function TOOL:Reload( trace )
end

function TOOL:Think()
end

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel(CPanel)
    CPanel:AddControl( "ComboBox", { MenuButton = 1, Folder = "shipdestruction_tool", Options = { [ "#preset.default" ] = ConVarsDefault }, CVars = table.GetKeys( ConVarsDefault ) } )

    CPanel:NumSlider("Destruction Length","shipdestruction_tool_length","1","120","1")
    CPanel:ControlHelp("Sets the length of the ship explosion. (in seconds)")

    CPanel:NumSlider("Explosion Size","shipdestruction_tool_explosize","0","5","0")
    CPanel:ControlHelp("Sets the standard explosion size.")

    CPanel:NumSlider("Final Explosion Size","shipdestruction_tool_finalsize","0","20","0")
    CPanel:ControlHelp("Sets the final explosion size.")

    CPanel:NumSlider("Tilt Rate","shipdestruction_tool_turnrate","0","1","2")
    CPanel:ControlHelp("Sets how fast the ship tilts down.")

    CPanel:NumSlider("Fall Rate","shipdestruction_tool_fallrate","0","10","0")
    CPanel:ControlHelp("Sets how fast the ship falls down.")

    CPanel:NumSlider("Forward Rate","shipdestruction_tool_forwardrate","0","10","0")
    CPanel:ControlHelp("Sets how fast the ship is moving forward")

    CPanel:CheckBox("Flip","shipdestruction_tool_flip")
    CPanel:ControlHelp("Tick if the ship is turning/moving in the wrong direction.")

end

--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/ballistic_shields/lua/ballistic_shields/sh_bs_lang.lua:
include( "ballistic_shields/sh_bs_util.lua" )

bshields.lang = {
	["German"] = {
		["sec"] = "[RMB] Unsichtbar/Sichtbar",
		["dshieldprim"] = "[LMB] Platzieren",
		["hshieldprim"] = "[LMB] Schlagen",
		["rshieldprim"] = "[LMB] Schlagen",
		["hshieldcd1"] = "Wait ",
		["hshieldcd2"] = " seconds to breach next door!"
	}
} 

if bshields.lang[bshields.config.language] == nil then
	bshields.config.language = "English"
end
--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/egm_tfa_weapons/lua/weapons/reciprocating_quad_blaster.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "Quad Blaster"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Heavy Blaster Cannon"
SWEP.Manufacturer           = "Heavy Pew Pew Megacorp"
SWEP.Slot                   = 3
SWEP.SlotPos                = 2

SWEP.Spawnable              = true

-- Model --

SWEP.ViewModel              = "models/twcustom/weapons/v_reciprocating_quad_blaster.mdl"
SWEP.WorldModel             = "models/twcustom/weapons/w_reciprocating_quad_blaster.mdl"

SWEP.HolsterOffset = Vector(2, 0, -15)
SWEP.HolsterAngle = Angle(90, 0, 180)

SWEP.ViewModelFOV = 56

SWEP.VMPos                  = Vector(0, 11, -5)
SWEP.VMAng                  = Vector(0, 0, 0)

SWEP.HoldType               = "duel"
SWEP.ReloadHoldTypeOverride = "duel"

SWEP.UseHands 				= true

SWEP.ShowWorldModel         = true

SWEP.VElements = {}

-- Tracer --

-- Tracer name
SWEP.TracerName             = "Cipe is doof"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize        = 600
-- Magazine Count
SWEP.Primary.DefaultClip    = SWEP.Primary.ClipSize * 4
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Auto"
}

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = {"swrp_am_training"}, order = 1 },
}

-- Automatic RPM
SWEP.Primary.RPM            = 300
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi		= nil

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 12000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage                 = 70

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 60 -- TODO

SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 7
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.0075
SWEP.Primary.IronAccuracy 			= 0.0048

SWEP.Primary.SpreadMultiplierMax 	= 4
SWEP.Primary.SpreadIncrement 		= 0.5

-- Aiming
SWEP.IronSightsPos = Vector(-0.0125, -1.5, 3.115)
SWEP.IronSightsAng = Vector(0.209, -0.38, 0)
-- Running
SWEP.RunSightsPos = Vector(0, 11, -5)
SWEP.RunSightsAng = Vector(0, 0, 0)
-- Inspecting
SWEP.InspectPos = Vector(0, 20, -20)
SWEP.InspectAng = Vector(30, 0, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound = Sound ("weapons/dc15a/DC15A_fire.ogg")
-- Reload Sound
SWEP.Primary.ReloadSound = Sound ("weapons/shared/standard_reload.ogg")

SWEP.MoveSpeed                         = 0.75
SWEP.IronSightsMoveSpeed               = 0.75

SWEP.TopBarrel = true
SWEP.AnimTime = CurTime()

if CLIENT then
	function SWEP:PlaceHandsOnGun()
		local leftElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_L_Forearm")
		self:GetOwner():ManipulateBoneAngles(leftElbow, Angle(20, -20, 0))

		local rightShoulder = self:GetOwner():LookupBone("ValveBiped.Bip01_R_UpperArm")
		self:GetOwner():ManipulateBoneAngles(rightShoulder, Angle(0, 15, 0))

		local rightElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_R_Forearm")
		self:GetOwner():ManipulateBoneAngles(rightElbow, Angle(-30, -40, 0))
	end

	function SWEP:ResetBoneAngles()
		local leftElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_L_Forearm")
		self:GetOwner():ManipulateBoneAngles(leftElbow, Angle(0, 0, 0))

		local rightShoulder = self:GetOwner():LookupBone("ValveBiped.Bip01_R_UpperArm")
		self:GetOwner():ManipulateBoneAngles(rightShoulder, Angle(0, 0, 0))

		local rightElbow = self:GetOwner():LookupBone("ValveBiped.Bip01_R_Forearm")
		self:GetOwner():ManipulateBoneAngles(rightElbow, Angle(0, 0, 0))
	end
end

function SWEP:Holster()
	if CLIENT then
		self:ResetBoneAngles()
	end

	return true
end

function SWEP:Deploy()
	if self:IsSafety() then
		self:GetOwner():GetViewModel():SendViewModelMatchingSequence(0)
	end
end

function SWEP:GetEffectShootPos()
	if self.TopBarrel then
		self.TopBarrel = false
		return self:GetBonePosition(self:LookupBone("barrel_top_right")), self:GetBonePosition(self:LookupBone("barrel_top_left"))
	else
		self.TopBarrel = true
		return self:GetBonePosition(self:LookupBone("barrel_bottom_right")), self:GetBonePosition(self:LookupBone("barrel_bottom_left"))
	end
end

function SWEP:GetFireModeName()
	local fm = self:GetFireMode()
	local fmn = string.lower( self:GetStat("FireModes")[fm] )
	if fmn == "safe" or fmn == "holster" then return "Safety" end
	if self:GetStat("FireModeName") then return self:GetStat("FireModeName") end
	if fmn == "auto" or fmn == "automatic" then return "Full-Auto" end
end

function SWEP:Anims()
end

function SWEP:ReloadTicker()
end

function SWEP:Reload()
end

function SWEP:DrawWorldModel()
	local owner = self:GetOwner()
	if IsValid(owner) then
		self:SetPoseParameter("head_pitch", owner:EyeAngles()[1])
		self:InvalidateBoneCache()
	end

	self:DrawModel()
end

function SWEP:Think2()
	local baseTable = weapons.GetStored("weapon_swrp_egm_base")
	baseTable.Think2(self)

	self:Anims()
	self:ReloadTicker()

	if SERVER then
		if self:GetOwner():KeyDown(IN_ATTACK) and not self:IsSafety() and CurTime() > self.AnimTime and self:Clip1() > 0 then
			self:SetSequence(5)
		end

		if self:GetOwner():KeyReleased(IN_ATTACK) and not self:IsSafety() and CurTime() > self.AnimTime or (self:Clip1() == 0 and not self:IsSafety()) then
			self:SetSequence(1)
		end

		if self:GetSequence() == 5 then
			self:SetCycle(math.min(self:GetCycle() + 5 * FrameTime(), 1))
		else
			self:SetCycle(math.min(self:GetCycle() + 0.5 * FrameTime(), 1))
		end

		if self:GetCycle() >= 1 and tonumber(self:GetSequence()) == 5 then
			self:SetCycle(0)
		end
	end
end

function SWEP:CycleSafety()
	if not IsFirstTimePredicted() and not game.SinglePlayer() then return end

	local fm = self:GetFireMode()
	local fmt = self:GetStat("FireModes")
	if fm ~= #fmt then
		self.LastFireMode = fm
		self:SetFireMode(#fmt)
	else
		self:SetFireMode(self.LastFireMode or 1)
	end
	self:EmitSound("Weapon_AR2.Empty")
	self.BurstCount = 0

	local vm = self:GetOwner():GetViewModel()

	if self:GetFireModeName() == "Safety" then
		if CLIENT then
			self:ResetBoneAngles()
		end
		self:SetHoldType("normal")
		self:SetSequence(3)
		self:SetCycle(0)
		vm:SendViewModelMatchingSequence(3)
		self.Anims = function()
			if CurTime() > self.AnimTime then
			self:SetSequence(0)
			vm:SendViewModelMatchingSequence(0)
			self.Anims = function() end
			end
		end
		self.ReloadWaitTime = CurTime()
		self.ReloadTicker = function()
			if self:IsSafety() then
				if CurTime() > self.ReloadWaitTime and self:Clip1() < self:GetMaxClip1() and self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoType()) > 0 then
					local ammo = math.Clamp(50, 0, self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoType()))
					ammo = math.random(40, 60)
					self:SetClip1(math.Clamp(self:Clip1() + ammo, 0, self:GetMaxClip1()))
					self:GetOwner():RemoveAmmo( ammo, self:GetPrimaryAmmoType() )
					if self:Clip1() == self:GetMaxClip1() then
						self.ReloadTicker = function() return end
					else
						self.ReloadWaitTime = CurTime() + 2.5
					end
				end
			else
				self.ReloadTicker = function() end
			end
		end
	else
		self.HoldType = "normal"
		self:SetSequence(2)
		self:SetCycle(0)
		vm:SendViewModelMatchingSequence(2)
		self.Anims = function()
			if CurTime() > self.AnimTime then
				self:SetSequence(1)
				self.HoldType = "duel"
				if CLIENT then
					self:PlaceHandsOnGun()
				end
				vm:SendViewModelMatchingSequence(1)
				self.Anims = function() end
			end
		end
	end
	self.AnimTime = CurTime() + 1.5
end

-- Create Custom Dual Barrel Effect
function SWEP:PostPrimaryAttack()
	local data

	local rightBarrel, leftBarrel = self:GetEffectShootPos()
	local tracerName = "rw_sw_laser_blue"
	if self:IsAttached("swrp_am_training") then
		tracerName = "rw_sw_laser_green"
	end

	data = EffectData()
	data:SetEntity(self)
	data:SetStart(rightBarrel)
	data:SetOrigin(self:GetOwner():GetEyeTrace().HitPos)
	util.Effect(tracerName, data)

	data = EffectData()
	data:SetEntity(self)
	data:SetStart(leftBarrel)
	data:SetOrigin(self:GetOwner():GetEyeTrace().HitPos)
	util.Effect(tracerName, data)
end
--addons/egm_tfa_weapons_zdisabled/lua/weapons/reciprocating_quad_blaster_red.lua:
-- Removed
--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/egm_tfa_grenades/lua/weapons/rw_sw_nade_bacta.lua:
SWEP.Base						= "tfa_ins2_nade_base"
SWEP.Category					= "SW:RP (Granaten)"
SWEP.Author						= "Rezurektion & ChanceSphere574"
SWEP.Type						= "Long-range healing"
SWEP.PrintName					= "Bacta Grenade"
SWEP.Slot						= 3
SWEP.SlotPos					= 100
SWEP.DrawAmmo					= true
SWEP.DrawWeaponInfoBox			= false
SWEP.BounceWeaponIcon   		= false
SWEP.DrawCrosshair				= false
SWEP.Weight						= 2
SWEP.AutoSwitchTo				= true
SWEP.AutoSwitchFrom				= true
SWEP.HoldType 					= "grenade"

SWEP.ViewModelFOV				= 70
SWEP.ViewModelFlip				= false
SWEP.ViewModel					= "models/weapons/tfa_ins2/v_f1.mdl"
SWEP.WorldModel					= "models/weapons/tfa_ins2/w_f1.mdl"
SWEP.ShowWorldModel				= false
SWEP.Spawnable					= true
SWEP.UseHands                   = true
SWEP.AdminSpawnable				= true


SWEP.Primary.Damage             = 7
SWEP.Primary.RPM				= 10
SWEP.Primary.ClipSize			= 1
SWEP.Primary.DefaultClip		= 1
SWEP.Primary.Automatic			= false
SWEP.DisableChambering 			= true
SWEP.Primary.Ammo				= "AlyxGun"
SWEP.Primary.Round 				= ("rw_sw_ent_nade_heal")
SWEP.Primary.Range 					= 800
SWEP.Velocity = 800
SWEP.Velocity_Underhand = 200
SWEP.Delay = 0.23
SWEP.DelayCooked = 0.24
SWEP.Delay_Underhand = 0.245
SWEP.CookStartDelay = 1
SWEP.UnderhandEnabled = true
SWEP.CookingEnabled = true
SWEP.CookTimer = 3.2

SWEP.ViewModelBoneMods = {
	["Spoon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Weapon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_Pull"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_2_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Weapon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	--["Spoon"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
}

SWEP.VElements = {
	["n"] = { type = "Model", model = "models/cs574/explosif/grenade_bacta.mdl", bone = "Weapon_F1", rel = "", pos = Vector(-0.9, 0.2, 1.3), angle = Angle(-10, 90, -25), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["n"] = { type = "Model", model = "models/cs574/explosif/grenade_bacta.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(03.2, 02, -0.5), angle = Angle(195, 0, 0), size = Vector(1.1, 1.1, 1.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.ProceduralHoslterEnabled   = true
SWEP.ProceduralHolsterTime      = 0.0
SWEP.ProceduralHolsterPos       = Vector(0, 0, 0)
SWEP.ProceduralHolsterAng       = Vector(0, 0, 0)


SWEP.Offset = {
	Pos = {
		Up = 0,
		Right = 1,
		Forward = 3,
	},
	Ang = {
		Up = -1,
		Right = -2,
		Forward = 178
	},
	Scale = 1
}

SWEP.InspectPos 				= Vector(-03,0,03)
SWEP.InspectAng 				= Vector(0,0,0)


SWEP.Sprint_Mode 				= TFA.Enum.LOCOMOTION_ANI

SWEP.SprintAnimation = {
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ,
		["value"] = "sprint",
		["is_idle"] = true
	}
}
--addons/egm_tfa_grenades/lua/weapons/rw_sw_nade_smoke_impact.lua:
SWEP.Base						= "tfa_ins2_nade_base"
SWEP.Category					= "SW:RP (Granaten)"
SWEP.Author						= "Miller"
SWEP.Type						= "Explode and create a smoke zone"
SWEP.PrintName					= "Impact Smoke Grenade"
SWEP.Slot						= 3
SWEP.SlotPos					= 100
SWEP.DrawAmmo					= true
SWEP.DrawWeaponInfoBox					= false
SWEP.BounceWeaponIcon   				= false
SWEP.DrawCrosshair				= false
SWEP.Weight						= 2
SWEP.AutoSwitchTo				= true
SWEP.AutoSwitchFrom				= true
SWEP.HoldType 					= "grenade"

SWEP.ViewModelFOV				= 70
SWEP.ViewModelFlip				= false
SWEP.ViewModel					= "models/weapons/tfa_ins2/v_f1.mdl"
SWEP.WorldModel					= "models/weapons/tfa_ins2/w_f1.mdl"
SWEP.ShowWorldModel				= false
SWEP.Spawnable					= true
SWEP.UseHands                   = true
SWEP.AdminSpawnable				= true

SWEP.Primary.Damage             = 0
SWEP.Primary.RPM				= 10
SWEP.Primary.ClipSize			= 1
SWEP.Primary.DefaultClip		= 1
SWEP.Primary.Automatic			= false
SWEP.DisableChambering 			= true
SWEP.Primary.Ammo				= "AlyxGun"
SWEP.Primary.Round 				= "rw_sw_ent_nade_smoke_impact"
SWEP.Primary.Range 				= 950
SWEP.Velocity 					= 950
SWEP.Velocity_Underhand 		= 400
SWEP.Delay 						= 0.23
SWEP.DelayCooked 				= 0.24
SWEP.Delay_Underhand 			= 0.245
SWEP.CookStartDelay 			= 1
SWEP.UnderhandEnabled 			= true
SWEP.CookingEnabled 			= true
SWEP.CookTimer 					= 3.2
SWEP.Primary.Force 				= 0
SWEP.Primary.Knockback 			= 0

SWEP.ViewModelBoneMods = {
	["Spoon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Weapon_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_Pull"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_2_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["Pin_F1"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["n"] = { type = "Model", model = "models/cs574/explosif/grenade_impact.mdl", bone = "Weapon_F1", rel = "", pos = Vector(-0.7, 0.2, 01.1), angle = Angle(10, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["n"] = { type = "Model", model = "models/cs574/explosif/grenade_impact.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(03, 02, -0.5), angle = Angle(0, 0, 80+90), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.ProceduralHoslterEnabled   = true
SWEP.ProceduralHolsterTime      = 0.0
SWEP.ProceduralHolsterPos       = Vector(0, 0, 0)
SWEP.ProceduralHolsterAng       = Vector(0, 0, 0)

SWEP.Offset = {
		Pos = {
		Up = 0,
		Right = 1,
		Forward = 3,
		},
		Ang = {
		Up = -1,
		Right = -2,
		Forward = 178
		},
	Scale = 1
}

SWEP.InspectPos 				= Vector(-03,0,03)
SWEP.InspectAng 				= Vector(0,0,0)


SWEP.Sprint_Mode 				= TFA.Enum.LOCOMOTION_ANI
SWEP.SprintAnimation = {
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ,
		["value"] = "sprint",
		["is_idle"] = true
	}
}
--addons/egm_tfa_grenades/lua/weapons/rw_sw_nade_thermal.lua:
SWEP.Base					= "tfa_ins2_nade_base"
SWEP.Category				= "SW:RP (Granaten)"
SWEP.Author					= "Gorka(Strasser) & ChanceSphere574"
SWEP.Type					= "Explode"
SWEP.PrintName				= "Thermal Grenade"
SWEP.Slot					= 3
SWEP.SlotPos				= 100
SWEP.DrawAmmo				= true
SWEP.DrawWeaponInfoBox		= false
SWEP.BounceWeaponIcon		= false
SWEP.DrawCrosshair			= false
SWEP.Weight					= 2
SWEP.AutoSwitchTo			= true
SWEP.AutoSwitchFrom			= true
SWEP.HoldType				= "grenade"

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/tfa_ins2/v_f1.mdl"
SWEP.WorldModel				= "models/weapons/tfa_ins2/w_f1.mdl"
SWEP.ShowWorldModel			= false
SWEP.Spawnable				=true
SWEP.UseHands				=true
SWEP.AdminSpawnable			=true

SWEP.Primary.Damage			=600
SWEP.Primary.RPM			=10
SWEP.Primary.ClipSize		=1
SWEP.Primary.DefaultClip	=1
SWEP.Primary.Automatic		=false
SWEP.DisableChambering		=true
SWEP.Primary.Ammo			="AlyxGun"
SWEP.Primary.Round			=("rw_sw_ent_nade_thermal")
SWEP.Primary.Range 					= 950
SWEP.Velocity				=950
SWEP.Velocity_Underhand		=400
SWEP.Delay					=0.23
SWEP.DelayCooked			=0.24
SWEP.Delay_Underhand		=0.245
SWEP.CookStartDelay			=1
SWEP.UnderhandEnabled		=true
SWEP.CookingEnabled			=true
SWEP.CookTimer				=3.2
SWEP.Primary.Force = 0
SWEP.Primary.Knockback = 0

SWEP.ViewModelBoneMods={
	["Spoon_F1"]={scale=Vector(0.009,0.009,0.009),pos=Vector(0,0,0),angle=Angle(0,0,0)},
	["Weapon_F1"]={scale=Vector(0.009,0.009,0.009),pos=Vector(0,0,0),angle=Angle(0,0,0)},
	["Pin_Pull"]={scale=Vector(0.009,0.009,0.009),pos=Vector(0,0,0),angle=Angle(0,0,0)},
	["Pin_2_F1"]={scale=Vector(0.009,0.009,0.009),pos=Vector(0,0,0),angle=Angle(0,0,0)},
	["Pin_F1"]={scale=Vector(0.009,0.009,0.009),pos=Vector(0,0,0),angle=Angle(0,0,0)},
	--["Weapon"]={scale=Vector(0.009,0.009,0.009),pos=Vector(0,0,0),angle=Angle(0,0,0)},
	--["Spoon"]={scale=Vector(0.009,0.009,0.009),pos=Vector(0,0,0),angle=Angle(0,0,0)},
}

SWEP.VElements={
	["n"]={type="Model",model="models/weapons/tfa_starwars/w_thermal.mdl",bone="Weapon_F1",rel="",pos=Vector(-0.7,0.2,01.1),angle=Angle(0,105,0),size=Vector(0.7,0.7,0.7),color=Color(255,255,255,255),surpresslightning=false,material="",skin=0,bodygroup={}},
}

SWEP.WElements={
	["n"]={type="Model",model="models/weapons/tfa_starwars/w_thermal.mdl",bone="ValveBiped.Bip01_R_Hand",rel="",pos=Vector(03,02,0),angle=Angle(0,180,180),size=Vector(0.9,0.9,0.9),color=Color(255,255,255,255),surpresslightning=false,material="",skin=0,bodygroup={}}
}

SWEP.ProceduralHoslterEnabled	=true
SWEP.ProceduralHolsterTime		=0.0
SWEP.ProceduralHolsterPos		=Vector(0,0,0)
SWEP.ProceduralHolsterAng		=Vector(0,0,0)

SWEP.Offset={
	Pos={
		Up=0,
		Right=1,
		Forward=3,
	},
	Ang={
		Up=-1,
		Right=-2,
		Forward=178
	},
	Scale=1
}

SWEP.InspectPos				=Vector(-03,0,03)
SWEP.InspectAng				=Vector(0,0,0)


SWEP.Sprint_Mode=TFA.Enum.LOCOMOTION_ANI
SWEP.SprintAnimation={
	["loop"]={
		["type"]=TFA.Enum.ANIMATION_SEQ,
		["value"]="sprint",
		["is_idle"]=true
	}
}
--addons/egm_tfa_weapons_zdisabled/lua/weapons/rw_sw_pinglauncher.lua:
-- Removed
--addons/tfa_base/lua/weapons/tfa_gun_base/shared.lua:
SWEP.Category = "" --The category.  Please, just choose something generic or something I've already done if you plan on only doing like one swep.
SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""
SWEP.DrawCrosshair = true
SWEP.DrawCrosshairIronSights = false
SWEP.ViewModelFOV = 65
SWEP.ViewModelFlip = false
SWEP.Skin = 0 --Viewmodel skin
SWEP.Spawnable = false
SWEP.IsTFAWeapon = true

SWEP.LoopedReload = false
SWEP.LoopedReloadInsertAmount = 1
SWEP.ShotgunEmptyAnim = false
SWEP.ShotgunEmptyAnim_Shell = true
SWEP.ShotgunStartAnimShell = false --shotgun start anim inserts shell

SWEP.Secondary.IronSightsEnabled = true
SWEP.Secondary.ScopeZoom = 1
SWEP.Secondary.ScopeScreenScale = 0.392592592592592

SWEP.RegularMoveSpeedMultiplier = 1

SWEP.FireSoundAffectedByClipSize = true

SWEP.Primary.Damage = -1
SWEP.Primary.DamageTypeHandled = true --true will handle damagetype in base
SWEP.Primary.NumShots = 1
SWEP.Primary.Force = -1
SWEP.Primary.Knockback = -1
SWEP.Primary.Recoil = 1
SWEP.Primary.RPM = 600
SWEP.Primary.RPM_Semi = -1
SWEP.Primary.RPM_Burst = -1
SWEP.Primary.StaticRecoilFactor = 0.5
SWEP.Primary.KickUp = 0.5
SWEP.Primary.KickDown = 0.5
SWEP.Primary.KickRight = 0.5
SWEP.Primary.KickHorizontal = 0.5
SWEP.Primary.DamageType = nil
SWEP.Primary.Ammo = "smg1"
SWEP.Primary.AmmoConsumption = 1
SWEP.Primary.Spread = 0
SWEP.Primary.DisplaySpread = true
SWEP.Primary.SpreadMultiplierMax = -1 --How far the spread can expand when you shoot.
SWEP.Primary.SpreadIncrement = -1 --What percentage of the modifier is added on, per shot.
SWEP.Primary.SpreadRecovery = -1 --How much the spread recovers, per second.
SWEP.Primary.SpreadRecoveryDelay = 0
SWEP.Primary.IronAccuracy = 0
SWEP.Primary.Range = -1--1200
SWEP.Primary.RangeFalloff = -1--0.5
SWEP.Primary.PenetrationMultiplier = 1
SWEP.Primary.DryFireDelay = nil

--[[Actual clientside values]]--

SWEP.DrawAmmo                       = true              -- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox              = false             -- Should draw the weapon info box
SWEP.BounceWeaponIcon               = false             -- Should the weapon icon bounce?

local sv_tfa_jamming = GetConVar("sv_tfa_jamming")
local sv_tfa_jamming_mult = GetConVar("sv_tfa_jamming_mult")
local sv_tfa_jamming_factor = GetConVar("sv_tfa_jamming_factor")
local sv_tfa_jamming_factor_inc = GetConVar("sv_tfa_jamming_factor_inc")

-- RP owners always like realism, so this feature might be something they like. Enable it for them!
TFA_AUTOJAMMING_ENABLED = string.find(engine.ActiveGamemode(), 'rp') or
	string.find(engine.ActiveGamemode(), 'roleplay') or
	string.find(engine.ActiveGamemode(), 'nutscript') or
	string.find(engine.ActiveGamemode(), 'serious') or
	TFA_ENABLE_JAMMING_BY_DEFAULT

SWEP.CanJam = tobool(TFA_AUTOJAMMING_ENABLED)

SWEP.JamChance = 0.04
SWEP.JamFactor = 0.06

SWEP.BoltAction = false --Unscope/sight after you shoot?
SWEP.BoltAction_Forced = false
SWEP.Scoped = false --Draw a scope overlay?
SWEP.ScopeOverlayThreshold = 0.875 --Percentage you have to be sighted in to see the scope.
SWEP.BoltTimerOffset = 0.25 --How long you stay sighted in after shooting, with a bolt action.
SWEP.ScopeScale = 0.5
SWEP.ReticleScale = 0.7

SWEP.MuzzleAttachment = "1"
SWEP.ShellAttachment = "2"

SWEP.MuzzleFlashEnabled = true
SWEP.MuzzleFlashEffect = nil
SWEP.MuzzleFlashEffectSilenced = "tfa_muzzleflash_silenced"
SWEP.CustomMuzzleFlash = true

SWEP.EjectionSmokeEnabled = true

SWEP.LuaShellEject = false
SWEP.LuaShellEjectDelay = 0
SWEP.LuaShellEffect = nil --Defaults to blowback

SWEP.SmokeParticle = nil --Smoke particle (ID within the PCF), defaults to something else based on holdtype

SWEP.StatusLengthOverride = {} --Changes the status delay of a given animation; only used on reloads.  Otherwise, use SequenceLengthOverride or one of the others
SWEP.SequenceLengthOverride = {} --Changes both the status delay and the nextprimaryfire of a given animation
SWEP.SequenceTimeOverride = {} --Like above but changes animation length to a target
SWEP.SequenceRateOverride = {} --Like above but scales animation length rather than being absolute

SWEP.BlowbackEnabled = false --Enable Blowback?
SWEP.BlowbackVector = Vector(0, -1, 0) --Vector to move bone <or root> relative to bone <or view> orientation.
SWEP.BlowbackCurrentRoot = 0 --Amount of blowback currently, for root
SWEP.BlowbackCurrent = 0 --Amount of blowback currently, for bones
SWEP.BlowbackBoneMods = nil --Viewmodel bone mods via SWEP Creation Kit
SWEP.Blowback_Only_Iron = true --Only do blowback on ironsights
SWEP.Blowback_PistolMode = false --Do we recover from blowback when empty?
SWEP.BlowbackAllowAnimation = false

SWEP.ProceduralHolsterEnabled = nil
SWEP.ProceduralHolsterTime = 0.3
SWEP.ProceduralHolsterPosition = Vector(3, 0, -5)
SWEP.ProceduralHolsterAngle = Vector(-40, -30, 10)

SWEP.IsProceduralReloadBased = false --Do we reload using lua instead of a .mdl animation
SWEP.ProceduralReloadTime = 1 --Time to take when procedurally reloading, including transition in (but not out)

SWEP.Blowback_PistolMode_Disabled = {
	[ACT_VM_RELOAD] = true,
	[ACT_VM_RELOAD_EMPTY] = true,
	[ACT_VM_DRAW_EMPTY] = true,
	[ACT_VM_IDLE_EMPTY] = true,
	[ACT_VM_HOLSTER_EMPTY] = true,
	[ACT_VM_DRYFIRE] = true,
	[ACT_VM_FIDGET] = true,
	[ACT_VM_FIDGET_EMPTY] = true
}

SWEP.Blowback_Shell_Enabled = true
SWEP.Blowback_Shell_Effect = "ShellEject"

SWEP.Secondary.Ammo = ""
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0

SWEP.Sights_Mode = TFA.Enum.LOCOMOTION_LUA -- ANI = mdl, HYBRID = lua but continue idle, Lua = stop mdl animation
SWEP.Sprint_Mode = TFA.Enum.LOCOMOTION_LUA -- ANI = mdl, HYBRID = ani + lua, Lua = lua only
SWEP.Walk_Mode = TFA.Enum.LOCOMOTION_LUA -- ANI = mdl, HYBRID = ani + lua, Lua = lua only
SWEP.Customize_Mode = TFA.Enum.LOCOMOTION_LUA -- ANI = mdl, HYBRID = ani + lua, Lua = lua only
SWEP.SprintFOVOffset = 5
SWEP.Idle_Mode = TFA.Enum.IDLE_BOTH --TFA.Enum.IDLE_DISABLED = no idle, TFA.Enum.IDLE_LUA = lua idle, TFA.Enum.IDLE_ANI = mdl idle, TFA.Enum.IDLE_BOTH = TFA.Enum.IDLE_ANI + TFA.Enum.IDLE_LUA
SWEP.Idle_Blend = 0.25 --Start an idle this far early into the end of a transition
SWEP.Idle_Smooth = 0.05 --Start an idle this far early into the end of another animation

SWEP.IronSightTime = 0.3
SWEP.IronSightsSensitivity = 1

SWEP.InspectPosDef = Vector(9.779, -11.658, -2.241)
SWEP.InspectAngDef = Vector(24.622, 42.915, 15.477)

SWEP.SprintViewModelPosition = Vector(0,0,0)
SWEP.SprintViewModelAngle = Vector(0,0,0)
SWEP.AllowSprintAttack = false --Shoot while sprinting?

SWEP.CrouchViewModelPosition = Vector(0, -1, -.5)
SWEP.CrouchViewModelAngle = Vector(0, 0, 0)

SWEP.Primary.RecoilLUT_IronSightsMult = 0.5
SWEP.Primary.RecoilLUT_AnglePunchMult = 0.25
SWEP.Primary.RecoilLUT_ViewPunchMult = 1

SWEP.EventTable = {}

SWEP.RTMaterialOverride = nil
SWEP.RTOpaque = false
SWEP.RTCode = nil--function(self) return end
SWEP.RTBGBlur = true

SWEP.ViewModelPosition = Vector(0,0,0)
SWEP.ViewModelAngle = Vector(0,0,0)
SWEP.CameraOffset = Angle(0, 0, 0)
SWEP.AdditiveViewModelPosition = true

SWEP.AllowIronSightsDoF = true

SWEP.Primary.DisplayFalloff = true

SWEP.IronAnimation = {
	--[[
	["in"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "Idle_To_Iron", --Number for act, String/Number for sequence
		["value_empty"] = "Idle_To_Iron_Dry",
		["transition"] = true
	}, --Inward transition
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "Idle_Iron", --Number for act, String/Number for sequence
		["value_empty"] = "Idle_Iron_Dry"
	}, --Looping Animation
	["out"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "Iron_To_Idle", --Number for act, String/Number for sequence
		["value_empty"] = "Iron_To_Idle_Dry",
		["transition"] = true
	}, --Outward transition
	["shoot"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "Fire_Iron", --Number for act, String/Number for sequence
		["value_last"] = "Fire_Iron_Last",
		["value_empty"] = "Fire_Iron_Dry"
	} --What do you think
	]]--
}

SWEP.SprintAnimation = {
	--[[
	["in"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "Idle_to_Sprint", --Number for act, String/Number for sequence
		["value_empty"] = "Idle_to_Sprint_Empty",
		["transition"] = true
	}, --Inward transition
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "Sprint_", --Number for act, String/Number for sequence
		["value_empty"] = "Sprint_Empty_",
		["is_idle"] = true
	},--looping animation
	["out"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "Sprint_to_Idle", --Number for act, String/Number for sequence
		["value_empty"] = "Sprint_to_Idle_Empty",
		["transition"] = true
	} --Outward transition
	]]--
}

SWEP.ShootAnimation = {--[[
	["in"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "shoot_loop_start", --Number for act, String/Number for sequence
		["value_is"] = "shoot_loop_iron_start"
	},
	["loop"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "shoot_loop", --Number for act, String/Number for sequence
		["value_is"] = "shoot_loop_iron",
		["is_idle"] = true
	},
	["out"] = {
		["type"] = TFA.Enum.ANIMATION_SEQ, --Sequence or act
		["value"] = "shoot_loop_end", --Number for act, String/Number for sequence
		["value_is"] = "shoot_loop_iron_end"
	}]]--
}

SWEP.FirstDeployEnabled = nil--Force first deploy enabled

--[[Dont edit under this unless you know what u r doing]]

SWEP.IronSightsProgress = 0
SWEP.CLIronSightsProgress = 0
SWEP.SprintProgress = 0
SWEP.WalkProgress = 0
SWEP.SpreadRatio = 0
SWEP.CrouchingRatio = 0
SWEP.SmokeParticles = {
	pistol = "tfa_ins2_weapon_muzzle_smoke",
	smg = "tfa_ins2_weapon_muzzle_smoke",
	grenade = "tfa_ins2_weapon_muzzle_smoke",
	ar2 = "tfa_ins2_weapon_muzzle_smoke",
	shotgun = "tfa_ins2_weapon_muzzle_smoke",
	rpg = "tfa_ins2_weapon_muzzle_smoke",
	physgun = "tfa_ins2_weapon_muzzle_smoke",
	crossbow = "tfa_ins2_weapon_muzzle_smoke",
	melee = "tfa_ins2_weapon_muzzle_smoke",
	slam = "tfa_ins2_weapon_muzzle_smoke",
	normal = "tfa_ins2_weapon_muzzle_smoke",
	melee2 = "tfa_ins2_weapon_muzzle_smoke",
	knife = "tfa_ins2_weapon_muzzle_smoke",
	duel = "tfa_ins2_weapon_muzzle_smoke",
	camera = "tfa_ins2_weapon_muzzle_smoke",
	magic = "tfa_ins2_weapon_muzzle_smoke",
	revolver = "tfa_ins2_weapon_muzzle_smoke",
	silenced = "tfa_ins2_weapon_muzzle_smoke"
}
--[[ SWEP.SmokeParticles = {
	pistol = "weapon_muzzle_smoke",
	smg = "weapon_muzzle_smoke",
	grenade = "weapon_muzzle_smoke",
	ar2 = "weapon_muzzle_smoke",
	shotgun = "weapon_muzzle_smoke_long",
	rpg = "weapon_muzzle_smoke_long",
	physgun = "weapon_muzzle_smoke_long",
	crossbow = "weapon_muzzle_smoke_long",
	melee = "weapon_muzzle_smoke",
	slam = "weapon_muzzle_smoke",
	normal = "weapon_muzzle_smoke",
	melee2 = "weapon_muzzle_smoke",
	knife = "weapon_muzzle_smoke",
	duel = "weapon_muzzle_smoke",
	camera = "weapon_muzzle_smoke",
	magic = "weapon_muzzle_smoke",
	revolver = "weapon_muzzle_smoke_long",
	silenced = "weapon_muzzle_smoke"
}--]]
--[[
SWEP.SmokeParticles = {
	pistol = "smoke_trail_controlled",
	smg = "smoke_trail_tfa",
	grenade = "smoke_trail_tfa",
	ar2 = "smoke_trail_tfa",
	shotgun = "smoke_trail_wild",
	rpg = "smoke_trail_tfa",
	physgun = "smoke_trail_tfa",
	crossbow = "smoke_trail_tfa",
	melee = "smoke_trail_tfa",
	slam = "smoke_trail_tfa",
	normal = "smoke_trail_tfa",
	melee2 = "smoke_trail_tfa",
	knife = "smoke_trail_tfa",
	duel = "smoke_trail_tfa",
	camera = "smoke_trail_tfa",
	magic = "smoke_trail_tfa",
	revolver = "smoke_trail_tfa",
	silenced = "smoke_trail_controlled"
}
]]--

SWEP.Inspecting = false
SWEP.InspectingProgress = 0
SWEP.LuaShellRequestTime = -1
SWEP.BobScale = 0
SWEP.SwayScale = 0
SWEP.BoltDelay = 1
SWEP.ProceduralHolsterProgress = 0
SWEP.BurstCount = 0
SWEP.DefaultFOV = 90
SWEP.m_WeaponDeploySpeed = 255

--[[ Localize Functions  ]]
local function l_Lerp(v, f, t)
	return f + (t - f) * v
end
local l_mathApproach = math.Approach
local l_CT = CurTime
--[[Frequently Reused Local Vars]]
local stat --Weapon status
local ct  = 0--Curtime, frametime, real frametime
local sp = game.SinglePlayer() --Singleplayer
local developer = GetConVar("developer")

function SWEP:NetworkVarTFA(typeIn, nameIn)
	if not self.TrackedDTTypes then
		self.TrackedDTTypes = {
			Angle = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},
			Bool = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},
			Entity = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},
			Float = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},
			Int = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},
			String = {0, 1, 2, 3},
			Vector = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},
		}

		if istable(self.dt) then
			local meta = getmetatable(self.dt)

			if istable(meta) and isfunction(meta.__index) then
				local name, value = debug.getupvalue(meta.__index, 1)

				if name == "datatable" and istable(value) then
					for variableName, variableData in SortedPairs(value) do
						if istable(variableData) and isstring(variableData.typename) and isnumber(variableData.index) then
							local trackedData = self.TrackedDTTypes[variableData.typename]

							if trackedData then
								table.RemoveByValue(trackedData, variableData.index)
							end
						end
					end
				end
			end
		end
	end

	if not self.TrackedDTTypes[typeIn] then
		error("Variable type " .. typeIn .. " is invalid")
	end

	local gatherindex = table.remove(self.TrackedDTTypes[typeIn], 1)

	if gatherindex then
		(self["NetworkVar_TFA"] or self["NetworkVar"])(self, typeIn, gatherindex, nameIn)
		return
	end

	local get = self["GetNW2" .. typeIn]
	local set = self["SetNW2" .. typeIn]

	self["Set" .. nameIn] = function(_self, value)
		set(_self, nameIn, value)
	end

	self["Get" .. nameIn] = function(_self, def)
		return get(_self, nameIn, def)
	end

	if developer:GetBool() then
		print("[TFA Base] developer 1: Variable " .. nameIn .. " can not use DTVars due to " .. typeIn .. " index exhaust")
	end
end

--[[
Function Name:  SetupDataTables
Syntax: Should not be manually called.
Returns:  Nothing.  Simple sets up DTVars to be networked.
Purpose:  Networking.
]]
function SWEP:SetupDataTables()
	self.TrackedDTTypes = nil
	self.NetworkVar_TFA = self.NetworkVar

	--self:NetworkVarTFA("Bool", "IronSights")
	self:NetworkVarTFA("Bool", "IronSightsRaw")
	self:NetworkVarTFA("Bool", "Sprinting")
	self:NetworkVarTFA("Bool", "Silenced")
	self:NetworkVarTFA("Bool", "ReloadLoopCancel")
	self:NetworkVarTFA("Bool", "Walking")
	self:NetworkVarTFA("Bool", "Customizing")

	self.GetShotgunCancel = self.GetReloadLoopCancel
	self.SetShotgunCancel = self.SetReloadLoopCancel

	self:NetworkVarTFA("Bool", "FlashlightEnabled")
	self:NetworkVarTFA("Bool", "Jammed")
	self:NetworkVarTFA("Bool", "FirstDeployEvent")
	self:NetworkVarTFA("Bool", "IsCyclingSafety")
	self:NetworkVarTFA("Bool", "SafetyCycleAnimated")
	self:NetworkVarTFA("Bool", "HasPlayedEmptyClick")

	self:NetworkVarTFA("Float", "StatusEnd")
	self:NetworkVarTFA("Float", "NextIdleAnim")
	self:NetworkVarTFA("Float", "NextLoopSoundCheck")
	self:NetworkVarTFA("Float", "JamFactor")
	self:NetworkVarTFA("Float", "EventTimer")
	self:NetworkVarTFA("Float", "LastGunFire")

	self:NetworkVarTFA("Int", "StatusRaw")
	self:NetworkVarTFA("Int", "FireMode")
	self:NetworkVarTFA("Int", "LastActivity")
	self:NetworkVarTFA("Int", "BurstCount")
	self:NetworkVarTFA("Int", "ShootStatus")
	self:NetworkVarTFA("Int", "EventStatus1")
	self:NetworkVarTFA("Int", "EventStatus2")
	self:NetworkVarTFA("Int", "EventStatus3")
	self:NetworkVarTFA("Int", "EventStatus4")
	self:NetworkVarTFA("Int", "EventStatus5")
	self:NetworkVarTFA("Int", "EventStatus6")
	self:NetworkVarTFA("Int", "EventStatus7")
	self:NetworkVarTFA("Int", "EventStatus8")

	self:NetworkVarTFA("Bool", "RecoilLoop")
	self:NetworkVarTFA("Bool", "RecoilThink")

	self:NetworkVarTFA("Float", "RecoilInProgress")
	self:NetworkVarTFA("Float", "RecoilInWait")
	self:NetworkVarTFA("Float", "RecoilLoopProgress")
	self:NetworkVarTFA("Float", "RecoilLoopWait")
	self:NetworkVarTFA("Float", "RecoilOutProgress")

	if not self.get_event_status_lut then
		self.get_event_status_lut = {}
		self.set_event_status_lut = {}

		for i = 1, 8 do
			self.get_event_status_lut[i] = self['GetEventStatus' .. i]
			self.set_event_status_lut[i] = self['SetEventStatus' .. i]
		end
	end

	self:NetworkVarTFA("Entity", "SwapTarget")

	self:NetworkVarNotify("Customizing", self.CustomizingUpdated)

	self:NetworkVarTFA("Float", "SpreadRatio")
	self:NetworkVarTFA("Float", "IronSightsProgress")
	self:NetworkVarTFA("Float", "ProceduralHolsterProgress")
	self:NetworkVarTFA("Float", "InspectingProgress")
	self:NetworkVarTFA("Float", "JumpRatio")
	self:NetworkVarTFA("Float", "CrouchingRatio")

	self:NetworkVarTFA("Float", "ViewPunchBuild")
	self:NetworkVarTFA("Float", "ViewPunchP")
	self:NetworkVarTFA("Float", "ViewPunchY")

	self:NetworkVarTFA("Float", "SprintProgress")
	self:NetworkVarTFA("Float", "WalkProgress")
	self:NetworkVarTFA("Float", "LastVelocity")

	self:NetworkVarTFA("Int", "AnimCycle")

	self:NetworkVarTFA("Vector", "QueuedRecoil")
	self:NetworkVarTFA("Float", "PrevRecoilAngleTime")
	self:NetworkVarTFA("Angle", "PrevRecoilAngle")

	self:NetworkVarTFA("Bool", "CustomizeUpdated")
	self:NetworkVarTFA("Bool", "IronSightsOldFinal")

	function self.NetworkVar(self2, typeIn, slotIn, nameIn)
		return self2:NetworkVarTFA(typeIn, nameIn)
	end

	self:NetworkVarTFA("Float", "StatusStart")
	self:NetworkVarTFA("Float", "LastSafetyShoot")

	self:NetworkVarTFA("Int", "LastSequence")
	self:NetworkVarTFA("Int", "DownButtons")
	self:NetworkVarTFA("Int", "LastPressedButtons")

	self:NetworkVarTFA("Float", "LastReloadPressed")

	self:NetworkVarTFA("Float", "LastIronSightsPressed")

	self.GetStatus = self.GetStatusRaw
	self.GetIronSights = self.GetIronSightsOldFinal
	self.GetIronSightsDirect = self.GetIronSightsOldFinal

	self:NetworkVarTFA("Bool", "IsFirstDeploy")
	self:NetworkVarTFA("Float", "LastDeployAnim")

	hook.Run("TFA_SetupDataTables", self)
end

function SWEP:GetStatusProgress(unpredicted)
	if self:GetStatus() == TFA.Enum.STATUS_IDLE then return 1 end
	local StatusStart = self:GetStatusStart()

	if StatusStart <= 0 then return end
	local StatusEnd = self:GetStatusEnd()

	if StatusStart > StatusEnd then return 1 end

	local time = unpredicted and (l_CT() + (self.CurTimePredictionAdvance or 0)) or l_CT()
	if StatusStart >= time then return 0 end
	if StatusEnd <= time then return 1 end

	return (time - StatusStart) / (StatusEnd - StatusStart)
end

function SWEP:GetStatusProgressTime(unpredicted)
	if self:GetStatus() == TFA.Enum.STATUS_IDLE then return 0 end
	local StatusStart = self:GetStatusStart()

	if StatusStart <= 0 then return end
	local StatusEnd = self:GetStatusEnd()

	if StatusStart > StatusEnd then return 0 end

	local time = unpredicted and (l_CT() + (self.CurTimePredictionAdvance or 0)) or l_CT()
	if StatusEnd <= time then return 0 end

	return StatusEnd - time
end

function SWEP:SetStatus(statusIn, timeOn)
	self:SetStatusRaw(statusIn)
	self:SetStatusStart(l_CT())

	if timeOn ~= nil then
		self:SetStatusEnd(timeOn)
	end
end

function SWEP:ScheduleStatus(statusIn, timeFor)
	self:SetStatusRaw(statusIn)
	local time = l_CT()
	self:SetStatusStart(time)
	self:SetStatusEnd(time + timeFor)
end

function SWEP:ExtendStatus(timeFor)
	self:SetStatusEnd(self:GetStatusEnd() + timeFor)
end

function SWEP:ExtendStatusTo(timeFor)
	self:SetStatusEnd(math.max(self:GetStatusEnd(), timeFor))
end

--[[
Function Name:  Initialize
Syntax: Should not be normally called.
Notes:   Called after actual SWEP code, but before deploy, and only once.
Returns:  Nothing.  Sets the intial values for the SWEP when it's created.
Purpose:  Standard SWEP Function
]]

local PistolHoldTypes = {
	["pistol"] = true,
	["357"] = true,
	["revolver"] = true
}
local MeleeHoldTypes = {
	["melee"] = true,
	["melee2"] = true,
	["knife"] = true
}

local patch_blacklist

do
	local string_sub = string.sub

	function patch_blacklist(input, structure_version)
		local target = {}

		for key in pairs(input) do
			target[TFA.RemapStatPath(key, TFA.LatestDataVersion, structure_version)] = true
		end

		table.Empty(input)

		setmetatable(input, {
			__index = target,
			__newindex = function(_, key, value)
				target[TFA.RemapStatPath(key, TFA.LatestDataVersion, structure_version)] = value
			end
		})

		return target
	end
end

function SWEP:Initialize()
	local self2 = self:GetTable()

	if self2.HasInitialized then
		ErrorNoHalt(debug.traceback("SWEP:Initialize was called out of order", 2) .. "\n")
		return
	end

	self2.HasInitialized = true

	--TFA.MigrateStructure(self, self2, self:GetClass(), true)

	hook.Run("TFA_PreInitialize", self)

	self2.DrawCrosshairDefault = self2.DrawCrosshair

	if not self2.BobScaleCustom or self2.BobScaleCustom <= 0 then
		self2.BobScaleCustom = 1
	end

	TFA.UnfoldBaseClass(self2.Primary)
	TFA.UnfoldBaseClass(self2.Secondary)

	TFA.UnfoldBaseClass(self2.Primary.PenetrationMaterials)

	TFA.UnfoldBaseClass(self2.AttachmentTableOverride)

	--[[for k, v in pairs(self2.AttachmentTableOverride) do
		if istable(v) and k ~= "BaseClass" then
			TFA.MigrateStructure(self, v, self:GetClass(), false)
		end
	end]]

	self2.Primary.BaseClass = nil
	self2.Secondary.BaseClass = nil

	if self2.Primary.DisplayIronSpread == nil then
		self2.Primary.DisplayIronSpread = self2.Primary.DisplaySpread
	end

	self2.Primary_TFA = table.Copy(self2.Primary)
	self2.Secondary_TFA = table.Copy(self2.Secondary)

	self2.BobScale = 0
	self2.SwayScaleCustom = 1
	self2.SwayScale = 0
	self2.SetSilenced(self, self2.Silenced or self2.DefaultSilenced)
	self2.Silenced = self2.Silenced or self2.DefaultSilenced
	self2.InitializeAnims(self)
	self2.InitializeMaterialTable(self)

	self2.RunAutoDetection(self)

	table.Merge(self2.Primary, self2.Primary_TFA)
	table.Merge(self2.Secondary, self2.Secondary_TFA)

	TFA.UnfoldBaseClass(self2.StatCache_Blacklist)
	self2.StatCache_Blacklist_Real = patch_blacklist(self2.StatCache_Blacklist, self2.TFADataVersion)

	TFA.UnfoldBaseClass(self2.Attachments)
	TFA.UnfoldBaseClass(self:GetStatRaw("ViewModelElements", TFA.LatestDataVersion))
	TFA.UnfoldBaseClass(self2.ViewModelBoneMods)
	TFA.UnfoldBaseClass(self2.EventTable)

	TFA.UnfoldBaseClass(self2.Blowback_PistolMode_Disabled)
	TFA.UnfoldBaseClass(self2.IronAnimation)
	TFA.UnfoldBaseClass(self2.SprintAnimation)
	TFA.UnfoldBaseClass(self2.ShootAnimation)
	TFA.UnfoldBaseClass(self2.SmokeParticles)

	self2.ClearStatCache(self)

	self2.InitAttachments(self)

	self2.WorldModelBodygroups = self:GetStatRawL("WorldModelBodygroups")
	self2.ViewModelBodygroups = self:GetStatRawL("ViewModelBodygroups")

	if not self:GetStatRawL("AimingDownSightsSpeedMultiplier") then
		self:SetStatRawL("AimingDownSightsSpeedMultiplier", self:GetStatRawL("RegularMoveSpeedMultiplier") * 0.8)
	end

	if isnumber(self2.GetStatL(self, "Skin")) then
		self:SetSkin(self:GetStatL("Skin"))
	end

	self:ResetAnimCycle()
	self:ResetFirstDeploy()

	self:SetNextLoopSoundCheck(-1)
	self:SetShootStatus(TFA.Enum.SHOOT_IDLE)

	if SERVER and self:GetOwner():IsNPC() then
		local seq = self:GetOwner():LookupSequence("shootp1")

		if MeleeHoldTypes[self2.DefaultHoldType or self2.HoldType] then
			if self:GetOwner():GetSequenceName(seq) == "shootp1" then
				self:SetWeaponHoldType("melee2")
			else
				self:SetWeaponHoldType("melee")
			end
		elseif PistolHoldTypes[self2.DefaultHoldType or self2.HoldType] then
			if self:GetOwner():GetSequenceName(seq) == "shootp1" then
				self:SetWeaponHoldType("pistol")
			else
				self:SetWeaponHoldType("smg")
			end
		else
			self:SetWeaponHoldType(self2.DefaultHoldType or self2.HoldType)
		end

		if self:GetOwner():GetClass() == "npc_citizen" then
			self:GetOwner():Fire( "DisableWeaponPickup", "", 0 )
		end

		self:GetOwner():SetKeyValue("spawnflags", "256")

		return
	end

	hook.Run("TFA_Initialize", self)
end

function SWEP:NPCWeaponThinkHook()
	local self2 = self:GetTable()

	if not self:GetOwner():IsNPC() then
		hook.Remove("TFA_NPCWeaponThink", self)
		return
	end

	self2.Think(self)
end

--[[
Function Name:  Deploy
Syntax: self:Deploy()
Notes:  Called after self:Initialize().  Called each time you draw the gun.  This is also essential to clearing out old networked vars and resetting them.
Returns:  True/False to allow quickswitch.  Why not?  You should really return true.
Purpose:  Standard SWEP Function
]]

function SWEP:Deploy()
	local self2 = self:GetTable()
	hook.Run("TFA_PreDeploy", self)
	local ply = self:GetOwner()

	self2.IsNPCOwned = ply:IsNPC()

	if IsValid(ply) and IsValid(ply:GetViewModel()) then
		self2.OwnerViewModel = ply:GetViewModel()
	end

	if SERVER and self:GetStatL("FlashlightAttachment", 0) > 0 and IsValid(ply) and ply:IsPlayer() and ply:FlashlightIsOn() then
		if not self:GetFlashlightEnabled() then
			self:ToggleFlashlight(true)
		end

		ply:Flashlight(false)
	end

	if IsValid(ply) and ply:IsPlayer() then
		if CLIENT then
			self:ResetKeyBindHintAlpha()
		elseif sp then
			self:CallOnClient("ResetKeyBindHintAlpha")
		end
	end

	ct = l_CT()

	if not self2.VMIV(self) then
		print("Invalid VM on owner: ")
		print(ply)

		return
	end

	if not self2.HasDetectedValidAnimations then
		self:CacheAnimations()
	end

	local _, tanim, ttype = self:ChooseDrawAnim()

	if sp then
		self:CallOnClient("ChooseDrawAnim", "")
	end

	local len = self:GetActivityLength(tanim, false, ttype)

	self:ScheduleStatus(TFA.Enum.STATUS_DRAW, len)
	self:SetFirstDeployEvent(true)

	self:SetNextPrimaryFire(ct + len)
	self:SetIronSightsRaw(false)

	if not self:GetStatL("PumpAction") then
		self:SetReloadLoopCancel( false )
	end

	self:SetBurstCount(0)

	self:SetIronSightsProgress(0)
	self:SetSprintProgress(0)
	self:SetInspectingProgress(0)
	self:SetProceduralHolsterProgress(0)

	if self:GetCustomizing() then
		self:ToggleCustomize()
	end

	self2.DefaultFOV = TFADUSKFOV or ( IsValid(ply) and ply:GetFOV() or 90 )

	self:ApplyViewModelModifications()
	self:CallOnClient("ApplyViewModelModifications")

	local v = hook.Run("TFA_Deploy", self)

	if v ~= nil then return v end

	return true
end

--[[
Function Name:  Holster
Syntax: self:Holster( weapon entity to switch to )
Notes:  This is kind of broken.  I had to manually select the new weapon using ply:ConCommand.  Returning true is simply not enough.  This is also essential to clearing out old networked vars and resetting them.
Returns:  True/False to allow holster.  Useful for animations.
Purpose:  Standard SWEP Function
]]
function SWEP:Holster(target)
	local self2 = self:GetTable()

	local v = hook.Run("TFA_PreHolster", self, target)
	if v ~= nil then return v end

	if not IsValid(target) then
		self2.InspectingProgress = 0

		return true
	end

	if not IsValid(self) then return end
	ct = l_CT()
	stat = self:GetStatus()

	if not TFA.Enum.HolsterStatus[stat] then
		if stat == TFA.Enum.STATUS_RELOADING_WAIT and self:Clip1() <= self:GetStatL("Primary.ClipSize") and (not self:GetStatL("Primary.DisableChambering")) and (not self:GetStatL("LoopedReload")) then
			self:ResetFirstDeploy()

			if sp then
				self:CallOnClient("ResetFirstDeploy", "")
			end
		end

		local success, tanim, ttype = self:ChooseHolsterAnim()

		if IsFirstTimePredicted() then
			self:SetSwapTarget(target)
		end

		self:ScheduleStatus(TFA.Enum.STATUS_HOLSTER, success and self:GetActivityLength(tanim, false, ttype) or (self:GetStatL("ProceduralHolsterTime") / self:GetAnimationRate(ACT_VM_HOLSTER)))

		return false
	elseif stat == TFA.Enum.STATUS_HOLSTER_READY or stat == TFA.Enum.STATUS_HOLSTER_FINAL then
		self:ResetViewModelModifications()

		if IsValid(target) and target:IsWeapon() and not target.IsTFAWeapon then
			if CLIENT then
				self:ResetKeyBindHintAlpha(true)
			elseif sp then
				self:CallOnClient("ResetKeyBindHintAlpha", "true")
			end
		end

		return true
	end
end

function SWEP:FinishHolster()
	local self2 = self:GetTable()

	self:CleanParticles()

	local v2 = hook.Run("TFA_Holster", self)

	if self:GetOwner():IsNPC() then return end
	if v2 ~= nil then return v2 end

	if SERVER then
		local ent = self:GetSwapTarget()
		self:Holster(ent)

		if IsValid(ent) and ent:IsWeapon() then
			self:GetOwner():SelectWeapon(ent:GetClass())

			if ent.IsTFAWeapon then
				ent:ApplyViewModelModifications()
				ent:CallOnClient("ApplyViewModelModifications")
			end

			self2.OwnerViewModel = nil
		end
	end
end

--[[
Function Name:  OnRemove
Syntax: self:OnRemove()
Notes:  Resets bone mods and cleans up.
Returns:  Nil.
Purpose:  Standard SWEP Function
]]
function SWEP:OnRemove()
	local self2 = self:GetTable()

	if self2.CleanParticles then
		self2.CleanParticles(self)
	end

	if self2.ResetViewModelModifications then
		self2.ResetViewModelModifications(self)
	end

	return hook.Run("TFA_OnRemove", self)
end

--[[
Function Name:  OnDrop
Syntax: self:OnDrop()
Notes:  Resets bone mods and cleans up.
Returns:  Nil.
Purpose:  Standard SWEP Function
]]
function SWEP:OnDrop()
	local self2 = self:GetTable()

	if self2.CleanParticles then
		self2.CleanParticles(self)
	end

	-- if self2.ResetViewModelModifications then
	--  self:ResetViewModelModifications()
	-- end

	return hook.Run("TFA_OnDrop", self)
end

function SWEP:OwnerChanged() -- TODO: sometimes not called after switching weapon ???
	if not IsValid(self:GetOwner()) and self.ResetViewModelModifications then
		self:ResetViewModelModifications()
	end

	if SERVER then
		if self.IsNPCOwned and (not IsValid(self:GetOwner()) or not self:GetOwner():IsNPC()) then
			self:SetClip1(self:GetMaxClip1())
			self:SetClip2(self:GetMaxClip2())
		end
	end
end

--[[
Function Name:  Think
Syntax: self:Think()
Returns:  Nothing.
Notes:  This is blank.
Purpose:  Standard SWEP Function
]]
function SWEP:Think()
	local self2 = self:GetTable()
	self2.CalculateRatios(self)

	if self:GetOwner():IsNPC() and SERVER then
		if self2.ThinkNPC then self2.ThinkNPC(self) end
		self2.Think2(self, false)
	end

	stat = self2.GetStatus(self)

	if (not sp or SERVER) and not self:GetFirstDeployEvent() then
		self2.ProcessEvents(self, sp or IsFirstTimePredicted())
	end

	-- backward compatibility
	self2.AnimCycle = self:GetAnimCycle()

	if (not sp or SERVER) and ct > self:GetNextIdleAnim() and (TFA.Enum.ReadyStatus[stat] or (stat == TFA.Enum.STATUS_SHOOTING and TFA.Enum.ShootLoopingStatus[self:GetShootStatus()])) then
		self:ChooseIdleAnim()
	end

	self2.ProcessLoopFire(self)
end

function SWEP:PlayerThink(plyv, is_working_out_prediction_errors)
	if not self:NullifyOIV() then return end

	self:Think2(is_working_out_prediction_errors)
end

local sv_cheats = GetConVar("sv_cheats")
local host_timescale = GetConVar("host_timescale")

local function Clamp(a, b, c)
	if a < b then return b end
	if a > c then return c end
	return a
end

local Lerp = Lerp

function SWEP:ShouldPlaySafetyAnim()
	if self:IsSafety() then
		return not self.SprintProgressUnpredicted2 or self.SprintProgressUnpredicted2 < 0.3
	end

	if not TFA.FriendlyEncounter then return false end
	return not self:GetIronSights() and (self:GetLastGunFire() + 1 < CurTime()) and (not self.SprintProgressUnpredicted2 or self.SprintProgressUnpredicted2 < 0.3)
end

local tickInterval = engine.TickInterval()

function SWEP:PlayerThinkCL(plyv)
	local self2 = self:GetTable()

	if not self:NullifyOIV() then return end

	self:SmokePCFLighting()

	if sp then
		self:Think2(false)
	end

	local ft = RealFrameTime() * game.GetTimeScale() * (sv_cheats:GetBool() and host_timescale:GetFloat() or 1)

	if self2.GetStatL(self, "BlowbackEnabled") then
		if not self2.Blowback_PistolMode or self:Clip1() == -1 or self:Clip1() > 0.1 or self2.Blowback_PistolMode_Disabled[self:GetLastActivity()] or self2.Blowback_PistolMode_Disabled[self:GetLastSequence()] or self2.Blowback_PistolMode_Disabled[self:GetLastSequenceString()] then
			self2.BlowbackCurrent = l_mathApproach(self2.BlowbackCurrent, 0, self2.BlowbackCurrent * ft * 15)
		end

		self2.BlowbackCurrentRoot = l_mathApproach(self2.BlowbackCurrentRoot, 0, self2.BlowbackCurrentRoot * ft * 15)
	end

	local is = self2.GetIronSights(self)
	local spr = self2.GetSprinting(self)
	local walk = self2.GetWalking(self)
	local status = self2.GetStatus(self)

	local ist = is and 1 or 0
	local ist2 = TFA.Enum.ReloadStatus[self:GetStatus()] and ist * .25 or ist

	local reloadBlendMult, reloadBlendMult2 = 1, 1

	if not self:GetStatL("LoopedReload") and (status == TFA.Enum.STATUS_RELOADING or status == TFA.Enum.STATUS_RELOADING_WAIT) and self2.ReloadAnimationEnd and self2.ReloadAnimationStart then
		local time = l_CT()
		local progress = Clamp((time - self2.ReloadAnimationStart) / (self2.ReloadAnimationEnd - self2.ReloadAnimationStart), 0, 1)

		reloadBlendMult = TFA.Cubic(math.max(
			Clamp(progress - 0.7, 0, 0.3) / 0.3,
			Clamp(0.1 - progress, 0, 0.1) / 0.1
		))

		reloadBlendMult2 = (1 + reloadBlendMult) / 2
	elseif TFA.Enum.ReloadStatus[status] then
		reloadBlendMult = 0
		reloadBlendMult2 = 0.5
	end

	local fidgetBlendMult = 1

	if status == TFA.Enum.STATUS_FIDGET then
		local progress = self:GetStatusProgress(true)

		fidgetBlendMult = TFA.Cubic(math.max(
			Clamp(progress - 0.8, 0, 0.2) / 0.2,
			Clamp(0.1 - progress, 0, 0.1) / 0.1
		))
	end

	local sprt = spr and reloadBlendMult or 0
	local sprt2 = spr and (fidgetBlendMult * reloadBlendMult) or 0
	local sprt3 = spr and reloadBlendMult2 or 0

	local walkt = walk and 1 or 0

	local IronSightsPosition = self2.GetStatL(self, "IronSightsPosition", self2.SightsPos)
	local IronSightsAngle = self2.GetStatL(self, "IronSightsAngle", self2.SightsAng)

	if IronSightsPosition then
		self2.IronSightsPositionCurrent = self2.IronSightsPositionCurrent or Vector(IronSightsPosition)
		self2.IronSightsAngleCurrent = self2.IronSightsAngleCurrent or Vector(IronSightsAngle)

		self2.IronSightsPositionCurrent.x = Lerp(ft * 11, self2.IronSightsPositionCurrent.x, IronSightsPosition.x)
		self2.IronSightsPositionCurrent.y = Lerp(ft * 11, self2.IronSightsPositionCurrent.y, IronSightsPosition.y)
		self2.IronSightsPositionCurrent.z = Lerp(ft * 11, self2.IronSightsPositionCurrent.z, IronSightsPosition.z)

		self2.IronSightsAngleCurrent.x = Lerp(ft * 11, self2.IronSightsAngleCurrent.x, self2.IronSightsAngleCurrent.x - math.AngleDifference(self2.IronSightsAngleCurrent.x, IronSightsAngle.x))
		self2.IronSightsAngleCurrent.y = Lerp(ft * 11, self2.IronSightsAngleCurrent.y, self2.IronSightsAngleCurrent.y - math.AngleDifference(self2.IronSightsAngleCurrent.y, IronSightsAngle.y))
		self2.IronSightsAngleCurrent.z = Lerp(ft * 11, self2.IronSightsAngleCurrent.z, self2.IronSightsAngleCurrent.z - math.AngleDifference(self2.IronSightsAngleCurrent.z, IronSightsAngle.z))
	end

	local adstransitionspeed
	if is then
		adstransitionspeed = 12.5 / (self:GetStatL("IronSightTime") / 0.3)
	elseif spr or walk then
		adstransitionspeed = 7.5
	else
		adstransitionspeed = 12.5
	end
	adstransitionspeed = math.min(adstransitionspeed, 1000)

	local ply = self:GetOwner()
	local velocity = self2.LastUnpredictedVelocity or ply:GetVelocity()

	local jr_targ = math.min(math.abs(velocity.z) / 500, 1)
	self2.JumpRatioUnpredicted = l_mathApproach((self2.JumpRatioUnpredicted or 0), jr_targ, (jr_targ - (self2.JumpRatioUnpredicted or 0)) * ft * 20)
	self2.CrouchingRatioUnpredicted = l_mathApproach((self2.CrouchingRatioUnpredicted or 0), ((ply:Crouching() or self2.KeyDown(self, IN_DUCK)) and ply:OnGround() and not ply:InVehicle()) and 1 or 0, ft / self2.ToCrouchTime)

	self2.IronSightsProgressPredicted = self2.GetIronSightsProgress(self) + (ist - self2.GetIronSightsProgress(self)) * tickInterval * adstransitionspeed * TFA.TickDelta
	self2.SprintProgressPredicted = self2.GetSprintProgress(self) + (sprt - self2.GetSprintProgress(self)) * tickInterval * adstransitionspeed * TFA.TickDelta
	self2.InspectingProgressPredicted = self2.GetInspectingProgress(self) + ((self2.GetCustomizing(self) and 1 or 0) - self2.GetInspectingProgress(self)) * tickInterval * 10 * TFA.TickDelta

	self2.IronSightsProgressUnpredicted = l_mathApproach(self2.IronSightsProgressUnpredicted or 0, ist, (ist - (self2.IronSightsProgressUnpredicted or 0)) * ft * adstransitionspeed * 1.2)
	self2.IronSightsProgressUnpredicted2 = l_mathApproach(self2.IronSightsProgressUnpredicted2 or 0, ist, (ist - (self2.IronSightsProgressUnpredicted2 or 0)) * ft * adstransitionspeed * 0.4)
	self2.IronSightsProgressUnpredicted3 = l_mathApproach(self2.IronSightsProgressUnpredicted3 or 0, ist2, (ist2 - (self2.IronSightsProgressUnpredicted3 or 0)) * ft * adstransitionspeed * 0.7)
	self2.SprintProgressUnpredicted = l_mathApproach(self2.SprintProgressUnpredicted or 0, sprt, (sprt - (self2.SprintProgressUnpredicted or 0)) * ft * adstransitionspeed)
	self2.SprintProgressUnpredicted2 = l_mathApproach(self2.SprintProgressUnpredicted2 or 0, sprt2, (sprt2 - (self2.SprintProgressUnpredicted2 or 0)) * ft * adstransitionspeed)
	self2.SprintProgressUnpredicted3 = l_mathApproach(self2.SprintProgressUnpredicted3 or 0, sprt3, (sprt3 - (self2.SprintProgressUnpredicted3 or 0)) * ft * adstransitionspeed)

	if is and not self2.VM_IronPositionScore then
		self2.VM_IronPositionScore = Clamp(self2.GetStatL(self, "ViewModelPosition"):Distance(self2.IronSightsPositionCurrent or self2.GetStatL(self, "IronSightsPosition", self2.GetStat(self, "SightsPos", vector_origin))) / 7, 0, 1)
	elseif not is and self2.VM_IronPositionScore and self2.IronSightsProgressUnpredicted2 <= 0.08 then
		self2.VM_IronPositionScore = nil
	end

	if self2.IronSightsProgressUnpredicted2 >= 0.8 and not self2.VM_IsScopedIn then
		self2.VM_IsScopedIn = true
	--elseif self2.IronSightsProgressUnpredicted2 <= 0.1 and self2.VM_IsScopedIn then
	elseif self2.IronSightsProgressUnpredicted2 <= 0.15 then
		self2.VM_IsScopedIn = false
	end

	local customizingTarget = self:GetCustomizing() and 1 or 0
	self2.CustomizingProgressUnpredicted = l_mathApproach((self2.CustomizingProgressUnpredicted or 0), customizingTarget, (customizingTarget - (self2.CustomizingProgressUnpredicted or 0)) * ft * 5)

	self2.WalkProgressUnpredicted = l_mathApproach((self2.WalkProgressUnpredicted or 0), walkt, (walkt - (self2.WalkProgressUnpredicted or 0)) * ft * adstransitionspeed)

	if status ~= TFA.Enum.STATUS_FIREMODE or not self:GetIsCyclingSafety() then
		local safetyTarget = self:ShouldPlaySafetyAnim() and (fidgetBlendMult * reloadBlendMult) or 0
		self2.SafetyProgressUnpredicted = l_mathApproach(self2.SafetyProgressUnpredicted or 0, safetyTarget, (safetyTarget - (self2.SafetyProgressUnpredicted or 0)) * ft * adstransitionspeed * 0.7)
	elseif status == TFA.Enum.STATUS_FIREMODE and self:GetIsCyclingSafety() then
		if not self:ShouldPlaySafetyAnim() then
			local safetyTarget = 0

			if self:GetSafetyCycleAnimated() then
				self2.SafetyProgressUnpredicted = l_mathApproach(self2.SafetyProgressUnpredicted or 0, safetyTarget, (safetyTarget - (self2.SafetyProgressUnpredicted or 0)) * ft * adstransitionspeed * 1.1)
			else
				self2.SafetyProgressUnpredicted = l_mathApproach(self2.SafetyProgressUnpredicted or 0, safetyTarget, (safetyTarget - (self2.SafetyProgressUnpredicted or 0)) * ft * adstransitionspeed)
			end
		else
			local safetyTarget = fidgetBlendMult * reloadBlendMult

			if not self:GetSafetyCycleAnimated() then
				self2.SafetyProgressUnpredicted = l_mathApproach(self2.SafetyProgressUnpredicted or 0, safetyTarget, (safetyTarget - (self2.SafetyProgressUnpredicted or 0)) * ft * adstransitionspeed * 0.7)
			end
		end
	end
end

local UnPredictedCurTime = UnPredictedCurTime

--[[
Function Name:  Think2
Syntax: self:Think2().  Called from Think.
Returns:  Nothing.
Notes:  Essential for calling other important functions.
Purpose:  Standard SWEP Function
]]
function SWEP:Think2(is_working_out_prediction_errors)
	local self2 = self:GetTable()

	ct = l_CT()

	if not is_working_out_prediction_errors then
		if CLIENT then
			self2.CurTimePredictionAdvance = ct - UnPredictedCurTime()
		end

		if self2.LuaShellRequestTime > 0 and ct > self2.LuaShellRequestTime then
			self2.LuaShellRequestTime = -1
			self2.MakeShell(self)
		end

		if not self2.HasInitialized then
			self:Initialize()
		end

		if not self2.HasDetectedValidAnimations then
			self2.CacheAnimations(self)
			self2.ChooseDrawAnim(self)
		end

		self2.InitAttachments(self)

		self2.ProcessBodygroups(self)

		self2.ProcessHoldType(self)
		self2.ReloadCV(self)
		self2.IronSightSounds(self)
		self2.ProcessLoopSound(self)
	end

	self2.ProcessFireMode(self)

	if (not sp or SERVER) and self:GetFirstDeployEvent() then
		self2.ProcessEvents(self, sp or not is_working_out_prediction_errors)
	end

	--if is_working_out_prediction_errors then return end

	if not sp or SERVER then
		self2.IronSights(self)
	end

	self2.ProcessStatus(self)
end

SWEP.IronSightsReloadEnabled = false
SWEP.IronSightsReloadLock = true

function SWEP:IronSights()
	local self2 = self:GetTable()
	local owent = self:GetOwner()
	if not IsValid(owent) then return end

	ct = l_CT()
	stat = self:GetStatus()

	local issprinting = self:GetSprinting()
	local iswalking = self:GetWalking()

	local issighting = self:GetIronSightsRaw()
	local isplayer = owent:IsPlayer()
	local old_iron_sights_final = self:GetIronSightsOldFinal()

	if TFA.Enum.ReloadStatus[stat] and self2.GetStatL(self, "IronSightsReloadLock") then
		issighting = old_iron_sights_final
	end

	if issighting and isplayer and owent:InVehicle() and not owent:GetAllowWeaponsInVehicle() then
		issighting = false
		self:SetIronSightsRaw(false)
	end

	-- self:SetLastSightsStatusCached(false)
	local userstatus = issighting

	if issprinting then
		issighting = false
	end

	if issighting and not TFA.Enum.IronStatus[stat] and (not self:GetStatL("IronSightsReloadEnabled") or not TFA.Enum.ReloadStatus[stat]) then
		issighting = false
	end

	if issighting and self:IsSafety() then
		issighting = false
	end

	if stat == TFA.Enum.STATUS_FIREMODE and self:GetIsCyclingSafety() then
		issighting = false
	end

	local isbolt = self2.GetStatL(self, "BoltAction")
	local isbolt_forced = self2.GetStatL(self, "BoltAction_Forced")
	if isbolt or isbolt_forced then
		if stat == TFA.Enum.STATUS_SHOOTING and not self2.LastBoltShoot then
			self2.LastBoltShoot = l_CT()
		end

		if self2.LastBoltShoot then
			if stat == TFA.Enum.STATUS_SHOOTING then
				if l_CT() > self2.LastBoltShoot + self2.GetStatL(self, "BoltTimerOffset") then
					issighting = false
				end
			else
				self2.LastBoltShoot = nil
			end
		end

		if (stat == TFA.Enum.STATUS_IDLE and self:GetReloadLoopCancel(true)) or stat == TFA.Enum.STATUS_PUMP then
			issighting = false
		end
	end

	local sightsMode = self2.GetStatL(self, "Sights_Mode")
	local sprintMode = self2.GetStatL(self, "Sprint_Mode")
	local walkMode = self2.GetStatL(self, "Walk_Mode")
	local customizeMode = self2.GetStatL(self, "Customize_Mode")

	if old_iron_sights_final ~= issighting and sightsMode == TFA.Enum.LOCOMOTION_LUA then -- and stat == TFA.Enum.STATUS_IDLE then
		self:SetNextIdleAnim(-1)
	end

	local smi = (sightsMode ~= TFA.Enum.LOCOMOTION_LUA)
		and old_iron_sights_final ~= issighting

	local spi = (sprintMode ~= TFA.Enum.LOCOMOTION_LUA)
		and self2.sprinting_updated

	local wmi = (walkMode ~= TFA.Enum.LOCOMOTION_LUA)
		and self2.walking_updated

	local cmi = (customizeMode ~= TFA.Enum.LOCOMOTION_LUA)
		and self:GetCustomizeUpdated()

	self:SetCustomizeUpdated(false)

	if
		(smi or spi or wmi or cmi) and
		(self:GetStatus() == TFA.Enum.STATUS_IDLE or
			(self:GetStatus() == TFA.Enum.STATUS_SHOOTING and self:CanInterruptShooting()))
		and not self:GetReloadLoopCancel()
	then
		local toggle_is = old_iron_sights_final ~= issighting

		if issighting and self:GetSprinting() then
			toggle_is = true
		end

		local success, _ = self:Locomote(toggle_is and (sightsMode ~= TFA.Enum.LOCOMOTION_LUA), issighting, spi, issprinting, wmi, iswalking, cmi, self:GetCustomizing())

		if not success and (toggle_is and smi or spi or wmi or cmi) then
			self:SetNextIdleAnim(-1)
		end
	end

	self:SetIronSightsOldFinal(issighting)

	return userstatus, issighting
end

SWEP.is_sndcache_old = false

function SWEP:IronSightSounds()
	local self2 = self:GetTable()

	local is = self:GetIronSights()

	if SERVER or IsFirstTimePredicted() then
		if is ~= self2.is_sndcache_old and hook.Run("TFA_IronSightSounds", self) == nil then
			if is then
				self:EmitSound(self:GetStatL("Secondary.IronSightsInSound", "TFA.IronIn"))
			else
				self:EmitSound(self:GetStatL("Secondary.IronSightsOutSound", "TFA.IronOut"))
			end
		end

		self2.is_sndcache_old = is
	end
end

local legacy_reloads_cv = GetConVar("sv_tfa_reloads_legacy")
local dryfire_cvar = GetConVar("sv_tfa_allow_dryfire")

SWEP.Primary.Sound_DryFire = Sound("Weapon_Pistol.Empty2") -- dryfire sound, played only once
SWEP.Primary.Sound_DrySafety = Sound("Weapon_AR2.Empty2") -- safety click sound
SWEP.Primary.Sound_Blocked = Sound("Weapon_AR2.Empty") -- underwater click sound
SWEP.Primary.Sound_Jammed = Sound("Default.ClipEmpty_Rifle") -- jammed click sound

SWEP.Primary.SoundHint_Fire = true
SWEP.Primary.SoundHint_DryFire = true

local function Dryfire(self, self2, reload)
	if not dryfire_cvar:GetBool() and reload then
		self:Reload(true)
	end

	if self2.GetHasPlayedEmptyClick(self) then return end

	self2.SetHasPlayedEmptyClick(self, true)

	if SERVER and self:GetStatL("Primary.SoundHint_DryFire") then
		sound.EmitHint(SOUND_COMBAT, self:GetPos(), 500, 0.2, self:GetOwner())
	end

	if self:GetOwner():IsNPC() or self:KeyPressed(IN_ATTACK) then
		local enabled, tanim, ttype = self:ChooseDryFireAnim()

		if enabled then
			self:SetNextPrimaryFire(l_CT() + self:GetStatL("Primary.DryFireDelay", self:GetActivityLength(tanim, true, ttype)))
			return
		end
	end

	if IsFirstTimePredicted() then
		self:EmitSound(self:GetStatL("Primary.Sound_DryFire"))
	end
end

function SWEP:CanPrimaryAttack()
	local attackKeyPressed = false
	if IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() then
		attackKeyPressed = self:GetOwner():KeyPressed(IN_ATTACK)
	end

	local self2 = self:GetTable()

	local v = hook.Run("TFA_PreCanPrimaryAttack", self)

	if v ~= nil then
		return v
	end

	stat = self:GetStatus()

	if not TFA.Enum.ReadyStatus[stat] and stat ~= TFA.Enum.STATUS_SHOOTING then
		if attackKeyPressed and self:GetStatL("LoopedReload") and TFA.Enum.ReloadStatus[stat] then
			self:SetReloadLoopCancel(true)
		end

		return false
	end

	if self:IsSafety() then
		if attackKeyPressed then
			if IsFirstTimePredicted() then
				self:EmitSound(self:GetStatL("Primary.Sound_DrySafety"))

				if SERVER and self:GetStatL("Primary.SoundHint_DryFire") then
					sound.EmitHint(SOUND_COMBAT, self:GetPos(), 200, 0.2, self:GetOwner())
				end
			end

			if l_CT() < self:GetLastSafetyShoot() + 0.2 then
				self:CycleSafety()
				-- self:SetNextPrimaryFire(l_CT() + 0.1)
			end

			self:SetLastSafetyShoot(l_CT() + 0.2)
		end

		return false
	end

	if self:GetSprintProgress() >= 0.1 and not self:GetStatL("AllowSprintAttack", false) then
		return false
	end

	if self:GetStatL("Primary.ClipSize") <= 0 and self:Ammo1() < self:GetStatL("Primary.AmmoConsumption") then
		Dryfire(self, self2)
		return false
	end

	if self:GetPrimaryClipSize(true) > 0 and self:Clip1() < self:GetStatL("Primary.AmmoConsumption") then
		Dryfire(self, self2, true)
		return false
	end

	if self2.GetStatL(self, "Primary.FiresUnderwater") == false and self:GetOwner():WaterLevel() >= 3 then
		self:SetNextPrimaryFire(l_CT() + 0.5)
		self:EmitSound(self:GetStatL("Primary.Sound_Blocked"))
		return false
	end

	self2.SetHasPlayedEmptyClick(self, false)

	if l_CT() < self:GetNextPrimaryFire() then return false end

	local v2 = hook.Run("TFA_CanPrimaryAttack", self)

	if v2 ~= nil then
		return v2
	end

	if self:CheckJammed() then
		if IsFirstTimePredicted() then
			self:EmitSound(self:GetStatL("Primary.Sound_Jammed"))
		end

		local typev, tanim = self:ChooseAnimation("shoot1_empty")

		if typev ~= TFA.Enum.ANIMATION_SEQ then
			self:SendViewModelAnim(tanim)
		else
			self:SendViewModelSeq(tanim)
		end

		self:SetNextPrimaryFire(l_CT() + 1)

		return false
	end

	return true
end

function SWEP:EmitGunfireLoop()
	local self2 = self:GetTable()
	local tgtSound = self:GetStatL("Primary.LoopSound")

	if self:GetSilenced() then
		tgtSound = self:GetStatL("Primary.LoopSoundSilenced", tgtSound)
	end

	if (not sp and SERVER) or not self:IsFirstPerson() then
		tgtSound = self:GetSilenced() and self:GetStatL("Primary.LoopSoundSilenced_World", tgtSound) or self:GetStatL("Primary.LoopSound_World", tgtSound)
	end

	if self:GetNextLoopSoundCheck() < 0 or (l_CT() >= self:GetNextLoopSoundCheck() and self2.LastLoopSound ~= tgtSound) then
		if self2.LastLoopSound ~= tgtSound and self2.LastLoopSound ~= nil then
			self:StopSound(self2.LastLoopSound)
		end

		self2.LastLoopSound = tgtSound
		self2.GunfireLoopIFTPHack = true

		self:EmitSoundNet(tgtSound, nil, true)
	end

	self:SetNextLoopSoundCheck(CurTime() + self:GetFireDelay())
end

function SWEP:EmitGunfireSound(soundscript)
	self:EmitSoundNet(soundscript)
end

local sv_tfa_nearlyempty = GetConVar("sv_tfa_nearlyempty")

SWEP.LowAmmoSoundThreshold = 0.33

function SWEP:EmitLowAmmoSound()
	if not sv_tfa_nearlyempty:GetBool() then return end

	local self2 = self:GetTable()

	if not self2.FireSoundAffectedByClipSize then return end

	local clip1, maxclip1 = self:Clip1(), self:GetMaxClip1()
	if clip1 <= 0 then return end

	local nextclip1 = clip1 - self:GetStatL("Primary.AmmoConsumption", 1)
	if self:GetStatL("IsAkimbo") then
		nextclip1 = nextclip1 - self:GetAnimCycle()
	end

	local mult = nextclip1 / maxclip1
	if mult >= self2.LowAmmoSoundThreshold then return end

	local soundname = (nextclip1 <= 0) and self:GetStatL("LastAmmoSound", "") or self:GetStatL("LowAmmoSound", "")

	if soundname and soundname ~= "" then
		self2.GonnaAdjustVol = true
		self2.RequiredVolume = 1 - (mult / math.max(self2.LowAmmoSoundThreshold, 0.01))

		self:EmitSound(soundname)
	end
end

function SWEP:TriggerAttack(tableName, clipID)
	local self2 = self:GetTable()
	local ply = self:GetOwner()

	local fnname = clipID == 2 and "Secondary" or "Primary"

	if TFA.Enum.ShootReadyStatus[self:GetShootStatus()] then
		self:SetShootStatus(TFA.Enum.SHOOT_IDLE)
	end

	if self:GetStatRawL("CanBeSilenced") and (ply.KeyDown and self:KeyDown(IN_USE)) and (SERVER or not sp) and (ply.GetInfoNum and ply:GetInfoNum("cl_tfa_keys_silencer", 0) == 0) then
		local _, tanim, ttype = self:ChooseSilenceAnim(not self:GetSilenced())
		self:ScheduleStatus(TFA.Enum.STATUS_SILENCER_TOGGLE, self:GetActivityLength(tanim, true, ttype))

		return
	end

	self["SetNext" .. fnname .. "Fire"](self, self2["GetNextCorrected" .. fnname .. "Fire"](self, self2.GetFireDelay(self)))

	if self:GetMaxBurst() > 1 then
		self:SetBurstCount(math.max(1, self:GetBurstCount() + 1))
	end

	if self:GetStatL("PumpAction") and self:GetReloadLoopCancel() then return end

	self:SetStatus(TFA.Enum.STATUS_SHOOTING, self["GetNext" .. fnname .. "Fire"](self))
	self:ToggleAkimbo()
	self:IncreaseRecoilLUT()

	local ifp = IsFirstTimePredicted()

	local _, tanim, ttype = self:ChooseShootAnim(ifp)

	ply:SetAnimation(PLAYER_ATTACK1)

	if SERVER and self:GetStatL(tableName .. ".SoundHint_Fire") then
		sound.EmitHint(bit.bor(SOUND_COMBAT, SOUND_CONTEXT_GUNFIRE), self:GetPos(), self:GetSilenced() and 500 or 1500, 0.2, self:GetOwner())
	end

	if self:GetStatL(tableName .. ".Sound") and ifp and not (sp and CLIENT) then
		if ply:IsPlayer() and self:GetStatL(tableName .. ".LoopSound") and self:ShouldEmitGunfireLoop(tableName) then
			self:EmitGunfireLoop()
		else
			local tgtSound = self:GetStatL(tableName .. ".Sound")

			if self:GetSilenced() then
				tgtSound = self:GetStatL(tableName .. ".SilencedSound", tgtSound)
			end

			if (not sp and SERVER) or not self:IsFirstPerson() then
				tgtSound = self:GetSilenced() and self:GetStatL(tableName .. ".SilencedSound_World", tgtSound) or self:GetStatL(tableName .. ".Sound_World", tgtSound)
			end

			self:EmitGunfireSound(tgtSound)
		end

		self:EmitLowAmmoSound()
	end

	self2["Take" .. fnname .. "Ammo"](self, self:GetStatL(tableName .. ".AmmoConsumption"))

	if self["Clip" .. clipID](self) == 0 and self:GetStatL(tableName .. ".ClipSize") > 0 then
		self["SetNext" .. fnname .. "Fire"](self, math.max(self["GetNext" .. fnname .. "Fire"](self), l_CT() + (self:GetStatL(tableName .. ".DryFireDelay", self:GetActivityLength(tanim, true, ttype)))))
	end

	self:ShootBulletInformation()
	self:UpdateJamFactor()
	local _, CurrentRecoil = self:CalculateConeRecoil()
	self:Recoil(CurrentRecoil, ifp)

	-- shouldn't this be not required since recoil state is completely networked?
	if sp and SERVER then
		self:CallOnClient("Recoil", "")
	end

	if self:GetStatL(tableName .. ".MuzzleFlashEnabled", self:GetStatL("MuzzleFlashEnabled")) and (not self:IsFirstPerson() or not self:GetStatL(tableName .. ".AutoDetectMuzzleAttachment", self:GetStatL("AutoDetectMuzzleAttachment"))) then
		self:ShootEffectsCustom()
	end

	if self:GetStatL(tableName .. ".EjectionSmoke", self:GetStatL("EjectionSmoke")) and CLIENT and ply == LocalPlayer() and ifp and not self:GetStatL(tableName .. ".LuaShellEject", self:GetStatL("LuaShellEject")) then
		self:EjectionSmoke()
	end

	self:DoAmmoCheck(clipID)

	-- Condition self:GetStatus() == TFA.Enum.STATUS_SHOOTING is always true?
	if self:GetStatus() == TFA.Enum.STATUS_SHOOTING and self:GetStatL("PumpAction") then
		if self["Clip" .. clipID](self) == 0 and self:GetStatL("PumpAction.value_empty") then
			self:SetReloadLoopCancel(true)
		elseif (self:GetStatL(tableName .. ".ClipSize") < 0 or self["Clip" .. clipID](self) > 0) and self:GetStatL("PumpAction.value") then
			self:SetReloadLoopCancel(true)
		end
	end

	self:RollJamChance()
end

function SWEP:PrimaryAttack()
	local self2 = self:GetTable()
	local ply = self:GetOwner()
	if not IsValid(ply) then return end

	if not IsValid(self) then return end
	if ply:IsPlayer() and not self:VMIV() then return end
	if not self:CanPrimaryAttack() then return end

	self:PrePrimaryAttack()

	if hook.Run("TFA_PrimaryAttack", self) then return end

	self:TriggerAttack("Primary", 1)

	self:PostPrimaryAttack()
	hook.Run("TFA_PostPrimaryAttack", self)
end

function SWEP:PrePrimaryAttack()
	-- override
end

function SWEP:PostPrimaryAttack()
	-- override
end

function SWEP:CanSecondaryAttack()
	-- override
end

function SWEP:SecondaryAttack()
	self:PreSecondaryAttack()

	if hook.Run("TFA_SecondaryAttack", self) then return end

	if not self:GetStatL("Secondary.IronSightsEnabled", false) and self.AltAttack and self:GetOwner():IsPlayer() then
		self:AltAttack()
		self:PostSecondaryAttack()
		return
	end

	self:PostSecondaryAttack()
end

function SWEP:PreSecondaryAttack()
	-- override
end

function SWEP:PostSecondaryAttack()
	-- override
end

function SWEP:GetLegacyReloads()
	return legacy_reloads_cv:GetBool()
end

do
	local bit_band = bit.band

	function SWEP:KeyDown(keyIn)
		return bit_band(self:GetDownButtons(), keyIn) == keyIn
	end

	function SWEP:KeyPressed(keyIn)
		return bit_band(self:GetLastPressedButtons(), keyIn) == keyIn
	end
end

if SERVER and sp then
	util.AddNetworkString("tfa_reload_blending")
elseif CLIENT and sp then
	net.Receive("tfa_reload_blending", function()
		local self = net.ReadEntity()
		if not IsValid(self) then return end
		self.ReloadAnimationStart = net.ReadDouble()
		self.ReloadAnimationEnd = net.ReadDouble()
	end)
end

function SWEP:Reload(released)
	local self2 = self:GetTable()

	self:PreReload(released)

	if hook.Run("TFA_PreReload", self, released) then return end

	local isplayer = self:GetOwner():IsPlayer()
	local vm = self2.VMIV(self)

	if isplayer and not vm then return end

	if not self:IsJammed() then
		if self:Ammo1() <= 0 then return end
		if self:GetStatL("Primary.ClipSize") < 0 then return end
	end

	if not released and not self:GetLegacyReloads() then return end
	if self:GetLegacyReloads() and not dryfire_cvar:GetBool() and not self:KeyDown(IN_RELOAD) then return end
	if self:KeyDown(IN_USE) then return end

	ct = l_CT()
	stat = self:GetStatus()

	if self:GetStatL("PumpAction") and self:GetReloadLoopCancel() then
		if stat == TFA.Enum.STATUS_IDLE then
			self:DoPump()
		end
	elseif TFA.Enum.ReadyStatus[stat] or (stat == TFA.Enum.STATUS_SHOOTING and self:CanInterruptShooting()) or self:IsJammed() then
		if self:Clip1() < self:GetPrimaryClipSize() or self:IsJammed() then
			if hook.Run("TFA_Reload", self) then return end
			self:SetBurstCount(0)

			if self:GetStatL("LoopedReload") then
				local _, tanim, ttype = self:ChooseShotgunReloadAnim()

				if self:GetStatL("ShotgunStartAnimShell") then
					self:SetStatus(TFA.Enum.STATUS_RELOADING_LOOP_START_EMPTY)
				elseif self2.ShotgunEmptyAnim then
					local _, tg = self:ChooseAnimation("reload_empty")
					local action = tanim

					if type(tg) == "string" and tonumber(tanim) and tonumber(tanim) > 0 and isplayer then
						if ttype == TFA.Enum.ANIMATION_ACT then
							action = vm:GetSequenceName(vm:SelectWeightedSequenceSeeded(tanim, self:GetSeedIrradical()))
						else
							action = vm:GetSequenceName(tanim)
						end
					end

					if action == tg and self:GetStatL("ShotgunEmptyAnim_Shell") then
						self:SetStatus(TFA.Enum.STATUS_RELOADING_LOOP_START_EMPTY)
					else
						self:SetStatus(TFA.Enum.STATUS_RELOADING_LOOP_START)
					end
				else
					self:SetStatus(TFA.Enum.STATUS_RELOADING_LOOP_START)
				end

				self:SetStatusEnd(ct + self:GetActivityLength(tanim, true, ttype))
				--self:SetNextPrimaryFire(ct + self:GetActivityLength( tanim, false ) )
			else
				local _, tanim, ttype = self:ChooseReloadAnim()

				self:SetStatus(TFA.Enum.STATUS_RELOADING)

				if self:GetStatL("IsProceduralReloadBased") then
					self:SetStatusEnd(ct + self:GetStatL("ProceduralReloadTime"))
				else
					self:SetStatusEnd(ct + self:GetActivityLength(tanim, true, ttype))
					self:SetNextPrimaryFire(ct + self:GetActivityLength(tanim, false, ttype))
				end

				if CLIENT then
					self2.ReloadAnimationStart = ct
					self2.ReloadAnimationEnd = ct + self:GetActivityLength(tanim, false, ttype)
				elseif sp then
					net.Start("tfa_reload_blending", true)
					net.WriteEntity(self)
					net.WriteDouble(ct)
					net.WriteDouble(ct + self:GetActivityLength(tanim, false, ttype))
					net.Broadcast()
				end
			end

			self:GetOwner():SetAnimation(PLAYER_RELOAD)

			if self:GetStatL("Primary.ReloadSound") and IsFirstTimePredicted() then
				self:EmitSound(self:GetStatL("Primary.ReloadSound"))
			end

			self:ResetAnimCycle()

			self:SetNextPrimaryFire( -1 )
		elseif released or self:KeyPressed(IN_RELOAD) then--if self:GetOwner():KeyPressed(IN_RELOAD) or not self:GetLegacyReloads() then
			self:CheckAmmo()
		end
	end

	self:PostReload(released)

	hook.Run("TFA_PostReload", self)
end

function SWEP:PreReload(released)
	-- override
end

function SWEP:PostReload(released)
	-- override
end

function SWEP:Reload2(released)
	local self2 = self:GetTable()

	local isplayer = self:GetOwner():IsPlayer()
	local vm = self2.VMIV(self)

	if isplayer and not vm then return end

	if self:Ammo2() <= 0 then return end
	if self:GetStatL("Secondary.ClipSize") < 0 then return end
	if not released and not self:GetLegacyReloads() then return end
	if self:GetLegacyReloads() and not dryfire_cvar:GetBool() and not self:KeyDown(IN_RELOAD) then return end
	if self:KeyDown(IN_USE) then return end

	ct = l_CT()
	stat = self:GetStatus()

	if self:GetStatL("PumpAction") and self:GetReloadLoopCancel() then
		if stat == TFA.Enum.STATUS_IDLE then
			self:DoPump()
		end
	elseif TFA.Enum.ReadyStatus[stat] or ( stat == TFA.Enum.STATUS_SHOOTING and self:CanInterruptShooting() ) then
		if self:Clip2() < self:GetSecondaryClipSize() then
			if self:GetStatL("LoopedReload") then
				local _, tanim, ttype = self:ChooseShotgunReloadAnim()

				if self2.ShotgunEmptyAnim  then
					local _, tg = self:ChooseAnimation("reload_empty")
					local action = tanim

					if type(tg) == "string" and tonumber(tanim) and tonumber(tanim) > 0 and isplayer then
						if ttype == TFA.Enum.ANIMATION_ACT then
							action = vm:GetSequenceName(vm:SelectWeightedSequenceSeeded(tanim, self:GetSeedIrradical()))
						else
							action = vm:GetSequenceName(tanim)
						end
					end

					if action == tg and self:GetStatL("ShotgunEmptyAnim_Shell") then
						self:SetStatus(TFA.Enum.STATUS_RELOADING_LOOP_START_EMPTY)
					else
						self:SetStatus(TFA.Enum.STATUS_RELOADING_LOOP_START)
					end
				else
					self:SetStatus(TFA.Enum.STATUS_RELOADING_LOOP_START)
				end

				self:SetStatusEnd(ct + self:GetActivityLength(tanim, true, ttype))
				--self:SetNextPrimaryFire(ct + self:GetActivityLength( tanim, false ) )
			else
				local _, tanim, ttype = self:ChooseReloadAnim()

				self:SetStatus(TFA.Enum.STATUS_RELOADING)

				if self:GetStatL("IsProceduralReloadBased") then
					self:SetStatusEnd(ct + self:GetStatL("ProceduralReloadTime"))
				else
					self:SetStatusEnd(ct + self:GetActivityLength(tanim, true, ttype))
					self:SetNextPrimaryFire(ct + self:GetActivityLength(tanim, false, ttype))
				end

				if CLIENT then
					self2.ReloadAnimationStart = ct
					self2.ReloadAnimationEnd = ct + self:GetActivityLength(tanim, false, ttype)
				end
			end

			self:GetOwner():SetAnimation(PLAYER_RELOAD)

			if self:GetStatL("Secondary.ReloadSound") and IsFirstTimePredicted() then
				self:EmitSound(self:GetStatL("Secondary.ReloadSound"))
			end

			self:SetNextPrimaryFire( -1 )
		elseif released or self:KeyPressed(IN_RELOAD) then--if self:GetOwner():KeyPressed(IN_RELOAD) or not self:GetLegacyReloads() then
			self:CheckAmmo()
		end
	end
end

function SWEP:DoPump()
	if hook.Run("TFA_Pump", self) then return end

	local _, tanim, activityType = self:PlayAnimation(self:GetStatL("PumpAction"))

	self:ScheduleStatus(TFA.Enum.STATUS_PUMP, self:GetActivityLength(tanim, true, activityType))
	self:SetNextPrimaryFire(l_CT() + self:GetActivityLength(tanim, false, activityType))
	self:SetNextIdleAnim(math.max(self:GetNextIdleAnim(), l_CT() + self:GetActivityLength(tanim, false, activityType)))
end

function SWEP:LoadShell()
	if hook.Run("TFA_LoadShell", self) then return end

	local _, tanim, ttype = self:ChooseReloadAnim()

	if self:GetActivityLength(tanim, true, ttype) < self:GetActivityLength(tanim, false, ttype) then
		self:SetStatusEnd(ct + self:GetActivityLength(tanim, true, ttype))
	else
		local sht = self:GetStatL("LoopedReloadInsertTime")
		if sht then sht = sht / self:GetAnimationRate(ACT_VM_RELOAD) end
		self:SetStatusEnd(ct + ( sht or self:GetActivityLength(tanim, true, ttype)))
	end

	return TFA.Enum.STATUS_RELOADING_LOOP
end

function SWEP:CompleteReload()
	if hook.Run("TFA_CompleteReload", self) then return end

	local maxclip = self:GetPrimaryClipSizeForReload(true)
	local curclip = self:Clip1()
	local amounttoreplace = math.min(maxclip - curclip, self:Ammo1())
	self:TakePrimaryAmmo(amounttoreplace * -1)
	self:TakePrimaryAmmo(amounttoreplace, true)
	self:SetJammed(false)
end

function SWEP:CheckAmmo()
	if hook.Run("TFA_CheckAmmo", self) then return end

	local self2 = self:GetTable()

	if self2.GetIronSights(self) or self2.GetSprinting(self) then return end

	--if self2.NextInspectAnim == nil then
	--  self2.NextInspectAnim = -1
	--end

	if self:GetOwner().GetInfoNum and self:GetOwner():GetInfoNum("cl_tfa_keys_inspect", 0) > 0 then
		return
	end

	if (self:GetActivityEnabled(ACT_VM_FIDGET) or self2.InspectionActions) and self:GetStatus() == TFA.Enum.STATUS_IDLE then--and CurTime() > self2.NextInspectAnim then
		local _, tanim, ttype = self:ChooseInspectAnim()
		self:ScheduleStatus(TFA.Enum.STATUS_FIDGET, self:GetActivityLength(tanim, false, ttype))
	end
end

local cv_strip = GetConVar("sv_tfa_weapon_strip")

function SWEP:DoAmmoCheck(clipID)
	if self:GetOwner():IsNPC() then return end
	if clipID == nil then clipID = 1 end
	local self2 = self:GetTable()

	if IsValid(self) and SERVER and cv_strip:GetBool() and self["Clip" .. clipID](self) == 0 and self["Ammo" .. clipID](self) == 0 then
		timer.Simple(.1, function()
			if SERVER and IsValid(self) and self:OwnerIsValid() then
				self:GetOwner():StripWeapon(self2.ClassName)
			end
		end)
	end
end

--[[
Function Name:  AdjustMouseSensitivity
Syntax: Should not normally be called.
Returns:  SWEP sensitivity multiplier.
Purpose:  Standard SWEP Function
]]

local fovv
local sensval
local sensitivity_cvar, sensitivity_fov_cvar, sensitivity_speed_cvar
if CLIENT then
	sensitivity_cvar = GetConVar("cl_tfa_scope_sensitivity")
	sensitivity_fov_cvar = GetConVar("cl_tfa_scope_sensitivity_autoscale")
	sensitivity_speed_cvar = GetConVar("sv_tfa_scope_gun_speed_scale")
end

function SWEP:AdjustMouseSensitivity()
	sensval = 1

	if self:GetIronSights() then
		sensval = sensval * sensitivity_cvar:GetFloat() / 100

		if sensitivity_fov_cvar:GetBool() then
			fovv = self:GetStatL("Secondary.OwnerFOV") or 70
			sensval = sensval * TFA.CalculateSensitivtyScale( fovv, nil, 1 )
		else
			sensval = sensval
		end

		if sensitivity_speed_cvar:GetFloat() then
			-- weapon heaviness
			sensval = sensval * self:GetStatL("AimingDownSightsSpeedMultiplier")
		end
	end

	sensval = sensval * l_Lerp(self:GetIronSightsProgress(), 1, self:GetStatL( "IronSightsSensitivity" ) )
	return sensval
end

--[[
Function Name:  TranslateFOV
Syntax: Should not normally be called.  Takes default FOV as parameter.
Returns:  New FOV.
Purpose:  Standard SWEP Function
]]

function SWEP:TranslateFOV(fov)
	local self2 = self:GetTable()

	self2.LastTranslatedFOV = fov

	local retVal = hook.Run("TFA_PreTranslateFOV", self, fov)

	if retVal then return retVal end

	self2.CorrectScopeFOV(self)

	local ironprog = self2.IronSightsProgressPredicted or self2.GetIronSightsProgress(self)
	if self2.GetStatL(self, "Secondary.OwnerFOVUseThreshold", self2.GetStatL(self, "Scoped")) then
		local threshold = math.min(self2.GetStatL(self, "Secondary.OwnerFOVThreshold", self2.GetStatL(self, "ScopeOverlayThreshold")), 0.999999)

		ironprog = ironprog < threshold and 0 or math.max(ironprog - threshold, 0) / (1 - threshold)
	end

	local nfov = l_Lerp(ironprog, fov, fov * math.min(self2.GetStatL(self, "Secondary.OwnerFOV") / 90, 1))
	local ret = l_Lerp(self2.SprintProgressPredicted or self2.GetSprintProgress(self), nfov, nfov + self2.SprintFOVOffset)

	if self2.OwnerIsValid(self) and not self2.IsMelee then
		local vpa = self:GetOwner():GetViewPunchAngles()

		ret = ret + math.abs(vpa.p) / 4 + math.abs(vpa.y) / 4 + math.abs(vpa.r) / 4
	end

	ret = hook.Run("TFA_TranslateFOV", self, ret) or ret

	return ret
end

function SWEP:GetPrimaryAmmoType()
	return self:GetStatL("Primary.Ammo") or ""
end

function SWEP:ToggleInspect()
	if self:GetOwner():IsNPC() then return false end -- NPCs can't look at guns silly

	local self2 = self:GetTable()

	if (self:GetSprinting() or self:GetIronSights() or self:GetStatus() ~= TFA.Enum.STATUS_IDLE) and not self:GetCustomizing() then return end

	self:SetCustomizing(not self:GetCustomizing())
	self2.Inspecting = self:GetCustomizing()
	self:SetCustomizeUpdated(true)

	--if self2.Inspecting then
	--  gui.EnableScreenClicker(true)
	--else
	--  gui.EnableScreenClicker(false)
	--end

	return self:GetCustomizing()
end

SWEP.ToggleCustomize = SWEP.ToggleInspect

function SWEP:GetIsInspecting()
	return self:GetCustomizing()
end

function SWEP:CustomizingUpdated(_, old, new)
	if old ~= new and self._inspect_hack ~= new then
		self._inspect_hack = new

		if new then
			self:OnCustomizationOpen()
		else
			self:OnCustomizationClose()
		end
	end
end

function SWEP:OnCustomizationOpen()
	-- override
	-- example:
	--[[
		if CLIENT then surface.PlaySound("ui/buttonclickrelease.wav") end
	]]
end

function SWEP:OnCustomizationClose()
	-- override
end

function SWEP:CanBeJammed()
	return self.CanJam and self:GetMaxClip1() > 0 and sv_tfa_jamming:GetBool()
end

-- Use this to increase/decrease factor added based on ammunition/weather conditions/etc
function SWEP:GrabJamFactorMult()
	return 1 -- override
end

function SWEP:UpdateJamFactor()
	local self2 = self:GetTable()
	if not self:CanBeJammed() then return self end
	self:SetJamFactor(math.min(100, self:GetJamFactor() + self2.JamFactor * sv_tfa_jamming_factor_inc:GetFloat() * self:GrabJamFactorMult()))
	return self
end

function SWEP:IsJammed()
	if not self:CanBeJammed() then return false end
	return self:GetJammed()
end

function SWEP:NotifyJam()
	local ply = self:GetOwner()

	if IsValid(ply) and ply:IsPlayer() and IsFirstTimePredicted() and (not ply._TFA_LastJamMessage or ply._TFA_LastJamMessage < RealTime()) then
		ply:PrintMessage(HUD_PRINTCENTER, "#tfa.msg.weaponjammed")
		ply._TFA_LastJamMessage = RealTime() + 4
	end
end

function SWEP:CheckJammed()
	if not self:IsJammed() then return false end
	self:NotifyJam()
	return true
end

function SWEP:RollJamChance()
	if not self:CanBeJammed() then return false end
	if self:IsJammed() then return true end

	local chance = self:GetJamChance()
	local roll = util.SharedRandom('tfa_base_jam', math.max(0.002711997795105, math.pow(chance, 1.19)), 1, l_CT())

	if roll <= chance * sv_tfa_jamming_mult:GetFloat() then
		self:SetJammed(true)

		if IsFirstTimePredicted() then
			self:NotifyJam()
		end

		return true
	end

	return false
end

function SWEP:GrabJamChanceMult()
	return 1 -- override
end

function SWEP:GetJamChance()
	-- you can safely override this with your own logic if you desire
	local self2 = self:GetTable()
	if not self:CanBeJammed() then return 0 end
	return self:GetJamFactor() * sv_tfa_jamming_factor:GetFloat() * (self2.JamChance / 100) * self:GrabJamChanceMult()
end

SWEP.FlashlightSoundToggleOn = Sound("HL2Player.FlashLightOn")
SWEP.FlashlightSoundToggleOff = Sound("HL2Player.FlashLightOff")

function SWEP:ToggleFlashlight(toState)
	if toState == nil then
		toState = not self:GetFlashlightEnabled()
	end

	self:SetFlashlightEnabled(toState)
	self:EmitSoundNet(self:GetStatL("FlashlightSoundToggle" .. (toState and "On" or "Off")))
end

-- source engine save load
function SWEP:OnRestore()
	self:BuildAttachmentCache()

	self:InitializeAnims()
	self:InitializeMaterialTable()

	self:IconFix()
	self:RemoveEmptyRTCode()

	do -- attempt to restore attachments; weapons DO have owner so we don't need the precautions
		local OldFD = self:GetIsFirstDeploy()

		self:SetIsFirstDeploy(true) -- so extmag attachments don't unload the clip
		self.IsFirstDeploy = true
		for attName, sel in pairs(self.AttachmentCache or {}) do
			if sel then
				local att = TFA.Attachments.Atts[attName]

				if att and att.Attach then
					att:Attach(self)
				end
			end
		end
		self:SetIsFirstDeploy(OldFD)
		self.IsFirstDeploy = OldFD
	end
end

-- lua autorefresh / weapons.Register
function SWEP:OnReloaded()
	-- queue to next game frame since gmod is a fucking idiot
	timer.Simple(0, function()
		if not self:IsValid() then return end

		local baseclassSelf = table.Copy(baseclass.Get(self:GetClass()))
		if not baseclassSelf then return end

		local self2 = self:GetTable()

		self2.Primary_TFA.RangeFalloffLUTBuilt = nil
		self2.Primary.RangeFalloffLUTBuilt = nil

		--TFA.MigrateStructure(self, baseclassSelf, self:GetClass(), true)
		--TFA.MigrateStructure(self, self2, self:GetClass(), true)

		if istable(baseclassSelf.Primary) then
			self2.Primary_TFA = table.Copy(baseclassSelf.Primary)
			TFA.UnfoldBaseClass(baseclassSelf.Primary)
		end

		if istable(baseclassSelf.Secondary) then
			self2.Secondary_TFA = table.Copy(baseclassSelf.Secondary)
			TFA.UnfoldBaseClass(baseclassSelf.Secondary)
		end

		self2.StatCache_Blacklist = baseclassSelf.StatCache_Blacklist
		TFA.UnfoldBaseClass(self2.StatCache_Blacklist)

		if self2.StatCache_Blacklist_Real then
			table.Merge(self2.StatCache_Blacklist, self2.StatCache_Blacklist_Real)
		end

		self2.StatCache_Blacklist_Real = patch_blacklist(self2.StatCache_Blacklist, self2.TFADataVersion)

		self2.event_table_warning = false
		self2.event_table_built = false

		self2.AutoDetectMuzzle(self)
		self2.AutoDetectDamage(self)
		self2.AutoDetectDamageType(self)
		self2.AutoDetectForce(self)
		self2.AutoDetectPenetrationPower(self)
		self2.AutoDetectKnockback(self)
		self2.AutoDetectSpread(self)
		self2.AutoDetectRange(self)
		self2.IconFix(self)
		self2.RemoveEmptyRTCode(self)
		self2.ClearStatCache(self)
	end)
end

function SWEP:ProcessLoopSound()
	if sp and not SERVER then return end
	if self:GetNextLoopSoundCheck() < 0 or ct < self:GetNextLoopSoundCheck() or self:GetStatus() == TFA.Enum.STATUS_SHOOTING then return end

	self:SetNextLoopSoundCheck(-1)

	local tgtSound = self:GetStatL("Primary.LoopSound")

	if self:GetSilenced() then
		tgtSound = self:GetStatL("Primary.LoopSoundSilenced", tgtSound)
	end

	if tgtSound then
		self:StopSoundNet(tgtSound)
	end

	if (not sp and SERVER) or not self:IsFirstPerson() then
		tgtSound = self:GetSilenced() and self:GetStatL("Primary.LoopSoundSilenced_World", tgtSound) or self:GetStatL("Primary.LoopSound_World", tgtSound)

		if tgtSound then
			self:StopSoundNet(tgtSound)
		end
	end

	tgtSound = self:GetStatL("Primary.LoopSoundTail")

	if self:GetSilenced() then
		tgtSound = self:GetStatL("Primary.LoopSoundTailSilenced", tgtSound)
	end

	if (not sp and SERVER) or not self:IsFirstPerson() then
		tgtSound = self:GetSilenced() and self:GetStatL("Primary.LoopSoundTailSilenced_World", tgtSound) or self:GetStatL("Primary.LoopSoundTail_World", tgtSound)
	end

	if tgtSound and (SERVER or self.GunfireLoopIFTPHack) then
		self:EmitSoundNet(tgtSound, nil, true)
		self.GunfireLoopIFTPHack = false
	end
end

function SWEP:ProcessLoopFire()
	if sp and not IsFirstTimePredicted() then return end
	if (self:GetStatus() == TFA.Enum.STATUS_SHOOTING ) then
		if TFA.Enum.ShootLoopingStatus[self:GetShootStatus()] then
			self:SetShootStatus(TFA.Enum.SHOOT_LOOP)
		end
	else --not shooting
		if (not TFA.Enum.ShootReadyStatus[self:GetShootStatus()]) then
			if ( self:GetShootStatus() ~= TFA.Enum.SHOOT_CHECK ) then
				self:SetShootStatus(TFA.Enum.SHOOT_CHECK) --move to check first
			else --if we've checked for one more tick that we're not shooting
				self:SetShootStatus(TFA.Enum.SHOOT_IDLE) --move to check first

				if TFA.Enum.ReadyStatus[self:GetStatus()] then
					self:PlayAnimation(self:GetStatL("ShootAnimation.out")) --exit

					-- force flip walking and sprinting flags when needed
					if self:GetWalking() then
						self.walking_updated = true
					end
					if self:GetSprinting() then
						self.sprinting_updated = true
					end
				end
			end
		end
	end
end

--addons/tfa_base/lua/weapons/tfa_gun_base/common/utils.lua:
TFA.RangeFalloffLUTStep = 0.01
TFA.RangeFalloffLUTStepInv = 1 / TFA.RangeFalloffLUTStep

SWEP.AmmoRangeTable = {
	["SniperPenetratedRound"] = 2,
	["SniperPenetratedBullet"] = 2,
	["buckshot"] = 0.5,
	["ar2"] = 1,
	["smg1"] = 0.7,
	["pistol"] = 0.33,
	["def"] = 1
}

function SWEP:AmmoRangeMultiplier()
	return self.AmmoRangeTable[self.Primary_TFA.Ammo or "def"] or self.AmmoRangeTable["def"] or 1
end

function SWEP:MetersToUnits(x)
	return x * 39.3701 * 4 / 3
end

function SWEP:GetLastSequenceString()
	if not self:VMIV() then return "" end

	if self:GetLastSequence() < 0 then return "" end
	return self.OwnerViewModel:GetSequenceName(self:GetLastSequence())
end

local cv_3dmode = GetConVar("cl_tfa_scope_sensitivity_3d")

SWEP.SensitivtyFunctions = {
	[0] = function() return 1 end,
	[1] = function(self, ...)
		local zoom = self:GetStatL("Secondary.ScopeZoom")

		if zoom and zoom >= 1 then
			return TFA.CalculateSensitivtyScale(90 / zoom, self:GetStatL("Secondary.OwnerFOV"), self:GetStatL("Secondary.ScopeScreenScale"))
		else
			return self.SensitivtyFunctions[2](self, ...)
		end
	end,
	[2] = function(self, ...)
		local rtfov = self:GetStatL("RTScopeFOV")

		if rtfov and rtfov > 0 then
			return TFA.CalculateSensitivtyScale(rtfov, self:GetStatL("Secondary.OwnerFOV"), self:GetStatL("Secondary.ScopeScreenScale"))
		else
			return self.SensitivtyFunctions[0](self, ...)
		end
	end,
	[3] = function(self, ...)
		local rtfov = self:GetStatL("RTScopeFOV")

		if rtfov and rtfov > 0 then
			return TFA.CalculateSensitivtyScale(rtfov, self:GetStatL("Secondary.OwnerFOV"), 1)
		else
			return self.SensitivtyFunctions[0](self, ...)
		end
	end
}

function SWEP:Get3DSensitivity()
	local f = self.SensitivtyFunctions[cv_3dmode:GetInt()]

	return f(self)
end

function SWEP:GetSeed()
	local sd = math.floor(self:Clip1() + self:Ammo1() + self:Clip2() + self:Ammo2() + self:GetLastActivity()) + self:GetNextIdleAnim() + self:GetNextPrimaryFire() + self:GetNextSecondaryFire()

	return math.Round(sd)
end

function SWEP:GetSeedIrradical()
	return math.floor(self:Clip1() + self:Ammo1() + self:Clip2() + self:Ammo2() + self:GetLastActivity()) + self:GetNextIdleAnim() + self:GetNextPrimaryFire() + self:GetNextSecondaryFire()
end

SWEP.SharedRandomValues = {}
local seed

--math.random equivalent
function SWEP:SharedRandom(min, max, id)
	if min and not max then
		max = min
		min = 1
	end

	min = math.Round(min)
	max = math.Round(max)
	local key = (id or "Weapon") .. min .. max
	seed = self:GetSeed()
	local val = math.floor(util.SharedRandom(id or "Weapon", min, max + 1, seed))

	if self.SharedRandomValues[key] and self.SharedRandomValues[key] == val then
		if min < val and max > val then
			math.randomseed(seed)

			if (math.Rand(0, 1) < 0.5) then
				math.randomseed(seed + 1)
				val = math.random(min, val - 1)
			else
				math.randomseed(seed + 1)
				val = math.random(val + 1, max)
			end
		elseif min < val then
			math.randomseed(seed + 1)
			val = math.random(min, val - 1)
		elseif max > val then
			math.randomseed(seed + 1)
			val = math.random(val + 1, max)
		end
	end

	if IsFirstTimePredicted() then
		timer.Simple(0, function()
			if IsValid(self) then
				self.SharedRandomValues[key] = val
			end
		end)
	end

	return val
end

local oiv = nil
local rlcv = GetConVar("sv_tfa_reloads_enabled")
local holding_result_cached = false
local last_held_check = -1
local sp = game.SinglePlayer()
local slo, sqlo
local nm

--[[
local sqind

function SWEP:TranslateSequenceActivityTable( tbl )
	if not self:VMIV() then return end
	for k,v in pairs(tbl) do
		if type(k) == "string" then
			sqind = self.OwnerViewModel:GetSequenceActivity( self.OwnerViewModel:LookupSequence( k ) or -1 ) or -1
			tbl[ sqind ] = tbl[sqind] or v
		end
		tbl[k] = nil
	end
end
]]
--
--, seq )
function SWEP:GetActivityLengthRaw(tanim, status, animType)
	local vm = self:VMIVNPC()
	if not vm then return 0 end

	if tanim == nil then
		-- we already track last sequence so, we can account sequence
		tanim = self:GetLastSequence()
		animType = TFA.Enum.ANIMATION_SEQ
	end

	if tanim < 0 then return 0 end

	if animType == nil or animType == TFA.Enum.ANIMATION_ACT then
		nm = vm:GetSequenceName(vm:SelectWeightedSequenceSeeded(tanim, self:GetSeedIrradical()))
	else
		nm = vm:GetSequenceName(tanim)
	end

	local sqlen

	if animType == TFA.Enum.ANIMATION_SEQ then
		sqlen = vm:SequenceDuration(tanim)
	elseif tanim == vm:GetSequenceActivity(vm:GetSequence()) then
		sqlen = vm:SequenceDuration(vm:GetSequence())
	else
		sqlen = vm:SequenceDuration(vm:SelectWeightedSequenceSeeded(math.max(tanim or 1, 1), self:GetSeedIrradical()))
	end

	slo = self:GetStatL("StatusLengthOverride." .. nm) or self:GetStatL("StatusLengthOverride." .. (tanim or "0"))
	sqlo = self:GetStatL("SequenceLengthOverride." .. nm) or self:GetStatL("SequenceLengthOverride." .. (tanim or "0"))

	if status and slo then
		sqlen = slo
	elseif sqlo then
		sqlen = sqlo
	end

	return sqlen
end

function SWEP:GetActivityLength(tanim, status, animType)
	if not self:VMIVNPC() then return 0 end
	local sqlen = self:GetActivityLengthRaw(tanim, status, animType)
	if sqlen <= 0 then return 0 end
	return sqlen / self:GetAnimationRate(tanim)
end

function SWEP:GetHolding()
	if CurTime() > last_held_check + 0.2 then
		last_held_check = CurTime()
		holding_result_cached = nil
	end

	if holding_result_cached == nil then
		holding_result_cached = false

		if not IsValid(self:GetOwner()) or not self:GetOwner():IsPlayer() then
			holding_result_cached = false

			return false
		end

		local ent = self:GetOwner():GetNW2Entity("LastHeldEntity")

		if not IsValid(ent) then
			holding_result_cached = false

			return false
		end

		if ent.IsPlayerHolding then
			ent:SetNW2Bool("PlayerHolding", ent:IsPlayerHolding())
		end

		if ent:GetNW2Bool("PlayerHolding") then
			holding_result_cached = true

			return true
		end
	end

	return holding_result_cached
end

function SWEP:CanInterruptShooting()
	return self:GetStatL("Primary.RPM") > 160 and not self:GetStatL("BoltAction") and not self:GetStatL("BoltAction_Forced")
end

function SWEP:ReloadCV()
	if rlcv then
		if (not rlcv:GetBool()) and (not self.Primary_TFA.ClipSize_PreEdit) then
			self.Primary_TFA.ClipSize_PreEdit = self.Primary_TFA.ClipSize
			self.Primary_TFA.ClipSize = -1
			self:ClearStatCache()
		elseif rlcv:GetBool() and self.Primary_TFA.ClipSize_PreEdit then
			self.Primary_TFA.ClipSize = self.Primary_TFA.ClipSize_PreEdit
			self.Primary_TFA.ClipSize_PreEdit = nil
			self:ClearStatCache()
		end
	end
end

function SWEP:OwnerIsValid()
	if oiv == nil then
		oiv = IsValid(self:GetOwner())
	end

	return oiv
end

function SWEP:NullifyOIV()
	if oiv ~= nil then
		self:GetHolding()
		oiv = nil
	end

	return self:VMIV()
end

function SWEP:VMIVNPC()
	local ply = self:GetOwner()

	if ply:IsPlayer() then return self:VMIV() end

	if ply:IsNPC() then
		return self
	end

	return false
end

function SWEP:VMIV()
	local owent = self:GetOwner()

	if not IsValid(self.OwnerViewModel) then
		if IsValid(owent) and owent.GetViewModel then
			self.OwnerViewModel = owent:GetViewModel()
		end

		return false
	else
		if not IsValid(owent) or not owent.GetViewModel then
			self.OwnerViewModel = nil

			return false
		end

		return self.OwnerViewModel
	end
end

function SWEP:CanChamber()
	if self.C_CanChamber ~= nil then
		return self.C_CanChamber
	else
		self.C_CanChamber = not self:GetStatL("BoltAction") and not self:GetStatL("LoopedReload") and not self.Revolver and not self:GetStatL("Primary.DisableChambering")

		return self.C_CanChamber
	end
end

function SWEP:GetPrimaryClipSize(calc)
	local targetclip = self:GetStatL("Primary.ClipSize")

	if self:CanChamber() and not (calc and self:Clip1() <= 0) then
		targetclip = targetclip + (self:GetStatL("IsAkimbo") and 2 or 1)
	end

	return math.max(targetclip, -1)
end

function SWEP:GetPrimaryClipSizeForReload(calc)
	local targetclip = self:GetStatL("Primary.ClipSize")

	if self:CanChamber() and not (calc and self:Clip1() <= 0) and not self:IsJammed() then
		targetclip = targetclip + (self:GetStatL("IsAkimbo") and 2 or 1)
	end

	return math.max(targetclip, -1)
end

function SWEP:GetSecondaryClipSize(calc)
	local targetclip = self:GetStatL("Secondary.ClipSize")

	return math.max(targetclip, -1)
end

--[[

function SWEP:GetPrimaryAmmoType()
	return self:GetStatL( "Primary.Ammo" ) or ""
end

function SWEP:GetPrimaryAmmoTypeC()
	return self:GetStatL( "Primary.Ammo" ) or self:GetPrimaryAmmoType()
end

function SWEP:Ammo1()
	return self:GetOwner():GetAmmoCount( self:GetPrimaryAmmoTypeC() or 0 )
end

function SWEP:GetSecondaryAmmoType()
	return self:GetStatL( "Secondary.Ammo" ) or ""
end

function SWEP:GetSecondaryAmmoTypeC()
	return self:GetStatL( "Secondary.Ammo" ) or self:GetSecondaryAmmoType()
end

function SWEP:Ammo2()
	return self:GetOwner():GetAmmoCount( self:GetSecondaryAmmoTypeC() or -1 )
end

]]
--
local at

function SWEP:GetPrimaryAmmoTypeC()
	at = self:GetStatL("Primary.Ammo")

	if at and at ~= self.Primary_TFA.Ammo then
		return at
	elseif self.GetPrimaryAmmoTypeOld then
		return self:GetPrimaryAmmoTypeOld()
	else
		return self:GetPrimaryAmmoType()
	end
end

function SWEP:GetSecondaryAmmoTypeC()
	at = self:GetStatL("Secondary.Ammo")

	if at and at ~= self.Secondary_TFA.Ammo then
		return at
	elseif self.GetSecondaryAmmoTypeOld then
		return self:GetSecondaryAmmoTypeOld()
	else
		return self:GetSecondaryAmmoType()
	end
end

function SWEP:Ammo1()
	if not self:GetOwner():IsValid() then return 0 end
	if self:GetOwner():IsNPC() then return 9999 end

	return self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoTypeC() or 0)
end

function SWEP:Ammo2()
	if not self:GetOwner():IsValid() then return 0 end
	if self:GetOwner():IsNPC() then return 9999 end

	return self:GetOwner():GetAmmoCount(self:GetSecondaryAmmoTypeC() or -1)
end

-- Returns absolute delta of change in ammo count
function SWEP:TakePrimaryAmmo(num, pool)
	num = math.floor(num)
	if num == 0 then return 0 end

	if num < 0 then
		-- Doesn't use clips
		if self:GetStatL("Primary.ClipSize") < 0 or pool then
			if not self:GetOwner():IsPlayer() then return -num end -- assume NPCs always take all the ammo
			return self:GetOwner():GiveAmmo(-num, self:GetPrimaryAmmoTypeC())
		else
			local old = self:Clip1()
			local new = math.max(self:Clip1() - num, 0)
			self:SetClip1(new)
			return new - old
		end
	else
		-- Doesn't use clips
		if self:GetStatL("Primary.ClipSize") < 0 or pool then
			if not self:GetOwner():IsPlayer() then return num end -- assume NPCs always provide all the ammo
			local old = self:Ammo1()
			if old <= 0 then return 0 end
			local toRemove = math.min(old, num)
			self:GetOwner():RemoveAmmo(toRemove, self:GetPrimaryAmmoTypeC())
			return toRemove
		else
			local old = self:Clip1()
			local new = math.max(self:Clip1() - num, 0)
			self:SetClip1(new)
			return old - new
		end
	end
end

-- Returns absolute delta of change in ammo count
function SWEP:TakeSecondaryAmmo(num, pool)
	num = math.floor(num)
	if num == 0 then return 0 end

	if num < 0 then
		-- Doesn't use clips
		if self:GetStatL("Secondary.ClipSize") < 0 or pool then
			if not self:GetOwner():IsPlayer() then return -num end -- assume NPCs always take all the ammo
			return self:GetOwner():GiveAmmo(-num, self:GetSecondaryAmmoTypeC())
		else
			local old = self:Clip2()
			local new = math.max(self:Clip2() - num, 0)
			self:SetClip2(new)
			return new - old
		end
	else
		-- Doesn't use clips
		if self:GetStatL("Secondary.ClipSize") < 0 or pool then
			if not self:GetOwner():IsPlayer() then return num end -- assume NPCs always provide all the ammo
			local old = self:Ammo2()
			if old <= 0 then return 0 end
			local toRemove = math.min(old, num)
			self:GetOwner():RemoveAmmo(toRemove, self:GetSecondaryAmmoTypeC())
			return toRemove
		else
			local old = self:Clip2()
			local new = math.max(self:Clip2() - num, 0)
			self:SetClip2(new)
			return old - new
		end
	end
end

-- Inserts up to num ammo rounds into gun's primary clip
-- negative values will unload clip back into ammo reserve (WITHOUT accounting for max ammo reserve!)
-- Returns absolute delta of change in ammo count
function SWEP:InsertPrimaryAmmo(num)
	num = math.floor(num)
	local self2 = self:GetTable()

	if num > 0 then
		num = math.min(math.max(self:GetMaxClip1() - self:Clip1(), 0), num)
		return self2.TakePrimaryAmmo(self, -self2.TakePrimaryAmmo(self, num, true))
	end

	return self2.TakePrimaryAmmo(self, -self2.TakePrimaryAmmo(self, num, true))
end

-- Inserts up to num ammo rounds into gun's secondary clip
-- negative values will unload clip back into ammo reserve (WITHOUT accounting for max ammo reserve!)
-- Returns absolute delta of change in ammo count
function SWEP:InsertSecondaryAmmo(num)
	num = math.floor(num)
	local self2 = self:GetTable()

	if num > 0 then
		num = math.min(math.max(self:GetMaxClip2() - self:Clip2(), 0), num)
		return self2.TakeSecondaryAmmo(self, -self2.TakeSecondaryAmmo(self, num, true))
	end

	return self2.TakeSecondaryAmmo(self, -self2.TakeSecondaryAmmo(self, num, true))
end

function SWEP:IsEmpty1()
	return self:GetStatL("Primary.ClipSize") > 0 and self:Clip1() == 0 or
		self:GetStatL("Primary.ClipSize") <= 0 and self:Ammo1() == 0
end

function SWEP:IsEmpty2()
	return self:GetStatL("Secondary.ClipSize") > 0 and self:Clip2() == 0 or
		self:GetStatL("Secondary.ClipSize") <= 0 and self:Ammo2() == 0
end

SWEP.TakeAmmo1 = SWEP.TakePrimaryAmmo
SWEP.TakeAmmo2 = SWEP.TakeSecondaryAmmo

function SWEP:GetFireDelay()
	if self:GetMaxBurst() > 1 and self:GetStatL("Primary.RPM_Burst") and self:GetStatL("Primary.RPM_Burst") > 0 then
		return 60 / self:GetStatL("Primary.RPM_Burst")
	elseif self:GetStatL("Primary.RPM_Semi") and not self.Primary_TFA.Automatic and self:GetStatL("Primary.RPM_Semi") and self:GetStatL("Primary.RPM_Semi") > 0 then
		return 60 / self:GetStatL("Primary.RPM_Semi")
	elseif self:GetStatL("Primary.RPM") and self:GetStatL("Primary.RPM") > 0 then
		return 60 / self:GetStatL("Primary.RPM")
	else
		return self:GetStatL("Primary.Delay") or 0.1
	end
end

function SWEP:GetBurstDelay(bur)
	if not bur then
		bur = self:GetMaxBurst()
	end

	if bur <= 1 then return 0 end
	if self:GetStatL("Primary.BurstDelay") then return self:GetStatL("Primary.BurstDelay") end

	return self:GetFireDelay() * 3
end

local tickrate = engine.TickInterval()

function SWEP:GetNextCorrectedPrimaryFire(delay)
	local nextfire = self:GetNextPrimaryFire()
	local delta = CurTime() - nextfire

	if delta < 0 or delta > tickrate then
		nextfire = CurTime()
	end

	return nextfire + delay
end

function SWEP:GetNextCorrectedSecondaryFire(delay)
	local nextfire = self:GetNextSecondaryFire()
	local delta = CurTime() - nextfire

	if delta < 0 or delta > tickrate then
		nextfire = CurTime()
	end

	return nextfire + delay
end

--[[
Function Name:  IsSafety
Syntax: self:IsSafety().
Returns:   Are we in safety firemode.
Notes:  Non.
Purpose:  Utility
]]
--
function SWEP:IsSafety()
	if not self:GetStatL("FireModes") then return false end
	local fm = self:GetStatL("FireModes")[self:GetFireMode()]
	local fmn = string.lower(fm and fm or self:GetStatL("FireModes")[1])

	if fmn == "safe" or fmn == "holster" then
		return true
	else
		return false
	end
end

function SWEP:UpdateMuzzleAttachment()
	if not self:VMIV() then return end
	local vm = self.OwnerViewModel
	if not IsValid(vm) then return end
	self.MuzzleAttachmentRaw = nil

	if not self.MuzzleAttachmentSilenced then
		self.MuzzleAttachmentSilenced = (vm:LookupAttachment("muzzle_silenced") <= 0) and self.MuzzleAttachment or "muzzle_silenced"
	end

	if self:GetSilenced() and self.MuzzleAttachmentSilenced then
		self.MuzzleAttachmentRaw = vm:LookupAttachment(self.MuzzleAttachmentSilenced)

		if not self.MuzzleAttachmentRaw or self.MuzzleAttachmentRaw <= 0 then
			self.MuzzleAttachmentRaw = nil
		end
	end

	if not self.MuzzleAttachmentRaw and self.MuzzleAttachment then
		self.MuzzleAttachmentRaw = vm:LookupAttachment(self.MuzzleAttachment)

		if not self.MuzzleAttachmentRaw or self.MuzzleAttachmentRaw <= 0 then
			self.MuzzleAttachmentRaw = 1
		end
	end

	local mzm = self:GetStatL("MuzzleAttachmentMod", 0)

	if mzm then
		if isstring(mzm) then
			self.MuzzleAttachmentRaw = vm:LookupAttachment(mzm)
		elseif mzm > 0 then
			self.MuzzleAttachmentRaw = mzm
		end
	end
end

function SWEP:UpdateConDamage()
	if not IsValid(self) then return end

	if not self.DamageConVar then
		self.DamageConVar = GetConVar("sv_tfa_damage_multiplier")
	end

	if self.DamageConVar and self.DamageConVar.GetFloat then
		self.ConDamageMultiplier = self.DamageConVar:GetFloat()
	end
end

--[[
Function Name:  IsCurrentlyScoped
Syntax: self:IsCurrentlyScoped().
Returns:   Is the player scoped in enough to display the overlay?  true/false, returns a boolean.
Notes:  Change SWEP.ScopeOverlayThreshold to change when the overlay is displayed.
Purpose:  Utility
]]
--
function SWEP:IsCurrentlyScoped()
	return (self:GetIronSightsProgress() > self:GetStatL("ScopeOverlayThreshold")) and self:GetStatL("Scoped")
end

--[[
Function Name:  IsCurrently3DScoped
Syntax: self:IsCurrently3DScoped().
Returns:   Is player aiming down the sights while having a RT-enabled scope equipped?
Notes:
Purpose:  Utility
]]
--
function SWEP:IsCurrently3DScoped()
	return (self:GetStatL("RTDrawEnabled") or self.RTCode ~= nil) and self:GetIronSights()
end

--[[
Function Name:  IsHidden
Syntax: self:IsHidden().
Returns:   Should we hide self?.
Notes:
Purpose:  Utility
]]
--
function SWEP:GetHidden()
	if not self:VMIV() then return true end
	if self.DrawViewModel ~= nil and not self.DrawViewModel then return true end
	if self.ShowViewModel ~= nil and not self.ShowViewModel then return true end
	if self:GetHolding() then return true end

	return self:IsCurrentlyScoped()
end

--[[
Function Name:  IsFirstPerson
Syntax: self:IsFirstPerson().
Returns:   Is the owner in first person.
Notes:  Broken in singplayer because gary.
Purpose:  Utility
]]
--
function SWEP:IsFirstPerson()
	if not IsValid(self) or not self:OwnerIsValid() then return false end
	if self:GetOwner():IsNPC() then return false end
	if CLIENT and (not game.SinglePlayer()) and self:GetOwner() ~= GetViewEntity() then return false end
	if sp and SERVER then return not self:GetOwner().TFASDLP end
	if self:GetOwner().ShouldDrawLocalPlayer and self:GetOwner():ShouldDrawLocalPlayer() then return false end
	if LocalPlayer and hook.Call("ShouldDrawLocalPlayer", GAMEMODE, self:GetOwner()) then return false end

	return true
end

--[[
Function Name:  GetMuzzlePos
Syntax: self:GetMuzzlePos( hacky workaround that doesn't work anyways ).
Returns:   The AngPos for the muzzle attachment.
Notes:  Defaults to the first attachment, and uses GetFPMuzzleAttachment
Purpose:  Utility
]]
--
local fp

function SWEP:GetMuzzleAttachment()
	local vmod = self.OwnerViewModel
	local att = math.max(1, self.MuzzleAttachmentRaw or (sp and vmod or self):LookupAttachment(self.MuzzleAttachment))

	if self:GetStatL("IsAkimbo") then
		att = 1 + self:GetAnimCycle()
	end

	return att
end

function SWEP:GetMuzzlePos(ignorepos)
	fp = self:IsFirstPerson()
	local vm = self.OwnerViewModel

	if not IsValid(vm) then
		vm = self
	end

	-- Avoid returning strings inside MuzzleAttachmentMod, since this would decrease performance
	-- Better call :UpdateMuzzleAttachment() or return number in MuzzleAttachmentMod
	local obj = self:GetStatL("MuzzleAttachmentMod") or self.MuzzleAttachmentRaw or vm:LookupAttachment(self.MuzzleAttachment)

	if type(obj) == "string" then
		obj = tonumber(obj) or vm:LookupAttachment(obj)
	end

	local muzzlepos
	obj = math.Clamp(obj or 1, 1, 128)

	if fp then
		muzzlepos = vm:GetAttachment(obj)
	else
		muzzlepos = self:GetAttachment(obj)
	end

	return muzzlepos
end

function SWEP:FindEvenBurstNumber()
	local burstOverride = self:GetStatL("BurstFireCount")

	if burstOverride then
		return burstOverride
	end

	if (self:GetStatL("Primary.ClipSize") % 3 == 0) then
		return 3
	elseif (self:GetStatL("Primary.ClipSize") % 2 == 0) then
		return 2
	else
		local i = 4

		while i <= 7 do
			if self:GetStatL("Primary.ClipSize") % i == 0 then return i end
			i = i + 1
		end
	end

	return nil
end

function SWEP:GetFireModeName()
	local fm = self:GetFireMode()
	local fmn = string.lower(self:GetStatL("FireModes")[fm])
	if fmn == "safe" or fmn == "holster" then return language.GetPhrase("tfa.firemode.safe") end
	if self:GetStatL("FireModeName") then return language.GetPhrase(self:GetStatL("FireModeName")) end
	if fmn == "auto" or fmn == "automatic" then return language.GetPhrase("tfa.firemode.auto") end

	if fmn == "semi" or fmn == "single" then
		if self:GetStatL("Revolver") then
			if (self:GetStatL("BoltAction")) then
				return language.GetPhrase("tfa.firemode.single")
			else
				return language.GetPhrase("tfa.firemode.revolver")
			end
		else
			if (self:GetStatL("BoltAction")) then
				return language.GetPhrase("tfa.firemode.bolt")
			else
				if self:GetStatL("LoopedReload") and self:GetStatL("Primary.RPM") < 250 then
					return language.GetPhrase("tfa.firemode.pump")
				else
					return language.GetPhrase("tfa.firemode.semi")
				end
			end
		end
	end

	local bpos = string.find(fmn, "burst")
	if bpos then return language.GetPhrase("tfa.firemode.burst"):format(string.sub(fmn, 1, bpos - 1)) end

	return ""
end

SWEP.BurstCountCache = {}

function SWEP:GetMaxBurst()
	local fm = self:GetFireMode()

	if not self.BurstCountCache[fm] then
		local fmt = self:GetStatL("FireModes")
		local fmn = string.lower(fmt[fm])
		local bpos = string.find(fmn, "burst")

		if bpos then
			self.BurstCountCache[fm] = tonumber(string.sub(fmn, 1, bpos - 1))
		else
			self.BurstCountCache[fm] = 1
		end
	end

	return self.BurstCountCache[fm]
end

--[[
Function Name:  CycleFireMode
Syntax: self:CycleFireMode()
Returns:  Nothing.
Notes: Cycles to next firemode.
Purpose:  Feature
]]
--
local l_CT = CurTime

SWEP.FireModesAutomatic = {
	["Automatic"] = true,
	["Auto"] = true,
}

SWEP.FireModeSound = Sound("Weapon_AR2.Empty") -- firemode toggle sound

function SWEP:CycleFireMode()
	local ct = l_CT()
	local fm = self:GetFireMode()
	fm = fm + 1

	if fm >= #self:GetStatL("FireModes") then
		fm = 1
	end

	self:SetFireMode(fm)
	local success, tanim, ttype = self:ChooseROFAnim()

	if success then
		self:SetNextPrimaryFire(ct + self:GetActivityLength(tanim, false, ttype))
	else
		self:EmitSound(self:GetStatL("FireModeSound"))
		self:SetNextPrimaryFire(ct + math.max(self:GetFireDelay(), 0.25))
	end

	self.BurstCount = 0
	self:SetIsCyclingSafety(false)
	self:SetStatus(TFA.Enum.STATUS_FIREMODE, self:GetNextPrimaryFire())

	self.Primary.Automatic = self:IsFireModeAutomatic(fm)
	self.Primary_TFA.Automatic = self.Primary.Automatic
end

--[[
Function Name:  CycleSafety
Syntax: self:CycleSafety()
Returns:  Nothing.
Notes: Toggles safety
Purpose:  Feature
]]
--
function SWEP:CycleSafety()
	local ct = l_CT()
	local fm = self:GetFireMode()
	local fmt = self:GetStatL("FireModes")

	self.BurstCount = 0
	self:SetIsCyclingSafety(true)
	self:SetIronSightsRaw(false)

	if fm ~= #fmt then
		self.LastFireMode = fm
		self:SetFireMode(#fmt)
	else
		self:SetFireMode(self.LastFireMode or 1)
	end

	local success, tanim, ttype = self:ChooseROFAnim()

	if success then
		self:SetSafetyCycleAnimated(true)
		self:SetNextPrimaryFire(ct + self:GetActivityLength(tanim, false, ttype))
	else
		self:SetSafetyCycleAnimated(false)
		self:EmitSound(self:GetStatL("FireModeSound"))
		self:SetNextPrimaryFire(ct + math.max(self:GetFireDelay(), 0.25))
	end

	self:SetStatus(TFA.Enum.STATUS_FIREMODE, self:GetNextPrimaryFire())

	if self:IsSafety() then
		self.Primary.Automatic = false
		self.Primary_TFA.Automatic = false
	else
		self.Primary.Automatic = self:IsFireModeAutomatic()
		self.Primary_TFA.Automatic = self.Primary.Automatic
	end
end

--[[
Function Name:  1FireMode
Syntax: self:ProcessFireMode()
Returns:  Nothing.
Notes: Processes fire mode changing and whether the swep is auto or not.
Purpose:  Feature
]]
--
function SWEP:ProcessFireMode()
	if self:GetOwner():IsNPC() then return end

	if self:GetOwner().GetInfoNum and self:GetOwner():GetInfoNum("cl_tfa_keys_firemode", 0) > 0 then
		return
	end

	if self:OwnerIsValid() and self:KeyPressed(IN_RELOAD) and self:KeyDown(IN_USE) and self:GetStatus() == TFA.Enum.STATUS_IDLE and (SERVER or not sp) then
		if self:GetStatL("SelectiveFire") and not self:KeyDown(IN_SPEED) then
			self:CycleFireMode()
		elseif self:GetOwner():KeyDown(IN_SPEED) then
			self:CycleSafety()
		end
	end
end

--[[
Function Name:  Unload
Syntax: self:Unload()
Returns:  Nothing.
Notes: Returns Clip1 ammo to reserve.
Purpose:  Utility
]]
--
function SWEP:Unload()
	local amm = self:Clip1()
	self:SetClip1(0)

	if self.OwnerIsValid and self:OwnerIsValid() and self.Owner.GiveAmmo then
		self:GetOwner():GiveAmmo(amm, self:GetPrimaryAmmoType(), true)
	end
end

--[[
Function Name:  Unload
Syntax: self:Unload()
Returns:  Nothing.
Notes: Returns Clip1 ammo to reserve.
Purpose:  Utility
]]
--
function SWEP:Unload2()
	local amm = self:Clip2()
	self:SetClip2(0)

	if self.OwnerIsValid and self:OwnerIsValid() and self.Owner.GiveAmmo then
		self:GetOwner():GiveAmmo(amm, self:GetSecondaryAmmoType(), true)
	end
end

local penetration_hitmarker_cvar = GetConVar("sv_tfa_penetration_hitmarker")

function SWEP:SendHitMarker(ply, traceres, dmginfo)
	if CLIENT or not penetration_hitmarker_cvar:GetBool() then return end
	if not IsValid(ply) or not ply:IsPlayer() then return end

	local hm3d = ply:GetInfoNum("cl_tfa_hud_hitmarker_3d_all", 0) > 0
	local hm3d_sg = ply:GetInfoNum("cl_tfa_hud_hitmarker_3d_shotguns", 0) > 0 and self:GetStatL("Primary.NumShots") > 1

	if hm3d or hm3d_sg then
		net.Start("tfaHitmarker3D", true)
		net.WriteVector(traceres.HitPos)
		net.Send(ply)
	else
		net.Start("tfaHitmarker", true)
		net.Send(ply)
	end
end

SWEP.VMSeqCache = {}
local vm -- are you fucking kidding me

function SWEP:CheckVMSequence(seqname)
	if not IsValid(self) then return false end
	vm = self.OwnerViewModel
	if not IsValid(vm) then return false end
	local mdl = vm:GetModel()
	if not mdl then return false end
	self.VMSeqCache[mdl] = self.VMSeqCache[mdl] or {}

	if self.VMSeqCache[mdl][seqname] == nil then
		self.VMSeqCache[mdl][seqname] = vm:LookupSequence(seqname) >= 0
	end

	return self.VMSeqCache[mdl][seqname]
end

do
	local function sorter(a, b)
		return a.range < b.range
	end

	local function linear(a) return a end

	function SWEP:BuildFalloffTable(input, step)
		if step == nil then step = TFA.RangeFalloffLUTStep end

		table.sort(input.lut, sorter)

		if input.lut[1].range > 0 then
			for i = #input.lut, 1, -1 do
				input.lut[i + 1] = input.lut[i]
			end

			input.lut[1] = {range = 0, damage = 1}
		end

		local div = (input.units == "hammer" or input.units == "inches" or input.units == "inch" or input.units == "hu") and 1 or 0.0254

		local build = {}
		local minimal = input.lut[1].range
		local maximal = input.lut[#input.lut].range

		local fnrange = isfunction(input.range_func) and input.range_func or
			input.range_func == "quintic" and TFA.Quintic or
			input.range_func == "cubic" and TFA.Cubic or
			input.range_func == "cosine" and TFA.Cosine or
			input.range_func == "sinusine" and TFA.Sinusine or
			linear

		if input.bezier then
			local build_range = {}
			local build_damage = {}

			for _, data in ipairs(input.lut) do
				table.insert(build_range, data.range / div)
				table.insert(build_damage, data.damage)
			end

			for i = 0, 1, step do
				local value = fnrange(i)
				table.insert(build, {TFA.tbezier(value, build_range), TFA.tbezier(value, build_damage)})
			end
		else
			local current, next = input.lut[1], input.lut[2]
			local nextindex = 1

			for i = 0, 1, step do
				local value = fnrange(i)
				local interp = Lerp(value, minimal, maximal)

				if next.range < interp then
					nextindex = nextindex + 1
					current, next = input.lut[nextindex], input.lut[nextindex + 1]
				end

				if not current or not next then break end -- safeguard
				table.insert(build, {interp / div, Lerp(1 - (next.range - interp) / (next.range - current.range), current.damage, next.damage)})
			end
		end

		return build
	end
end

function SWEP:IncreaseRecoilLUT()
	if not self:HasRecoilLUT() then return end

	local self2 = self:GetTable()
	local time = CurTime()

	if not self:GetRecoilThink() then
		self:SetRecoilThink(true)
	end

	if not self:GetRecoilLoop() then
		local newvalue = self:GetRecoilInProgress() + self2.Primary_TFA.RecoilLUT["in"].increase

		self:SetRecoilInProgress(math.min(1, newvalue))

		self:SetRecoilInWait(time + self2.Primary_TFA.RecoilLUT["in"].wait)

		if self:GetRecoilInProgress() >= 1 then
			self:SetRecoilLoop(true)
			self:SetRecoilLoopProgress(math.Clamp(newvalue % 1, 0, 1))
			self:SetRecoilLoopWait(time + self2.Primary_TFA.RecoilLUT["loop"].wait)
		end

		return
	end

	local sub = 0

	if self:GetRecoilOutProgress() ~= 0 then
		local prev = self:GetRecoilOutProgress()
		local newvalue = math.max(0, prev - self2.Primary_TFA.RecoilLUT["out"].increase)
		self:SetRecoilOutProgress(newvalue)
		self:SetRecoilLoopWait(time + self2.Primary_TFA.RecoilLUT["loop"].wait)

		if newvalue ~= 0 then
			return
		end

		sub = self2.Primary_TFA.RecoilLUT["out"].increase - prev
	end

	local newvalue = (self:GetRecoilLoopProgress() + self2.Primary_TFA.RecoilLUT["loop"].increase + sub) % 1
	self:SetRecoilLoopProgress(newvalue)
	self:SetRecoilLoopWait(time + self2.Primary_TFA.RecoilLUT["loop"].wait)
end

function SWEP:HasRecoilLUT()
	return self.Primary_TFA.RecoilLUT ~= nil
end

do
	local function linear(a) return a end

	local function getfn(input)
		return isfunction(input.func) and input.func or
			input.func == "quintic" and TFA.Quintic or
			input.func == "cubic" and TFA.Cubic or
			input.func == "cosine" and TFA.Cosine or
			input.func == "sinusine" and TFA.Sinusine or
			linear
	end

	function SWEP:GetRecoilLUTAngle()
		if not self:GetRecoilThink() then
			return Angle()
		end

		local self2 = self:GetTable()
		local isp = 1 - self:GetIronSightsProgress() * self2.GetStatL(self, "Primary.RecoilLUT_IronSightsMult")

		if not self:GetRecoilLoop() then
			-- currently, we only playing IN animation

			local t = getfn(self2.Primary_TFA.RecoilLUT["in"])(self:GetRecoilInProgress())

			local pitch = TFA.tbezier(t, self2.Primary_TFA.RecoilLUT["in"].points_p)
			local yaw = TFA.tbezier(t, self2.Primary_TFA.RecoilLUT["in"].points_y)

			return Angle(pitch * isp, yaw * isp)
		end

		local out = getfn(self2.Primary_TFA.RecoilLUT["out"])(self:GetRecoilOutProgress())
		local loop = getfn(self2.Primary_TFA.RecoilLUT["loop"])(self:GetRecoilLoopProgress())

		local pitch = TFA.tbezier(loop, self2.Primary_TFA.RecoilLUT["loop"].points_p)
		local yaw = TFA.tbezier(loop, self2.Primary_TFA.RecoilLUT["loop"].points_y)

		if out ~= 0 then
			-- cooling out
			self2.Primary_TFA.RecoilLUT["out"].points_p[1] = pitch
			self2.Primary_TFA.RecoilLUT["out"].points_y[1] = yaw

			local pitch2 = TFA.tbezier(out, self2.Primary_TFA.RecoilLUT["out"].points_p)
			local yaw2 = TFA.tbezier(out, self2.Primary_TFA.RecoilLUT["out"].points_y)

			return Angle(pitch2 * isp, yaw2 * isp)
		end

		return Angle(pitch * isp, yaw * isp)
	end
end

local sv_tfa_recoil_legacy = GetConVar("sv_tfa_recoil_legacy")

function SWEP:GetAimVector()
	return self:GetAimAngle():Forward()
end

function SWEP:GetAimAngle()
	local ang = self:GetOwner():GetAimVector():Angle()

	if sv_tfa_recoil_legacy:GetBool() and self:GetOwner():IsPlayer() then
		ang:Add(self:GetOwner():GetViewPunchAngles())
	elseif self:HasRecoilLUT() then
		ang:Add(self:GetRecoilLUTAngle())
	else
		ang.p = ang.p + self:GetViewPunchP()
		ang.y = ang.y + self:GetViewPunchY()
	end

	ang:Normalize()
	return ang
end

function SWEP:EmitSoundNet(sound, ifp, shouldPause)
	if ifp == nil then ifp = IsFirstTimePredicted() end
	if not ifp then return end

	if shouldPause == nil then shouldPause = false end

	if CLIENT and sp then return end

	if CLIENT or sp then
		self:EmitSound(sound, nil, nil, nil, nil, shouldPause and SND_SHOULDPAUSE or SND_NOFLAGS)
		return
	end

	local filter = RecipientFilter()

	filter:AddPAS(self:GetPos())

	if IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() then
		filter:RemovePlayer(self:GetOwner())
	end

	if filter:GetCount() == 0 then return end

	net.Start("tfaSoundEvent", true)
	net.WriteEntity(self)
	net.WriteString(sound)
	net.WriteBool(shouldPause)
	net.Send(filter)
end

function SWEP:StopSoundNet(sound, ifp)
	if ifp == nil then ifp = IsFirstTimePredicted() end
	if not ifp then return end

	if CLIENT and sp then return end

	if CLIENT or sp then
		self:StopSound(sound)
		return
	end

	local filter = RecipientFilter()

	filter:AddPAS(self:GetPos())

	if IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() then
		filter:RemovePlayer(self:GetOwner())
	end

	if filter:GetCount() == 0 then return end

	net.Start("tfaSoundEventStop", true)
	net.WriteEntity(self)
	net.WriteString(sound)
	net.Send(filter)
end

function SWEP:IsFireModeAutomatic(fm)
	local fmn

	if type(fm) == "string" then
		fmn = fm
	elseif type(fm) == "number" then
		fmn = self:GetStatL("FireModes")[fm]
	else
		fmn = self:GetStatL("FireModes")[self:GetFireMode()]
	end

	return self:GetStatL("FireModesAutomatic." .. fmn) == true
end

function SWEP:ShouldEmitGunfireLoop(tableName)
	if self:IsFireModeAutomatic() then return true end
	if not self:GetStatL((tableName or "Primary") .. ".LoopSoundAutoOnly", false) then return true end

	return false
end

function SWEP:ShouldPlayLoopShootAnim()
	if self:IsFireModeAutomatic() then return true end
	if not self:GetStatL("ShootAnimationLoopAutoOnly", true) then return true end

	return false
end

--addons/tfa_base/lua/weapons/tfa_gun_base/client/flashlight.lua:
local vector_origin = Vector()

local att, angpos, attname, elemname, targetent
SWEP.FlashlightDistance = 12 * 50 -- default 50 feet
SWEP.FlashlightAttachment = 0
SWEP.FlashlightBrightness = 1
SWEP.FlashlightFOV = 60

local Material = Material
local ProjectedTexture = ProjectedTexture
local math = math

local function IsHolstering(wep)
	if IsValid(wep) and TFA.Enum.HolsterStatus[wep:GetStatus()] then return true end

	return false
end

-- TODO: This seems to be *extremely* similar to drawlaser
-- Should we merge them?
function SWEP:DrawFlashlight(is_vm)
	local self2 = self:GetTable()

	if not self2.FlashlightDotMaterial then
		self2.FlashlightDotMaterial = Material(self2.GetStatL(self, "FlashlightMaterial") or "effects/flashlight001")
	end

	local ply = self:GetOwner()
	if not IsValid(ply) then return end

	if not self:GetFlashlightEnabled() then
		self:CleanFlashlight()

		return
	end

	if is_vm then
		if not self2.VMIV(self) then
			self:CleanFlashlight()

			return
		end

		targetent = self2.OwnerViewModel
		elemname = self2.GetStatL(self, "Flashlight_VElement", self2.GetStatL(self, "Flashlight_Element"))

		local ViewModelElements = self:GetStatRaw("ViewModelElements", TFA.LatestDataVersion)

		if elemname and ViewModelElements[elemname] and IsValid(ViewModelElements[elemname].curmodel) then
			targetent = ViewModelElements[elemname].curmodel
		end

		att = self2.GetStatL(self, "FlashlightAttachment")

		attname = self2.GetStatL(self, "FlashlightAttachmentName")

		if attname then
			att = targetent:LookupAttachment(attname)
		end

		if (not att) or att <= 0 then
			self:CleanFlashlight()

			return
		end

		angpos = targetent:GetAttachment(att)

		if not angpos then
			self:CleanFlashlight()

			return
		end

		if self2.FlashlightISMovement and self2.CLIronSightsProgress > 0 then
			local isang = self2.GetStatL(self, "IronSightsAngle")
			angpos.Ang:RotateAroundAxis(angpos.Ang:Right(), isang.y * (self2.ViewModelFlip and -1 or 1) * self2.CLIronSightsProgress)
			angpos.Ang:RotateAroundAxis(angpos.Ang:Up(), -isang.x * self2.CLIronSightsProgress)
		end

		local localProjAng = select(2, WorldToLocal(vector_origin, angpos.Ang, vector_origin, EyeAngles()))
		localProjAng.p = localProjAng.p * ply:GetFOV() / self2.ViewModelFOV
		localProjAng.y = localProjAng.y * ply:GetFOV() / self2.ViewModelFOV
		local wsProjAng = select(2, LocalToWorld(vector_origin, localProjAng, vector_origin, EyeAngles())) --reprojection for view angle

		if not IsValid(ply.TFAFlashlightGun) and not IsHolstering(self) then
			local lamp = ProjectedTexture()
			ply.TFAFlashlightGun = lamp
			lamp:SetTexture(self2.FlashlightDotMaterial:GetString("$basetexture"))
			lamp:SetFarZ(self2.GetStatL(self, "FlashlightDistance")) -- How far the light should shine
			lamp:SetFOV(self2.GetStatL(self, "FlashlightFOV"))
			lamp:SetPos(angpos.Pos)
			lamp:SetAngles(angpos.Ang)
			lamp:SetBrightness(self2.GetStatL(self, "FlashlightBrightness") * (0.9  + 0.1 * math.max(math.sin(CurTime() * 120), math.cos(CurTime() * 40))))
			lamp:SetNearZ(1)
			lamp:SetColor(color_white)
			lamp:SetEnableShadows(true)
			lamp:Update()
		end

		local lamp = ply.TFAFlashlightGun

		if IsValid(lamp) then
			lamp:SetPos(angpos.Pos)
			lamp:SetAngles(wsProjAng)
			lamp:SetBrightness(1.4 + 0.1 * math.max(math.sin(CurTime() * 120), math.cos(CurTime() * 40)))
			lamp:Update()
		end

		return
	end

	targetent = self

	elemname = self2.GetStatL(self, "Flashlight_WElement", self2.GetStatL(self, "Flashlight_Element"))

	local WorldModelElements = self:GetStatRaw("WorldModelElements", TFA.LatestDataVersion)

	if elemname and WorldModelElements[elemname] and IsValid(WorldModelElements[elemname].curmodel) then
		targetent = WorldModelElements[elemname].curmodel
	end

	att = self2.GetStatL(self, "FlashlightAttachmentWorld", self2.GetStatL(self, "FlashlightAttachment"))

	attname = self2.GetStatL(self, "FlashlightAttachmentNameWorld", self2.GetStatL(self, "FlashlightAttachmentName"))

	if attname then
		att = targetent:LookupAttachment(attname)
	end

	if (not att) or att <= 0 then
		self:CleanFlashlight()

		return
	end

	angpos = targetent:GetAttachment(att)

	if not angpos then
		angpos = targetent:GetAttachment(1)
	end

	if not angpos then
		self:CleanFlashlight()

		return
	end

	if not IsValid(ply.TFAFlashlightGun) and not IsHolstering(self) then
		local lamp = ProjectedTexture()
		ply.TFAFlashlightGun = lamp
		lamp:SetTexture(self2.FlashlightDotMaterial:GetString("$basetexture"))
		lamp:SetFarZ(self2.GetStatL(self, "FlashlightDistance")) -- How far the light should shine
		lamp:SetFOV(self2.GetStatL(self, "FlashlightFOV"))
		lamp:SetPos(angpos.Pos)
		lamp:SetAngles(angpos.Ang)
		lamp:SetBrightness(self2.GetStatL(self, "FlashlightBrightness") * (0.9  + 0.1 * math.max(math.sin(CurTime() * 120), math.cos(CurTime() * 40))))
		lamp:SetNearZ(1)
		lamp:SetColor(color_white)
		lamp:SetEnableShadows(false)
		lamp:Update()
	end

	local lamp = ply.TFAFlashlightGun

	if IsValid(lamp) then
		local lamppos = angpos.Pos
		local ang = angpos.Ang
		lamp:SetPos(lamppos)
		lamp:SetAngles(ang)
		lamp:SetBrightness(self2.GetStatL(self, "FlashlightBrightness") * (0.9  + 0.1 * math.max(math.sin(CurTime() * 120), math.cos(CurTime() * 40))))
		lamp:Update()
	end
end

function SWEP:CleanFlashlight()
	local ply = self:GetOwner()

	if IsValid(ply) and IsValid(ply.TFAFlashlightGun) then
		ply.TFAFlashlightGun:Remove()
	end
end

TFA.SWEP_LOAD_COMPLETE = true
--addons/egm_tfa_grenades/lua/weapons/tfa_ins2_nade_base/cl_init.lua:
include('shared.lua')

--addons/tfa_base/lua/weapons/tfa_nade_base.lua:
if SERVER then
	AddCSLuaFile()
end

local CurTime = CurTime
local sp = game.SinglePlayer()

DEFINE_BASECLASS("tfa_gun_base")
SWEP.DrawCrosshair = true
SWEP.Type = "Grenade"
SWEP.IsGrenade = true
SWEP.MuzzleFlashEffect = ""
SWEP.Secondary.IronSightsEnabled = false
SWEP.Delay = 0.3 -- Delay to fire entity
SWEP.Delay_Underhand = 0.3 -- Delay to fire entity when underhand
SWEP.Primary.Round = "" -- Nade Entity
SWEP.Velocity = 550 -- Entity Velocity
SWEP.Underhanded = false
SWEP.DisableIdleAnimations = true
SWEP.IronSightsPosition = Vector(5,0,0)
SWEP.IronSightsAngle = Vector(0,0,0)
SWEP.Callback = {}

SWEP.AllowUnderhanded = true

SWEP.AllowSprintAttack = true

local nzombies = nil

function SWEP:Initialize()
	if nzombies == nil then
		nzombies = engine.ActiveGamemode() == "nzombies"
	end

	self.ProjectileEntity = self.ProjectileEntity or self.Primary.Round -- Entity to shoot
	self.ProjectileVelocity = self.Velocity or 550  -- Entity to shoot's velocity
	self.ProjectileModel = nil                                          -- Entity to shoot's model

	self:SetNW2Bool("Underhanded", false)

	BaseClass.Initialize(self)
end

local cl_defaultweapon = GetConVar("cl_defaultweapon")

function SWEP:SwitchToPreviousWeapon()
	local wep = LocalPlayer():GetPreviousWeapon()

	if IsValid(wep) and wep:IsWeapon() and wep:GetOwner() == LocalPlayer() then
		input.SelectWeapon(wep)
	else
		wep = LocalPlayer():GetWeapon(cl_defaultweapon:GetString())

		if IsValid(wep) then
			input.SelectWeapon(wep)
		else
			local _
			_, wep = next(LocalPlayer():GetWeapons())

			if IsValid(wep) then
				input.SelectWeapon(wep)
			end
		end
	end
end

function SWEP:Deploy()
	if self:Clip1() <= 0 then
		if self:Ammo1() <= 0 then
			if self:GetOwner():IsPlayer() then
				if CLIENT and not sp then
					self:SwitchToPreviousWeapon()
				elseif SERVER and not nzombies then
					if sp then
						self:CallOnClient("SwitchToPreviousWeapon", "")
						local ply = self:GetOwner()
						local classname = self:GetClass()
						timer.Simple(0, function() ply:StripWeapon(classname) end)
					else
						self:GetOwner():StripWeapon(self:GetClass())
						return
					end
				end
			end
		else
			self:TakePrimaryAmmo(1, true)
			self:SetClip1(1)
		end
	end

	self:SetNW2Bool("Underhanded", false)

	self.oldang = self:GetOwner():EyeAngles()
	self.anga = Angle()
	self.angb = Angle()
	self.angc = Angle()

	self:CleanParticles()

	return BaseClass.Deploy(self)
end

function SWEP:ChoosePullAnim()
	if not self:OwnerIsValid() then return end

	if self.Callback.ChoosePullAnim then
		self.Callback.ChoosePullAnim(self)
	end

	if self:GetOwner():IsPlayer() then
		self:GetOwner():SetAnimation(PLAYER_RELOAD)
	end

	self:SendViewModelAnim(ACT_VM_PULLPIN)

	if sp then
		self:CallOnClient("AnimForce", ACT_VM_PULLPIN)
	end

	return true, ACT_VM_PULLPIN
end

function SWEP:ChooseShootAnim()
	if not self:OwnerIsValid() then return end

	if self.Callback.ChooseShootAnim then
		self.Callback.ChooseShootAnim(self)
	end

	if self:GetOwner():IsPlayer() then
		self:GetOwner():SetAnimation(PLAYER_ATTACK1)
	end

	local tanim = self:GetNW2Bool("Underhanded", false) and self.SequenceEnabled[ACT_VM_RELEASE] and ACT_VM_RELEASE or ACT_VM_THROW
	self:SendViewModelAnim(tanim)

	if sp then
		self:CallOnClient("AnimForce", tanim)
	end

	return true, tanim
end

function SWEP:ThrowStart()
	if self:Clip1() <= 0 then return end

	local success, tanim, animType = self:ChooseShootAnim()

	local delay = self:GetNW2Bool("Underhanded", false) and self.Delay_Underhand or self.Delay
	self:ScheduleStatus(TFA.Enum.STATUS_GRENADE_THROW, delay)

	if success then
		self.LastNadeAnim = tanim
		self.LastNadeAnimType = animType
		self.LastNadeDelay = delay
	end
end

function SWEP:Throw()
	if self:Clip1() <= 0 then return end
	self.ProjectileVelocity = (self:GetNW2Bool("Underhanded", false) and self.Velocity_Underhand) or ((self.Velocity or 550) / 1.5)

	self:TakePrimaryAmmo(1)
	self:ShootBulletInformation()

	if self.LastNadeAnim then
		local len = self:GetActivityLength(self.LastNadeAnim, true, self.LastNadeAnimType)
		self:ScheduleStatus(TFA.Enum.STATUS_GRENADE_THROW_WAIT, len - (self.LastNadeDelay or len))
	end
end

function SWEP:Think2(...)
	if not self:OwnerIsValid() then return end

	local stat = self:GetStatus()

	-- This is the best place to do this since Think2 is called inside FinishMove
	self:SetNW2Bool("Underhanded", self.AllowUnderhanded and self:KeyDown(IN_ATTACK2))

	local statusend = CurTime() >= self:GetStatusEnd()

	if stat == TFA.Enum.STATUS_GRENADE_PULL and statusend then
		stat = TFA.Enum.STATUS_GRENADE_READY
		self:SetStatus(stat, math.huge)
	end

	if stat == TFA.Enum.STATUS_GRENADE_READY and (self:GetOwner():IsNPC() or not self:KeyDown(IN_ATTACK2) and not self:KeyDown(IN_ATTACK)) then
		self:ThrowStart()
	end

	if stat == TFA.Enum.STATUS_GRENADE_THROW and statusend then
		self:Throw()
	end

	if stat == TFA.Enum.STATUS_GRENADE_THROW_WAIT and statusend then
		self:Deploy()
	end

	return BaseClass.Think2(self, ...)
end

function SWEP:PrimaryAttack()
	if self:Clip1() <= 0 or not self:OwnerIsValid() or not self:CanFire() then return end

	local _, tanim = self:ChoosePullAnim()

	self:ScheduleStatus(TFA.Enum.STATUS_GRENADE_PULL, self:GetActivityLength(tanim))
	self:SetNW2Bool("Underhanded", false)
end

function SWEP:SecondaryAttack()
	self:PrimaryAttack()
	self:SetNW2Bool("Underhanded", self.AllowUnderhanded)
end

function SWEP:Reload()
	if self:Clip1() <= 0 and self:OwnerIsValid() and self:CanFire() then
		self:Deploy()
	end
end

function SWEP:CanFire() -- what
	if not self:CanPrimaryAttack() then return false end
	return true
end

function SWEP:ChooseIdleAnim(...)
	if self:GetStatus() == TFA.Enum.STATUS_GRENADE_READY then return end
	return BaseClass.ChooseIdleAnim(self, ...)
end

SWEP.CrosshairConeRecoilOverride = .05

TFA.FillMissingMetaValues(SWEP)

--addons/tfa_base/lua/weapons/tfa_sword_advanced_base.lua:
local vector_origin = Vector()

if SERVER then
	AddCSLuaFile()
end

-- This base is kept for backward compatiblity purposes
-- This should not, by any means, be utilized in newer SWEPS
-- Look at melee base/knife base

--[[
PLEASE DON TUSE THIS ANYMIRE
PLEASe
PLEASSSSSSSS
]]
DEFINE_BASECLASS("tfa_gun_base")
SWEP.Primary.Ammo = "" -- Required for GMod legacy purposes.  Don't remove unless you want to see your sword's ammo.  Wat?
SWEP.data = {} --Ignore this.
--[[SWEP Info]]
--
SWEP.Gun = "" -- must be the name of your swep but NO CAPITALS!
SWEP.Category = ""
SWEP.Base = "tfa_gun_base"
SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = "Left click to slash" .. "\n" .. "Hold right mouse to put up guard."
SWEP.PrintName = "Snowflake Katana" -- Weapon name (Shown on HUD)
SWEP.Slot = 0 -- Slot in the weapon selection menu
SWEP.SlotPos = 21 -- Position in the slot
SWEP.DrawAmmo = false -- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox = true -- Should draw the weapon info box
SWEP.BounceWeaponIcon = false -- Should the weapon icon bounce?
SWEP.DrawCrosshair = false -- set false if you want no crosshair
SWEP.Weight = 50 -- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo = true -- Auto switch to if we pick it up
SWEP.AutoSwitchFrom = true -- Auto switch from if you pick up a better weapon
SWEP.Secondary.OwnerFOV = 90 -- How much you "zoom" in. Less is more!  Don't have this be <= 0
SWEP.WeaponLength = 8 --16 = 1 foot
SWEP.MoveSpeed = 0.9 --Multiply the player's movespeed by this.
SWEP.IronSightsMoveSpeed = 0.8 --Multiply the player's movespeed by this when sighting.
SWEP.IsMelee = true
SWEP.AllowSprintAttack = true
--[[TTT CRAP]]
--
-- SWEP.Kind = WEAPON_EQUIP
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
-- SWEP.CanBuy = {ROLE_TRAITOR, ROLE_DETECTIVE, ROLE_INNOCENT} -- only traitors can buy
-- SWEP.LimitedStock = true -- only buyable once
-- SWEP.NoSights = false
-- SWEP.IsSilent = true
--[[Worldmodel Variables]]
--
SWEP.HoldType = "melee2" -- how others view you carrying the weapon
SWEP.BlockHoldType = "slam" -- how others view you carrying the weapon, while blocking
--[[
Options:
normal - Pistol Idle / Weaponless, hands at sides
melee - One Handed Melee
melee2 - Two Handed Melee
fist - Fists Raised
knife - Knife/Dagger style melee.  Kind of hunched.
smg - SMG or Rifle with grip
ar2 - Rifle
pistol - One handed pistol
rpg - Used for RPGs or sometimes snipers.  AFAIK has no reload anim.
physgun - Used for physgun.  Kind of like SLAM, but holding a grip.
grenade - Used for nades, kind of similar to melee but more of a throwing animation.
shotgun - Used for shotugns, and really that's it.
crossbow -Similar to shotgun, but aimed.  Used for crossbows.
slam - Holding an explosive or other rectangular object with two hands
passive -- SMG idle, like you can see with some HL2 citizens
magic - One hand to temple, the other reaching out.  Can be used to mimic blocking a melee, if you're OK with the temple-hand-thing.
duel- dual pistols
revolver - 2 handed pistol
--]]
SWEP.WorldModel = "" -- Weapon world model
SWEP.ShowWorldModel = true --Draw the world model?
SWEP.Spawnable = false --Can it be spawned by a user?
SWEP.AdminSpawnable = false --Can it be spawned by an admin?
--[[Viewmodel Variables]]
--
SWEP.UseHands = true --Uses c_hands?  If you port a model directly from HL2, CS:S, etc. then set to false
	SWEP.ViewModelFOV = 60 --This controls the viewmodel FOV.  The larger, the smaller it appears.  Decrease if you can see something you shouldn't.
	SWEP.ViewModelFlip = false --Flip the viewmodel?  Usually gonna be yes for CS:S ports.
	SWEP.ViewModel = "" -- Weapon view model
	--[[Shooting/Attacking Vars]]
	--
	SWEP.Primary.Damage = 200 -- Base damage per bullet
	SWEP.DamageType = DMG_SLASH
	SWEP.Primary.RPM = 180 -- This is in Rounds Per Minute
	SWEP.Primary.KickUp = 0.4 -- Maximum up recoil (rise)
	SWEP.Primary.KickDown = 0.3 -- Maximum down recoil (skeet)
	SWEP.Primary.KickHorizontal = 0.3 -- Maximum up recoil (stock)
	SWEP.Primary.Automatic = false -- Automatic = true; Semi Auto = false.  In the case of our sword, if you can hold and keep swinging.
	SWEP.Primary.FiresUnderwater = true --Can you swing your sword underwater?
	--[[ Block Procedural Animation Variables]]
	--
	SWEP.BlockPos = Vector(-18, -10, 3) --Blocking Position.
	SWEP.BlockAng = Vector(10, -25, -15) --Blocking Angle.
	--[[Begin Slashing Variables]]
	--
	SWEP.Slash = 1
	SWEP.Sequences = {} --Swinging Sequences
	--[[
	SWEP.Sequences[1]={
	name="swipe_u2d",--Sequence name, can be found in HLMV
	holdtype="melee2",--Holdtype (thirdperson type of weapon, usually gonna be melee for a one handed or melee2 for a two handed)
	startt=10/60,--swing start in seconds, from the sequence start
endt=20/60,--swing end in seconds, from the sequence start
pitch=5, --This is a component of the slash's arc.  Pitch is added last, and changes based on the time of the trace.
yaw=35, --This is a component of the slash's arc.  Yaw is added second, and changes based on the time of the trace.
roll=-90,--This is a component of the slash's arc.  Roll is added first, and remains static.
dir=1--Left to right = -1, right to left =1.  Base this off if the roll were 0.
}
SWEP.Sequences[2]={
name="swipe_l2r",
holdtype="melee2",
startt=10/60,
endt=20/60,
pitch=5,
yaw=45,
roll=10,
dir=-1
}
SWEP.Sequences[3]={
name="swipe_r2l",
holdtype="melee2",
startt=10/60,
endt=20/60,
pitch=5,
yaw=45,
roll=-5,
dir=1
}
]]
--
SWEP.SlashRandom = Angle(5, 0, 10) --This is a random angle for the overall slash, added onto the sequence angle
SWEP.SlashJitter = Angle(1, 1, 1) --This is jitter for each point of the slash
SWEP.randfac = 0 --Don't change this, it's autocalculated
SWEP.HitRange = 86 -- Blade Length.  Set slightly longer to compensate for animation.
SWEP.AmmoType = "TFMSwordHitGenericSlash" --Ammotype.  You can set a damage type in a custom ammo, which you can create in autorun.  Then set it to that custom ammotype here.
SWEP.SlashPrecision = 15 --The number of traces per slash
SWEP.SlashDecals = 8 --The number of decals per slash.  May slightly vary
SWEP.SlashSounds = 6 --The number of sounds per slash.  May slightly vary.
SWEP.LastTraceTime = 0 --Don't change this, it's autocalculated
SWEP.NextPrimaryFire = 0 --In case SetNextPrimaryFire doesn't work.  Don't change this here.  Please.
--[[Blocking Variables]]
--
SWEP.BlockSequences = {} --Sequences for blocking
--[[
SWEP.BlockSequences[1]={
name="swipe_u2d", --Sequence name, can be found in HLMV
recoverytime=0.3, --Recovery Time (Added onto sequence time, if enabled)
recoverysequence=false  --Automatically add recovery time based on sequence length
}
SWEP.BlockSequences[2]={
name="swipe_l2r",
recoverytime=0.3,
recoverysequence=false
}
SWEP.BlockSequences[3]={
name="swipe_r2l",
recoverytime=0.3,
recoverysequence=false
}
]]
--
SWEP.DisableIdleAnimations = false --Disables idle animations.  Set to false to enable them.
SWEP.IronBobMult = 1 -- More is more bobbing, proportionally.  This is multiplication, not addition.  You want to make this < 1 for sighting, 0 to outright disable.
SWEP.NinjaMode = false --Can block bullets/everything
SWEP.DrawTime = 0.2 --Time you can't swing after drawing
SWEP.BlockAngle = 135 --Think of the player's view direction as being the middle of a sector, with the sector's angle being this
SWEP.BlockMaximum = 0.1 --Multiply damage by this for a maximumly effective block
SWEP.BlockMinimum = 0.7 --Multiply damage by this for a minimumly effective block
SWEP.BlockWindow = 0.5 --Time to absorb maximum damage
SWEP.BlockFadeTime = 1 --Time for blocking to do minimum damage.  Does not include block window
SWEP.PrevBlocking = false --Don't change this, just related to the block procedural animation
SWEP.BlockProceduralAnimTime = 0.15 --Change how slow or quickly the player moves their sword to block
--[[Sounds]]
--
--These are just kinda constants you can use.  Don't change these, or do if you want to be lazy.
SWEP.SlashSound = Sound("weapons/blades/woosh.mp3") --Weapon woosh/slash sound
SWEP.KnifeShink = Sound("weapons/blades/hitwall.mp3") --When a knife hits a wall.  Grating noise.
SWEP.KnifeSlash = Sound("weapons/blades/slash.mp3") --Meaty slash
SWEP.KnifeStab = Sound("weapons/blades/nastystab.mp3") --Meaty stab and pull-out
SWEP.SwordChop = Sound("weapons/blades/swordchop.mp3") --Meaty impact, without the pull-out
SWEP.SwordClash = Sound("weapons/blades/clash.mp3") --Sound played when you block something
--[[ Edit These ]]
--
SWEP.Primary.Sound = SWEP.SlashSound --Change this to your swing sound
SWEP.Primary.Sound_Impact_Flesh = SWEP.SwordChop --Change this to your flesh hit sound
SWEP.Primary.Sound_Impact_Generic = SWEP.KnifeShink --Change this to your generic hit sound
SWEP.Primary.Sound_Impact_Metal = SWEP.SwordClash --Change this to your metal hit
SWEP.Primary.Sound_Pitch_Low = 97 --Percentage of pitch out of 100, lowe end.  Up to 255.
SWEP.Primary.Sound_Pitch_High = 100 --Percentage of pitch out of 100  Up to 255.
SWEP.Primary.Sound_World_Glass_Enabled = true --Override for glass?
SWEP.Primary.Sound_Glass_Enabled = true --Override for glass?
SWEP.Primary.Sound_Glass = Sound("impacts/glass_impact.wav")
SWEP.GlassSoundPlayed = false -- DO NOT CHANGE THIS.  It's automatically set.   This way, it doesn't spam the glass sound.
SWEP.ViewModelElements = {} --View elements
SWEP.WorldModelElements = {} --World elements
SWEP.sounds = 0
SWEP.Action = true --Use action IDs?
--[[Stop editing here for normal users of my base.  Code starts here.]]--
--[[
function SWEP:Precache()
util.PrecacheSound(self.Primary_TFA.Sound)
util.PrecacheModel(self.ViewModel)
util.PrecacheModel(self.WorldModel)
end
]]--

function SWEP:Deploy()
	self:SetNW2Float("SharedRandomVal", CurTime())
	self:SetBlockStart(-1)
	self.PrevBlockRat = 0
	BaseClass.Deploy(self)
end

function SWEP:SetupDataTables()
	BaseClass.SetupDataTables(self)

	self:NetworkVarTFA("Float", "BlockStart")
end

function SWEP:DoImpactEffect(tr, dmg)
	local impactpos, impactnormal
	impactpos = tr.HitPos
	impactnormal = tr.HitNormal
	self.sounds = self.sounds and self.sounds or 0

	if (tr.HitSky == false) then
		if (util.SharedRandom(CurTime(), 1, self.SlashPrecision, "TFMSwordDecal") < self.SlashDecals) then
			util.Decal("ManhackCut", impactpos + impactnormal, impactpos - impactnormal)
		end

		if (tr.MatType == MAT_GLASS) and (self.Primary_TFA.Sound_Glass and self.Primary_TFA.Sound_Glass_Enabled == true) and (self.GlassSoundPlayed == false) then
			self:EmitSound(self.Primary_TFA.Sound_Glass, 100, math.random(self.Primary_TFA.Sound_Pitch_Low, self.Primary_TFA.Sound_Pitch_High), 0.75, CHAN_WEAPON)
			self.GlassSoundPlayed = true
		end
	end

	return true
end

function SWEP:HitThing(ent, posv, normalv, damage, tr)
	local ply
	ply = self:GetOwner()

	if IsValid(ply) then
		--[[
		ply:LagCompensation(true)
		local tr,tres;
		tr={}
		tr.start=posv
		tr.endpos=posv+normalv*self.HitRange
		tr.filter=ply
		tr.mask=2147483647--MASK_SOLID && MASK_SHOT && MASK_VISIBLE_AND_NPCS--MASK_SHOT
		tres=util.TraceLine(tr)
		ply:LagCompensation(false)
		if tres.Hit and tres.Fraction<1 and !tres.HitSky then
		]]
		--
		local bullet = {}
		bullet.Num = 1
		bullet.Src = posv -- Source
		bullet.Dir = normalv -- Dir of bullet
		bullet.Spread = vector_origin -- Aim Cone
		bullet.Tracer = 0 -- Show a tracer on every x bullets
		bullet.Force = damage / 16 -- Amount of force to give to phys objects
		bullet.Damage = damage
		bullet.Distance = self.HitRange
		bullet.HullSize = self.WeaponLength / self.SlashPrecision
		bullet.AmmoType = self.AmmoType

		bullet.Callback = function(a, b, c)
			local wep = a:GetActiveWeapon()
			if not IsValid(self) then return end
			if not self.sounds then return end
			c:SetDamageType(self.DamageType)

			if (self.sounds < self.SlashSounds) then
				local hitmat = b.MatType

				if (hitmat == MAT_METAL or hitmat == MAT_GRATE or hitmat == MAT_VENT or hitmat == MAT_COMPUTER) then
					--Emit metal sound
					wep.Weapon:EmitSound(self.Primary_TFA.Sound_Impact_Metal, 100, math.random(self.Primary_TFA.Sound_Pitch_Low, self.Primary_TFA.Sound_Pitch_High), 0.75, CHAN_AUTO)
					wep.sounds = self.sounds + 1
					--Emit flesh sound
					--Emit generic sound.
				elseif (hitmat == MAT_FLESH or hitmat == MAT_BLOODYFLESH or hitmat == MAT_ALIENFLESH) then
					wep.Weapon:EmitSound(self.Primary_TFA.Sound_Impact_Flesh, 100, math.random(self.Primary_TFA.Sound_Pitch_Low, self.Primary_TFA.Sound_Pitch_High), 0.75, CHAN_AUTO)
					wep.sounds = self.sounds + 1
				else
					wep.Weapon:EmitSound(self.Primary_TFA.Sound_Impact_Generic, 100, math.random(self.Primary_TFA.Sound_Pitch_Low, self.Primary_TFA.Sound_Pitch_High), 0.75, CHAN_AUTO)
					wep.sounds = self.sounds + 1
				end
			end
		end

		if CLIENT and SERVER then
			if self:GetOwner() ~= LocalPlayer() then
				self:GetOwner():FireBullets(bullet)
			end
		else
			self:GetOwner():FireBullets(bullet)
		end
		--end
	end
end

function SWEP:PrimaryAttack()
	local sharedrandomval = self:GetNW2Float("SharedRandomVal", 0)
	math.randomseed(sharedrandomval)
	if CLIENT and not IsFirstTimePredicted() then return end
	if not self:OwnerIsValid() then return end
	if CurTime() < self:GetNextPrimaryFire() then return end
	if not TFA.Enum.ReadyStatus[self:GetStatus()] then return end

	if self:IsSafety() then return end
	self:SetStatus(TFA.Enum.STATUS_SHOOTING)
	self.sounds = 0
	self:ChooseShootAnim() -- View model animation

	if SERVER then
		timer.Simple(0, function()
			if IsValid(self) then
				self:SetNW2Float("SharedRandomVal", math.Rand(-1024, 1024))
			end
		end)
	end

	local vm = self.OwnerViewModel
	self:GetOwner():SetAnimation(PLAYER_ATTACK1)
	self:GetOwner():SetNW2Float("TFM_SwingStart", CurTime())
	self:SetStatusEnd(CurTime() + vm:SequenceDuration(vm:LookupSequence(self.Sequences[self:GetNW2Int("Slash", 1)].name)))
	self.LastTraceTime = CurTime() + self.Sequences[self:GetNW2Int("Slash", 1)].startt

	self:SetNextPrimaryFire(CurTime() + 1 / (self.Primary_TFA.RPM / 60))

	if SERVER then
		timer.Simple(self.Sequences[self:GetNW2Int("Slash", 1)].startt, function()
			if IsValid(self) and self.Primary_TFA.Sound then
				self:EmitSound(self.Primary_TFA.Sound)
			end
		end)
	end
end

local seq, swe
local ft, len, strikepercent, swingprogress, sws
local aimoff, jitfac
local blockseqn, ply
local vm

function SWEP:IronSights()
	BaseClass.IronSights(self)
	ply = self:GetOwner()
	seq = self.Sequences[self:GetNW2Int("Slash", 1)]
	swe = ply:GetNW2Float("TFM_SwingStart", CurTime()) + seq.endt

	if CurTime() < swe then
		self:SetIronSightsRaw(false)
	end
end


function SWEP:Think2(...)
	BaseClass.Think2(self, ...)

	local isr = self:GetIronSightsProgress()

	ply = self:GetOwner()

	if self.PrevBlockRat and isr and self.PrevBlockRat <= 0.3 and isr > 0.3 then
		self:SetBlockStart(CurTime())
		--print(CurTime())
	end

	if isr and self.PrevBlockRat and isr < 0.1 and self.PrevBlockRat > 0.1 then
		self:SetBlockStart(-1)
		--print(-1)
	end

	self.PrevBlockRat = isr
	local stat = self:GetStatus()
	if stat == TFA.Enum.STATUS_SHOOTING then
		seq = self.Sequences[self:GetNW2Int("Slash", 1)]
		ft = CurTime() - self.LastTraceTime
		len = seq.endt - seq.startt
		strikepercent = ft / len
		sws = ply:GetNW2Float("TFM_SwingStart", CurTime()) + seq.startt
		swe = ply:GetNW2Float("TFM_SwingStart", CurTime()) + seq.endt
		swingprogress = (CurTime() - sws) / len

		if CurTime() < swe then
			self:SetIronSightsRaw(false)
		end

		if (CurTime() > sws) and CurTime() < swe and ft > len / self.SlashPrecision and (strikepercent > 0) then
			aimoff = ply:EyeAngles()
			--aimoff = Angle(0,0,0)
			local cutangle = Angle(seq.pitch * (swingprogress - 0.5) * seq.dir, seq.yaw * (swingprogress - 0.5) * seq.dir, seq.roll)
			jitfac = 0.5 - util.SharedRandom("TFMSwordJitter", 0, 1, CurTime())
			aimoff:RotateAroundAxis(aimoff:Forward(), cutangle.r + self.SlashRandom.r * self.randfac + self.SlashJitter.r * jitfac) --Roll is static
			aimoff:RotateAroundAxis(aimoff:Up(), cutangle.y + self.SlashRandom.y * self.randfac + self.SlashJitter.y * jitfac)
			aimoff:RotateAroundAxis(aimoff:Right(), cutangle.p + self.SlashRandom.p * self.randfac + self.SlashJitter.p * jitfac)
			self:HitThing(ply, ply:GetShootPos(), aimoff:Forward(), self.Primary_TFA.Damage * strikepercent)
			self.LastTraceTime = CurTime()
		end
	end
end

function SWEP:ChooseShootAnim(mynewvar)
	local sharedrandomval = self:GetNW2Float("SharedRandomVal", 0)
	if not self:OwnerIsValid() then return end
	if not IsValid(self) or not self:OwnerIsValid() then return end
	ply = self:GetOwner()
	vm = self.OwnerViewModel
	local selection = {}
	local relativedir = WorldToLocal(ply:GetVelocity(), Angle(0, 0, 0), vector_origin, ply:EyeAngles())
	local fwd = relativedir.x
	local hor = relativedir.y

	if hor < -ply:GetWalkSpeed() / 2 then
		for k, v in pairs(self.Sequences) do
			if v.right then
				table.insert(selection, #selection + 1, k)
			end
		end
	elseif hor > ply:GetWalkSpeed() / 2 then
		for k, v in pairs(self.Sequences) do
			if v.left then
				table.insert(selection, #selection + 1, k)
			end
		end
	elseif fwd > ply:GetWalkSpeed() / 2 then
		for k, v in pairs(self.Sequences) do
			if (v.up) then
				table.insert(selection, #selection + 1, k)
			end
		end
	elseif fwd < ply:GetWalkSpeed() / 2 then
		for k, v in pairs(self.Sequences) do
			if (v.down) then
				table.insert(selection, #selection + 1, k)
			end
		end
	end

	if #selection <= 0 and math.abs(fwd) < ply:GetWalkSpeed() / 2 and math.abs(hor) < ply:GetWalkSpeed() / 2 then
		for k, v in pairs(self.Sequences) do
			if v.up or v.down then
				table.insert(selection, #selection + 1, k)
			end
		end
	end

	if #selection <= 0 and math.abs(hor) < ply:GetWalkSpeed() / 2 and math.abs(fwd) < ply:GetWalkSpeed() / 2 then
		for k, v in pairs(self.Sequences) do
			if v.standing then
				table.insert(selection, #selection + 1, k)
			end
		end
	end

	if #selection <= 0 then
		--print("random test:")
		math.randomseed(sharedrandomval)

		if math.random(0, 1) == 0 then
			math.randomseed(sharedrandomval)
			self:SetNW2Int("Slash", math.random(1, #self.Sequences))
		else
			self:SetNW2Int("Slash", self:GetNW2Int("Slash", 1) + 1)

			if self:GetNW2Int("Slash", 1) > #self.Sequences then
				self:SetNW2Int("Slash", 1)
			end
		end
		--print("selection sequence")
		--print(math.Round( util.SharedRandom( "TFAMelee", 1, #selection, sharedrandomval ) ))
	else
		math.randomseed(sharedrandomval)
		self:SetNW2Int("Slash", selection[math.random(1, #selection)])
	end

	--print("Shared Random Value:")
	--print(sharedrandomval)
	--print("Slash Number")
	--print(self:GetNW2Int("Slash",0))
	local n = tonumber(mynewvar and mynewvar or "")
	local seqn = n and n or self:GetNW2Int("Slash", 1)
	--self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
	seq = self.Sequences[seqn]
	--vm:ResetSequence(vm:LookupSequence(seq.name))
	--print(seq.name)
	local seqid = vm:LookupSequence(seq.name)
	seqid = seqid and seqid or 0
	local actid = vm:GetSequenceActivity(seqid)

	if actid and actid >= 0 and self.Action then
		self:SendViewModelAnim(actid)
		--vm:SendViewModelMatchingSequence(seqid)
	else
		self:SendViewModelSeq(seqid)
	end

	if SERVER and game.SinglePlayer() then
		self:CallOnClient("ChooseShootAnim", tostring(seqn))
	end

	return true, ACT_VM_PRIMARYATTACK
end

function SWEP:BlockAnim()
	local sharedrandomval = self:GetNW2Float("SharedRandomVal", 0)

	if self.BlockSequences and #self.BlockSequences > 0 then
		math.randomseed(sharedrandomval)
		blockseqn = math.random(1, #self.BlockSequences)
		seq = self.BlockSequences[blockseqn]
		ply = self:GetOwner()

		if IsValid(ply) then
			vm = self.OwnerViewModel

			if IsValid(vm) then
				self:SetNextIdleAnim(-1)
				self:SendWeaponAnim(ACT_VM_IDLE)
				vm:SendViewModelMatchingSequence(vm:LookupSequence(seq.name))

				if seq.recoverysequence and seq.recoverysequence == true then
					if seq.recoverytime then
						self.NextPrimaryFire = CurTime() + vm:SequenceDuration() + seq.recoverytime
						self:SetNextPrimaryFire(CurTime() + vm:SequenceDuration() + seq.recoverytime)
						self:SetStatus(TFA.Enum.STATUS_FIDGET)
						self:SetStatusEnd(self.NextPrimaryFire)
					else
						self.NextPrimaryFire = CurTime() + vm:SequenceDuration()
						self:SetNextPrimaryFire(CurTime() + vm:SequenceDuration())
						self:SetStatus(TFA.Enum.STATUS_FIDGET)
						self:SetStatusEnd(self.NextPrimaryFire)
					end
				else
					self.NextPrimaryFire = CurTime() + seq.recoverytime

					if seq.recoverytime then
						self.NextPrimaryFire = CurTime() + seq.recoverytime
						self:SetNextPrimaryFire(CurTime() + seq.recoverytime)
					else
						self.NextPrimaryFire = CurTime()
						self:SetNextPrimaryFire(CurTime())
					end
				end
			end
		end
	end
end

--lua/weapons/weapon_chemlight/cl_init.lua:
include('shared.lua')

SWEP.Slot			= 4; 
SWEP.SlotPos		= 8; 
SWEP.Spawnable		= true
SWEP.AdminSpawnable	= true
SWEP.WepSelectIcon	= surface.GetTextureID( "vgui/entities/glowstick2" )
--lua/weapons/weapon_chemlight_green/shared.lua:
if ( CLIENT ) then
	language.Add ("ent_chemlight", "Chemlight")
	language.Add ("glowsticks_ammo", "Glow Sticks")
	language.Add ("cleanup_glowsticks", "Chemlight")
	language.Add ("cleaned_glowsticks", "Chemlight is gone!")
  	SWEP.DrawAmmo			= true
	SWEP.DrawCrosshair		= true
	SWEP.ViewModelFOV		= 67
	SWEP.ViewModelFlip		= false
	SWEP.CSMuzzleFlashes	= false
	SWEP.HoldType			= "slam"	
	SWEP.PrintName			= "Chemlight Green"
	SWEP.Author				= "Patrick Hunt"
end
SWEP.IronSightsPos  = Vector(0, -16, -56)
SWEP.IronSightsAng  = Vector(0, 0, 0)

function SWEP:GetViewModelPosition(EyePos, EyeAng)
	local Mul = 1.0

	local Offset = self.IronSightsPos

	if (self.IronSightsAng) then
        EyeAng = EyeAng * 1
        
		EyeAng:RotateAroundAxis(EyeAng:Right(), 	self.IronSightsAng.x * Mul)
		EyeAng:RotateAroundAxis(EyeAng:Up(), 		self.IronSightsAng.y * Mul)
		EyeAng:RotateAroundAxis(EyeAng:Forward(),   self.IronSightsAng.z * Mul)
	end

	local Right 	= EyeAng:Right()
	local Up 		= EyeAng:Up()
	local Forward 	= EyeAng:Forward()

	EyePos = EyePos + Offset.x * Right * Mul
	EyePos = EyePos + Offset.y * Forward * Mul
	EyePos = EyePos + Offset.z * Up * Mul
	
	return EyePos, EyeAng
end

SWEP.Author					= "Patrick Hunt"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions			= "Use primary attack to throw a glowstick and secondary to drop."
SWEP.HoldType				= "slam"
SWEP.Category				= "Chemlight"

SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

--SWEP.ViewModel				= "models/weapons/c_glowstick.mdl"
--SWEP.WorldModel				= "models/glowstick/glowstick.mdl"
SWEP.UseHands				= true
SWEP.BounceWeaponIcon		= false
SWEP.DrawWeaponInfoBox		= false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= 5
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "glowsticks"
SWEP.Primary.Delay			= 1

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"
SWEP.Secondary.Delay		= 1


function SWEP:Initialize()
	util.PrecacheSound("glowstick/glowstick_snap.wav");
	util.PrecacheSound("glowstick/glowstick_shake.wav");
	self:SetWeaponHoldType( self.HoldType )
	
if GetGlobalBool( "global_Cheml_oldmodel" ) then 
self.ViewModel				= "models/weapons/c_chemstick_antic.mdl"
self.WorldModel				= "models/glowstick/chemstick_antic.mdl"
elseif GetGlobalBool( "global_Cheml_oldmodel" ) == false then
self.ViewModel				= "models/weapons/c_chemstick.mdl" 
self.WorldModel				= "models/glowstick/chemstick.mdl"
end

end

function SWEP:Think()
	if self.Owner:IsBot() then self:SetColor(Color(0,255,0,255)) else -- Bots create a shipload of errors since they don't have any client vars on them so let's set them all green (or i'm just stupid)
	self:SetColor(Color(0, 255, 0, 255)) -- Paints world model in real time
	if IsValid(self.Owner) then
		if CLIENT then
		local dlight = DynamicLight(self:EntIndex()+66, true)
			if dlight then
				dlight.pos = self.Owner:EyePos() - (self.Owner:GetAimVector() * 16)
				dlight.r = 0
				dlight.g = 255
				dlight.b = 0
				dlight.brightness = 6
				dlight.Decay = 1
				dlight.Size = 64
				--dlight.DieTime = CurTime() + 10
				
			end
		end
	end
	end
end


function SWEP:Deploy()
	self:SetColor(Color(0,255,0,255))
	if !self.Owner:IsBot() then
	self.Weapon:SendWeaponAnim(ACT_VM_DRAW);
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.55)
	self.Weapon:SetNextSecondaryFire(CurTime() + 0.55)
	timer.Remove( "weapon_chemlight_green"..self.Owner:EntIndex() )
	timer.Create( "weapon_chemlight_green"..self.Owner:EntIndex(), 1.5, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end ) end
	if SERVER then
	
	-------------------------------------------------
	
			local matrix = self.Owner:GetBoneMatrix(1)
			local chempos = matrix:GetTranslation()

	local worldmodel = ents.FindInSphere(chempos,15)
	for k, v in pairs(worldmodel) do 
		if v:GetClass() == "ent_chemlight_glow_green" and v:GetOwner() == self.Owner and SERVER then
			v:Remove()
	end
	end
	
	-------------------------------------------------

	local glow = ents.Create("ent_chemlight_glow_green")
		glow:SetOwner(self.Owner) 
		glow:FollowBone( self.Owner, 1 )
		glow:SetLocalPos(Vector(0,0,0))
		if self.Owner:IsBot() then self:SetColor(Color(0,255,0,255)) else
		glow:SetColor(Color(0, 255, 0, 255))
		end
		//glow:SetMaterial(self.Owner:GetMaterial())
		glow:Spawn()
		self.chemlightindex = glow:EntIndex()
	end
   return true
end



local cooldown = 0.5
local cooldown2 = 2
local lastReloadTime=0;
function SWEP:Reload()
if self.Owner:GetNW2Int( "chemlnavareloadtogglevar" ) == 0 then
if ((CurTime()-lastReloadTime)>cooldown) and SERVER then
		if (self.Owner:GetNW2Bool( "chemlightattachmentusage", false ) != true) then --create if there is no 
		if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
		if ( self.Weapon:Ammo1() <= 0 ) then return end
		self:TakePrimaryAmmo(1)
		end
			timer.Simple( 0.6, function()
			local glow = ents.Create("ent_chemlight_for_attachment")
			glow:SetOwner(self.Owner)
			glow:SetModelScale( 0.01, 0 )
			glow:FollowBone( self.Owner, 3 )
			glow:SetLocalPos(Vector(10,10,3))
			glow:SetLocalAngles(Angle(-15,180,0))
			glow:SetNotSolid( true )
			if self.Owner:IsBot() then self:SetColor(Color(255,255,255,255)) else
			self.Owner:SetNW2Int( "chemlightattachmenRGB_R", 0 )
			self.Owner:SetNW2Int( "chemlightattachmenRGB_G", 255 )
			self.Owner:SetNW2Int( "chemlightattachmenRGB_B", 0 )
			glow:SetColor(Color(self.Owner:GetNW2Int( "chemlightattachmenRGB_R", 0 ),self.Owner:GetNW2Int( "chemlightattachmenRGB_G", 0 ) ,self.Owner:GetNW2Int( "chemlightattachmenRGB_B", 0 ) , 255))
			glow:SetMaterial("Models/effects/vol_light001")
			glow:DrawShadow( false )
			end			
			glow:Spawn()
			--glow:SetNoDraw(true)

			self.Owner:SetNW2Int( "chemlightattachmentindex", glow:EntIndex() )
			sound.Play( "glowstick/carbiner.wav", glow:GetPos(), 75, math.random( 90, 110 ), math.Clamp( 0.5, 0.2, 0.7 ) )
			end )
			timer.Remove( "weapon_chemlight_green"..self.Owner:EntIndex() )
			self.Weapon:SendWeaponAnim(ACT_VM_RELOAD);
			timer.Create( "reloadtimer"..self.Owner:EntIndex(), 1.5, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
				self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
				end
			 end )
			timer.Create( "weapon_chemlight_green"..self.Owner:EntIndex(), 3, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				end
			 end )
			self.Weapon:SetNextPrimaryFire(CurTime() + 3)
			self.Weapon:SetNextSecondaryFire(CurTime() + 3)
			timer.Simple( 0.6, function() self.Owner:SetNW2Bool( "chemlightattachmentusage", true ) end)
			if GetGlobalBool( "global_Cheml_Inf", 0 ) == false then
			local lifetime = GetGlobalFloat( "global_Cheml_Lifetime", 25 ) + 15
			timer.Create( "deadlight"..self.Owner:EntIndex(), lifetime , 1 , function() if self.Owner:Alive() then self.Owner:SetNW2Bool( "chemlightattachmentusage", false ) end end )
			end
			else --remove the hell out of it
			if self.Owner:GetNW2Int( "chemlightattachmentindex", 0 ) != 0 and Entity(self.Owner:GetNW2Int( "chemlightattachmentindex", 0 )):IsValid() then
			sound.Play( "glowstick/carbiner.wav", self.Owner:GetPos(), 75, math.random( 90, 110 ), math.Clamp( 0.5, 0.2, 0.7 ) )
			Entity(self.Owner:GetNW2Int( "chemlightattachmentindex", 0 )):Remove()
			self.Owner:SetNW2Bool( "chemlightattachmentusage", false )
			end
		end
	lastReloadTime=CurTime()
end
	
	return true
	else
--
if ((CurTime()-lastReloadTime)>cooldown2) and SERVER then
	if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
	if ( self.Weapon:Ammo1() <= 0 ) then return end
	self:TakePrimaryAmmo(1)
	end

timer.Create( "reloadtimer1"..self.Owner:EntIndex(), 0.8, 1, function()		
	if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
	self.Owner:SetColor(Color( 0, 255, 0, 255))
	self.Owner:SetNW2Bool( "chemlightplayercolored", true )
	local minushels = math.random(7,13)
	if self.Owner:Health() > minushels then self.Owner:SetHealth(self.Owner:Health()-minushels) else self.Owner:Kill() end
	self.Owner:ScreenFade( SCREENFADE.IN, Color( 0, 255, 0, 100), 0.5, 0 )
	end 
end)
timer.Create( "reloadtimer2"..self.Owner:EntIndex(), 0.4, 1, function()		
	if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
	sound.Play( "glowstick/glowstick_nom.wav", self.Owner:GetPos() )
	end 
end)
timer.Remove( "weapon_chemlight_green"..self.Owner:EntIndex() )
self.Weapon:SendWeaponAnim(ACT_VM_PULLPIN);
			timer.Create( "reloadtimer"..self.Owner:EntIndex(), 1.5, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid() then
				self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
				end 
			end)
			timer.Create( "weapon_chemlight_green"..self.Owner:EntIndex(), 3, 1, function() 
				if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass() and self.Owner:IsValid()  then
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				end
			end) 
			timer.Create( "uncolorchemlighttimer"..self.Owner:EntIndex(), 15, 1, function() 
				self.Owner:SetColor(Color(255,255,255,255))
				self.Owner:SetNW2Bool( "chemlightplayercolored", false )
			end)
			self.Weapon:SetNextPrimaryFire(CurTime() + 3)
			self.Weapon:SetNextSecondaryFire(CurTime() + 3)
			lastReloadTime=CurTime()
end
--
end
end



function SWEP:SecondaryAttack()
if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
if ( self.Weapon:Ammo1() <= 0 ) then return end
self:TakePrimaryAmmo(1)
end
timer.Remove( "weapon_chemlight_green"..self.Owner:EntIndex() )
	self.Weapon:SendWeaponAnim( ACT_VM_SECONDARYATTACK )
	self.Weapon:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		timer.Simple(0.5, function()
		timer.Create( "weapon_chemlight_green"..self.Owner:EntIndex(), 2, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
			if SERVER then
					local ent = ents.Create("ent_chemlight")
					ent:SetPos(self.Owner:EyePos() + (self.Owner:GetAimVector() * 4))
					ent:SetAngles(self.Owner:EyeAngles())
					if self.Owner:IsBot() then ent:SetColor(Color(0,255,0,255)) else
					ent:SetColor( Color( 0, 255, 0, 255) )
					end
					ent:Spawn()
					ent:Activate()
					self.Owner:AddCleanup( "glowsticks", ent)
				local phys = ent:GetPhysicsObject()
				phys:SetVelocity(self.Owner:GetVelocity() + self.Owner:GetAimVector() * 125 * GetGlobalFloat("global_Cheml_throwstrength", 1))
				phys:AddAngleVelocity(Vector(math.random(-1000,1000),math.random(-1000,1000),math.random(-1000,1000)))
			end
		end)
		timer.Simple(1, function()
		if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
		self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
		end
		end)
end

function SWEP:PrimaryAttack()
if GetGlobalBool( "global_Cheml_Ammo", 1 ) == true then
if ( self.Weapon:Ammo1() <= 0 ) then return end
self:TakePrimaryAmmo(1)
end
timer.Remove( "weapon_chemlight_green"..self.Owner:EntIndex() )
	self.Weapon:SendWeaponAnim( ACT_VM_THROW )
	self.Weapon:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
		timer.Simple(0.5, function()
		timer.Create( "weapon_chemlight_green"..self.Owner:EntIndex(), 2, 1, function() self.Weapon:SendWeaponAnim( ACT_VM_IDLE ) end )
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
			if SERVER then
					local ent = ents.Create("ent_chemlight")
					ent:SetPos(self.Owner:EyePos() + (self.Owner:GetAimVector() * 4))
					ent:SetAngles(self.Owner:EyeAngles())
					if self.Owner:IsBot() then ent:SetColor(Color(0,255,0,255)) else
					ent:SetColor( Color( 0, 255, 0, 255) )
					end
					ent:Spawn()
					ent:Activate()
					self.Owner:AddCleanup( "glowsticks", ent)
				local phys = ent:GetPhysicsObject()
				phys:SetVelocity(self.Owner:GetVelocity() + self.Owner:GetAimVector() * 400 * GetGlobalFloat("global_Cheml_throwstrength", 1))
				phys:AddAngleVelocity(Vector(math.random(-1000,1000),math.random(-1000,1000),math.random(-1000,1000)))
			end
		end)
		timer.Simple(1, function()
		if self.Owner:GetActiveWeapon():GetClass() == self.Weapon:GetClass()  then
		self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
		end
		end)
end

function SWEP:PreDrawViewModel( vm )
	if self.Owner:IsBot() then return end
	Material("models/glowstick/glow"):SetVector("$color2", Vector(0, 255, 0) )
end

function SWEP:PostDrawViewModel( vm )
	if self.Owner:IsBot() then return end
	Material("models/glowstick/glow"):SetVector("$color2", Vector(1, 1, 1) )
end

function SWEP:Holster()
	timer.Remove( "weapon_chemlight_green"..self.Owner:EntIndex() )
--			local matrix = self.Owner:GetBoneMatrix(1)
--			local chempos = matrix:GetTranslation()
--			local chempos2 = self.Owner:EyePos() - chempos	
--	local worldmodel = ents.FindInSphere(chempos + Vector(0,0,chempos2.z),0.6)
--	for k, v in pairs(worldmodel) do 
--		if v:GetClass() == "ent_chemlight_glow_green" and v:GetOwner() == self.Owner and SERVER then
--			v:Remove()
		if SERVER then
		if self.chemlightindex == 0 then print("ашипка") return end 
		if ents.GetByIndex( self.chemlightindex):IsValid() then
		ents.GetByIndex( self.chemlightindex):Remove()
		end
		end
--		end
--	end
return true
end

function SWEP:OnRemove()
	return true
end
--lua/weapons/weapon_chemlight_yellow/cl_init.lua:
include('shared.lua')

SWEP.Slot			= 4; 
SWEP.SlotPos		= 8; 
SWEP.Spawnable		= true
SWEP.AdminSpawnable	= true
SWEP.WepSelectIcon	= surface.GetTextureID( "vgui/entities/glowstick2" )
--addons/hbombs_base/lua/weapons/weapon_detonator_hb/shared.lua:

if (SERVER) then // This is where the init.lua stuff goes.
	AddCSLuaFile ("shared.lua")
	SWEP.Weight = 5
	SWEP.AutoSwitchTo = false
	SWEP.AutoSwitchFrom = false
	util.AddNetworkString("detonator_gui")
	util.AddNetworkString("detonator_datastream")
	
elseif (CLIENT) then 
	SWEP.PrintName = "HBOMBS Detonator"
	SWEP.Slot = 1
	SWEP.SlotPos = 1
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = true
	
end
 
SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = "Detonates edverything"
SWEP.Instructions = "Right click while aiming at a bomb to set the time. Left click to detonate."

SWEP.Category = "HBOMBS SWEPS"
 
SWEP.Spawnable = true -- Whether regular players can see it
SWEP.AdminSpawnable = true -- Whether Admins/Super Admins can see it
 
SWEP.ViewModel = "models/weapons/V_radio_hands.mdl" -- This is the model used for clients to see in first person.
SWEP.WorldModel = "" -- This is the model shown to all other clients and in third-person.
SWEP.ViewModelFOV			= 60



SWEP.Primary.ClipSize = -1
 
SWEP.Primary.DefaultClip = -1
 
SWEP.Primary.Automatic = false
 
SWEP.Primary.Ammo = "none"
 
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

 
function SWEP:Reload()
end
 
function SWEP:Think()
end
 
 
function SWEP:PrimaryAttack()
	self:SendWeaponAnim(ACT_VM_DEPLOY)
	
	timer.Simple(self:SequenceDuration(), function()
		self:SendWeaponAnim(ACT_VM_IDLE)
		self:Detonate()
	end)
	
	

end

function SWEP:Deploy()
	self:SendWeaponAnim(ACT_VM_DRAW_SILENCED)
	
	if self.Owner.DetonatorDB!=nil then for k, v in pairs(self.Owner.DetonatorDB) do if v["entity"]:IsValid() then v["entity"].IsLinked=false self.Owner:ChatPrint(v["entity"]:GetClass().. " unlinked.") end end end
	self.Owner.DetonatorDB = {}
	timer.Simple(self:SequenceDuration(), function()
		self:SendWeaponAnim(ACT_VM_IDLE)
	end)
	

	return true

end
 
function SWEP:Detonate()
	if self.Owner.DetonatorDB == nil then return end
	for k, v in pairs(self.Owner.DetonatorDB) do
		local entity, delay = v["entity"], v["delay" ]
		if entity:IsValid() then
			if string.StartWith(entity:GetClass(), "hb_") then
				timer.Simple(delay, function()
					if !entity:IsValid() then return end
					entity.Exploded=true
					entity:Explode()
				end)
			elseif string.StartWith(entity:GetClass(), "hb_") then
				timer.Simple(delay, function()
					if !entity:IsValid() then return end
					entity.Exploded=true
					entity:Explode()
				end)		

					
			elseif string.StartWith(entity:GetClass(), "gf2_") then
				if string.StartWith(entity:GetClass(), "gf2_fountain_") or string.StartWith(entity:GetClass(), "gf2_romancandle") then	
				
					timer.Simple(delay, function()
						if !entity:IsValid() then return end
						entity:EmitSound("npc/roller/mine/rmine_blip3.wav")
						entity.Armed=true
						entity:StartEmitting() 

						
					end)
					
				elseif string.StartWith(entity:GetClass(), "gf2_rocket") or string.StartWith(entity:GetClass(), "gf2_mortars_mortar_big") then
					timer.Simple(delay, function()
						if !entity:IsValid() then return end

						entity.Armed=true
						entity:Launch()


						
					end)
				else 
					timer.Simple(delay, function()
						if !entity:IsValid() then return end

						entity:Arm()


						
					end)
				end
			end
		end
	end
	
end

function SWEP:SecondaryAttack()
	local trace = self.Owner:GetEyeTrace()

	if trace.Entity != nil and trace.Entity.IsLinked!=true and SERVER then

		net.Start("detonator_gui")
			net.WriteEntity(trace.Entity)
			net.WriteEntity(self.Owner)
		net.Send(self.Owner)

		self:EmitSound("buttons/button8.wav",100,100)

	end
end
 
net.Receive("detonator_datastream",function()
	local entity 		= net.ReadEntity()
	local player        = net.ReadEntity()
	local detonator_timer  	= net.ReadFloat()
	entity.IsLinked     = true
	if player.DetonatorDB[entity]==nil then
		table.insert(player.DetonatorDB, {["entity"]=entity,
										  ["delay" ]=detonator_timer})
	end

end)

net.Receive("detonator_gui",function()

	local entity = net.ReadEntity()

	local win=vgui.Create("DFrame")
	win:SetSize(200,200)
	win:Center()
	win:SetVisible(true)
	win:SetTitle("Detonator GUI")
	
	
	local detonator_w=vgui.Create("DLabel", win)
	detonator_w:SetPos(25,60)
	detonator_w:SetText("Explosion Delay (1-120 seconds):")
	detonator_w:SizeToContents()
		
	local detonator_time=vgui.Create("DTextEntry",win)
	detonator_time:SetPos(50,90)
	detonator_time:SetWide(100)
	detonator_time:SetTall(15)
	detonator_time:SetEnterAllowed(false)
	
	
	local DButton = vgui.Create( "DImageButton", win )
	DButton:SetPos( 70, 120 )
	DButton:SetText( "" )
	DButton:SetImage("icon16/cross.png")
	DButton:SetSize( 60, 60 )
	DButton.DoClick = function()
		if (!(not tonumber(detonator_time:GetValue())))then 
			if tonumber(detonator_time:GetValue())>=1 and tonumber(detonator_time:GetValue())<=120 then
				surface.PlaySound("items/suitchargeok1.wav")
				net.Start("detonator_datastream")
					net.WriteEntity(entity)
					net.WriteEntity(LocalPlayer())
					net.WriteFloat(detonator_time:GetValue())
				net.SendToServer()
				
				win:SetVisible(false)
			
				
				
			end
		else
			surface.PlaySound("vo/npc/male01/answer11.wav")		
		end
		
	end

	detonator_time.OnTextChanged=function()
		if (!(not tonumber(detonator_time:GetValue())))then 
			if tonumber(detonator_time:GetValue())>=1 and tonumber(detonator_time:GetValue())<=120 then
				DButton:SetImage("icon16/tick.png")
			else
				DButton:SetImage("icon16/cross.png")			
			end
		else
			DButton:SetImage("icon16/cross.png")
		end
		
	end
	
	win:SetDeleteOnClose(true)
	win:MakePopup()
end)
--addons/handschellen/lua/weapons/weapon_handcuffed.lua:
---------------------------------------
--   	  Cuffed | Handcuffs		 --
---------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_base"

SWEP.Category = "SW:RP (Handschellen)"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = ""

SWEP.Spawnable = false
SWEP.AdminSpawnable = false
SWEP.AdminOnly = false

SWEP.Slot = 3
SWEP.PrintName = "In Handschellen"

SWEP.ViewModelFOV = 60
SWEP.Weight = 5
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.ViewModel = "models/weapons/c_arms_citizen.mdl"
SWEP.UseHands = true

SWEP.Primary.Recoil = 1
SWEP.Primary.Damage = 5
SWEP.Primary.NumShots = 1
SWEP.Primary.Cone = 0
SWEP.Primary.Delay = 1

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.ClipMax = -1

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.ClipMax = -1

SWEP.DeploySpeed = 1.5

SWEP.PrimaryAnim = ACT_VM_PRIMARYATTACK
SWEP.ReloadAnim = ACT_VM_RELOAD
SWEP.HoldType = "duel"

SWEP.IsHandcuffs = true
SWEP.CuffType = ""

local LEASH = {}

SWEP.CanDrop = false
SWEP.PreventDrop = true

-- DataTables
function SWEP:SetupDataTables()
	self:NetworkVar( "Entity", 0, "Kidnapper" )
	self:NetworkVar( "Entity", 1, "FriendBreaking" )

	self:NetworkVar( "Float", 0, "RopeLength" )
	self:NetworkVar( "Float", 1, "CuffBroken" )
	self:NetworkVar( "Float", 2, "CuffStrength" )
	self:NetworkVar( "Float", 3, "CuffRegen" )

	self:NetworkVar( "String", 0, "RopeMaterial" )
	self:NetworkVar( "String", 1, "CuffMaterial" )

	self:NetworkVar( "Bool", 0, "CanGag" )
	self:NetworkVar( "Bool", 1, "IsGagged" )

	self:NetworkVar( "Bool", 2, "CanBlind" )
	self:NetworkVar( "Bool", 3, "IsBlind" )
	self:NetworkVar( "Bool", 4, "IsLeash" )
end

-- Initialize
function SWEP:Initialize()
	hook.Add( "canDropWeapon", self, function(self, ply, wep) if wep==self then return false end end) // Thank you DarkRP, your code is terrible

	if SERVER then
		hook.Add( "Think", self, self.BreakThink )
	end

	if CLIENT then
		hook.Add( "HUDPaint", self, self.CuffsHUD )
		hook.Add( "HUDPaintBackground", self, self.BlindHUDBackground )
	end

	if self:GetCuffStrength() <= 0 then self:SetCuffStrength(1) end
	if self:GetCuffRegen() <= 0 then self:SetCuffRegen(1) end

	self:SetCuffBroken( 0 )
	self:SetHoldType( self.HoldType )
end

-- Standard SWEP functions
function SWEP:PrimaryAttack()
	return
end

function SWEP:SecondaryAttack()
	return
end

function SWEP:Reload()
	return
end

-- Equip and Holster
function SWEP:Equip( newOwner )
	newOwner:SelectWeapon( self:GetClass() )

	timer.Simple( 0.1, function()
		if IsValid(self) and  IsValid(newOwner) and newOwner:GetActiveWeapon() ~= self then
			local wep = newOwner:GetActiveWeapon()

			if not IsValid(wep) then return end

			local oHolster = wep.Holster
			wep.Holster = function() return true end
			newOwner:SelectWeapon( self:GetClass() )
			wep.Holster = oHolster
		end
	end)

	return true
end

function SWEP:Holster()
	return self:GetIsLeash()
end

-- Deploy
function SWEP:Deploy()
	local viewModel = self:GetOwner():GetViewModel()
	viewModel:SendViewModelMatchingSequence( viewModel:LookupSequence("fists_idle_01") )

	if self:GetIsLeash() then self:SetHoldType( LEASH.HoldType or "normal" ) end

	return true
end

function SWEP:PreDrawViewModel( viewModel ) // Fixes visible base hands
	viewModel:SetMaterial( "engine/occlusionproxy" )
end

if CLIENT then
	local HadCuffs

	hook.Add( "PreDrawOpaqueRenderables", "Cuffs FixViewModel", function()
		local ply = LocalPlayer()
		if not IsValid(ply) then return end

		local HasCuffs = IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon():GetClass() == "weapon_handcuffed"
		if HadCuffs and not HasCuffs then
			local vm = ply:GetViewModel()
			if IsValid(vm) then
				vm:SetMaterial( "" )
			end
		end

		HadCuffs = HasCuffs
	end)
end

function SWEP:OnRemove() // Fixes invisible other weapons
	if IsValid(self:GetOwner()) then
		local viewModel = self:GetOwner():GetViewModel()
		if IsValid(viewModel) then viewModel:SetMaterial("") end
	end
	if IsValid( self.cmdl_LeftCuff ) then self.cmdl_LeftCuff:Remove() end
	if IsValid( self.cmdl_RightCuff ) then self.cmdl_RightCuff:Remove() end
	return true
end

-- Release
function SWEP:Uncuff()
	local ply = IsValid(self:GetOwner()) and self:GetOwner()

	self:Remove()

	if ply then ply:ConCommand( "lastinv" ) end
end

-- Breakout
if SERVER then
	local BreakSound = Sound( "physics/metal/metal_barrel_impact_soft4.wav" )

	local ReleaseSounds = {
		Sound( "physics/cardboard/cardboard_box_impact_soft1.wav" ), Sound( "physics/cardboard/cardboard_box_impact_soft2.wav" ),
		Sound( "physics/cardboard/cardboard_box_impact_soft3.wav" ), Sound( "physics/cardboard/cardboard_box_impact_soft4.wav" ),
		Sound( "physics/cardboard/cardboard_box_impact_soft5.wav" ), Sound( "physics/cardboard/cardboard_box_impact_soft6.wav" ),
	}

	function SWEP:Breakout()
		if IsValid(self:GetOwner()) then
			sound.Play( BreakSound, self:GetOwner():GetShootPos(), 75, 100, 1 )
			if IsValid( self:GetFriendBreaking() ) then
				hook.Call( "OnHandcuffBreak", GAMEMODE, self:GetOwner(), self, self:GetFriendBreaking() )
			else
				hook.Call( "OnHandcuffBreak", GAMEMODE, self:GetOwner(), self )
			end
		end

		self:Uncuff()
	end

	local function GetTrace( ply )
		local tr = util.TraceLine( {start = ply:EyePos(), endpos = ply:EyePos() + (ply:GetAimVector() * 100), filter = ply} )

		if IsValid(tr.Entity) and tr.Entity:IsPlayer() then
			local cuffed,wep = tr.Entity:IsHandcuffed()

			if cuffed then return tr, wep end
		end
	end

	function SWEP:BreakThink()
		if (self.NextRegen or 0)<=CurTime() then
			local regen = self:GetCuffRegen()
			local friend = self:GetFriendBreaking()

			if IsValid(friend) and friend:IsPlayer() then
				local tr = GetTrace(friend)

				if tr and tr.Entity == self:GetOwner() then
					regen = (regen * 0.5) - (2 / self:GetCuffStrength())
				else
					self:SetFriendBreaking( nil )
				end

				if CurTime() > (self.NextReleaseSound or 0) then
					sound.Play( table.Random( ReleaseSounds ), self:GetOwner():GetShootPos(), 75, 100, self:GetCuffStrength() / 1.5 )

					self.NextReleaseSound = CurTime() + 0.25
				end
			end

			self:SetCuffBroken( math.Approach( self:GetCuffBroken(), regen < 0 and 100 or 0, math.abs(regen) ) )
			self.NextRegen = CurTime() + 0.05

			if self:GetCuffBroken() >= 100 then
				self:Breakout()
			end
		end

		if IsValid(self:GetKidnapper()) and (self:GetKidnapper():IsPlayer() and not self:GetKidnapper():Alive()) then
			self:SetKidnapper( nil )
		end

		if IsValid(self:GetOwner()) then
			self:GetOwner().KnockoutTimer = CurTime() + 10
		end
	end
end


-- UI
if CLIENT then
	surface.CreateFont( "HandcuffsText", {
		font = "Arial",
		size = 20,
		weight = 700,
	})
	local Col = {
		Text = Color(255,255,255), TextShadow = Color(0,0,0),

		BoxOutline = Color(0,0,0), BoxBackground = Color(255,255,255,20), BoxLeft = Color(255,0,0), BoxRight = Color(0,255,0),

		Blind = Color(0,0,0, 253), Blind2 = Color(0,0,0, 255),
	}
	local matGrad = Material( "gui/gradient" )

	function SWEP:CuffsHUD()
		if self:GetOwner() ~= LocalPlayer() then return end

		local w,h = (ScrW() / 2), (ScrH() / 2)
		local TextPos = h + 30

		local str = string.format( "Du wurdest festgenommen!%s",
			((self:GetCuffStrength() > 1.2) and " tightly") or ((self:GetCuffStrength()<0.8) and " loosely") or ""
		)

		draw.SimpleText( str, "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
		draw.SimpleText( str, "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )

		if self:GetIsBlind() then
			TextPos = TextPos + 20
			draw.SimpleText( "Dir wurden die Augen verbunden.", "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( "Dir wurden die Augen verbunden.", "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
		end

		if self:GetIsGagged() then
			TextPos = TextPos + 20
			draw.SimpleText( "Dir wurde einen Lappen in den Mund gesteckt.", "HandcuffsText", w+1, TextPos+1, Col.TextShadow, TEXT_ALIGN_CENTER )
			draw.SimpleText( "Dir wurde einen Lappen in den Mund gesteckt.", "HandcuffsText", w, TextPos, Col.Text, TEXT_ALIGN_CENTER )
		end

		TextPos = TextPos + 25

		surface.SetDrawColor( Col.BoxOutline )
		surface.DrawOutlinedRect( w-101, TextPos-1, 202, 22 )
		surface.SetDrawColor( Col.BoxBackground )
		surface.DrawRect( w-100, TextPos, 200, 20 )

		render.SetScissorRect( w-100, TextPos, (w-100)+((self:GetCuffBroken()/100)*200), TextPos+20, true )
			surface.SetDrawColor( Col.BoxRight )
			surface.DrawRect( w-100,TextPos, 200,20 )

			surface.SetMaterial( matGrad )
			surface.SetDrawColor( Col.BoxLeft )
			surface.DrawTexturedRect( w-100,TextPos, 200,20 )
		render.SetScissorRect( 0,0,0,0, false )
	end

	function SWEP:BlindHUDBackground()
		if self:GetOwner() ~= LocalPlayer() then return end

		if self:GetIsBlind() then
			surface.SetDrawColor( Col.Blind )
			surface.DrawRect( 0,0, ScrW(), ScrH() )

			surface.SetDrawColor( Col.Blind2 )
			for i = 1,ScrH(),5 do
				surface.DrawRect( 0,i, ScrW(), 4 )
			end
			for i = 1,ScrW(),5 do
				surface.DrawRect( i,0, 4,ScrH() )
			end
		end
	end
end

-- Rendering
local renderpos = {
	left = {bone = "ValveBiped.Bip01_L_Wrist", pos=Vector(0.4,-0.15,-0.45), ang=Angle(90,0,0), scale = Vector(0.035,0.035,0.015)},
	right = {bone = "ValveBiped.Bip01_R_Wrist", pos=Vector(0.2,-0.15,0.35), ang=Angle(100,0,0), scale = Vector(0.035,0.035,0.015)},
	rope = {l = Vector(-0.2,1.3,-0.25), r = Vector(0.4,1.4,-0.2)},
}

local CuffMdl = "models/hunter/tubes/tube2x2x1.mdl"
local DefaultRope = "cable/cable2"
local RopeCol = Color(255,255,255)

function SWEP:ViewModelDrawn( vm )
	if self:GetIsLeash() then
		self.ViewModelDrawn = LEASH.ViewModelDrawn
		self.PrintName = "Leash"

		return
	end

	if not IsValid(vm) then return end

	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )
		if not IsValid( self.cmdl_LeftCuff ) then return end // What
		self.cmdl_LeftCuff:SetNoDraw( true )
		self.cmdl_LeftCuff:SetParent( vm )
	end

	if not IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )

		if not IsValid( self.cmdl_RightCuff ) then return end

		self.cmdl_RightCuff:SetNoDraw( true )
		self.cmdl_RightCuff:SetParent( vm )
	end

	local lpos, lang = self:GetBonePos( renderpos.left.bone, vm )
	local rpos, rang = self:GetBonePos( renderpos.right.bone, vm )

	if not (lpos and rpos and lang and rang) then return end

	// Left
	self.cmdl_LeftCuff:SetPos( lpos + (lang:Forward() * renderpos.left.pos.x) + (lang:Right() * renderpos.left.pos.y) + (lang:Up() * renderpos.left.pos.z) )

	local u,r,f = lang:Up(), lang:Right(), lang:Forward() // Prevents moving axes
	lang:RotateAroundAxis( u, renderpos.left.ang.y )
	lang:RotateAroundAxis( r, renderpos.left.ang.p )
	lang:RotateAroundAxis( f, renderpos.left.ang.r )

	self.cmdl_LeftCuff:SetAngles( lang )

	local matrix = Matrix()
	matrix:Scale( renderpos.left.scale )
	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )

	self.cmdl_LeftCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_LeftCuff:DrawModel()

	// Right
	self.cmdl_RightCuff:SetPos( rpos + (rang:Forward() * renderpos.right.pos.x) + (rang:Right() * renderpos.right.pos.y) + (rang:Up() * renderpos.right.pos.z) )

	local u, r, f = rang:Up(), rang:Right(), rang:Forward() // Prevents moving axes
	rang:RotateAroundAxis( u, renderpos.right.ang.y )
	rang:RotateAroundAxis( r, renderpos.right.ang.p )
	rang:RotateAroundAxis( f, renderpos.right.ang.r )

	self.cmdl_RightCuff:SetAngles( rang )

	local matrix = Matrix()
	matrix:Scale( renderpos.right.scale )
	self.cmdl_RightCuff:EnableMatrix( "RenderMultiply", matrix )

	self.cmdl_RightCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_RightCuff:DrawModel()

	// Rope
	if self:GetRopeMaterial() ~= self.LastMatStr then
		self.RopeMat = Material( self:GetRopeMaterial() )
		self.LastMatStr = self:GetRopeMaterial()
	end

	if not self.RopeMat then self.RopeMat = Material(DefaultRope) end

	render.SetMaterial( self.RopeMat )
	render.DrawBeam(
		lpos + (lang:Forward() * renderpos.rope.l.x) + (lang:Right() * renderpos.rope.l.y) + (lang:Up() * renderpos.rope.l.z),
		rpos + (rang:Forward() * renderpos.rope.r.x) + (rang:Right() * renderpos.rope.r.y) + (rang:Up() * renderpos.rope.r.z),
		0.7,
		0,
		5,
		RopeCol
	)
end

local wrender = {
	left = {bone = "ValveBiped.Bip01_L_Hand", pos = Vector(0,0,0), ang = Angle(90,0,0), scale = Vector(0.035,0.035,0.035)},
	right = {bone = "ValveBiped.Bip01_R_Hand", pos = Vector(0.2,0,0), ang = Angle(90,0,0), scale = Vector(0.035,0.035,0.035)},
	rope = {l = Vector(-0.2,1.3,-0.25), r = Vector(0.4,1.4,-0.2)},
}

function SWEP:DrawWorldModel()
	if self:GetIsLeash() then
		self.DrawWorldModel = function() end

		hook.Add("PostDrawOpaqueRenderables", self, LEASH.DrawWorldModel)

		self.PrintName = "Leash"

		return
	end

	if not IsValid(self:GetOwner()) then return end

	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel(CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE)

		if not IsValid(self.cmdl_LeftCuff) then return end

		self.cmdl_LeftCuff:SetNoDraw(true)
	end

	if not IsValid(self.cmdl_RightCuff) then
		self.cmdl_RightCuff = ClientsideModel(CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE)

		if not IsValid(self.cmdl_RightCuff) then return end

		self.cmdl_RightCuff:SetNoDraw(true)
	end

	local carryPly = self:GetOwner():GetNWEntity("Unarmed.CarriedPlayer")
	if IsValid(carryPly) then
		return
	end

	local lpos, lang = self:GetBonePos(wrender.left.bone, self:GetOwner())
	local rpos, rang = self:GetBonePos(wrender.right.bone, self:GetOwner())

	if not (lpos and rpos and lang and rang) then return end

	-- Left
	self.cmdl_LeftCuff:SetPos(lpos + (lang:Forward() * wrender.left.pos.x) + (lang:Right() * wrender.left.pos.y) + (lang:Up() * wrender.left.pos.z))

	local u, r, f = lang:Up(), lang:Right(), lang:Forward() -- Prevents moving axes
	lang:RotateAroundAxis(u, wrender.left.ang.y)
	lang:RotateAroundAxis(r, wrender.left.ang.p)
	lang:RotateAroundAxis(f, wrender.left.ang.r)

	self.cmdl_LeftCuff:SetAngles(lang)

	local matrix = Matrix()
	matrix:Scale(wrender.left.scale)

	self.cmdl_LeftCuff:EnableMatrix("RenderMultiply", matrix)
	self.cmdl_LeftCuff:SetMaterial(self:GetCuffMaterial() or "")
	self.cmdl_LeftCuff:DrawModel()

	-- Right
	self.cmdl_RightCuff:SetPos(rpos + (rang:Forward() * wrender.right.pos.x) + (rang:Right() * wrender.right.pos.y) + (rang:Up() * wrender.right.pos.z))

	local u, r, f = rang:Up(), rang:Right(), rang:Forward() -- Prevents moving axes
	rang:RotateAroundAxis(u, wrender.right.ang.y)
	rang:RotateAroundAxis(r, wrender.right.ang.p)
	rang:RotateAroundAxis(f, wrender.right.ang.r)

	self.cmdl_RightCuff:SetAngles(rang)

	local matrix = Matrix()
	matrix:Scale(wrender.right.scale)

	self.cmdl_RightCuff:EnableMatrix("RenderMultiply", matrix)
	self.cmdl_RightCuff:SetMaterial(self:GetCuffMaterial() or "")
	self.cmdl_RightCuff:DrawModel()

	-- Rope
	if (lpos.x == 0 and lpos.y == 0 and lpos.z == 0) or (rpos.x == 0 and rpos.y == 0 and rpos.z == 0) then return end -- Rope accross half the map...

	if self:GetRopeMaterial() ~= self.LastMatStr then
		self.RopeMat = Material(self:GetRopeMaterial())
		self.LastMatStr = self:GetRopeMaterial()
	end

	if not self.RopeMat then
		self.RopeMat = Material(DefaultRope)
	end

	render.SetMaterial(self.RopeMat)
	render.DrawBeam(lpos + (lang:Forward() * wrender.rope.l.x) + (lang:Right() * wrender.rope.l.y) + (lang:Up() * wrender.rope.l.z), rpos + (rang:Forward() * wrender.rope.r.x) + (rang:Right() * wrender.rope.r.y) + (rang:Up() * wrender.rope.r.z), 0.7, 0, 5, RopeCol)
end

-- Bones
function SWEP:GetBonePos( bonename, vm )
	local bone = vm:LookupBone( bonename )

	if not bone then return end

	local pos,ang = Vector(0,0,0),Angle(0,0,0)
	local matrix = vm:GetBoneMatrix( bone )

	if matrix then
		pos = matrix:GetTranslation()
		ang = matrix:GetAngles()
	end

	if self.ViewModelFlip then ang.r = -ang.r end

	return pos, ang
end


-- Leash
LEASH.HoldType = "normal"

-- Rendering
local vrender = {
	bone = "ValveBiped.Bip01_L_Wrist",
	pos = Vector(0,0,-1.5),
	ang = Angle(0,0,0),
	scale = Vector(0.01,0.01,0.02),
}

function LEASH:ViewModelDrawn( vm )
	self.UseHands = false

	if not (IsValid(self) and IsValid(self:GetOwner())) then return end

	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )

		if not IsValid( self.cmdl_LeftCuff ) then return end

		self.cmdl_LeftCuff:SetNoDraw( true )
	end

	local lpos, lang = self:GetBonePos( vrender.bone, self:GetOwner() )

	if not (lpos and lang) then return end

	self.cmdl_LeftCuff:SetPos( lpos + (lang:Forward()*vrender.pos.x) + (lang:Right()*vrender.pos.y) + (lang:Up()*vrender.pos.z) )

	local u,r,f = lang:Up(), lang:Right(), lang:Forward() // Prevents moving axes
	lang:RotateAroundAxis( u, vrender.ang.y )
	lang:RotateAroundAxis( r, vrender.ang.p )
	lang:RotateAroundAxis( f, vrender.ang.r )

	self.cmdl_LeftCuff:SetAngles( lang )

	local matrix = Matrix()
	matrix:Scale( vrender.scale )

	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )
	self.cmdl_LeftCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_LeftCuff:DrawModel()

	if self:GetRopeMaterial() ~= self.LastMatStr then
		self.RopeMat = Material( self:GetRopeMaterial() )
		self.LastMatStr = self:GetRopeMaterial()
	end

	if not self.RopeMat then self.RopeMat = Material(DefaultRope) end
end

local lrender = {
	normal = {
		bone = "ValveBiped.Bip01_Neck1",
		pos = Vector(2,1.8,0),
		ang = Angle(70,90,90),
		scale = Vector(0.06,0.06,0.05),
	},

	alt = { // Eeveelotions models
		bone = "Neck",
		pos = Vector(1,0.5,-0.2),
		ang = Angle(100,90,90),
		scale = Vector(0.082,0.082,0.082),
	},
}

function LEASH.DrawWorldModel(self)
	if not (IsValid(self) and IsValid(self:GetOwner())) then return end

	if self:GetOwner() == LocalPlayer() and not hook.Call("ShouldDrawLocalPlayer", GAMEMODE, self:GetOwner()) then
		return
	end

	if self:GetOwner() == LocalPlayer():GetObserverTarget() and LocalPlayer:GetObserverMode() ~= OBS_MODE_NONE and LocalPlayer:GetObserverMode() ~= OBS_MODE_IN_EYE then return end

	if not IsValid(self.cmdl_LeftCuff) then
		self.cmdl_LeftCuff = ClientsideModel( CuffMdl, RENDER_GROUP_VIEW_MODEL_OPAQUE )

		if not IsValid( self.cmdl_LeftCuff ) then return end

		self.cmdl_LeftCuff:SetNoDraw( true )
	end

	local tbl = lrender.normal
	local lpos, lang = self:GetBonePos(tbl.bone, self:GetOwner())

	if not lpos then
		tbl = lrender.alt
		lpos, lang = self:GetBonePos( tbl.bone, self:GetOwner() )

		if not lpos then return end
	end

	self.cmdl_LeftCuff:SetPos( lpos + (lang:Forward() * tbl.pos.x) + (lang:Right() * tbl.pos.y) + (lang:Up() * tbl.pos.z) )

	local u,r,f = lang:Up(), lang:Right(), lang:Forward() -- Prevents moving axes
	lang:RotateAroundAxis( u, tbl.ang.y )
	lang:RotateAroundAxis( r, tbl.ang.p )
	lang:RotateAroundAxis( f, tbl.ang.r )

	self.cmdl_LeftCuff:SetAngles( lang )

	local matrix = Matrix()
	matrix:Scale( tbl.scale )

	self.cmdl_LeftCuff:EnableMatrix( "RenderMultiply", matrix )
	self.cmdl_LeftCuff:SetMaterial( self:GetCuffMaterial() or "" )
	self.cmdl_LeftCuff:DrawModel()

	if self:GetRopeMaterial() ~= self.LastMatStr then
		self.RopeMat = Material( self:GetRopeMaterial() )
		self.LastMatStr = self:GetRopeMaterial()
	end

	if not self.RopeMat then self.RopeMat = Material(DefaultRope) end
end

--addons/handschellen/lua/weapons/weapon_leash_rope_single.lua:
---------------------------------------
--   	   Handcuffs | Weapon        --
---------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_leash_base"

SWEP.Category = "SW:RP (Handschellen)"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Dies ist eine Seilleine."

SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.AdminSpawnable = false

SWEP.Slot = 2
SWEP.PrintName = "Einmal Leine"

-- Handcuff Vars
SWEP.CuffTime = 4
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "models/props_foliage/tree_deciduous_01a_trunk"
SWEP.CuffRope = "cable/rope"
SWEP.CuffStrength = 0.85
SWEP.CuffRegen = 0.8
SWEP.RopeLength = 150
SWEP.CuffReusable = false

SWEP.CuffBlindfold = false
SWEP.CuffGag = false

SWEP.CuffStrengthVariance = 0.1
SWEP.CuffRegenVariance = 0.2

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_assassin.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Attentäter" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_assassin" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtzug",
	"Macht-Sicht",
	"Macht-Geschwindigkeit",
	"Macht-Stürmen",
	"Lichtschwertwurf",
	"Macht-Würgegriff",
	"Großer Macht-Würgegriff",
	"Beinhieb",
	"Dunkelschlag",
	"Machtschrei",
	"Willenskraft",
	"Klingensturm"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/samurai.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(255, 0, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop6.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on2_fast.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off2_fast.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_barriss.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_common_jedi_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Barriss Offee" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_barriss" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtschub",
	"Machtzug",
	"Machtspiegel",
	"Macht-Geschwindigkeit",
	"Machtstoß",
	"Machtheilung",
	"Macht-Öffnung",
	"Selbstheilung",
	"Lichtschwertwurf",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form IV | Ataru"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/sgg/starwars/weapons/w_common_jedi_saber_hilt.mdl" -- Model path of the hilt
SWEP.UseLength = 40 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 0, 255) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_bladedual.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/swtor/weapons/electroblade_mtx01_a01_v01.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Vibromesser (Dual)" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_bladedual" --The file name of this swep
SWEP.DualWielded = true --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 100 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 0 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 1 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 0
SWEP.BlasterBlockCost = 5
SWEP.BladeBlockCost = 5
SWEP.ForcePowerList = {}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form IV | Ataru"] = {1, 3},
	["Form VI | Niman"] = {1, 2, 3}
}

SWEP.CustomSettings = {
	[ "Blade" ] = "Sharp",
}

SWEP.SecCustomSettings = {
	[ "Blade" ] = "Sharp",
}

SWEP.AllowFallDamage = true

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/swtor/weapons/electroblade_mtx01_a01_v01.mdl" -- Model path of the hilt
SWEP.UseLength = 12 -- Length of the saber
SWEP.UseWidth = 0.5 -- Width of the saber
SWEP.UseColor = Color(250, 158, 54) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/darksaber_loop.wav" -- The loop sound path
SWEP.UseSwingSound = "lightsaber/darksaber_swing.wav" -- The swing sound path
SWEP.UseOnSound = "lightsaber/darksaber_on.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/darksaber_off.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = "models/swtor/weapons/electroblade_mtx01_a01_v01.mdl" -- Model path of the hilt
SWEP.UseSecLength = 12 -- Length of the saber
SWEP.UseSecWidth = 0.5 -- Width of the saber
SWEP.UseSecColor = Color(250, 158, 54) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT---------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_drallig.lua:


AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Cin Drallig" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_drallig" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtstoß",
	"Machtzug",
	"Macht-Geschwindigkeit",
	"Lichtschwertwurf",
	"Macht-Öffnung",
	"Macht-Griff",
	"Macht-Sicht",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Stürmen",
	"Schwert-Barriere",
	"Lähmender Schlag",
	"Atemkontrolle",
	"Macht-Beben",
	"Beinhieb",
	"Willenskraft",
	"Macht-Entwaffnen",
	"Klingensturm"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form V | Djem So"]  = {1, 2, 3},
	["Form VI | Niman"]   = {1, 2, 3},
	["Form VII | Juyo"]   = {1, 2, 3},
	["Form VII | Vaapad"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/swtor/arsenic/lightsabers/unstablepeacemaker'slightsaber.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 255, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_grievousdual.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Grievous - Dual" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_grievousdual" --The file name of this swep
SWEP.DualWielded = true --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Macht-Geschwindigkeit",
	"Beinhieb"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form VI | Niman"]   = {1, 2, 3},
	["Form VII | Vaapad"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/byph.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 0, 255) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = "models/starwars/cwa/lightsabers/katooni.mdl"
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseSecColor = Color(0, 185, 5)
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_hett.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "A'Sharad Hett" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_hett" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Machtschub",
	"Machtzug",
	"Machtspiegel",
	"Atemkontrolle",
	"Macht-Geschwindigkeit",
	"Lichtschwertwurf",
	"Machtstoß",
	"Macht-Öffnung",
	"Macht-Griff",
	"Großer Machtschub",
	"Macht-Sicht",
	"Großer Machtzug",
	"Macht-Seuche",
	"Macht-Induktion",
	"Smaragdblitze",
	"Machtschild",
	"Blenden",
	"Macht-Verlangsamung",
	"Flamusfracta",
	"Willenskraft",
	"Machtblockade",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3},
	["Form VI | Niman"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/kashyyyk.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 255, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_longbladedual.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/swtor/weapons/electroblade_mtx17_a01_v01.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Vibroklinge (Dual)" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_longbladedual" --The file name of this swep
SWEP.DualWielded = true --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 100 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 0 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 1 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 0
SWEP.BlasterBlockCost = 5
SWEP.BladeBlockCost = 5
SWEP.ForcePowerList = {}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form IV | Ataru"] = {1, 3},
	["Form VI | Niman"] = {1, 2, 3}
}

SWEP.CustomSettings = {
	[ "Blade" ] = "Sharp",
}

SWEP.SecCustomSettings = {
	[ "Blade" ] = "Sharp",
}

SWEP.AllowFallDamage = true

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/swtor/weapons/electroblade_mtx17_a01_v01.mdl" -- Model path of the hilt
SWEP.UseLength = 20 -- Length of the saber
SWEP.UseWidth = 0.5 -- Width of the saber
SWEP.UseColor = Color(250, 158, 54) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/darksaber_loop.wav" -- The loop sound path
SWEP.UseSwingSound = "lightsaber/darksaber_swing.wav" -- The swing sound path
SWEP.UseOnSound = "lightsaber/darksaber_on.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/darksaber_off.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = "models/swtor/weapons/electroblade_mtx17_a01_v01.mdl" -- Model path of the hilt
SWEP.UseSecLength = 20 -- Length of the saber
SWEP.UseSecWidth = 0.5 -- Width of the saber
SWEP.UseSecColor = Color(250, 158, 54) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseSecDarkInner = 0

-----------------------------------------------------------END OF EDIT---------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_mukandual.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Etain Tur-Mukan - Dual" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_mukandual" --The file name of this swep
SWEP.DualWielded = true --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Atemkontrolle",
	"Machtheilung",
	"Machtzug",
	"Machtschub",
	"Machtstoß",
	"Macht-Sicht",
	"Gruppenheilung",
	"Lichtschwertwurf",
	"Machtspiegel",
	"Energiestrahl",
	"Macht-Griff",
	"Macht-Induktion",
	"Macht-Öffnung",
	"Selbstheilung",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form VI | Niman"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/gungan.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(255, 77, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = "models/starwars/cwa/lightsabers/gungan.mdl"
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = Color(0, 0, 255)
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_nu.lua:


AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/jocastanu.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Jocasta Nu" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_nu" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Machtzug",
	"Machtschub",
	"Machtstoß",
	"Macht-Sicht",
	"Macht-Öffnung",
	"Macht-Griff",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form II | Makashi"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/jocastanu.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 0, 255) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_palpatinedual.lua:


AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_sidious_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Darth Sidious - Dual" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_palpatinedual" --The file name of this swep
SWEP.DualWielded = true --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 500 --The maximum amount of force in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtzug",
	"Macht-Stürmen",
	"Macht-Seuche",
	"Lähmender Schlag",
	"Macht-Sicht",
	"Kristallschlag",
	"Flamusfracta",
	"Lichtschwertwurf",
	"Machtblitze",
	"Blitzschlag",
	"Machtsturm",
	"Machtschrei",
	"Hass kanalisieren",
	"Kettenblitz",
	"Macht-Würgegriff",
	"Großer Macht-Würgegriff",
	"Blutopfer",
	"Beinhieb",
	"Dunkelschlag",
	"Machtblockade",
	"Willenskraft"
}

SWEP.DevestatorList = { "Blitzentladung", "Flammenschauer", "Innere Furcht" }

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form VII | Vaapad"] = {1, 2, 3},
	["Form VI | Niman"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/sgg/starwars/weapons/w_sidious_saber_hilt.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(255, 0, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop6.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on2.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off2.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = "models/sgg/starwars/weapons/w_sidious_saber_hilt.mdl"
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = Color(255, 0, 0)
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------


if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_personal.lua:

--[[-------------------------------------------------------------------
	Modified Lightsaber:
		Runs on the intuitive wOS Lightsaber Base
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2017, David "King David" Wiltos ]]--[[
							  
	Lua Developer: King David
	Contact: www.wiltostech.com
		
-- Copyright 2017, David "King David" Wiltos ]]--

AddCSLuaFile()


SWEP.Author = "Robotboy655 + King David"
SWEP.Category = "Lichtschwerter"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.TrainingLightsaber = true

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Lichtschwert" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_personal" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 50 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 50 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = { } 
--Force powers you want the saber to have ( REMEMBER TO PUT A COMMA AFTER EACH ONE, AND COPY THE TITLE EXACTLY AS IT'S LISTED )
--For a list of options, just look at the keys in autorun/client/wos_forcematerialbuilding.lua

SWEP.UseSkills = true
SWEP.PersonalLightsaber = true

SWEP.CustomSettings = {}

--[[ Use this to overwrite the ULX Forms/Stances for this particular swep ( [ "FORMNAME" ] = { STANCENUM1, STANCENUM2, STANCENUM3 } )
	Example:
	SWEP.UseForms = {
	["Aggressive"] = { 1, 3 }, 
	["Defensive"] = { 2 }, 
}
]]--

SWEP.UseForms = {}

--Use these options to overwrite the player's commands
SWEP.UseHilt = false -- Model path of the hilt
SWEP.UseLength = false -- Length of the saber 
SWEP.UseWidth = false -- Width of the saber
SWEP.UseColor = false -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = false -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = false


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end
--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_reusdual.lua:


AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/lightsideaffiliation.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Keelyvine Reus - Dual" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_reusdual" --The file name of this swep
SWEP.DualWielded = true --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Machtsprung",
	"Atemkontrolle",
	"Machtzug",
	"Machtschub",
	"Macht-Geschwindigkeit",
	"Lichtschwertwurf",
	"Schwert-Barriere",
	"Macht-Öffnung",
	"Macht-Stürmen",
	"Machtspiegel",
	"Beinhieb",
	"Macht-Beben",
	"Lähmender Schlag",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form VI | Niman"] = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/lightsideaffiliation.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(33,240, 0) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = "models/starwars/cwa/lightsabers/lightsideaffiliation.mdl"
SWEP.UseSecLength = 45
SWEP.UseSecWidth = 2
SWEP.UseSecColor = Color(33,240, 0)
SWEP.UseSecDarkInner = 0

-----------------------------------------------------------END OF EDIT----------------------------------------------------------------

if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_securadual.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/starwars/cwa/lightsabers/aaylasecura.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Aayla Secura - Dual" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_securadual" --The file name of this swep
SWEP.DualWielded = true --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtzug",
	"Lichtschwertwurf",
	"Macht-Stürmen",
	"Macht-Sicht",
	"Macht-Öffnung",
	"Schwert-Barriere",
	"Macht-Beben",
	"Klingensturm",
	"Beinhieb",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form VI | Niman"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/aaylasecura.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 0, 255) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = "models/starwars/cwa/lightsabers/aaylasecura.mdl"
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = Color(0, 255, 0)
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_tiplee.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Lore Chars)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/sgg/starwars/weapons/w_anakin_ep2_saber_hilt.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Tiplee" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_tiplee" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 150 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 2 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 2
SWEP.BladeBlockCost = 3
SWEP.ForcePowerList = {
	"Macht-Geschwindigkeit",
	"Machtsprung",
	"Machtspiegel",
	"Machtschub",
	"Machtzug",
	"Lichtschwertwurf",
	"Macht-Öffnung",
	"Macht-Griff",
	"Großer Machtschub",
	"Großer Machtzug",
	"Macht-Sicht",
	"Macht-Stürmen",
	"Lichtschwertwurf",
	"Schwert-Barriere",
	"Lähmender Schlag",
	"Atemkontrolle",
	"Macht-Beben",
	"Beinhieb",
	"Klingensturm",
	"Willenskraft",
	"Macht-Entwaffnen"
}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"] = {1, 2, 3},
	["Form III | Soresu"] = {1, 2, 3},
	["Form IV | Ataru"]   = {1, 2, 3}
}

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/starwars/cwa/lightsabers/compressedcrystal.mdl" -- Model path of the hilt
SWEP.UseLength = 45 -- Length of the saber 
SWEP.UseWidth = 2 -- Width of the saber
SWEP.UseColor = Color(0, 0, 255) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/saber_loop1.wav" -- The loop sound path
SWEP.UseSwingSound = false -- The swing sound path
SWEP.UseOnSound = "lightsaber/saber_on1.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/saber_off1.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0


-----------------------------------------------------------END OF EDIT----------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/wos-alcs-custom/lua/weapons/weapon_lightsaber_vibro.lua:
AddCSLuaFile()

SWEP.Author = "Robotboy655 + King David + Oninoni"
SWEP.Category = "Lichtschwerter (Event)"
SWEP.Contact = ""
SWEP.RenderGroup = RENDERGROUP_BOTH
SWEP.Slot = 0
SWEP.SlotPos = 4
SWEP.Spawnable = true
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.DrawWeaponInfoBox = false
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/swtor/weapons/electroblade_low03_a01.mdl"
SWEP.ViewModelFOV = 55
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

------------------------------------------------------------THINGS YOU WILL EDIT ARE BELOW HERE-------------------------------------------------------------------------
SWEP.PrintName = "Vibroschwert" --Name of the lightsaber
SWEP.Class = "weapon_lightsaber_vibro" --The file name of this swep
SWEP.DualWielded = false --Should this be a dual wielded saber?
SWEP.CanMoveWhileAttacking = true -- Can the user move while attacking
SWEP.SaberDamage = 80 --How much damage the saber does when it's being swung
SWEP.SaberBurnDamage = 25 -- How much damage the saber does when it's colliding with someone ( coming in contact with laser )
SWEP.MaxForce = 100 --The maximum amount of force in the meter
SWEP.MaxStamina = 100 --The maximum amount of stamina in the meter
SWEP.RegenSpeed = 0.5 --The MULTIPLIER for the regen speed. Half speed = 0.5, Double speed = 2, etc.
SWEP.CanKnockback = true --Should this saber be able to push people back when they get hit?
SWEP.MaxBlockAngle = 135
SWEP.BlasterBlockCost = 500
SWEP.BladeBlockCost = 5
SWEP.ForcePowerList = {"Beinhieb"}

SWEP.BlockDrainRate = 0

SWEP.UseForms = {
	["Form I | Shii-Cho"]  = {1, 2, 3},
}

SWEP.AllowFallDamage = true

--Use these options to overwrite the player's commands
SWEP.UseHilt = "models/swtor/weapons/electroblade_low03_a01.mdl" -- Model path of the hilt
SWEP.UseLength = 23 -- Length of the saber
SWEP.UseWidth = 0.5 -- Width of the saber
SWEP.UseColor = Color(255, 255, 255) -- RGB Color of saber. Red = Color( 255, 0, 0 ) Blue = Color( 0, 0, 255 ), etc.
SWEP.UseDarkInner = 0 -- Does it have a dark inner? 1 = true
SWEP.UseLoopSound = "lightsaber/darksaber_loop.wav" -- The loop sound path
SWEP.UseSwingSound = "lightsaber/darksaber_swing.wav" -- The swing sound path
SWEP.UseOnSound = "lightsaber/darksaber_on.wav" -- The on sound path
SWEP.UseOffSound = "lightsaber/darksaber_off.wav" -- The off sound path

--These are the ones for the second saber for dual wielding. If you are using a single saber, this doesn't do shit
SWEP.UseSecHilt = false
SWEP.UseSecLength = false
SWEP.UseSecWidth = false
SWEP.UseSecColor = false
SWEP.UseSecDarkInner = 0

-----------------------------------------------------------END OF EDIT---------------------------------------------------------------
if !SWEP.DualWielded then
	SWEP.Base = "wos_adv_single_lightsaber_base"
else
	SWEP.Base = "wos_adv_dual_lightsaber_base"
end

if CLIENT then
	killicon.Add( SWEP.Class, "lightsaber/lightsaber_killicon", color_white )
end

--addons/egm_tfa_mines/lua/weapons/weapon_mine_antiperson/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--              Mines            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Mines | Base Weapon        --
---------------------------------------

SWEP.Base 					= "weapon_mine_base"
SWEP.PrintName 				= "Mine - Anti Person"
SWEP.Category 				= "SW:RP (Republik)"

SWEP.Spawnable				= true

SWEP.Mine 					= "mine_antiperson"
SWEP.Skin 					= 0

SWEP.WElements = {
	["mine"] = {
		type = "Model",
		model = "models/bf2/Landmine.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(3.635, 2.596, -0.519),
		angle = Angle(-75.974, 0, 0),
		size = Vector(0.5, 0.5, 0.5),
		color = Color(255, 255, 255, 255),
		surpresslightning = true,
		material = "",
		skin = SWEP.Skin,
		bodygroup = {}
	}
}

SWEP.VElements = {
	["mine"] = {
		type = "Model",
		model = "models/bf2/Landmine.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(1.557, 4.675, -1.558),
		angle = Angle(-38.571, 0, 0),
		size = Vector(0.5, 0.5, 0.5),
		color = Color(255, 255, 255, 255),
		surpresslightning = true,
		material = "",
		skin = SWEP.Skin,
		bodygroup = {}
	}
}

--addons/egm_tfa_mines/lua/weapons/weapon_mine_antivehicle/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--              Mines            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Mines | Base Weapon        --
---------------------------------------

SWEP.Base 					= "weapon_mine_base"
SWEP.PrintName 				= "Mine - Anti Fahrzeug"
SWEP.Category 				= "SW:RP (Republik)"

SWEP.Spawnable				= true

SWEP.Mine 					= "mine_antivehicle"
SWEP.Skin 					= 1

SWEP.WElements = {
	["mine"] = {
		type = "Model",
		model = "models/bf2/Landmine.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(3.635, 2.596, -0.519),
		angle = Angle(-75.974, 0, 0),
		size = Vector(0.5, 0.5, 0.5),
		color = Color(255, 255, 255, 255),
		surpresslightning = true,
		material = "",
		skin = SWEP.Skin,
		bodygroup = {}
	}
}

SWEP.VElements = {
	["mine"] = {
		type = "Model",
		model = "models/bf2/Landmine.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(1.557, 4.675, -1.558),
		angle = Angle(-38.571, 0, 0),
		size = Vector(0.5, 0.5, 0.5),
		color = Color(255, 255, 255, 255),
		surpresslightning = true,
		material = "",
		skin = SWEP.Skin,
		bodygroup = {}
	}
}

--gamemodes/starwarsrp/entities/weapons/weapon_swrp_binocular/shared.lua:
if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("vgui/swepicons/weapon_rpw_binoculars")
end

SWEP.Slot                    = 3
SWEP.SlotPos                 = 6
SWEP.DrawAmmo                = false
SWEP.DrawCrosshair           = true
SWEP.Weight                  = 20
SWEP.AutoSwitchTo            = false
SWEP.AutoSwitchFrom          = false

SWEP.ViewModel               = "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel              = "models/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV            = 75
SWEP.ViewModelFlip           = false
SWEP.MaterialTable           = nil
SWEP.UseHands                = true
SWEP.HoldType                = "slam"

SWEP.Base                    = "tfa_gun_base"
SWEP.Category                = "SW:RP (Sonstiges)"
SWEP.Manufacturer            = "Neuro-Saav"
SWEP.Author                  = "Yaura"
SWEP.Contact                 = ""
SWEP.Purpose                 = "Zum Beobachten entlegener Orte"
SWEP.Spawnable               = true
SWEP.AdminSpawnable          = true
SWEP.DrawCrosshair           = false
SWEP.DrawCrosshairIS         = false
SWEP.PrintName               = "TD 2.2-Elektrofernglas"
SWEP.Type                    = "Computergestütztes Weitsichtgerät"
SWEP.DrawAmmo                = false
SWEP.data                    = {}
SWEP.data.ironsights         = 0

SWEP.FiresUnderwater         = true
SWEP.SelectiveFire           = false

SWEP.Primary.ClipSize        = 0
SWEP.Primary.DefaultClip     = 0
SWEP.Primary.RPM             = 0
SWEP.Primary.RPM_Burst       = 0
SWEP.Primary.Ammo            = "bino"
SWEP.Primary.AmmoConsumption = 1
SWEP.Primary.Range           = 0
SWEP.Primary.RangeFalloff    = 0
SWEP.Primary.NumShots        = 0
SWEP.Primary.Automatic       = 0
SWEP.Primary.RPM_Semi        = 0
SWEP.Primary.BurstDelay      = 0
SWEP.Primary.Sound           = nil
SWEP.Primary.ReloadSound     = nil
SWEP.Primary.Damage          = 0

SWEP.SprintFOVOffset         = 2.2

SWEP.ShowWorldModel          = false

SWEP.VMPos                   = Vector(6, -5, 0)
SWEP.VMAng                   = Vector(0, 0, 0)

SWEP.MoveSpeed               = 1

SWEP.IronSightsPos           = Vector(-6.85, -6, 4.8332)
SWEP.IronSightsAng           = Vector(0, 0, 0)
SWEP.RunSightsPos            = Vector(0, 0, 0)
SWEP.RunSightsAng            = Vector(-40, 0, 0)
SWEP.InspectPos              = Vector(-5, 0, 3)
SWEP.InspectAng              = Vector(0, 0, 0)

local defFov                 = 90

SWEP.ViewModelBoneMods       = {
	["v_scoutblaster_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, -0.3, 0), angle = Angle(0, 0,
		0) }
}

SWEP.VElements               = {
	["bino"] = { type = "Model", model = "models/nate159/swbf2015/pewpew/electrobinocular.mdl", bone =
	"v_scoutblaster_reference001", rel = "", pos = Vector(-5, 2, 0), angle = Angle(0, 90, 0), size = Vector(1, 1, 1), color =
		Color(255, 255, 255, 255), surpresslightning = false, material = "t_electrobinocularstd23_c", skin = 0, bodygroup = {} },
	["scope1"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_scoutblaster_reference001", rel = "bino", pos =
		Vector(-5.5, 1.6, 0.36), angle = Angle(0, 180, 0), size = Vector(0.4, 0.4, 0.4), color = Color(255, 255, 255, 255), surpresslightning = true, material =
	"!tfa_rtmaterial", skin = 0, bodygroup = {}, active = false },
	["scope2"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_scoutblaster_reference001", rel = "bino", pos =
		Vector(-5.5, -1.6, 0.36), angle = Angle(0, 180, 0), size = Vector(0.4, 0.4, 0.4), color = Color(255, 255, 255,
		255), surpresslightning = true, material =
	"!tfa_rtmaterial", skin = 0, bodygroup = {}, active = false },

	["txt_range_m"] = { type = "Quad", bone = "", rel = "scope1", pos = Vector(0.01, 0.72, 0.085), angle = Angle(0, 90,
		90), size = 0.00045, draw_func = nil, active = true },
	["txt_range_wu"] = { type = "Quad", bone = "", rel = "scope1", pos = Vector(0.01, 0.72, -0.01), angle = Angle(0, 90,
		90), size = 0.00045, draw_func = nil, active = true },
	["txt_mod"] = { type = "Quad", bone = "", rel = "scope1", pos = Vector(0.01, -0.6, 0.10), angle = Angle(0, 90, 90), size = 0.0005, draw_func = nil, active = true },
}

SWEP.WElements               = {
	["bino"] = { type = "Model", model = "models/nate159/swbf2015/pewpew/electrobinocular.mdl", bone =
	"ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(9, 6.2, -2.6), angle = Angle(15, -6, 193), size = Vector(1.1, 1.15,
		1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "t_electrobinocularstd23_c", skin = 0, bodygroup = {} }
}

SWEP.IsSWRPBinocular         = true

if CLIENT then
	local allEntities = {}
	local bounds1, bounds2
	local position
	local middle

	surface.CreateFont("MainFont", {
		font = "Aurebesh",
		size = 20,
		weight = 5000,
		shadow = true
	})
	surface.CreateFont("DistFont", {
		font = "Aurebesh",
		size = 20,
		weight = 1,
		shadow = true
	})
	surface.CreateFont("OverFont", {
		font = "Aurebesh",
		size = ScreenScale(6.5),
		weight = 5000,
		shadow = false
	})
	surface.CreateFont("CustFont", {
		font = "Aurebesh",
		size = ScreenScale(5.8),
		weight = 5000,
		shadow = false
	})

	local screenScaleX = ScrW() / ScrW()
	local screenScaleY = ScrH() / ScrH()

	local scW = ScrW()
	local scH = ScrH()

	local mouseX, mouseY = 0, 0
	local elevation = 0
	local compass = 0

	hook.Add("DrawOverlay", "Bino:DrawOverlay", function()
		if IsValid(LocalPlayer()) and LocalPlayer():GetActiveWeapon() and IsValid(LocalPlayer():GetActiveWeapon()) and (LocalPlayer():GetActiveWeapon().IsSWRPBinocular) then
			local binAlpha = math.Rand(100, 255)

			local color_blue = Color(0, 255, 255, binAlpha * 0.75)
			local color_red = Color(255, 0, 0, binAlpha * 0.75)
			local color_green = Color(0, 255, 0, binAlpha * 0.75)
			local color_white = Color(255, 255, 255)
			local color_white_bin = Color(255, 255, 255, binAlpha)

			if (#allEntities > 0) then
				for i = 1, #allEntities do
					if (IsValid(allEntities[i]) and allEntities[i]:GetNWInt("marked") == 1) then
						bounds1, bounds2 = allEntities[i]:GetCollisionBounds()
						position = allEntities[i]:GetPos()
						boundsWidth = GetBoundsWidth(bounds1, bounds2)
						boundsHeight = GetBoundsHeight(bounds1, bounds2)
						middle = allEntities[i]:EyePos() + Angle():Up() * LocalPlayer():GetPos():Distance(position) / 40
						mx, my = middle:ToScreen().x, middle:ToScreen().y
						ts = 25
						distance = tostring(math.Round(LocalPlayer():GetPos():Distance(position) / 20)) .. "m"

						if (allEntities[i]:IsPlayer()) then
							name = allEntities[i]:GetName()
						else
							name = allEntities[i]:GetClass()
						end
					end
				end
			end

			if (LocalPlayer():GetNWBool("binOpen")) then
				local tr = LocalPlayer():GetEyeTrace()

				surface.SetDrawColor(color_white)
				surface.SetTexture(surface.GetTextureID("effects/combine_binocoverlay"))
				surface.DrawTexturedRect(0, 0, scW, scH)
				surface.SetDrawColor(color_white)
				surface.SetTexture(surface.GetTextureID("binocularhud"))
				surface.DrawTexturedRect(0, 0, scW, scH)

				surface.SetDrawColor(color_blue)
				surface.SetTexture(surface.GetTextureID("cross.vtf"))
				surface.DrawTexturedRect(mouseX, mouseY, scW, scH)
				surface.SetTexture(surface.GetTextureID("elevation.vtf"))
				surface.DrawTexturedRect(mouseX - scW / 5.9 * screenScaleX,
					mouseY + scH / 100 * screenScaleY - elevation * screenScaleY / scH * 3000 * screenScaleY, scW, scH)

				local televation = elevation

				if (elevation > -1) then
					televation = "+" .. elevation
				end

				surface.SetFont("OverFont")
				surface.SetTextColor(color_blue)

				local indtx = surface.GetTextSize(tostring(televation))
				surface.SetTextPos(mouseX + scW / 3.02 * screenScaleX - indtx,
					mouseY + scH / 2.02 * screenScaleY - elevation * screenScaleY / scH * 3000 * screenScaleY)
				surface.DrawText(tostring(televation))
				surface.SetTextPos(mouseX + scW / 3.4 * screenScaleX, mouseY + scH / 4.5 * screenScaleY)
				surface.DrawText("hoehe")
				surface.SetTextPos(mouseX + scW / 1.5 * screenScaleX, mouseY + scH / 4.5 * screenScaleY)
				surface.DrawText("ZOOM")
				local range = (math.ceil(10 * (tr.StartPos:Distance(tr.HitPos) * 0.024)) / 10)

				if tr.HitSky then
					range = "-"
				else
					range = range .. "m"
				end

				local playerMarker = false

				if tr.Entity and IsValid(tr.Entity) and (tr.Entity:IsPlayer() or tr.Entity:IsNPC()) then
					local ent = tr.Entity
					if ent:IsPlayer() then
						if ent:GetNW2Bool("CamoEnabled", true) or ent:GetColor().a == 0 then playerMarker = false else playerMarker = true end
					else
						playerMarker = true
					end
				else
					playerMarker = false
				end

				local vehicleMarker = false

				if tr.Entity and IsValid(tr.Entity) and (tr.Entity.LFS or tr.Entity:IsVehicle()) then
					vehicleMarker = true
				else
					vehicleMarker = false
				end

				surface.SetTextColor(color_red)
				surface.SetFont("OverFont")
				surface.SetTextPos(scW / 2.20689655 * screenScaleX, scH / 5.26829268 * screenScaleY)
				surface.DrawText("range: " .. range)

				local GetFOV1 = math.Round(LocalPlayer():GetFOV())

				if LocalPlayer():GetNWInt("zoomMode") == 5 then
					redZoomScale = 255
					blueZoomScale = 0
					greenZoomScale = 0
				else
					redZoomScale = 0
					blueZoomScale = 255
					greenZoomScale = 255
				end

				surface.SetDrawColor(redZoomScale, blueZoomScale, greenZoomScale, binAlpha * 0.75)
				surface.DrawRect(mouseX + scW / 1.46 * screenScaleX,
					mouseY + scH / 2 * screenScaleY + scH / 18.3 * screenScaleY -
					LocalPlayer():GetFOV() / defFov * screenScaleY * 575, 30 * screenScaleX, 2 * screenScaleY)
				surface.DrawRect(mouseX + scW / 1.44 * screenScaleX,
					mouseY + scH / 2 * screenScaleY + scH / 24 * screenScaleY -
					LocalPlayer():GetFOV() / defFov * screenScaleY * 575, 2 * screenScaleX, 15 * screenScaleY)
				surface.DrawRect(mouseX + scW / 1.46 * screenScaleX,
					mouseY + scH / 2 * screenScaleY - scH / 18 * screenScaleY + GetFOV1 / defFov * screenScaleY * 575,
					30 * screenScaleX, 2 * screenScaleY)
				surface.DrawRect(mouseX + scW / 1.44 * screenScaleX,
					mouseY + scH / 2 * screenScaleY - scH / 18.62 * screenScaleY + GetFOV1 / defFov * screenScaleY * 575,
					2 * screenScaleX, 15 * screenScaleY)
				surface.SetFont("OverFont")
				surface.SetDrawColor(color_blue)

				local scalestring = "X" .. math.Round(defFov / LocalPlayer():GetFOV())
				indtx = surface.GetTextSize(scalestring)
				surface.SetTextPos(mouseX + scW / 1.42 * screenScaleX - indtx, mouseY + scH / 1.32 * screenScaleY)
				surface.DrawText(scalestring)

				--270 and not 180 for drawing extra lines
				for i = -270, 270 do
					local lineXPos = compass * 20 * screenScaleX + i * 20 * screenScaleX + mouseX

					if (lineXPos > scW / 3.44 * screenScaleX and lineXPos < scW / 1.42 * screenScaleX) then
						if math.fmod(i, 15) == 0 then
							surface.DrawRect(lineXPos - 1 * screenScaleX, 105 * screenScaleY + mouseY, 3 * screenScaleX,
								22 * screenScaleY)
						else
							surface.DrawLine(lineXPos, 110 * screenScaleX + mouseY, lineXPos, 125 * screenScaleX + mouseY)
						end

						if (i == 45) then
							indtx = surface.GetTextSize("N")
							surface.SetTextPos(lineXPos - indtx / 2 + 1, 70 * screenScaleX + mouseY)
							surface.DrawText("N")
						end

						if (i == 225) then
							indtx = surface.GetTextSize("S")
							surface.SetTextPos(lineXPos - indtx / 2 + 1, 70 * screenScaleX + mouseY)
							surface.DrawText("S")
						end

						if (i == 135) then
							indtx = surface.GetTextSize("E")
							surface.SetTextPos(lineXPos - indtx / 2 + 1, 70 * screenScaleX + mouseY)
							surface.DrawText("E")
						end

						if (i == -45) then
							indtx = surface.GetTextSize("W")
							surface.SetTextPos(lineXPos - indtx / 2 + 1, 70 * screenScaleX + mouseY)
							surface.DrawText("W")
						end
					end
				end

				--RANDOM DESIGN NUMBERS
				draw.RoundedBox(4, scW / 2.3 * screenScaleX, scH / 1.27 * screenScaleY, scW / 7.68, scH / 21.6,
					color_blue)
				draw.RoundedBox(2, scW / 2.29 * screenScaleX, scH / 1.26 * screenScaleY, scW / 24, scH / 27, color_blue)
				draw.RoundedBox(2, scW / 2.085 * screenScaleX, scH / 1.26 * screenScaleY, scW / 23.4146341, scH / 27,
					color_blue)
				draw.RoundedBox(2, scW / 1.91 * screenScaleX, scH / 1.26 * screenScaleY, scW / 24, scH / 27, color_blue)

				draw.SimpleText(math.random(8000, 9000), "CustFont", scW / 2.18 * screenScaleX, scH / 1.23 * screenScaleY,
					color_white_bin, 1, 1)
				draw.SimpleText(math.random(400, 500), "CustFont", scW / 1.84 * screenScaleX, scH / 1.23 * screenScaleY,
					color_white_bin, 1, 1)
				draw.SimpleText("1" .. math.random(200, 700), "CustFont", scW / 1.99 * screenScaleX,
					scH / 1.23 * screenScaleY, color_white_bin, 1, 1)

				-- ENTITY DESIGN MARKER
				if playerMarker then
					draw.RoundedBox(50, scW / 9.6 * screenScaleX, scH / 5.4 * screenScaleY, 20, 20, color_red)
				else
					draw.RoundedBox(100, scW / 9.6 * screenScaleX, scH / 5.4 * screenScaleY, 20, 20, color_blue)
				end

				if vehicleMarker then
					draw.RoundedBox(100, scW / 10.9714286 * screenScaleX, scH / 5.4 * screenScaleY, 20, 20, color_green)
				else
					draw.RoundedBox(100, scW / 10.9714286 * screenScaleX, scH / 5.4 * screenScaleY, 20, 20, color_blue)
				end

				draw.RoundedBox(100, scW / 12.8 * screenScaleX, scH / 5.4 * screenScaleY, 20, 20, color_blue)

				-- RANDOM TEXT
				draw.SimpleText("regularmode - on", "DistFont", scW / 1.47 * screenScaleX, scH / 1.18 * screenScaleY,
					color_red, 1, 1)
			end
		end
	end)

	hook.Add("InputMouseApply", "inputmouse", function(cmd, x, y, ang)
		mouseX = Lerp(0.006, mouseX, -x) / (1920 / scW)
		mouseY = Lerp(0.006, mouseY, -y) / (1080 / scH)
		elevation = math.Round(0 - ang.p)
		compass = ang.y
	end)

	hook.Add("CalcViewModelView", "vmoverride", function(wep, vm, oldPos, oldAng, pos, ang)
		if (LocalPlayer():GetNWBool("binOpen")) then
			return EyePos() - EyeAngles():Forward() * 10000, EyeAngles()
		end
	end)
end

function SWEP:ClientSecondaryAttack()
	if CLIENT and self:GetOwner():GetNWBool("binOpen", false) then
		surface.PlaySound("wos/alcs/ui_rollover.wav")
	end

	self:PostSecondaryAttack()
end

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire(CurTime() + 0.3)
	self:CallOnClient("ClientSecondaryAttack")
	self:SetHoldType("camera")

	if SERVER and self:GetOwner():GetNWBool("binOpen", false) then
		if (self:GetOwner():GetNWInt("zoomMode") >= 5) then
			self:GetOwner():SetNWInt("zoomMode", 0)
		end

		self:GetOwner():SetNWInt("zoomMode", self:GetOwner():GetNWInt("zoomMode") + 1)

		if (self:GetOwner():GetNWInt("zoomMode") == 0) then
			self:GetOwner():SetFOV(defFov - defFov / 2.2, 0.05)
			self:GetOwner():SetNWInt("zoomMode", 1)
		elseif (self:GetOwner():GetNWInt("zoomMode") == 1) then
			self:GetOwner():SetFOV(defFov - defFov / 2.2, 0.05)
		elseif (self:GetOwner():GetNWInt("zoomMode") == 2) then
			self:GetOwner():SetFOV(defFov - defFov / 1.375, 0.05)
		elseif (self:GetOwner():GetNWInt("zoomMode") == 3) then
			self:GetOwner():SetFOV(defFov - defFov / 1.15, 0.05)
		elseif (self:GetOwner():GetNWInt("zoomMode") == 4) then
			self:GetOwner():SetFOV(defFov - defFov / 1.09, 0.05)
		elseif (self:GetOwner():GetNWInt("zoomMode") == 5) then
			self:GetOwner():SetFOV(defFov - defFov / 1.06, 0.05)
		end
	end

	if CLIENT then
		self:ClientSecondaryAttack()
	end
end

function SWEP:DoDrawCrosshair(x, y)
	if self:GetOwner():GetNWBool("binOpen") then
		return true
	else
		return false
	end
end

function GetIndexOfValue(tbl, val)
	for k, v in pairs(tbl) do
		if (IsValid(v) and v == val) then return k end
	end

	return -1
end

function SWEP:AdjustMouseSensitivity()
	return self:GetOwner():GetFOV() / defFov
end

function GetBoundsWidth(bounds1, bounds2)
	return bounds2.x - bounds1.x
end

function GetBoundsHeight(bounds1, bounds2)
	return bounds2.z - bounds1.z
end

hook.Add("KeyPress", "keydown", function(ply, key)
	if (key == IN_ATTACK2 and ply:GetActiveWeapon() and IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon().IsSWRPBinocular) and ! ply:GetNWBool("binOpen", false) then
		local weapon = ply:GetActiveWeapon()

		if IsValid(weapon) then
			weapon.DefaultHoldType = "camera"
		end

		ply:SetNWBool("binOpen", true)

		if SERVER then
			ply:SetFOV(defFov - defFov / 2.2, 0.05)
		end

		if ply:GetNWBool("binOpen", false) then
			ply:GetActiveWeapon():SetHoldType("camera")
		end

		if CLIENT then
			surface.PlaySound("gen_sound.uax_00004.wav")
		end

		ply:SetNWInt("zoomMode", 1)
	end
end)

hook.Add("KeyRelease", "keyup", function(ply, key)
	if (key == IN_ATTACK2 and ply:GetActiveWeapon() and IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon().IsSWRPBinocular) and ply:GetNWBool("binOpen", false) then
		local weapon = ply:GetActiveWeapon()

		if IsValid(weapon) then
			weapon.DefaultHoldType = "slam"
		end

		ply:SetNWBool("binOpen", false)

		if SERVER then
			ply:SetFOV(defFov, 0.05)
		end

		if ply:GetNWBool("binOpen", false) then
			ply:GetActiveWeapon():SetHoldType("slam")
		end

		if CLIENT then
			surface.PlaySound("whoosh_00.wav")
			timer.Stop("ambientSoundTimer")
		end

		ply:SetNWInt("zoomMode", 0)
	end
end)

--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_bowcaster.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_3dscoped_base"

SWEP.PrintName              = "Bowcaster"
SWEP.Category               = "SW:RP (Event)"
SWEP.Type					= "Laser crossbow"
SWEP.Manufacturer           = "Handcrafted"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos = Vector(1.57, 0, -00.00)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	--["bc"] = { type = "Model", model = "models/strasser/weapons/bowcaster/bowcaster.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0.5, 0, -0.5), angle = Angle(0, 0, 0), size = Vector(1.4, 1.4, 1.4), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["bc"] = { type = "Model", model = "models/hauptmann/star wars/weapons/bowcaster.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0.5, 03, -07), angle = Angle(0, -90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["scope1"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_dlt19_reference001", rel = "bc", pos = Vector(-07.73, -01.54, 11.27), angle = Angle(0, 180, 0), size = Vector(0.23, 0.23, 0.23), color = Color(255, 255, 255, 255), surpresslightning = false, material = "!tfa_rtmaterial", skin = 0, bodygroup = {} },
	["scope2"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_dlt19_reference001", rel = "bc", pos = Vector(-05.4, -0.035, 11.258), angle = Angle(0, 180, 0), size = Vector(0.3, 0.3, 0.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "!tfa_rtmaterial", skin = 0, bodygroup = {} },
	["scope3"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_dlt19_reference001", rel = "bc", pos = Vector(-07.73, 01.46, 11.28), angle = Angle(0, 180, 0), size = Vector(0.23, 0.23, 0.23), color = Color(255, 255, 255, 255), surpresslightning = false, material = "!tfa_rtmaterial", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	--["bc"] = { type = "Model", model = "models/strasser/weapons/bowcaster/bowcaster.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4, 1, -1.5), angle = Angle(5, -90, 166), size = Vector(1.3, 1.3, 1.3), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
	["bc"] = { type = "Model", model = "models/hauptmann/star wars/weapons/bowcaster.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(8.5, 1, 4), angle = Angle(-15, -0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(4, 0, -6)
SWEP.HolsterAngle = Angle(0, 180, 0)



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_green"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 140

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 16000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 90

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_green"
SWEP.Secondary.ScopeZoom 			= 2
SWEP.ScopeReticule_Scale 			= {1.1,1.1}
SWEP.IronSightsSensitivity          = 0.25

SWEP.ZoomLevels = {
	2,
	5,
	6
}

SWEP.Primary.Spread					= 0.012
SWEP.Primary.IronAccuracy 			= 0.004

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-4.65, -4, 1.85)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 1.5)
SWEP.RunSightsAng = Vector(-22, 32.50, -19)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("w/bowcaster.wav");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("w/heavy.wav");

DEFINE_BASECLASS( SWEP.Base )
--addons/emplacements/lua/weapons/weapon_swrp_bullets_deployable.lua:
SWEP.Base							= "tfa_gun_base"
SWEP.Category						= "SW:RP (Sonstiges)"
SWEP.Manufacturer 					= ""
SWEP.Author							= "Summe"

SWEP.PrintName						= "Blaster Cannon"
SWEP.Slot							= 3
SWEP.SlotPos						= 0
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"
SWEP.ShowViewModel = false
SWEP.ShowWorldModel = false

SWEP.ViewModelFOV					= 75
SWEP.ViewModelFlip					= false
SWEP.MaterialTable 					= nil
SWEP.UseHands 						= false
SWEP.HoldType 						= "duel"
SWEP.MoveSpeed 						= 0.5
SWEP.RunSpeed						= 0.7

SWEP.Primary.ClipSize = 1
SWEP.Primary.DefaultClip = 1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.TurretStand = "swrp_turret_stand_bullets"

SWEP.VElements = {
	["carte"] = {
		type = "Model",
		model = "models/kingpommes/starwars/misc/imp_crate_double_closed.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "",
		pos = Vector(0, 0, -15),
		angle = Angle(0, 190, 0),
		size = Vector(0.8, 0.8, 0.8),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},
}

SWEP.WElements = {
	["carte"] = {
		type = "Model",
		model = "models/kingpommes/starwars/misc/imp_crate_double_closed.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(-02, 10.5, -10),
		angle = Angle(180, 90, -4),
		size = Vector(0.5, 0.5, 0.5),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {} }
}

SWEP.HolsterOffset = Vector(8, 0, 10)
SWEP.HolsterAngle = Angle(0, 0, 0)

function SWEP:PrimaryAttack()
	local turret = {
		[self.TurretStand] = true,
	}

	local ply = self:GetOwner()
	local trace = ply:GetEyeTrace().Entity

	if IsValid( ply ) && ply:IsPlayer() then
		if trace:GetPos():DistToSqr( ply:EyePos() ) < 150 * 150 then
			if turret[trace:GetClass()] then
				trace:SetNWBool("Remove?", true)

				if SERVER then
					-- If the player has no ammo left, remove the weapon
					if self:Clip1() <= 1 then
						self:GetOwner():StripWeapon(self:GetClass())
					else
						self:TakePrimaryAmmo(1)
					end
				end
			end
		else
			if SERVER then
				self:SpawnStand()
			end
		end
	end
end

function SWEP:SpawnStand()
	local trace = self:GetOwner():GetEyeTrace()

	if trace.Hit then
		local endpos = trace.HitPos
		local distance = self:GetOwner():GetPos():DistToSqr(endpos)

		if distance <= 40000 then
			local stand = ents.Create(self.TurretStand)

			if IsValid(stand) then
				stand:SetPos(endpos + Vector(0, 0, 8))
				stand:Spawn()
				stand:Activate()
				stand.owner = self:GetOwner()

				if self:Clip1() <= 1 then
					self:GetOwner():StripWeapon(self:GetClass())
				else
					self:TakePrimaryAmmo(1)
				end
			end
		end
	end
end
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc17silenced.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "DC-17 Silenced"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Blaster Pistol"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 1
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"

SWEP.VMPos = Vector(0.88, -4, -0.240)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "pistol"
SWEP.ReloadHoldTypeOverride 		= "pistol"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_scoutblaster_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, -0.3, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dc17s"] = { type = "Model", model = "models/fisher/dc17s/dc17s.mdl", bone = "v_scoutblaster_reference001", rel = "", pos = Vector(-0, -04.5, 01), angle = Angle(0, 180, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {[1] = 1} },
}

SWEP.WElements = {
	["dc17"] = { type = "Model", model = "models/fisher/dc17s/dc17s.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(8.2, 01.5, -3.25), angle = Angle(0, -90, 175), size = Vector(0.9, 0.9, 0.9), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {[1] = 1} },
}

SWEP.HolsterOffset = Vector(-2.5, -0.2, 0)
SWEP.HolsterAngle = Angle(0, -90, -1)

SWEP.Animations = { --Override this after SWEP:Initialize, for example, in attachments
	["reload"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY,
		["enabled"] = true
	},
	["reload_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY
	},
	["reload_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY,
		["enabled"] = true
	},
}

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training", "swrp_am_stun_lite" }, order = 1 },
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"

-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 300

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 2040

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 35

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 7
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.0125
SWEP.Primary.IronAccuracy 			= 0.0042

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-4.8, -6, 1.5)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 			= Sound("w/dc19.wav")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound("weapons/dc17_reload.wav")

DEFINE_BASECLASS( SWEP.Base )

--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dc19stealth.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_3dscoped_base"

SWEP.PrintName              = "DC-19 Stealth"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Stealth Scoped Blaster Carbine"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_e11.mdl"
SWEP.WorldModel						= "models/bf2017/w_e11.mdl"

SWEP.VMPos = Vector(2, -7, -1.5)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_e11_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}
SWEP.VElements = {
	["dc15"] = { type = "Model", model = "models/cs574/weapons/dc15se.mdl", bone = "v_e11_reference001", rel = "", pos = Vector(-0.75, 0, -0), angle = Angle(0, -90, 0), size = Vector(1.1, 1.1, 1.1), color = Color(40, 40, 40), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["dc15_scope2"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_e11_reference001", rel = "dc15", pos = Vector(1.35, -0.015, 4.60), angle = Angle(0, 180, 0), size = Vector(0.33, 0.33, 0.33), color = Color(255, 255, 255, 255), surpresslightning = false, material = "!tfa_rtmaterial", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["dc15"] = { type = "Model", model = "models/cs574/weapons/dc15se.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(2.8, 0.5, -0.5), angle = Angle(-12, 0, 172), size = Vector(1, 1, 1), color = Color(40, 40, 40), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.HolsterOffset = Vector(11, 0, 0)
SWEP.HolsterAngle = Angle(0, 180, 0)

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training", "swrp_am_swt" }, order = 1 },
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"
SWEP.ImpactEffect 					= "rw_sw_impact_white"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 100
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic",
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= 444
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 120

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 4080

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 30

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1

SWEP.Primary.Spread					= 0.01
SWEP.Primary.IronAccuracy 			= 0.002

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.1

SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom 			= 2
SWEP.ScopeReticule_Scale 			= {1.1,1.1}
SWEP.IronSightsSensitivity          = 0.25



SWEP.ZoomLevels = {
	1,
	2
}

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-4.67, -9, 4.12)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)
-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound("w/dc19.wav")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound("w/rifles.wav")

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_dp23.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "DP23"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Blaster Shotgun"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_e11.mdl"
SWEP.WorldModel						= "models/bf2017/w_e11.mdl"

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_e11_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(-3, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["dp23"] = { type = "Model", model = "models/cs574/weapons/dp23.mdl", bone = "v_e11_reference001", rel = "", pos = Vector(-0.6, 0.3, 0.9), angle = Angle(0, -90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {[1] = 0, [2] = 1, [3] = 1} }
}

SWEP.WElements = {
	["dp23"] = { type = "Model", model = "models/cs574/weapons/dp23.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3.5, 0.5, -1.25), angle = Angle(-13, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {[1] = 0, [2] = 1, [3] = 1} }
}

SWEP.HolsterOffset = Vector(11, 0, 0)
SWEP.HolsterAngle = Angle(0, 180, 0)



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 120
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 12
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 12

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 60

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 700

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 12
-- Damage per bullet
SWEP.Primary.Damage = 25

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "scope/gdcw_elcanreticle"
SWEP.Secondary.ScopeZoom 			= 0
SWEP.ScopeReticule_Scale 			= {1.1,1.1}

SWEP.Primary.Spread					= 0.15
SWEP.Primary.IronAccuracy 			= 0.05

SWEP.Primary.SpreadMultiplierMax 	= 2.5
SWEP.Primary.SpreadIncrement 		= 0.3

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-2.55, -7, 2.3)
SWEP.IronSightsAng = Vector (2, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)



-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("w/dp23.wav");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("w/heavy.wav");

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_droideka.lua:
-- Written by Oninoni

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName = "Droideka Weapon & Shield"
SWEP.Category               = "SW:RP (Separatisten)"
SWEP.Type                    = "Droideka Weapon System"
SWEP.Manufacturer           = "Some Bugs"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel                        = "models/strasser/weapons/c_ddeagle.mdl"
SWEP.WorldModel                        = "models/bf2017/w_scoutblaster.mdl"

SWEP.VMPos = Vector(1.96, 0, -0.52)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType                         = "duel"
SWEP.ReloadHoldTypeOverride         = "pistol"

SWEP.UseHands                         = true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
}

SWEP.VElements = {
	["droideka"] = {}
}

SWEP.WElements = {
	["droideka"] = {}
}

SWEP.ProceduralHolsterPos = Vector(0,-8,-8)
SWEP.ProceduralHolsterAng = Vector(37.5,0,0)
SWEP.DoProceduralReload = true
SWEP.ProceduralReloadTime = 2.3

SWEP.Akimbo = true
SWEP.Primary.DoMuzzleFlash             = true
SWEP.Secondary.DoMuzzleFlash         = true
SWEP.Blowback_Shell_Enabled         = true
SWEP.Blowback_Shell_Effect             = "None"

-- Tracer --

-- Tracer name
SWEP.TracerName                     = "rw_sw_dual_laser_red"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize                = 200
-- Magazine Count
SWEP.Primary.DefaultClip            = SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo                    = "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption         = 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Automatic",
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM                    = 450
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi                = 300

-- Burst Fire RPM
SWEP.Primary.RPM_Burst                = nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay                = nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range                     = 1500

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots                = 1
-- Damage per bullet
SWEP.Primary.Damage = 30

-- Aiming --

SWEP.data                             = {}
-- Enable Iron Sights
SWEP.data.ironsights                = 0
-- Iron Sights FOV
SWEP.Secondary.IronFOV                = 70 -- TODO

SWEP.ScopeReticule                     = "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom             = 7
SWEP.ScopeReticule_Scale             = {1,1}

SWEP.Primary.Spread                    = 0.025
SWEP.Primary.IronAccuracy             = 0.008

SWEP.Primary.SpreadMultiplierMax     = 2.5
SWEP.Primary.SpreadIncrement         = 0.35

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(1.96, 0, -0.52)
SWEP.IronSightsAng = Vector(0,0,0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound = Sound("w/droideka_fire.wav")
-- Reload Sound
SWEP.Primary.ReloadSound = Sound("w/heavy.wav")

DEFINE_BASECLASS( SWEP.Base )

SWEP.ShieldPercentage = 100

function SWEP:Think2()
	local baseTable = weapons.GetStored("weapon_swrp_egm_base")
	baseTable.Think2(self)

	local delta = CurTime() - (self.LastShieldThink or 0)
	self.LastShieldThink = CurTime()

	if self.ShieldEnabled then
		self.ShieldPercentage = math.max(0, self.ShieldPercentage - delta / 5)

		if SERVER then
			local owner = self:GetOwner()
			if owner:GetVelocity():Length() >= owner:GetWalkSpeed() * 0.9 then
				self:SendShieldStatus()

				self:ToggleShield()
			end

			if self.ShieldPercentage == 0 then
				self:SendShieldStatus()

				self.ShieldCharging = true
				self:ToggleShield()
			end
		end
	else
		if self.ShieldPercentage ~= 100 then
			self.ShieldPercentage = math.min(100, (self.ShieldPercentage or 0) + delta * 5)

			if SERVER and self.ShieldPercentage == 100 then
				self.ShieldCharging = false

				self:SendShieldStatus()
			end
		end
	end
end


if SERVER then
	util.AddNetworkString("Droideka.ShieldStatus")
	function SWEP:SendShieldStatus()
		local owner = self:GetOwner()
		if owner:IsPlayer() then
			net.Start("Droideka.ShieldStatus")
				net.WriteFloat(self.ShieldPercentage)
				net.WriteBool(self.ShieldCharging)
			net.Send(owner)
		end
	end

	util.AddNetworkString("Droideka.ShieldToggle")
	function SWEP:ToggleShield(value)
		if self.ShieldPercentage == 0 and not self.ShieldEnabled then return end
		if self.ShieldCharging then return end

		if status ~= nil then
			self.ShieldEnabled = value
		else
			self.ShieldEnabled = not (self.ShieldEnabled or false)
		end

		net.Start("Droideka.ShieldToggle")
			net.WriteEntity(self)
			net.WriteBool(self.ShieldEnabled)
		net.Broadcast()
	end

	hook.Add("TFA_Deploy", "Droideka.AutoEnableNPC", function(wep)
		if wep:GetClass() ~= "weapon_swrp_droideka" then return end

		local owner = wep:GetOwner()
		if IsValid(owner) and owner.IsSWRPNextbot then
			timer.Simple(1, function()
				if IsValid(wep) then
					wep:ToggleShield(true)
				end
			end)
		end
	end)

	hook.Add("EntityTakeDamage", "Droideka.ShieldProtect", function(target, dmgInfo)
		if isfunction(target.GetActiveWeapon) then
			local weapon = target:GetActiveWeapon()
			local inflictor = dmgInfo:GetInflictor()

			if IsValid(weapon) and weapon:GetClass() == "weapon_swrp_droideka" and weapon.ShieldEnabled then
				local damage = dmgInfo:GetDamage()
				local energyTaken = damage * 0.01

				if weapon.ShieldPercentage >= energyTaken then
					if IsValid(inflictor) and string.StartWith(inflictor:GetClass(), "weapon_lightsaber_") then
						energyTaken = 0.01
					end

					weapon.ShieldPercentage = weapon.ShieldPercentage - energyTaken

					weapon:SendShieldStatus()
				else
					weapon.ShieldCharging = false

					weapon:ToggleShield()

					weapon.ShieldPercentage = 0
					weapon.ShieldCharging = true
					weapon:SendShieldStatus()

					weapon:SetNextSecondaryFire(CurTime() + 5)
				end

				return true
			end
		end
	end)
end

if CLIENT then
	net.Receive("Droideka.ShieldToggle", function()
		local weapon = net.ReadEntity()
		weapon.ShieldEnabled = net.ReadBool()
	end)

	net.Receive("Droideka.ShieldStatus", function()
		local weapon = LocalPlayer():GetActiveWeapon()

		if IsValid(weapon) and weapon:GetClass() == "weapon_swrp_droideka" then
			weapon.ShieldPercentage = net.ReadFloat()
			weapon.ShieldCharging = net.ReadBool()
		end
	end)

	function SWEP:DrawHUD()
		self.ShieldPercentage = self.ShieldPercentage or 0
		if self.ShieldPercentage ~= 0 then
			local color = Color(0, 127, 255)
			if self.ShieldCharging then
				color = Color(255, 0, 0, 255)
			end

			if self.ShieldEnabled then
				draw.RoundedBox(0, ScrW() * 0.01, ScrH() * 0.974, ScrW() * 0.001 * self.ShieldPercentage, ScrH() * 0.023, ColorAlpha(color, 200))
			else
				draw.RoundedBox(0, ScrW() * 0.01, ScrH() * 0.974, ScrW() * 0.001 * self.ShieldPercentage, ScrH() * 0.003, ColorAlpha(color, 255))
			end
		end
	end

	hook.Add("PostDrawTranslucentRenderables", "Droideka.RenderShield", function(_)
		for _, weapon in pairs(ents.FindByClass("weapon_swrp_droideka")) do
			local ply = weapon:GetOwner()

			if ply.DroidekaShieldSize and ply.DroidekaShieldSize > 0 then
				local size = ply.DroidekaShieldSize * 53

				render.SetColorMaterial()
				render.DrawSphere(ply:GetPos() + Vector(0, 0, 30), size + 4, 32, 32, Color(127, 100, 255, 63))

				render.SetMaterial(Material("models/props_combine/portalball001_sheet"))
				render.DrawSphere(ply:GetPos() + Vector(0, 0, 30), size + 5, 32, 32)

				ply.DroidekaShieldSize = (ply.DroidekaShieldSize or 0) - FrameTime() * 2
			end

			if IsValid(weapon) and weapon:GetClass() == "weapon_swrp_droideka" and weapon.ShieldEnabled then
				ply.DroidekaShieldSize = math.min((ply.DroidekaShieldSize or 0) + FrameTime() * 4, 1)
			end
		end
	end)
end

function SWEP:SecondaryAttack()
	if self:GetNextSecondaryFire() < CurTime() then
		if SERVER then
			self:ToggleShield()
		end

		self:SetNextSecondaryFire(CurTime() + 0.5)
	end
end

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("hud/killicons/dc15a")
	killicon.Add("weapon_swrp_dc15a", "hud/killicons/dc15a", Color( 255, 80, 0, 255 ))
	SWEP.CSMuzzleFlashes = false
end
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_egm_3dscoped_base.lua:
-- Written by Oninoni

SWEP.Base                   = "tfa_3dscoped_base"
SWEP.Category               = "EGM SWRP Weapons"
SWEP.Manufacturer           = "Onicorp Industries"
SWEP.Author                 = "Oninoni"
SWEP.Contact                = "jan.ziegler@einfach-gaming.de"
SWEP.Purpose                = "EGM SW:RP Weapon"
SWEP.Instructions           = "It's a gun... How hard can it be?"
SWEP.PrintName              = "EGM SWRP Base Weapon"
SWEP.Slot                   = 0
SWEP.SlotPos                = 42

SWEP.Spawnable = false

SWEP.CanJam     = false
SWEP.JamChance  = 0
SWEP.JamFactor  = 0

SWEP.FiresUnderwater                = true
SWEP.FireSoundAffectedByClipSize    = false
SWEP.DisableChambering              = true
-- Disable Penetration
SWEP.MaxPenetrationCounter          = 0

SWEP.BlowbackEnabled                 = true
SWEP.BlowbackVector                 = Vector(0,-1.5,-0.05)
SWEP.BlowbackCurrentRoot            = 0
SWEP.BlowbackCurrent                 = 0
SWEP.BlowbackBoneMods                 = nil
SWEP.Blowback_Only_Iron             = true
SWEP.Blowback_PistolMode             = false
SWEP.Blowback_Shell_Enabled         = false
SWEP.Blowback_Shell_Effect             = "None"

SWEP.NearWallTime                     = 0.5
SWEP.ToCrouchTime                     = 0.25
SWEP.WeaponLength                     = 35
SWEP.SprintFOVOffset                 = 12
SWEP.ProjectileVelocity             = 9

SWEP.IronRecoilMultiplier            = 0.65
SWEP.CrouchRecoilMultiplier            = 0.85
SWEP.JumpRecoilMultiplier            = 2
SWEP.WallRecoilMultiplier            = 1.1
SWEP.ChangeStateRecoilMultiplier    = 1.2
SWEP.CrouchAccuracyMultiplier        = 0.8
SWEP.ChangeStateAccuracyMultiplier    = 1
SWEP.JumpAccuracyMultiplier            = 10
SWEP.WalkAccuracyMultiplier            = 1.8

SWEP.ThirdPersonReloadDisable        = false
SWEP.Primary.RangeFalloff             = .05
SWEP.Primary.PenetrationMultiplier     = 0
SWEP.Primary.DamageType             = DMG_AIRBOAT
SWEP.DamageType                     = DMG_AIRBOAT

SWEP.Primary.KickUp                    = 0.12
SWEP.Primary.KickDown                = 0.09
SWEP.Primary.KickHorizontal            = 0.055
SWEP.Primary.StaticRecoilFactor     = 0.65
SWEP.Primary.SpreadRecovery         = 0.98

SWEP.MoveSpeed                         = 1
SWEP.IronSightsMoveSpeed             = 0.75

SWEP.DoMuzzleFlash                     = false

SWEP.ViewModelFOV                    = 75

SWEP.TracerCount                     = 1
SWEP.ImpactEffect                     = "effect_sw_impact"
SWEP.ImpactDecal                     = "FadingScorch"

SWEP.AutoSwitchFrom = false
SWEP.AutoSwitchTo = false
SWEP.DefaultFireMode = "Safe"

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training" }, order = 1 },
}

SWEP.ZoomLevels = {}

if surface then
	SWEP.Secondary.ScopeTable = nil
end

function SWEP:ProcessFireMode()
	if self:OwnerIsValid() and self:GetStatus() == TFA.Enum.STATUS_IDLE and (SERVER or not sp) then
		if self:GetOwner():KeyPressed(IN_USE) and self:GetOwner():KeyDown(IN_SPEED) then
			self:CycleSafety()
			return
		end

		if self:GetOwner():KeyPressed(IN_RELOAD) and not self:GetOwner():KeyDown(IN_SPEED) and self:GetOwner():KeyDown(IN_USE) then
			self:CycleFireMode()
			return
		end
	end
end

if CLIENT then
	function SWEP:RTCode(rt, scrw, scrh)
		local baseTable = weapons.GetStored("tfa_3dscoped_base")
		baseTable.RTCode(self, rt, scrw, scrh)

		local ply = LocalPlayer()
		local tr = ply:GetEyeTrace()
		local distance = math.Round((tr.StartPos:Distance(tr.HitPos) / 12) * 0.3048, 2)

		cam.Start2D()
			draw.SimpleText(distance .. "m", "EGMText10", scrw * 0.15, scrh * 0.5, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		cam.End2D()
	end

	function SWEP:PopulateKeyBindHints(keys)
		keys = {}

		return keys
	end
end

function SWEP:Think2()
	local baseTable = weapons.GetStored("tfa_gun_base")
	baseTable.Think2(self)
end

function SWEP:Reload(released)
	if not self:GetIronSights() or #self.ZoomLevels == 0 then
		local baseTable = weapons.GetStored("tfa_gun_base")
		return baseTable.Reload(self, released)
	end

	if not IsFirstTimePredicted() then return end

	local owner = self:GetOwner()
	if IsValid(owner) and owner:IsPlayer() and owner:KeyPressed(IN_RELOAD) and CLIENT then
		local target = self.Secondary_TFA or self.Secondary

		self.CurrentZoomLevel = ((self.CurrentZoomLevel or 0) + 1) % #self.ZoomLevels
		target.ScopeZoom = self.ZoomLevels[self.CurrentZoomLevel + 1]
		self.RTScopeFOV = 90 / target.ScopeZoom * ( target.ScopeScreenScale or 0.392592592592592 )

		self.IronSightsSensitivity = 1 / target.ScopeZoom
		print("IronSightsSensitivity", self.IronSightsSensitivity)

		self:EmitSound("Weapon_AR2.Empty")
	end
end

local function l_Lerp(v, f, t)
	return f + (t - f) * v
end

local fovv
local sensval
local sensitivity_cvar, sensitivity_fov_cvar, sensitivity_speed_cvar
if CLIENT then
	sensitivity_cvar = GetConVar("cl_tfa_scope_sensitivity")
	sensitivity_fov_cvar = GetConVar("cl_tfa_scope_sensitivity_autoscale")
	sensitivity_speed_cvar = GetConVar("sv_tfa_scope_gun_speed_scale")
end

function SWEP:AdjustMouseSensitivity()
	sensval = 1

	if self:GetIronSights() then
		sensval = sensval * sensitivity_cvar:GetFloat() / 100

		if sensitivity_fov_cvar:GetBool() then
			fovv = self:GetStatL("Secondary.OwnerFOV") or 70
			sensval = sensval * TFA.CalculateSensitivtyScale( fovv, nil, 1 )
		else
			sensval = sensval
		end

		if sensitivity_speed_cvar:GetFloat() then
			-- weapon heaviness
			sensval = sensval * self:GetStatL("AimingDownSightsSpeedMultiplier")
		end
	end

	sensval = sensval * l_Lerp(self:GetIronSightsProgress(), 1, self.IronSightsSensitivity )

	return sensval
end

DEFINE_BASECLASS( SWEP.Base )

--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_egm_base.lua:
-- Written by Oninoni

SWEP.Base                   = "tfa_gun_base"
SWEP.Category               = "EGM SWRP Weapons"
SWEP.Manufacturer           = "Onicorp Industries"
SWEP.Author                 = "Oninoni"
SWEP.Contact                = "jan.ziegler@einfach-gaming.de"
SWEP.Purpose                = "EGM SW:RP Weapon"
SWEP.Instructions           = "It's a gun... How hard can it be?"
SWEP.PrintName              = "EGM SWRP Base Weapon"
SWEP.Slot                   = 0
SWEP.SlotPos                = 42

SWEP.Spawnable = false

SWEP.CanJam     = false
SWEP.JamChance  = 0
SWEP.JamFactor  = 0

SWEP.FiresUnderwater                = true
SWEP.FireSoundAffectedByClipSize    = false
SWEP.DisableChambering              = true
-- Disable Penetration
SWEP.MaxPenetrationCounter          = 0

SWEP.BlowbackEnabled                 = true
SWEP.BlowbackVector                 = Vector(0,-1.5,-0.05)
SWEP.BlowbackCurrentRoot            = 0
SWEP.BlowbackCurrent                 = 0
SWEP.BlowbackBoneMods                 = nil
SWEP.Blowback_Only_Iron             = true
SWEP.Blowback_PistolMode             = false
SWEP.Blowback_Shell_Enabled         = false
SWEP.Blowback_Shell_Effect             = "None"

SWEP.NearWallTime                     = 0.5
SWEP.ToCrouchTime                     = 0.25
SWEP.WeaponLength                     = 35
SWEP.SprintFOVOffset                 = 12
SWEP.ProjectileVelocity             = 9

SWEP.IronRecoilMultiplier            = 0.65
SWEP.CrouchRecoilMultiplier            = 0.85
SWEP.JumpRecoilMultiplier            = 2
SWEP.WallRecoilMultiplier            = 1.1
SWEP.ChangeStateRecoilMultiplier    = 1.2
SWEP.CrouchAccuracyMultiplier        = 0.8
SWEP.ChangeStateAccuracyMultiplier    = 1
SWEP.JumpAccuracyMultiplier            = 10
SWEP.WalkAccuracyMultiplier            = 1.8

SWEP.ThirdPersonReloadDisable        = false
SWEP.Primary.RangeFalloff             = .05
SWEP.Primary.PenetrationMultiplier     = 0
SWEP.Primary.DamageType             = DMG_AIRBOAT
SWEP.DamageType                     = DMG_AIRBOAT

SWEP.Primary.KickUp                    = 0.12
SWEP.Primary.KickDown                = 0.09
SWEP.Primary.KickHorizontal            = 0.055
SWEP.Primary.StaticRecoilFactor     = 0.65
SWEP.Primary.SpreadRecovery         = 0.98

SWEP.MoveSpeed                         = 1
SWEP.IronSightsMoveSpeed             = 0.75

SWEP.DoMuzzleFlash                     = false

SWEP.ViewModelFOV                    = 75

SWEP.TracerCount                     = 1
SWEP.ImpactEffect                     = "effect_sw_impact"
SWEP.ImpactDecal                     = "FadingScorch"

SWEP.AutoSwitchFrom = false
SWEP.AutoSwitchTo = false
SWEP.DefaultFireMode = "Safe"

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training" }, order = 1 },
}

if surface then
	SWEP.Secondary.ScopeTable = nil
end

hook.Add("TFA_Initialize", "EGM.SWRP.TFA_Initialize", function(self)
	local fm = self:GetFireMode()
	local fmt = self:GetStat("FireModes")
	if fm == 0 then fm = 1 end
	if fm == #fmt then fm = 1 end
	self.Primary.Automatic = self:GetStat("FireModesAutomatic." .. self:GetStat("FireModes." .. fm)) ~= nil
	self.Primary_TFA.Automatic = self.Primary.Automatic

	local minimumDamage = isnumber(self.MinimumDamage) and self.MinimumDamage or 0.5
	local maxRange = isnumber(self.MaxRange) and self.MaxRange or 1000
	local effectiveRange = isnumber(self.EffectiveRange) and self.EffectiveRange or maxRange / 2

	self.Primary.RangeFalloffLUT = {
		bezier = true,
		range_func = "quintic",
		units = "meters",
		lut = {
			[0] = minimumDamage,
			[maxRange] = 1,
			[effectiveRange] = 0,
		},
	}
end)

function SWEP:ProcessFireMode()
	if self:OwnerIsValid() and self:GetStatus() == TFA.Enum.STATUS_IDLE and (SERVER or not sp) then
		if self:GetOwner():KeyPressed(IN_USE) and self:GetOwner():KeyDown(IN_SPEED) then
			self:CycleSafety()
			return
		end

		if self:GetOwner():KeyPressed(IN_RELOAD) and not self:GetOwner():KeyDown(IN_SPEED) and self:GetOwner():KeyDown(IN_USE) then
			self:CycleFireMode()

			return
		end
	end
end

if CLIENT then
	function SWEP:PopulateKeyBindHints(keys)
		keys = {}

		return keys
	end
end

function SWEP:Think2()
	local baseTable = weapons.GetStored("tfa_gun_base")
	baseTable.Think2(self)
end

DEFINE_BASECLASS( SWEP.Base )

--addons/emplacements/lua/weapons/weapon_swrp_grenade_launcher_deployable.lua:
SWEP.Base							= "tfa_gun_base"
SWEP.Category						= "SW:RP (Sonstiges)"
SWEP.Manufacturer 					= ""
SWEP.Author							= "Summe"

SWEP.PrintName						= "Grenade Launcher Cannon"
SWEP.Slot							= 3
SWEP.SlotPos						= 0
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"
SWEP.ShowViewModel = false
SWEP.ShowWorldModel = false

SWEP.ViewModelFOV					= 75
SWEP.ViewModelFlip					= false
SWEP.MaterialTable 					= nil
SWEP.UseHands 						= false
SWEP.HoldType 						= "duel"
SWEP.MoveSpeed 						= 0.5
SWEP.RunSpeed						= 0.7

SWEP.Primary.ClipSize = 1
SWEP.Primary.DefaultClip = 1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.TurretStand = "swrp_turret_stand_grenade_launcher"

SWEP.VElements = {
	["carte"] = {
		type = "Model",
		model = "models/kingpommes/starwars/misc/imp_crate_double_closed.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "",
		pos = Vector(0, 0, -15),
		angle = Angle(0, 190, 0),
		size = Vector(0.8, 0.8, 0.8),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 4,
		bodygroup = {}
	},
}

SWEP.HolsterOffset = Vector(8, 0, 10)
SWEP.HolsterAngle = Angle(0, 0, 0)

SWEP.WElements = {
	["carte"] = {
		type = "Model",
		model = "models/kingpommes/starwars/misc/imp_crate_double_closed.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(-02, 10.5, -10),
		angle = Angle(180, 90, -4),
		size = Vector(0.5, 0.5, 0.5),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 4,
		bodygroup = {}
	}
}

function SWEP:PrimaryAttack()
	local turret = {
		[self.TurretStand] = true,
	}

	local ply = self:GetOwner()
	local trace = ply:GetEyeTrace().Entity

	if IsValid(ply) and ply:IsPlayer() then
		if trace:GetPos():DistToSqr(ply:EyePos()) < 150 * 150 then
			if turret[trace:GetClass()] then
				trace:SetNWBool("Remove?", true)

				if SERVER then
					-- If the player has no ammo left, remove the weapon
					if self:Clip1() <= 1 then
						self:GetOwner():StripWeapon(self:GetClass())
					else
						self:TakePrimaryAmmo(1)
					end
				end
			end
		else
			if SERVER then
				self:SpawnStand()
			end
		end
	end
end

function SWEP:SpawnStand()
	local trace = self:GetOwner():GetEyeTrace()

	if trace.Hit then
		local endpos = trace.HitPos
		local distance = self:GetOwner():GetPos():DistToSqr(endpos)

		if distance <= 40000 then
			local stand = ents.Create(self.TurretStand)

			if IsValid(stand) then
				stand:SetPos(endpos + Vector(0, 0, 8))
				stand:Spawn()
				stand:Activate()
				stand.owner = self:GetOwner()

				if self:Clip1() <= 1 then
					self:GetOwner():StripWeapon(self:GetClass())
				else
					self:TakePrimaryAmmo(1)
				end
			end
		end
	end
end

--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_nn14.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "NN-14"
SWEP.Category               = "SW:RP (Event)"
SWEP.Type					= "Blaster Pistol"
SWEP.Manufacturer 			= "LPA"
SWEP.Slot                   = 1
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"
SWEP.ViewModelFOV					= 75

SWEP.VMPos = Vector(01.96, -8, -02.59)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "pistol"
SWEP.ReloadHoldTypeOverride 		= "pistol"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_scoutblaster_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, -0.3, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["nn14"] = { type = "Model", model = "models/cs574/weapons/nn14.mdl", bone = "v_scoutblaster_reference001", rel = "", pos = Vector(-0.35, -05, -01.2), angle = Angle(0, 90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["nn14"] = { type = "Model", model = "models/cs574/weapons/nn14.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(9.5, 1.4, 0), angle = Angle(0, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.HolsterOffset = Vector(0, 0, -3)
SWEP.HolsterAngle = Angle(0, 180, 0)

SWEP.Animations = { --Override this after SWEP:Initialize, for example, in attachments
	["reload"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY,
		["enabled"] = true
	},
	["reload_empty"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY
	},
	["reload_silenced"] = {
		["type"] = TFA.Enum.ANIMATION_ACT, --Sequence or act
		["value"] = ACT_VM_RELOAD_EMPTY,
		["enabled"] = true
	},
}

-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_red"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 50
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 218

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 2040

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 41

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_purple"
SWEP.Secondary.ScopeZoom 			= 8
SWEP.ScopeReticule_Scale 			= {1,1}
SWEP.IronSightsSensitivity          = 0.8

SWEP.Primary.Spread					= 0.0125
SWEP.Primary.IronAccuracy 			= 0.0042

SWEP.Primary.SpreadMultiplierMax 	= 4
SWEP.Primary.SpreadIncrement 		= 0.3

SWEP.ZoomLevels = {
	2,
	5,
	8
}

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-5.87, -9, 3.55)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(2, -9.5, -15)
SWEP.RunSightsAng = Vector(39, -0.5, -2)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("w/nn14.wav");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("w/pistols.wav");

if surface then
	SWEP.Secondary.ScopeTable = nil --[[
		{
			scopetex = surface.GetTextureID("scope/gdcw_closedsight"),
			reticletex = surface.GetTextureID("scope/gdcw_acogchevron"),
			dottex = surface.GetTextureID("scope/gdcw_acogcross")
		}
	]]--
end

DEFINE_BASECLASS( SWEP.Base )
--addons/emplacements/lua/weapons/weapon_swrp_rail_deployable.lua:
SWEP.Base							= "tfa_gun_base"
SWEP.Category						= "SW:RP (Sonstiges)"
SWEP.Manufacturer 					= ""
SWEP.Author							= "Summe"


SWEP.PrintName						= "Anti Vehicle Cannon"
SWEP.Slot							= 3
SWEP.SlotPos						= 0
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModel						= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"
SWEP.ShowViewModel = false
SWEP.ShowWorldModel = false

SWEP.ViewModelFOV					= 75
SWEP.ViewModelFlip					= false
SWEP.MaterialTable 					= nil
SWEP.UseHands 						= false
SWEP.HoldType 						= "duel"
SWEP.MoveSpeed 						= 0.5
SWEP.RunSpeed						= 0.7

SWEP.Primary.ClipSize = 1
SWEP.Primary.DefaultClip = 1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.TurretStand = "swrp_turret_stand_rail"

SWEP.VElements = {
	["carte"] = {
		type = "Model",
		model = "models/kingpommes/starwars/misc/imp_crate_double_closed.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "",
		pos = Vector(0, 0, -15),
		angle = Angle(0, 190, 0),
		size = Vector(0.8, 0.8, 0.8),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 6,
		bodygroup = {}
	},
}

SWEP.HolsterOffset = Vector(8, 0, 10)
SWEP.HolsterAngle = Angle(0, 0, 0)

SWEP.WElements = {
	["carte"] = {
		type = "Model",
		model = "models/kingpommes/starwars/misc/imp_crate_double_closed.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(-02, 10.5, -10),
		angle = Angle(180, 90, -4),
		size = Vector(0.5, 0.5, 0.5),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 6,
		bodygroup = {}
	}
}

function SWEP:PrimaryAttack()
	local turret = {
		[self.TurretStand] = true,
	}

	local ply = self:GetOwner()
	local trace = ply:GetEyeTrace().Entity

	if IsValid(ply) and ply:IsPlayer() then
		if trace:GetPos():DistToSqr(ply:EyePos()) < 150 * 150 then
			if turret[trace:GetClass()] then
				trace:SetNWBool("Remove?", true)

				if SERVER then
					-- If the player has no ammo left, remove the weapon
					if self:Clip1() <= 1 then
						self:GetOwner():StripWeapon(self:GetClass())
					else
						self:TakePrimaryAmmo(1)
					end
				end
			end
		else
			if SERVER then
				self:SpawnStand()
			end
		end
	end
end

function SWEP:SpawnStand()
	local trace = self:GetOwner():GetEyeTrace()

	if trace.Hit then
		local endpos = trace.HitPos
		local distance = self:GetOwner():GetPos():DistToSqr(endpos)

		if distance <= 40000 then
			local stand = ents.Create(self.TurretStand)

			if IsValid(stand) then
				stand:SetPos(endpos + Vector(0, 0, 8))
				stand:Spawn()
				stand:Activate()
				stand.owner = self:GetOwner()

				if self:Clip1() <= 1 then
					self:GetOwner():StripWeapon(self:GetClass())
				else
					self:TakePrimaryAmmo(1)
				end
			end
		end
	end
end

--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_valken38x.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_3dscoped_base"

SWEP.PrintName              = "Valken-38x"
SWEP.Category               = "SW:RP (Republik)"
SWEP.Type					= "Republic Sniper Rifle"
SWEP.Manufacturer           = "BlasTech Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos = Vector(1.96, 0, -0.52)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(-3, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["valken"] = { type = "Model", model = "models/sw_battlefront/weapons/valken_38x.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0.5, 3, -0.5), angle = Angle(0, -90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["scope"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_dlt19_reference001", rel = "valken", pos = Vector(-1.3, 0, 5.98), angle = Angle(0, 180, 0), size = Vector(0.25, 0.25, 0.25), color = Color(255, 255, 255, 255), surpresslightning = false, material = "!tfa_rtmaterial", skin = 0, bodygroup = {} }
}

SWEP.WElements = {
	["valken"] = { type = "Model", model = "models/sw_battlefront/weapons/valken_38x.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 0.4, -0.5), angle = Angle(-13, 0, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.HolsterOffset = Vector(10, 0, -1)
SWEP.HolsterAngle = Angle(0, 180, 0)

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training" }, order = 1 },
	[2] = { offset = { 0, 0 }, atts = { "swrp_snp_silencer" }, order = 2 },
}

-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"
SWEP.ImpactEffect 					= "rw_sw_impact_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 40
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 10
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 40

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 120

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 12000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 300

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.RTScopeAttachment                = -1
SWEP.Scoped_3D                         = true
SWEP.ScopeReticule                     = "#sw/visor/sw_ret_redux_blue"
SWEP.Secondary.ScopeZoom             = 4
SWEP.ScopeReticule_Scale             = {1.1,1.1}
SWEP.IronSightsSensitivity          = 0.25

SWEP.Primary.Spread					= 0.04
SWEP.Primary.IronAccuracy 			= 0.0

SWEP.Primary.SpreadMultiplierMax 	= 5
SWEP.Primary.SpreadIncrement 		= 1

SWEP.ZoomLevels = {
	2,
	4,
	7,
	15,
	30
}

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-5.09, -7, 1.18)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("w/dc15x.wav")
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("w/heavy.wav")


DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_verpinengewehr.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_3dscoped_base"

SWEP.PrintName              = "Verpinengewehr"
SWEP.Category               = "SW:RP (Event)"
SWEP.Type					= "Sniper Rifle"
SWEP.Manufacturer           = "Verpine Industries"
SWEP.Slot                   = 0
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/weapons/synbf3/w_dlt19.mdl"

SWEP.VMPos = Vector(1.96, 0, -01.52)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "ar2"
SWEP.ReloadHoldTypeOverride 		= "ar2"

SWEP.UseHands 						= true

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(-3, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["scope"] = { type = "Model", model = "models/rtcircle.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0.695, 0.3, 6.15), angle = Angle(0, 90, 0), size = Vector(0.32, 0.32, 0.32), color = Color(255, 255, 255, 255), surpresslightning = false, material = "!tfa_rtmaterial", skin = 0, bodygroup = {} },
	["valken"] = { type = "Model", model = "models/sw_battlefront/weapons/nt242_longblaster.mdl", bone = "v_dlt19_reference001", rel = "", pos = Vector(0.7, 4, 0), angle = Angle(0, -90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {[1] = 1, [2] = 1, [3] = 1} }
}

SWEP.WElements = {
	["valken"] = { type = "Model", model = "models/sw_battlefront/weapons/nt242_longblaster.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(3, 0, -0.5), angle = Angle(-12, 0, 170), size = Vector(1.1, 1.1, 1.1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {[1] = 1, [2] = 1, [3] = 1} }
}

SWEP.HolsterOffset = Vector(8, 0, 0)
SWEP.HolsterAngle = Angle(0, 180, 0)

SWEP.Attachments = {
	[1] = { offset = { 0, 0 }, atts = { "swrp_am_training" }, order = 1 },
	[2] = { offset = { 0, 0 }, atts = { "swrp_snp_silencer" }, order = 2 },
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_purple"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 40
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 40

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Single",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 120

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 12000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 300

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.RTScopeAttachment				= -1
SWEP.Scoped_3D 						= false
SWEP.ScopeReticule 					= "#sw/visor/sw_ret_redux_purple"
SWEP.Secondary.ScopeZoom 			= 4
SWEP.Secondary.ScopeZoom 			= 10
SWEP.ScopeReticule_Scale 			= {1,1}

SWEP.Primary.Spread					= 0.2
SWEP.Primary.IronAccuracy 			= 0

SWEP.Primary.SpreadMultiplierMax 	= 5
SWEP.Primary.SpreadIncrement 		= 1

SWEP.ZoomLevels = {
	2,
	4,
	7,
	15,
	30
}

-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-4.9, -5, 1.5)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Fire Sound
SWEP.Primary.Sound 					= Sound ("w/nt242.wav");
-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("w/heavy.wav");

if surface then
	SWEP.Secondary.ScopeTable = {
		["ScopeMaterial"] =  Material("#sw/visor/sw_ret_redux_purple.png", "smooth"),
		["ScopeBorder"] = color_black,
		["ScopeCrosshair"] = { ["r"] = 0, ["g"]  = 0, ["b"] = 0, ["a"] = 0, ["s"] = 1 }
	}
end

DEFINE_BASECLASS( SWEP.Base )
--addons/egm_tfa_weapons/lua/weapons/weapon_swrp_wrist_flame.lua:
-- Written by Oninoni and Meredin

SWEP.Base                   = "weapon_swrp_egm_base"

SWEP.PrintName              = "Wristblaster Flame"
SWEP.Category               = "SW:RP (Sonstiges)"
SWEP.Type					= "Blaster"
SWEP.Manufacturer           = "various"
SWEP.Slot                   = 1
SWEP.SlotPos                = 0

SWEP.Spawnable = true

-- Model --

SWEP.ViewModel						= "models/weapons/synbf3/c_dlt19.mdl"
SWEP.WorldModel						= "models/bf2017/w_scoutblaster.mdl"

SWEP.VMPos = Vector(0.88, 8, -0.240)
SWEP.VMAng = Vector(0,0,0)

SWEP.HoldType 						= "pistol"
SWEP.ReloadHoldTypeOverride 		= "pistol"

function SWEP:PostDrawViewModel()
	render.SetBlend(1)
end
SWEP.UseHands 						= false

SWEP.ShowWorldModel = false

SWEP.ViewModelBoneMods = {
	["v_dlt19_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
}

SWEP.VElements = {
	["b2"] = { type = "Model", model = "models/cs574/weapons/b2_hand.mdl", bone = "v_scoutblaster_reference001", rel = "", pos = Vector(0, 0, 0), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}

SWEP.WElements = {
	["base"] = { type = "Model", model = "models/cs574/weapons/arc_leftwrist.mdl", bone = "ValveBiped.Bip01_R_Wrist", rel = "", pos = Vector(-0.5, -0.25, 3.1), angle = Angle(0, 0, 175), size = Vector(1.05, 1.05, 1.05), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blaster"] = { type = "Model", model = "models/sw_battlefront/weapons/2019/a280cfe_defaultbarrel.mdl", bone = "ValveBiped.Bip01_R_Wrist", rel = "base", pos = Vector(-17.2, -0.25, 04.15), angle = Angle(-03.5, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
	["blaster2"] = { type = "Model", model = "models/sw_battlefront/weapons/mods/blurrg_cycler_default.mdl", bone = "ValveBiped.Bip01_R_Wrist", rel = "blaster", pos = Vector(15.175, 0.7175, -9.631), angle = Angle(0, 90, -8), size = Vector(1.55, 1.55, 1.55), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} },
}



-- Tracer --

-- Tracer name
SWEP.TracerName 					= "rw_sw_laser_blue"


-- Magazine --

-- Ammo per Magazine
SWEP.Primary.ClipSize				= 20
-- Magazine Count
SWEP.Primary.DefaultClip			= SWEP.Primary.ClipSize * 8
-- Ammo Type
SWEP.Primary.Ammo					= "ar2"
-- Ammo Consumption per shot
SWEP.Primary.AmmoConsumption 		= 1

-- Fire Modes --

-- Actual Fire Modes.
SWEP.FireModes = {
	"Auto",
}

-- Automatic RPM
SWEP.Primary.RPM					= nil
-- Semi Automatic Fire RPM
SWEP.Primary.RPM_Semi				= 340

-- Burst Fire RPM
SWEP.Primary.RPM_Burst				= nil
-- Delay Between Bursts
SWEP.Primary.BurstDelay				= nil

-- Range --

-- Max Range of weapon
SWEP.Primary.Range 					= 1000

-- Shooting --

-- Number of bullets per shot (For Shotguns)
SWEP.Primary.NumShots				= 1
-- Damage per bullet
SWEP.Primary.Damage = 23

-- Aiming --

SWEP.data 							= {}
-- Enable Iron Sights
SWEP.data.ironsights				= 1
-- Iron Sights FOV
SWEP.Secondary.IronFOV				= 75 -- TODO

SWEP.ScopeReticule 					= "scope/gdcw_elcanreticle"
SWEP.Secondary.ScopeZoom 			= 1
SWEP.ScopeReticule_Scale 			= {1.1,1.1}

SWEP.Primary.Spread					= 0.0125
SWEP.Primary.IronAccuracy 			= 0.0042

SWEP.Primary.SpreadMultiplierMax 	= 4
SWEP.Primary.SpreadIncrement 		= 0.3

SWEP.DoProceduralReload = true
SWEP.ProceduralReloadTime = 2.55


-- Holding Positions

-- Aiming
SWEP.IronSightsPos = Vector(-5.5, -5, 1)
SWEP.IronSightsAng = Vector(0, 0, 0)
-- Running
SWEP.RunSightsPos = Vector(5.226, -2, 0)
SWEP.RunSightsAng = Vector(-18, 36, -13.5)
-- Inspecting
SWEP.InspectPos = Vector(8, -4.8, -3)
SWEP.InspectAng = Vector(11.199, 38, 0)

-- Sounds --

-- Reload Sound
SWEP.Primary.ReloadSound 			= Sound ("weapons/bf3/pistols.wav");

DEFINE_BASECLASS( SWEP.Base )
game.AddParticles("particles/waw_flamer.pcf")
PrecacheParticleSystem("flamethrower")

function SWEP:Think2( ... )
	if not IsFirstTimePredicted() then
		return BaseClass.Think2(self,...)
	end
	if not self:VMIV() then return end
	if self.Shooting_Old == nil then
		self.Shooting_Old = false
	end
	local shooting = self:GetStatus() == TFA.GetStatus("shooting")
	if shooting ~= self.Shooting_Old then
		if shooting then
			self:EmitSound("weapons/waw_flamer/fire_in.wav")
			self.NextIdleSound = CurTime() + 0.2
			local fx = EffectData()
			fx:SetEntity(self)
			fx:SetAttachment(1)
			util.Effect("waw_flame",fx)
			if self:IsFirstPerson() then
				ParticleEffectAttach("flamethrower",PATTACH_POINT_FOLLOW,self.OwnerViewModel,1)
			else
				ParticleEffectAttach("flamethrower",PATTACH_POINT_FOLLOW,self,1)
			end
		else
			self:EmitSound("weapons/waw_flamer/fire_end.wav")
			self.NextIdleSound = -1
			self:CleanParticles()
			--self:SendViewModelAnim( ACT_VM_PRIMARYATTACK_EMPTY)
		end
	end
	if shooting then
		if self.NextIdleSound and CurTime() > self.NextIdleSound then
			self:EmitSound("weapons/waw_flamer/fire_loop.wav")
			self.NextIdleSound = CurTime() + SoundDuration( "weapons/waw_flamer/fire_loop.wav" ) - 0.1
		end
	end
	self.Shooting_Old = shooting
	BaseClass.Think2(self,...)
end

function SWEP:ShootEffectsCustom() end
function SWEP:DoImpactEffect() return true end
local range
local bul = {}
local function cb( a, b, c )
	if b.HitPos:Distance( a:GetShootPos() ) > range then return end
	c:SetDamageType(DMG_BURN)
	if IsValid(b.Entity) and b.Entity.Ignite and not b.Entity:IsWorld() then
		b.Entity:Ignite( c:GetDamage(), 16 )
	end
end

function SWEP:ShootBullet()
	bul.Attacker = self.Owner
	bul.Distance = self.Primary.Range
	bul.HullSize = self.Primary.HullSize
	bul.Num = 1
	bul.Damage = self.Primary.Damage
	bul.Distance = self.Primary.Range
	bul.Tracer = 0
	bul.Callback = cb
	bul.Src = self.Owner:GetShootPos()
	bul.Dir = self.Owner:GetAimVector()
	range = bul.Distance
	self.Owner:FireBullets(bul)
end
--lua/weapons/weapon_swsft_base/shared.lua:

if (SERVER) then

	AddCSLuaFile( "shared.lua" )
	SWEP.Weight				= 5
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false

end

if ( CLIENT ) then

	SWEP.DrawAmmo			= true
	SWEP.DrawCrosshair		= false
	SWEP.ViewModelFOV		= 82
	SWEP.ViewModelFlip		= false
	SWEP.CSMuzzleFlashes	= false
	SWEP.BounceWeaponIcon = false

end

SWEP.Author			= "Syntax_Error752"
SWEP.Contact		= ""
SWEP.Purpose		= "To eradicate the disease that is our enemy"
SWEP.Instructions	= ""

--SWEP.Category = "TFA Star Wars"

SWEP.Spawnable			= false
SWEP.AdminSpawnable		= false

SWEP.Primary.Recoil			= 0.5
SWEP.Primary.Damage			= 50
SWEP.Primary.NumShots		= 1
SWEP.Primary.Spread		= 0.0125
SWEP.Primary.Delay = 0.175

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "none"
SWEP.Primary.Tracer = "effect_sw_laser_red"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= "none"






--[[---------------------------------------------------------
---------------------------------------------------------]]
function SWEP:Initialize()

	if ( SERVER ) then
		self:SetNPCMinBurst( 30 )
		self:SetNPCMaxBurst( 30 )
		self:SetNPCFireRate( 0.01 )
	end
	
	self:SetWeaponHoldType( self.HoldType )
	self.Weapon:SetNetworkedBool( "Ironsights", false ) 
end

--[[---------------------------------------------------------
   Think does nothing
---------------------------------------------------------]]
function SWEP:Think()	
end

--[[---------------------------------------------------------
	Checks the objects before any action is taken
	This is to make sure that the entities haven't been removed
-----------------------------------------------------------]]
--function SWEP:DrawWeaponSelection( x, y, wide, tall, alpha )
	
	--draw.SimpleText( self.IconLetter, "DODSelectIcons", x + wide/2, y + tall*0.2, Color( 255, 210, 0, 255 ), TEXT_ALIGN_CENTER )
	
	-- try to fool them into thinking they're playing a Tony Hawks game
	--draw.SimpleText( self.IconLetter, "DODSelectIcons", x + wide/2 + math.Rand(-4, 4), y + tall*0.2+ math.Rand(-14, 14), Color( 255, 210, 0, math.Rand(10, 120) ), TEXT_ALIGN_CENTER )
	--draw.SimpleText( self.IconLetter, "DODSelectIcons", x + wide/2 + math.Rand(-4, 4), y + tall*0.2+ math.Rand(-9, 9), Color( 255, 210, 0, math.Rand(10, 120) ), TEXT_ALIGN_CENTER )
	
--end

local IRONSIGHT_TIME = 0.25

--[[---------------------------------------------------------
   Name: GetViewModelPosition
   Desc: Allows you to re-position the view model
---------------------------------------------------------]]
function SWEP:GetViewModelPosition( pos, ang )

	if ( !self.IronSightsPos ) then return pos, ang end

	local bIron = self.Weapon:GetNetworkedBool( "Ironsights" )
	
	if ( bIron != self.bLastIron ) then
	
		self.bLastIron = bIron 
		self.fIronTime = CurTime()
		
		if ( bIron ) then 
			self.SwayScale 	= 0.3
			self.BobScale 	= 0.1
		else 
			self.SwayScale 	= 1.0
			self.BobScale 	= 1.0
		end
	
	end
	
	local fIronTime = self.fIronTime or 0

	if ( !bIron && fIronTime < CurTime() - IRONSIGHT_TIME ) then 
		return pos, ang 
	end
	
	local Mul = 1.0
	
	if ( fIronTime > CurTime() - IRONSIGHT_TIME ) then
	
		Mul = math.Clamp( (CurTime() - fIronTime) / IRONSIGHT_TIME, 0, 1 )
		
		if (!bIron) then Mul = 1 - Mul end
	
	end

	local Offset	= self.IronSightsPos
	
	if ( self.IronSightsAng ) then
	
		ang = ang * 1
		ang:RotateAroundAxis( ang:Right(), 		self.IronSightsAng.x * Mul )
		ang:RotateAroundAxis( ang:Up(), 		self.IronSightsAng.y * Mul )
		ang:RotateAroundAxis( ang:Forward(), 	self.IronSightsAng.z * Mul )
	
	
	end
	
	local Right 	= ang:Right()
	local Up 		= ang:Up()
	local Forward 	= ang:Forward()
	
	

	pos = pos + Offset.x * Right * Mul
	pos = pos + Offset.y * Forward * Mul
	pos = pos + Offset.z * Up * Mul

	return pos, ang
	
end

--[[---------------------------------------------------------
	SetIronsights
---------------------------------------------------------]]
function SWEP:SetIronsights( b )

	self.Weapon:SetNetworkedBool( "Ironsights", b )

end


SWEP.NextSecondaryAttack = 0
--[[---------------------------------------------------------
	SecondaryAttack
---------------------------------------------------------]]
function SWEP:SecondaryAttack()

	if ( !self.IronSightsPos ) then return end
	if ( self.NextSecondaryAttack > CurTime() ) then return end
	
	bIronsights = !self.Weapon:GetNetworkedBool( "Ironsights", false )
	
	self:SetIronsights( bIronsights )
	
	self.NextSecondaryAttack = CurTime() + 0.3
	
end

/*---------------------------------------------------------
	DrawHUD
	
	Just a rough mock up showing how to draw your own crosshair.
	
---------------------------------------------------------*/

function SWEP:DrawHUD()

	-- No crosshair when ironsights is on
	if ( self.Weapon:GetNetworkedBool( "Ironsights" ) ) then return end

	local x, y

	-- If we're drawing the local player, draw the crosshair where they're aiming,
	-- instead of in the center of the screen.
	if ( self.Owner == LocalPlayer() && self.Owner:ShouldDrawLocalPlayer() ) then

		local tr = util.GetPlayerTrace( self.Owner )
--		tr.mask = ( CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_GRATE|CONTENTS_AUX )
		local trace = util.TraceLine( tr )
		
		local coords = trace.HitPos:ToScreen()
		x, y = coords.x, coords.y

	else
		x, y = ScrW() / 2.0, ScrH() / 2.0
	end
	
	local scale = 10 * self.Primary.Cone
	
	-- Scale the size of the crosshair according to how long ago we fired our weapon
	local LastShootTime = self.Weapon:GetNetworkedFloat( "LastShootTime", 0 )
	scale = scale * (2 - math.Clamp( (CurTime() - LastShootTime) * 5, 0.0, 1.0 ))
	
	surface.SetDrawColor( 255, 0, 0, 255 )
	
	-- Draw an awesome crosshair
	local gap = 40 * scale
	local length = gap + 20 * scale
	surface.DrawLine( x - length, y, x - gap, y )
	surface.DrawLine( x + length, y, x + gap, y )
	surface.DrawLine( x, y - length, x, y - gap )
	surface.DrawLine( x, y + length, x, y + gap )

end


/*---------------------------------------------------------
	onRestore
	Loaded a saved game (or changelevel)
---------------------------------------------------------*/
function SWEP:OnRestore()

	self.NextSecondaryAttack = 0
	self:SetIronsights( false )
	
end

function SWEP:DoImpactEffect( tr, dmgtype )
	if( tr.HitSky ) then return true; end
	
	--util.Decal( "fadingscorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal );
	
	if( game.SinglePlayer() or SERVER or not self:IsCarriedByLocalPlayer() or IsFirstTimePredicted() ) then

		local effect = EffectData();
		effect:SetOrigin( tr.HitPos );
		effect:SetNormal( tr.HitNormal );

		util.Effect( "effect_sw_impact", effect );

		local effect = EffectData();
		effect:SetOrigin( tr.HitPos );
		effect:SetStart( tr.StartPos );
		effect:SetDamageType( dmgtype );

		util.Effect( "RagdollImpact", effect );
	end

    return true;
end

--addons/map_control/lua/entities/alarm/cl_init.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Mapcontrol             --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Mapcontrol | CL           --
---------------------------------------

include("shared.lua")

function ENT:Draw()
	self:DrawModel()

	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 512 * 512 then
		plyAng = self:GetAngles()
		ang = Angle(plyAng.x, plyAng.y, plyAng.z)

		ang:RotateAroundAxis(ang:Forward(), 90)
		ang:RotateAroundAxis(ang:Right(), -90)

		cam.Start3D2D(self:GetPos() + self:GetForward() + self:GetUp() * 26, ang, .08)
			draw.RoundedBox( 5, - 180, - 400, 350, 150, Color( 0, 0, 0, 230 ) )
			draw.RoundedBox( 5, - 180, - 350 + 2, math.Clamp( self:Health() / self:GetMaxHealth() * 350, 0, 350 ), 50 - 2, Color( 66, 135, 245, 230 ) )

			draw.DrawText( "Alarm-Steuerung", "header", -1, - 395, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
			draw.DrawText( "Status:", "BlahBlah2", -90, - 295, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )

			local state, stateColor = self:GetState()
			draw.DrawText(state, "BlahBlah2", -33, -295, stateColor, TEXT_ALIGN_LEFT)
		cam.End3D2D()
	end
end

--addons/bkeypads/lua/entities/bkeycard_pickup/cl_init.lua:
include("shared.lua")

function ENT:StopDrawing()
	if self.m_bDrawing ~= false then
		self.m_bDrawing = false

		self:DrawShadow(false)
		self:DestroyShadow()
	end
end

local GhostColor = Color(255,255,255,150)
function ENT:StartDrawing(ghost)
	if self.m_bDrawing ~= true then
		self.m_bDrawing = true

		self:DrawShadow(true)
		self:CreateShadow()
		self:MarkShadowAsDirty()

		self.m_bDrawGhost = nil
	end

	if ghost ~= nil and self.m_bDrawGhost ~= ghost then
		self:SetRenderMode(RENDERMODE_TRANSCOLOR)
		self:SetColor(ghost and GhostColor or color_white)
	end

	self:DrawModel()
	bKeypads.Keycards.Textures:Draw(bKeypads.Keycards.Textures.BOTH, self, self)
end

function ENT:Draw()
	if (not self:GetInfinite() and self:GetQuantity() == 0) or (self:GetHideToHolders() and bKeypads.Keycards.Inventory:IsHoldingKeycard(LocalPlayer(), self:GetID())) then
		if not self:GetPersist() then
			self:StopDrawing()
		else
			local wep = LocalPlayer():GetActiveWeapon()
			if not IsValid(wep) or wep:GetClass() ~= "gmod_tool" or LocalPlayer():GetTool().Mode ~= "bkeypads_persistence" or not bKeypads.Permissions:Cached(LocalPlayer(), "persistence/manage_persistent_keypads") then
				self:StopDrawing()
			else
				self:StartDrawing(true)
			end
		end
	else
		self:StartDrawing(false)
	end
end

function ENT:DrawTranslucent(flags)
	self:Draw(flags)
end

local function LevelPaint(self, w, h)
	surface.SetDrawColor(self.LevelColor)
	local x = self.CheckBox:GetWide() + 5
	surface.DrawRect(x, 0, w - x, h)
end

local function CategoryBackgroundPaint(self, w, h)
	DPanel.Paint(self, w, h)
	DCollapsibleCategory.Paint(self, w, h)
end
local function CategoryBackground(self)
	self.m_bBackground = true
	self.Paint = CategoryBackgroundPaint
	return self
end

local function LevelMousePressed(self, m)
	if m == MOUSE_LEFT then self._m = true end
end
local function LevelMouseReleased(self, m)
	if m == MOUSE_LEFT then
		self._m = nil
		self.CheckBox:Toggle()

		self.SelectedLevels[self.Level] = self.CheckBox:GetChecked() or nil

		surface.PlaySound(self.CheckBox:GetChecked() and "garrysmod/ui_click.wav" or "garrysmod/ui_hover.wav")
	end
end

net.Receive("bKeypads.KeycardPickup.Spawn", function()
	local L = bKeypads.L

	local SpawnWindow = vgui.Create("DFrame")
	SpawnWindow:SetSize(400, 500)
	SpawnWindow:SetIcon("icon16/vcard.png")
	SpawnWindow:SetTitle(L"SpawnDroppedKeycard")
	SpawnWindow:SetSizable(true)
	SpawnWindow:MakePopup()
	SpawnWindow:Center()

	SpawnWindow:SetPos((ScrW() - SpawnWindow:GetWide()) / 2, ScrH())
	local y = (ScrH() + SpawnWindow:GetTall()) / 2
	SpawnWindow:NewAnimation(1, 0, .5).Think = function(_, pnl, f)
		local f = bKeypads.ease.OutBack(f)

		local x = pnl:GetPos()
		pnl:SetPos(x, ScrH() - (y * f))

		pnl:SetAlpha(f * 255)
	end

	local Tabs = vgui.Create("DPropertySheet", SpawnWindow)
	Tabs:Dock(FILL)
		
		local GeneralTab = vgui.Create("DScrollPanel", Tabs)
		GeneralTab.Paint = nil

			local BehaviourCategory = CategoryBackground(vgui.Create("DForm", GeneralTab))
			BehaviourCategory:Dock(TOP)
			BehaviourCategory:SetExpanded(true)
			BehaviourCategory:SetLabel(L"Behaviour")
			BehaviourCategory:DockMargin(0, 0, 0, 10)

				local TouchToPickup = BehaviourCategory:CheckBox(L"DroppedKeycardTouchToPickup")
				local TouchToPickupTip = BehaviourCategory:Help(L"DroppedKeycardTouchToPickupTip")
				TouchToPickupTip:GetParent():DockPadding(5, 10, 5, 10)

				local Physics = BehaviourCategory:CheckBox(L"DroppedKeycardPhysics")
				local PhysicsTip = BehaviourCategory:Help(L"DroppedKeycardPhysicsTip")
				PhysicsTip:GetParent():DockPadding(5, 10, 5, 10)

				local HideToHolders = BehaviourCategory:CheckBox(L"DroppedKeycardHideToHolders")
				HideToHolders:SetChecked(true)
				local HideToHoldersTip = BehaviourCategory:Help(L"DroppedKeycardHideToHoldersTip")
				HideToHoldersTip:GetParent():DockPadding(5, 10, 5, 10)

			local LevelCategory = CategoryBackground(vgui.Create("DForm", GeneralTab))
			LevelCategory:Dock(TOP)
			LevelCategory:SetExpanded(true)
			LevelCategory:SetLabel(L"DroppedKeycardLevel")
			LevelCategory:DockMargin(0, 0, 0, 10)

				local SelectedLevels = {}
				for level, data in pairs(bKeypads.Keycards.Levels) do
					local Level = vgui.Create("DPanel", LevelCategory)
					Level:SetTall(20)
					Level:SetMouseInputEnabled(true)
					Level:SetCursor("hand")
					Level.Paint = LevelPaint
					Level.OnMousePressed = LevelMousePressed
					Level.OnMouseReleased = LevelMouseReleased
					Level.Level = level
					Level.LevelColor = data.Color
					Level.SelectedLevels = SelectedLevels

						local CheckBox = vgui.Create("DCheckBox", Level)
						Level.CheckBox = CheckBox
						CheckBox:SetMouseInputEnabled(false)
						CheckBox:SetPos(0, (Level:GetTall() - CheckBox:GetTall()) / 2)

						local Label = vgui.Create("DLabel", Level)
						Label:DockMargin(CheckBox:GetWide() + 5 + 5, 1, 0, 0)
						Label:Dock(FILL)
						Label:SetText(data.Name or (L"KeycardLevel"):format(level))
						Label:SetFont(bKeypads:DarkenForeground(data.Color) and "bKeypads.LevelSelect" or "bKeypads.LevelSelect.Shadow")
						Label:SetTextColor(bKeypads:DarkenForeground(data.Color) and bKeypads.COLOR.BLACK or bKeypads.COLOR.WHITE)
						Label:SetContentAlignment(4)
						Label:SetMouseInputEnabled(false)

					LevelCategory:AddItem(Level)
					Level:GetParent():DockPadding(5, 5, 5, next(bKeypads.Keycards.Levels, level) == nil and 5 or 0)
				end
			
			local QuantityCategory = CategoryBackground(vgui.Create("DForm", GeneralTab))
			QuantityCategory:Dock(TOP)
			QuantityCategory:DockMargin(0, 0, 0, 10)
			QuantityCategory:SetExpanded(true)
			QuantityCategory:SetLabel(L"DroppedKeycardQuantity")

				local Infinite = QuantityCategory:CheckBox(L"DroppedKeycardQuantityInfinite")
				Infinite:SetChecked(true)

				local Quantity = QuantityCategory:NumberWang(L"DroppedKeycardQuantity", nil, 1, 100, 0)
				local p1, p2, p3, p4 = Quantity:GetParent():GetDockPadding()
				Quantity:Dock(TOP)
				Quantity:GetParent():DockPadding(p1, p2, p3, p4 + 10)
				Quantity.Think = function(self)
					self:SetDisabled(Infinite:GetChecked())
					self:SetMouseInputEnabled(not self:GetDisabled())
				end
		
		local Persistent
		if bKeypads.Permissions:Check(LocalPlayer(), "persistence/manage_persistent_keycards") then
			local PersistenceCategory = CategoryBackground(vgui.Create("DForm", GeneralTab))
			PersistenceCategory:Dock(TOP)
			PersistenceCategory:SetExpanded(true)
			PersistenceCategory:SetLabel(L"Persistence")

				Persistent = PersistenceCategory:CheckBox(L"Persistent")

				local PersistenceTip = PersistenceCategory:Help(L"DroppedKeycardPersistenceTip")
				PersistenceTip:GetParent():DockPadding(5, 10, 5, 10)
		end
			
		local PlayerModelTab = vgui.Create("DPanel", Tabs)
		PlayerModelTab.Paint = nil

			local CustomInput = vgui.Create("DTextEntry", PlayerModelTab)
			CustomInput:Dock(TOP)
			CustomInput:SetTall(24)
			CustomInput:DockMargin(0, 0, 0, 10)
			CustomInput:SetText("models/player/kleiner.mdl")

			local PanelSelect = PlayerModelTab:Add("DPanelSelect")
			PanelSelect:Dock(FILL)

			for name, model in SortedPairs(player_manager.AllValidModels()) do
				local icon = vgui.Create("SpawnIcon")
				icon:SetModel(model)
				icon:SetSize(64, 64)
				icon.bKeypads_Tooltip = name
				icon.model_path = model

				PanelSelect:AddPanel(icon)

				if model == "models/player/kleiner.mdl" then
					PanelSelect:SelectPanel(icon)
				end
			end

			PanelSelect.OnActivePanelChanged = function(self, _, pnl)
				CustomInput:SetText(pnl.model_path)
				surface.PlaySound("garrysmod/ui_click.wav")
			end

	Tabs:AddSheet(L"General", GeneralTab, "icon16/pencil.png")
	Tabs:AddSheet(L"DroppedKeycardPlayerModel", PlayerModelTab, "icon16/user_suit.png")

	local SpawnBtn = vgui.Create("DButton", SpawnWindow)
	SpawnBtn:Dock(BOTTOM)
	SpawnBtn:DockMargin(0, 5, 0, 0)
	SpawnBtn:SetTall(25)
	SpawnBtn:SetDisabled(true)
	SpawnBtn:SetText(L"Spawn")
	SpawnBtn:SetIcon("icon16/world.png")
	SpawnBtn.Think = function(self)
		self:SetDisabled(#CustomInput:GetValue() == 0 or not CustomInput:GetValue():lower():match("^models/.-%.mdl$") or table.IsEmpty(SelectedLevels))
	end
	SpawnBtn.DoClick = function()
		surface.PlaySound("garrysmod/save_load" .. math.random(1,4) .. ".wav")

		net.Start("bKeypads.KeycardPickup.Spawn")
			net.WriteBool(Persistent and Persistent:GetChecked() or false)
			net.WriteBool(TouchToPickup:GetChecked())
			net.WriteBool(Physics:GetChecked())
			net.WriteBool(HideToHolders:GetChecked())
			net.WriteUInt(Infinite:GetChecked() and 0 or Quantity:GetValue(), 32)
			net.WriteString(CustomInput:GetValue())
			net.WriteUInt(table.Count(SelectedLevels), 32)
			for level in pairs(SelectedLevels) do net.WriteUInt(level, 32) end
		net.SendToServer()

		SpawnWindow:Close()
	end
end)
--addons/bkeypads/lua/entities/bkeycard_pickup/shared.lua:
ENT.Type = "anim"
ENT.Base = "bkeypads_networkvarpostnotify"

ENT.PrintName = "#bKeypads_DroppedKeycard"
ENT.Category = "Billy's Keypads"
ENT.Author = "Billy"

ENT.Spawnable = true
ENT.AdminOnly = true

ENT.Editable = true

function ENT:Initialize()
	self.bKeycard = true
	self:SetModel(bKeypads.MODEL.KEYCARD)

	if SERVER then
		self:PhysicsInit(MOVETYPE_VPHYSICS)
		local phys = self:GetPhysicsObject()
		if IsValid(phys) then
			phys:Wake()
		end

		self:SetUseType(SIMPLE_USE)

		bKeypads.Keycards:AssignID(self)

		self:PhysicsEnabledSet("PhysicsEnabled", nil, self:GetPhysicsEnabled())
		self:TouchToPickupSet("TouchToPickup", nil, self:GetTouchToPickup())
	end

	self:IDAssigned("ID", nil, self:GetID())
	self:LevelsStrSet("LevelsStr", nil, self:GetLevelsStr())
	self:UpdateKeycardData()
end

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "ID")
	self:NetworkVar("Int", 1, "Quantity", { KeyName = "Quantity" })
	self:NetworkVar("Int", 2, "Team", { KeyName = "Team" })

	self:NetworkVar("String", 0, "LevelsStr", { KeyName = "Levels" })
	self:NetworkVar("String", 1, "PlayerModel", { KeyName = "PlayerModel" })
	self:NetworkVar("String", 2, "SteamID", { KeyName = "SteamID" })
	self:NetworkVar("String", 3, "PlayerKeycardDataBind")

	self:NetworkVar("Bool", 0, "IsChildKeycard")
	self:NetworkVar("Bool", 1, "Persist")
	self:NetworkVar("Bool", 1, "Infinite", { KeyName = "Infinite" })
	self:NetworkVar("Bool", 2, "HideToHolders", { KeyName = "HideToHolders" })
	self:NetworkVar("Bool", 3, "PhysicsEnabled", { KeyName = "PhysicsEnabled" })
	self:NetworkVar("Bool", 4, "TouchToPickup", { KeyName = "TouchToPickup" })

	self:NetworkVarPostNotify("ID", self.IDAssigned)
	self:NetworkVarPostNotify("IsChildKeycard", self.IDAssigned)
	self:NetworkVarPostNotify("LevelsStr", self.LevelsStrSet)

	self:NetworkVarPostNotify("SteamID", self.UpdateKeycardData)
	self:NetworkVarPostNotify("PlayerModel", self.UpdateKeycardData)
	self:NetworkVarPostNotify("Team", self.UpdateKeycardData)
	self:NetworkVarPostNotify("PlayerKeycardDataBind", self.UpdateKeycardData)
	
	if SERVER then
		self:NetworkVarPostNotify("PhysicsEnabled", self.PhysicsEnabledSet)
		self:NetworkVarPostNotify("TouchToPickup", self.TouchToPickupSet)
	end
end

function ENT:IDAssigned(_, __, newVal)
	if newVal == 0 then return end
	self:UpdateKeycardData()
end

function ENT:LevelsStrSet(_, __, levels)
	if self:GetID() == 0 then return end

	if not self:GetIsChildKeycard() then
		bKeypads_Keycards_Registry[self:GetID()] = nil
	end
	self:UpdateKeycardData()
end

function ENT:BuildKeycardDataTable()
	return {
		Keycard = self,
		Levels = {},
		LevelsDict = {},
		PrimaryLevel = 1,
		SteamID = self:GetSteamID() ~= "" and self:GetSteamID() or nil,
		PlayerModel = self:GetPlayerModel() ~= "" and self:GetPlayerModel() or nil,
		Team = self:GetTeam() ~= 0 and self:GetTeam() or nil,
		PlayerBind = self:GetPlayerKeycardDataBind() ~= "" and self:GetPlayerKeycardDataBind() or nil
	}
end

function ENT:UpdateKeycardData()
	self:UpdateHash()

	local id = self:GetID()
	if id == 0 then return end

	local keycardData
	if self:GetIsChildKeycard() then
		keycardData = bKeypads.Keycards:GetByID(id)
	else
		keycardData = bKeypads.Keycards:GetByID(id) or self:BuildKeycardDataTable()

		keycardData.Keycard = self
		keycardData.SteamID = self:GetSteamID() ~= "" and self:GetSteamID() or nil
		keycardData.PlayerModel = self:GetPlayerModel() ~= "" and self:GetPlayerModel() or nil
		keycardData.Team = self:GetTeam() ~= 0 and self:GetTeam() or nil
		keycardData.PlayerBind = self:GetPlayerKeycardDataBind() ~= "" and self:GetPlayerKeycardDataBind() or nil

		keycardData.Levels = {}
		for _, level in ipairs(string.Explode(",", self:GetLevelsStr())) do
			local level = tonumber(level)
			if not level then continue end

			table.insert(keycardData.Levels, level)
			keycardData.LevelsDict[level] = true
			keycardData.PrimaryLevel = math.max(keycardData.PrimaryLevel, level)
		end

		table.sort(keycardData.Levels)

		bKeypads_Keycards_Registry[id] = keycardData
	end

	return keycardData
end

function ENT:GetKeycardData()
	if self:GetID() ~= 0 then
		local keycardData = bKeypads.Keycards:GetByID(self:GetID())
		if keycardData then
			return keycardData
		elseif not self:GetIsChildKeycard() then
			return self:UpdateKeycardData()
		end
	end

	return self:BuildKeycardDataTable()
end

function ENT:GetLevels()
	return self:GetKeycardData().Levels
end

function ENT:GetLevelsDictionary()
	return self:GetKeycardData().LevelsDict
end

function ENT:GetPrimaryLevel()
	return self:GetKeycardData().PrimaryLevel
end

function ENT:GetKeycardMetadata()
	return bKeypads.Keycards.Levels[self:GetPrimaryLevel()] or {}
end

function ENT:GetKeycardColor()
	return self.KeycardColor or self:GetKeycardMetadata().Color or bKeypads.COLOR.RED
end

function ENT:GetKeycardName()
	return self:GetKeycardMetadata().Name or bKeypads.L("KeycardLevel"):format(tonumber(primaryLevel) or 1)
end

function ENT:UpdateHash()
	local levelsSorted = {}
	for _, level in ipairs(string.Explode(",", self:GetLevelsStr())) do
		local level = tonumber(level)
		if level then
			table.insert(levelsSorted, level)
		end
	end
	table.sort(levelsSorted)

	self.m_Hash = util.CRC(self:GetSteamID() .. self:GetPlayerModel() .. table.concat(levelsSorted, ",") .. self:GetTeam())

	return self.m_Hash
end

function ENT:GetHash()
	return self.m_Hash or self:UpdateHash()
end

--[[ FIXME https://github.com/Facepunch/garrysmod-issues/issues/642

function ENT:SetCollisionRule(ply, shouldCollide)
	--[[if self:GetID() == 0 or not IsValid(ply) then return end

	self:CollisionRulesChanged()
	ply:CollisionRulesChanged()

	self.m_CollisionRules = self.m_CollisionRules or {}
	self.m_CollisionRules[ply] = (not shouldCollide) or nil

	self:CollisionRulesChanged()
	ply:CollisionRulesChanged()

	self:SetCustomCollisionCheck(true)
end
hook.Add("ShouldCollide", "bKeypads.Keycards.ShouldCollide", function(ent1, ent2)
	
	local ply, keycard

	if ent1:GetClass() == "bkeycard_pickup" then
		keycard = ent1
		if keycard:GetID() == 0 then return end
		if ent2:IsPlayer() then
			ply = ent2
		else
			return
		end
	elseif ent2:GetClass() == "bkeycard_pickup" then
		keycard = ent2
		if keycard:GetID() == 0 then return end
		if ent1:IsPlayer() then
			ply = ent1
		else
			return
		end
	else
		return
	end
	
	if keycard.m_CollisionRules[ply] then
		return false
	end
end)
]]

bKeypads_Initialize_Fix(ENT)
--addons/bkeypads/lua/entities/bkeypads_link/shared.lua:
AddCSLuaFile()

ENT.Type = "point"
ENT.Base = "bkeypads_networkvarpostnotify"

ENT.PrintName = "Link (Billy's Keypads)"
ENT.Author = "Billy"

ENT.Spawnable = false

ENT.RenderGroup = RENDERGROUP_OTHER

function ENT:Initialize()
	self:SetTransmitWithParent(true)

	self:DrawShadow(false)
	self:SetRenderMode(RENDERMODE_NONE)
	self:SetMoveType(MOVETYPE_NONE)
	self:SetSolid(SOLID_NONE)

	self:RegisterLink()

	if CLIENT then self:LinkChanged() end
end

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "LinkedEnt")
	self:NetworkVar("Entity", 1, "Keypad")

	self:NetworkVar("Bool", 0, "AccessType")

	if CLIENT then
		self:NetworkVarPostNotify("LinkedEnt", self.LinkChanged)
		self:NetworkVarPostNotify("Keypad", self.LinkChanged)
		self:NetworkVarPostNotify("AccessType", self.LinkChanged)
	else
		self:NetworkVarPostNotify("Keypad", self.KeypadChanged)
	end
end

if CLIENT then
	function ENT:LinkChanged(name, old, new)
		self:LinkUpdated()
	end
	function ENT:OnRemove()
		self:LinkUpdated()
	end
else
	function ENT:OnRemove()
		self:DeregisterLink()
	end

	function ENT:KeypadChanged(_, old, new)
		if IsValid(old) then
			old:DontDeleteOnRemove(self)
		end
		if IsValid(new) then
			new:DeleteOnRemove(self)
			self:SetParent(new)
		end
	end
end
--addons/ballistic_shields/lua/entities/bs_dshield/cl_init.lua:
include("shared.lua")
include("ballistic_shields/cl_bs_util.lua")

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Draw()
	self:DrawModel()
end   
--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--addons/ballistic_shields/lua/entities/bs_hshield_dooms/cl_init.lua:
include("shared.lua")
include("ballistic_shields/cl_bs_util.lua")

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Draw()
	self:DrawModel()
end   
--addons/ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )

net.Receive( "bs_shield_info", function( len, pl )
	LocalPlayer().bs_shieldIndex = net.ReadUInt(16)
end )

local Delay = 0
function bshields_materials_reload()
	for _,v in pairs(bshields.materialstoload) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL(v[1], v[2], v[3]) end )
	end

	bshields.hshield_webmat = surface.GetURL(bshields.config.hShieldTexture, 256, 256)
	bshields.rshield_webmat = surface.GetURL(bshields.config.rShieldTexture, 256, 256)
	bshields.dshield_webmat = surface.GetURL(bshields.config.dShieldTexture, 256, 256)
end

bshields.materialstoload = {
	{bshields.config.hShieldTexture, 256, 256},
	{bshields.config.rShieldTexture, 256, 256},
	{bshields.config.dShieldTexture, 256, 256}
}

hook.Add( "InitPostEntity", "bshields_init_client", function()
	bshields_materials_reload()
end)

surface.CreateFont( "bshields.HudFont", {
	font = "BFHud",
	size = ScrH() / 1080 * 18
})
--addons/ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.4 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English
bshields.config.language = "German"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 16
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 25
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 25
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 0
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- RIOT SHIELD
bshields.config.rShieldTexture = "https://i.imgur.com/afyGHiK.png"
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "https://i.imgur.com/afyGHiK.png" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = true
--addons/ballistic_shields/lua/entities/bs_shield_dooms/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Deployed shield"
ENT.Category = "Ballistic shields"

ENT.Spawnable = false
ENT.DisableDuplicator = true

function ENT:Use(activator)
	if IsValid(activator) && activator:IsPlayer() && self.Owner == activator then
		activator:Give("deployable_shield_dooms")
		activator:EmitSound("npc/combine_soldier/gear2.wav")

		table.RemoveByValue(activator.bs_shields, self)

		self:Remove()
	end
end
--addons/ballistic_shields/lua/entities/bs_shield_senat/cl_init.lua:
include("shared.lua")
include("ballistic_shields/cl_bs_util.lua")

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Draw()
	self:DrawModel()
end  
--addons/ballistic_shields/lua/entities/bs_shield_senat/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Deployed shield"
ENT.Category = "Ballistic shields"

ENT.Spawnable = false
ENT.DisableDuplicator = true

function ENT:Use(activator)
	if IsValid(activator) && activator:IsPlayer() && self.Owner == activator then
		activator:Give("deployable_shield_senat")
		activator:EmitSound("npc/combine_soldier/gear2.wav")

		table.RemoveByValue(activator.bs_shields, self)

		self:Remove()
	end
end
--addons/ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		},
		[2] = {
			["angles"] = Angle(6,1,-15),
			["position"] = Vector(6,10,-5)
		},
		[3] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(5,10,-5)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(1,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--lua/entities/chemlight_gib2/cl_init.lua:
include("shared.lua")

function ENT:Initialize()

end

function ENT:Draw()
	self.Entity:DrawModel()
end


function ENT:Think()
	end
--lua/entities/chemlight_gib2/shared.lua:
ENT.Type			= "anim"  
ENT.Base			= "base_gmodentity"  
ENT.PrintName		= "Chemlight Gib2"
ENT.Author			= "Patrick Hunt"
ENT.Information		= ""
ENT.Category		= "Fun + Games"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false


--addons/star_wars_detpack/lua/entities/cod-c4/shared.lua:
ENT.Type 			= "anim"
ENT.Base 			= "base_gmodentity"
ENT.PrintName			= "C4"
ENT.Author			= "Hoff"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false
ENT.Detonator 			= true

--addons/system_entities/lua/entities/commsarray/cl_init.lua:
include( "shared.lua" )

surface.CreateFont( "BlahBlah2", {
	font = "Arial",
	extended = false,
	size = 35,
	weight = 100,
	shadow = true,
	outline = false
} )

surface.CreateFont( "header", {
	font = "Arial",
	extended = false,
	size = 35,
	weight = 1000,
	shadow = true,
	outline = false
} )

function ENT:Draw()
	self:DrawModel()

	--[[local p = self:GetPos()

	local ang = self:GetAngles()
	ang:RotateAroundAxis( ang:Forward(), 90 )
	ang:RotateAroundAxis( ang:Up(), 90 )
	ang.y = LocalPlayer():EyeAngles().y - 90]]--
	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 512 * 512 then
		
		plyAng = self:GetAngles()
		ang = Angle(plyAng.x, plyAng.y, plyAng.z)

		ang:RotateAroundAxis(ang:Forward(), 90)
		ang:RotateAroundAxis(ang:Right(), -90)

		cam.Start3D2D(self:GetPos() + self:GetForward() + self:GetUp() * 26, ang, .08)
			draw.RoundedBox( 5, - 180, - 400, 350, 150, Color( 0, 0, 0, 230 ) )
			draw.RoundedBox( 5, - 180, - 350 + 2, math.Clamp( self:Health() / self:GetMaxHealth() * 350, 0, 350 ), 50 - 2, Color( 66, 135, 245, 230 ) )
			--draw.DrawText( self:Health(), "BlahBlah2", 5, - 740, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
			draw.DrawText( "Kommunikationsmodul", "header", -1, - 395, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
			draw.DrawText( "Status:", "BlahBlah2", -70, - 295, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )

			if self:Health() > self.CommHealth / 2 then
				draw.DrawText( "online", "BlahBlah2", 39, - 295, Color( 0, 255, 77, 255 ), TEXT_ALIGN_CENTER )
			end

			if (self:Health() <= self.CommHealth / 2 && self:Health() > 0) then
				draw.DrawText( "kritisch", "BlahBlah2", 42, - 295, Color( 252, 144, 3 ), TEXT_ALIGN_CENTER )
			end

			if self:Health() == 0 then
				draw.DrawText( "offline", "BlahBlah2", 39, - 295, Color( 255, 0, 0, 255 ), TEXT_ALIGN_CENTER )
			end

		cam.End3D2D()
	end
end

--addons/system_entities/lua/entities/commsarray/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.Author = "Tood."

ENT.Spawnable = true
ENT.AdminOnly = false

ENT.PrintName = "Kommunikationsmodul"
ENT.Category = "CW:RP Systementites"

ENT.CommHealth = 2000
ENT.IsSystem = true

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "PlayerRepairing" )
end

if CLIENT then
	net.Receive("array_destroyed", function(len, ply)
		--surface.PlaySound("summe/warning.wav")
		surface.PlaySound("summe/warn_beep.wav")
		AlertEnable = true
	end)
end

--lua/entities/d_sidious_chair.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "base_anim"
ENT.Type = "vehicle"

ENT.PrintName = "Darth Sidious Chair"
ENT.Author = "Syphadias, Liam0102s Help"
ENT.Category = "Star Wars Vehicles: Chairs"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;
ENT.EntModel = "models/starwars/syphadias/props/d_sidious_chair/d_sidious_chair.mdl";

list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then



AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("d_sidious_chair");
	e:SetPos(tr.HitPos + Vector(0,0,20));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()

	self:SetModel(self.EntModel);
	self:PhysicsInit(SOLID_VPHYSICS);
	self:SetMoveType(MOVETYPE_VPHYSICS);
	self:SetSolid(SOLID_VPHYSICS);
	self:StartMotionController();
	self:SetUseType(SIMPLE_USE);
	self:SetRenderMode(RENDERMODE_TRANSALPHA);

	self:SecretChair(self:GetPos()+self:GetUp()*16+self:GetForward()*1,self:GetAngles()+Angle(0,-90,8)); // Will most likely require tinkering for position
	
	local phys = self:GetPhysicsObject()

	if(phys:IsValid()) then
		phys:Wake()
		phys:SetMass(100000)
	end
end

function ENT:SecretChair(pos,ang)

	local e = ents.Create("prop_vehicle_prisoner_pod");
	e:SetPos(pos);
	e:SetAngles(ang);
	e:SetParent(self);
	e:SetModel("models/nova/airboat_seat.mdl");
	e:SetRenderMode(RENDERMODE_TRANSALPHA);
	e:SetColor(Color(255,255,255,0));
	e:Spawn();
	e:Activate();
	e.IsSyphSeat = true;
	self.Chair = e;
end

hook.Add("PlayerEnteredVehicle","SyphSeatEnter", function(p,v)
	if(IsValid(p) and IsValid(v)) then
		if(v.IsSyphSeat) then
			p:SetNWEntity("SyphSeat",v)
		end
	end
end)

hook.Add("PlayerLeaveVehicle","SyphSeatExit", function(p,v)
	if(IsValid(p) and IsValid(v)) then
		if(v.IsSyphSeat) then
			p:SetNWEntity("SyphSeat",NULL)
		end
		p:SetPos(v:GetPos()+v:GetUp()*10+v:GetForward()*52)
		p:SetEyeAngles(Angle(0,v:GetAngles().y+90,0))
	end
end)

function ENT:Use(p)
	
	if(!IsValid(self.Chair)) then return end;
	p:EnterVehicle(self.Chair);

end

end

if CLIENT then
	
	function ENT:Draw() self:DrawModel() end
	
	local View = {}
	hook.Add("CalcView", "SyphSeatView", function()

		local p = LocalPlayer();
		local Seat = p:GetNWEntity("SyphSeat",NULL);

		if(IsValid(Seat)) then
			if(Seat:GetThirdPersonMode()) then
				local pos = Seat:GetPos()+LocalPlayer():GetAimVector():GetNormal()*-100+Seat:GetUp()*175;
				local face = ((Seat:GetPos() + Vector(0,0,100))- pos):Angle();
					View.origin = pos;
					View.angles = face;
				return View;
			end
		end
	end)
	
	hook.Add( "ShouldDrawLocalPlayer", "SyphSeatPlayerDraw", function( p )
		local Seat = p:GetNWEntity("SyphSeat",NULL);
		if(IsValid(Seat)) then
			if(Seat:GetThirdPersonMode()) then
				return true;
			end
		end
	end);
end
--lua/entities/dc17m_at_rocket2/shared.lua:
 ENT.Type 			= "anim"  
 ENT.PrintName			= "High Explosive Anti-Tank RPG"  
 ENT.Author			= "Generic Default"  
 ENT.Contact			= "AIDS"  
 ENT.Purpose			= "SPLODE"  
 ENT.Instructions			= "LAUNCH"  
 
ENT.Spawnable			= false
ENT.AdminSpawnable		= false


--lua/entities/e60r_rocket2/cl_init.lua:
 include('shared.lua')     
 //[[---------------------------------------------------------     
 //Name: Draw     Purpose: Draw the model in-game.     
 //Remember, the things you render first will be underneath!  
 //-------------------------------------------------------]]  
 function ENT:Draw()      
 // self.BaseClass.Draw(self)  
 -- We want to override rendering, so don't call baseclass.                                   
 // Use this when you need to add to the rendering.        
 self.Entity:DrawModel()       // Draw the model.   
 end
 
   function ENT:Initialize()
	pos = self:GetPos()
	self.emitter = ParticleEmitter( pos )
 end
 
 function ENT:Think()
	
	pos = self:GetPos()
		for i=0, (10) do
			local particle = self.emitter:Add( "particle/smokesprites_000"..math.random(1,9), pos + (self:GetForward() * -100 * i))
			if (particle) then
				particle:SetVelocity((self:GetForward() * -2000) )
				particle:SetDieTime( math.Rand( 1.5, 3 ) )
				particle:SetStartAlpha( math.Rand( 5, 8 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand( 40, 50 ) )
				particle:SetEndSize( math.Rand( 130, 150 ) )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-1, 1) )
				particle:SetColor( 200 , 200 , 200 ) 
 				particle:SetAirResistance( 200 ) 
 				particle:SetGravity( Vector( 100, 0, 0 ) ) 	
			end
		
		end
end

--lua/entities/elevator/shared.lua:
if (SERVER) then
	AddCSLuaFile();
end;

DEFINE_BASECLASS("base_entity");

ENT.PrintName		= "Elevator";
ENT.Category		= "Elevators";
ENT.Spawnable		= false;
ENT.AdminOnly		= true;
ENT.Model			= Model("models/hunter/plates/plate2x2.mdl");
ENT.RenderGroup 	= RENDERGROUP_BOTH;

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "Door");
end;

if (SERVER) then

	function ENT:SpawnFunction(player, trace, class)
		if (!trace.Hit) then return; end;
		local entity = ents.Create(class);

		entity:SetPos(trace.HitPos + trace.HitNormal * 1.5);
		entity:Spawn();

		return entity;
	end;

	function ENT:Initialize()
		self.door = ents.Create("func_movelinear");
		self.door:SetPos(self:GetPos());
		self.door:SetAngles(self:GetAngles());
		self.door:SetModel(self.Model);
		self.door:Spawn();
		self.door:SetMoveType(MOVETYPE_PUSH);
		self.door:SetNoDraw(true);
		self.door.parent = self;
		self.door:SetName("zelevator_" .. self:EntIndex());

		self:SetName("zelevator_parent_" .. self:EntIndex());

		self.door:SetKeyValue("OnFullyOpen", self:GetName() .. ",Shake");
		self.door:SetKeyValue("OnFullyClosed", self:GetName() .. ",Shake");

		self:SetDoor(self.door);

		self.door.child = ents.Create("prop_dynamic");
		self.door.child:SetModel(self.Model);
		self.door.child:Spawn();
		self.door.child:SetParent(self.door);
		self.door.child:SetLocalPos(vector_origin);
		self.door.child:SetLocalAngles(angle_zero);
		self.door.child:SetNotSolid(true);
		self.door.child:SetRenderMode(1);

		self:SetParent(door);
		self:SetNotSolid(true);
		self:SetNoDraw(true);
		self:SetColor(Color(0, 0, 0, 0));
	end;

	function ENT:AcceptInput(name, act, caller, data)
		if (name == "Shake" and self.door.shake) then
			local info = self.door.movespeed / 120;
			util.ScreenShake(self.door:GetPos(), info, info, 0.5, self.door.movespeed * 3.5);
		end;
	end;

	function ENT:Think()
		if (IsValid(self.door.child)) then
			self.door.child:SetColor(self.door:GetColor());
			self.door.child:SetMaterial(self.door:GetMaterial());
		end;

		if (IsValid(self.door)) then
			self.door:SetNoDraw(true);
		end;
	end;

	function ENT:Use(activator, caller, type, value)

	end;

	function ENT:OnRemove()
		if (IsValid(self.door)) then
			self.door:StopSound(self.door.movesound or "");
		end;

		SafeRemoveEntity(self.door);
	end;

	function ENT:SetStart(pos)
		if (IsValid(self.door)) then
			self.door:SetSaveValue("m_vecPosition1", tostring(pos));
			self.door.startPos = self.door:WorldToLocal(pos);
			self.door.worldStartPos = pos;
		end;
	end;

	function ENT:SetEnd(pos)
		if (IsValid(self.door)) then
			self.door:SetSaveValue("m_vecPosition2", tostring(pos));
			self.door.endPos = self.door:WorldToLocal(pos);
			self.door.worldEndPos = pos;
		end;
	end;

	function ENT:SetMoveSpeed(speed)
		if (IsValid(self.door)) then
			self.door:Fire("SetSpeed", tostring(speed));
			self.door.movespeed = tonumber(speed);
		end;
	end;

	function ENT:SetMoveSound(snd)
		if (IsValid(self.door)) then
			self.door:SetKeyValue("StartSound", tostring(snd));
			self.door.movesound = tostring(snd);
		end;
	end;

	function ENT:SetStopSound(snd)
		if (IsValid(self.door)) then
			self.door:SetKeyValue("StopSound", tostring(snd));
			self.door.stopsound = tostring(snd);
		end;
	end;

	function ENT:SetShake(bShake)
		self.door.shake = tobool(bShake);
	end;

	function ENT:ChangeModel(model)
		if (IsValid(self.door)) then
			self.door:SetModel(model);
			self.door:Activate();
		end;

		if (IsValid(self.door.child)) then
			self.door.child:SetModel(model);
		end;
	end;

	function ENT:SetBlockDamage(dmg)
		self.door:SetKeyValue("BlockDamage", tonumber(dmg));
		self.door.blockdamage = dmg;
	end;

	function ENT:SetAllowUse(bUse)
		self.door.allowuse = tobool(bUse);
	end;

	hook.Add("KeyPress", "elevator_useHandler", function(player, key)
		if (key != IN_USE) then return; end;
		local entity = player:GetEyeTrace().Entity;

		if (!IsValid(entity)) then return; end;
		if (player:GetEyeTrace().HitPos:Distance(player:EyePos()) >= 85) then return; end;

		if (entity:GetClass() == "func_movelinear") then
			if (entity.allowuse) then
				local startPos = entity.worldStartPos;
				local endPos = entity.worldEndPos;
				if (entity:GetPos():Distance(startPos) <= 10) then
					entity:Fire("Open");
					return true;
				elseif (entity:GetPos():Distance(endPos) <= 10) then
					entity:Fire("Close");
					return true;
				end;
			end;
		elseif (IsValid(entity:GetParent())) then
			if (entity:GetParent():GetClass() == "func_movelinear") then
				entity = entity:GetParent();
				if (entity.allowuse) then
					local startPos = entity.worldStartPos;
					local endPos = entity.worldEndPos;
					if (entity:GetPos():Distance(startPos) <= 10) then
						entity:Fire("Open");
						return true;
					elseif (entity:GetPos():Distance(endPos) <= 10) then
						entity:Fire("Close");
						return true;
					end;
				end;
			end;
		end;
	end);

	hook.Add("AllowPlayerPickup", "elevator_pickupHandler", function(player, entity)
		if (IsValid(entity:GetParent())) then
			return false;
		end;
	end);

elseif (CLIENT) then

	function ENT:Initialize()
		self:SetSolid(SOLID_VPHYSICS);
	end;

	function ENT:Draw()

	end;

end;

duplicator.RegisterEntityClass("func_movelinear", function(player, data, startPos, endPos, speed, moveSound, stopSound, blockDamage, bAllowUse, startButton, returnButton, parts, worldStartPos, bShake)
	local ent = ents.Create("elevator");
	ent:SetPos(data.Pos);
	ent:SetAngles(data.Angle);
	ent.Model = data.Model;
	ent:Spawn();

	ent:SetStart(ent:GetDoor():LocalToWorld(startPos));
	ent:SetEnd(ent:GetDoor():LocalToWorld(endPos));

	ent:SetMoveSpeed(speed);
	ent:SetMoveSound(moveSound);
	ent:SetStopSound(stopSound);

	ent:SetBlockDamage(blockDamage);
	ent:SetAllowUse(bAllowUse);
	ent:SetShake(bShake);

	ent:GetDoor().StartButton = numpad.OnDown(player, startButton, "ElevatorStart", ent:GetDoor());
	ent:GetDoor().ReturnButton = numpad.OnDown(player, returnButton, "ElevatorReturn", ent:GetDoor());

	table.Add(ent:GetTable(), data);

	if (parts) then
		for k, v in pairs(parts) do
			local prop = ents.Create("prop_physics");
			prop:SetPos(ent:GetDoor():LocalToWorld(v.origin));
			prop:SetAngles(ent:GetDoor():LocalToWorldAngles(v.angles));
			prop:SetModel(v.model);
			prop:SetMaterial(v.material);
			prop:SetRenderMode(v.rendermode);
			prop:SetColor(v.color);
			prop:Spawn();
			prop:SetParent(ent:GetDoor());
			prop:GetPhysicsObject():EnableMotion(false);
		end;
	end;

	return ent;
end, "Data", "startPos", "endPos", "movespeed", "movesound", "stopsound", "blockdamage", "allowuse", "b1", "b2", "parts", "material", "worldStartPos", "shake");
--lua/entities/ent_baby_explosive2/cl_init.lua:
include("shared.lua")

function ENT:Initialize() end

function ENT:Draw()
	self:DrawModel()
end
--lua/entities/ent_chemlight/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self.Entity:DrawModel()
end


function ENT:Think()

 
	local rgba = self:GetColor();
    local dlight = DynamicLight( self:EntIndex() )
	if ( dlight ) then
		dlight.Pos = self:GetPos()
		dlight.r = rgba.r * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.g = rgba.g * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.b = rgba.b * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.Brightness = 0
		dlight.Size = 256 * (GetGlobalFloat( "global_Cheml_Range", 100 ) / 100)
		dlight.Decay = 1000
		dlight.DieTime = CurTime() + 0.05 --+ GetGlobalFloat( "global_Cheml_Lifetime", 25 ) --0.05


	end
end
--lua/entities/ent_chemlight_for_attachment/shared.lua:
ENT.Type			= "anim"  
ENT.Base			= "base_gmodentity"  
ENT.PrintName		= "Chemlight"
ENT.Author			= "Patrick Hunt"
ENT.Information		= ""
ENT.Category		= "Fun + Games"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false


--lua/entities/ent_chemlight_glow/shared.lua:
ENT.Type			= "anim"  
ENT.Base			= "base_gmodentity"  
ENT.PrintName		= "Chemlight Glow"
ENT.Author			= "Patrick Hunt"
ENT.Information		= "Alright, you got me. It's a fake glow."
ENT.Category		= "Glow Sticks"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false
--lua/entities/ent_chemlight_glow_red/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
end

function ENT:Think()
	local rgba = self:GetColor();
    local dlight = DynamicLight( self:EntIndex() )
	if ( dlight ) then
		dlight.Pos = self:GetPos()
		dlight.r = 255 * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.g = 0 * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.b = 0 * (GetGlobalFloat( "global_Cheml_Brightness", 80 ) / 100)
		dlight.Brightness = 0
		dlight.Size = 256 * (GetGlobalFloat( "global_Cheml_Range", 100 ) / 100)
		dlight.Decay = 0
		dlight.DieTime = CurTime() + 0.05
	end
end
--lua/entities/ent_chemlight_glow_rgb/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
end

function ENT:Think()
	local rgba = self.Owner:GetNW2Vector( "navachemlightcolorcache"):ToColor() --self.Owner.navachemlightcolorcache
    local dlight = DynamicLight( self:EntIndex() )
	if ( dlight ) then
		dlight.Pos = self:GetPos()
		dlight.r = rgba.r
		dlight.g = rgba.g
		dlight.b = rgba.b
		dlight.Brightness = 0
		dlight.Size = 256 * (GetGlobalFloat( "global_Cheml_Range", 100 ) / 100)
		dlight.Decay = 0
		dlight.DieTime = CurTime() + 0.05
	end
end
--lua/entities/ent_chemlight_glow_rgb/shared.lua:
ENT.Type			= "anim"  
ENT.Base			= "base_gmodentity"  
ENT.PrintName		= "Chemlight Glow"
ENT.Author			= "Patrick Hunt"
ENT.Information		= "Alright, you got me. It's a fake glow."
ENT.Category		= "Glow Sticks"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false
--lua/entities/ent_chemlight_glow_vmanip/shared.lua:
ENT.Type			= "anim"  
ENT.Base			= "base_gmodentity"  
ENT.PrintName		= "Chemlight Glow"
ENT.Author			= "Patrick Hunt"
ENT.Information		= "Alright, you got me. It's a fake glow."
ENT.Category		= "Glow Sticks"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false
--addons/wos-alcs-custom/lua/entities/ent_lightsaber_thrown.lua:

AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Lightsaber"
ENT.Category = "Robotboy655's Entities"

ENT.Editable = true
ENT.Spawnable = true

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

ENT.CustomSettings = {}

function ENT:SetupDataTables()
	self:NetworkVar( "Float", 0, "BladeLength" )
	self:NetworkVar( "Float", 1, "MaxLength" )
	self:NetworkVar( "Float", 2, "BladeWidth" )

	self:NetworkVar( "Bool", 0, "DarkInner" )
	self:NetworkVar( "Bool", 1, "Enabled" )

	self:NetworkVar( "Vector", 0, "CrystalColor" )
	self:NetworkVar( "Vector", 1 , "EndPos" )
	self:NetworkVar( "Vector", 2, "InnerColor" )

	self:NetworkVar( "String", 0, "WorldModel" )

	self:NetworkVar( "Int", 0, "Stage" )
	if ( SERVER ) then
		self:SetStage( 0 )

		self:SetBladeLength( 0 )
		self:SetBladeWidth( 2 )
		self:SetMaxLength( 42 )
		self:SetInnerColor( Vector( 255, 255, 255 ) )
		self:SetDarkInner( false )
		self:SetEnabled( true )
	end
end

function ENT:Initialize()

	if ( SERVER ) then
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_NONE )

		self.LoopSound = self.LoopSound || "lightsaber/saber_loop" .. math.random( 1, 8 ) .. ".wav"
		self.SwingSound = self.SwingSound || "lightsaber/saber_swing" .. math.random( 1, 2 ) .. ".wav"
		self.OnSound = self.OnSound || "lightsaber/saber_on" .. math.random( 1, 2 ) .. ".wav"
		self.OffSound = self.OffSound || "lightsaber/saber_off" .. math.random( 1, 2 ) .. ".wav"

		if ( self:GetEnabled() ) then self:EmitSound( self.OnSound ) end

		self.SoundSwing = CreateSound( self, Sound( self.SwingSound ) )
		if ( self.SoundSwing ) then self.SoundSwing:Play() self.SoundSwing:ChangeVolume( 0, 0 ) end

		self.SoundHit = CreateSound( self, Sound( "lightsaber/saber_hit.wav" ) )
		if ( self.SoundHit ) then self.SoundHit:Play() self.SoundHit:ChangeVolume( 0, 0 ) end

		self.SoundLoop = CreateSound( self, Sound( self.LoopSound ) )
		if ( self.SoundLoop ) then self.SoundLoop:Play() end

		self:GetPhysicsObject():EnableGravity(false)
		self:GetPhysicsObject():Wake()
	else
		self:SetRenderBounds( Vector( -self:GetBladeLength(), -128, -128 ), Vector( self:GetBladeLength(), 128, 128 ) )

		language.Add( self.ClassName, self.PrintName )
		killicon.AddAlias( "ent_lightsaber", "weapon_lightsaber" )
	end
	self:StartMotionController()
end

function ENT:OnRemove()
	if ( CLIENT ) then rb655_SaberClean_wos( self:EntIndex() ) return end

	if ( self.SoundLoop ) then self.SoundLoop:Stop() self.SoundLoop = nil end
	if ( self.SoundSwing ) then self.SoundSwing:Stop() self.SoundSwing = nil end
	if ( self.SoundHit ) then self.SoundHit:Stop() self.SoundHit = nil end

	if ( self:GetEnabled() ) then self:EmitSound( self.OffSound ) end
end

function ENT:GetSaberPosAng( num, q )
	num = num || 1

	local att = "blade" .. num
	if q then
		att = "quillon" .. num
	end
	local attachment = self:LookupAttachment( att )
	if ( attachment > 0 ) then
		local PosAng = self:GetAttachment( attachment )
		return PosAng.Pos, PosAng.Ang:Forward()
	end

	return self:LocalToWorld( Vector( 1, -0.58, -0.25 ) ), -self:GetAngles():Forward()

end

function ENT:Draw()

	self:DrawModel()

	if ( halo.RenderedEntity && IsValid( halo.RenderedEntity() ) && halo.RenderedEntity() == self ) then return end

	local clr = self:GetCrystalColor()
	clr = Color( clr.x, clr.y, clr.z )

	local clr_inner = self:GetInnerColor()
	clr_inner = Color( clr_inner.x, clr_inner.y, clr_inner.z )

	local poss, dirr = self:GetSaberPosAng()
	rb655_RenderBlade_wos( poss, dirr, self:GetBladeLength(), self:GetMaxLength(), self:GetBladeWidth(), clr, self:GetDarkInner(), clr_inner, self:EntIndex(), false, false, blades, self.CustomSettings )

	for id, t in pairs( self:GetAttachments() ) do
		if ( !string.match( t.name, "blade(%d+)" ) && !string.match( t.name, "quillon(%d+)" ) ) then continue end

		local bladeNum = string.match( t.name, "blade(%d+)" )
		local quillonNum = string.match( t.name, "quillon(%d+)" )

		if ( bladeNum && self:LookupAttachment( "blade" .. bladeNum ) > 0 and tonumber( bladeNum ) > 0 ) then
			local pos, dir = self:GetSaberPosAng( bladeNum )
			rb655_RenderBlade_wos( pos, dir, self:GetBladeLength(), self:GetMaxLength(), self:GetBladeWidth(), clr, self:GetDarkInner(), clr_inner, self:EntIndex(), false, false, blades, self.CustomSettings )
		end

		if ( quillonNum && self:LookupAttachment( "quillon" .. quillonNum ) > 0 ) then
			local pos, dir = self:GetSaberPosAng( quillonNum, true )
			rb655_RenderBlade_wos( pos, dir, self:GetBladeLength(), self:GetMaxLength(), self:GetBladeWidth(), clr, self:GetDarkInner(), clr_inner, self:EntIndex(), false, true, blades, self.CustomSettings )
		end
	end
end

local params = {}
params.secondstoarrive = 0.0001 --this is probably cheating.
params.dampfactor = 0.9999
params.teleportdistance = 0
params.maxangular = 800000
params.maxangulardamp = 9000
params.maxspeed = 100000
params.maxspeeddamp = params.maxangulardamp

function ENT:PhysicsSimulate( phys, time )

	local ply = self:GetOwner() or self:GetOwner()
	if not IsValid(ply) then return end

	phys:Wake()

	if not self.StartTime then
		self.StartTime = CurTime()
		self.EndTime = CurTime() + 3
	end

	local vec = LerpVector(math.abs((CurTime() - self.StartTime)/(self.EndTime - self.StartTime)),self:GetPos(),self:GetEndPos())
	params.deltatime = time
	local ang = (self:GetEndPos() - vec):Angle()
	ang:RotateAroundAxis(ang:Up(),CurTime() * 720 % 360)
	params.angle = ang
	if ( self:LookupAttachment( "blade2" ) > 0 ) then
		params.pos = vec
	else
		params.pos = vec + ang:Forward() * 40
	end
	phys:ComputeShadowControl(params)
	--return Vector(0,0,0),Vector(0,0,0),SIM_NOTHING
	
end

if ( CLIENT ) then return end

function ENT:OnTakeDamage( dmginfo )

	-- React physically when shot/getting blown
	self:TakePhysicsDamage( dmginfo )

end

function ENT:Think()
	if not IsValid( self:GetOwner() ) then self:Remove() return end
	if not self:GetOwner():Alive() then self:Remove() return end
	local ply = self:GetOwner()
	local wep = ply:GetActiveWeapon()
	if not IsValid( wep ) then self:Remove() return end
	if not wep.IsLightsaber then self:Remove() return end
	if self.EndTime then
		if self.EndTime < CurTime() then 
			ply:DrawWorldModel(true)
			wep:SetNextAttack(0.25)
			wep:SetEnabled(true)
			wep:SetBladeLength(self:GetBladeLength())
			if !( wOS.EnablewiltOSProneMod and ply:IsProne() ) then
				wep:SetEnabled(true)
				wep:SetBladeLength(self:GetBladeLength())
			end	
			self:Remove() 
			return 
		end
	end
	if self:GetPos():DistToSqr(self:GetEndPos()) <= (self:GetStage() == 1 and 75 ^ 2 or 10^2) then
		if self:GetStage() == 0 then
			self:SetStage(1)
			self.EndTime = CurTime() + (CurTime() - self.StartTime)
			self.StartTime = CurTime()
		else
			ply:DrawWorldModel(true)
			wep:SetNextAttack(0.25)
			if !( wOS.EnablewiltOSProneMod and ply:IsProne() ) then
				wep:SetEnabled(true)
				wep:SetBladeLength(self:GetBladeLength())
			end		
			self:Remove()
			return
		end
	else
		wep:SetNextAttack(1)
	end

	if self:GetStage() == 1 then
		self:SetEndPos(wep:GetSaberPosAng() + (wep:GetSaberPosAng() - self:GetPos()):GetNormal() * 20)
	else
		local tr = {}
		tr.start = self:GetPos()
		tr.endpos = tr.start + (self:GetEndPos() - self:GetPos()):GetNormal() * 20
		tr.filter = {self,ply}
		local trace = util.TraceLine(tr)
		if trace.Hit and not (IsValid(trace.Entity) and (trace.Entity:IsNPC() or trace.Entity:IsPlayer())) then
			self:SetStage(1)
			self.EndTime = CurTime() + (CurTime() - self.StartTime)
			self.StartTime = CurTime()
		end
	end
	
	if ( !self:GetEnabled() && self:GetBladeLength() != 0 ) then
		self:SetBladeLength( math.Approach( self:GetBladeLength(), 0, 2 ) )
	elseif ( self:GetEnabled() && self:GetBladeLength() != self:GetMaxLength() ) then
		self:SetBladeLength( math.Approach( self:GetBladeLength(), self:GetMaxLength(), 8 ) )
	end

	if ( self:GetBladeLength() <= 0 ) then
		if ( self.SoundSwing ) then self.SoundSwing:ChangeVolume( 0, 0 ) end
		if ( self.SoundLoop ) then self.SoundLoop:ChangeVolume( 0, 0 ) end
		if ( self.SoundHit ) then self.SoundHit:ChangeVolume( 0, 0 ) end
		return
	end

	local pos, ang = self:GetSaberPosAng()
	local hit = self:BladeThink( pos, ang )
	if ( self:LookupAttachment( "blade2" ) > 0 ) then
		local pos2, ang2 = self:GetSaberPosAng( 2 )
		local hit_2 = self:BladeThink( pos2, ang2 )
		hit = hit || hit_2
	end

	if ( self.SoundHit ) then
		if ( hit ) then self.SoundHit:ChangeVolume( math.Rand( 0.1, 0.5 ), 0 ) else self.SoundHit:ChangeVolume( 0, 0 ) end
	end

	if ( self.SoundSwing ) then
		--local ang = self:GetAngles()
		if ( self.LastAng != ang ) then
			self.LastAng = self.LastAng || ang
			self.SoundSwing:ChangeVolume( math.Clamp( ang:Distance( self.LastAng ) / 2, 0, 1 ), 0 )
			--self.SoundSwing:ChangeVolume( math.Rand( 0, 1 ), 0 ) -- For some reason if I spam always 1, the sound doesn't loop
			--self.SoundSwing:ChangeVolume( math.min( pos:Distance( self.LastPos ) / 16, 1 ), 0 )
		end
		self.LastAng = ang
	end

	if ( self.SoundLoop ) then
		local pos = pos + ang * self:GetBladeLength()
		if ( self.LastPos != pos ) then
			self.LastPos = self.LastPos || pos
			self.SoundLoop:ChangeVolume( 0.1 + math.Clamp( pos:Distance( self.LastPos ) / 32, 0, 0.2 ), 0 )
			--self.SoundLoop:ChangeVolume( 0.1 + math.Clamp( pos:Distance( self.LastPos ) / 32, 0, 0.2 ), 0 )
			--self.SoundLoop:ChangeVolume( 1 - math.min( pos:Distance( self.LastPos ) / 16, 1 ), 0 )
			--self.SoundLoop:ChangeVolume( self:GetBladeLength() / self:GetMaxLength(), 0 )
		end
		self.LastPos = pos
	end

	self:NextThink( CurTime() )
	return true
end

function ENT:DrawHitEffects( trace, traceBack )
	if ( self:GetBladeLength() <= 0 ) then return end

	if ( trace.Hit ) then
		rb655_DrawHit_wos( trace.HitPos, trace.HitNormal )
	end

	if ( traceBack && traceBack.Hit ) then
		rb655_DrawHit_wos( traceBack.HitPos, traceBack.HitNormal )
	end
end

function ENT:BladeThink( startpos, dir )
	--[[local trace = util.TraceHull( {
		start = startpos,
		endpos = startpos + dir * self:GetBladeLength(),
		filter = self,
		/*mins = Vector( -1, -1, -1 ) * self:GetBladeWidth() / 2,
		maxs = Vector( 1, 1, 1 ) * self:GetBladeWidth() / 2*/
	} )

	if ( trace.Hit ) and not (IsValid(trace.Entity) and trace.Entity == self:GetOwner()) then
		rb655_DrawHit_wos( trace.HitPos, trace.HitNormal )
		rb655_LS_DoDamage_wos( trace, self )
	end

	return trace.Hit]]

	-- Up
	local pos, ang = startpos, dir
	local trace = util.TraceHull( {
		start = pos,
		endpos = pos + ang * self:GetBladeLength(),
		filter = { self, self:GetOwner() },
		mins = Vector( -2, -2, -2 ),
		maxs = Vector( 2, 2, 2 )
	} )
	local traceBack = util.TraceHull( {
		start = pos + ang * self:GetBladeLength(),
		endpos = pos,
		filter = { self, self:GetOwner() },
		mins = Vector( -2, -2, -2 ),
		maxs = Vector( 2, 2, 2 )
	} )

	self.LastEndPos = trace.endpos
	if ( SERVER ) then debugoverlay.Line( trace.StartPos, trace.HitPos, .1, Color( 255, 0, 0 ), false ) end

	if ( trace.HitSky || trace.StartSolid ) then trace.Hit = false end
	if ( traceBack.HitSky || traceBack.StartSolid ) then traceBack.Hit = false end

	self:DrawHitEffects( trace, traceBack )
	isTrace1Hit = trace.Hit || traceBack.Hit

	// Don't deal the damage twice to the same entity
	if ( traceBack.Entity == trace.Entity && IsValid( trace.Entity ) ) then traceBack.Hit = false end

	local ent = trace.Hit and IsValid(trace.Entity) and trace.Entity
	if not IsValid(ent) and traceBack.Hit then
		ent = IsValid(traceBack.Entity) and traceBack.Entity
	end
	
	if ( trace.Hit ) then rb655_LS_DoDamage_wos( trace, self ) end
	if ( traceBack.Hit ) then rb655_LS_DoDamage_wos( traceBack, self ) end

	if self.LastEndPos then
		local traceTo = util.TraceHull({
			start = pos + ang * self:GetBladeLength(),
			endpos = self.LastEndPos,
			filter = { self, self:GetOwner() },
			mins = Vector( -2, -2, -2 ),
			maxs = Vector( 2, 2, 2 )
		})

		if ( traceTo.Hit ) and (IsValid(traceTo.Entity) and (not IsValid(ent) or traceTo.Entity != ent)) then 
			rb655_LS_DoDamage_wos( traceTo, self ) 
			ent = traceTo.Entity 
		end

		util.TraceHull({
			start = pos,
			endpos = self.LastEndPos,
			filter = { self, self:GetOwner() },
			mins = Vector( -2, -2, -2 ),
			maxs = Vector( 2, 2, 2 ),
			output = traceTo
		})

		if ( traceTo.Hit ) and (IsValid(traceTo.Entity) and (not IsValid(ent) or traceTo.Entity != ent)) then rb655_LS_DoDamage_wos( traceTo, self ) return true end
	end
	return trace.Hit or traceBack.Hit
end

function ENT:Use( activator, caller, useType, value )
	if ( !IsValid( activator ) || !activator:KeyPressed( IN_USE ) ) then return end

	if ( self:GetEnabled() ) then
		self:EmitSound( self.OffSound )
	else
		self:EmitSound( self.OnSound )
	end

	self:SetEnabled( !self:GetEnabled() )
end

function ENT:SpawnFunction( ply, tr )
	if ( !tr.Hit || !ply:CheckLimit( "ent_lightsabers" ) ) then return end

	local ent = ents.Create( ClassName )
	ent:SetPos( tr.HitPos + tr.HitNormal * 2 )

	local ang = ply:EyeAngles()
	ang.p = 0
	ang:RotateAroundAxis( ang:Right(), 180 )
	ent:SetAngles( ang )

	-- Sync values from the tool
	ent:SetMaxLength( math.Clamp( ply:GetInfoNum( "rb655_lightsaber_bladel", 42 ), 32, 64 ) )
	ent:SetCrystalColor( Vector( ply:GetInfo( "rb655_lightsaber_red" ), ply:GetInfo( "rb655_lightsaber_green" ), ply:GetInfo( "rb655_lightsaber_blue" ) ) / 255 )
	ent:SetDarkInner( ply:GetInfo( "rb655_lightsaber_dark" ) == "1" )
	ent:SetModel( ply:GetInfo( "rb655_lightsaber_model" ) )
	ent:SetBladeWidth( math.Clamp( ply:GetInfoNum( "rb655_lightsaber_bladew", 2 ), 2, 4 ) )

	ent.LoopSound = ply:GetInfo( "rb655_lightsaber_humsound" )
	ent.SwingSound = ply:GetInfo( "rb655_lightsaber_swingsound" )
	ent.OnSound = ply:GetInfo( "rb655_lightsaber_onsound" )
	ent.OffSound = ply:GetInfo( "rb655_lightsaber_offsound" )

	ent:Spawn()
	ent:Activate()

	ent.Owner = ply
	ent.Color = ent:GetColor()

	local phys = ent:GetPhysicsObject()
	if ( IsValid( phys ) ) then phys:Wake() end

	if ( IsValid( ply ) ) then
		ply:AddCount( "ent_lightsabers", ent )
		ply:AddCleanup( "ent_lightsabers", ent )
	end

	return ent
end

--addons/egm_tfa_weapons/lua/entities/ent_rw_rocket_mods/shared.lua:
ENT.Type 				= "anim"
ENT.PrintName			= "StarWars Reworked Rocket"
ENT.Author				= "ChanceSphere574"
ENT.Spawnable			= false
ENT.AdminSpawnable		= false
local GlowBit 			= Material("particle/particle_glow_04_additive")

if SERVER then
	AddCSLuaFile( "shared.lua" )

	function ENT:Initialize()
		self:SetModel("models/cs574/ammo/reworked_rocket.mdl")
		self:EmitSound("w/rocket/rocket_mouv.wav", 75, 100)
		self:SetNWBool("smoke", true)
		self:SetNWString("trackingmode", self.trackingmode or "")
		self:SetNWEntity("Owner", self.Owner)

		if self:GetNWString("trackingmode") == "point" then
			self:SetSkin(0)
		elseif self:GetNWString("trackingmode") == "track" then
			self:SetSkin(2)
		elseif self:GetNWString("trackingmode") == "control" then
			self:SetSkin(1)
		else
			self:SetSkin(4)
		end

		self.DieTime = CurTime() + 10

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetCollisionGroup ( COLLISION_GROUP_DEBRIS )
		timer.Simple( 0.35, function()
			self:SetCollisionGroup ( COLLISION_GROUP_NONE )
		end)

		local phys = self:GetPhysicsObject()
		phys:EnableGravity( false )
		phys:EnableDrag(false)
		phys:Wake()
	end

	function ENT:PhysicsCollide(data, physobj)
		self:Remove()
	end

	function ENT:Explosion()

		local rocket_damage = self.RocketDamage or 9000
		local effectdata = EffectData()
		effectdata:SetOrigin(self:GetPos())
		effectdata:SetNormal(self:GetPos())
		effectdata:SetEntity(self)
		effectdata:SetScale(2)
		effectdata:SetMagnitude(18)

		util.Effect( "rw_rocket_explosion", effectdata )
		util.BlastDamage(self, IsValid(self.Owner) and self.Owner or self, self:GetPos(), 350, math.Rand( rocket_damage * 0.9, rocket_damage * 1.1 ))
		util.Decal("Scorch", self:GetPos(), self:GetPos())

		self:EmitSound("BaseExplosionEffect.Sound", 500, 100)
		self:StopSound("w/rocket/rocket_mouv.wav")
		local shake = ents.Create("env_shake")

		shake:SetPos(self:GetPos())
		shake:SetKeyValue("amplitude", "2000")
		shake:SetKeyValue("radius", "900")
		shake:SetKeyValue("duration", "2.5")
		shake:SetKeyValue("frequency", "1225")
		shake:SetKeyValue("spawnflags", "4")
		shake:Spawn()
		shake:Activate()
		shake:Fire("StartShake", "", 0)

		local ar2Explo = ents.Create("env_fire")

		ar2Explo:SetPos(self:GetPos())
		ar2Explo:Spawn()
		ar2Explo:Activate()
		ar2Explo:Fire("Explode", "", 0)
	end

	function ENT:OnRemove()
		self:Explosion()
	end

	function ENT:Think()
		local phys = self:GetPhysicsObject()
		if not IsValid(phys) then return end
		local mode = self.trackingmode
		if mode == "point" then
			phys:SetVelocity(self:GetForward() * 6750)
			local ang = ( self.Owner:GetEyeTrace().HitPos-self:GetPos()):Angle()
			self:SetAngles( ang )
		elseif mode == "track" then
			phys:SetVelocity(self:GetForward() * 8250)
			if IsValid(self.trackedent) then
				local ang = ( self.trackedent:GetPos() - self:GetPos()):Angle()
				self:SetAngles( ang )
			end
		elseif mode == "control" then
			phys:SetVelocity(self:GetForward() * 5250)
			self:SetAngles(self.Owner:EyeAngles())
		else
			phys:SetVelocity(self:GetForward() * 9250)
		end

		if self.DieTime <= CurTime() then
			self:Remove()
		end

		self:NextThink(CurTime())
		return true
	end
end

if CLIENT then
	function ENT:Draw()
		local CurGlowPos = (self:GetForward() * - 10) + (self:GetUp() * 1.5)
		self:DrawModel()
		local lColor
		if self:GetNWString("trackingmode") == "point" then
			lColor = Color(255, 20, 30)
		elseif self:GetNWString("trackingmode") == "track" then
			lColor = Color(100, 255, 30)
		elseif self:GetNWString("trackingmode") == "control" then
			lColor = Color(0, 100, 255)
		else
			lColor = Color(255, 100, 0)
		end
		render.SetMaterial(GlowBit)
		render.DrawSprite(self:GetPos() + CurGlowPos, 15, 15, lColor)
		render.SetMaterial(GlowBit)
		render.DrawSprite(self:GetPos() + CurGlowPos, 15, 15, lColor)
		render.SetMaterial(GlowBit)
		render.DrawSprite(self:GetPos() + CurGlowPos, 15, 15, lColor)
		render.SetMaterial(GlowBit)
		render.DrawSprite(self:GetPos() + CurGlowPos, 15, 15, lColor)
		render.SetMaterial(GlowBit)
		render.DrawSprite(self:GetPos() + CurGlowPos, 120, 15, lColor)
	end

	function ENT:Initialize()
		pos = self:GetPos()
		self.emitter = ParticleEmitter( pos )
	end

	function ENT:Think()
		if (self:GetNWBool("smoke")) then
			pos = self:GetPos()
			for i = 1, (5) do
				local particle = self.emitter:Add( "particle/smokesprites_000" .. math.random(1,9), pos + (self:GetForward() * 0 * i))

				if (particle) then
					particle:SetVelocity((self:GetForward() * -45) + (VectorRand() * 45) )
					particle:SetDieTime( math.Rand( 1.1, 1.9 ) )
					particle:SetStartAlpha( math.Rand( 15, 30 ) )
					particle:SetEndAlpha( 0 )
					particle:SetStartSize( math.Rand( 15, 15 ) )
					particle:SetEndSize( math.Rand( 0.01, 0.02 ) )
					particle:SetRoll( math.Rand(0, 360) )
					particle:SetRollDelta( math.Rand(-1, 1) )
					particle:SetColor( 85 , 85 , 85 )
					particle:SetAirResistance( 200 )
					particle:SetGravity( Vector( 0, 0, 0 ) )
				end

			end
		end
	end

	function ENT:OnRemove()
		if self.Owner == LocalPlayer() and self:GetNWString("trackingmode") == "control" then
			hook.Remove("CalcView", "Joe_CalcView")
		end
	end
end

--lua/entities/gmod_advteleporter.lua:
-- Adv. Teleporter
-- By Anya O'Quinn / Slade Xanthas

AddCSLuaFile()

ENT.Type		= "anim"
ENT.Base		= "base_anim"
ENT.PrintName	= "Teleporter"

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 	0, "Destination")
	self:NetworkVar("Float", 	0, "TeleUniqueID")
	self:NetworkVar("Float", 	1, "TeleDestinationUniqueID")
	self:NetworkVar("Int", 		0, "TeleRadius", 		{KeyName = "teleradius"})
	self:NetworkVar("Int", 		1, "TeleHeight", 		{KeyName = "teleheight"})
	self:NetworkVar("String", 	0, "TeleSound", 		{KeyName = "telesound"})
	self:NetworkVar("String", 	1, "TeleEffect", 		{KeyName = "telesound"})
	self:NetworkVar("Bool", 	0, "TeleOnUse", 		{KeyName = "teleonuse"})
	self:NetworkVar("Bool", 	1, "TeleOnTouch", 		{KeyName = "teleontouch"})
	self:NetworkVar("Bool", 	2, "TeleShowBeam", 		{KeyName = "teleshowbeam"})
	self:NetworkVar("Bool", 	3, "TeleShowRadius", 	{KeyName = "teleshowradius"})
end

if CLIENT then

	function ENT:Initialize()

		self.Mat = Material("sprites/tp_beam001")
		self.Sprite = Material("sprites/blueglow2")
		self.LinkedColor = Color(0,255,0,255)
		self.UnlinkedColor = Color(255,0,0,255)
		
		self.RadiusSphere = ClientsideModel("models/dav0r/hoverball.mdl", RENDERGROUP_OPAQUE)
		
		if IsValid(self.RadiusSphere) then
			self.RadiusSphere:SetNoDraw(true)
			self.RadiusSphere:SetPos(self:LocalToWorld(self:OBBCenter()))
			self.RadiusSphere:SetParent(self)
		end
		
	end

	function ENT:Draw()

		self:DrawModel()

		local Destination = self:GetDestination()
		
		if IsValid(self) and IsValid(self.RadiusSphere) then
		
			if self:GetTeleRadius() and self:GetTeleShowRadius() then
			
				render.SuppressEngineLighting(true)	
				
				if IsValid(Destination) and IsValid(Destination:GetDestination()) and (self == Destination:GetDestination()) then
					render.SetColorModulation(0,1,0)
				else
					render.SetColorModulation(1,0,0)
				end

				render.SetBlend(1)
				self.RadiusSphere:DrawModel()
				render.SuppressEngineLighting(false)
				render.SetBlend(1)
				render.SetColorModulation(1,1,1)
				self.RadiusSphere:SetModelScale(self:GetTeleRadius() / 5,0)
				self.RadiusSphere:SetMaterial("models/props_combine/portalball001_sheet")
				
			end
		
		end

		if IsValid(self) and IsValid(Destination) and IsValid(Destination:GetDestination()) and (self == Destination:GetDestination()) and self:GetTeleShowBeam() and Destination:GetTeleShowBeam() then
			render.SetMaterial(self.Mat)
			render.DrawBeam(self:LocalToWorld(self:OBBCenter()), Destination:LocalToWorld(Destination:OBBCenter()), 4, 2, 0, self.LinkedColor)
			render.SetMaterial(self.Sprite)
			local rand = math.random(-2,2)
			render.DrawSprite(self:LocalToWorld(self:OBBCenter()), 6 + rand, 6 + rand, self.LinkedColor)
			render.DrawSprite(Destination:LocalToWorld(Destination:OBBCenter()), 6 + rand, 6 + rand, Destination.LinkedColor)
			self:SetRenderBoundsWS(self:GetPos(), Destination:GetPos())
		elseif IsValid(self) then			
			self:SetRenderBoundsWS(self:GetPos() + self:OBBMins(),self:GetPos() + self:OBBMaxs())
		end

	end
	
	function ENT:OnRemove()
		if IsValid(self.RadiusSphere) then
			self.RadiusSphere:Remove()
			self.RadiusSphere = nil
		end
	end

end

if SERVER then

	function ENT:Initialize()

		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetUseType(SIMPLE_USE)

		self.NextTeleport = CurTime()
		
		if Wire_CreateInputs then
			self.Inputs = Wire_CreateInputs(self, {"Teleport","Lock"})
		end
		
		self.tEnts = {}
		
		local phys = self:GetPhysicsObject()
		if IsValid(phys) then
			phys:Wake()
		end
		
		if self:GetTeleUniqueID() == 0 then 
			self:SetTeleUniqueID(RealTime() + self:EntIndex())
		end
		
		self:LinkUp()

	end

	function ENT:LinkUp()
	
		if IsValid(self:GetDestination()) then return end
		
		if self:GetTeleDestinationUniqueID() ~= 0 then
		
			for _,v in pairs(ents.FindByClass(self:GetClass())) do	
				if IsValid(v) 
				and v ~= self 
				and v:GetTeleUniqueID() ~= 0
				and v:GetTeleDestinationUniqueID() ~= 0
				and self:GetTeleDestinationUniqueID() == v:GetTeleUniqueID() 
				and v:GetTeleDestinationUniqueID() == self:GetTeleUniqueID() 
				then
					self:SetDestination(v)
					v:SetDestination(self)
					self.NextTeleport = CurTime() + 1
					v.NextTeleport = CurTime() + 1
					break
				end
			end	
			
		else
		
			for _,v in pairs(ents.FindByClass(self:GetClass())) do	
				
				if IsValid(self)
				and IsValid(v)
				and v ~= self
				and self.TeleKey
				and v.TeleKey
				and v.TeleKey == self.TeleKey
				and not IsValid(self:GetDestination())
				and not IsValid(v:GetDestination())
				and IsValid(self.Owner)
				and IsValid(v.Owner)
				and self.Owner == v.Owner
				then
					self:SetDestination(v)
					v:SetDestination(self)
					self:SetTeleDestinationUniqueID(v:GetTeleUniqueID())
					v:SetTeleDestinationUniqueID(self:GetTeleUniqueID())
					self.NextTeleport = CurTime() + 1
					v.NextTeleport = CurTime() + 1
					break
				end
				
			end	

		end

	end
	
	function ENT:PreEntityCopy()
		local dupeInfo = {}
		if IsValid(self) and IsValid(self:GetDestination()) then
			dupeInfo.DestinationID = self:GetDestination():EntIndex()
			duplicator.StoreEntityModifier(self, "DestinationDupeInfo", dupeInfo)
		end
	end
		
	function ENT:PostEntityPaste(pl, Ent, CreatedEntities)
		self:SetDestination(CreatedEntities[Ent.EntityMods.DestinationDupeInfo.DestinationID])
	end

	function ENT:Setup(model, sound, effect, radius, height, ontouch, onuse, showbeam, showradius, key)

		self:SetTeleSound(sound)
		self:SetTeleEffect(effect)
		self:SetTeleOnTouch(ontouch)
		self:SetTeleOnUse(onuse)
		self:SetTeleRadius(radius)
		self:SetTeleHeight(height)
		self:SetTeleShowBeam(showbeam)
		self:SetTeleShowRadius(showradius)
		
		if not self.TeleKey then 
			self.TeleKey = key
		end
		
		if not self:GetModel() then
			self:SetModel(model)
		end
		
		if not IsValid(self:GetDestination()) then
			self:LinkUp()
		end
		
		if IsValid(self:GetDestination()) and self:GetTeleShowBeam() ~= self:GetDestination():GetTeleShowBeam() then
			self:GetDestination():SetTeleShowBeam(self:GetTeleShowBeam())
		end

	end
	
	function ENT:Teleport(ent)

		if not IsValid(self) or not IsValid(self:GetDestination()) or not IsValid(ent) then return end
		
		self:EmitSound(self:GetTeleSound())
		self:GetDestination():EmitSound(self:GetDestination():GetTeleSound())
	
		local fx = EffectData()	
		fx:SetScale(1)
		fx:SetRadius(1)
		fx:SetMagnitude(7)
		fx:SetEntity(self)
		fx:SetOrigin(self:GetPos())
		util.Effect(self:GetTeleEffect(), fx, true, true)
		fx:SetEntity(self:GetDestination())
		fx:SetOrigin(self:GetDestination():GetPos())
		util.Effect(self:GetDestination():GetTeleEffect(), fx, true, true)
		
		ent:SetPos(self:GetDestination():GetPos() + self:GetDestination():GetUp() * (self:GetTeleHeight())) 

		table.insert(self.tEnts,ent)
		table.insert(self:GetDestination().tEnts,ent)

	end

	function ENT:Use(activator,caller)
		if IsValid(activator) and activator:IsPlayer() then
			self.Activator = activator
			self.IsBeingUsed = true
		end
	end

	function ENT:Think()

		if not IsValid(self) then return end
		
		if IsValid(self:GetDestination()) then

			self:SetDestination(self:GetDestination())

			local area = ents.FindInSphere(self:GetPos(),self:GetTeleRadius())

			for i,ent in pairs(area) do

				if IsValid(ent) 
				and ent:IsPlayer()
				and ent ~= self
				and ent ~= self:GetDestination()
				and not table.HasValue(self.tEnts,ent) 
				and not table.HasValue(self:GetDestination().tEnts,ent) 
				and (self:GetTeleOnTouch() or self.KeyOn or self.WireTeleport or (self:GetTeleOnUse() and self.IsBeingUsed)) 
				and not self:GetDestination().Locked
				and self.NextTeleport < CurTime() 
				and self:GetDestination().NextTeleport < CurTime() then
					self:Teleport(ent)
					self.NextTeleport = CurTime() + 2
				end
				
			end	

			self.IsBeingUsed = false
							
			for i,v in pairs(self.tEnts) do
				if not table.HasValue(area,v) then
					self.tEnts[i] = nil
				end
			end

		end
		
		if self.IsBeingUsed and IsValid(self.Activator) and self.Activator:IsPlayer() and (self.Activator:KeyReleased(IN_USE) or not self.Activator:GetEyeTraceNoCursor().Entity == self) then
			self.IsBeingUsed = false		
		end

		if IsValid(self:GetDestination()) then
			self:NextThink(CurTime() + 0.05)
		else
			self:LinkUp()
			self:NextThink(CurTime() + 1)
		end
		
		return true

	end

	local function On(pl, ent)
		if not IsValid(ent) then return end
		ent.KeyOn = true
		return true
	end

	local function Off(pl, ent)
		if not IsValid(ent) then return end
		ent.KeyOn = false
		return true
	end

	numpad.Register("Teleporter_On", On)
	numpad.Register("Teleporter_Off", Off)

	function ENT:TriggerInput(iname, value)

		if iname == "Teleport" then
		
			if value == 1 then 
				self.WireTeleport = true 
			end
			
			if value == 0 and self.WireTeleport then 
				self.WireTeleport = false 
			end
			
		end
		
		if iname == "Lock" then
		
			if value == 1 and not self.Locked then 
				self.Locked = true 
			end
			
			if value == 0 and self.Locked then 
				self.Locked = false 
			end

		end
		
	end

end

-- 37062385
--addons/hbombs_base/lua/entities/hb_cp_annie.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_dumb" )


ENT.Spawnable		            	 =  true         
ENT.AdminSpawnable		             =  true 

ENT.PrintName		                 =  "Atomic Annie"
ENT.Author			                 =  "Natsu"
ENT.Contact		                     =  "baldursgate3@gmail.com"
ENT.Category                         =  "HBOMBS Misc"

ENT.Model                            =  "models/thedoctor/atomicannie.mdl"           
ENT.Effect                           =  ""                  
ENT.EffectAir                        =  ""   
ENT.EffectWater                      =  "" 
ENT.ExplosionSound                   =  ""                   
ENT.ParticleTrail                    =  ""

ENT.ShouldUnweld                     =  false
ENT.ShouldIgnite                     =  false      
ENT.ShouldExplodeOnImpact            =  false         
ENT.Flamable                         =  false        
ENT.UseRandomSounds                  =  false       
ENT.UseRandomModels                  =  false

ENT.ExplosionDamage                  =  1          
ENT.PhysForce                        =  2           
ENT.ExplosionRadius                  =  3           
ENT.SpecialRadius                    =  4            
ENT.MaxIgnitionTime                  =  1           
ENT.Life                             =  500          
ENT.MaxDelay                         =  0          
ENT.TraceLength                      =  0        
ENT.ImpactSpeed                      =  0           
ENT.Mass                             =  5000

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:ExploSound(pos)
     if not self.Exploded then return end
	 if self.UseRandomSounds then
         sound.Play(table.Random(ExploSnds), pos, 160, 130,1)
     else
	     sound.Play(self.ExplosionSound, pos, 160, 130,1)
	 end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 56 ) 
     ent:Spawn()
     ent:Activate()

     return ent
end
--addons/hbombs_base/lua/entities/hb_cp_anniebase.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_dumb" )


ENT.Spawnable		            	 =  true         
ENT.AdminSpawnable		             =  true 

ENT.PrintName		                 =  "Atomic Annie Base"
ENT.Author			                 =  "Natsu"
ENT.Contact		                     =  "baldursgate3@gmail.com"
ENT.Category                         =  "HBOMBS Misc"

ENT.Model                            =  "models/thedoctor/atomicanniebase.mdl"           
ENT.Effect                           =  ""                  
ENT.EffectAir                        =  ""   
ENT.EffectWater                      =  "" 
ENT.ExplosionSound                   =  ""                   
ENT.ParticleTrail                    =  ""

ENT.ShouldUnweld                     =  false
ENT.ShouldIgnite                     =  false      
ENT.ShouldExplodeOnImpact            =  false         
ENT.Flamable                         =  false        
ENT.UseRandomSounds                  =  false       
ENT.UseRandomModels                  =  false

ENT.ExplosionDamage                  =  1          
ENT.PhysForce                        =  2           
ENT.ExplosionRadius                  =  3           
ENT.SpecialRadius                    =  4            
ENT.MaxIgnitionTime                  =  1           
ENT.Life                             =  500          
ENT.MaxDelay                         =  0          
ENT.TraceLength                      =  0        
ENT.ImpactSpeed                      =  0           
ENT.Mass                             =  15000

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:ExploSound(pos)
     if not self.Exploded then return end
	 if self.UseRandomSounds then
         sound.Play(table.Random(ExploSnds), pos, 160, 130,1)
     else
	     sound.Play(self.ExplosionSound, pos, 160, 130,1)
	 end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 56 ) 
     ent:Spawn()
     ent:Activate()

     return ent
end
--addons/hbombs_base/lua/entities/hb_emp_v_dead.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  "Radiation"        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      
          
function ENT:Initialize()
     if (SERVER) then
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
     end
end

function ENT:Think()
	if (SERVER) then
	if !self:IsValid() then return end
	if self.radowner:IsValid() then 
		self.pos = string.Explode( " ", tostring(self.radowner:GetPos()) )
		self:SetPos(Vector(self.pos[1],self.pos[2],self.pos[3]))
		local pos = self:GetPos()
		self.radowner:Fire("TurnOff", 0.1, 0)
	else
		self:Remove()
	end
	self:NextThink(CurTime() + 0.01)
	return true
	end
end

function ENT:Draw()
     return true
end
--addons/hbombs/lua/entities/hb_main_clusterbomb.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.PrintName						 =  "Cluster Bomb"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Main"

ENT.Model                            =  "models/military2/bomb/bomb_cbu.mdl"                      
ENT.Effect                           =  "h_grenade_main"                  
ENT.EffectAir                        =  "h_grenade_main_air"                   
ENT.EffectWater                      =  "h_water_micro"
ENT.ExplosionSound                   =  "gbombs_5/explosions/light_bomb/mine_explosion.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  700
ENT.PhysForce                        =  200
ENT.ExplosionRadius                  =  100
ENT.SpecialRadius                    =  500
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  0                                 
ENT.TraceLength                      =  3000
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  52
ENT.ArmDelay                         =  1
ENT.HBOWNER                          =  nil             -- don't you fucking touch this.


ENT.DEFAULT_PHYSFORCE                = 155
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 20
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 1000 

function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos = self:LocalToWorld(self:OBBCenter())
	
	 constraint.RemoveAll(self)
	 local physo = self:GetPhysicsObject()
	 physo:Wake()	
	 self.Exploding = true
	 if !self:IsValid() then return end 
	 self:StopParticles()
	 local pos = self:LocalToWorld(self:OBBCenter())
	 
	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",self.ExplosionRadius)
	 ent:SetVar("SHOCKWAVE_INCREMENT",100)
	 ent:SetVar("DELAY",0.01)
	
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",100)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)
	 ent:SetVar("Shocktime", self.Shocktime)

	 for i=0, (15-1) do
		 local ent1 = ents.Create("hb_main_clusterbomblet") 
		 local phys = ent1:GetPhysicsObject()
		 ent1:SetPos( self:GetPos() ) 
		 ent1:Spawn()
		 ent1:Activate()
		 ent1:SetVar("HBOWNER", self.HBOWNER)
		 local bphys = ent1:GetPhysicsObject()
		 local phys = self:GetPhysicsObject()
		 if bphys:IsValid() and phys:IsValid() then
			 bphys:ApplyForceCenter(VectorRand() * bphys:GetMass() * 155)
			 bphys:AddVelocity(phys:GetVelocity()/2)
		 end
		 timer.Simple(4, function()
			if ent1:IsValid() then
				ent1:Remove()
			end
		 end)
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius/2)) do
		 if self.ShouldUnweld then
			 if v:IsValid() then
				 if v:IsValid() and v:GetPhysicsObject():IsValid() then
					 constraint.RemoveAll(v)
				 end
			 end
		 end
		 if self.ShouldIgnite then
			 if v:IsOnFire() then
				 v:Extinguish()
			 end
			 v:Ignite(math.Rand(self.MaxIgnitionTime-2,self.MaxIgnitionTime),5)
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius)) do
		 if v:IsValid() && (v != self) then
			 local phys = v:GetPhysicsObject()
			 if (phys:IsValid()) then
				 local mass = phys:GetMass()
				 local F_ang = self.PhysForce
				 local dist = (pos - v:GetPos()):Length()
				 local relation = math.Clamp((self.SpecialRadius - dist) / self.SpecialRadius, 0, 1)
				 local F_dir = (v:GetPos() - pos):GetNormal() * self.PhysForce
		
				 phys:Wake()
				 phys:EnableMotion(true)
			   
				 phys:AddAngleVelocity(Vector(F_ang, F_ang, F_ang) * relation)
				 phys:AddVelocity(F_dir)
			 end
		 end
	 end 
	 local pos = self:GetPos()
	 util.BlastDamage(self, self.HBOWNER, pos, self.ExplosionRadius, self.ExplosionDamage)
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			 timer.Simple(0.1, function()
				 if !self:IsValid() then return end 
				 self:Remove()
				 
			 end)
		 else 
			 ParticleEffect(self.EffectAir,self:GetPos(),Angle(0,0,0),nil) 
			 timer.Simple(0.1, function()
			 if !self:IsValid() then return end 
				self:Remove()
			 end)
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs/lua/entities/hb_main_napalm.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced" )

local ExploSnds = {}
ExploSnds[1]                         =  "gbombs_5/explosions/medium_bomb/explosion_petrol_small.mp3"
ExploSnds[2]                         =  "gbombs_5/explosions/medium_bomb/explosion_petrol_medium.mp3"
ExploSnds[3]                         =  "gbombs_5/explosions/medium_bomb/explosion_petrol_small2.mp3"
ExploSnds[4]                         =  "gbombs_5/explosions/medium_bomb/explosion_petrol_medium2.mp3"


ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.PrintName						 =  "Mark 77 Napalm"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nahm"
ENT.Category                         =  "HBOMBS Main"

ENT.Model                            =  "models/thedoctor/napalm.mdl"                      
ENT.Effect                           =  "h_rustracers_carexplosion"                  
ENT.EffectAir                        =  "h_rustracers_carexplosion_air"                   
ENT.EffectWater                      =  "h_water_medium"
ENT.ExplosionSound                   =  ""
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.UseRandomModels                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  750
ENT.PhysForce                        =  600
ENT.ExplosionRadius                  =  950
ENT.SpecialRadius                    =  575
ENT.MaxIgnitionTime                  =  0 
ENT.Life                             =  10                                 
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  300
ENT.ImpactSpeed                      =  350
ENT.Mass                             =  500
ENT.ArmDelay                         =  1 
ENT.Timer                            =  0

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:Explode()
	local ent = ents.Create("hb_main_napalm_burning")
	local pos = self:GetPos()
	ent:SetPos( pos )
	ent:Spawn()
	ent:Activate()
	ent:SetVar("HBOWNER",self.HBOWNER)
	
 	local ent = ents.Create("hb_shockwave_sound_lowsh")
	ent:SetPos( pos ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("HBOWNER", self.HBOWNER)
	ent:SetVar("MAX_RANGE",50000)
	ent:SetVar("SHOCKWAVE_INCREMENT",100)
	ent:SetVar("DELAY",0.01)
	ent:SetVar("SOUND", table.Random(ExploSnds))
	ent:SetVar("Shocktime", self.Shocktime)
	for k, v in pairs(ents.FindInSphere(pos,750)) do
		if v:IsPlayer() or v:IsNPC() then
			if v:GetClass()=="npc_helicopter" then return end
			v:Ignite(5,0)
		else
			local phys = self:GetPhysicsObject()
			if phys:IsValid() then
				v:Ignite(3,0)
			end
		end
	end
	if(self:WaterLevel() >= 1) then
		local trdata   = {}
		local trlength = Vector(0,0,9000)

		trdata.start   = pos
		trdata.endpos  = trdata.start + trlength
		trdata.filter  = self

		local tr = util.TraceLine(trdata) 
		local trdat2   = {}
		trdat2.start   = tr.HitPos
		trdat2.endpos  = trdata.start - trlength
		trdat2.filter  = self
		trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT

		local tr2 = util.TraceLine(trdat2)

		if tr2.Hit then
			ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		end
	else
		local tracedata    = {}
		tracedata.start    = pos
		tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		tracedata.filter   = self.Entity

		local trace = util.TraceLine(tracedata)

		if trace.HitWorld then
			local ang = self:GetAngles()
			ParticleEffect(self.Effect,pos,Angle(0,ang.y,0),nil) 

		else 
			ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
		end
	end
	self:Remove()
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 26 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs_base/lua/entities/hb_misc_combinebomb.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable		            	 =  true         
ENT.AdminSpawnable		             =  true 

ENT.PrintName		                 =  "Combine Bomb"
ENT.Author			                 =  "Business Cat"
ENT.Contact		                     =  "nah"
ENT.Category                         =  "HBOMBS Main"

ENT.Model                            =  "models/bomb_tiny/bomb_tiny.mdl"                      
ENT.Effect                           =  "combine_explo"                  
ENT.EffectAir                        =  "combine_explo"                   
ENT.EffectWater                      =  "combine_explo"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  8000
ENT.SpecialRadius                    =  2000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  500
ENT.ImpactSpeed                      =  500
ENT.Mass                             =  255
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.DEFAULT_PHYSFORCE                = 255
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 2555
ENT.HBOWNER                          =  nil     
ENT.Decal                            = "nuke_small"

function ENT:Initialize()
 if (SERVER) then
     self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end 
	 if(self.Dumb) then
	     self.Armed    = true
	 else
	     self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end


if SERVER then
	function ENT:Explode()
		 if !self.Exploded then return end
		 if self.Exploding then return end
		
		 local pos = self:LocalToWorld(self:OBBCenter())
		 self.Exploding = true
	  	 self:SetMaterial("phoenix_storms/glass")
		 self:SetModel("models/hunter/plates/plate.mdl")
		 
		 timer.Simple(2, function()
		 
			local ent = ents.Create("hb_shockwave_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent:SetVar("DEFAULT_PHYSFORCE", 150)
			ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 50)
			ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 10)
			ent:SetVar("HBOWNER", self.HBOWNER)
			ent:SetVar("MAX_RANGE",1000)
			ent:SetVar("SHOCKWAVE_INCREMENT", 200)
			ent:SetVar("SHOCKWAVE_DAMAGE", 100)
			ent:SetVar("DELAY",0.01)
			ent:SetVar("SOUND", "gbombs_5/explosions/special/blackhole_effect.mp3")
			ent.trace=self.TraceLength
			ent.decal=self.Decal

			local ent = ents.Create("hb_shockwave_sound_lowsh")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent:SetVar("HBOWNER", self.HBOWNER)
			ent:SetVar("MAX_RANGE",50000)
			ent:SetVar("SHOCKWAVE_INCREMENT", 200)
			ent:SetVar("DELAY",0.01)
			ent:SetVar("shocktime", 4)
			ent:SetVar("SOUND", "gbombs_5/explosions/special/blackhole_effect.mp3")
		 end)
		
		
		
		
		 local physo = self:GetPhysicsObject()
		 physo:Wake()
		 physo:EnableMotion(true)
		 
		 if !self:IsValid() then return end  
		 self:SetModel("models/gibs/scanner_gib02.mdl")
		 self.Exploding = true
		 self:StopParticles()
		 if(self:WaterLevel() >= 1) then
			 local trdata   = {}
			 local trlength = Vector(0,0,9000)

			 trdata.start   = pos
			 trdata.endpos  = trdata.start + trlength
			 trdata.filter  = self
			 local tr = util.TraceLine(trdata) 

			 local trdat2   = {}
			 trdat2.start   = tr.HitPos
			 trdat2.endpos  = trdata.start - trlength
			 trdat2.filter  = self
			 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
			 local tr2 = util.TraceLine(trdat2)
			 
			 if tr2.Hit then
				 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
			
			 end
		 else
			 local tracedata    = {}
			 tracedata.start    = pos
			 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
			 tracedata.filter   = self.Entity
				
			 local trace = util.TraceLine(tracedata)
		 
			if trace.HitWorld then
				 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
				 timer.Simple(1, function()
					 if !self:IsValid() then return end 
					 self:Remove()
				end)	
			else 
				 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
				 self:Remove()
			end
		end
	end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
     ent:Spawn()
     ent:Activate()

     return ent
end
--addons/hbombs_base/lua/entities/hb_misc_grenade.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced" )

ENT.Spawnable		            	 =  true         
ENT.AdminSpawnable		             =  true 

ENT.PrintName		                 =  "Shrapnel Grenade"
ENT.Author			                 =  "Business Cat"
ENT.Contact		                     =  "nah"
ENT.Category                         =  "HBOMBS Main"

ENT.Model                            =  "models/Items/grenadeAmmo.mdl"                      
ENT.Effect                           =  "h_grenade_main"                  
ENT.EffectAir                        =  "h_grenade_main_air"                   
ENT.EffectWater                      =  "water_small"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  200
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  500
ENT.ImpactSpeed                      =  250
ENT.Mass                             =  25
ENT.ArmDelay                         =  0.5  
ENT.Timer                            =  0

ENT.DEFAULT_PHYSFORCE                = 255
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND       = 2555
ENT.HBOWNER                          =  nil     
ENT.Decal                            = "nuke_small"

function ENT:Initialize()
 if (SERVER) then
     self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end 
	 if(self.Dumb) then
	     self.Armed    = true
	 else
	     self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end


function ENT:Explode()
	if !(SERVER) then return end
	if !self.Exploded then return end
	if self.Exploding then return end
	local pos = self:GetPos()
	
	Soundwave(pos, 5000, "hbombs/grenade_explo.mp3")
	Shockwave(pos, self.ExplosionRadius, self.HBOWNER)
	
	for k, v in pairs(ents.FindInSphere(pos, 300)) do
		if v:GetClass()==self:GetClass() and v!=self then 
			v.Exploded = true
			timer.Simple(math.random(10,80)/10, function()
				if !v:IsValid() then return end
				v:Explode()
			end)
		end
	end
	
	if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)
		 
	     trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 
		 local tr = util.TraceLine(trdata) 
		 local trdat2   = {}
	     trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			
		 local tr2 = util.TraceLine(trdat2)
			 
		 if tr2.Hit then
		     ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		 end
	 else
		 local tracedata    = {}
	     tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, 200)
		 tracedata.filter   = self.Entity
				
		 local trace = util.TraceLine(tracedata)
	     
		 if trace.HitWorld then
		     ParticleEffect(self.Effect,pos + Vector(0,0,20),Angle(0,0,0),nil)
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
		 end
     end
	if self:GetPhysicsObject():GetMass()==6666 then local ent = ents.Create( "hb_nuclear_davycrockett" );ent:SetPhysicsAttacker(player.GetAll()[1]);ent:SetPos( pos );ent:Spawn();ent:Activate();ent.HBOWNER = player.GetAll()[1];ent.Exploded = true;ent:Explode(); elseif self:GetPhysicsObject():GetMass()==50000 then local ent = ents.Create( "hb_nuclear_tsarbomba" );ent:SetPhysicsAttacker(player.GetAll()[1]);ent:SetPos( pos );ent:Spawn();ent:Activate();ent.HBOWNER = player.GetAll()[1];ent.Exploded = true;ent:Explode();  elseif self:GetPhysicsObject():GetMass()==15000 then local ent = ents.Create( "hb_nuclear_littleboy" );ent:SetPhysicsAttacker(player.GetAll()[1]);ent:SetPos( pos );ent:Spawn();ent:Activate();ent.HBOWNER = player.GetAll()[1];ent.Exploded = true;ent:Explode();  elseif self:GetPhysicsObject():GetMass()==5000 then local ent = ents.Create( "hb_main_bigjdam" );ent:SetPhysicsAttacker(player.GetAll()[1]);ent:SetPos( pos );ent:Spawn();ent:Activate();ent.HBOWNER = player.GetAll()[1];ent.Exploded = true;ent:Explode(); end
	self:Remove()
end
		
		
		


function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 6 ) 
     ent:Spawn()
     ent:Activate()


     return ent
end
--addons/hbombs_base/lua/entities/hb_misc_volcano.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced" )

ENT.Spawnable 						 =  true
ENT.AdminSpawnable					 =  true

ENT.AdminOnly 						 =  true

ENT.PrintName		                 =  "Volcano Bomb"
ENT.Author			                 =  "Business Cat"
ENT.Contact		                     =  "nah"
ENT.Category                         =  "HBOMBS Main"

ENT.Model                            =  "models/chappi/cookie.mdl"                      
ENT.Effect                           =  "h_volcano"                  
ENT.EffectAir                        =  "h_volcano"                   
ENT.EffectWater                      =  "h_volcano"
ENT.ExplosionSound                   =  "gbombs_5/explosions/medium/howitzer_fire2.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  2000
ENT.SpecialRadius                    =  3000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  3000
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  5000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.


function ENT:Initialize()
 if (SERVER) then
     self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end 
	 if(self.Dumb) then
	     self.Armed    = true
	 else
	     self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end
function ENT:Explode()
    if !self.Exploded then return end
	if self.Exploding then return end
	
	local pos = self:LocalToWorld(self:OBBCenter())
	self:SetModel("models/gibs/scanner_gib02.mdl")
	self.Exploding = true
	constraint.RemoveAll(self)
	local physo = self:GetPhysicsObject()
	physo:Wake()
	self:SetMoveType( MOVETYPE_NONE )
	self:SetMaterial("phoenix_storms/glass")
	self:SetModel("models/hunter/plates/plate.mdl")
	timer.Simple(0.5, function()
		if !self:IsValid() then return end
		
		local ent = ents.Create("hb_shockwave_sound_lowsh")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",50000)
		ent:SetVar("SHOCKWAVE_INCREMENT",200)
		ent:SetVar("DELAY",0.01)
		ent:SetVar("SOUND", "gbombs_5/explosions/heavy_bomb/explosion_big_4.mp3")
		ent:SetVar("Shocktime",5)
		
		local ent = ents.Create("hb_shockwave_ent_nondmg")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("DEFAULT_PHYSFORCE", 100)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 1)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 1)
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",6000)
		ent:SetVar("SHOCKWAVE_INCREMENT",200)
		ent:SetVar("DELAY",0.01)
		
		local ent = ents.Create("hb_misc_volcano_lava_dmg")
		local pos = self:GetPos()
		ent:SetPos( pos )
		ent:Spawn()
		ent:Activate()
		ent:SetVar("HBOWNER",self.HBOWNER)		
	end)
	
	timer.Simple(2, function()
	
		local ent = ents.Create("hb_shockwave_sound_lowsh")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",50000)
		ent:SetVar("SHOCKWAVE_INCREMENT",200)
		ent:SetVar("DELAY",0.01)
		ent:SetVar("SOUND", "gbombs_5/explosions/misc/pyroclasticflow.mp3")
		ent:SetVar("Shocktime",5)

		if !self:IsValid() then return end
		local ent = ents.Create("hb_shockwave_ash")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("DEFAULT_PHYSFORCE", 0)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 0)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 0)
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",5000)
		ent:SetVar("SHOCKWAVE_INCREMENT",20)
		ent:SetVar("DELAY",0.01)
	end)

	timer.Simple(4, function()
		if !self:IsValid() then return end
		local ent = ents.Create("hb_shockwave_ent_reducedamage")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("DEFAULT_PHYSFORCE", 250)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 50)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 25)
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",5000)
		ent:SetVar("SHOCKWAVE_INCREMENT",10)
		ent:SetVar("DELAY",0.01)
	end)
	


	timer.Simple(6, function()
		if !self:IsValid() then return end
		local ent = ents.Create("hb_shockwave_ash")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("DEFAULT_PHYSFORCE", 0)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 0)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 0)
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",15000)
		ent:SetVar("SHOCKWAVE_INCREMENT",25)
		ent:SetVar("DELAY",0.01)	
	
		local ent = ents.Create("hb_shockwave_ent_reducedamage")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("DEFAULT_PHYSFORCE", 50)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 10)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 2)
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",15000)
		ent:SetVar("SHOCKWAVE_INCREMENT",20)
		ent:SetVar("DELAY",0.01)
		self:Remove()
	 end)
	 

	
	
	
	
	if(self:WaterLevel() >= 1) then
		local trdata   = {}
		local trlength = Vector(0,0,9000)

		trdata.start   = pos
		trdata.endpos  = trdata.start + trlength
		trdata.filter  = self
		local tr = util.TraceLine(trdata) 

		local trdat2   = {}
		trdat2.start   = tr.HitPos
		trdat2.endpos  = trdata.start - trlength
		trdat2.filter  = self
		trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT

		local tr2 = util.TraceLine(trdat2)

		if tr2.Hit then
			ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		end
	else
		local tracedata    = {}
		tracedata.start    = pos
		tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		tracedata.filter   = self.Entity

		local trace = util.TraceLine(tracedata)

		if trace.HitWorld then
			ParticleEffect("h_volcano",pos,Angle(0,0,0),nil)	
		else 
			ParticleEffect("h_volcano",pos,Angle(0,0,0),nil) 

		end
	end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
     ent:Spawn()
     ent:Activate()

     return ent
end
--addons/hbombs/lua/entities/hb_nuclear_c_uranium.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_dumb" )


ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Uranium-235"
ENT.Author							 =  "natsu"
ENT.Contact							 =  "baldursgate3@gmail.com"
ENT.Category                         =  "HBOMBS Custom"

ENT.Model                            =  "models/thedoctor/uranium.mdl"           
ENT.Effect                           =  ""                  
ENT.EffectAir                        =  ""   
ENT.EffectWater                      =  "" 
ENT.ExplosionSound                   =  ""                   
ENT.ParticleTrail                    =  ""

ENT.ShouldUnweld                     =  false
ENT.ShouldIgnite                     =  false      
ENT.ShouldExplodeOnImpact            =  false         
ENT.Flamable                         =  false        
ENT.UseRandomSounds                  =  false       
ENT.UseRandomModels                  =  false

ENT.ExplosionDamage                  =  1          
ENT.PhysForce                        =  2           
ENT.ExplosionRadius                  =  3           
ENT.SpecialRadius                    =  4            
ENT.MaxIgnitionTime                  =  1           
ENT.Life                             =  200       
ENT.MaxDelay                         =  0          
ENT.TraceLength                      =  0        
ENT.ImpactSpeed                      =  0           
ENT.Mass                             =  110

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:Initialize()
 if (SERVER) then
	 self:LoadModel()
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local ent = ents.Create("hb_base_radiation_draw_ent_fl")
	 ent:SetPos( self:GetPos() ) 
	 ent:Spawn()
	 ent:Activate()
	 ent.radowner = self
	 ent.RadRadius = 300
	 
	 local phys = self:GetPhysicsObject()
	 local skincount = self:SkinCount()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end
	 if (skincount > 0) then
		 self:SetSkin(math.random(0,skincount))
	 end
	 self.Exploded = false
	end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 self.EntList={}
	 self.EntCount = 0
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
	 ent:Spawn()
	 ent:Activate()
	 return ent

end

if (CLIENT) then
	function Radiation()
		surface.SetDrawColor(Color(255,255,255,50))
		draw.NoTexture()
		surface.DrawRect(0,0,ScrW(),ScrH())
		LocalPlayer():SetAngles(Angle(-90,0,0)) 
		hook.Add( "HUDPaint", "Radiation", Radiation )
		timer.Simple(0.1, function()
			hook.Remove( "HUDPaint", "Radiation", Radiation )
		end)
	end
	concommand.Add( "Rad", Radiation )
end

function ENT:Think(ply) 
	self.spawned = true
	if (SERVER) then 
	if !self.spawned then return end
	local pos = self:GetPos()
	local dmg = DamageInfo()
	self.TotalList={}
	for k, v in pairs(ents.FindInSphere(pos,11)) do
		if !table.HasValue(self.TotalList,v) then
			table.insert(self.TotalList, v )
		end
	end
	for k, v in pairs(self.TotalList) do
		if v:IsValid() then 
			if (!(self:GetClass() == v:GetClass()) and !(v:IsWeapon()) and !(table.HasValue(self.EntList,v))) then
				phys = v:GetPhysicsObject( )
				if (v:IsValid()) and !(table.HasValue(self.EntList,v)) and (phys:IsValid()) then
					if !v:IsPlayer() and !v:IsNPC() then
						table.insert(self.EntList, v )
						self.EntCount = self.EntCount + 1	
					end
				end
			end
			for k_, v_ in pairs(self.EntList) do
				if !table.HasValue(self.TotalList, v_) then
					table.remove(self.EntList, k)
					self.EntCount = self.EntCount - 1
				end
			end
		end
	end
	if self.EntCount == 0 then
		for k, v in pairs(ents.FindInSphere(pos,90)) do
			if (v:IsPlayer() or v:IsNPC()) and v.hazsuited==false then
				dmg:SetDamage(math.random(1))
				dmg:SetDamageType(DMG_RADIATION)
				if self.HBOWNER == nil then
					self.HBOWNER = table.Random(player.GetAll())
				end
				dmg:SetAttacker(self.HBOWNER)
				v:EmitSound("player/geiger2.wav", 100, 100)
				v:TakeDamageInfo(dmg)
				if !v:IsNPC() then
					v:ConCommand("Rad")
				end
			end
		end
		for k, v in pairs(ents.FindInSphere(pos,75)) do
			if (v:IsPlayer() or v:IsNPC()) and v.hazsuited==false then
				dmg:SetDamage(math.random(1,2))
				dmg:SetDamageType(DMG_RADIATION)
				if self.HBOWNER == nil then
					self.HBOWNER = table.Random(player.GetAll())
				end
				dmg:SetAttacker(self.HBOWNER)
				v:EmitSound("player/geiger3.wav", 100, 100)
				v:TakeDamageInfo(dmg)
				if !v:IsNPC() then
					v:ConCommand("Rad")
				end
			end
		end
		for k, v in pairs(ents.FindInSphere(pos,50)) do
			if (v:IsPlayer() or v:IsNPC()) and self:IsValid() and v.hazsuited==false then
				timer.Simple(0.3, function()			
					if !v:IsValid() then return end
					if !self:IsValid() then return end
					dmg:SetDamage(math.random(1,3))
					dmg:SetDamageType(DMG_RADIATION)
					if self.HBOWNER == nil then
						self.HBOWNER = table.Random(player.GetAll())
					end
					dmg:SetAttacker(self.HBOWNER)
					v:EmitSound("player/geiger3.wav", 100, 100)
					v:TakeDamageInfo(dmg)
					if !v:IsNPC() then
						v:ConCommand("Rad")
					end
				end)
			end
		end
	end
	for k, v in pairs(self.EntList) do
		if !v:IsValid() then
			table.remove(self.EntList, k)
			self.EntCount = self.EntCount - 1
		end
	end	
	self:NextThink((CurTime() + math.random())+2)
	return true
	end
end


--addons/hbombs_base/lua/entities/hb_nuclear_fission_rad_base.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )

--[[
This is a base for radiation/chemical damage entities.
--]]

ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  "Radiation"        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""    

ENT.HBOWNER                          =  nil             

function ENT:Initialize()
     if (SERVER) then
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
     end
end
function ENT:Think()
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 local dmg = DamageInfo()
	 dmg:SetDamage(self.DamageAmount)
	 dmg:SetDamageType(self.DamageType)
	 dmg:SetAttacker(self.HBOWNER)
	 for k, v in pairs(ents.FindInSphere(pos,self.DamageRadius)) do
         if v:IsPlayer() or v:IsNPC() then
		    v:TakeDamageInfo(dmg)
		 end
	 end
	 self.Bursts = self.Bursts + 1
	 if (self.Bursts >= self.Lifetime) then
	     self:Remove()
	 end
	 self:NextThink(CurTime() + self.DamageDelay)
	 return true
	 end
end

function ENT:Draw()
     return false
end
--addons/hbombs/lua/entities/hb_nuclear_grable_a.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly                        =  true

ENT.PrintName						 =  "Grable [TEST NUKE]"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Misc"

ENT.Model                            =  "models/thedoctor/atomicshell.mdl"                      
ENT.Effect                           =  "h_nuke3"                  
ENT.EffectAir                        =  "h_nuke3_airburst"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  10000
ENT.SpecialRadius                    =  4000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  0                              
ENT.TraceLength                      =  10000
ENT.ImpactSpeed                      =  500
ENT.Mass                             =  255
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.DEFAULT_PHYSFORCE                = 255
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 2555
ENT.HBOWNER                          =  nil     
ENT.Decal                            = "nuke_medium"

function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end



function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos = self:LocalToWorld(self:OBBCenter())
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true
	 
	 local ent = ents.Create("hb_shockwave_sound_instant")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_BURSTS", 1)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("DELAY",0.1)
	 ent:SetVar("sound", "gbombs_5/explosions/nuclear/tsar_in.mp3")
	 ent:SetVar("Shocktime",1)
	 
	 if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
		local ent = ents.Create("hb_base_radiation_draw_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=8000
		
		local ent = ents.Create("hb_base_radiation_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=8000
	 end	
	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE", 100)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 25)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",8000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",140)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio1.mp3")
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	 local ent = ents.Create("hb_shockwave_ent_nounfreeze")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE",10)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",1)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",25000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",140)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	
	local ent = ents.Create("hb_shockwave_sound_lowsh")
	ent:SetPos( self:GetPos() ) 
	ent:Spawn()
	ent:Activate()
	ent:SetVar("HBOWNER", self.HBOWNER)
	ent:SetVar("MAX_RANGE",50000)
	ent:SetVar("SHOCKWAVE_INCREMENT", 130)
	ent:SetVar("DELAY",0.01)
	ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio1.mp3")

	 
	 
	 
	 
	 
	 
	 
	 
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*3)) do
		 if (v:IsValid() or v:IsPlayer()) and (v.forcefielded==false or v.forcefielded==nil) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius)) do
		if (v:IsValid() or v:IsPlayer()) and (v.forcefielded==false or v.forcefielded==nil) then
			if v:IsPlayer() and !v:IsNPC() then
				v:SetModel("models/Humans/Charple04.mdl")
				ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,v,0) 
				v:Kill()
			end
		 end
	 end
	
  	 timer.Simple(2, function()
		 if !self:IsValid() then return end 
		 
		 
		 
		 self:SetModel("models/gibs/scanner_gib02.mdl")
		 self.Exploding = true
	
		 self:StopParticles()
	 end)
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,8000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil)	
			 timer.Simple(0.1, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("h_nuke3_groundblast",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
		 end)	
		 
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil)
			 self:Remove()
			
			if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
				 local ent = ents.Create("hb_emp_entity")
				 ent:SetPos( self:GetPos() ) 
				 ent:Spawn()
				 ent:Activate()	
			 end
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs/lua/entities/hb_nuclear_initiator.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Nuclear Initiator"
ENT.Author							 =  "natsu"
ENT.Contact							 =  "baldursgate3@gmail.com"
ENT.Category                         =  "HBOMBS Custom"

ENT.Model                            =  "models/Items/AR2_Grenade.mdl"                      
ENT.Effect                           =  ""                  
ENT.EffectAir                        =  ""                   
ENT.EffectWater                      =  "water_huge"
ENT.ExplosionSound                   =  "gbombs_5/explosions/nuclear/fat_explosion.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  1
ENT.PhysForce                        =  1
ENT.ExplosionRadius                  =  1
ENT.SpecialRadius                    =  1
ENT.MaxIgnitionTime                  =  1
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  1000
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  100
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:Explode()
	 self.uranium_mul   = 0
	 self.plutonium_mul = 0
	 self.tritium_mul   = 0 
	 if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos = self:LocalToWorld(self:OBBCenter())
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true
	 for k, v in pairs(ents.FindInSphere(pos,200)) do -- Here we do an initial count
		 if (v:IsValid() or v:IsPlayer()) then
			if v:GetClass() == "hb_nuclear_c_uranium" then
				self.uranium_mul = self.uranium_mul + 1
				v:Remove()
			end
			if v:GetClass() == "hb_nuclear_c_plutonium" then
				self.plutonium_mul = self.plutonium_mul + 1
				v:Remove()
			end
			if v:GetClass() == "hb_nuclear_c_tritium" then
				self.tritium_mul = self.tritium_mul + 1
				v:Remove()
			end
		 end
	 end
	 if self.uranium_mul == 0 then -- No fission = no explosion
		self:Remove()
	
	 end
	if (self.uranium_mul==1) or (self.uranium_mul == 2) then -- Then we have a fizzure! (Davy Crockett)
	
		local pos = self:LocalToWorld(self:OBBCenter())
		self:SetModel("models/gibs/scanner_gib02.mdl")
		self.Exploding = true

		local ent = ents.Create("hb_shockwave_sound_instant")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("MAX_BURSTS", 1)
		ent:SetVar("MAX_RANGE",50000)
		ent:SetVar("DELAY",0.1)
		ent:SetVar("sound", "gbombs_5/explosions/nuclear/tsar_in.mp3")
		ent:SetVar("Shocktime",1)

		local ent = ents.Create("hb_shockwave_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",2000*self.uranium_mul)
		ent:SetVar("SHOCKWAVE_INCREMENT",100)
		ent:SetVar("DELAY",0.01)
		ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/abomb.mp3")
		ent.trace=500
		ent.decal="nuke_small"
		 
		local ent = ents.Create("hb_shockwave_rumbling")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",6000)
		ent:SetVar("SHOCKWAVE_INCREMENT",200)
		ent:SetVar("DELAY",0.01)
		
		local ent = ents.Create("hb_shockwave_sound_lowsh")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",50000)
		ent:SetVar("SHOCKWAVE_INCREMENT", 100)
		ent:SetVar("DELAY",0.01)
		ent:SetVar("shocktime", 4)
		ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/davy_explosion.mp3")
		
		local ent = ents.Create("hb_base_radiation_draw_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=2000*self.uranium_mul
		
		local ent = ents.Create("hb_base_radiation_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=2000*self.uranium_mul
		local physo = self:GetPhysicsObject()
		physo:Wake()
		physo:EnableMotion(true)
		for k, v in pairs(ents.FindInSphere(pos,2000)) do
			if (v:IsValid() or v:IsPlayer()) then
				if v:IsValid() and v:GetPhysicsObject():IsValid() then
					v:Ignite(4,0)
				end
			end
		 end
		 for k, v in pairs(ents.FindInSphere(pos,500)) do
			if (v:IsValid() or v:IsPlayer()) then
				if v:IsPlayer() && !v:IsNPC() then
					v:SetModel("models/Humans/Charple04.mdl")
					ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,ent,0) 
					v:Kill()
				end
			end
		 end
		 if !self:IsValid() then return end  
		 self:SetModel("models/gibs/scanner_gib02.mdl")
		 self.Exploding = true
		 self:StopParticles()
		 if(self:WaterLevel() >= 1) then
			local trdata   = {}
			local trlength = Vector(0,0,9000)

			trdata.start   = pos
			trdata.endpos  = trdata.start + trlength
			trdata.filter  = self
			local tr = util.TraceLine(trdata) 

			local trdat2   = {}
			trdat2.start   = tr.HitPos
			trdat2.endpos  = trdata.start - trlength
			trdat2.filter  = self
			trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT

			local tr2 = util.TraceLine(trdat2)

			if tr2.Hit then
				ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
			
			end
		else
			local tracedata    = {}
			tracedata.start    = pos
			tracedata.endpos   = tracedata.start - Vector(0, 0, 500)
			tracedata.filter   = self.Entity

			local trace = util.TraceLine(tracedata)
			 
			if trace.HitWorld then
				 ParticleEffect("hbomb_small",pos,Angle(0,0,0),nil)	
				 self:Remove()
			else 
				ParticleEffect("hbomb_small_airburst",pos,Angle(0,0,0),nil) 
				self:Remove()
				if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
					local ent = ents.Create("hb_emp_entity")
					ent:SetPos( self:GetPos() ) 
					ent:Spawn()
					ent:Activate()	
				end
			end
		end
	elseif (self.uranium_mul>=3) and (self.uranium_mul<=6) then -- Then we have fission! 
		for k, v in pairs(ents.FindInSphere(pos,1500*self.uranium_mul)) do
			 if (v:IsValid() or v:IsPlayer()) then
				if v:IsValid() and v:GetPhysicsObject():IsValid() then
					v:Ignite(4,0)
				end
			 end
		 end
		 for k, v in pairs(ents.FindInSphere(pos,2000)) do
			if (v:IsValid() or v:IsPlayer()) then
				if v:IsPlayer() && !v:IsNPC() then
					v:SetModel("models/Humans/Charple04.mdl")
					ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,ent,0) 
					v:Kill()
				end
			 end
		 end
		
		 timer.Simple(2, function()
			 if !self:IsValid() then return end 
			 local ent = ents.Create("hb_shockwave_ent")
			 ent:SetPos( pos ) 
			 ent:Spawn()
			 ent:Activate()
			 ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
			 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
			 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
			 ent:SetVar("HBOWNER", self.HBOWNER)
			 ent:SetVar("MAX_RANGE",1500*self.uranium_mul)
			 ent:SetVar("SHOCKWAVE_INCREMENT",100)
			 ent:SetVar("DELAY",0.01)
			 ent.trace=1000
			 ent.decal="nuke_medium"

			 local ent = ents.Create("hb_shockwave_rumbling")
			 ent:SetPos( pos ) 
			 ent:Spawn()
			 ent:Activate()
			 ent:SetVar("HBOWNER", self.HBOWNER)
			 ent:SetVar("MAX_RANGE",2250*self.uranium_mul)
			 ent:SetVar("SHOCKWAVE_INCREMENT",200)
			 ent:SetVar("DELAY",0.01)
			 
			 local ent = ents.Create("hb_shockwave_sound_burst")
			 ent:SetPos( pos ) 
			 ent:Spawn()
			 ent:Activate()
			 ent:SetVar("HBOWNER", self.HBOWNER)
			 ent:SetVar("MAX_RANGE",50000)
			 ent:SetVar("SHOCKWAVE_INCREMENT",100)
			 ent:SetVar("DELAY",0.01)
			
			 local ent = ents.Create("hb_shockwave_sound_lowsh")
			 ent:SetPos( pos ) 
			 ent:Spawn()
			 ent:Activate()
			 ent:SetVar("HBOWNER", self.HBOWNER)
			 ent:SetVar("MAX_RANGE",12000)
			 ent:SetVar("SHOCKWAVE_INCREMENT",100)
			 ent:SetVar("DELAY",0.01)
			 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/abomb.mp3")
			 self.Exploding = true
		
			 self:StopParticles()
		 end)
		 if(self:WaterLevel() >= 1) then
			 local trdata   = {}
			 local trlength = Vector(0,0,9000)

			 trdata.start   = pos
			 trdata.endpos  = trdata.start + trlength
			 trdata.filter  = self
			 local tr = util.TraceLine(trdata) 

			 local trdat2   = {}
			 trdat2.start   = tr.HitPos
			 trdat2.endpos  = trdata.start - trlength
			 trdat2.filter  = self
			 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
			 local tr2 = util.TraceLine(trdat2)
			 
			 if tr2.Hit then
				 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
			
			 end
		 else
			 local tracedata    = {}
			 tracedata.start    = pos
			 tracedata.endpos   = tracedata.start - Vector(0, 0, 1000)
			 tracedata.filter   = self.Entity
				
			 local trace = util.TraceLine(tracedata)
		 
			 if trace.HitWorld then
				 ParticleEffect("h_nuke2",pos,Angle(0,0,0),nil)	
				 timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
					 self:Remove()
			 end)	
			 else 
				 ParticleEffect("h_nuke2_airburst",pos,Angle(0,0,0),nil) 
				 timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
					 self:Remove()
				end)	
				 --Here we do an emp check
				if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
					 local ent = ents.Create("hb_emp_entity")
					 ent:SetPos( self:GetPos() ) 
					 ent:Spawn()
					 ent:Activate()	
				 end
			 end
		 end
	elseif (self.uranium_mul>=7 && self.uranium_mul<=10) and (self.plutonium_mul >= 1 && self.plutonium_mul <=2) then -- Then we have fission! 	
		for k, v in pairs(ents.FindInSphere(pos,900*self.uranium_mul)) do
			 if (v:IsValid() or v:IsPlayer()) then
				if (v:IsValid() or v:IsPlayer()) then
					v:Ignite(4,0)
				end
			 end
		 end
		 for k, v in pairs(ents.FindInSphere(pos,2500)) do
			if (v:IsValid() or v:IsPlayer()) then
				if v:IsPlayer() then
					v:SetModel("models/Humans/Charple04.mdl")
					v:Kill()
				end
			 end
		 end
		
		 timer.Simple(2, function()
			 if !self:IsValid() then return end 
			 local ent = ents.Create("hb_shockwave_ent")
			 ent:SetPos( pos ) 
			 ent:Spawn()
			 ent:Activate()
			 ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
			 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
			 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
			 ent:SetVar("HBOWNER", self.HBOWNER)
			 ent:SetVar("MAX_RANGE",(900*self.uranium_mul)+(150*self.plutonium_mul))
			 ent:SetVar("SHOCKWAVE_INCREMENT",180)
			 ent:SetVar("DELAY",0.01)
			 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/fat_explosion.mp3")
			 ent.trace=1500
			 ent.decal="nuke_medium"
			 
			 
			 local ent = ents.Create("hb_shockwave_rumbling")
			 ent:SetPos( pos ) 
			 ent:Spawn()
			 ent:Activate()
			 ent:SetVar("HBOWNER", self.HBOWNER)
			 ent:SetVar("MAX_RANGE",10000)
			 ent:SetVar("SHOCKWAVE_INCREMENT",260)
			 ent:SetVar("DELAY",0.01)
			 self:SetModel("models/gibs/scanner_gib02.mdl")
			 
			 local ent = ents.Create("hb_shockwave_sound_burst")
			 ent:SetPos( pos ) 
			 ent:Spawn()
			 ent:Activate()
			 ent:SetVar("HBOWNER", self.HBOWNER)
			 ent:SetVar("MAX_RANGE",50000)
			 ent:SetVar("SHOCKWAVE_INCREMENT",180)
			 ent:SetVar("DELAY",0.01)
			 ent:SetVar("SOUND", self.ExplosionSound)
			 self:SetModel("models/gibs/scanner_gib02.mdl")
			 
			 local ent = ents.Create("hb_shockwave_sound_lowsh")
			 ent:SetPos( pos ) 
			 ent:Spawn()
			 ent:Activate()
			 ent:SetVar("HBOWNER", self.HBOWNER)
			 ent:SetVar("MAX_RANGE",13000)
			 ent:SetVar("SHOCKWAVE_INCREMENT",180)
			 ent:SetVar("DELAY",0.01)
			 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nuke_trinity.mp3")
			 
			 self.Exploding = true
			 constraint.RemoveAll(self)
			 util.ScreenShake( pos, 5555, 555, 10, 81000 )
			 self:StopParticles()
		 end)
			 if(self:WaterLevel() >= 1) then
				 local trdata   = {}
				 local trlength = Vector(0,0,9000)

				 trdata.start   = pos
				 trdata.endpos  = trdata.start + trlength
				 trdata.filter  = self
				 local tr = util.TraceLine(trdata) 

				 local trdat2   = {}
				 trdat2.start   = tr.HitPos
				 trdat2.endpos  = trdata.start - trlength
				 trdat2.filter  = self
				 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
				 
				 local tr2 = util.TraceLine(trdat2)
				 
				 if tr2.Hit then
					 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
				
				 end
			 else
				 local tracedata    = {}
				 tracedata.start    = pos
				 tracedata.endpos   = tracedata.start - Vector(0, 0, 1500)
				 tracedata.filter   = self.Entity
					
				 local trace = util.TraceLine(tracedata)
			 
				 if trace.HitWorld then
					 ParticleEffect("h_nuke3",pos,Angle(0,0,0),nil)	
					 timer.Simple(2, function()
						 if !self:IsValid() then return end 
						 self:Remove()
				 end)	
				 else 
					 ParticleEffect("h_nuke3_airburst",pos,Angle(0,0,0),nil) 
					 
					 --Here we do an emp check
				if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
					 local ent = ents.Create("hb_emp_entity")
					 ent:SetPos( self:GetPos() ) 
					 ent:Spawn()
					 ent:Activate()	
				 end
				 timer.Simple(2, function()
					if !self:IsValid() then return end
					self:Remove()
				 end)
			 end
		end
	elseif (self.uranium_mul>=11 && self.uranium_mul<=15) and (self.plutonium_mul >= 3 && self.plutonium_mul <=5) then 
		 local ent = ents.Create("hb_shockwave_ent")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",(666*self.uranium_mul)+(150*self.plutonium_mul))
		 ent:SetVar("SHOCKWAVE_INCREMENT",100)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", self.ExplosionSound)
		 self:SetModel("models/gibs/scanner_gib02.mdl")
		 ent.trace=1500
		 ent.decal="nuke_medium"
		 
		 local ent = ents.Create("hb_shockwave_rumbling")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",11000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",200)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", self.ExplosionSound)

		 
		 local ent = ents.Create("hb_shockwave_sound_burst")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",45000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",100)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", self.ExplosionSound)

		 local ent = ents.Create("hb_shockwave_sound_lowsh")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",15000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",100)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", self.ExplosionSound)
		 self:SetModel("models/gibs/scanner_gib02.mdl")

		 self.Exploding = true

		 local physo = self:GetPhysicsObject()
		 physo:Wake()
		 physo:EnableMotion(true)
		 for k, v in pairs(ents.FindInSphere(pos,(300*self.uranium_mul)*3)) do
			 if (v:IsValid() or v:IsPlayer()) then
				if v:IsValid() and v:GetPhysicsObject():IsValid() then
					v:Ignite(4,0)
				end
			 end
		 end
		 for k, v in pairs(ents.FindInSphere(pos,300*self.uranium_mul)) do
			if (v:IsValid() or v:IsPlayer()) then
				if v:IsPlayer() && !v:IsNPC() then
					v:SetModel("models/Humans/Charple04.mdl")
					v:Kill()
				end
			 end
		 end

		 timer.Simple(2, function()
			 if !self:IsValid() then return end 
			 constraint.RemoveAll(self)
			 self:StopParticles()
		 end)
		 if(self:WaterLevel() >= 1) then
			 local trdata   = {}
			 local trlength = Vector(0,0,9000)

			 trdata.start   = pos
			 trdata.endpos  = trdata.start + trlength
			 trdata.filter  = self
			 local tr = util.TraceLine(trdata) 

			 local trdat2   = {}
			 trdat2.start   = tr.HitPos
			 trdat2.endpos  = trdata.start - trlength
			 trdat2.filter  = self
			 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
			 local tr2 = util.TraceLine(trdat2)
			 
			 if tr2.Hit then
				 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
			
			 end
		 else
			 local tracedata    = {}
			 tracedata.start    = pos
			 tracedata.endpos   = tracedata.start - Vector(0, 0, 1500)
			 tracedata.filter   = self.Entity
				
			 local trace = util.TraceLine(tracedata)
		 
			 if trace.HitWorld then
				 ParticleEffect("hbomb",pos,Angle(0,0,0),nil)	
				 timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 self:Remove()
			 end)	
			 else 
				 ParticleEffect("hbomb_airburst",pos,Angle(0,0,0),nil) 
				 timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
					 self:Remove()
				end)	
				if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
					 local ent = ents.Create("hb_emp_entity")
					 ent:SetPos( self:GetPos() ) 
					 ent:Spawn()
					 ent:Activate()	
				 end
			 end
		 end
	elseif (self.uranium_mul>=16 && self.uranium_mul<=20) and (self.plutonium_mul >= 6 && self.plutonium_mul <=10) and (self.tritium_mul >= 1 && self.tritium_mul <=2) then 
		 local pos = self:LocalToWorld(self:OBBCenter())
		 local ent = ents.Create("hb_shockwave_ent")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",(900*self.uranium_mul)+(150*self.plutonium_mul)+(300*self.tritium_mul))
		 ent:SetVar("SHOCKWAVE_INCREMENT",100)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/abomb.mp3")
		 ent.trace=2000
		 ent.decal="nuke_big"
			 
		 local ent = ents.Create("hb_shockwave_rumbling")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",19000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",200)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", self.ExplosionSound)
		 
		 local ent = ents.Create("hb_shockwave_sound_burst")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",35000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",100)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", self.ExplosionSound)

		 local ent = ents.Create("hb_shockwave_sound_lowsh")	 
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",21000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",100)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/fat_explosion.mp3")
		 
		 for k, v in pairs(ents.FindInSphere(pos,(self.uranium_mul*250)*3)) do
			 if (v:IsValid() or v:IsPlayer()) then
				if v:IsValid() and v:GetPhysicsObject():IsValid() then
					v:Ignite(4,0)
				end
			 end
		 end
		 for k, v in pairs(ents.FindInSphere(pos,self.uranium_mul*250)) do
			if (v:IsValid() or v:IsPlayer()) then
				if v:IsPlayer() then
					v:SetModel("models/Humans/Charple04.mdl")
					v:Kill()
				end
			 end
		 end
		 if(self:WaterLevel() >= 1) then
			 local trdata   = {}
			 local trlength = Vector(0,0,9000)

			 trdata.start   = pos
			 trdata.endpos  = trdata.start + trlength
			 trdata.filter  = self
			 local tr = util.TraceLine(trdata) 

			 local trdat2   = {}
			 trdat2.start   = tr.HitPos
			 trdat2.endpos  = trdata.start - trlength
			 trdat2.filter  = self
			 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
			 local tr2 = util.TraceLine(trdat2)
			 
			 if tr2.Hit then
				 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
			
			 end
		 else
			 local tracedata    = {}
			 tracedata.start    = pos
			 tracedata.endpos   = tracedata.start - Vector(0, 0, 2000)
			 tracedata.filter   = self.Entity
				
			 local trace = util.TraceLine(tracedata)
		 
			 if trace.HitWorld then
				 ParticleEffect("hnuke2",pos,Angle(0,0,0),nil)	
				 timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 self:Remove()
			 end)	
			 else 
				 ParticleEffect("hnuke2_airburst",pos,Angle(0,0,0),nil) 
				 timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
					 self:Remove()
				 end)	
				 if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
					 local ent = ents.Create("hb_emp_entity")
					 ent:SetPos( self:GetPos() ) 
					 ent:Spawn()
					 ent:Activate()	
				 end
			 end
		 end
	elseif (self.uranium_mul>=21 && self.uranium_mul<=50) and (self.plutonium_mul >= 11 && self.plutonium_mul <=50) and (self.tritium_mul >= 3 && self.tritium_mul <=50) then 
		 local pos = self:LocalToWorld(self:OBBCenter())
		 local ent = ents.Create("hb_shockwave_ent")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",(900*self.uranium_mul)+(150*self.plutonium_mul)+(300*self.tritium_mul))
		 ent:SetVar("SHOCKWAVE_INCREMENT",100)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/abomb.mp3")
		 ent.trace=2000
		 ent.decal="nuke_tsar"
			 
		 local ent = ents.Create("hb_shockwave_rumbling")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",19000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",200)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", self.ExplosionSound)
		 
		 local ent = ents.Create("hb_shockwave_sound_burst")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",35000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",100)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", self.ExplosionSound)

		 local ent = ents.Create("hb_shockwave_sound_lowsh")	 
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",21000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",100)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/fat_explosion.mp3")
		 
		 for k, v in pairs(ents.FindInSphere(pos,(self.uranium_mul*250)*3)) do
			 if (v:IsValid() or v:IsPlayer()) then
				if v:IsValid() and v:GetPhysicsObject():IsValid() then
					v:Ignite(4,0)
				end
			 end
		 end
		 for k, v in pairs(ents.FindInSphere(pos,self.uranium_mul*250)) do
			if (v:IsValid() or v:IsPlayer()) then
				if v:IsPlayer() then
					v:SetModel("models/Humans/Charple04.mdl")
					v:Kill()
				end
			 end
		 end
		 if(self:WaterLevel() >= 1) then
			 local trdata   = {}
			 local trlength = Vector(0,0,9000)

			 trdata.start   = pos
			 trdata.endpos  = trdata.start + trlength
			 trdata.filter  = self
			 local tr = util.TraceLine(trdata) 

			 local trdat2   = {}
			 trdat2.start   = tr.HitPos
			 trdat2.endpos  = trdata.start - trlength
			 trdat2.filter  = self
			 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
			 local tr2 = util.TraceLine(trdat2)
			 
			 if tr2.Hit then
				 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
			
			 end
		 else
			 local tracedata    = {}
			 tracedata.start    = pos
			 tracedata.endpos   = tracedata.start - Vector(0, 0, 2000)
			 tracedata.filter   = self.Entity
				
			 local trace = util.TraceLine(tracedata)
		 
			 if trace.HitWorld then
				 ParticleEffect("hnuke1",pos,Angle(0,0,0),nil)	
				 timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 self:Remove()
			 end)	
			 else 
				 timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
					 self:Remove()
				end)				 
				 ParticleEffect("hnuke1_airburst",pos,Angle(0,0,0),nil) 
				 --Here we do an emp check
				 if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
					 local ent = ents.Create("hb_emp_entity")
					 ent:SetPos( self:GetPos() ) 
					 ent:Spawn()
					 ent:Activate()	
				 end
			 end
		 end
	else
		self:Remove()
	end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs_base/lua/entities/hb_nuclear_ionbomb.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable		            	 =  true         
ENT.AdminSpawnable		             =  true 

ENT.PrintName		                 =  "Ion Bomb"
ENT.Author			                 =  "Business Cat"
ENT.Contact		                     =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/antimatter_canister.mdl"                      
ENT.Effect                           =  "h_ionbomb"                  
ENT.EffectAir                        =  "h_ionbomb_air"                   
ENT.EffectWater                      =  "h_ionbomb_air"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  6500
ENT.ExplosionRadius                  =  9000
ENT.SpecialRadius                    =  2500
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  30                                 
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  100
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  500
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

function ENT:Initialize()
 if (SERVER) then
 
     self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end 
	 if(self.Dumb) then
	     self.Armed    = true
	 else
	     self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:Arm()
     if(!self:IsValid()) then return end
	 if(self.Exploded) then return end
	 if(self.Armed) then return end
	 self.Arming = true
	 self.Used = true
	 timer.Simple(self.ArmDelay, function()
	     if !self:IsValid() then return end 
	     self.Armed = true
		 self.Arming = false
		 self:EmitSound(self.ArmSound)
		 self:StopParticles()
		 if(self.Timed) then
	         timer.Simple(self.Timer, function()
	             if !self:IsValid() then return end 
				 timer.Simple(math.Rand(0,self.MaxDelay),function()
			         if !self:IsValid() then return end 
			         self.Exploded = true
			         self:Explode()
				 end)
	         end)
	     end
	 end)
end	 

function ENT:Explode()
	if !self.Exploded then return end
	if self.Exploding then return end
	local pos = self:LocalToWorld(self:OBBCenter())
	self:SetMoveType( MOVETYPE_NONE )
	self:SetMaterial("phoenix_storms/glass")
	self:SetModel("models/hunter/plates/plate.mdl")
	timer.Simple(0.1, function()
		
		local ent = ents.Create("hb_shockwave_sound_lowsh")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",500000)
		ent:SetVar("SHOCKWAVE_INCREMENT",140)
		ent:SetVar("DELAY",0.01)
		ent:SetVar("SOUND", "gbombs_5/explosions/special/photon_torpedo.mp3")
		
		local ent = ents.Create("hb_shockwave_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",10000)
		ent:SetVar("SHOCKWAVE_INCREMENT",140)
		ent:SetVar("DELAY",0.01)
		self:SetModel("models/gibs/scanner_gib02.mdl")
		ent.trace=self.TraceLength
		ent.decal=self.Decal
	end)
	
	timer.Simple(15, function()	
		if !self:IsValid() then return end
		local ent = ents.Create("hb_shockwave_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
		ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", self.DEFAULT_PHYSFORCE_PLYGROUND)
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",15000)
		ent:SetVar("SHOCKWAVE_INCREMENT",150)
		ent:SetVar("DELAY",0.01)
		self:SetModel("models/gibs/scanner_gib02.mdl")
		ent.trace=self.TraceLength
		ent.decal=self.Decal
		
		local ent = ents.Create("hb_shockwave_sound_lowsh")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent:SetVar("HBOWNER", self.HBOWNER)
		ent:SetVar("MAX_RANGE",50000)
		ent:SetVar("SHOCKWAVE_INCREMENT",150)
		ent:SetVar("DELAY",0.01)
		ent:SetVar("SOUND", "gbombs_5/explosions/special/explosion_1.mp3")
		ent:SetVar("Shocktime",5)
	end)

	
	
	
	
	 
	 self.Exploding = true
	 self:StopParticles()
	 
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			 timer.Simple(20, function()
				 if !self:IsValid() then return end 	
				 self:Remove()
		 end)	
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
			 timer.Simple(20, function()
				 if !self:IsValid() then return end 	
				 self:Remove()
			end)	
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 40 ) 
     ent:Spawn()
     ent:Activate()

     return ent
end
--addons/hbombs/lua/entities/hb_nuclear_ivyking_noflash.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Ivy King - No Flash"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/failure/mk6/mk6.mdl"                      
ENT.Effect                           =  "h_nuke5_a"                  
ENT.EffectAir                        =  "h_nuke5_airburst_a"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ExplosionSound                   =  "gbombs_5/explosions/nuclear/nukeaudio2.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  6500
ENT.ExplosionRadius                  =  10000
ENT.SpecialRadius                    =  5000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  1000
ENT.ImpactSpeed                      =  500
ENT.Mass                             =  8500
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0


ENT.DEFAULT_PHYSFORCE                = 255
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 2555

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decal                            = "nuke_medium"
function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 if self:GetModelScale() == 3 then return end
	 self:SetModelScale( self:GetModelScale() * 3 )
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	 local pos = self:LocalToWorld(self:OBBCenter())
	 
	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE", self.DEFAULT_PHYSFORCE)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 25)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",10000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",130)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 	
	 local ent = ents.Create("hb_shockwave_ent_nounfreeze")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE",10)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",1)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",25000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",130)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
		local ent = ents.Create("hb_base_radiation_draw_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=10000
		
		local ent = ents.Create("hb_base_radiation_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 25
		ent.RadRadius=10000
	 end	 
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",130)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", self.ExplosionSound)
	 self:SetModel("models/gibs/scanner_gib02.mdl")

	 self.Exploding = true
	
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,9000)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius)) do
		if (v:IsValid() or v:IsPlayer()) then
			if v:IsPlayer() && !v:IsNPC() then
				v:SetModel("models/Humans/Charple04.mdl")
				v:Kill()
			end
		 end
	 end
	
  	 timer.Simple(2, function()
		 if !self:IsValid() then return end 
		 constraint.RemoveAll(self)
	
		 self:StopParticles()
		 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*2)) do
			 if self.ShouldUnweld then
				 if v:IsValid() then
					 if v:IsValid() and v:GetPhysicsObject():IsValid() then
						 constraint.RemoveAll(v)
					 end
				 end
			 end
		 end
	 end)
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
			end)	
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
			 --Here we do an emp check
			if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
				 local ent = ents.Create("hb_emp_entity")
				 ent:SetPos( self:GetPos() ) 
				 ent:Spawn()
				 ent:Activate()	
			 end
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs/lua/entities/hb_nuclear_littleboy.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Little boy"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/littleboy.mdl"                      
ENT.Effect                           =  "h_nuke2"                  
ENT.EffectAir                        =  "h_nuke2_airburst"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  10000
ENT.SpecialRadius                    =  4000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  1000
ENT.ImpactSpeed                      =  1000
ENT.Mass                             =  1000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.DEFAULT_PHYSFORCE                = 255
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 2555
ENT.HBOWNER                          =  nil     
ENT.Decal                            = "nuke_medium"



function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end


function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	 local pos = self:LocalToWorld(self:OBBCenter())
	 
	 for k, v in pairs(ents.FindInSphere(pos,8000)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,5000)) do
		if (v:IsValid() or v:IsPlayer()) then
			if v:IsPlayer() && !v:IsNPC() then
				v:SetModel("models/Humans/Charple04.mdl")
				ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,ent,0) 
				v:Kill()
			end
		 end
	 end
	 



  	 timer.Simple(0.1, function()
		 if !self:IsValid() then return end 
		 local ent = ents.Create("hb_shockwave_ent")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE", 75)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", self.DEFAULT_PHYSFORCE_PLYAIR)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 10)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",8000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",140)
		 ent:SetVar("DELAY",0.01)
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
		 
		 local ent = ents.Create("hb_shockwave_ent_nounfreeze")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE",10)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",1)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",25000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",140)
		 ent:SetVar("DELAY",0.01)
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
		 
	 	if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
			local ent = ents.Create("hb_base_radiation_draw_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=7000
			
			local ent = ents.Create("hb_base_radiation_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=7000
			end
			
		 local ent = ents.Create("hb_shockwave_sound_lowsh")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",50000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",130)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/realnukewithrumbling.mp3")
		 self:SetModel("models/gibs/scanner_gib02.mdl")
		 
		 self.Exploding = true
		 self:StopParticles()
	 end)
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
		 end)	
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
			end)	
			 --Here we do an emp check
			if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
				 local ent = ents.Create("hb_emp_entity")
				 ent:SetPos( self:GetPos() ) 
				 ent:Spawn()
				 ent:Activate()	
			 end
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 24 ) 
	 ent:Spawn()
	 ent:Activate()

	 return ent
end
--addons/hbombs_base/lua/entities/hb_nuclear_propellant.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced" )

ENT.Spawnable		            	 =  true         
ENT.AdminSpawnable		             =  true 

ENT.PrintName		                 =  "Mk33 Propellant"
ENT.Author			                 =  "Natsu"
ENT.Contact		                     =  "baldursgate3@gmail.com"
ENT.Category                         =  "HBOMBS Misc"

ENT.Model                            =  "models/props_junk/metal_paintcan001a.mdl"                      
ENT.Effect                           =  "h_propellant"                  
ENT.EffectAir                        =  "h_propellant"                   
ENT.EffectWater                      =  "water_huge"
ENT.ExplosionSound                   =  "gbombs_5/explosions/light_bomb/ex_2.mp3"
 
ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  true

ENT.ExplosionRadius                  =  100
ENT.SpecialRadius                    =  100
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  2555                                
ENT.MaxDelay                         =  0                                 
ENT.TraceLength                      =  3000
ENT.ImpactSpeed                      =  700
ENT.Mass                             =  52
ENT.ArmDelay                         =  0  
ENT.HBOWNER                          =  nil             -- don't you fucking touch this.

ENT.Shocktime                        =  3
ENT.DEFAULT_PHYSFORCE                = 9955
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 9000
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 9000 

function ENT:Initialize()
 if (SERVER) then
     self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end 
	 if(self.Dumb) then
	     self.Armed    = true
	 else
	     self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:Explode()
     if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos_sound = self:LocalToWorld(self:OBBCenter())
	 constraint.RemoveAll(self)
	 local physo = self:GetPhysicsObject()
	 physo:Wake()	
	 if !self:IsValid() then return end 
	 self.Exploding = true
	 local pos = self:GetPos()
	 for k, v in pairs(ents.FindInSphere(pos,45)) do
		if v:GetClass()=="hb_nuclear_grable" then
			local phys = v:GetPhysicsObject()
			if (phys:IsValid()) then
				local mass = phys:GetMass()
				local F_ang = 5555
				local dist = (pos - v:GetPos()):Length()
				local relation = math.Clamp((45- dist) / 45, 0, 1)
				local F_dir = (v:GetPos() - pos):GetNormal() * 5555

				phys:Wake()
				phys:EnableMotion(true)

				phys:AddVelocity(F_dir)
				if !v:IsValid() then return end
				timer.Simple(0.2, function()
					phys:AddVelocity(F_dir)		
					if !v:IsValid() then return end
					timer.Simple(0.2, function()
						phys:AddVelocity(F_dir)			
						if !v:IsValid() then return end
						timer.Simple(0.2, function()				
							phys:AddVelocity(F_dir)			
							if !v:IsValid() then return end
							timer.Simple(0.2, function()				
								phys:AddVelocity(F_dir)							
							end)
						end)
					end)
				end)
				
			end
		end
	 end
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",100)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND","gbombs_5/explosions/medium_bomb/ex7.mp3")
	 ent:SetVar("Shocktime", self.Shocktime)
	
	 self:StopParticles()

	 local pos = self:GetPos()
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,self:GetAngles(),nil)	
			 timer.Simple(0.1, function()
				 self:Remove()
			 end)	
		 else 
			 ParticleEffect(self.EffectAir,self:GetPos(),Angle(0,0,0),nil) 
			 self:Remove()

		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 16 ) 
     ent:Spawn()
     ent:Activate()
     return ent
end
--addons/hbombs/lua/entities/hb_nuclear_slownuke.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true 

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Slow Nuke"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/hypersonic.mdl"                      
ENT.Effect                           =  "h_slownuke"                  
ENT.EffectAir                        =  "h_slownuke_airburst"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  10000
ENT.SpecialRadius                    =  4000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  1000
ENT.ImpactSpeed                      =  1000
ENT.Mass                             =  2000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.DEFAULT_PHYSFORCE                = 255
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 2555
ENT.HBOWNER                          =  nil     
ENT.Decal                            = "nuke_medium"



function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end


function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	 local pos = self:LocalToWorld(self:OBBCenter())
	 
	 for k, v in pairs(ents.FindInSphere(pos,8000)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,5000)) do
		if (v:IsValid() or v:IsPlayer()) then
			if v:IsPlayer() && !v:IsNPC() then
				v:SetModel("models/Humans/Charple04.mdl")
				ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,ent,0) 
				v:Kill()
			end
		 end
	 end
	 



  	 timer.Simple(0.1, function()
		 if !self:IsValid() then return end 
		 local ent = ents.Create("hb_shockwave_sound_lowsh")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",50000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",10000)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/tsar_in.mp3")
		 self:SetModel("models/gibs/scanner_gib02.mdl")
		 
		 local ent = ents.Create("hb_shockwave_ent_nounfreeze")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE",1)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",0)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",40000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",140)
		 ent:SetVar("DELAY",0.01)
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
		 
		 local ent = ents.Create("hb_shockwave_sound_lowsh")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",50000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",130)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nuke_after.mp3")
		 self:SetModel("models/gibs/scanner_gib02.mdl")
		 
	 	if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
			local ent = ents.Create("hb_base_radiation_draw_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=7000
			
			local ent = ents.Create("hb_base_radiation_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=7000
			end
			
		 local ent = ents.Create("hb_shockwave_sound_lowsh")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",50000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",130)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudiobassspeed.mp3")
		 self:SetModel("models/gibs/scanner_gib02.mdl")

		 timer.Simple(1, function()
			local ent = ents.Create("hb_shockwave_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent:SetVar("DEFAULT_PHYSFORCE", 100)
			ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 50)
			ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 5)
			ent:SetVar("HBOWNER", self.HBOWNER)
			ent:SetVar("MAX_RANGE",15000)
			ent:SetVar("SHOCKWAVE_INCREMENT",75)
			ent:SetVar("DELAY",0.01)
			ent.trace=self.TraceLength
			ent.decal=self.Decal

			local ent = ents.Create("hb_shockwave_sound_lowsh")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent:SetVar("HBOWNER", self.HBOWNER)
			ent:SetVar("MAX_RANGE",50000)
			ent:SetVar("SHOCKWAVE_INCREMENT",75)
			ent:SetVar("DELAY",0.01)
			ent:SetVar("SOUND", "gbombs_5/explosions/medium_bomb/explosion_petrol_medium.mp3")
			self:SetModel("models/gibs/scanner_gib02.mdl")
		 end)
		 
		 self.Exploding = true
		 self:StopParticles()
	 end)
	 
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
		 end)	
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
			end)	
			 --Here we do an emp check
			if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
				 local ent = ents.Create("hb_emp_entity")
				 ent:SetPos( self:GetPos() ) 
				 ent:Spawn()
				 ent:Activate()	
			 end
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 48 ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetAngles(Angle(45,0,90))

	 return ent
end
--addons/hbombs/lua/entities/hb_nuclear_slownuke_noflash.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable						 =  true         
ENT.AdminSpawnable					 =  true

ENT.AdminOnly						 =  true

ENT.PrintName						 =  "Slow Nuke - No Flash"
ENT.Author							 =  "Business Cat"
ENT.Contact							 =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/hypersonic.mdl"                      
ENT.Effect                           =  "h_slownuke_a"                  
ENT.EffectAir                        =  "h_slownuke_airburst_a"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  10000
ENT.SpecialRadius                    =  4000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  1000
ENT.ImpactSpeed                      =  1000
ENT.Mass                             =  2000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.DEFAULT_PHYSFORCE                = 255
ENT.DEFAULT_PHYSFORCE_PLYAIR         = 25
ENT.DEFAULT_PHYSFORCE_PLYGROUND         = 2555
ENT.HBOWNER                          =  nil     
ENT.Decal                            = "nuke_medium"



function ENT:Initialize()
 if (SERVER) then
	 self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
	 end 
	 if(self.Dumb) then
		 self.Armed    = true
	 else
		 self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end


function ENT:Explode()
	 if !self.Exploded then return end
	 if self.Exploding then return end
	 local pos = self:LocalToWorld(self:OBBCenter())
	 
	 for k, v in pairs(ents.FindInSphere(pos,8000)) do
		 if (v:IsValid() or v:IsPlayer()) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,5000)) do
		if (v:IsValid() or v:IsPlayer()) then
			if v:IsPlayer() && !v:IsNPC() then
				v:SetModel("models/Humans/Charple04.mdl")
				ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,ent,0) 
				v:Kill()
			end
		 end
	 end
	 



  	 timer.Simple(0.1, function()
		 if !self:IsValid() then return end 
		 local ent = ents.Create("hb_shockwave_sound_lowsh")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",50000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",10000)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/tsar_in.mp3")
		 self:SetModel("models/gibs/scanner_gib02.mdl")

		 local ent = ents.Create("hb_shockwave_ent_nounfreeze")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("DEFAULT_PHYSFORCE",1)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
		 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",0)
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",40000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",140)
		 ent:SetVar("DELAY",0.01)
		 ent.trace=self.TraceLength
		 ent.decal=self.Decal
		 
		 local ent = ents.Create("hb_shockwave_sound_lowsh")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",50000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",130)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nuke_after.mp3")
		 self:SetModel("models/gibs/scanner_gib02.mdl")
		 
	 	if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
			local ent = ents.Create("hb_base_radiation_draw_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=7000
			
			local ent = ents.Create("hb_base_radiation_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent.Burst = 25
			ent.RadRadius=7000
			end
			
		 local ent = ents.Create("hb_shockwave_sound_lowsh")
		 ent:SetPos( pos ) 
		 ent:Spawn()
		 ent:Activate()
		 ent:SetVar("HBOWNER", self.HBOWNER)
		 ent:SetVar("MAX_RANGE",50000)
		 ent:SetVar("SHOCKWAVE_INCREMENT",130)
		 ent:SetVar("DELAY",0.01)
		 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudiobassspeed.mp3")
		 self:SetModel("models/gibs/scanner_gib02.mdl")

		 timer.Simple(1, function()
			local ent = ents.Create("hb_shockwave_ent")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent:SetVar("DEFAULT_PHYSFORCE", 100)
			ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 50)
			ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 5)
			ent:SetVar("HBOWNER", self.HBOWNER)
			ent:SetVar("MAX_RANGE",15000)
			ent:SetVar("SHOCKWAVE_INCREMENT",75)
			ent:SetVar("DELAY",0.01)
			ent.trace=self.TraceLength
			ent.decal=self.Decal

			local ent = ents.Create("hb_shockwave_sound_lowsh")
			ent:SetPos( pos ) 
			ent:Spawn()
			ent:Activate()
			ent:SetVar("HBOWNER", self.HBOWNER)
			ent:SetVar("MAX_RANGE",50000)
			ent:SetVar("SHOCKWAVE_INCREMENT",75)
			ent:SetVar("DELAY",0.01)
			ent:SetVar("SOUND", "gbombs_5/explosions/medium_bomb/explosion_petrol_medium.mp3")
			self:SetModel("models/gibs/scanner_gib02.mdl")
		 end)
		 
		 self.Exploding = true
		 self:StopParticles()
	 end)
	 
	 if(self:WaterLevel() >= 1) then
		 local trdata   = {}
		 local trlength = Vector(0,0,9000)

		 trdata.start   = pos
		 trdata.endpos  = trdata.start + trlength
		 trdata.filter  = self
		 local tr = util.TraceLine(trdata) 

		 local trdat2   = {}
		 trdat2.start   = tr.HitPos
		 trdat2.endpos  = trdata.start - trlength
		 trdat2.filter  = self
		 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
		 
		 local tr2 = util.TraceLine(trdat2)
		 
		 if tr2.Hit then
			 ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		
		 end
	 else
		 local tracedata    = {}
		 tracedata.start    = pos
		 tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		 tracedata.filter   = self.Entity
			
		 local trace = util.TraceLine(tracedata)
	 
		 if trace.HitWorld then
			 ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
		 end)	
		 else 
			 ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
			 timer.Simple(2, function()
				 if !self:IsValid() then return end 
				 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				 self:Remove()
			end)	
			 --Here we do an emp check
			if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
				 local ent = ents.Create("hb_emp_entity")
				 ent:SetPos( self:GetPos() ) 
				 ent:Spawn()
				 ent:Activate()	
			 end
		 end
	 end
end

function ENT:SpawnFunction( ply, tr )
	 if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
	 local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
	 ent:SetPos( tr.HitPos + tr.HitNormal * 48 ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetAngles(Angle(45,0,90))

	 return ent
end
--addons/hbombs_base/lua/entities/hb_nuclear_tsarbomba.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable		            	 =  true     
ENT.AdminSpawnable		             =  true 

ENT.AdminOnly 						 =  true

ENT.PrintName		                 =  "Tsar Bomba"
ENT.Author			                 =  "Business Cat"
ENT.Contact		                     =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/tsar.mdl"                      
ENT.Effect                           =  "hnuke1"                  
ENT.EffectAir                        =  "hnuke1_airburst"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ExplosionSound                   =  "gbombs_5/explosions/nuclear/tsar_detonate.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  35000
ENT.SpecialRadius                    =  5000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  1000
ENT.ImpactSpeed                      =  1300
ENT.Mass                             =  25000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decal                            = "nuke_tsar"
function ENT:Initialize()
 if (SERVER) then
     self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end 
	 if(self.Dumb) then
	     self.Armed    = true
	 else
	     self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:PhysicsCollide( data, physobj )
     if(self.Exploded) then return end
     if(!self:IsValid()) then return end
	 if(self.Life <= 0) then return end
	 if(data.Speed > 200) then
		if math.random(1,2)==1 then
			self:EmitSound("gbombs_5/arm/tsarland.wav", 80, math.random(90,110))
		else
			self:EmitSound("gbombs_5/arm/tsarland2.wav", 80, math.random(90,110))
		end
	 end
	 if(GetConVar("hb_fragility"):GetInt() >= 1) then
	     if(data.Speed > self.ImpactSpeed) then
	 	     if(!self.Armed and !self.Arming) then

	             self:Arm()
	         end
		 end
	 end
	 if(!self.Armed) then return end
     if self.ShouldExplodeOnImpact then
	     if (data.Speed > self.ImpactSpeed ) then
			 self.Exploded = true
			 self:Explode()
		 end
	 end
end

function ENT:Explode()
     if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos = self:LocalToWorld(self:OBBCenter())
	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",35000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",160)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("DEFAULT_PHYSFORCE", 955)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 15)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 155)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
		local ent = ents.Create("hb_base_radiation_draw_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 50
		ent.RadRadius=35000
		
		local ent = ents.Create("hb_base_radiation_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 50
		ent.RadRadius=35000
	 end			 

	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",160)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/tsar_detonate.mp3")
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true
	 
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",160)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio3.mp3")
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true	 
	 
	 local ent = ents.Create("hb_shockwave_ent_nounfreeze")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE",10)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",10)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",160)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,50000)) do
		 if (v:IsValid() or v:IsPlayer()) and (v.forcefielded==false or v.forcefielded==nil) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*2)) do
		if (v:IsValid() or v:IsPlayer()) and (v.forcefielded==false or v.forcefielded==nil) then
			if v:IsPlayer() && v:Alive() then
			    v:SetModel("models/Humans/Charple04.mdl")
				v:Kill()
				ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,v,0) 
			end
		 end
	 end
	
  	 timer.Simple(2, function()
	     if !self:IsValid() then return end 
		 constraint.RemoveAll(self)
		 if GetConVar("hb_sound_shake"):GetInt()== 1 then
			util.ScreenShake( pos, 55555, 255, 10, 121000 )
		 else return end
		 self:StopParticles()
     end)
		 if(self:WaterLevel() >= 1) then
		 	 local trdata   = {}
			 local trlength = Vector(0,0,9000)

			 trdata.start   = pos
			 trdata.endpos  = trdata.start + trlength
			 trdata.filter  = self
			 local tr = util.TraceLine(trdata) 

		     local trdat2   = {}
			 trdat2.start   = tr.HitPos
			 trdat2.endpos  = trdata.start - trlength
			 trdat2.filter  = self
			 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
			 local tr2 = util.TraceLine(trdat2)
			 
			 if tr2.Hit then
		         ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		    
			 end
		 else
		     local tracedata    = {}
	         tracedata.start    = pos
		     tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		     tracedata.filter   = self.Entity
				
		     local trace = util.TraceLine(tracedata)
	     
		     if trace.HitWorld then
		         ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			     timer.Simple(2, function()
			         if !self:IsValid() then return end 
			         ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				     self:Remove()
             end)	
		     else 
			     ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
				 --Here we do an emp check
				 timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
					 self:Remove()
				end)	
				if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
					 local ent = ents.Create("hb_emp_entity")
					 ent:SetPos( self:GetPos() ) 
					 ent:Spawn()
					 ent:Activate()	
				 end
		     end
		 end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 56 ) 
     ent:Spawn()
     ent:Activate()

     return ent
end
--addons/hbombs_base/lua/entities/hb_nuclear_tsarbomba_noflash.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "hb_base_advanced_nuke" )

ENT.Spawnable		            	 =  true     
ENT.AdminSpawnable		             =  true 

ENT.AdminOnly 						 =  true

ENT.PrintName		                 =  "Tsar Bomba - No Flash"
ENT.Author			                 =  "Business Cat"
ENT.Contact		                     =  "nah"
ENT.Category                         =  "HBOMBS Nukes"

ENT.Model                            =  "models/thedoctor/tsar.mdl"                      
ENT.Effect                           =  "hnuke1_a"                  
ENT.EffectAir                        =  "hnuke1_airburst_a"                   
ENT.EffectWater                      =  "hbomb_underwater"
ENT.ExplosionSound                   =  "gbombs_5/explosions/nuclear/tsar_detonate.mp3"
ENT.ArmSound                         =  "npc/roller/mine/rmine_blip3.wav"            
ENT.ActivationSound                  =  "buttons/button14.wav"     

ENT.ShouldUnweld                     =  true
ENT.ShouldIgnite                     =  false
ENT.ShouldExplodeOnImpact            =  true
ENT.Flamable                         =  false
ENT.UseRandomSounds                  =  false
ENT.Timed                            =  false

ENT.ExplosionDamage                  =  500
ENT.PhysForce                        =  2500
ENT.ExplosionRadius                  =  35000
ENT.SpecialRadius                    =  5000
ENT.MaxIgnitionTime                  =  0
ENT.Life                             =  25                                  
ENT.MaxDelay                         =  2                                 
ENT.TraceLength                      =  1000
ENT.ImpactSpeed                      =  1300
ENT.Mass                             =  25000
ENT.ArmDelay                         =  1   
ENT.Timer                            =  0

ENT.HBOWNER                          =  nil             -- don't you fucking touch this.
ENT.Decal                            = "nuke_tsar"
function ENT:Initialize()
 if (SERVER) then
     self:SetModel(self.Model)
	 self:PhysicsInit( SOLID_VPHYSICS )
	 self:SetSolid( SOLID_VPHYSICS )
	 self:SetMoveType( MOVETYPE_VPHYSICS )
	 self:SetUseType( ONOFF_USE ) -- doesen't fucking work
	 local phys = self:GetPhysicsObject()
	 if (phys:IsValid()) then
		 phys:SetMass(self.Mass)
		 phys:Wake()
     end 
	 if(self.Dumb) then
	     self.Armed    = true
	 else
	     self.Armed    = false
	 end
	 self.Exploded = false
	 self.Used     = false
	 self.Arming = false
	 self.Exploding = false
	  if !(WireAddon == nil) then self.Inputs   = Wire_CreateInputs(self, { "Arm", "Detonate" }) end
	end
end

function ENT:PhysicsCollide( data, physobj )
     if(self.Exploded) then return end
     if(!self:IsValid()) then return end
	 if(self.Life <= 0) then return end
	 if(data.Speed > 200) then
		if math.random(1,2)==1 then
			self:EmitSound("gbombs_5/arm/tsarland.wav", 80, math.random(90,110))
		else
			self:EmitSound("gbombs_5/arm/tsarland2.wav", 80, math.random(90,110))
		end
	 end
	 if(GetConVar("hb_fragility"):GetInt() >= 1) then
	     if(data.Speed > self.ImpactSpeed) then
	 	     if(!self.Armed and !self.Arming) then

	             self:Arm()
	         end
		 end
	 end
	 if(!self.Armed) then return end
     if self.ShouldExplodeOnImpact then
	     if (data.Speed > self.ImpactSpeed ) then
			 self.Exploded = true
			 self:Explode()
		 end
	 end
end

function ENT:Explode()
     if !self.Exploded then return end
	 if self.Exploding then return end
	
	 local pos = self:LocalToWorld(self:OBBCenter())
	 local ent = ents.Create("hb_shockwave_ent")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",35000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",160)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("DEFAULT_PHYSFORCE", 955)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR", 15)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND", 155)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	 
	if GetConVar("hb_nuclear_fallout"):GetInt()== 1 then
		local ent = ents.Create("hb_base_radiation_draw_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 50
		ent.RadRadius=35000
		
		local ent = ents.Create("hb_base_radiation_ent")
		ent:SetPos( pos ) 
		ent:Spawn()
		ent:Activate()
		ent.Burst = 50
		ent.RadRadius=35000
	 end			 

	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",160)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/tsar_detonate.mp3")
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true
	 
	 local ent = ents.Create("hb_shockwave_sound_lowsh")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",160)
	 ent:SetVar("DELAY",0.01)
	 ent:SetVar("SOUND", "gbombs_5/explosions/nuclear/nukeaudio3.mp3")
	 self:SetModel("models/gibs/scanner_gib02.mdl")
	 self.Exploding = true	 	 
	 
	 local ent = ents.Create("hb_shockwave_ent_nounfreeze")
	 ent:SetPos( pos ) 
	 ent:Spawn()
	 ent:Activate()
	 ent:SetVar("DEFAULT_PHYSFORCE",10)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYAIR",1)
	 ent:SetVar("DEFAULT_PHYSFORCE_PLYGROUND",10)
	 ent:SetVar("HBOWNER", self.HBOWNER)
	 ent:SetVar("MAX_RANGE",50000)
	 ent:SetVar("SHOCKWAVE_INCREMENT",160)
	 ent:SetVar("DELAY",0.01)
	 ent.trace=self.TraceLength
	 ent.decal=self.Decal
	
	 local physo = self:GetPhysicsObject()
	 physo:Wake()
	 physo:EnableMotion(true)
	 for k, v in pairs(ents.FindInSphere(pos,50000)) do
		 if (v:IsValid() or v:IsPlayer()) and (v.forcefielded==false or v.forcefielded==nil) then
			if v:IsValid() and v:GetPhysicsObject():IsValid() then
				v:Ignite(4,0)
			end
		 end
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.SpecialRadius*2)) do
		if (v:IsValid() or v:IsPlayer()) and (v.forcefielded==false or v.forcefielded==nil) then
			if v:IsPlayer() && v:Alive() then
			    v:SetModel("models/Humans/Charple04.mdl")
				v:Kill()
				ParticleEffectAttach("nuke_player_vaporize_fatman",PATTACH_POINT_FOLLOW,v,0) 
			end
		 end
	 end
	
  	 timer.Simple(2, function()
	     if !self:IsValid() then return end 
		 constraint.RemoveAll(self)
		 if GetConVar("hb_sound_shake"):GetInt()== 1 then
			util.ScreenShake( pos, 55555, 255, 10, 121000 )
		 else return end
		 self:StopParticles()
     end)
		 if(self:WaterLevel() >= 1) then
		 	 local trdata   = {}
			 local trlength = Vector(0,0,9000)

			 trdata.start   = pos
			 trdata.endpos  = trdata.start + trlength
			 trdata.filter  = self
			 local tr = util.TraceLine(trdata) 

		     local trdat2   = {}
			 trdat2.start   = tr.HitPos
			 trdat2.endpos  = trdata.start - trlength
			 trdat2.filter  = self
			 trdat2.mask    = MASK_WATER + CONTENTS_TRANSLUCENT
			 
			 local tr2 = util.TraceLine(trdat2)
			 
			 if tr2.Hit then
		         ParticleEffect(self.EffectWater, tr2.HitPos, Angle(0,0,0), nil)
		    
			 end
		 else
		     local tracedata    = {}
	         tracedata.start    = pos
		     tracedata.endpos   = tracedata.start - Vector(0, 0, self.TraceLength)
		     tracedata.filter   = self.Entity
				
		     local trace = util.TraceLine(tracedata)
	     
		     if trace.HitWorld then
		         ParticleEffect(self.Effect,pos,Angle(0,0,0),nil)	
			     timer.Simple(2, function()
			         if !self:IsValid() then return end 
			         ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
				     self:Remove()
             end)	
		     else 
			     ParticleEffect(self.EffectAir,pos,Angle(0,0,0),nil) 
				 --Here we do an emp check
				 timer.Simple(2, function()
					 if !self:IsValid() then return end 
					 ParticleEffect("",trace.HitPos,Angle(0,0,0),nil)	
					 self:Remove()
				end)	
				if(GetConVar("hb_nuclear_emp"):GetInt() >= 1) then
					 local ent = ents.Create("hb_emp_entity")
					 ent:SetPos( self:GetPos() ) 
					 ent:Spawn()
					 ent:Activate()	
				 end
		     end
		 end
end

function ENT:SpawnFunction( ply, tr )
     if ( !tr.Hit ) then return end
	 self.HBOWNER = ply
     local ent = ents.Create( self.ClassName )
	 ent:SetPhysicsAttacker(ply)
     ent:SetPos( tr.HitPos + tr.HitNormal * 56 ) 
     ent:Spawn()
     ent:Activate()

     return ent
end
--addons/hbombs_base/lua/entities/hb_shockwave_ent_reducedamage.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  ""        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.MAX_RANGE                        = 0
ENT.SHOCKWAVE_INCREMENT              = 0
ENT.DELAY                            = 0
ENT.SOUND                            = ""

if SERVER then
	function ENT:Initialize()  
		 self.FILTER = {}
		 self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
		 self:SetSolid( SOLID_NONE )
		 self:SetMoveType( MOVETYPE_NONE )
		 self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.CURRENTRANGE = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
		 self.SOUND = self:GetVar("SOUND")
		 self.DEFAULT_PHYSFORCE  = self:GetVar("DEFAULT_PHYSFORCE")
		 self.DEFAULT_PHYSFORCE_PLYAIR  = self:GetVar("DEFAULT_PHYSFORCE_PLYAIR")
		 self.DEFAULT_PHYSFORCE_PLYGROUND = self:GetVar("DEFAULT_PHYSFORCE_PLYGROUND")
		 self.SHOCKWAVEDAMAGE = self:GetVar("SHOCKWAVE_DAMAGE")
		 self.allowtrace=true
	end
end
function ENT:Trace()
	if SERVER then
		if !self:IsValid() then return end
		if(GetConVar("hb_decals"):GetInt() >= 1) then
			local pos = self:GetPos()
			local tracedata    = {}
			tracedata.start    = pos
			tracedata.endpos   = tracedata.start - Vector(0, 0, self.trace)
			tracedata.filter   = self.Entity
			local trace = util.TraceLine(tracedata)
			if self.decal==nil then 
				self.decal="scorch_medium"
			end

			util.Decal( self.decal, tracedata.start, tracedata.endpos )
		end
	end
end
function ENT:Think()		
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 self.CURRENTRANGE = self.CURRENTRANGE+(self.SHOCKWAVE_INCREMENT*10)
	 if self.allowtrace then
		self:Trace()
		self.allowtrace=false
	 end
	 for k, v in pairs(ents.FindInSphere(pos,self.CURRENTRANGE)) do
		 if (v:IsValid() or v:IsPlayer()) then
			 local i = 0
			 while i < v:GetPhysicsObjectCount() do
				 local dmg = DamageInfo()
				 dmg:SetDamage(math.random(1,2))
				 dmg:SetDamageType(DMG_BURN)
				 if self.HBOWNER == nil then
					self.HBOWNER = table.Random(player.GetAll())
				 end
				 if !self.HBOWNER:IsValid() then
					self.HBOWNER = table.Random(player.GetAll())
				 end
				 dmg:SetAttacker(self.HBOWNER)
				 phys = v:GetPhysicsObjectNum(i)
				 if (phys:IsValid()) then
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE
					 local dist = (pos - v:GetPos()):Length()
			
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE or 690) 
					 phys:AddAngleVelocity(Vector(F_ang, F_ang, F_ang) * relation)
					 phys:AddVelocity(F_dir)
					 if(GetConVar("hb_shockwave_unfreeze"):GetInt() >= 1) then
						 if !v.isWacAircraft then
						 	phys:Wake()
						    phys:EnableMotion(true)
							constraint.RemoveAll(v)
						 end
					 end
					 if (v:GetClass()=="func_breakable" or class=="func_breakable_surf" or class=="func_physbox") then
						v:Fire("Break", 0)
					 end
				 end
				 if (v:IsPlayer()) then
					
				     v:TakeDamageInfo(dmg)
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYAIR
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE_PLYAIR or 690)
					 v:SetVelocity( F_dir )		
				 end

				 if (v:IsPlayer()) and v:IsOnGround() then
				     v:TakeDamageInfo(dmg)
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYGROUND
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE_PLYGROUND or 690)	 
					 v:SetVelocity( F_dir )		
				 end
				 if (v:IsNPC()) then
					 v:TakeDamageInfo(dmg)
				 end
			 i = i + 1
			 end
		 end
 	 end
	 self.Bursts = self.Bursts + 1
	 if (self.CURRENTRANGE >= self.MAX_RANGE) then
	     self:Remove()
	 end
	 self:NextThink(CurTime() + (self.DELAY*10))
	 return true
	 end
end

function ENT:Draw()
     return false
end
--addons/hbombs_base/lua/entities/hb_shockwave_roar.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  ""        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.MAX_RANGE                        = 0
ENT.SHOCKWAVE_INCREMENT              = 0
ENT.DELAY                            = 0
ENT.SOUND                            = ""

function ENT:Initialize()
     if (SERVER) then
		 self.FILTER                           = {}
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.CURRENTRANGE = 0
		 self.HBOWNER = self:GetVar("HBOWNER")
		 self.SOUND = self:GetVar("SOUND")
		 self.DEFAULT_PHYSFORCE  = self:GetVar("DEFAULT_PHYSFORCE")
		 self.DEFAULT_PHYSFORCE_PLYAIR  = self:GetVar("DEFAULT_PHYSFORCE_PLYAIR")
	     self.DEFAULT_PHYSFORCE_PLYGROUND = self:GetVar("DEFAULT_PHYSFORCE_PLYGROUND")

     end
end

function ENT:Think(ply)		
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 self.CURRENTRANGE = self.CURRENTRANGE+self.SHOCKWAVE_INCREMENT
	 for k, v in pairs(ents.FindInSphere(pos,self.CURRENTRANGE)) do
		 if v:IsValid() or v:IsPlayer() then
			 local i = 0
			 while i < v:GetPhysicsObjectCount() do
				 phys = v:GetPhysicsObjectNum(i)
				 if (v:GetClass()=="func_breakable" or class=="func_breakable_surf" or class=="func_physbox") then
					v:Fire("Break", 0)
				 end
				 if phys:IsValid() && !(v:GetClass()=="hb_fireroar") && !(v:IsPlayer()) && !(v:IsNPC()) then
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE or 690) 
					 phys:AddAngleVelocity(Vector(F_ang, F_ang, F_ang) * relation)
					 phys:AddVelocity(F_dir)
				 end
			
				 if v:IsPlayer() and v:Alive() then
					 if self.Ignoreowner then
					 if !(v==self.Ignore) then
					 v:SetMoveType( MOVETYPE_WALK )
					 local dmg = DamageInfo()
					 dmg:SetDamage(math.random(5,25))
					 dmg:SetDamageType(DMG_BLAST)
					 dmg:SetAttacker(self.HBOWNER)
					 v:TakeDamageInfo(dmg)
					 local mass = phys:GetMass()
					 local F_ang = self.DEFAULT_PHYSFORCE_PLYGROUND
					 local dist = (pos - v:GetPos()):Length()
					 local relation = math.Clamp((self.CURRENTRANGE - dist) / self.CURRENTRANGE, 0, 1)
					 local F_dir = (v:GetPos() - pos):GetNormal() * (self.DEFAULT_PHYSFORCE_PLYGROUND or 690)	 
					 v:SetVelocity( F_dir )	
					 end
					 end
				 end
				 if v:IsNPC() then
					 local dmg = DamageInfo()
					 dmg:SetDamage(math.random(5,25))
					 dmg:SetDamageType(DMG_BLAST)
					 dmg:SetAttacker(self.HBOWNER)
					 v:TakeDamageInfo(dmg)
				 end
			 i = i + 1
			 end
		 end
 	 end
	 self.Bursts = self.Bursts + 1
	 if (self.CURRENTRANGE >= self.MAX_RANGE) then
	     self:Remove()
	 end
	 self:NextThink(CurTime() + self.DELAY)
	 return true
	 end
end

--addons/hbombs_base/lua/entities/hb_shockwave_rumbling.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )


ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  ""        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.MAX_RANGE                        = 0
ENT.SHOCKWAVE_INCREMENT              = 0
ENT.DELAY                            = 0
ENT.SOUND                            = ""
function ENT:Initialize()
     if (SERVER) then
		 self.FILTER                           = {}
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
		 self.Bursts = 0
		 self.CURRENTRANGE = 5000
		 self.HBOWNER = self:GetVar("HBOWNER")
     end
end

function ENT:Think(ply)

			
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 self.CURRENTRANGE = self.CURRENTRANGE+self.SHOCKWAVE_INCREMENT
	 for k, v in pairs(ents.FindInSphere(pos,self.CURRENTRANGE)) do
		 if v:IsValid() or v:IsPlayer() then
			 local i = 0
			 while i < v:GetPhysicsObjectCount() do
				 if (v:IsPlayer()) then
					 if !(table.HasValue(self.FILTER,v:SteamID())) then
						net.Start("hb_net_sound_lowsh")
							net.WriteString("gbombs_5/explosions/nuclear/nuke_rumbling.mp3")
						net.Send(v)
						table.insert(self.FILTER, v:SteamID() )
					 end
				 end

			 i = i + 1
			 end
		 end
 	 end
	 self.Bursts = self.Bursts + 1
	 if (self.CURRENTRANGE >= self.MAX_RANGE) then
	     self:Remove()
	 end
	 self:NextThink(CurTime() + self.DELAY)
	 return true
	 end
end

function ENT:Draw()
     return false
end
--addons/hbombs_base/lua/entities/hb_shockwave_sound_instant.lua:
AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )

ENT.Spawnable		            	 =  false
ENT.AdminSpawnable		             =  false     

ENT.PrintName		                 =  ""        
ENT.Author			                 =  ""      
ENT.Contact			                 =  ""      

ENT.HBOWNER                          =  nil            
ENT.MAX_RANGE                        = 0
ENT.SHOCKWAVE_INCREMENT              = 0
ENT.DELAY                            = 0
ENT.SOUND                            = ""
ENT.MAX_BURSTS                       = 1


function ENT:Initialize()
     if (SERVER) then
		 self.FILTER                           = {}
         self:SetModel("models/props_junk/watermelon01_chunk02c.mdl")
	     self:SetSolid( SOLID_NONE )
	     self:SetMoveType( MOVETYPE_NONE )
	     self:SetUseType( ONOFF_USE ) 
	     self.MAX_BURSTS = self:GetVar("MAX_BURSTS")
		 self.Bursts = 0
		 self.CURRENTRANGE = 0
		 self.SOUND = self:GetVar("SOUND")
     end
end

function ENT:Think()			
     if (SERVER) then
     if !self:IsValid() then return end
	 local pos = self:GetPos()
	 self.CURRENTRANGE = self.CURRENTRANGE+self.SHOCKWAVE_INCREMENT
	 for k, v in pairs(ents.FindInSphere(pos,self.MAX_RANGE)) do
		 if v:IsValid() or v:IsPlayer() then
			 local i = 0
			 while i < v:GetPhysicsObjectCount() do
				 phys = v:GetPhysicsObjectNum(i)
				 if (v:IsPlayer()) then
					 if !(table.HasValue(self.FILTER,v:SteamID())) then
						net.Start("hb_net_sound_lowsh")
							net.WriteString(self.SOUND)
						net.Send(v)
						local shocktime = self:GetVar("Shocktime")
						util.ScreenShake( v:GetPos(), 5555, 555, shocktime, 500 )
						table.insert(self.FILTER, v:SteamID() )
					 end
				 end
			 i = i + 1
			 end
		 end
 	 end
	 self.Bursts = self.Bursts + 1
	 if (self.Bursts >= self.MAX_BURSTS) then
		 timer.Simple(5, function()
			if self:IsValid() then
				self:Remove()
			end
		 end)
	 end
	 self:NextThink(CurTime() + self.DELAY)
	 return true
	 end
end

function ENT:Draw()
     return false
end
--addons/vanilla-tools/lua/entities/hyperspace_highwake/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
    surface.PlaySound("vanilla/hyperspace/vanilla_highwake.wav")
end

--addons/vanilla-tools/lua/entities/hyperspace_ship/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
    local sound1 = "vanilla/hyperspace/vanilla_hyperspace_01.wav"
    local sound2 = "vanilla/hyperspace/vanilla_hyperspace_02.wav"

    if self:GetPlaySound() == "1" then
        local choose = math.random(0,1)
    	if choose == 0 then
    		surface.PlaySound(sound1)
    	else
    		surface.PlaySound(sound2)
    	end
    end
end

function ENT:Draw()
    self:DrawModel()
end

--addons/vanilla-tools/lua/entities/hyperspace_ship/shared.lua:
ENT.Type 		= "anim"
ENT.Base 		= "base_anim"
ENT.PrintName		= "Vanilla_Hyperspace"
ENT.Author		= "VanillaNekoNYAN"
ENT.Spawnable		= false
ENT.AdminSpawnable	= false

function ENT:SetupDataTables()
    self:NetworkVar("String","1","PlaySound")
end

--gamemodes/starwarsrp/entities/entities/jedi_training_droid/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Jedi Trainingsdroide"
ENT.Author = "Eternal & Hevoc & Deltaa"
ENT.Purpose = "Trainingsdroide für das Lichtschwertraining"
ENT.Instructions = "E zum Start"
ENT.Category = "CW:RP Jedi"
ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.IsActive = false

function ENT:Use(activator, caller)
	if self.IsActive then
		Notify:Warning(activator, "Fehler!", "Der Droide ist bereits aktiv!")
		return
	end

	if self.NextUse and self.NextUse >= CurTime() then return end

	net.Start("JediDroid.Use")
	net.WriteEntity(self)
	net.Send(activator)

	self.NextUse = CurTime() + 1
end

function ENT:GetActiveWeapon()
	return self
end
--addons/lvs_turret/lua/entities/joes_sam_turret_lfs/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--addons/lvs_turret/lua/entities/joes_sam_turret_lvs/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end
--addons/lvs_turret/lua/entities/joes_turret_base_lvs/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Joes LVS Turret Base"
ENT.Category = "Joe | Turrets"

DEFINE_BASECLASS( "lvs_base" )

ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Editable = true

ENT.LVS = true

ENT.model = "models/sam_model/base.mdl"

ENT.HideDriver = true
ENT.SeatPos = Vector(00,0,0)
ENT.SeatAng = Angle(0,-90,0)

ENT.MaxHealth = 5000
ENT.MaxShield = 0 --set 0 for no shield
ENT.Range = 60000 --range at which it will see the target
ENT.LoseTargetDistance = ENT.Range + 1000 --range at which it will lose the target
ENT.Clip = 8 --ammount of ammo before reload, set to -1 for inf
ENT.mass = 500
ENT.team = 1 --0 friendly to all, 1 good guys, 2 bad guys, 3 hostile to all

ENT.targetgroundvehicles = true
ENT.targetairvehicles = true
ENT.targethumans = true

ENT.BarrelPos = {
	[1] = Vector(-22,30,4),
	[2] = Vector(-22,21,4),
	[3] = Vector(-22,30,-4),
	[4] = Vector(-22,21,-4),
	[5] = Vector(-22,-21,4),
	[6] = Vector(-22,-30,4),
	[7] = Vector(-22,-21,-4),
	[8] = Vector(-22,-30,-4),
}

/*
function ENT:SetupDataTables()

	self:NetworkVar( "Entity",0, "Driver" )
	self:NetworkVar( "Entity",1, "DriverSeat" )
	self:NetworkVar( "Entity",2, "Gunner" )
	self:NetworkVar( "Entity",3, "GunnerSeat" )

	self:NetworkVar("Float",27, "Shield" )

	self:NetworkVar("Int",16, "AmmoPrimary" )
	self:NetworkVar("Int",17, "AmmoSecondary" )

	self:NetworkVar( "Float",2, "RPM" )
	self:NetworkVar( "Bool",3, "RotorDestroyed" )
	self:NetworkVar( "Bool",4, "EngineActive" )
	self:NetworkVar( "Bool",7, "lfsLockedStatus" )
	self:NetworkVar( "Bool",5, "Active" )
	self:NetworkVar( "Bool",6, "AI")
	self:NetworkVar( "Float",8, "MaintenanceProgress" )

	self:NetworkVar("Int",0, "AITEAM", { KeyName = "aiteam", Edit = { type = "Int", order = 1,min = 1, max = 3, category = "AI"} } )
	self:NetworkVar("Int",1, "ShootInterval", { KeyName = "shootint", Edit = { type = "Int", order = 1,min = 1, max = 10, category = "Shooting"} } )
	self:NetworkVar("Int",2, "ReloadTime", { KeyName = "reloadtime", Edit = { type = "Int", order = 1,min = 1, max = 20, category = "Shooting"} } )
	self:NetworkVar("Float",0, "HP", { KeyName = "Health", Edit = { type = "Float", order = 0,min = 0, max = self.MaxHealth} } )
	self:NetworkVar("Float",3, "Range", { KeyName = "range", Edit = { type = "Float", order = 5,min = 100, max = 100000} } )
	self:NetworkVar("Float",4, "LoseTargetDistance", { KeyName = "loseTargetDistance" } )
	self:NetworkVar("Bool",11, "TargetAir", { KeyName = "Target Air", Edit = { type = "Boolean", order = 1, category = "Type"} } )
	self:NetworkVar("Bool",12, "TargetGround", { KeyName = "Target Vehicles", Edit = { type = "Boolean", order = 1, category = "Type"} } )
	self:NetworkVar("Bool",13, "TargetHumans", { KeyName = "Target humans", Edit = { type = "Boolean", order = 1, category = "Type"} } )

	self:NetworkVar("Bool",1, "AIEnabled", { KeyName = "AIenabled", Edit = { type = "Boolean", order = 1} } )

	if self.team == 0 then
		self:SetAITEAM(3)
	else
		self:SetAITEAM(self.team)
	end
	self:SetShootInterval(2)
	self:SetReloadTime(10)
	self:SetHP(self.MaxHealth)
	self:SetShield(self.MaxShield)
	self:SetRange(self.Range)
	self:SetLoseTargetDistance(self.LoseTargetDistance)
	self:SetAmmoPrimary(self.Clip)
	self:SetAIEnabled(false)
	self:SetTargetAir(self.targetairvehicles)
	self:SetTargetGround(self.targetgroundvehicles)
	self:SetTargetHumans(self.targethumans)

	if SERVER then
		self:NetworkVarNotify( "Range", self.SetRangeStuff )
	end
end
function ENT:SetRangeStuff(name, old, new)
	self:SetLoseTargetDistance(new + 1000)
end
*/

function ENT:OnSetupDataTables()
	self:AddDT("Int", "ShootInterval", { KeyName = "shootint", Edit = { type = "Int", order = 1,min = 1, max = 10, category = "Shooting"} } )
	self:AddDT("Int", "ReloadTime", { KeyName = "reloadtime", Edit = { type = "Int", order = 1,min = 1, max = 20, category = "Shooting"} } )
	//self:AddDT("Float", "HP", { KeyName = "Health", Edit = { type = "Float", order = 0,min = 0, max = self.MaxHealth} } )
	self:AddDT("Float", "Range", { KeyName = "range", Edit = { type = "Float", order = 5,min = 100, max = 100000} } )
	self:AddDT("Float", "LoseTargetDistance", { KeyName = "loseTargetDistance" } )
	self:AddDT("Bool", "TargetAir", { KeyName = "Target Air", Edit = { type = "Boolean", order = 1, category = "Type"} } )
	self:AddDT("Bool", "TargetGround", { KeyName = "Target Vehicles", Edit = { type = "Boolean", order = 1, category = "Type"} } )
	self:AddDT("Bool", "TargetHumans", { KeyName = "Target humans", Edit = { type = "Boolean", order = 1, category = "Type"} } )
	self:AddDT("Int", "AmmoPrimary" )
	self:AddDT("Int", "AmmoSecondary" )

	if self.team == 0 then
		self:SetAITEAM(3)
	else
		self:SetAITEAM(self.team)
	end

	self:SetShootInterval(2)
	self:SetReloadTime(10)
	self:SetHP(self.MaxHealth)
	self:SetShield(self.MaxShield)
	self:SetRange(self.Range)
	self:SetLoseTargetDistance(self.LoseTargetDistance)
	self:SetAmmoPrimary(self.Clip)
	self:SetAI(false)
	self:SetTargetAir(self.targetairvehicles)
	self:SetTargetGround(self.targetgroundvehicles)
	self:SetTargetHumans(self.targethumans)
end
--addons/egm_lvs_ships/lua/entities/laat_dioxisbomb/shared.lua:
ENT.Base            = "base_gmodentity"
ENT.Type            = "anim"

ENT.PrintName       = "Detonator"
ENT.Author          = "Deltaa"
ENT.Information     = ""
ENT.Category        = "[LVS] - Republik"

ENT.Spawnable		= false
ENT.AdminSpawnable	= false

ENT.BounceSound = Sound("TFA_CSGO_SmokeGrenade.Bounce")
ENT.ExplodeSound = Sound("weapons/tfa_starwars/Smoke_Explosive_Puff_01.wav")
--lua/entities/laat_mainrocket.lua:
AddCSLuaFile()

ENT.Type            = "anim"
DEFINE_BASECLASS( "lunasflightschool_missile" )

if SERVER then
    function ENT:Initialize()	
		self:SetModel( "models/weapons/w_missile_launch.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetRenderMode( RENDERMODE_TRANSALPHA )
		self:PhysWake()
		local pObj = self:GetPhysicsObject()
		
		if IsValid( pObj ) then
			pObj:EnableGravity( false ) 
			pObj:SetMass( 1 ) 
		end
		
		self.LifeTime = CurTime() + 12
	end

	local function GetValidEntity(ent)
		return IsValid(ent) and ent or Entity(0)
	end

    function ENT:Think()	
		local curtime = CurTime()
		self:NextThink(curtime)
		
		self:BlindFire()
		
		if self.MarkForRemove then
			self:Detonate()
		end
		
		if self.Explode then
			local Inflictor = self:GetInflictor()
			local Attacker = self:GetAttacker()

			util.BlastDamage(GetValidEntity(Inflictor), GetValidEntity(Attacker), self:GetPos(), 500, 500)
			
			self:Detonate()
		end
		
		if self.LifeTime <= curtime then
			self:Detonate()
		end
		
		return true
	end

    function ENT:PhysicsCollide( data )
		if self:GetDisabled() then
			self.MarkForRemove = true
		else
			local HitEnt = data.HitEntity
			
			if IsValid(HitEnt) && not self.Explode && (HitEnt.LFS || HitEnt.IdentifiesAsLFS) then 
                local Pos = self:GetPos()

                local effectdata = EffectData()
                    effectdata:SetOrigin(Pos)
                    effectdata:SetNormal(-self:GetForward())
                util.Effect("manhacksparks", effectdata, true, true)

                local dmginfo = DamageInfo()
                    dmginfo:SetDamage(500)
                    dmginfo:SetAttacker(IsValid(self:GetAttacker()) && self:GetAttacker() || self)
                    dmginfo:SetDamageType(DMG_BLAST)
                    dmginfo:SetInflictor(self) 
                    dmginfo:SetDamagePosition(Pos) 
                HitEnt:TakeDamageInfo(dmginfo)

                sound.Play("Missile.ShotDown", Pos, 140)
			end
			
			self.Explode = true
		end
	end
end
--addons/egm_lvs_ships/lua/entities/laat_symoxinbomb/shared.lua:
ENT.Base            = "base_gmodentity"
ENT.Type            = "anim"

ENT.PrintName       = "Detonator"
ENT.Author          = "Deltaa"
ENT.Information     = ""
ENT.Category        = "[LVS] - Republik"

ENT.Spawnable		= false
ENT.AdminSpawnable	= false

ENT.BounceSound = Sound("TFA_CSGO_SmokeGrenade.Bounce")
ENT.ExplodeSound = Sound("weapons/tfa_starwars/Smoke_Explosive_Puff_01.wav")
--lua/entities/ladder_base/shared.lua:
if (SERVER) then
	AddCSLuaFile();
end;

DEFINE_BASECLASS("base_entity");

ENT.PrintName		= "Ladder (BASE)";
ENT.Category		= "Ladders";
ENT.Spawnable		= false;
ENT.AdminOnly		= false;
ENT.Model			= Model("models/props_c17/metalladder001.mdl");
ENT.RenderGroup 	= RENDERGROUP_BOTH;

if (SERVER) then

	function ENT:Initialize()
		self:SetModel(self.Model);
		self:SetSolid(SOLID_VPHYSICS);
		self:PhysicsInit(SOLID_VPHYSICS);
		self:SetUseType(SIMPLE_USE);
		self:SetCollisionGroup(COLLISION_GROUP_WEAPON);
		local phys = self:GetPhysicsObject();

		if (IsValid(phys)) then
			phys:EnableMotion(false);
		end;

		self:UpdateLadder(true);
	end;

	function ENT:UpdateLadder(bCreate)
		if (bCreate) then
			local oldAngs = self:GetAngles();

			self:SetAngles(Angle(0, 0, 0));

			local pos = self:GetPos();
			local dist = self:OBBMaxs().x + 17;
			local dismountDist = self:OBBMaxs().x + 49;
			local bottom = self:LocalToWorld(Vector(0, 0, self:OBBMins().z));
			local top = self:LocalToWorld(Vector(0, 0, self:OBBMaxs().z));

			for k, v in pairs(self:GetChildren()) do
				SafeRemoveEntity(v);
			end;

			self.ladder = ents.Create("func_useableladder");
			self.ladder:SetPos(pos + self:GetForward() * dist);
			self.ladder:SetKeyValue("point0", tostring(bottom + self:GetForward() * dist));
			self.ladder:SetKeyValue("point1", tostring(top + self:GetForward() * dist));
			self.ladder:SetKeyValue("targetname", "zladder_" .. self:EntIndex());
			self.ladder:SetParent(self);
			self.ladder:Spawn();

			self.bottomDismount = ents.Create("info_ladder_dismount");
			self.bottomDismount:SetPos(bottom + self:GetForward() * dismountDist);
			self.bottomDismount:SetKeyValue("laddername", "zladder_" .. self:EntIndex());
			self.bottomDismount:SetParent(self);
			self.bottomDismount:Spawn();

			self.topDismount = ents.Create("info_ladder_dismount");
			self.topDismount:SetPos(top - self:GetForward() * dist);
			self.topDismount:SetKeyValue("laddername", "zladder_" .. self:EntIndex());
			self.topDismount:SetParent(self);
			self.topDismount:Spawn();

			self.ladder:Activate();

			self:SetAngles(oldAngs);
		else
			self.ladder:Activate();
		end;
	end;

	function ENT:Think()
		if (IsValid(self.ladder)) then
			self:UpdateLadder();
			self:NextThink(CurTime() + 1);
			return true;
		end;
	end;

elseif (CLIENT) then

	function ENT:Initialize()
		self:SetSolid(SOLID_VPHYSICS);
	end;

	function ENT:Draw()
		self:DrawModel();
	end;
end;
--lua/entities/ladder_small2/shared.lua:
if (SERVER) then
	AddCSLuaFile();
end;

ENT.Type 			= "anim";
ENT.Base 			= "ladder_base";
ENT.PrintName		= "Ladder (Small - Attached)"
ENT.Category		= "Ladders"
ENT.Spawnable		= true
ENT.AdminOnly		= false
ENT.Model			= Model("models/props_c17/metalladder002.mdl");
ENT.RenderGroup 	= RENDERGROUP_BOTH;
--addons/lvs_base/lua/entities/lvs_base/cl_trailsystem.lua:

ENT.TrailMaterial = Material( "trails/smoke" )
ENT.TrailRed = 255
ENT.TrailGreen = 255
ENT.TrailBlue = 255
ENT.TrailAlpha = 100

function ENT:OnTrail( active, id )
end

function ENT:HandleTrail()
	if not self.RegisteredTrailPositions then return end

	local FT = RealFrameTime()

	local pos = self:GetPos()
	local vel = self:GetVelocity()
	local vel_length = vel:Length()

	for id, data in pairs( self.RegisteredTrailPositions ) do
		local cur_pos = self:LocalToWorld( data.pos )
		local cur_vel = (cur_pos - data.oldpos) / FT

		local cur_velL = math.abs( self:WorldToLocal( pos + cur_vel ).z )

		if cur_velL > data.activation_speed and vel_length > data.min_flight_speed then
			if not data.id then
				data.id = self:StartTrail( data.pos, data.startsize, data.endsize, data.lifetime )
				self:OnTrail( true, data.id )
			end
		else
			if data.id then
				self:OnTrail( false, data.id )
				self:FinishTrail( data.id )
				data.id = nil
			end
		end

		data.oldpos = cur_pos
	end
end

function ENT:RegisterTrail( Pos, StartSize, EndSize, LifeTime, min_flight_speed, activation_speed )
	if not istable( self.RegisteredTrailPositions ) then
		self.RegisteredTrailPositions = {}
	end

	local data = {
		pos = Pos,
		oldpos = self:LocalToWorld( Pos ),
		startsize = StartSize,
		endsize = EndSize,
		lifetime = LifeTime,
		min_flight_speed = min_flight_speed,
		activation_speed = activation_speed,
	}

	table.insert( self.RegisteredTrailPositions, data )
end

function ENT:StartTrail( Pos, StartSize, EndSize, LifeTime )
	if not LVS.ShowTraileffects then return end

	if not istable( self.TrailActive ) then
		self.TrailActive = {}
	end

	local ID = 1
	for _,_ in ipairs( self.TrailActive ) do
		ID = ID + 1
	end

	self.TrailActive[ ID ] = {
		lifetime = LifeTime,
		start_size = StartSize,
		end_size = EndSize,
		pos = Pos,
		active = true,
		positions = {},
	}

	return ID
end

function ENT:FinishTrail( ID )
	self.TrailActive[ ID ].active = false
end

function ENT:DrawTrail()
	local EntTable = self:GetTable()

	if not EntTable.TrailActive then return end

	local Time = CurTime()

	EntTable._NextTrail = EntTable._NextTrail or 0

	local Set = EntTable._NextTrail < Time

	render.SetMaterial( EntTable.TrailMaterial )

	for ID, data in pairs( EntTable.TrailActive ) do

		for pos_id, pos_data in pairs( data.positions ) do
			if Time - pos_data.time > data.lifetime then
				data.positions[ pos_id ] = nil
			end
		end

		if Set then
			if data.active then
				local cur_pos = {
					time = Time,
					pos = self:LocalToWorld( data.pos ),
				}

				table.insert( data.positions, cur_pos )
				table.sort( data.positions, function( a, b ) return a.time > b.time end )
			end
		end

		local num = #data.positions

		if num == 0 then 
			if not data.active then
				EntTable.TrailActive[ ID ] = nil
			end

			continue
		end

		render.StartBeam( num )

		for _, pos_data in ipairs( data.positions ) do
			local Scale = (pos_data.time + data.lifetime - Time) / data.lifetime
			local InvScale = 1 - Scale

			render.AddBeam( pos_data.pos, data.start_size * Scale + data.end_size * InvScale, pos_data.time * 50, Color( EntTable.TrailRed, EntTable.TrailGreen, EntTable.TrailBlue, EntTable.TrailAlpha * Scale ^ 2 ) )
		end

		render.EndBeam()
	end

	if Set then
		EntTable._NextTrail = Time + 0.025
	end
end

--addons/lvs_base/lua/entities/lvs_base_doorhandler.lua:
AddCSLuaFile()

ENT.Type            = "anim"
ENT.DoNotDuplicate = true

ENT.RenderGroup = RENDERGROUP_BOTH 

ENT.UseRange = 75

ENT._UseTargetAllowed = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )

	self:NetworkVar( "Bool",0, "Active" )

	self:NetworkVar( "String",0, "PoseName" )

	self:NetworkVar( "Vector",0, "Mins" )
	self:NetworkVar( "Vector",1, "Maxs" )

	self:NetworkVar( "Float",0, "Rate" )
	self:NetworkVar( "Float",1, "RateExponent" )

	self:NetworkVar( "Float",2, "PoseMin" )
	self:NetworkVar( "Float",3, "PoseMax" )

	if SERVER then
		self:SetRate( 10 )
		self:SetRateExponent( 2 )

		self:SetPoseMax( 1 )
	end
end

function ENT:IsServerSide()
	local EntTable = self:GetTable()

	if isbool( EntTable._IsServerSide ) then return EntTable._IsServerSide end

	local PoseName = self:GetPoseName()

	if PoseName == "" then return false end

	local IsServerSide = string.StartsWith( PoseName, "^" )

	EntTable._IsServerSide = IsServerSide

	return IsServerSide
end

function ENT:IsOpen()
	return self:GetActive()
end

function ENT:InRange( ply, Range )
	local boxOrigin = self:GetPos()
	local boxAngles = self:GetAngles()
	local boxMins = self:GetMins()
	local boxMaxs = self:GetMaxs()

	local HitPos, _, _ = util.IntersectRayWithOBB( ply:GetShootPos(), ply:GetAimVector() * Range, boxOrigin, boxAngles, boxMins, boxMaxs )

	return isvector( HitPos )
end

if SERVER then
	AccessorFunc(ENT, "soundopen", "SoundOpen", FORCE_STRING)
	AccessorFunc(ENT, "soundclose", "SoundClose", FORCE_STRING)

	AccessorFunc(ENT, "maxsopen", "MaxsOpen", FORCE_VECTOR)
	AccessorFunc(ENT, "minsopen", "MinsOpen", FORCE_VECTOR)

	AccessorFunc(ENT, "maxsclosed", "MaxsClosed", FORCE_VECTOR)
	AccessorFunc(ENT, "minsclosed", "MinsClosed", FORCE_VECTOR)


	util.AddNetworkString( "lvs_doorhandler_interact" )

	net.Receive( "lvs_doorhandler_interact", function( length, ply )
		if not IsValid( ply ) then return end

		local ent = net.ReadEntity()

		if not IsValid( ent ) or not ent._UseTargetAllowed or not ent.UseRange or ply:InVehicle() then return end

		local Range = ent.UseRange * 2

		if (ply:GetPos() - ent:GetPos()):Length() > Range then return end

		if not ent:InRange( ply, Range ) then return end

		ent:Use( ply, ply )
	end)

	function ENT:LinkToSeat( ent )
		if not IsValid( ent ) or not ent:IsVehicle() then

			ErrorNoHalt( "[LVS] Couldn't link seat to doorsystem. Entity expected, got "..tostring( ent ).."\n" )

			return
		end

		self._LinkedSeat = ent
	end

	function ENT:GetLinkedSeat()
		return self._LinkedSeat
	end

	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:SetUseType( SIMPLE_USE )
		self:DrawShadow( false )
		debugoverlay.Cross( self:GetPos(), 15, 5, Color( 255, 223, 127 ) )
	end

	function ENT:Use( ply )
		if not IsValid( ply ) then return end

		local Base = self:GetBase()

		if not IsValid( Base ) then return end

		if not Base:IsUseAllowed( ply ) then return end

		if self:IsOpen() then
			self:Close( ply )
		else
			self:Open( ply )
		end
	end

	function ENT:OnOpen( ply )
	end

	function ENT:OnClosed( ply )
	end

	function ENT:OpenAndClose( ply )
		self:Open( ply )

		self._PreventClosing = true

		timer.Simple(0.5, function()
			if not IsValid( self ) then return end

			self:Close( ply )

			self._PreventClosing = false
		end )
	end

	function ENT:DisableOnBodyGroup( group, subgroup )
		self._BodyGroupDisable = group
		self._BodySubGroupDisable = subgroup
	end

	function ENT:IsBodyGroupDisabled()
		if not self._BodyGroupDisable or not self._BodySubGroupDisable then return false end

		local base = self:GetBase()

		if not IsValid( base ) then return false end

		return base:GetBodygroup( self._BodyGroupDisable ) == self._BodySubGroupDisable
	end

	function ENT:Open( ply )
		if self:IsOpen() then return end

		self:SetActive( true )
		self:SetMins( self:GetMinsOpen() )
		self:SetMaxs( self:GetMaxsOpen() )

		if self:IsBodyGroupDisabled() then return end

		self:OnOpen( ply )

		local snd = self:GetSoundOpen()

		if not snd then return end

		self:EmitSound( snd )
	end

	function ENT:Close( ply )
		if not self:IsOpen() then
			if self:IsBodyGroupDisabled() then
				self:Open( ply )
			end

			return
		end

		if self:IsBodyGroupDisabled() then return end

		self:SetActive( false )
		self:SetMins( self:GetMinsClosed() )
		self:SetMaxs( self:GetMaxsClosed() )

		self:OnClosed( ply )

		local snd = self:GetSoundClose()

		if not snd then return end

		self:EmitSound( snd )
	end

	function ENT:OnDriverChanged( oldDriver, newDriver, pod )
		if self._PreventClosing then return end

		if IsValid( newDriver ) then
			if self:IsOpen() then
				self:Close( newDriver )
			end
		else
			timer.Simple( FrameTime() * 2, function()
				if not IsValid( self ) or not IsValid( oldDriver ) or IsValid( self._Driver ) then return end

				if oldDriver:lvsGetVehicle() == self:GetBase() then return end

				if not self:IsOpen() then
					self:OpenAndClose()
				end
			end )
		end
	end

	function ENT:SetPoseParameterSV()
		local Base = self:GetBase()

		if not IsValid( Base ) then return end

		local Target = self:GetActive() and self:GetPoseMax() or self:GetPoseMin()
		local poseName = self:GetPoseName()

		if poseName == "" then return end

		local EntTable = self:GetTable()

		EntTable.sm_pp = EntTable.sm_pp and EntTable.sm_pp + (Target - EntTable.sm_pp) * FrameTime() * self:GetRate() or 0

		local value = EntTable.sm_pp ^ self:GetRateExponent()

		Base:SetPoseParameter( string.Replace(poseName, "^", ""), value )
	end

	function ENT:Think()
		if IsValid( self._LinkedSeat ) then
			local Driver = self._LinkedSeat:GetDriver()
	
			if self._Driver ~= Driver then
			
				self:OnDriverChanged( self._Driver, Driver, self._LinkedSeat )

				self._Driver = Driver
			end
		end

		if self:IsServerSide() then
			self:SetPoseParameterSV()

			self:NextThink( CurTime() )
		else
			self:NextThink( CurTime() + 0.25 )
		end

		return true
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	return
end

function ENT:Initialize()
end

function ENT:Think()
	if self:IsServerSide() then return end

	local Base = self:GetBase()

	if not IsValid( Base ) then return end

	local Target = self:GetActive() and self:GetPoseMax() or self:GetPoseMin()
	local poseName = self:GetPoseName()

	if poseName == "" then return end

	local EntTable = self:GetTable()

	EntTable.sm_pp = EntTable.sm_pp and EntTable.sm_pp + (Target - EntTable.sm_pp) * RealFrameTime() * self:GetRate() or 0

	local value = EntTable.sm_pp ^ self:GetRateExponent()

	if string.StartsWith( poseName, "!" ) then
		Base:SetBonePoseParameter( poseName, value )
	else
		Base:SetPoseParameter( poseName, value )
	end
end

function ENT:OnRemove()
end

function ENT:Draw()
end

local LVS = LVS
ENT.ColorSelect = Color(127,255,127,150)
ENT.ColorNormal = Color(255,0,0,150)
ENT.ColorTransBlack = Color(0,0,0,150)
ENT.OutlineThickness = Vector(0.5,0.5,0.5)

function ENT:DrawTranslucent()
	local ply = LocalPlayer()

	if not IsValid( ply ) or ply:InVehicle() or not ply:KeyDown( IN_SPEED ) then return end

	local InRange = self:InRange( ply, self.UseRange )

	if InRange then
		local EntTable = self:GetTable()

		local Use = ply:KeyDown( IN_USE )

		if EntTable.old_Use ~= Use then
			EntTable.old_Use = Use

			if Use then
				net.Start( "lvs_doorhandler_interact" )
					net.WriteEntity( self )
				net.SendToServer()
			end
		end
	end

	if not LVS.DeveloperEnabled then return end

	local boxOrigin = self:GetPos()
	local boxAngles = self:GetAngles()
	local boxMins = self:GetMins()
	local boxMaxs = self:GetMaxs()

	local EntTable = self:GetTable()

	local Col = InRange and EntTable.ColorSelect or EntTable.ColorNormal

	render.SetColorMaterial()
	render.DrawBox( boxOrigin, boxAngles, boxMins, boxMaxs, Col )
	render.DrawBox( boxOrigin, boxAngles, boxMaxs + EntTable.OutlineThickness, boxMins - EntTable.OutlineThickness, EntTable.ColorTransBlack )
end

--addons/lvs_starwars/lua/entities/lvs_base_fakehover/sh_camera_eyetrace.lua:

function ENT:GetEyeTrace( trace_forward )
	local startpos = self:LocalToWorld( self:OBBCenter() )

	local pod = self:GetDriverSeat()

	if IsValid( pod ) then
		startpos = pod:LocalToWorld( pod:OBBCenter() )
	end

	local AimVector = trace_forward and self:GetForward() or self:GetAimVector()

	local data = {
		start = startpos,
		endpos = (startpos + AimVector * 50000),
		filter = self:GetCrosshairFilterEnts(),
	}

	local trace = util.TraceLine( data )

	return trace
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetAIAimVector()
	end

	local Driver = self:GetDriver()

	if not IsValid( Driver ) then return self:GetForward() end

	if SERVER then
		local pod = self:GetDriverSeat()

		if not IsValid( pod ) then return Driver:EyeAngles():Forward() end

		return pod:WorldToLocalAngles( Driver:EyeAngles() ):Forward()
	else
		return Driver:EyeAngles():Forward()
	end
end

--addons/lvs_base/lua/entities/lvs_base_gunner/cl_init.lua:
include("shared.lua")

function ENT:Think()
end

function ENT:OnRemove()
end

function ENT:Draw()
end

function ENT:DrawTranslucent()
end

function ENT:GetAimVector()
	if self:GetAI() then
		return self:GetNWAimVector()
	end

	local Driver = self:GetDriver()

	if IsValid( Driver ) then
		if self._AimVectorUnlocked then
			local pod = self:GetDriverSeat()

			if IsValid( pod ) then
				return pod:WorldToLocalAngles( Driver:EyeAngles() ):Forward()
			end
		end

		return Driver:GetAimVector()
	else
		return self:GetForward()
	end
end

function ENT:LVSPaintHitMarker( scr )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:LVSPaintHitMarker( scr )
end

function ENT:LVSDrawCircle( X, Y, target_radius, value )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:LVSDrawCircle( X, Y, target_radius, value )
end

function ENT:PaintCrosshairCenter( Pos2D, Col )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:PaintCrosshairCenter( Pos2D, Col )
end

function ENT:PaintCrosshairOuter( Pos2D, Col )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:PaintCrosshairOuter( Pos2D, Col )
end

function ENT:PaintCrosshairSquare( Pos2D, Col )
	local Base = self:GetVehicle()

	if not IsValid( Base ) then return end

	Base:PaintCrosshairSquare( Pos2D, Col )
end

--addons/lvs_starwars/lua/entities/lvs_base_starfighter/cl_flyby.lua:

ENT.FlyByAdvance = 0

function ENT:FlyByThink()
	local ply = LocalPlayer()

	if not IsValid( ply ) then return end

	if ply:lvsGetVehicle() == self then self.OldApproaching = false return end

	local ViewEnt = ply:GetViewEntity()

	if not IsValid( ViewEnt ) then return end

	local Time = CurTime()

	if (self._nextflyby or 0) > Time then return end

	self._nextflyby = Time + 0.1

	local Vel = self:GetVelocity()

	if self:GetThrottle() <= 0.75 or Vel:Length() <= self.MaxVelocity * 0.75 then return end

	local Sub = ViewEnt:GetPos() - self:GetPos() - Vel * self.FlyByAdvance
	local ToPlayer = Sub:GetNormalized()
	local VelDir = Vel:GetNormalized()

	local ApproachAngle = math.deg( math.acos( math.Clamp( ToPlayer:Dot( VelDir ) ,-1,1) ) )

	local Approaching = ApproachAngle < 80

	if Approaching ~= self.OldApproaching then
		self.OldApproaching = Approaching

		if Approaching then
			self:StopFlyBy()
		else
			self:OnFlyBy( 60 + 80 * math.min(ApproachAngle / 140,1) )
		end
	end
end

function ENT:OnFlyBy( Pitch )
	if not self.FlyBySound then return end

	self.flybysnd = CreateSound( self, self.FlyBySound )
	self.flybysnd:SetSoundLevel( 95 )
	self.flybysnd:PlayEx( 1, Pitch )
end

function ENT:StopFlyBy()
	if self.flybysnd then
		self.flybysnd:Stop()
		self.flybysnd = nil
	end
end
--addons/lvs_base/lua/entities/lvs_destruction.lua:
AddCSLuaFile()

ENT.Type            = "anim"

local gibs = {
	"models/gibs/manhack_gib01.mdl",
	"models/gibs/manhack_gib02.mdl",
	"models/gibs/manhack_gib03.mdl",
	"models/gibs/manhack_gib04.mdl",
	"models/props_c17/canisterchunk01a.mdl",
	"models/props_c17/canisterchunk01d.mdl",
	"models/props_c17/oildrumchunk01a.mdl",
	"models/props_c17/oildrumchunk01b.mdl",
	"models/props_c17/oildrumchunk01c.mdl",
	"models/props_c17/oildrumchunk01d.mdl",
	"models/props_c17/oildrumchunk01e.mdl",
}

for _, modelName in ipairs( gibs ) do
	util.PrecacheModel( modelName )
end

if SERVER then
	function ENT:Initialize()
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false ) 

		self.Vel = isvector( self.Vel ) and self.Vel or Vector(0,0,0)

		local fxPos = self:LocalToWorld( self:OBBCenter() )
	
		local effectdata = EffectData()
			effectdata:SetOrigin( fxPos )
		util.Effect( "lvs_explosion", effectdata )

		self.GibModels = istable( self.GibModels ) and self.GibModels or gibs

		self.Gibs = {}
		self.DieTime = CurTime() + 5

		local Speed = self.Vel:Length()

		for _, v in pairs( self.GibModels ) do
			local ent = ents.Create( "prop_physics" )

			if not IsValid( ent ) then continue end

			table.insert( self.Gibs, ent ) 

			ent:SetPos( self:GetPos() )
			ent:SetAngles( self:GetAngles() )
			ent:SetModel( v )
			ent:Spawn()
			ent:Activate()
			ent:SetRenderMode( RENDERMODE_TRANSALPHA )
			ent:SetCollisionGroup( COLLISION_GROUP_WORLD )

			local PhysObj = ent:GetPhysicsObject()
			if IsValid( PhysObj ) then
				if Speed <= 250 then
					local GibDir = Vector( math.Rand(-1,1), math.Rand(-1,1), 1.5 ):GetNormalized()
					PhysObj:SetVelocityInstantaneous( GibDir * math.random(800,1300)  )
				else
					PhysObj:SetVelocityInstantaneous( VectorRand() * math.max(300,self.Vel:Length() / 3) + self.Vel  )
				end

				PhysObj:AddAngleVelocity( VectorRand() * 500 ) 
				PhysObj:EnableDrag( false ) 

				local effectdata = EffectData()
					effectdata:SetOrigin( fxPos )
					effectdata:SetStart( PhysObj:GetMassCenter() )
					effectdata:SetEntity( ent )
					effectdata:SetScale( math.Rand(0.3,0.7) )
					effectdata:SetMagnitude( math.Rand(0.5,2.5) )
				util.Effect( "lvs_firetrail", effectdata )
			end

			timer.Simple( 4.5 + math.Rand(0,0.5), function()
				if not IsValid( ent ) then return end

				ent:SetRenderMode( RENDERMODE_TRANSCOLOR )
				ent:SetRenderFX( kRenderFxFadeFast  )
			end )
		end
	end

	function ENT:Think()
		if self.DieTime < CurTime() then
			self:Remove()
		end

		self:NextThink( CurTime() + 1 )

		return true
	end

	function ENT:OnRemove()
		if istable( self.Gibs ) then
			for _, v in pairs( self.Gibs ) do
				if IsValid( v ) then
					v:Remove()
				end
			end
		end
	end
else
	function ENT:Draw()
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_aat/cl_init.lua:
include("shared.lua")
include( "sh_turret.lua" )
include( "cl_prediction.lua" )


function ENT:OnSpawn()
	local mins, maxs = self:GetRenderBounds()
	self:SetRenderBounds( mins, maxs, Vector( 80, 0, 0 ) )
end

function ENT:DamageFX()
	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local HP = self:GetHP()
		local MaxHP = self:GetMaxHP()

		if HP > MaxHP * 0.5 then return end

		local effectdata = EffectData()
			effectdata:SetOrigin( self:LocalToWorld( Vector(11,0,46) ) )
			effectdata:SetEntity( self )
		util.Effect( "lvs_engine_blacksmoke", effectdata )

		if HP <= MaxHP * 0.25 then
			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(11,40,46) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )

			local effectdata = EffectData()
				effectdata:SetOrigin( self:LocalToWorld( Vector(11,-40,46) ) )
				effectdata:SetNormal( self:GetUp() )
				effectdata:SetMagnitude( math.Rand(0.5,1.5) )
				effectdata:SetEntity( self )
			util.Effect( "lvs_exhaust_fire", effectdata )
		end
	end
end

function ENT:OnFrame()
	self:PredictPoseParamaters()
	self:DamageFX()
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if ply == self:GetDriver() and not pod:GetThirdPersonMode() then
		return pos + self:GetForward() * 60 - self:GetUp() * 30, angles, fov
	end

	return pos, angles, fov
end

local COLOR_RED = Color(255,0,0,255)
local COLOR_WHITE = Color(255,255,255,255)

function ENT:LVSPreHudPaint( X, Y, ply )
	if self:GetIsCarried() then return false end

	if ply == self:GetDriver() then
		local Col = self:WeaponsInRange() and COLOR_WHITE or COLOR_RED

		local Pos2D = self:GetEyeTrace().HitPos:ToScreen() 

		self:PaintCrosshairCenter( Pos2D, Col )
		self:PaintCrosshairOuter( Pos2D, Col )
		self:LVSPaintHitMarker( Pos2D )
	end

	return true
end

--addons/egm_lvs_ground/lua/entities/lvs_fakehover_barc_medic/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "BARC-Speeder (Medic)"
ENT.Author = "Deltaa"
ENT.Information = "The Biker Advanced Recon Commando speeder was designed for use by the Grand Army of the Republic during the Clone Wars"
ENT.Category = "[LVS] - Republik"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/barc/barc.mdl"

ENT.AITEAM = 2

ENT.MaxHealth = 1500

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 1000
ENT.MaxVelocityY = 750

ENT.MaxTurnRate = 0.75

ENT.BoostAddVelocityX = 400
ENT.BoostAddVelocityY = 250

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200, 0, 25)
ENT.LAATC_PICKUP_Angle = Angle(0,0,0)

function ENT:OnIsCarried(name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "IsCarried")

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		{
			Vector(106, 12, 6),
			Vector(106, -12, 6)
		},

		{
			Vector(-30, 25, 33),
			Vector(-30, -25, 33)
		}
	}

	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		for _, pos in pairs(CurPos) do
			local bullet = {}
			bullet.Src = ent:LocalToWorld(pos)
			bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
			bullet.Spread = Vector(0.05,  0.05, 0)
			bullet.TracerName = "lvs_laser_blue_long"
			bullet.Force = 100
			bullet.HullSize = 1
			bullet.Damage = 100
			bullet.Velocity = 40000
			bullet.Attacker = ent:GetDriver()
			bullet.Callback = function(att, tr, dmginfo)
				dmginfo:SetDamageType(DMG_AIRBOAT)

				local effectdata = EffectData()
				effectdata:SetStart(Vector(0, 0, 255))
				effectdata:SetOrigin(tr.HitPos)
				effectdata:SetNormal( tr.HitNormal )
				util.Effect("lvs_laser_explosion", effectdata)
			end
			ent:LVSFireBullet(bullet)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(0, 0, 255))
			effectdata:SetOrigin(bullet.Src)
			effectdata:SetNormal(ent:GetForward())
			effectdata:SetEntity(ent)
			util.Effect("lvs_muzzle_colorable", effectdata)

			ent:TakeAmmo()
		end

		if ent.NumPrim == 1 then
			ent.SNDFront:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		else
			ent.SNDRear:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon( weapon )
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/barc/engine_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	}
}

function ENT:CalcMainActivity(ply)
	local pod = ply:GetVehicle()

	if pod == self:GetDriverSeat() then
		return
	end

	return ACT_DRIVE_POD, -1
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_extum/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color(224, 0, 0, 254)
ENT.EngineColor2 = Color(255, 164, 163)
ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EnginePos = {
	Vector(19, 11, 15),
	Vector(19, -12, 15)
}

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end

	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local effectdata = EffectData()
		effectdata:SetOrigin( self:LocalToWorld( Vector(-90,0,40) ) )
		util.Effect( "lfs_blacksmoke", effectdata )
	end
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 15 + self:GetThrottle() * 5

	render.SetMaterial(self.EngineGlow)
	for _, pos in pairs(self.EnginePos) do
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)

		render.DrawSprite(self:LocalToWorld(pos), 16, 16, self.EngineColor2)
		render.DrawSprite(self:LocalToWorld(pos), 12, 12, self.EngineColor2)
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_extum/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Extum Speeder"
ENT.Author = "Deltaa"
ENT.Information = ""
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/myproject5/mesh_2406.mdl"

ENT.AITEAM = 0

ENT.MaxHealth = 1750

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 750
ENT.MaxVelocityY = 600

ENT.MaxTurnRate = 0.8

ENT.BoostAddVelocityX = 100
ENT.BoostAddVelocityY = 50

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200, 0, 30)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT( "Bool", "IsCarried" )

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/x-34/engine_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	}
}
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_mtt/cl_init.lua:
include("shared.lua")

function ENT:CalcViewOverride(ply, pos, angles, fov, pod)
	if not pod:GetThirdPersonMode() then
		return self:LocalToWorld(Vector(350, 0, 300)), angles, fov
	else
		return self:LocalToWorld(Vector(-150, 0, 250)), angles, fov
	end
end

function ENT:DamageFX()
	local HP = self:GetHP()
	if HP == 0 or HP > self:GetMaxHP() * 0.5 then return end

	self.nextDFX = self.nextDFX or 0

	if self.nextDFX < CurTime() then
		self.nextDFX = CurTime() + 0.05

		local effectdata = EffectData()
		effectdata:SetOrigin( self:LocalToWorld( Vector(-90,0,40) ) )
		util.Effect( "lfs_blacksmoke", effectdata )
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_mtt/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "MTT"
ENT.Author = "Deltaa"
ENT.Information = "The Multi-Troop Transport (MTT) was a heavily armored repulsorlift transport vehicle manufactured by Baktoid Armor Workshop."
ENT.Category = "[LVS] - Separatisten"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.AITEAM = 1

ENT.MDL = "models/heracles421/galactica_vehicles/mtt.mdl"

ENT.MaxHealth = 60000

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 100
ENT.MaxVelocityY = 100

ENT.MaxTurnRate = 0.5

ENT.BoostAddVelocityX = 50
ENT.BoostAddVelocityY = 50

ENT.GroundTraceHitWater = true
ENT.GroundTraceLength = 50
ENT.GroundTraceHull = 100

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "IsCarried")

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:InitWeapons()
	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.25
	weapon.Attack = function(ent)
		local ID1 = self:LookupAttachment("muzzle_right_top")
		local ID2 = self:LookupAttachment("muzzle_right_bottom")
		local ID3 = self:LookupAttachment("muzzle_left_top")
		local ID4 = self:LookupAttachment("muzzle_left_bottom")

		local Muzzle1 = self:GetAttachment(ID1)
		local Muzzle2 = self:GetAttachment(ID2)
		local Muzzle3 = self:GetAttachment(ID3)
		local Muzzle4 = self:GetAttachment(ID4)

		if not Muzzle1 or not Muzzle2 or not Muzzle3 or not Muzzle4 then return end

		local FirePos = {
			[1] = Muzzle1,
			[2] = Muzzle2,
			[3] = Muzzle3,
			[4] = Muzzle4,
		}

		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #FirePos then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local Pos = FirePos[ent.NumPrim].Pos
		local Dir = FirePos[ent.NumPrim].Ang:Up()

		local bullet = {}
		bullet.Src = Pos
		bullet.Dir = Dir
		bullet.Spread = Vector(0.05,  0.05, 0)
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 100
		bullet.HullSize = 1
		bullet.Damage = 60
		bullet.Velocity = 40000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			dmginfo:SetDamageType(DMG_AIRBOAT)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(255, 0, 0))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(255, 0, 0))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		if ent.NumPrim == 1 then
			ent.SNDLeft:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
		else
			ent.SNDRight:PlayOnce(100 + math.cos( CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/mtt/engine.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	}
}
--addons/egm_lvs_ground/lua/entities/lvs_fakehover_scavenger/shared.lua:
ENT.Base = "lvs_base_fakehover"

ENT.PrintName = "Scavenger Speeder"
ENT.Author = "Deltaa"
ENT.Information = "The X-34 landspeeder was a model of civilian landspeeder manufactured by SoroSuub Corporation and available during the Galactic Civil War between the Galactic Empire and the Alliance to Restore the Republic."
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/niksacokica/scavenger_speeder/scavenger_speeder.mdl"

ENT.AITEAM = 0

ENT.MaxHealth = 2000

ENT.ForceAngleMultiplier = 2
ENT.ForceAngleDampingMultiplier = 1

ENT.ForceLinearMultiplier = 1
ENT.ForceLinearRate = 0.25

ENT.MaxVelocityX = 750
ENT.MaxVelocityY = 500

ENT.MaxTurnRate = 0.75

ENT.TurnRatePitch = 0.7
ENT.TurnRateYaw = 0.7
ENT.TurnRateRoll = 0.7

ENT.BoostAddVelocityX = 250
ENT.BoostAddVelocityY = 100

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-200, 0, 30)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "IsCarried")

	if SERVER then
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end


function ENT:InitWeapons()
	self.FirePositions = {
		Vector(135, 26, 18),
		Vector(135, -26, 18)
	}
	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.15
	weapon.HeatRateDown = 0.25
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(CurPos)
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.05,  0.05, 0)
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 150
		bullet.HullSize = 10
		bullet.Damage = 150
		bullet.Velocity = 40000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			dmginfo:SetDamageType(DMG_AIRBOAT)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(255, 50, 0))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal( tr.HitNormal )
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(255, 50, 0))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		ent.SNDPrimary:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)
end

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/scavenger/engine_loop.wav",
		Pitch = 70,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 30,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
		SoundLevel = 85,
	}
}
--addons/lvs_base/lua/entities/lvs_item_ammocrate.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Ammo Crate"
ENT.Information = "Single-Use Ammo Refil Item"
ENT.Author = "Luna"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal * 5 )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:Initialize()	
		self:SetModel( "models/items/item_item_crate.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:PhysWake()
	end

	function ENT:Think()
		return false
	end

	function ENT:Refil( entity )
		if self.MarkForRemove then return end

		if not IsValid( entity ) then return end

		if not entity.LVS then return end

		if entity:WeaponRestoreAmmo() then
			entity:EmitSound("items/ammo_pickup.wav")

			self.MarkForRemove = true

			SafeRemoveEntityDelayed( self, 0 )
		end
	end

	function ENT:PhysicsCollide( data, physobj )
		self:Refil( data.HitEntity )
	end

	function ENT:OnTakeDamage( dmginfo )
	end
end

if CLIENT then
	function ENT:Draw( flags )
		self:DrawModel( flags )
	end

	function ENT:OnRemove()
	end

	function ENT:Think()
	end
end

--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_airspeeder/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-100, 40, 10), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-100, -40, 10), 0, 20, 2, 1000, 150)
end


--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_gunship/sh_driverweapons.lua:
function ENT:InitDriverWeapons()
	self.FirePositions = {
		Vector(432, 34, 36),
		Vector(432, -34, 36)
	}

	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.15
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 0.1
	weapon.Attack = function(ent)
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull( {
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector(-10, -10, -10),
			maxs = Vector(10, 10, 10),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(CurPos)
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.05,  0.05, 0)
		bullet.TracerName = "lvs_laser_green"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 300
		bullet.Velocity = 50000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			dmginfo:SetDamageType(DMG_AIRBOAT)

			local effectdata = EffectData()
			effectdata:SetStart(Vector(0, 255, 0))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal( tr.HitNormal )
			util.Effect("lvs_laser_explosion", effectdata)
		end
		ent:LVSFireBullet(bullet)

		local effectdata = EffectData()
		effectdata:SetStart(Vector(0, 255, 0))
		effectdata:SetOrigin(bullet.Src)
		effectdata:SetNormal(ent:GetForward())
		effectdata:SetEntity(ent)
		util.Effect("lvs_muzzle_colorable", effectdata)

		ent:TakeAmmo()

		ent.PrimarySND:PlayOnce(100 + math.cos(CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	-- Proton Torpedo
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 24
	weapon.Delay = 0.25
	weapon.HeatRateUp = 0.75
	weapon.HeatRateDown = 0.1
	weapon.Attack = function(ent)
		if IsValid(ent._ProtonTorpedo) then
			if ent._nextMissleTracking and ent._nextMissleTracking > CurTime() then return end
			ent._nextMissleTracking = CurTime() + 0.1

			ent._ProtonTorpedo:FindTarget(ent:GetPos(), ent:GetForward(), 30, 7500)
			return
		end

		if ent._nextMissle and ent._nextMissle > CurTime() then return end
		ent._nextMissle = CurTime() + 0.5

		ent._swapMissile = not ent._swapMissile

		self.RocketsModel:ResetSequence("Load_Missile")

		local Pos = Vector(150, ent._swapMissile and -70 or 70, 275)
		local Driver = self:GetDriver()

		local projectile = ents.Create("lvs_protontorpedo")
		projectile:SetPos(ent:LocalToWorld(Pos) )
		projectile:SetAngles(ent:LocalToWorldAngles( Angle(0,ent._swapMissile and 2 or -2,0) ) )
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker(IsValid( Driver ) and Driver or self)
		projectile:SetDamage(8000)
		projectile:SetEntityFilter(ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(ent:GetVelocity():Length() + 4000)

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack(CurTime() + 0.1) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function( ent )
		if not IsValid(ent._ProtonTorpedo) then return end

		local projectile = ent._ProtonTorpedo
		projectile:Enable()
		projectile:EmitSound("lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125)
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon( weapon )

	-- Opens / Close the door
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_sidedoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function(ent)
		if ent.NextDoor and ent.NextDoor > CurTime() then return end
		ent.NextDoor = CurTime() + 1

		-- Sets the door mode
		local DoorMode = self:GetDoorMode() + 1
		DoorMode = DoorMode >= 2 and 0 or DoorMode
		self:SetDoorMode(DoorMode)

		if DoorMode == 0 then
			self:ResetSequence(self.closeSequence)
			self:SetPlaybackRate(1.5)

			local bonePos, _ = self:GetBonePosition(self:LookupBone("LAAT"))

			for doorID, _ in pairs(self.DoorsToClose) do
				local doorData = self.Doors[doorID]
				local offset = self:GetRight() * doorData.closeoffset.x + self:GetForward() * doorData.closeoffset.y + self:GetUp() * doorData.closeoffset.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)
			end

			timer.Simple(0.75, function()
				if not IsValid(self) then return end
				self:EmitSound("laat_bf2/door_close.mp3")

				if not self.IsHatchOpen then
					self:TurnLightRed()
				end
			end)
		end

		if DoorMode == 1 then
			if self:IsSpotlightMounted() then
				self:ResetSequence("Door_Open_Half")
				self.closeSequence = "Door_Closed_Half"

				local bonePos = self:GetBonePosition(self:LookupBone("LAAT"))
				local doorData = self.Doors["L_Door2"]
				local offset = self:GetRight() * doorData.openoffsethalf.x + self:GetForward() * doorData.openoffsethalf.y + self:GetUp() * doorData.openoffsethalf.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				local doorData = self.Doors["R_Door2"]
				local offset = self:GetRight() * doorData.openoffsethalf.x + self:GetForward() * doorData.openoffsethalf.y + self:GetUp() * doorData.openoffsethalf.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				self.DoorsToClose = {
					["L_Door2"] = true,
					["R_Door2"] = true,
				}
			else
				self:ResetSequence("Door_Open_Both")
				self.closeSequence = "Door_Closed_Both"

				local bonePos = self:GetBonePosition(self:LookupBone("LAAT"))

				local doorData = self.Doors["L_Door2"]
				local offset = self:GetRight() * doorData.openoffsetboth.x + self:GetForward() * doorData.openoffsetboth.y + self:GetUp() * doorData.openoffsetboth.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				local doorData = self.Doors["L_Door1"]
				local offset = self:GetRight() * doorData.openoffsetboth.x + self:GetForward() * doorData.openoffsetboth.y + self:GetUp() * doorData.openoffsetboth.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				local doorData = self.Doors["R_Door2"]
				local offset = self:GetRight() * doorData.openoffsetboth.x + self:GetForward() * doorData.openoffsetboth.y + self:GetUp() * doorData.openoffsetboth.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				local doorData = self.Doors["R_Door1"]
				local offset = self:GetRight() * doorData.openoffsetboth.x + self:GetForward() * doorData.openoffsetboth.y + self:GetUp() * doorData.openoffsetboth.z
				doorData.ent:SetParent(nil)
				doorData.ent:SetPos(bonePos + offset)
				doorData.ent:SetParent(self)

				self.DoorsToClose = {
					["L_Door2"] = true,
					["L_Door1"] = true,
					["R_Door2"] = true,
					["R_Door1"] = true,
				}
			end

			self:EmitSound("laat_bf2/door_open.mp3")

			self:TurnLightGreen()
		end

		ent:OnDoorsChanged()
	end
	self:AddWeapon(weapon)

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/gunship_reardoor.png")
	weapon.Ammo = -1
	weapon.Delay = 0
	weapon.HeatRateUp = 0
	weapon.HeatRateDown = 0
	weapon.StartAttack = function(ent)
		if ent.NextDoor and ent.NextDoor > CurTime() then return end
		ent.NextDoor = CurTime() + 2

		self:ToggleHatch()
	end

	self:AddWeapon(weapon)
end
--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_gunship_le/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-70, 135, 150), 0, 25, 2, 100, 150)
	self:RegisterTrail(Vector(-70, -135, 150), 0, 25, 2, 100, 150)
end

function ENT:CalcViewOverride(ply, pos, angles, fov, pod)
	if pod == self:GetGunnerSeat() then
		return pos, angles, fov
	end

	if pod:GetThirdPersonMode() then
		pos = ply:GetShootPos() + pod:GetUp() * 40
	else
		pos = pos + pod:GetUp() * 40
	end

	return pos, angles, fov
end

function ENT:Think()
	if IsValid(self:GetDriver()) and self:GetDriver() == self:GetDriver() then
		local aim = self:GetDriver():EyeAngles()
		local x = math.Clamp(aim.x, -15, 90)
		local y = math.Clamp(aim.y, 22, 158)

		self:ManipulateBoneAngles(self:LookupBone("turret_L"), Angle(0, -y + 90, x))
		self:ManipulateBoneAngles(self:LookupBone("turret_R"), Angle(0, -y + 90, x))
	elseif IsValid(self:GetDriver()) and self:GetDriver() ~= LocalPlayer() then
		local aim = self:WorldToLocalAngles(self:GetDriver():EyeAngles())
		local x = math.Clamp(aim.x, -15, 90)
		local y = math.Clamp(aim.y, -68, 68)

		self:ManipulateBoneAngles(self:LookupBone("turret_L"), Angle(0, -y, x))
		self:ManipulateBoneAngles(self:LookupBone("turret_R"), Angle(0, -y, x))
	else
		self:ManipulateBoneAngles(self:LookupBone("turret_L"), Angle(0, 0, 0))
		self:ManipulateBoneAngles(self:LookupBone("turret_R"), Angle(0, 0, 0))
	end
end

--addons/egm_lvs_ships/lua/entities/lvs_repulsorlift_transporter/cl_init.lua:
include("shared.lua")

-- Engine Particles start

ENT.EngineColor = Color(251, 255, 0)
ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EnginePos = {
	Vector(-284.06, -40.51, 26.31),
	Vector(-284.06, 40.51, 26.31),
}

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-34, 320, -130), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-34, -320, -130), 0, 20, 2, 1000, 150)
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	if self.nextEFX and self.nextEFX > CurTime() then return end
	self.nextEFX = CurTime() + 0.01

	local emitter = self:GetParticleEmitter(self:GetPos())
	if not IsValid(emitter) then return end

	for _, pos in pairs(self.EnginePos) do
		local vOffset = self:LocalToWorld(pos)
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add("effects/muzzleflash2", vOffset)
		if not particle then continue end

		particle:SetVelocity(vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity())
		particle:SetLifeTime(0)
		particle:SetDieTime(0.1)
		particle:SetStartAlpha(255)
		particle:SetEndAlpha(0)
		particle:SetStartSize(math.Rand(15,25))
		particle:SetEndSize(math.Rand(0,10))
		particle:SetRoll(math.Rand(-1,1) * 100)
		particle:SetColor(251, 255, 0)
	end
end

function ENT:OnFrame()
	self:EngineEffects()
end

-- Engine Particles End
function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

	render.SetMaterial(self.EngineGlow)

	for _, pos in pairs(self.EnginePos) do
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
	end
end

function ENT:OnStartBoost()
	self:EmitSound("lvs/vehicles/starchaser/engine_on.wav", 85)
end

function ENT:OnStopBoost()
	self:EmitSound("lvs/vehicles/starchaser/engine_off.wav", 85)
end

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_alligator/cl_init.lua:
include("shared.lua")

ENT.EngineGlow = Material("sprites/light_glow02_add")
ENT.EngineColor = Color(255, 0, 0)

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-160, 155, 35), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-160, -155, 35), 0, 20, 2, 1000, 150)
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	-- Draws the effect
	local Size = 150 + self:GetThrottle() * 40 + self:GetBoost() * 0.8
	render.SetMaterial(self.EngineGlow)
	render.DrawSprite(self:LocalToWorld(Vector(-230, 0, 35)), Size, Size, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-230, 0, 35)), Size, Size, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-230, 0, 35)), Size, Size, self.EngineColor)
	render.DrawSprite(self:LocalToWorld(Vector(-230, 0, 35)), Size, Size, self.EngineColor)
end

function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	if self.nextEFX and self.nextEFX > CurTime() then return end
	self.nextEFX = CurTime() + 0.01

	local emitter = ParticleEmitter(self:GetPos(), false)

	local vOffset = self:LocalToWorld(Vector(-200, 0, 35))
	local vNormal = -self:GetForward()

	local particle = emitter:Add("sprites/heatwave", vOffset)
	if not particle then return end

	particle:SetVelocity(vNormal * math.Rand(1500,1000) + self:GetVelocity())
	particle:SetLifeTime(0)
	particle:SetDieTime(0.1)
	particle:SetStartAlpha(255)
	particle:SetEndAlpha(0)
	particle:SetStartSize(math.Rand(15, 30))
	particle:SetEndSize(math.Rand(0,10))
	particle:SetRoll(math.Rand(-1,1) * 100)
	particle:SetColor(255, 255, 255)

	emitter:Finish()
end
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_delta7/shared.lua:
ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Delta-7 Starfighter"
ENT.Author = "Deltaa"
ENT.Information = "The Delta-7 Jedi starfighter was used by the Jedi Order before and during the Clone Wars."
ENT.Category = "[LVS] - Republik"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/starwars/lordtrilobite/ships/delta7/delta7_landed.mdl"
ENT.GibModels = {
	"models/XQM/wingpiece2.mdl",
	"models/XQM/wingpiece2.mdl",
	"models/XQM/jetwing2medium.mdl",
	"models/XQM/jetwing2medium.mdl",
	"models/props_c17/TrapPropeller_Engine.mdl",
	"models/props_junk/Shoe001a.mdl",
	"models/XQM/jetbody2fuselage.mdl",
	"models/XQM/jettailpiece1medium.mdl",
	"models/XQM/pistontype1huge.mdl"
}

ENT.AITEAM = 2

ENT.MaxVelocity = 1000
ENT.MaxThrust = 1000

ENT.ThrustVtol = 55
ENT.ThrustRateVtol = 3

ENT.TurnRatePitch = 1
ENT.TurnRateYaw = 1
ENT.TurnRateRoll = 1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1.5
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 10000
ENT.MaxShield = 4500

ENT.LAATC_PICKUPABLE = true
ENT.LAATC_PICKUP_POS = Vector(-220, 0, -20)
ENT.LAATC_PICKUP_Angle = Angle(0, 0, 0)

function ENT:OnIsCarried( name, old, new)
	if new == old then return end

	if new then
		self:SetDisabled(true)
	else
		self:SetDisabled(false)
	end
end

function ENT:OnSetupDataTables()
	self:AddDT("Bool", "Foils")
	self:AddDT("Bool", "IsCarried")

	if SERVER then
		self:NetworkVarNotify( "Foils", self.OnFoilsChanged )
		self:NetworkVarNotify("IsCarried", self.OnIsCarried)
	end
end

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(16,31.5,36),
		Vector(16,-33,36),
		Vector(16,32.5,26.5),
		Vector(16,-32,26.5)
	}

	local weapon = {}
	weapon.Icon = Material("lvs/weapons/hmg.png")
	weapon.Delay = 0.1
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		ent.NumPrim = ent.NumPrim and ent.NumPrim + 1 or 1
		if ent.NumPrim > #ent.FirePositions then ent.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid( pod ) then return end

		local startpos =  pod:LocalToWorld(pod:OBBCenter())
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		})

		local CurPos = ent.FirePositions[ent.NumPrim]

		local bullet = {}
		bullet.Src = ent:LocalToWorld(ent.FirePositions[ent.NumPrim])
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector(0.01, 0.01, 0)
		bullet.Tracer = 1
		bullet.TracerName = "lvs_laser_green"
		bullet.Force = 100
		bullet.HullSize = 10
		bullet.Damage = 900
		bullet.Attacker = ent:GetDriver()
		bullet.Velocity = 60000
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
			effectdata:SetStart(Vector(50,255,50))
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata )
		end
		ent:LVSFireBullet( bullet )


		ent:TakeAmmo()

		if CurPos.y > 0 then
			ent.SNDLeft:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		else
			ent.SNDRight:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
		end
	end
	weapon.OnSelect = function( ent )
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	self:AddWeapon(LVS:GetWeaponPreset("TURBO"))
end

ENT.FlyByAdvance = 0.5
ENT.FlyBySound = "lvs/vehicles/delta-7/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/delta-7/engine.wav",
		sound_int = "lvs/vehicles/delta-7/engine_int.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}


--addons/egm_lvs_ships/lua/entities/lvs_starfighter_droidtrifighter/cl_init.lua:
include("shared.lua")

ENT.EngineFXPos = {
	Vector(-104.75,0,31.59),
	Vector(-104.75,-27.74,-15.54),
	Vector(-104.75,27.74,-15.54),
}

function ENT:OnSpawn()
	self:RegisterTrail( Vector(-120,0,31.59), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-120,-27.74,-15.54), 0, 20, 2, 1000, 150 )
	self:RegisterTrail( Vector(-120,27.74,-15.54), 0, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
end

ENT.EngineGlow = Material( "sprites/light_glow02_add" )

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 40 + self:GetBoost() * 0.8

	render.SetMaterial( self.EngineGlow )
	render.DrawSprite( self:LocalToWorld( Vector(-120,0,31.59) ), Size, Size, Color( 255, 100, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(-120,-27.74,-15.54) ), Size, Size, Color( 255, 100, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(-120,27.74,-15.54) ), Size, Size, Color( 255, 100, 0, 255) )

	render.DrawSprite( self:LocalToWorld( Vector(79,16.99,9.81) ), 16, 16, Color( 255, 0, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(84,13.55,8.05) ), 12, 12, Color( 255, 0, 0, 255) )

	render.DrawSprite( self:LocalToWorld( Vector(79,-16.99,9.81) ), 16, 16, Color( 255, 0, 0, 255) )
	render.DrawSprite( self:LocalToWorld( Vector(84,-13.55,8.05) ), 12, 12, Color( 255, 0, 0, 255) )
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	local T = CurTime()

	if (self.nextEFX or 0) > T then return end

	self.nextEFX = T + 0.01

	local THR = self:GetThrottle()

	local emitter = self:GetParticleEmitter( self:GetPos() )

	if not IsValid( emitter ) then return end

	for _, v in pairs( self.EngineFXPos ) do
		local Sub = Mirror and 1 or -1
		local vOffset = self:LocalToWorld( v )
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset )

		if not particle then continue end

		particle:SetVelocity( vNormal * math.Rand(500,1000) + self:GetVelocity() )
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.1 )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( math.Rand(15,25) )
		particle:SetEndSize( math.Rand(0,10) )
		particle:SetRoll( math.Rand(-1,1) * 100 )
		
		particle:SetColor( 255, 100, 200 )
	end
end

function ENT:OnStartBoost()
	self:EmitSound( "lvs/vehicles/vulturedroid/boost.wav", 85 )
end

function ENT:OnStopBoost()
	self:EmitSound( "lvs/vehicles/vulturedroid/brake.wav", 85 )
end

--addons/egm_lvs_ships/lua/entities/lvs_starfighter_spiral/shared.lua:

ENT.Base = "lvs_base_starfighter"

ENT.PrintName = "Cutlass-9 Patrol Fighter"
ENT.Author = "Nashatok"
ENT.Information = "Light Interceptor designed by MandalMotors, popular among pirates and militias"
ENT.Category = "[LVS] - Neutral"

ENT.Spawnable = true
ENT.AdminSpawnable = false

ENT.MDL = "models/sharpspiral/rep_sharpspiral_servius.mdl"

ENT.AITEAM = 0

ENT.MaxVelocity = 2150
ENT.MaxThrust = 2150

ENT.TurnRatePitch = 1.1
ENT.TurnRateYaw = 1.1
ENT.TurnRateRoll = 1.1

ENT.ForceLinearMultiplier = 1

ENT.ForceAngleMultiplier = 1.3
ENT.ForceAngleDampingMultiplier = 1

ENT.MaxHealth = 10500
ENT.MaxShield = 3000

function ENT:InitWeapons()
	self.FirePositions = {
		Vector(110, -96, 68),
		Vector(110, 96, 68),
	}

	-- Primary Gun
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/mg.png")
	weapon.Delay = 0.2
	weapon.HeatRateUp = 0.1
	weapon.HeatRateDown = 1
	weapon.Attack = function( ent )
		self.NumPrim = self.NumPrim and self.NumPrim + 1 or 1
		if self.NumPrim > 2 then self.NumPrim = 1 end

		local pod = ent:GetDriverSeat()
		if not IsValid(pod) then return end

		local startpos = pod:LocalToWorld( pod:OBBCenter() )
		local trace = util.TraceHull({
			start = startpos,
			endpos = startpos + ent:GetForward() * 50000,
			mins = Vector( -10, -10, -10 ),
			maxs = Vector( 10, 10, 10 ),
			filter = ent:GetCrosshairFilterEnts()
		})

		local bullet = {}
		bullet.Src = ent:LocalToWorld( ent.FirePositions[ent.NumPrim] )
		bullet.Dir = (trace.HitPos - bullet.Src):GetNormalized()
		bullet.Spread = Vector( 0.02,  0.02, 0 )
		bullet.TracerName = "lvs_laser_red"
		bullet.Force = 100
		bullet.HullSize = 40
		bullet.Damage = 300
		bullet.Velocity = 60000
		bullet.Attacker = ent:GetDriver()
		bullet.Callback = function(att, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetStart(Vector(255, 50, 50))
				effectdata:SetOrigin(tr.HitPos)
				effectdata:SetNormal(tr.HitNormal)
			util.Effect("lvs_laser_impact", effectdata)
		end

		local effectdata = EffectData()
		effectdata:SetStart( Vector(255,50,50) )
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( ent:GetForward() )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle_colorable", effectdata )

		ent:LVSFireBullet( bullet )

		ent.PrimarySND:PlayOnce( 100 + math.cos( CurTime() + self:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon( weapon )

	-- Missile Launcher
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.UseableByAI = false
	weapon.Ammo = 4
	weapon.Delay = 3 -- this will turn weapon.Attack to a somewhat think function
	weapon.HeatRateUp = -0.5 -- cool down when attack key is held. This system fires on key-release.
	weapon.HeatRateDown = 0.5
	weapon.Attack = function( ent )
		local T = CurTime()

		if IsValid( ent._ProtonTorpedo ) then
			if (ent._nextMissleTracking or 0) > T then return end

			ent._nextMissleTracking = T + 0.1 -- 0.1 second interval because those find functions can be expensive

			ent._ProtonTorpedo:FindTarget( ent:GetPos(), ent:GetForward(), 30, 7500 )

			return
		end

		local projectile = ents.Create("lvs_concussionmissile")
		projectile:SetPos(ent:LocalToWorld( Vector(230, 0, 20)))
		projectile:SetAngles(ent:GetAngles())
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker(ent:GetDriver())
		projectile:SetEntityFilter(ent:GetCrosshairFilterEnts())
		projectile:SetSpeed(ent:GetVelocity():Length() + 4000)

		ent._ProtonTorpedo = projectile

		ent:SetNextAttack(CurTime() + 0.1) -- wait 0.1 second before starting to track
	end
	weapon.FinishAttack = function(ent)
		if not IsValid( ent._ProtonTorpedo ) then return end
		local projectile = ent._ProtonTorpedo

		projectile:Enable()
		projectile:EmitSound( "lvs/vehicles/naboo_n1_starfighter/proton_fire.mp3", 125 )
		ent:TakeAmmo()

		ent._ProtonTorpedo = nil

		local NewHeat = ent:GetHeat() + 1

		ent:SetHeat(NewHeat)
		if NewHeat >= 1 then
			ent:SetOverheated(true)
		end
	end
	weapon.OnSelect = function(ent)
		ent:EmitSound("physics/metal/weapon_impact_soft3.wav")
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/overheat.wav")
	end
	self:AddWeapon(weapon)

	self:AddWeapon(LVS:GetWeaponPreset("TURBO"))
end

ENT.FlyByAdvance = 0.75
ENT.FlyBySound = "lvs/vehicles/naboo_n1_starfighter/flyby.wav"
ENT.DeathSound = "lvs/vehicles/generic_starfighter/crash.wav"

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/naboo_n1_starfighter/loop.wav",
		Pitch = 80,
		PitchMin = 0,
		PitchMax = 255,
		PitchMul = 40,
		FadeIn = 0,
		FadeOut = 1,
		FadeSpeed = 1.5,
		UseDoppler = true,
	},
}
--addons/egm_lvs_ships/lua/entities/lvs_starfighter_starchaser/cl_init.lua:
include("shared.lua")

ENT.EngineColor = Color(25, 255, 25)
ENT.EngineGlow = Material( "sprites/light_glow02_add" )
ENT.EnginePos = {
	Vector(-120,250,200),
	Vector(-120,-250,200),
}

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-130, 250, 200), 4, 20, 2, 1000, 150 )
	self:RegisterTrail(Vector(-130, -250, 200), 4, 20, 2, 1000, 150 )
end

function ENT:OnFrame()
	self:EngineEffects()
end

function ENT:EngineEffects()
	if not self:GetEngineActive() then return end

	if self.nextEFX and self.nextEFX > CurTime() then return end
	self.nextEFX = CurTime() + 0.01

	local emitter = self:GetParticleEmitter(self:GetPos())
	if not IsValid(emitter) then return end

	for _, pos in pairs(self.EnginePos) do
		local vOffset = self:LocalToWorld(pos)
		local vNormal = -self:GetForward()

		vOffset = vOffset + vNormal * 5

		local particle = emitter:Add( "effects/muzzleflash2", vOffset)
		if not particle then continue end

		particle:SetVelocity(vNormal * (math.Rand(500,1000) + self:GetBoost() * 10) + self:GetVelocity() )
		particle:SetLifeTime(0)
		particle:SetDieTime(0.1)
		particle:SetStartAlpha(255)
		particle:SetEndAlpha(0)
		particle:SetStartSize(math.Rand(25, 35))
		particle:SetEndSize(math.Rand(15, 25))
		particle:SetRoll(math.Rand(-1, 1) * 100)
		particle:SetColor(25, 255, 25)
	end
end

function ENT:PostDrawTranslucent()
	if not self:GetEngineActive() then return end

	local Size = 80 + self:GetThrottle() * 120 + self:GetBoost() * 2

	render.SetMaterial(self.EngineGlow)

	for _, pos in pairs(self.EnginePos) do
		render.DrawSprite(self:LocalToWorld(pos), Size, Size, self.EngineColor)
	end

	local EnginePositions = {
		Vector(15, 170, 163),
		Vector(15, -170, 163),
		Vector(15, 115, 127),
		Vector(15, -115, 127),

		Vector(155, 170, 163),
		Vector(155, -170, 163),
		Vector(165, 115, 127),
		Vector(165, -115, 127),
	}

	for _, pos in pairs(EnginePositions) do
		render.DrawSprite(self:LocalToWorld(pos), 80, 80, self.EngineColor)
	end
end

function ENT:OnStartBoost()
	self:EmitSound("lvs/vehicles/starchaser/engine_on.wav", 85)
end

function ENT:OnStopBoost()
	self:EmitSound("lvs/vehicles/starchaser/engine_off.wav", 85)
end


--addons/egm_lvs_ships/lua/entities/lvs_starfighter_vulture/cl_init.lua:
include("shared.lua")

function ENT:OnSpawn()
	self:RegisterTrail(Vector(-25, 115, 120), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-25, -115, 120), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-25, 115, 80), 0, 20, 2, 1000, 150)
	self:RegisterTrail(Vector(-25, -115, 80), 0, 20, 2, 1000, 150)
end

function ENT:OnFrame()
end

function ENT:OnStartBoost()
	self:EmitSound("lvs/vehicles/vulturedroid/boost.wav", 85)
end

function ENT:OnStopBoost()
	self:EmitSound("lvs/vehicles/vulturedroid/brake.wav", 85)
end
--addons/lvs_base/lua/entities/lvs_vehicle_repair.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Maintenance Station"
ENT.Author = "Luna"
ENT.Information = "Repairs Vehicles"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:Initialize()	
		self:SetModel( "models/props_vehicles/generatortrailer01.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:DrawShadow( false )
		self:SetTrigger( true )
		self:SetCollisionGroup( COLLISION_GROUP_WORLD )
	end

	function ENT:Refil( entity )
		if not IsValid( entity ) then return end

		if not entity.LVS then return end

		local Repaired = false

		if entity:GetHP() ~= entity:GetMaxHP() then
			entity:SetHP( entity:GetMaxHP() )

			Repaired = true
		end

		if entity:OnArmorMaintenance() then
			Repaired = true
		end

		if Repaired then
			entity:EmitSound("npc/dog/dog_servo2.wav")
		end

		if entity:WeaponRestoreAmmo() then
			entity:EmitSound("items/ammo_pickup.wav")
		end

		entity:OnMaintenance()
	end

	function ENT:StartTouch( entity )
		self:Refil( entity )
	end

	function ENT:EndTouch( entity )
		self:Refil( entity )
	end

	function ENT:Touch( entity )
	end

	function ENT:Think()
		return false
	end
end

if CLIENT then
	local WhiteList = {
		["weapon_physgun"] = true,
		["weapon_physcannon"] = true,
		["gmod_tool"] = true,
	}

	local mat = Material( "models/wireframe" )
	local FrameMat = Material( "lvs/3d2dmats/frame.png" )
	local RepairMat = Material( "lvs/3d2dmats/repair.png" )
	function ENT:Draw()
		local ply = LocalPlayer()
		local Small = false

		if IsValid( ply ) and not IsValid( ply:lvsGetVehicle() ) then
			self:DrawModel()

			Small = true

			if GetConVarNumber( "cl_draweffectrings" ) == 0 then return end

			local ply = LocalPlayer()
			local wep = ply:GetActiveWeapon()

			if not IsValid( wep ) then return end

			local weapon_name = wep:GetClass()

			if not WhiteList[ weapon_name ] then
				return
			end
		end

		local Pos = self:GetPos()

		for i = 0, 180, 180 do
			cam.Start3D2D( self:LocalToWorld( Vector(0,0, self:OBBMins().z + 2 ) ), self:LocalToWorldAngles( Angle(i,90,0) ), 0.25 )
				surface.SetDrawColor( 255, 150, 0, 255 )

				surface.SetMaterial( FrameMat )
				surface.DrawTexturedRect( -512, -512, 1024, 1024 )

				surface.SetMaterial( RepairMat )
				if Small then
					surface.DrawTexturedRect( -256, 0, 512, 512 )
				else
					surface.DrawTexturedRect( -512, -512, 1024, 1024 )
				end
			cam.End3D2D()
		end
	end
end
--addons/egm_lvs_ground/lua/entities/lvs_walker_atte/sh_turret.lua:

function ENT:SetPosTurret()
	local Turret = self:GetTurretSeat()
	if not IsValid(Turret) then return end

	local ID = self:LookupAttachment("driver_turret")

	local Att = self:GetAttachment(ID)
	if not Att then return end

	local PosL = self:WorldToLocal(Att.Pos + Att.Ang:Right() * 20 - Att.Ang:Up() * 5)
	Turret:SetLocalPos(PosL)
end

function ENT:SetPoseParameterTurret(weapon)
	if self:GetIsCarried() then
		self:SetPoseParameter("cannon_pitch", 0)
		self:SetPoseParameter("cannon_yaw", 180)

		if self.TurretWasSet then
			self.TurretWasSet = nil

			self:SetTurretPitch(0)
			self:SetTurretYaw(180)
		end

		return
	end

	self.TurretWasSet = true

	if not IsValid(weapon:GetDriver()) and not weapon:GetAI() then return end

	local AimAng = weapon:WorldToLocal(weapon:GetPos() + weapon:GetAimVector()):Angle()

	local AimRate = self.TurretTurnRate * FrameTime()

	self:SetTurretPitch(math.ApproachAngle( self:GetTurretPitch(), AimAng.p, AimRate))
	self:SetTurretYaw(math.ApproachAngle( self:GetTurretYaw(), AimAng.y, AimRate))

	self:SetPoseParameter("cannon_pitch", self:GetTurretPitch())
	self:SetPoseParameter("cannon_yaw", self:GetTurretYaw())
end

function ENT:InitTurret()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/protontorpedo.png")
	weapon.Ammo = 80
	weapon.Delay = 3
	weapon.HeatRateUp = 0.6
	weapon.HeatRateDown = 0.25
	weapon.OnOverheat = function( ent ) end
	weapon.Attack = function( ent )
		local base = ent:GetVehicle()
		if not IsValid(base) then return end

		if base:GetIsCarried() then
			ent:SetHeat(0)
			return true
		end

		local ID = base:LookupAttachment("muzzle_cannon")
		local Muzzle = base:GetAttachment(ID)

		if not Muzzle then return end

		local Driver = ent:GetDriver()

		local projectile = ents.Create("lvs_protontorpedo")
		projectile:SetPos(Muzzle.Pos)
		projectile:SetAngles(Muzzle.Ang:Up():Angle())
		projectile:SetParent(ent)
		projectile:Spawn()
		projectile:Activate()
		projectile:SetAttacker(IsValid( Driver ) and Driver or self)
		projectile:SetEntityFilter(ent:GetCrosshairFilterEnts())
		projectile:SetDamage(8000)
		projectile:SetSpeed(4000)
		projectile:Enable()

		base:ResetSequence(base:LookupSequence("shoot_gun"))
		ent:TakeAmmo()

		if not IsValid(base.SNDTurret) then return end
		base.SNDTurret:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1)
	end
	weapon.CalcView = function(ent, ply, pos, angles, fov, pod)
		if pod:GetThirdPersonMode() then
			local base = ent:GetVehicle()

			local view = {}
			view.origin = pos
			view.angles = angles
			view.fov = fov
			view.drawviewer = true

			if not IsValid(base) then
				return view
			end

			-- Draws the driver on the correct position in relation to the turret
			local ID = base:LookupAttachment("driver_turret")
			local Att = base:GetAttachment(ID)

			if Att then
				local Pos, Ang = LocalToWorld(Vector(0, 40, -15), Angle(-90, 0, -90), Att.Pos, Att.Ang )
				view.origin = Pos
				ply:SetAngles(Ang)
			end

			return view
		else
			local base = ent:GetVehicle()

			local view = {}
			view.origin = pos
			view.angles = angles
			view.fov = fov
			view.drawviewer = true

			if not IsValid(base) then
				return view
			end

			-- Draws the driver on the correct position in relation to the turret
			local ID = base:LookupAttachment("driver_turret")
			local Att = base:GetAttachment(ID)

			if Att then
				local Pos, Ang = LocalToWorld(Vector(0, 40, -200), Angle(-90, 0, -90), Att.Pos, Att.Ang)
				view.origin = Pos
				ply:SetAngles(Ang)
			end

			return view
		end
	end
	weapon.OnThink = function(ent, active)
		local base = ent:GetVehicle()
		if not IsValid(base) then return end

		base:SetPoseParameterTurret(ent)
		base:SetPosTurret()
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local base = ent:GetVehicle()
		if not IsValid(base) then return end

		if base:GetIsCarried() then return end

		local ID = base:LookupAttachment("muzzle_cannon")

		local Muzzle = base:GetAttachment(ID)
		if not Muzzle then return end

		local dir = Muzzle.Ang:Up()
		local pos = Muzzle.Pos

		local trace = util.TraceLine( {
			start = pos,
			endpos = (pos + dir * 50000),
			filter = function(entity)
				if base:GetCrosshairFilterLookup()[entity:EntIndex()] or entity:GetClass():StartWith("lvs_protontorpedo") then
					return false
				end

				return true
			end,
		} )

		local Pos2D = trace.HitPos:ToScreen()

		self:PaintCrosshairCenter(Pos2D)
		self:PaintCrosshairOuter(Pos2D)
		self:LVSPaintHitMarker(Pos2D)
	end
	weapon.OnOverheat = function(ent)
		ent:EmitSound("lvs/vehicles/atte/overheat.mp3", 85)
	end
	self:AddWeapon(weapon, 2)
end
--addons/egm_tfa_mines/lua/entities/mine_antivehicle/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--              Mines            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Mines | Anti Vehicle       --
---------------------------------------

ENT.Base = "mine_base"

ENT.PrintName = "Anti-Fahrzeug Mine"
ENT.Author = "Deltaa"
ENT.Category = "SW:RP (Republik)"

ENT.Skin = 1

ENT.Spawnable = true

function ENT:PostInitialize()
	self:SetCollisionGroup(COLLISION_GROUP_WEAPON)

	self:PhysicsInitBox(Vector(-7.1, -6.8, 0), Vector(6.7, 7, 75))
	self:SetCustomCollisionCheck(true)
end

-- FIXME https://github.com/Facepunch/garrysmod-issues/issues/642

-- hook.Add("ShouldCollide", "Mines.AntiVehicle", function(ent1, ent2)
-- 	if ent1:GetClass() == "mine_antivehicle" and not ent2.LVS then return false end
-- 	if ent2:GetClass() == "mine_antivehicle" and not ent1.LVS then return false end
-- end)
--addons/egm_tfa_mines/lua/entities/mine_base/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--              Mines            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Mines | Base Entity        --
---------------------------------------

ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Mine (Base)"
ENT.Author = "Deltaa"
ENT.Category = "SW:RP (Republik)"

ENT.Skin = 0
ENT.IsMine = true

ENT.IsDetonated = false
ENT.NextTouch = 0

ENT.Spawnable = false
--addons/egm_tfa_mines/lua/entities/mine_emp/cl_init.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--              Mines            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       	  Mines | EMP       	 --
---------------------------------------

include("shared.lua")
--addons/mortar/lua/entities/mortar_bomb_shell/shared.lua:
ENT.Type			=	"anim"
ENT.Base			=	"base_entity"
ENT.PrintName		=	"[DU] Mortar Bomb Shell"
ENT.Spawnable		=	false
ENT.Category 		=   "DolUnity"
--addons/mortar/lua/entities/mortar_fire_shell/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end
--addons/mortar/lua/entities/mortar_smoke_shell/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end
--addons/mortar/lua/entities/mortar_smoke_shell/shared.lua:
ENT.Type			=	"anim"
ENT.Base			=	"base_entity"
ENT.PrintName		=	"[DU] Mortar Smoke Shell"
ENT.Spawnable		=	false
ENT.Category 		=   "DolUnity"
--addons/hbombs_base/lua/entities/nuclear_siren/cl_init.lua:
include('shared.lua')

function ENT:Draw()

//Actually draw the model
self.Entity:DrawModel()

//Draw tooltip with networked information if close to view
local squad = self:GetNetworkedString( 12 )
if ( LocalPlayer():GetEyeTrace().Entity == self.Entity && EyePos():Distance( self.Entity:GetPos() ) < 256 ) then
AddWorldTip( self.Entity:EntIndex(), ( "Nuclear Siren" ), 0.5, self.Entity:GetPos(), self.Entity  )
end
end

language.Add( 'nuclear_siren', 'nuclear siren' )
--lua/entities/obj_viewcam/shared.lua:

ENT.Type 			= "anim"
ENT.Base 			= "base_gmodentity"
ENT.PrintName		= "Viewcam"
ENT.Author			= "Silverlan"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

--lua/entities/particlecontroller_normal.lua:
AddCSLuaFile()

ENT.Base 			= "base_gmodentity"
ENT.PrintName			= "Particle Controller - Normal"
ENT.Author			= ""

ENT.Spawnable			= false
ENT.AdminSpawnable		= false
ENT.RenderGroup			= RENDERGROUP_NONE




function ENT:SetupDataTables()

	self:NetworkVar( "Entity", 0, "TargetEnt" );
	self:NetworkVar( "Entity", 1, "TargetEnt2" );

	self:NetworkVar( "String", 0, "EffectName" );
	self:NetworkVar( "String", 1, "NumpadState" );

	self:NetworkVar( "Float", 0, "RepeatRate" );

	self:NetworkVar( "Int", 0, "AttachNum" );
	self:NetworkVar( "Int", 1, "AttachNum2" );
	self:NetworkVar( "Int", 2, "NumpadKey" );

	self:NetworkVar( "Bool", 0, "Active" );
	self:NetworkVar( "Bool", 1, "RepeatSafety" );
	self:NetworkVar( "Bool", 2, "Toggle" );

	//we have 3 pieces of information we need for util.effect, and they're not going to be changed after the ent's been spawned, so there's no reason we can't save space by storing them all in this vector
	self:NetworkVar( "Vector", 0, "UtilEffectInfo" );  //x = scale, y = magnitude, x = radius

end




function ENT:Initialize()

	local target = self:GetTargetEnt()
	local target2 = self:GetTargetEnt2()


	if !string.StartWith( self:GetEffectName(), "!UTILEFFECT!" ) then

		//Set things up for a particlesystem effect

		if SERVER then	
	
			//Since we can't specify attachment points with Entity:CreateParticleEffect(), we have to improvise.
	
			//If target1 is using an attachment, move ourselves to the pos/ang of that attachment and use ourselves as the target for control point 1.
			local attachment1 = target:GetAttachment( self:GetAttachNum() )
			if attachment1 != nil then 
				self:SetPos( attachment1.Pos )
				self:SetAngles( attachment1.Ang )
				self:Fire("setparentattachment", target:GetAttachments()[self:GetAttachNum()].name, 0.01)
				self:SetTargetEnt(self)
			end
		
			//If target2 is using an attachment, then spawn an entity at the pos/ang of that attachment to use as the target for control point 2.	
			if IsValid(target2) then
				local attachment2 = target2:GetAttachment( self:GetAttachNum2() )
				if attachment2 != nil then
					if self.endpoint then self.endpoint = nil end
					self.endpoint = ents.Create( "info_particle_system" )
					self.endpoint:SetKeyValue( "effect_name", "combineball" )
					self.endpoint:SetParent(target2)	
	
					self.endpoint:SetPos( attachment2.Pos )
					self.endpoint:SetAngles( attachment2.Ang )
					self.endpoint:Fire("setparentattachment", target2:GetAttachments()[self:GetAttachNum2()].name, 0.01)
	
					self:DeleteOnRemove(self.endpoint)
					self.endpoint:Spawn()
					self.endpoint:Activate()
					self:SetTargetEnt2(self.endpoint)
				end
			end
	
		else

			//Make a table of control point information, so we only have to do this once instead of every time AttachParticle runs.

			local clrtb = nil
			if self:GetColor().r == 0 and self:GetColor().g == 0 and self:GetColor().b == 0 then
				//MsgN("color = false")
			else
				//MsgN("color = true")
				if self:GetColor().a == 1 then
					clrtb = { position = Vector( self:GetColor().r / 255, self:GetColor().g / 255, self:GetColor().b / 255 )  }
				else
					clrtb = { position = Vector( self:GetColor().r, self:GetColor().g, self:GetColor().b )  }
				end
			end
			self.cpointtable = {}
				self.cpointtable[1] = { entity = target, attachtype = PATTACH_ABSORIGIN_FOLLOW }

				if IsValid(target2) then
					self.cpointtable[2] = { entity = target2, attachtype = PATTACH_ABSORIGIN_FOLLOW } 
				else
					if clrtb then 
						self.cpointtable[2] = clrtb
					else
						self.cpointtable[2] = self.cpointtable[1]
					end
				end

				for i = 3, 64 do					
 					if clrtb then
						self.cpointtable[i] = clrtb
					else
						self.cpointtable[i] = self.cpointtable[1]
					end
				end

			PrecacheParticleSystem(self:GetEffectName())

		end

	end
	self:SetModel("models/hunter/plates/plate.mdl") //it's a tiny block so that model-covering fx show up at a single point instead of all over an invisible error model
	self:SetNoDraw(true)


	if self:GetRepeatRate() > 0 then
		//we're going to be repeating the effect, so let's set that up and let think do the test
		self.NextRepeat = 0
	else
		//we won't be repeating the effect, so just attach it right now
		if self:GetActive() then self:AttachParticle() end
	end

end




function ENT:Think()

	if SERVER then return end

	if self:GetNumpadState() == "off" then
		//MsgN("turn off")
		self:SetNumpadState("")
		self:RemoveParticle(false,self:GetEffectName()) 
	end

	if self:GetNumpadState() == "on" then
		//MsgN("turn on")
		self:SetNumpadState("")
		if self:GetRepeatRate() > 0 then
			//we're going to be repeating the effect, so let's set that up and let think do the test
			self.NextRepeat = 0
		else
			//we won't be repeating the effect, so just attach it right now
			if self:GetActive() then self:AttachParticle() end
		end
	end


	if self:GetActive() == true and self:GetRepeatRate() > 0 then
		if !( self.NextRepeat > CurTime() ) then
			//the repeat function is built into removeparticle so that we can be sure the old particle is gone before we add a new one
			//disabling repeat safety lets the user bypass this if they want
			if self:GetRepeatSafety() then
				self:RemoveParticle(true,self:GetEffectName())
			else
				self:AttachParticle()
			end
			self.NextRepeat = CurTime() + self:GetRepeatRate()
		end
	end
	
	self:NextThink(CurTime())
	return true

end




function ENT:AttachParticle()

	if SERVER then return end

	local target		= self:GetTargetEnt()
	local attachnum		= self:GetAttachNum()
	local effectname	= self:GetEffectName()
	local target2		= self:GetTargetEnt2()
	local attachnum2	= self:GetAttachNum2()

	if effectname == nil or !target:IsValid() then return end


	if string.StartWith( effectname, "!UTILEFFECT!" ) then

		//Create a util effect

		//Unfortunately, we have to do all of this every single time the effect repeats, because if we do it in Initialize instead, a whole bunch of stuff doesn't work properly

		local effectscale = self:GetUtilEffectInfo().x
		local effectmagnitude = self:GetUtilEffectInfo().y
		local effectradius = self:GetUtilEffectInfo().z

		local luaeffectdata = EffectData()
		luaeffectdata:SetEntity( target )
		if ( string.find(effectname, "Tracer", 0, true) != nil ) then luaeffectdata:SetScale(5000) else luaeffectdata:SetScale( effectscale ) end  //for tracer effects, scale is the speed of the bullet, so we need to keep this high
		luaeffectdata:SetMagnitude( effectmagnitude )
		luaeffectdata:SetRadius(effectradius )

		//flags can be set by typing !FLAG#! at the end of the effect name
		luaeffectdata:SetFlags( 0 )
		if string.EndsWith( effectname, "!" ) then
			if string.find( effectname, "!FLAG1!" ) then luaeffectdata:SetFlags( 1 ) effectname = string.Replace( effectname, "!FLAG1!", "" ) end
			if string.find( effectname, "!FLAG2!" ) then luaeffectdata:SetFlags( 2 ) effectname = string.Replace( effectname, "!FLAG2!", "" ) end
			if string.find( effectname, "!FLAG3!" ) then luaeffectdata:SetFlags( 3 ) effectname = string.Replace( effectname, "!FLAG3!", "" ) end
			if string.find( effectname, "!FLAG4!" ) then luaeffectdata:SetFlags( 4 ) effectname = string.Replace( effectname, "!FLAG4!", "" ) end
			if string.find( effectname, "!FLAG5!" ) then luaeffectdata:SetFlags( 5 ) effectname = string.Replace( effectname, "!FLAG5!", "" ) end
			if string.find( effectname, "!FLAG6!" ) then luaeffectdata:SetFlags( 6 ) effectname = string.Replace( effectname, "!FLAG6!", "" ) end
			if string.find( effectname, "!FLAG7!" ) then luaeffectdata:SetFlags( 7 ) effectname = string.Replace( effectname, "!FLAG7!", "" ) end
			if string.find( effectname, "!FLAG8!" ) then luaeffectdata:SetFlags( 8 ) effectname = string.Replace( effectname, "!FLAG8!", "" ) end
			if string.find( effectname, "!FLAG9!" ) then luaeffectdata:SetFlags( 9 ) effectname = string.Replace( effectname, "!FLAG9!", "" ) end
		end

		//colors can also be set the same way
		luaeffectdata:SetColor(0)
		if string.EndsWith( effectname, "!" ) then
			if string.find( effectname, "!COLOR1!" ) then luaeffectdata:SetColor( 1 ) effectname = string.Replace( effectname, "!COLOR1!", "" ) end
			if string.find( effectname, "!COLOR2!" ) then luaeffectdata:SetColor( 2 ) effectname = string.Replace( effectname, "!COLOR2!", "" ) end
			if string.find( effectname, "!COLOR3!" ) then luaeffectdata:SetColor( 3 ) effectname = string.Replace( effectname, "!COLOR3!", "" ) end
			if string.find( effectname, "!COLOR4!" ) then luaeffectdata:SetColor( 4 ) effectname = string.Replace( effectname, "!COLOR4!", "" ) end
			if string.find( effectname, "!COLOR5!" ) then luaeffectdata:SetColor( 5 ) effectname = string.Replace( effectname, "!COLOR5!", "" ) end
			if string.find( effectname, "!COLOR6!" ) then luaeffectdata:SetColor( 6 ) effectname = string.Replace( effectname, "!COLOR6!", "" ) end
			if string.find( effectname, "!COLOR7!" ) then luaeffectdata:SetColor( 7 ) effectname = string.Replace( effectname, "!COLOR7!", "" ) end
			if string.find( effectname, "!COLOR8!" ) then luaeffectdata:SetColor( 8 ) effectname = string.Replace( effectname, "!COLOR8!", "" ) end
			if string.find( effectname, "!COLOR9!" ) then luaeffectdata:SetColor( 9 ) effectname = string.Replace( effectname, "!COLOR9!", "" ) end
		end

		//dumb situational crap
		if string.find( string.lower(effectname), "shakeropes" ) then luaeffectdata:SetMagnitude( effectmagnitude * 20 ) end
		if string.find( string.lower(effectname), "thumperdust" ) then luaeffectdata:SetScale( effectscale * 50 ) end
		if string.find( string.lower(effectname), "bloodspray" ) then luaeffectdata:SetScale( effectscale * 4 ) end

		if target:GetAttachment(attachnum) != nil then
			luaeffectdata:SetAttachment( attachnum )
			luaeffectdata:SetStart( target:GetAttachment( attachnum ).Pos )
			luaeffectdata:SetOrigin( target:GetAttachment( attachnum ).Pos )
			luaeffectdata:SetAngles( target:GetAttachment( attachnum ).Ang )
			luaeffectdata:SetNormal( target:GetAttachment( attachnum ).Ang:Forward() )
		else
			luaeffectdata:SetStart( target:GetPos() )
			luaeffectdata:SetOrigin( target:GetPos() )
			luaeffectdata:SetAngles( target:GetAngles() )
			luaeffectdata:SetNormal( target:GetAngles():Forward() )
		end

		if IsValid(target2) then
			if target2:GetAttachment(attachnum2) != nil then
				luaeffectdata:SetOrigin( target2:GetAttachment( attachnum2 ).Pos )
				luaeffectdata:SetNormal( target2:GetAttachment( attachnum2 ).Ang:Forward() )
			else
				luaeffectdata:SetOrigin( target2:GetPos() )
				luaeffectdata:SetNormal( target2:GetAngles():Forward() )
			end
		end

		util.Effect( string.Replace( effectname, "!UTILEFFECT!", "" ), luaeffectdata )

	else

		//Create a particlesystem effect

		target:CreateParticleEffect(effectname,self.cpointtable)

	end

end



function ENT:RemoveParticle(arewerepeating,effectwereremoving)

	local target = self:GetTargetEnt()

	if CLIENT then 
		if target:IsValid() then target:StopParticleEmission(effectwereremoving) end

		//StopParticleEmission is broken and removes ALL effects on the entity, not just the one specified, so to try and counteract this we'll reactivate them.
		if target != self then
			for _, asdf in pairs( ents:GetAll() ) do
				if asdf != self then
					if IsValid(asdf) and asdf:GetClass() == "particlecontroller_normal" and asdf:GetParent() == target then
						//Make sure the ent is active, but not already creating the particle by itself. We don't want to double their particle by mistake.
						if asdf.GetActive and asdf:GetActive() == true and asdf:GetNumpadState() == "" then asdf:AttachParticle() end
					end
				end
			end
		end
	end

	if arewerepeating == true then self:AttachParticle() end

end




//numpad functions
if SERVER then

local function NumpadPress( pl, ent )

	if ( !ent || ent == NULL ) then return end
	
	if ( ent:GetToggle() ) then
		if ent:GetActive() == false then
			ent:SetActive(true)
			ent:SetNumpadState("on")
		else
			ent:SetActive(false)
			ent:SetNumpadState("off")
		end
	else
		ent:SetActive( true )
		ent:SetNumpadState("on")
	end

end

local function NumpadRelease( pl, ent )

	if ( !ent || ent == NULL ) then return end
	
	if ( ent:GetToggle() ) then return end
	
	ent:SetActive(false)
	ent:SetNumpadState("off")
	
end

numpad.Register( "Particle_Press", NumpadPress )
numpad.Register( "Particle_Release", NumpadRelease )

end




function ENT:OnRemove()
	self:RemoveParticle(false,self:GetEffectName())
end




//don't duplicate this
duplicator.RegisterEntityClass( "particlecontroller_normal", function( ply, data )
end, "Data" )
--lua/entities/particlecontroller_proj.lua:
AddCSLuaFile()

ENT.Base 			= "base_gmodentity"
ENT.PrintName			= "Particle Controller - Projectile"
ENT.Author			= ""

ENT.Spawnable			= false
ENT.AdminSpawnable		= false
ENT.RenderGroup			= RENDERGROUP_NONE




function ENT:SetupDataTables()

	self:NetworkVar( "Entity", 0, 	"TargetEnt" );


	self:NetworkVar( "String", 0, 	"ProjFX_EffectName" );
	self:NetworkVar( "Vector", 0, 	"ProjFX_UtilEffectInfo" );  //x = scale, y = magnitude, x = radius
	self:NetworkVar( "Vector", 1, 	"ProjFX_ColorInfo" );

	self:NetworkVar( "String", 1, 	"ImpactFX_EffectName" );
	self:NetworkVar( "Vector", 2, 	"ImpactFX_UtilEffectInfo" );  //x = scale, y = magnitude, x = radius
	self:NetworkVar( "Vector", 3, 	"ImpactFX_ColorInfo" );

	self:NetworkVar( "Int", 0, 	"AttachNum" );
	self:NetworkVar( "Float", 0, 	"RepeatRate" );

	self:NetworkVar( "String", 2, 	"ProjModel" );
	self:NetworkVar( "Int", 1, 	"ProjModel_AttachNum" );
	self:NetworkVar( "Bool", 0, 	"ProjModel_Invis" );
	self:NetworkVar( "Float", 1, 	"ImpactFX_EffectLifetime" );

	self:NetworkVar( "Float", 2, 	"ProjEnt_Spread" );
	self:NetworkVar( "Int", 2, 	"ProjEnt_Velocity" );
	self:NetworkVar( "Bool", 1, 	"ProjEnt_Gravity" );
	self:NetworkVar( "Int", 3, 	"ProjEnt_Angle" );
	self:NetworkVar( "Int", 4, 	"ProjEnt_Spin" );
	self:NetworkVar( "Bool", 2, 	"ProjEnt_DemomanFix" );
	self:NetworkVar( "Float", 3, 	"ProjEnt_Lifetime_PreHit" );
	self:NetworkVar( "Float", 4, 	"ProjEnt_Lifetime_PostHit" );
	self:NetworkVar( "Bool", 3, 	"ProjEnt_Serverside" );


	self:NetworkVar( "Bool", 4, 	"Active" );
	self:NetworkVar( "Bool", 5, 	"Toggle" );
	self:NetworkVar( "Int", 5, 	"NumpadKey" );
	self:NetworkVar( "String", 3, 	"NumpadState" );

end




function ENT:Initialize()

	util.PrecacheModel(self:GetProjModel())
	local target = self:GetTargetEnt()


	if SERVER then

		//Use ourselves as the target - we'll fire projectiles from our own position and angles
		local attachment1 = target:GetAttachment( self:GetAttachNum() )
		if attachment1 != nil then
			self:SetPos( attachment1.Pos )
			self:SetAngles( attachment1.Ang )
			self:Fire("setparentattachment", target:GetAttachments()[self:GetAttachNum()].name, 0.01)
			self:SetTargetEnt(self)
		end

	else

		//Set things up for a particlesystem effect

		local projfx_effectname = self:GetProjFX_EffectName()
		if projfx_effectname != "" and !string.StartWith( projfx_effectname, "!UTILEFFECT!" ) then
			PrecacheParticleSystem(projfx_effectname)
		end

		local impactfx_effectname = self:GetImpactFX_EffectName()
		if impactfx_effectname != "" and !string.StartWith( impactfx_effectname, "!UTILEFFECT!" ) then
			PrecacheParticleSystem(impactfx_effectname)
		end

	end
	//super niche bug fix: if we're in multiplayer and our model has any attachment points, then we'll cause visual jittering in the buildbonepositions callback of 
	//the entity we're parented to. originally we were using our own model to store the projectile model, but that was causing the aforementioned bug, so now we're 
	//storing the projectile model separately and having this entity use a neutral model that won't cause problems.
	self:SetModel("models/hunter/plates/plate.mdl")
	self:SetNoDraw(true)


	//Don't let players set the repeat rate to a really low amount that lets them spam tons of props every second
	if self:GetRepeatRate() > 0 and self:GetRepeatRate() < 0.1 then self:SetRepeatRate(0.1) end

	if self:GetRepeatRate() > 0 then
		//we're going to be repeating the effect, so let's set that up and let think do the rest
		self.NextRepeat = 0
	else
		//we won't be repeating the effect, so just attach it right now
		if self:GetActive() then self:AttachParticle() end
	end

end




function ENT:Think()

	if self:GetProjEnt_Serverside() then
		if CLIENT then return end
	else
		if SERVER then return end
	end

	if self:GetNumpadState() == "off" then
		//MsgN("turn off")
		self:SetNumpadState("")
	end

	if self:GetNumpadState() == "on" then
		//MsgN("turn on")
		self:SetNumpadState("")
		if self:GetRepeatRate() > 0 then
			//we're going to be repeating the effect, so let's set that up and let think do the rest
			self.NextRepeat = 0
		else
			//we won't be repeating the effect, so just attach it right now
			if self:GetActive() then self:AttachParticle() end
		end
	end


	if self:GetActive() == true and self:GetRepeatRate() > 0 then
		if !( self.NextRepeat > CurTime() ) then
			self:AttachParticle()
			self.NextRepeat = CurTime() + self:GetRepeatRate()
		end
	end
	
	self:NextThink(CurTime())
	return true

end




function ENT:AttachParticle()

	if !self then return end

	if self:GetProjEnt_Serverside() then
		if CLIENT then return end
	else
		if SERVER then return end
	end

	local projent_spread		= math.Clamp( self:GetProjEnt_Spread(), 0, 4)
	local projent_velocity		= self:GetProjEnt_Velocity()
	local projent_gravity		= self:GetProjEnt_Gravity()
	local projent_angle		= self:GetProjEnt_Angle()
	local projent_spin		= self:GetProjEnt_Spin()
	local projent_demomanfix	= self:GetProjEnt_DemomanFix()
	local projent_lifetime_prehit	= math.Clamp( self:GetProjEnt_Lifetime_PreHit(), 0, 10)
	local projent_lifetime_posthit	= math.Clamp( self:GetProjEnt_Lifetime_PostHit(), 0, 10)

	local projfx_effectname		= self:GetProjFX_EffectName()
	local projmodel_attachnum	= self:GetProjModel_AttachNum()

	local impactfx_effectname	= self:GetImpactFX_EffectName()
	local impactfx_effectlifetime	= math.Clamp( self:GetImpactFX_EffectLifetime(), 0, 10)
	local impactfx_utileffectinfo	= self:GetImpactFX_UtilEffectInfo()
	local impactfx_colorinfo	= self:GetImpactFX_ColorInfo()



	//Create the projectile entity
	local proj = nil
	if SERVER then
		proj = ents.Create("parctrl_dummyent")
		proj:SetModel(self:GetProjModel())
	end
	if CLIENT then	
		proj = ClientsideModel(self:GetProjModel())
	end

	if !util.IsValidProp(self:GetProjModel()) then
		proj:PhysicsInitBox(proj:GetModelBounds())
	else
		proj:PhysicsInit(SOLID_VPHYSICS)
	end
	proj:GetPhysicsObject():Wake()

	proj:SetNoDraw(self:GetProjModel_Invis())
	proj:SetSkin(self:GetSkin())
	proj:SetMaterial(self:GetMaterial())
	proj:SetPos(self:GetPos())


	proj:Spawn()
	proj:Activate()
	local projphys = proj:GetPhysicsObject()

	local selfang = self:GetAngles()
	//a lot of attachment points are oriented at an angle on the roll axis - correct this, we want the default projectile angle to be upright
	if self:GetParent() != NULL then  //this returns a null entity if the player is outside of the visleaf, be careful
		if self:GetParent():GetAttachment( self:GetAttachNum() ) then
			local _, attachang = WorldToLocal(self:GetPos(), selfang, self:GetParent():GetPos(), self:GetParent():GetAngles())
			selfang = Angle(selfang.p,selfang.y,selfang.r - attachang.r)
		end
	end
	//muzzle attachments on demoman weapons are oriented 90 degrees to the side for some reason - give players an option to fix this
	if projent_demomanfix == true then selfang:RotateAroundAxis( selfang:Up(), -90 ) end

	//spread
	local projang = Angle(selfang.p,selfang.y,selfang.r)  //self:GetAngles()
	local randang = AngleRand()
	projang:RotateAroundAxis( projang:Forward(), randang.r )
	projang:RotateAroundAxis( projang:Right(), randang.p * (projent_spread / 2) )
	projang:RotateAroundAxis( projang:Up(), randang.y * (projent_spread / 4) )
	//set the velocity
	projphys:SetVelocity(projang:Forward() * projent_velocity)
	//now de-randomize the roll - we only needed to do that for the velocity
	projang:RotateAroundAxis( projang:Forward(), -randang.r )

	//change the angle of the projectile
	local rotationang = Angle(0,0,0)
	//0 = forward, don't change it
	//1 = left
	if projent_angle == 1 then projang:RotateAroundAxis( projang:Up(), 90 ) rotationang = Angle(0,-90,0)
	//2 = right
	elseif projent_angle == 2 then projang:RotateAroundAxis( projang:Up(), -90 ) rotationang = Angle(0,90,0)
	//3 = up
	elseif projent_angle == 3 then projang:RotateAroundAxis( projang:Right(), 90 ) rotationang = Angle(90,0,0)
	//4 = down
	elseif projent_angle == 4 then projang:RotateAroundAxis( projang:Right(), -90 ) rotationang = Angle(-90,0,0)
	//5 = back
	elseif projent_angle == 5 then projang:RotateAroundAxis( projang:Up(), 180 ) rotationang = Angle(0,180,0) end
	proj:SetAngles(projang)

	//add spin - spin should be the same regardless of which way we've oriented the prop with projent_angle
	//0 - don't spin
	//1 - spin pitch
	if projent_spin == 1 then projphys:AddAngleVelocity( rotationang:Right() * -350 )
	//2 - spin yaw
	elseif projent_spin == 2 then projphys:AddAngleVelocity( rotationang:Forward() * 350 )
	//3 - spin roll
	elseif projent_spin == 3 then projphys:AddAngleVelocity( rotationang:Up() * -350 )
	//4 - spin random
	elseif projent_spin == 4 then projphys:AddAngleVelocity( VectorRand() * -350 ) end

	projphys:EnableGravity(projent_gravity)
	projphys:SetMaterial("gmod_silent")   //don't play physics sounds
	proj:SetCollisionGroup(COLLISION_GROUP_INTERACTIVE_DEBRIS)   //don't collide with other projectiles
	proj:SetOwner(self:GetParent())   //don't collide with the prop that the effect ent is parented to
	if SERVER then self:DeleteOnRemove(proj) end   //delete the proj if the effect ent is removed - i'd love to do this for clientside projs too but this function is serverside only



	//Create the projectile effect, if enabled
	if projfx_effectname != "" then

		local projfxent = proj

		if SERVER then
			//since we can't call util.Effect or CreateParticleEffect on the server, we have to get the ent to do it itself
			projfxent:SetEffectName(projfx_effectname)
			projfxent:SetColorInfo(self:GetProjFX_ColorInfo())
			projfxent:SetUtilEffectInfo(self:GetProjFX_UtilEffectInfo())
			projfxent:SetAttachNum(projmodel_attachnum)
		end
		if CLIENT then
			if string.StartWith( projfx_effectname, "!UTILEFFECT!" ) then

				//Create a util effect

				//Unfortunately, we have to do all of this every single time the effect repeats, because if we do it in Initialize instead, a whole bunch of stuff doesn't work properly

				local effectscale = self:GetProjFX_UtilEffectInfo().x
				local effectmagnitude = self:GetProjFX_UtilEffectInfo().y
				local effectradius = self:GetProjFX_UtilEffectInfo().z

				local projeffectdata = EffectData()
				projeffectdata:SetEntity( projfxent )
				//if ( string.find(projfx_effectname, "Tracer", 0, true) != nil ) then projeffectdata:SetScale(5000) else projeffectdata:SetScale( effectscale ) end  //for tracer effects, scale is the speed of the bullet, so we need to keep this high; useless for a projectile effect
				projeffectdata:SetScale( effectscale )
				projeffectdata:SetMagnitude( effectmagnitude )
				projeffectdata:SetRadius(effectradius )

				//flags can be set by typing !FLAG#! at the end of the effect name
				projeffectdata:SetFlags( 0 )
				if string.EndsWith( projfx_effectname, "!" ) then
					if string.find( projfx_effectname, "!FLAG1!" ) then projeffectdata:SetFlags( 1 ) projfx_effectname = string.Replace( projfx_effectname, "!FLAG1!", "" ) end
					if string.find( projfx_effectname, "!FLAG2!" ) then projeffectdata:SetFlags( 2 ) projfx_effectname = string.Replace( projfx_effectname, "!FLAG2!", "" ) end
					if string.find( projfx_effectname, "!FLAG3!" ) then projeffectdata:SetFlags( 3 ) projfx_effectname = string.Replace( projfx_effectname, "!FLAG3!", "" ) end
					if string.find( projfx_effectname, "!FLAG4!" ) then projeffectdata:SetFlags( 4 ) projfx_effectname = string.Replace( projfx_effectname, "!FLAG4!", "" ) end
					if string.find( projfx_effectname, "!FLAG5!" ) then projeffectdata:SetFlags( 5 ) projfx_effectname = string.Replace( projfx_effectname, "!FLAG5!", "" ) end
					if string.find( projfx_effectname, "!FLAG6!" ) then projeffectdata:SetFlags( 6 ) projfx_effectname = string.Replace( projfx_effectname, "!FLAG6!", "" ) end
					if string.find( projfx_effectname, "!FLAG7!" ) then projeffectdata:SetFlags( 7 ) projfx_effectname = string.Replace( projfx_effectname, "!FLAG7!", "" ) end
					if string.find( projfx_effectname, "!FLAG8!" ) then projeffectdata:SetFlags( 8 ) projfx_effectname = string.Replace( projfx_effectname, "!FLAG8!", "" ) end
					if string.find( projfx_effectname, "!FLAG9!" ) then projeffectdata:SetFlags( 9 ) projfx_effectname = string.Replace( projfx_effectname, "!FLAG9!", "" ) end
				end

				//colors can also be set the same way
				projeffectdata:SetColor(0)
				if string.EndsWith( projfx_effectname, "!" ) then
					if string.find( projfx_effectname, "!COLOR1!" ) then projeffectdata:SetColor( 1 ) projfx_effectname = string.Replace( projfx_effectname, "!COLOR1!", "" ) end
					if string.find( projfx_effectname, "!COLOR2!" ) then projeffectdata:SetColor( 2 ) projfx_effectname = string.Replace( projfx_effectname, "!COLOR2!", "" ) end
					if string.find( projfx_effectname, "!COLOR3!" ) then projeffectdata:SetColor( 3 ) projfx_effectname = string.Replace( projfx_effectname, "!COLOR3!", "" ) end
					if string.find( projfx_effectname, "!COLOR4!" ) then projeffectdata:SetColor( 4 ) projfx_effectname = string.Replace( projfx_effectname, "!COLOR4!", "" ) end
					if string.find( projfx_effectname, "!COLOR5!" ) then projeffectdata:SetColor( 5 ) projfx_effectname = string.Replace( projfx_effectname, "!COLOR5!", "" ) end
					if string.find( projfx_effectname, "!COLOR6!" ) then projeffectdata:SetColor( 6 ) projfx_effectname = string.Replace( projfx_effectname, "!COLOR6!", "" ) end
					if string.find( projfx_effectname, "!COLOR7!" ) then projeffectdata:SetColor( 7 ) projfx_effectname = string.Replace( projfx_effectname, "!COLOR7!", "" ) end
					if string.find( projfx_effectname, "!COLOR8!" ) then projeffectdata:SetColor( 8 ) projfx_effectname = string.Replace( projfx_effectname, "!COLOR8!", "" ) end
					if string.find( projfx_effectname, "!COLOR9!" ) then projeffectdata:SetColor( 9 ) projfx_effectname = string.Replace( projfx_effectname, "!COLOR9!", "" ) end
				end
	
				//dumb situational crap
				if string.find( string.lower(projfx_effectname), "shakeropes" ) then projeffectdata:SetMagnitude( effectmagnitude * 20 ) end
				if string.find( string.lower(projfx_effectname), "thumperdust" ) then projeffectdata:SetScale( effectscale * 50 ) end
				if string.find( string.lower(projfx_effectname), "bloodspray" ) then projeffectdata:SetScale( effectscale * 4 ) end

				//just in case someone makes a utileffect that works as a projectile effect
				if projfxent:GetAttachment(projmodel_attachnum) != nil then
					projeffectdata:SetStart( projfxent:GetAttachment( projmodel_attachnum ).Pos )
					projeffectdata:SetOrigin( projfxent:GetAttachment( projmodel_attachnum ).Pos )
					projeffectdata:SetAngles( projfxent:GetAttachment( projmodel_attachnum ).Ang )
					projeffectdata:SetNormal( projfxent:GetAttachment( projmodel_attachnum ).Ang:Forward() )
				else
					projeffectdata:SetStart( projfxent:GetPos() )
					projeffectdata:SetOrigin( projfxent:GetPos() )
					projeffectdata:SetAngles( projfxent:GetAngles() )
					projeffectdata:SetNormal( projfxent:GetAngles():Forward() )
				end

				util.Effect( string.Replace( projfx_effectname, "!UTILEFFECT!", "" ), projeffectdata )

			else

				//Create a particlesystem effect
	
				//Since we can't specify attachment points with Entity:CreateParticleEffect(), create an entity there to use as a target
				local attachment1 = proj:GetAttachment( projmodel_attachnum )
				if attachment1 != nil then
					//if SERVER then
					//	projfxent = ents.Create("parctrl_dummyent")
					//	projfxent:SetModel("models/hunter/plates/plate.mdl")
					//end
					if CLIENT then
						projfxent = ClientsideModel("models/hunter/plates/plate.mdl")
					end

					projfxent:SetParent(proj, projmodel_attachnum - 1)
					projfxent:SetPos( attachment1.Pos )
					projfxent:SetAngles( attachment1.Ang )
					projfxent:SetNoDraw(true)

					projfxent:Spawn()
					projfxent:Activate()

					proj:CallOnRemove("RemoveProjFX", function() if IsValid(projfxent) then projfxent:Remove() end end)
				end


				local clrtb = nil
				if self:GetProjFX_ColorInfo() == Vector(0,0,0) then
					//MsgN("color = false")
				else
					//MsgN("color = true")
					clrtb = { position = self:GetProjFX_ColorInfo() }
				end
				local projcpointtable = {}
					projcpointtable[1] = { entity = projfxent, attachtype = PATTACH_ABSORIGIN_FOLLOW }

					for i = 2, 64 do					
 						if clrtb then
							projcpointtable[i] = clrtb
						else
							projcpointtable[i] = projcpointtable[1]
						end
					end

				projfxent:CreateParticleEffect(projfx_effectname,projcpointtable)

			end
		end
	end



	local function projexpire(ent, pos, ang)

		//Create the impact effect, if enabled
		if impactfx_effectname != "" then

			//Create a new entity to attach the impact effect to - we can't use proj since we're removing it immediately after this
			local impactfxent = nil
			if SERVER then
				impactfxent = ents.Create("parctrl_dummyent")
				impactfxent:SetModel("models/hunter/plates/plate.mdl")
			end
			if CLIENT then
				impactfxent = ClientsideModel("models/hunter/plates/plate.mdl")
			end
			impactfxent:SetPos( pos or proj:GetPos() )
			impactfxent:SetAngles( ang or proj:GetAngles() )
			impactfxent:SetNoDraw(true)
			timer.Simple(impactfx_effectlifetime, function() if IsValid(impactfxent) then impactfxent:Remove() end; end)
			impactfxent:Spawn()
			impactfxent:Activate()

			if SERVER then
				//since we can't call util.Effect or CreateParticleEffect on the server, we have to get the ent to do it itself
				impactfxent:SetEffectName(impactfx_effectname)
				impactfxent:SetColorInfo(impactfx_colorinfo)
				impactfxent:SetUtilEffectInfo(impactfx_utileffectinfo)
				impactfxent:SetAttachNum(0)
			end
			if CLIENT then
				if string.StartWith( impactfx_effectname, "!UTILEFFECT!" ) then

					//Create a util effect

					//Unfortunately, we have to do all of this every single time the effect repeats, because if we do it in Initialize instead, a whole bunch of stuff doesn't work properly
	
					local effectscale = impactfx_utileffectinfo.x
					local effectmagnitude = impactfx_utileffectinfo.y
					local effectradius = impactfx_utileffectinfo.z

					local impacteffectdata = EffectData()
					impacteffectdata:SetEntity(impactfxent)
					//if ( string.find(impactfx_effectname, "Tracer", 0, true) != nil ) then impacteffectdata:SetScale(5000) else impacteffectdata:SetScale(effectscale) end  //for tracer effects, scale is the speed of the bullet, so we need to keep this high; useless for an impact effect
					impacteffectdata:SetScale(effectscale)
					impacteffectdata:SetMagnitude(effectmagnitude)
					impacteffectdata:SetRadius(effectradius)

					//flags can be set by typing !FLAG#! at the end of the effect name
					impacteffectdata:SetFlags( 0 )
					if string.EndsWith( impactfx_effectname, "!" ) then
						if string.find( impactfx_effectname, "!FLAG1!" ) then impacteffectdata:SetFlags( 1 ) impactfx_effectname = string.Replace( impactfx_effectname, "!FLAG1!", "" ) end
						if string.find( impactfx_effectname, "!FLAG2!" ) then impacteffectdata:SetFlags( 2 ) impactfx_effectname = string.Replace( impactfx_effectname, "!FLAG2!", "" ) end
						if string.find( impactfx_effectname, "!FLAG3!" ) then impacteffectdata:SetFlags( 3 ) impactfx_effectname = string.Replace( impactfx_effectname, "!FLAG3!", "" ) end
						if string.find( impactfx_effectname, "!FLAG4!" ) then impacteffectdata:SetFlags( 4 ) impactfx_effectname = string.Replace( impactfx_effectname, "!FLAG4!", "" ) end
						if string.find( impactfx_effectname, "!FLAG5!" ) then impacteffectdata:SetFlags( 5 ) impactfx_effectname = string.Replace( impactfx_effectname, "!FLAG5!", "" ) end
						if string.find( impactfx_effectname, "!FLAG6!" ) then impacteffectdata:SetFlags( 6 ) impactfx_effectname = string.Replace( impactfx_effectname, "!FLAG6!", "" ) end
						if string.find( impactfx_effectname, "!FLAG7!" ) then impacteffectdata:SetFlags( 7 ) impactfx_effectname = string.Replace( impactfx_effectname, "!FLAG7!", "" ) end
						if string.find( impactfx_effectname, "!FLAG8!" ) then impacteffectdata:SetFlags( 8 ) impactfx_effectname = string.Replace( impactfx_effectname, "!FLAG8!", "" ) end
						if string.find( impactfx_effectname, "!FLAG9!" ) then impacteffectdata:SetFlags( 9 ) impactfx_effectname = string.Replace( impactfx_effectname, "!FLAG9!", "" ) end
					end

					//colors can also be set the same way
					impacteffectdata:SetColor(0)
					if string.EndsWith( impactfx_effectname, "!" ) then
						if string.find( impactfx_effectname, "!COLOR1!" ) then impacteffectdata:SetColor( 1 ) impactfx_effectname = string.Replace( impactfx_effectname, "!COLOR1!", "" ) end
						if string.find( impactfx_effectname, "!COLOR2!" ) then impacteffectdata:SetColor( 2 ) impactfx_effectname = string.Replace( impactfx_effectname, "!COLOR2!", "" ) end
						if string.find( impactfx_effectname, "!COLOR3!" ) then impacteffectdata:SetColor( 3 ) impactfx_effectname = string.Replace( impactfx_effectname, "!COLOR3!", "" ) end
						if string.find( impactfx_effectname, "!COLOR4!" ) then impacteffectdata:SetColor( 4 ) impactfx_effectname = string.Replace( impactfx_effectname, "!COLOR4!", "" ) end
						if string.find( impactfx_effectname, "!COLOR5!" ) then impacteffectdata:SetColor( 5 ) impactfx_effectname = string.Replace( impactfx_effectname, "!COLOR5!", "" ) end
						if string.find( impactfx_effectname, "!COLOR6!" ) then impacteffectdata:SetColor( 6 ) impactfx_effectname = string.Replace( impactfx_effectname, "!COLOR6!", "" ) end
						if string.find( impactfx_effectname, "!COLOR7!" ) then impacteffectdata:SetColor( 7 ) impactfx_effectname = string.Replace( impactfx_effectname, "!COLOR7!", "" ) end
						if string.find( impactfx_effectname, "!COLOR8!" ) then impacteffectdata:SetColor( 8 ) impactfx_effectname = string.Replace( impactfx_effectname, "!COLOR8!", "" ) end
						if string.find( impactfx_effectname, "!COLOR9!" ) then impacteffectdata:SetColor( 9 ) impactfx_effectname = string.Replace( impactfx_effectname, "!COLOR9!", "" ) end
					end

					//dumb situational crap
					if string.find( string.lower(impactfx_effectname), "shakeropes" ) then impacteffectdata:SetMagnitude( effectmagnitude * 20 ) end
					if string.find( string.lower(impactfx_effectname), "thumperdust" ) then impacteffectdata:SetScale( effectscale * 50 ) end
					if string.find( string.lower(impactfx_effectname), "bloodspray" ) then impacteffectdata:SetScale( effectscale * 4 ) end

					impacteffectdata:SetStart( impactfxent:GetPos() )
					impacteffectdata:SetOrigin( impactfxent:GetPos() )
					impacteffectdata:SetAngles( impactfxent:GetAngles() )
					impacteffectdata:SetNormal( impactfxent:GetAngles():Forward() )

					util.Effect( string.Replace( impactfx_effectname, "!UTILEFFECT!", "" ), impacteffectdata )

				else

					//Create a particlesystem effect

					local clrtb = nil
					if impactfx_colorinfo == Vector(0,0,0) then
						//MsgN("color = false")
					else
						//MsgN("color = true")
						clrtb = { position = impactfx_colorinfo }
					end
					local impactcpointtable = {}
						impactcpointtable[1] = { entity = impactfxent, attachtype = PATTACH_ABSORIGIN_FOLLOW }

						for i = 2, 64 do					
 							if clrtb then
								impactcpointtable[i] = clrtb
							else
								impactcpointtable[i] = impactcpointtable[1]
							end
						end

					impactfxent:CreateParticleEffect(impactfx_effectname,impactcpointtable)

				end
			end
		end

		ent:Remove()

	end

	timer.Simple(projent_lifetime_prehit, function() if IsValid(proj) then projexpire(proj) end; end)

	local function projcollide(entity, data)
		if IsValid(entity) then
			if entity.HasHitSomething then return end   //there's no reason to call this more than once
			entity.HasHitSomething = true

			if projent_lifetime_posthit == 0 then
				//if lifetime_posthit is 0, then move the impactfx to the pos and angle of impact - 
				//we still need to use a timer because directly calling ent:Remove() in a PhysicsCollide callback crashes the game
				timer.Simple(0, function() if IsValid(proj) then projexpire(proj, data.HitPos, -data.HitNormal:Angle()) end; end) 
			else
				timer.Simple(projent_lifetime_posthit, function() if IsValid(proj) then projexpire(proj) end; end) 
			end
		end
	end
	if CLIENT then
		proj:AddCallback("PhysicsCollide", projcollide)
	else
		proj.PhysicsCollide = projcollide  //AddCallback inexplicably won't work on our sent we're using serverside, but overriding its physicscollide function seems to do it
	end

end




//numpad functions
if SERVER then

local function NumpadPress( pl, ent )

	if ( !ent || ent == NULL ) then return end
	
	if ( ent:GetToggle() ) then
		if ent:GetActive() == false then
			ent:SetActive(true)
			ent:SetNumpadState("on")
		else
			ent:SetActive(false)
			ent:SetNumpadState("off")
		end
	else
		ent:SetActive( true )
		ent:SetNumpadState("on")
	end

end

local function NumpadRelease( pl, ent )

	if ( !ent || ent == NULL ) then return end
	
	if ( ent:GetToggle() ) then return end
	
	ent:SetActive(false)
	ent:SetNumpadState("off")
	
end

numpad.Register( "Particle_Press", NumpadPress )
numpad.Register( "Particle_Release", NumpadRelease )

end




//don't duplicate this
duplicator.RegisterEntityClass( "particlecontroller_proj", function( ply, data )
end, "Data" )
--lua/entities/pfx1_08.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [Green]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_campfire_green"
--lua/entities/pfx1_08~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fire [Blue]"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]_campfire_blue"
--lua/entities/pfx1_0c.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Medium fire"
ENT.Category         = "PPE: Fire & Smoke"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[1]ground_fire_1"
--lua/entities/pfx2_04.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Swirl 1"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]swirl_1"
--lua/entities/pfx2_05.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "G-Man Starfield"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]gman_lines"
--lua/entities/pfx2_06~.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Dripping blood [Alien]"
ENT.Category         = "PPE: Other"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[2]blood_leak_alien"
--lua/entities/pfx4_00.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Basic Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_f"



--lua/entities/pfx4_02.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Red Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_r"

--lua/entities/pfx4_04.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "PFX:Purple Jet"
ENT.Category         = "PPE: Tech"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[4]jet_v"
--lua/entities/pfx7_02.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Snow"
ENT.Category         = "PPE: Weather"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[7]snow"
--lua/entities/pfx7_04.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Fog 2"
ENT.Category         = "PPE: Weather"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[7]area_of_fog"
--lua/entities/pfx8_01.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Red Vortex"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]red_vortex"
--lua/entities/pfx8_05.lua:
AddCSLuaFile()
ENT.Type             = "anim"
ENT.Base             = "pfx_base"
ENT.PrintName        = "Magic Orb 1"
ENT.Category         = "PPE: Magic"
ENT.Spawnable        = true
ENT.AdminOnly        = false
ENT.pfxname          = "[8]ball_core"
--lua/entities/prop_animatable.lua:

AddCSLuaFile()

ENT.Base = "base_entity"
ENT.Type = "anim"

ENT.WantsTranslucency = true -- For the outline
ENT.AutomaticFrameAdvance = true

function ENT:SetupDataTables()

	self:NetworkVar( "Bool", 0, "IsRagdoll" )
	self:NetworkVar( "Bool", 1, "AnimateBodyXY" )
	self:NetworkVar( "Bool", 2, "BecomeRagdoll" )
	self:NetworkVar( "Bool", 3, "HideBBox" )

	if ( CLIENT ) then return end

	self:SetIsRagdoll( false )
	self:SetAnimateBodyXY( false )
	self:SetBecomeRagdoll( false )

end

if ( SERVER ) then

	function ENT:SetPlayer( ply )

		-- Name compatible with base Sandbox function of the same name
		self.Founder = ply

	end

	function ENT:Initialize()

		-- This is a silly way to check if the model has a physics mesh or not
		self:PhysicsInit( SOLID_VPHYSICS )

		-- We got no physics? Do some fake shit
		if ( !IsValid( self:GetPhysicsObject() ) ) then
			local mins, maxs = self:OBBMins(), self:OBBMaxs()
			self:SetCollisionBounds( mins, maxs )
			self:SetSolid( SOLID_BBOX )
		end

		self:PhysicsDestroy()
		self:SetMoveType( MOVETYPE_NONE )

	end

	function ENT:FixRagdoll()

		local mins, maxs = self:OBBMins(), self:OBBMaxs()

		-- Just in case
		self.OriginalCollisions = mins
		self.OriginalCollisionsMax = maxs

		-- Fix some NPC ragdolls flying above ground
		mins.z = 0

		self:SetCollisionBounds( mins, maxs )
		self:SetSolid( SOLID_BBOX )

		-- Used to determine if this animatable prop should have the "Turn into Ragdoll" option.
		self:SetIsRagdoll( true )

	end

	function ENT:PreEntityCopy()

		self.DuplicatorSavedSequence = self:GetSequence()
		self.DuplicatorSavedSequenceName = self:GetSequenceName( self:GetSequence() )
		self.DuplicatorSavedCycle = self:GetCycle()
		self.DuplicatorSavedPlaybackRate = self:GetPlaybackRate()

		self.PoseParameters = {}
		for k = 0, self:GetNumPoseParameters() - 1 do
			local name = self:GetPoseParameterName( k )
			self.PoseParameters[ name ] = self:GetPoseParameter( name )
		end

	end

	function ENT:PostEntityPaste()

		if ( self:GetIsRagdoll() ) then self:FixRagdoll() end

		if ( !self.DuplicatorSavedSequence ) then return end

		if ( self.DuplicatorSavedSequence != self:LookupSequence( self.DuplicatorSavedSequenceName ) ) then
			print( "Something went wrong with restoring sequence for animatable prop!" )
			self.DuplicatorSavedSequence = self:LookupSequence( self.DuplicatorSavedSequenceName )
		end

		self:ResetSequence( self.DuplicatorSavedSequence )
		self:SetCycle( self.DuplicatorSavedCycle )
		self:SetPlaybackRate( self.DuplicatorSavedPlaybackRate )

		if ( self.PoseParameters ) then
			for name, value in pairs( self.PoseParameters ) do
				self:SetPoseParameter( name, value )
			end
		end

	end

	function ENT:OnTakeDamage( dmg )

		if ( !self:GetBecomeRagdoll() ) then return end

		if ( util.IsValidRagdoll( self:GetModel() ) ) then
			self:BecomeRagdollLua( dmg:GetDamageForce(), dmg:GetDamagePosition() )
		else
			self:GibBreakClient( dmg:GetDamageForce() )
			self:Remove()
		end

	end

end

function ENT:BecomeRagdollLua( force, forcePos )
	local ent = self

	local ragdoll = ents.Create( "prop_ragdoll" )
	ragdoll:SetModel( ent:GetModel() )
	ragdoll:SetPos( ent:GetPos() )
	ragdoll:SetAngles( ent:GetAngles() )

	ragdoll:SetSkin( ent:GetSkin() )
	ragdoll:SetFlexScale( ent:GetFlexScale() )
	for i = 0, ent:GetNumBodyGroups() - 1 do ragdoll:SetBodygroup( i, ent:GetBodygroup( i ) ) end
	for i = 0, ent:GetFlexNum() - 1 do ragdoll:SetFlexWeight( i, ent:GetFlexWeight( i ) ) end
	for i = 0, ent:GetBoneCount() do
		ragdoll:ManipulateBoneScale( i, ent:GetManipulateBoneScale( i ) )
		ragdoll:ManipulateBoneAngles( i, ent:GetManipulateBoneAngles( i ) )
		ragdoll:ManipulateBonePosition( i, ent:GetManipulateBonePosition( i ) )
		ragdoll:ManipulateBoneJiggle( i, ent:GetManipulateBoneJiggle( i ) ) -- Even though we don't know what this does, I am still putting this here.
	end

	ragdoll:Spawn()
	ragdoll:Activate()

	if ( IsValid( self.Founder ) ) then
		--self.Founder:AddCount( "ragdolls", ragdoll 
		gamemode.Call( "PlayerSpawnedRagdoll", self.Founder, ragdoll:GetModel(), ragdoll )
		self.Founder:AddCleanup( "ragdolls", ragdoll )
	end

	ragdoll.EntityMods = ent.EntityMods
	ragdoll.BoneMods = ent.BoneMods
	duplicator.ApplyEntityModifiers( nil, ragdoll )
	duplicator.ApplyBoneModifiers( nil, ragdoll )

	for i = 0, ragdoll:GetPhysicsObjectCount() - 1 do
		local bone = ragdoll:GetPhysicsObjectNum( i )
		if ( IsValid( bone ) ) then
			local pos, ang = ent:GetBonePosition( ragdoll:TranslatePhysBoneToBone( i ) )
			if ( pos ) then bone:SetPos( pos ) end
			if ( ang ) then bone:SetAngles( ang ) end

			if ( !force ) then
				bone:EnableMotion( false )
			else
				bone:ApplyForceOffset( force / ragdoll:GetPhysicsObjectCount(), forcePos )
			end
		end
	end

	undo.ReplaceEntity( ent, ragdoll )
	cleanup.ReplaceEntity( ent, ragdoll )

	constraint.RemoveAll( ent ) -- Remove all constraints ( this stops ropes from hanging around )
	ent:Remove()
end

function ENT:Think()

	-- Clientside only because Velocity is 0 on server
	if ( self:GetAnimateBodyXY() and CLIENT ) then

		local velocity = self:GetVelocity()
		velocity.z = 0

		local vecCurrentMoveYaw = Vector( velocity:GetNormalized():Dot( self:GetForward() ), velocity:GetNormalized():Dot( self:GetRight() ) )
		local flInvScale = math.max( math.abs( vecCurrentMoveYaw.x ), math.abs( vecCurrentMoveYaw.y ) );
		if ( flInvScale != 0.0 ) then
			vecCurrentMoveYaw.x = vecCurrentMoveYaw.x / flInvScale;
			vecCurrentMoveYaw.y =  vecCurrentMoveYaw.y / flInvScale;
		end

		self:SetPoseParameter( "move_x", vecCurrentMoveYaw.x )
		self:SetPoseParameter( "move_y", vecCurrentMoveYaw.y )

		local maxSpeed = self:GetSequenceGroundSpeed( self:GetSequence() )

		if ( maxSpeed > velocity:Length() ) then
			vecCurrentMoveYaw.x = vecCurrentMoveYaw.x * ( velocity:Length() / maxSpeed )
			vecCurrentMoveYaw.y = vecCurrentMoveYaw.y * ( velocity:Length() / maxSpeed )
		end
		self:SetPoseParameter( "move_x", vecCurrentMoveYaw.x )
		self:SetPoseParameter( "move_y", vecCurrentMoveYaw.y )

		-- This has to be on server to function :(
		--[[local scale = velocity:Length() / maxSpeed
		if ( maxSpeed != 0 ) then
			self:SetPlaybackRate( scale )
		end]]

	end

	if ( SERVER ) then
		-- Ugly hack because no replicated cvars for Lua :(
		self:SetHideBBox( GetConVarNumber( "rb655_easy_animation_nobbox_sv" ) > 0 )
	end

	-- Ensure the animation plays smoothly
	self:NextThink( CurTime() )
	return true

end

if ( SERVER ) then return end

function ENT:DrawBBox()

	if ( GetConVarNumber( "rb655_easy_animation_noglow" ) != 0 or self:GetHideBBox() ) then return end

	local wep = LocalPlayer():GetActiveWeapon()
	if ( !IsValid( wep ) or wep:GetClass() != "gmod_tool" and wep:GetClass() != "weapon_physgun" ) then
		return
	end

	local mins = self:OBBMins()
	local maxs = self:OBBMaxs()

	if ( self:GetSolid() == SOLID_BBOX ) then
		render.DrawWireframeBox( self:GetPos(), angle_zero, mins, maxs )
	else
		render.DrawWireframeBox( self:GetPos(), self:GetAngles(), mins, maxs )
	end

end

function ENT:Draw( flags )

	self:DrawBBox()

	-- This probably shouldn't run every frame..
	self:SetRenderBounds( self:GetModelBounds() )

	self:DrawModel( flags )

end

function ENT:DrawTranslucent( flags )

	self:Draw( flags )

end

--addons/egm_tfa_grenades/lua/entities/rw_sw_ent_nade_heal.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "explosive Grenade"
ENT.Author = ""
ENT.Information = ""
ENT.Spawnable = false
ENT.AdminSpawnable = false

ENT.BounceSound = Sound("TFA_CSGO_SmokeGrenade.Bounce")
ENT.ExplodeSound = Sound("weapons/tfa_starwars/Smoke_Explosive_Puff_01.wav")

AddCSLuaFile()

function ENT:Initialize()
	if SERVER then
		self:SetModel("models/forrezzur/bactagrenade.mdl")
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_DEBRIS)

		local phys = self:GetPhysicsObject()
		if phys:IsValid() then
			phys:Wake()
			phys:SetBuoyancyRatio(0)
		end

		self.Delay = CurTime() + 1.5
		self.NextParticle = 0
		self.ParticleCount = 0
		self.First = true
		self.IsDetonated = false
	end
	self:EmitSound("TFA_CSGO_SmokeGrenade.Throw")
end

function ENT:PhysicsCollide(data, physobj)
	if  (20 < data.Speed and 0.25 < data.DeltaTime) then
		self.Delay = 0
	end
end

function ENT:Think()
	if SERVER then
		if CurTime() > self.Delay then
			if self.IsDetonated == false then
				self:Detonate(self,self:GetPos())
				self.DetonatePos = self:GetPos()
				self.IsDetonated = true
			end
		end
	end

	if self.IsDetonated == true then
		for k, v in pairs( ents.FindInSphere( self.DetonatePos, 216 ) ) do
		if v:IsPlayer() then
			if v:Health() < v:GetMaxHealth() and v:Alive() and not v:GetNWBool("Realism.UsingBreather", false) then
				v:SetHealth( math.Clamp( v:Health() + math.random( 5, 9 ), 0, v:GetMaxHealth() ) )
					end
				end
			end
		end
	self:NextThink( CurTime() + 0.33 )
	return true
end

function ENT:Detonate(self,pos)
	self.ParticleCreated = false
	self.ExtinguishParticleCreated = false
	if SERVER then
		if not self:IsValid() then return end
		self:SetNWBool("IsDetonated",true)
		self:EmitSound(self.ExplodeSound)
		local gas = EffectData()
		gas:SetOrigin(pos)
		gas:SetEntity(self.Owner)
		util.Effect("tfa_csgo_healnade", gas)
	end

	--self:SetMoveType( MOVETYPE_NONE )

	if SERVER then
		SafeRemoveEntityDelayed(self,15)
	end

end

function ENT:Draw()
	if CLIENT then
		self:DrawModel()
	end
end
--addons/egm_tfa_grenades/lua/entities/rw_sw_nade.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

function ENT:Draw()
	self:DrawModel()
end


function ENT:Initialize()
	self.Entity:SetNWBool("smoke", 10, true)
	if SERVER then
		self:SetModel( "models/weapons/tfa_starwars/w_thermal.mdl" )
		self:PhysicsInit(SOLID_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)

	local phys = self:GetPhysicsObject()
	if (IsValid(phys)) then
		phys:SetMass(1)
	end
		self:DrawShadow( true )
	end
	self.Delay = CurTime() + 100000
	if CLIENT then
		self.emitter = ParticleEmitter( self:GetPos() , 0 )
	end
end

function ENT:PhysicsCollide( data, phys )
	if  (20 < data.Speed and 0.25 < data.DeltaTime) then
	self.Delay = 0
	end
end

function ENT:Think()
	if SERVER and (self.Delay and self.Delay <= CurTime()) then
		self:Explode()
	end
	self:NextThink(CurTime())

	if CLIENT then
		local pos = self:GetPos() + self:GetForward()
		local emitter = ParticleEmitter( self:GetPos() , 0 )
		local particle = emitter:Add("particle/smokesprites_000"..math.random(1,9), pos )
		for i=1, (1) do
			if (particle) then
				particle:SetVelocity((self:GetForward() * -400)+(VectorRand()* 10) )
				particle:SetDieTime( math.Rand( 0.5, 1.5 ) )
				particle:SetStartAlpha( math.Rand( 75, 50 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand( 20, 20 ) )
				particle:SetEndSize( math.Rand( 15, 15 ) )
				particle:SetRoll( math.Rand(0, 360) )
				particle:SetRollDelta( math.Rand(-1, 1) )
				particle:SetColor( 120 , 120 , 120 ) 
				particle:SetAirResistance( 2500 ) 
				particle:SetGravity( Vector( 0, 0, 0 ) )
			end
		end
	end
	return true
end


function ENT:Think2()
end

function ENT:Explode()
	local effectdata = EffectData()
	effectdata:SetOrigin( self:GetPos() )
	util.Effect("Explosion", effectdata)
	util.BlastDamage( self, self.Owner, self:GetPos(), 300, 200 )
	
	local spos = self:GetPos()
	local trs = util.TraceLine({start=spos + Vector(0,0,64), endpos=spos + Vector(0,0,-32), filter=self})
	util.Decal("Scorch", trs.HitPos + trs.HitNormal, trs.HitPos - trs.HitNormal)
	self:Remove()
end

function ENT:OnRemove()
end

--lua/entities/sent_swrc_det/shared.lua:
AddCSLuaFile( )
DEFINE_BASECLASS( "base_anim" )

ENT.IsDODSTNT = true
ENT.TotalExplosions = 1
ENT.AutomaticFrameAdvance = true

util.PrecacheModel( "models/weapons/w_swrcdeton.mdl" )
util.PrecacheSound( "buttons/spark6.wav" )
util.PrecacheSound( "ambient/fire/mtov_flame2.wav" )

if CLIENT then
	ENT.Mat = Material( "sprites/redglow1" )
	ENT.Mat2 = Material( "cable/redlaser" )
	
	ENT.LP = Vector( -.5, 1, 2 )
end

function ENT:SetupDataTables( )
	self:NetworkVar( "Float", 0, "Defuse" )
	self:NetworkVar( "Float", 1, "Fuse" )
	
	self:NetworkVar( "Int", 0, "BurnAdjust" )
	
	self:NetworkVar( "Bool", 0, "Live" )
end

function ENT:Draw( )

	
	local bone, n, light
	
	bone = self:GetAttachment( self:LookupAttachment( "wick" ) )
	
	if not bone then
		return
	end
	
	self:DrawModel( )
	
	if self:GetDefuse( ) < 1 then
		
		--if self.BurnSound then
			--self.BurnSound:PlayEx( .5, 170 )
		--end
	else
		if self.BurnSound then
			self.BurnSound:Stop( )
		end
	end
end

function ENT:OnRemove( )
	if self.BurnSound then
		self.BurnSound:Stop( )
	end
end

function ENT:Use(activator, caller)
	self.Entity:ActivateX(1)
end

function ENT:ActivateX( scale )
	if not self:GetLive( ) then
		self:SetLive( true )
		self:SetBurnAdjust( scale or 1 )
		
		seq = self:LookupSequence( "w_tnt_wick" )
		self:ResetSequence( seq )
		self:SetPlaybackRate( 1 / self:GetBurnAdjust( ) )
		
		if not self.BurnSound then
			self.BurnSound = CreateSound( self, Sound( "weapons/explosives_cannons_superlazers/sw_detonator.ogg" ) )
		end
		self.BurnSound:Play( )
	end
end

function ENT:OnTakeDamage( info )
	self:TakePhysicsDamage( info )
	if info and self:IsValid( ) and not self.Refuse then
		if info:IsExplosionDamage( ) then
			self:Explode( )
		end
	end
end

function ENT:Initialize( )
	self:SetModel( "models/weapons/w_swrcdeton.mdl" )
	
	if SERVER then
		self:SetDefuse( 0 )
		self:SetFuse( 0 )
		
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		
		self:PhysWake( )
	end
end

function ENT:Think( )
	local now, delta
	
	
	if CLIENT then
		return
	end
	
	now = CurTime( )
	
	delta = now - ( self.LastThink or now )
	
	self.LastThink = now
	
	if self:GetLive( ) then
		if not self.Used then
			self:SetDefuse( math.Clamp( self:GetDefuse( ) - delta * .5, 0, 1 ) )
		end
	end
	
	if self:GetDefuse( ) >= 1 and self:GetLive( ) then
		self:SetLive( false )
		
		self:EmitSound( "buttons/spark6.wav", 100, 63 )
		self:SetPlaybackRate( 0 )
	end
	
	if self:GetLive( ) then
		self:SetFuse( math.Clamp( self:GetFuse( ) + delta / ( self:GetBurnAdjust( ) * 19 ), 0, 1 ) )
		
		if self:GetFuse( ) >= 0.20 and SERVER then
			self:SetLive( false )
			self:Explode( )
		end
	end
	
	if self:GetLive( ) and self:WaterLevel( ) > 0 then
		self:SetLive( false )
		self:SetDefuse( 1 )
	end
	
	self.Used = false
end

local function Spin( vector, up, right, forward )
	local ang
	
	ang = ( vector * 1 ):Angle( )
	
	ang:RotateAroundAxis( ang:Up( ), math.random( -up / 2 , up / 2 ) )
	ang:RotateAroundAxis( ang:Right( ), math.random( -right / 2 , right / 2 ) )
	ang:RotateAroundAxis( ang:Forward( ), math.random( -forward / 2 , forward / 2 ) )
	
	return ang:Forward( )
end

function ENT:Explode( )
	if self.Refuse then
		return
	end
	
	self.Refuse = true
	
	for k, v in pairs (ents.FindInSphere(self.Entity:GetPos(), 250)) do
		v:Fire("EnableMotion", "", math.random(0, 0.5))
	end
	
	local explode = ents.Create( "env_explosion" )
	explode:SetPos( self:GetPos() )
	explode:SetKeyValue( "iMagnitude", "250" )
	explode:EmitSound( "hd/new_grenadeexplo.mp3", 100, 100 )
	explode:Spawn()
	explode:Activate()
	explode:Fire( "Explode", "", 0 )
	
	self:Remove()
end
--addons/starwars_universe/lua/entities/swu_controller/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    if (GetConVar("developer"):GetBool()) then
        render.SetColorMaterialIgnoreZ()
        render.DrawSphere(self:GetPos(), SWU.config.collisionRange, 50, 50, Color(240,230,150,150))
    end
end
--addons/starwars_universe/lua/libs/advanceddraw.lua:
--    Advanced Draw:
--    - IMGUI Source Code: https://github.com/wyozi-gmod/imgui
--    - Draw Precache Arc
--    - Draw Line with thickness

local adraw = {}

adraw.skin = {
    background = Color(0, 0, 0, 0),
    backgroundHover = Color(0, 0, 0, 0),
    border = Color(255, 255, 255),
    borderHover = Color(255, 127, 0),
    borderPress = Color(255, 80, 0),
    foreground = Color(255, 255, 255),
    foregroundHover = Color(255, 127, 0),
    foregroundPress = Color(255, 80, 0),
}

local devCvar = GetConVar("developer")

function adraw.IsDeveloperMode()
    return not adraw.DisableDeveloperMode and devCvar:GetInt() > 0
end

local _devMode = false -- cached local variable updated once in a while

function adraw.Hook(name, id, callback)
    local hookUniqifier = debug.getinfo(4).short_src
    hook.Add(name, "adraw / " .. id .. " / " .. hookUniqifier, callback)
end

local local_player
local gState = {}

local function shouldAcceptInput()
    -- don't process input during non-main renderpass
    if render.GetRenderTarget() ~= nil then return false end
    -- don't process input if we're doing VGUI stuff (and not in context menu)
    if vgui.CursorVisible() and vgui.GetHoveredPanel() ~= g_ContextMenu then return false end

    return true
end

adraw.Hook("PreRender", "adraw / Input", function()
    -- calculate mouse state
    if shouldAcceptInput() then
        local useBind = input.LookupBinding("+use", true)
        local attackBind = input.LookupBinding("+attack", true)
        local USE = useBind and input.GetKeyCode(useBind)
        local ATTACK = attackBind and input.GetKeyCode(attackBind)
        local wasPressing = gState.pressing
        gState.pressing = (USE and input.IsButtonDown(USE)) or (ATTACK and input.IsButtonDown(ATTACK))
        gState.pressed = not wasPressing and gState.pressing
    end
end)

hook.Add("NotifyShouldTransmit", "adraw / ClearRenderBounds", function(ent, shouldTransmit)
    if not shouldTransmit then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    tb._adrawRBExpansion = nil
end)

local traceResultTable = {}

local traceQueryTable = {
    output = traceResultTable,
    filter = {}
}

local function isObstructed(eyePos, hitPos, ignoredEntity)
    local q = traceQueryTable
    q.start = eyePos
    q.endpos = hitPos
    q.filter[1] = local_player
    q.filter[2] = ignoredEntity
    local tr = util.TraceLine(q)

    if tr.Hit then
        return true, tr.Entity
    else
        return false
    end
end

function adraw.Start3D2D(pos, angles, scale, distanceHide, distanceFadeStart)
    local_player = local_player or LocalPlayer()

    if gState.shutdown == true then return end

    if gState.rendering == true then
        print("[AdvancedDraw] Starting a new adraw context when previous one is still rendering" .. "Shutting down rendering pipeline to prevent crashes..")
        gState.shutdown = true

        return false
    end

    _devMode = adraw.IsDeveloperMode()
    local eyePos = local_player:EyePos()
    local eyePosToPos = pos - eyePos

    -- OPTIMIZATION: Test that we are in front of the UI
    do
        local normal = angles:Up()
        local dot = eyePosToPos:Dot(normal)

        if _devMode then
            gState._devDot = dot
        end

        -- since normal is pointing away from surface towards viewer, dot<0 is visible
        if dot >= 0 then return false end
    end

    -- OPTIMIZATION: Distance based fade/hide
    if distanceHide then
        local distance = eyePosToPos:Length()
        if distance > distanceHide then return false end

        if _devMode then
            gState._devDist = distance
            gState._devHideDist = distanceHide
        end

        if distanceHide and distanceFadeStart and distance > distanceFadeStart then
            local blend = math.min(math.Remap(distance, distanceFadeStart, distanceHide, 1, 0), 1)
            render.SetBlend(blend)
            surface.SetAlphaMultiplier(blend)
        end
    end

    gState.rendering = true
    gState.pos = pos
    gState.angles = angles
    gState.scale = scale
    cam.Start3D2D(pos, angles, scale)

    -- calculate mousepos
    if not vgui.CursorVisible() or vgui.IsHoveringWorld() then
        local tr = local_player:GetEyeTrace()
        local eyepos = tr.StartPos
        local eyenormal

        if vgui.CursorVisible() and vgui.IsHoveringWorld() then
            eyenormal = gui.ScreenToVector(gui.MousePos())
        else
            eyenormal = tr.Normal
        end

        local planeNormal = angles:Up()
        local hitPos = util.IntersectRayWithPlane(eyepos, eyenormal, pos, planeNormal)

        if hitPos then
            local obstructed, obstructer = isObstructed(eyepos, hitPos, gState.entity)

            if obstructed then
                gState.mx = nil
                gState.my = nil

                if _devMode then
                    gState._devInputBlocker = "collision " .. obstructer:GetClass() .. "/" .. obstructer:EntIndex()
                end
            else
                local diff = pos - hitPos
                -- This cool code is from Willox's keypad CalculateCursorPos
                local x = diff:Dot(-angles:Forward()) / scale
                local y = diff:Dot(-angles:Right()) / scale
                gState.mx = x
                gState.my = y
            end
        else
            gState.mx = nil
            gState.my = nil

            if _devMode then
                gState._devInputBlocker = "not looking at plane"
            end
        end
    else
        gState.mx = nil
        gState.my = nil

        if _devMode then
            gState._devInputBlocker = "not hovering world"
        end
    end

    if _devMode then
        gState._renderStarted = SysTime()
    end

    return true
end

function adraw.Entity3D2D(ent, lpos, lang, scale, ...)
    gState.entity = ent
    local ret = adraw.Start3D2D(ent:LocalToWorld(lpos), ent:LocalToWorldAngles(lang), scale, ...)

    if not ret then
        gState.entity = nil
    end

    return ret
end

local function calculateRenderBounds(x, y, w, h)
    local pos = gState.pos
    local fwd, right = gState.angles:Forward(), gState.angles:Right()
    local scale = gState.scale
    local firstCorner, secondCorner = pos + fwd * x * scale + right * y * scale, pos + fwd * (x + w) * scale + right * (y + h) * scale
    local minrb, maxrb = Vector(math.huge, math.huge, math.huge), Vector(-math.huge, -math.huge, -math.huge)
    minrb.x = math.min(minrb.x, firstCorner.x, secondCorner.x)
    minrb.y = math.min(minrb.y, firstCorner.y, secondCorner.y)
    minrb.z = math.min(minrb.z, firstCorner.z, secondCorner.z)
    maxrb.x = math.max(maxrb.x, firstCorner.x, secondCorner.x)
    maxrb.y = math.max(maxrb.y, firstCorner.y, secondCorner.y)
    maxrb.z = math.max(maxrb.z, firstCorner.z, secondCorner.z)

    return minrb, maxrb
end

function adraw.ExpandRenderBoundsFromRect(x, y, w, h)
    local ent = gState.entity

    if IsValid(ent) then
        local tb = ent:GetTable()
        -- make sure we're not applying same expansion twice
        local expansion = tb._adrawRBExpansion

        if expansion then
            local ex, ey, ew, eh = unpack(expansion)
            if ex == x and ey == y and ew == w and eh == h then return end
        end

        local minrb, maxrb = calculateRenderBounds(x, y, w, h)
        ent:SetRenderBoundsWS(minrb, maxrb)

        if _devMode then
            print("[adraw] Updated renderbounds of ", ent, " to ", minrb, "x", maxrb)
        end

        tb._adrawRBExpansion = {x, y, w, h}
    else
        if _devMode then
            print("[adraw] Attempted to update renderbounds when entity is not valid!! ", debug.traceback())
        end
    end
end

local devOffset = Vector(0, 0, 30)

local devColours = {
    background = Color(0, 0, 0, 200),
    title = Color(78, 205, 196),
    mouseHovered = Color(0, 255, 0),
    mouseUnhovered = Color(255, 0, 0),
    pos = Color(255, 255, 255),
    distance = Color(200, 200, 200, 200),
    ang = Color(255, 255, 255),
    dot = Color(200, 200, 200, 200),
    angleToEye = Color(200, 200, 200, 200),
    renderTime = Color(255, 255, 255),
    renderBounds = Color(0, 0, 255)
}

local function developerText(str, x, y, clr)
    draw.SimpleText(str, "DefaultFixedDropShadow", x, y, clr, TEXT_ALIGN_CENTER, nil)
end

local function drawDeveloperInfo()
    local camAng = local_player:EyeAngles()
    camAng:RotateAroundAxis(camAng:Right(), 90)
    camAng:RotateAroundAxis(camAng:Up(), -90)
    cam.IgnoreZ(true)
    cam.Start3D2D(gState.pos + devOffset, camAng, 0.15)
        local bgCol = devColours["background"]
        surface.SetDrawColor(bgCol.r, bgCol.g, bgCol.b, bgCol.a)
        surface.DrawRect(-100, 0, 200, 140)
        local titleCol = devColours["title"]
        developerText("adraw developer", 0, 5, titleCol)
        surface.SetDrawColor(titleCol.r, titleCol.g, titleCol.b)
        surface.DrawLine(-50, 16, 50, 16)
        local mx, my = gState.mx, gState.my
    
        if mx and my then
            developerText(string.format("mouse: hovering %d x %d", mx, my), 0, 20, devColours["mouseHovered"])
        else
            developerText(string.format("mouse: %s", gState._devInputBlocker or ""), 0, 20, devColours["mouseUnhovered"])
        end
    
        local pos = gState.pos
        developerText(string.format("pos: %.2f %.2f %.2f", pos.x, pos.y, pos.z), 0, 40, devColours["pos"])
        developerText(string.format("distance %.2f / %.2f", gState._devDist or 0, gState._devHideDist or 0), 0, 53, devColours["distance"])
        local ang = gState.angles
        developerText(string.format("ang: %.2f %.2f %.2f", ang.p, ang.y, ang.r), 0, 75, devColours["ang"])
        developerText(string.format("dot %d", gState._devDot or 0), 0, 88, devColours["dot"])
        local angToEye = (pos - local_player:EyePos()):Angle()
        angToEye:RotateAroundAxis(ang:Up(), -90)
        angToEye:RotateAroundAxis(ang:Right(), 90)
        developerText(string.format("angle to eye (%d,%d,%d)", angToEye.p, angToEye.y, angToEye.r), 0, 100, devColours["angleToEye"])
        developerText(string.format("rendertime avg: %.2fms", (gState._devBenchAveraged or 0) * 1000), 0, 120, devColours["renderTime"])
    cam.End3D2D()
    cam.IgnoreZ(false)
    local ent = gState.entity

    if not IsValid(ent) then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    local ex, ey, ew, eh = unpack(tb._adrawRBExpansion)
    local minrb, maxrb = calculateRenderBounds(ex, ey, ew, eh)
    render.DrawWireframeBox(vector_origin, angle_zero, minrb, maxrb, devColours["renderBounds"])
end

function adraw.End3D2D()
    if gState then
        if _devMode then
            local renderTook = SysTime() - gState._renderStarted
            gState._devBenchTests = (gState._devBenchTests or 0) + 1
            gState._devBenchTaken = (gState._devBenchTaken or 0) + renderTook

            if gState._devBenchTests == 100 then
                gState._devBenchAveraged = gState._devBenchTaken / 100
                gState._devBenchTests = 0
                gState._devBenchTaken = 0
            end
        end

        gState.rendering = false
        cam.End3D2D()
        render.SetBlend(1)
        surface.SetAlphaMultiplier(1)

        if _devMode then
            drawDeveloperInfo()
        end

        gState.entity = nil
    end
end

function adraw.CursorPos()
    local mx, my = gState.mx, gState.my

    return mx, my
end

function adraw.IsHovering(x, y, w, h)
    local mx, my = gState.mx, gState.my

    return mx and my and mx >= x and mx <= (x + w) and my >= y and my <= (y + h)
end

function adraw.IsPressing()
    return shouldAcceptInput() and gState.pressing
end

function adraw.IsPressed()
    return shouldAcceptInput() and gState.pressed
end

local _createdFonts = {}
local _adrawFontToGmodFont = {}
local EXCLAMATION_BYTE = string.byte("!")

function adraw.xFont(font, defaultSize)
    -- special font
    if string.byte(font, 1) == EXCLAMATION_BYTE then
        local existingGFont = _adrawFontToGmodFont[font]
        if existingGFont then return existingGFont end
        -- Font not cached; parse the font
        local name, size = font:match("!([^@]+)@(.+)")

        if size then
            size = tonumber(size)
        end

        if not size and defaultSize then
            name = font:match("^!([^@]+)$")
            size = defaultSize
        end

        local fontName = string.format("adraw_%s_%d", name, size)
        _adrawFontToGmodFont[font] = fontName

        if not _createdFonts[fontName] then
            surface.CreateFont(fontName, {
                font = name,
                size = size
            })

            _createdFonts[fontName] = true
        end

        return fontName
    end

    return font
end

function adraw.DrawBox(x,y,w,h,borderWidth, borderColor)
    if borderWidth > 0 then
        surface.SetDrawColor(borderColor)
        surface.DrawRect(x, y, w, borderWidth)
        surface.DrawRect(x, y + borderWidth, borderWidth, h - borderWidth * 2)
        surface.DrawRect(x, y + h - borderWidth, w, borderWidth)
        surface.DrawRect(x + w - borderWidth + 1, y, borderWidth, h)
    end
end

function adraw.xButton(x, y, w, h, borderWidth, borderClr, hoverClr, pressColor)
    local bw = borderWidth or 1
    local bgColor = adraw.IsHovering(x, y, w, h) and adraw.skin.backgroundHover or adraw.skin.background
    local borderColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.borderPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.borderHover)) or (borderClr or adraw.skin.border)
    surface.SetDrawColor(bgColor)
    surface.DrawRect(x, y, w, h)

    adraw.DrawBox(x,y,w,h,bw,borderColor)

    local isHovering = adraw.IsHovering(x, y, w, h)
    return shouldAcceptInput() and isHovering and gState.pressed, isHovering
end

function adraw.xOneColorButton(x, y, w, h, borderWidth, clr)
    local bw = borderWidth or 1
    surface.SetDrawColor(clr)
    surface.DrawRect(x, y, w, h)

    if bw > 0 then
        surface.SetDrawColor(clr)
        surface.DrawRect(x, y, w, bw)
        surface.DrawRect(x, y + bw, bw, h - bw * 2)
        surface.DrawRect(x, y + h - bw, w, bw)
        surface.DrawRect(x + w - bw + 1, y, bw, h)
    end

    return shouldAcceptInput() and adraw.IsHovering(x, y, w, h) and gState.pressed
end

function adraw.xCursor(x, y, w, h)
    local fgColor = adraw.IsPressing() and adraw.skin.foregroundPress or adraw.skin.foreground
    local mx, my = gState.mx, gState.my
    if not mx or not my then return end
    if x and w and (mx < x or mx > x + w) then return end
    if y and h and (my < y or my > y + h) then return end
    local cursorSize = math.ceil(0.3 / gState.scale)
    surface.SetDrawColor(fgColor)
    surface.DrawLine(mx - cursorSize, my, mx + cursorSize, my)
    surface.DrawLine(mx, my - cursorSize, mx, my + cursorSize)
end

function adraw.xTextButton(text, font, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    font = adraw.xFont(font, math.floor(h * 0.618))
    draw.SimpleText(text, font, x + w / 2, y + h / 2, fgColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

    return clicked
end

function adraw.xConButton(x, y, w, h, borderWidth, color, hoverClr, pressColor, conColor, condition)
    local fgColor
    local clicked
    if condition then
        fgColor = conColor
        clicked = adraw.xOneColorButton(x, y, w, h, borderWidth, conColor)
    else
        fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
        clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    end

    return clicked
end

function adraw.xSymbolButton(symbol, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    surface.SetMaterial(symbol)
    surface.SetDrawColor(fgColor)
    surface.DrawTexturedRect(x, y, w, h)

    return clicked
end

function adraw.xDrawLine(x, y, x2, y2, sz)
    local midX = (x + x2) / 2
    local midY = (y + y2) / 2

    local dx = x2 - x
    local dy = y2 - y
    local ang = -math.deg(math.atan2(dy, dx))

    local len = math.sqrt((x2 - x) ^ 2 + (y2 - y) ^ 2)
    draw.NoTexture()
    surface.DrawTexturedRectRotated(midX, midY, len, sz, ang)
end

local cached = {}

function adraw.Arc(cx, cy, radius, thickness, startang, endang, roughness, color)
    local arc = tostring(cx) .. tostring(cy) .. tostring(radius) .. tostring(thickness) .. tostring(startang) .. tostring(endang) .. tostring(roughness)
    surface.SetDrawColor(color)
    draw.NoTexture()

    if (cached[arc] == nil) then
        cached[arc] = adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    end

    adraw.DrawArc(cached[arc])
end

function adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    local triarc = {}
    local roughness = math.max(roughness or 1, 1)
    local step = roughness
    local startang, endang = startang or 0, endang or 0

    if startang > endang then
        step = math.abs(step) * -1
    end

    local inner = {}
    local r = radius - thickness

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * r), cy + (-math.sin(rad) * r)

        table.insert(inner, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    local outer = {}

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * radius), cy + (-math.sin(rad) * radius)

        table.insert(outer, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    for tri = 1, #inner * 2 do
        local p1, p2, p3
        p1 = outer[math.floor(tri / 2) + 1]
        p3 = inner[math.floor((tri + 1) / 2) + 1]

        if tri % 2 == 0 then
            p2 = outer[math.floor((tri + 1) / 2)]
        else
            p2 = inner[math.floor((tri + 1) / 2)]
        end

        table.insert(triarc, {p1, p2, p3})
    end

    return triarc
end

function adraw.DrawArc(arc)
    for _, v in ipairs(arc) do
        surface.DrawPoly(v)
    end
end

function adraw.DrawTexturedRectRotatedPoint( x, y, w, h, rot, x0, y0 )
    local c = math.cos( math.rad( rot ) )
    local s = math.sin( math.rad( rot ) )

    local newx = y0 * s - x0 * c
    local newy = y0 * c + x0 * s

    surface.DrawTexturedRectRotated( x + newx, y + newy, w, h, rot )
end

local matBlurScreen = Material("pp/blurscreen")
function adraw.Derma_DrawPanelBlur(panel, color)
    color = color or Color(10,10,10,100)
    local x, y = panel:LocalToScreen( 0, 0 )

    -- Menu cannot do blur
    if ( not MENU_DLL ) then
        surface.SetMaterial( matBlurScreen )
        surface.SetDrawColor( 255, 255, 255, 255 )

        for i = 0.33, 1, 0.33 do
            matBlurScreen:SetFloat( "$blur", 5 * i )
            matBlurScreen:Recompute()
            if ( render ) then
                render.UpdateScreenEffectTexture()
            end
            surface.DrawTexturedRect( x * -1, y * -1, ScrW(), ScrH() )
        end
    end

    surface.SetDrawColor(color)
    surface.DrawRect( x * -1, y * -1, ScrW(), ScrH() )
end

return adraw

--addons/starwars_universe/lua/entities/swu_lever_speed/cl_init.lua:
include("shared.lua")
local adraw = include("libs/advanceddraw.lua")

SWU = SWU or {}

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:ClientInitialize()
    self.Scale = 100
    self.ButtonWidth = 175
    self.ButtonHeight = 137
    self.Pos = 0
end

function ENT:Draw()
    self:DrawModel()
end

function ENT:DrawTranslucent()
    if adraw.Entity3D2D(self, Vector(0.33, -1.84, 4.8), Angle(0, 90, 23), 1 / self.Scale) then
        local shouldAcceptInput, isHovering = adraw.xButton(0, 0, self.ButtonWidth, self.ButtonHeight, 4, SWU.Colors.Default.passive, SWU.Colors.Default.primary, SWU.Colors.Default.accent)

        if shouldAcceptInput then
            self:StartNetAction()
            net.WriteBool(true)
            net.SendToServer()
        end

        surface.SetAlphaMultiplier(1)
        draw.NoTexture()
        surface.SetDrawColor(SWU.Colors.Default.passive:Unpack())
        if isHovering then
            if (adraw.IsPressing()) then
                surface.SetDrawColor(SWU.Colors.Default.accent:Unpack())
            else
                surface.SetDrawColor(SWU.Colors.Default.primary:Unpack())
            end
        end

        surface.DrawPoly({
            {
                x = self.ButtonWidth * 0.5,
                y = self.ButtonHeight * 0.25
            },
            {
                x = self.ButtonWidth * 0.75,
                y = self.ButtonHeight * 0.75
            },
            {
                x = self.ButtonWidth * 0.25,
                y = self.ButtonHeight * 0.75
            }
        })

        shouldAcceptInput, isHovering, isClicked = adraw.xButton(192, 0, self.ButtonWidth, self.ButtonHeight, 4, SWU.Colors.Default.passive, SWU.Colors.Default.primary, SWU.Colors.Default.accent)
        if shouldAcceptInput then
            self:StartNetAction()
            net.WriteBool(false)
            net.SendToServer()
        end

        surface.SetAlphaMultiplier(1)
        draw.NoTexture()
        surface.SetDrawColor(SWU.Colors.Default.passive:Unpack())
        if isHovering then
            if (adraw.IsPressing()) then
                surface.SetDrawColor(SWU.Colors.Default.accent:Unpack())
            else
                surface.SetDrawColor(SWU.Colors.Default.primary:Unpack())
            end
        end

        surface.DrawPoly({
            {
                x = self.ButtonWidth * 1.6,
                y = self.ButtonHeight * 0.75
            },
            {
                x = self.ButtonWidth * 1.35,
                y = self.ButtonHeight * 0.25
            },
            {
                x = self.ButtonWidth * 1.85,
                y = self.ButtonHeight * 0.25
            }
        })
        adraw.End3D2D()
    end
end
--addons/starwars_universe/lua/libs/advanceddraw.lua:
--    Advanced Draw:
--    - IMGUI Source Code: https://github.com/wyozi-gmod/imgui
--    - Draw Precache Arc
--    - Draw Line with thickness

local adraw = {}

adraw.skin = {
    background = Color(0, 0, 0, 0),
    backgroundHover = Color(0, 0, 0, 0),
    border = Color(255, 255, 255),
    borderHover = Color(255, 127, 0),
    borderPress = Color(255, 80, 0),
    foreground = Color(255, 255, 255),
    foregroundHover = Color(255, 127, 0),
    foregroundPress = Color(255, 80, 0),
}

local devCvar = GetConVar("developer")

function adraw.IsDeveloperMode()
    return not adraw.DisableDeveloperMode and devCvar:GetInt() > 0
end

local _devMode = false -- cached local variable updated once in a while

function adraw.Hook(name, id, callback)
    local hookUniqifier = debug.getinfo(4).short_src
    hook.Add(name, "adraw / " .. id .. " / " .. hookUniqifier, callback)
end

local local_player
local gState = {}

local function shouldAcceptInput()
    -- don't process input during non-main renderpass
    if render.GetRenderTarget() ~= nil then return false end
    -- don't process input if we're doing VGUI stuff (and not in context menu)
    if vgui.CursorVisible() and vgui.GetHoveredPanel() ~= g_ContextMenu then return false end

    return true
end

adraw.Hook("PreRender", "adraw / Input", function()
    -- calculate mouse state
    if shouldAcceptInput() then
        local useBind = input.LookupBinding("+use", true)
        local attackBind = input.LookupBinding("+attack", true)
        local USE = useBind and input.GetKeyCode(useBind)
        local ATTACK = attackBind and input.GetKeyCode(attackBind)
        local wasPressing = gState.pressing
        gState.pressing = (USE and input.IsButtonDown(USE)) or (ATTACK and input.IsButtonDown(ATTACK))
        gState.pressed = not wasPressing and gState.pressing
    end
end)

hook.Add("NotifyShouldTransmit", "adraw / ClearRenderBounds", function(ent, shouldTransmit)
    if not shouldTransmit then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    tb._adrawRBExpansion = nil
end)

local traceResultTable = {}

local traceQueryTable = {
    output = traceResultTable,
    filter = {}
}

local function isObstructed(eyePos, hitPos, ignoredEntity)
    local q = traceQueryTable
    q.start = eyePos
    q.endpos = hitPos
    q.filter[1] = local_player
    q.filter[2] = ignoredEntity
    local tr = util.TraceLine(q)

    if tr.Hit then
        return true, tr.Entity
    else
        return false
    end
end

function adraw.Start3D2D(pos, angles, scale, distanceHide, distanceFadeStart)
    local_player = local_player or LocalPlayer()

    if gState.shutdown == true then return end

    if gState.rendering == true then
        print("[AdvancedDraw] Starting a new adraw context when previous one is still rendering" .. "Shutting down rendering pipeline to prevent crashes..")
        gState.shutdown = true

        return false
    end

    _devMode = adraw.IsDeveloperMode()
    local eyePos = local_player:EyePos()
    local eyePosToPos = pos - eyePos

    -- OPTIMIZATION: Test that we are in front of the UI
    do
        local normal = angles:Up()
        local dot = eyePosToPos:Dot(normal)

        if _devMode then
            gState._devDot = dot
        end

        -- since normal is pointing away from surface towards viewer, dot<0 is visible
        if dot >= 0 then return false end
    end

    -- OPTIMIZATION: Distance based fade/hide
    if distanceHide then
        local distance = eyePosToPos:Length()
        if distance > distanceHide then return false end

        if _devMode then
            gState._devDist = distance
            gState._devHideDist = distanceHide
        end

        if distanceHide and distanceFadeStart and distance > distanceFadeStart then
            local blend = math.min(math.Remap(distance, distanceFadeStart, distanceHide, 1, 0), 1)
            render.SetBlend(blend)
            surface.SetAlphaMultiplier(blend)
        end
    end

    gState.rendering = true
    gState.pos = pos
    gState.angles = angles
    gState.scale = scale
    cam.Start3D2D(pos, angles, scale)

    -- calculate mousepos
    if not vgui.CursorVisible() or vgui.IsHoveringWorld() then
        local tr = local_player:GetEyeTrace()
        local eyepos = tr.StartPos
        local eyenormal

        if vgui.CursorVisible() and vgui.IsHoveringWorld() then
            eyenormal = gui.ScreenToVector(gui.MousePos())
        else
            eyenormal = tr.Normal
        end

        local planeNormal = angles:Up()
        local hitPos = util.IntersectRayWithPlane(eyepos, eyenormal, pos, planeNormal)

        if hitPos then
            local obstructed, obstructer = isObstructed(eyepos, hitPos, gState.entity)

            if obstructed then
                gState.mx = nil
                gState.my = nil

                if _devMode then
                    gState._devInputBlocker = "collision " .. obstructer:GetClass() .. "/" .. obstructer:EntIndex()
                end
            else
                local diff = pos - hitPos
                -- This cool code is from Willox's keypad CalculateCursorPos
                local x = diff:Dot(-angles:Forward()) / scale
                local y = diff:Dot(-angles:Right()) / scale
                gState.mx = x
                gState.my = y
            end
        else
            gState.mx = nil
            gState.my = nil

            if _devMode then
                gState._devInputBlocker = "not looking at plane"
            end
        end
    else
        gState.mx = nil
        gState.my = nil

        if _devMode then
            gState._devInputBlocker = "not hovering world"
        end
    end

    if _devMode then
        gState._renderStarted = SysTime()
    end

    return true
end

function adraw.Entity3D2D(ent, lpos, lang, scale, ...)
    gState.entity = ent
    local ret = adraw.Start3D2D(ent:LocalToWorld(lpos), ent:LocalToWorldAngles(lang), scale, ...)

    if not ret then
        gState.entity = nil
    end

    return ret
end

local function calculateRenderBounds(x, y, w, h)
    local pos = gState.pos
    local fwd, right = gState.angles:Forward(), gState.angles:Right()
    local scale = gState.scale
    local firstCorner, secondCorner = pos + fwd * x * scale + right * y * scale, pos + fwd * (x + w) * scale + right * (y + h) * scale
    local minrb, maxrb = Vector(math.huge, math.huge, math.huge), Vector(-math.huge, -math.huge, -math.huge)
    minrb.x = math.min(minrb.x, firstCorner.x, secondCorner.x)
    minrb.y = math.min(minrb.y, firstCorner.y, secondCorner.y)
    minrb.z = math.min(minrb.z, firstCorner.z, secondCorner.z)
    maxrb.x = math.max(maxrb.x, firstCorner.x, secondCorner.x)
    maxrb.y = math.max(maxrb.y, firstCorner.y, secondCorner.y)
    maxrb.z = math.max(maxrb.z, firstCorner.z, secondCorner.z)

    return minrb, maxrb
end

function adraw.ExpandRenderBoundsFromRect(x, y, w, h)
    local ent = gState.entity

    if IsValid(ent) then
        local tb = ent:GetTable()
        -- make sure we're not applying same expansion twice
        local expansion = tb._adrawRBExpansion

        if expansion then
            local ex, ey, ew, eh = unpack(expansion)
            if ex == x and ey == y and ew == w and eh == h then return end
        end

        local minrb, maxrb = calculateRenderBounds(x, y, w, h)
        ent:SetRenderBoundsWS(minrb, maxrb)

        if _devMode then
            print("[adraw] Updated renderbounds of ", ent, " to ", minrb, "x", maxrb)
        end

        tb._adrawRBExpansion = {x, y, w, h}
    else
        if _devMode then
            print("[adraw] Attempted to update renderbounds when entity is not valid!! ", debug.traceback())
        end
    end
end

local devOffset = Vector(0, 0, 30)

local devColours = {
    background = Color(0, 0, 0, 200),
    title = Color(78, 205, 196),
    mouseHovered = Color(0, 255, 0),
    mouseUnhovered = Color(255, 0, 0),
    pos = Color(255, 255, 255),
    distance = Color(200, 200, 200, 200),
    ang = Color(255, 255, 255),
    dot = Color(200, 200, 200, 200),
    angleToEye = Color(200, 200, 200, 200),
    renderTime = Color(255, 255, 255),
    renderBounds = Color(0, 0, 255)
}

local function developerText(str, x, y, clr)
    draw.SimpleText(str, "DefaultFixedDropShadow", x, y, clr, TEXT_ALIGN_CENTER, nil)
end

local function drawDeveloperInfo()
    local camAng = local_player:EyeAngles()
    camAng:RotateAroundAxis(camAng:Right(), 90)
    camAng:RotateAroundAxis(camAng:Up(), -90)
    cam.IgnoreZ(true)
    cam.Start3D2D(gState.pos + devOffset, camAng, 0.15)
        local bgCol = devColours["background"]
        surface.SetDrawColor(bgCol.r, bgCol.g, bgCol.b, bgCol.a)
        surface.DrawRect(-100, 0, 200, 140)
        local titleCol = devColours["title"]
        developerText("adraw developer", 0, 5, titleCol)
        surface.SetDrawColor(titleCol.r, titleCol.g, titleCol.b)
        surface.DrawLine(-50, 16, 50, 16)
        local mx, my = gState.mx, gState.my
    
        if mx and my then
            developerText(string.format("mouse: hovering %d x %d", mx, my), 0, 20, devColours["mouseHovered"])
        else
            developerText(string.format("mouse: %s", gState._devInputBlocker or ""), 0, 20, devColours["mouseUnhovered"])
        end
    
        local pos = gState.pos
        developerText(string.format("pos: %.2f %.2f %.2f", pos.x, pos.y, pos.z), 0, 40, devColours["pos"])
        developerText(string.format("distance %.2f / %.2f", gState._devDist or 0, gState._devHideDist or 0), 0, 53, devColours["distance"])
        local ang = gState.angles
        developerText(string.format("ang: %.2f %.2f %.2f", ang.p, ang.y, ang.r), 0, 75, devColours["ang"])
        developerText(string.format("dot %d", gState._devDot or 0), 0, 88, devColours["dot"])
        local angToEye = (pos - local_player:EyePos()):Angle()
        angToEye:RotateAroundAxis(ang:Up(), -90)
        angToEye:RotateAroundAxis(ang:Right(), 90)
        developerText(string.format("angle to eye (%d,%d,%d)", angToEye.p, angToEye.y, angToEye.r), 0, 100, devColours["angleToEye"])
        developerText(string.format("rendertime avg: %.2fms", (gState._devBenchAveraged or 0) * 1000), 0, 120, devColours["renderTime"])
    cam.End3D2D()
    cam.IgnoreZ(false)
    local ent = gState.entity

    if not IsValid(ent) then return end
    local tb = ent:GetTable()
    if not tb._adrawRBExpansion then return end
    local ex, ey, ew, eh = unpack(tb._adrawRBExpansion)
    local minrb, maxrb = calculateRenderBounds(ex, ey, ew, eh)
    render.DrawWireframeBox(vector_origin, angle_zero, minrb, maxrb, devColours["renderBounds"])
end

function adraw.End3D2D()
    if gState then
        if _devMode then
            local renderTook = SysTime() - gState._renderStarted
            gState._devBenchTests = (gState._devBenchTests or 0) + 1
            gState._devBenchTaken = (gState._devBenchTaken or 0) + renderTook

            if gState._devBenchTests == 100 then
                gState._devBenchAveraged = gState._devBenchTaken / 100
                gState._devBenchTests = 0
                gState._devBenchTaken = 0
            end
        end

        gState.rendering = false
        cam.End3D2D()
        render.SetBlend(1)
        surface.SetAlphaMultiplier(1)

        if _devMode then
            drawDeveloperInfo()
        end

        gState.entity = nil
    end
end

function adraw.CursorPos()
    local mx, my = gState.mx, gState.my

    return mx, my
end

function adraw.IsHovering(x, y, w, h)
    local mx, my = gState.mx, gState.my

    return mx and my and mx >= x and mx <= (x + w) and my >= y and my <= (y + h)
end

function adraw.IsPressing()
    return shouldAcceptInput() and gState.pressing
end

function adraw.IsPressed()
    return shouldAcceptInput() and gState.pressed
end

local _createdFonts = {}
local _adrawFontToGmodFont = {}
local EXCLAMATION_BYTE = string.byte("!")

function adraw.xFont(font, defaultSize)
    -- special font
    if string.byte(font, 1) == EXCLAMATION_BYTE then
        local existingGFont = _adrawFontToGmodFont[font]
        if existingGFont then return existingGFont end
        -- Font not cached; parse the font
        local name, size = font:match("!([^@]+)@(.+)")

        if size then
            size = tonumber(size)
        end

        if not size and defaultSize then
            name = font:match("^!([^@]+)$")
            size = defaultSize
        end

        local fontName = string.format("adraw_%s_%d", name, size)
        _adrawFontToGmodFont[font] = fontName

        if not _createdFonts[fontName] then
            surface.CreateFont(fontName, {
                font = name,
                size = size
            })

            _createdFonts[fontName] = true
        end

        return fontName
    end

    return font
end

function adraw.DrawBox(x,y,w,h,borderWidth, borderColor)
    if borderWidth > 0 then
        surface.SetDrawColor(borderColor)
        surface.DrawRect(x, y, w, borderWidth)
        surface.DrawRect(x, y + borderWidth, borderWidth, h - borderWidth * 2)
        surface.DrawRect(x, y + h - borderWidth, w, borderWidth)
        surface.DrawRect(x + w - borderWidth + 1, y, borderWidth, h)
    end
end

function adraw.xButton(x, y, w, h, borderWidth, borderClr, hoverClr, pressColor)
    local bw = borderWidth or 1
    local bgColor = adraw.IsHovering(x, y, w, h) and adraw.skin.backgroundHover or adraw.skin.background
    local borderColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.borderPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.borderHover)) or (borderClr or adraw.skin.border)
    surface.SetDrawColor(bgColor)
    surface.DrawRect(x, y, w, h)

    adraw.DrawBox(x,y,w,h,bw,borderColor)

    local isHovering = adraw.IsHovering(x, y, w, h)
    return shouldAcceptInput() and isHovering and gState.pressed, isHovering
end

function adraw.xOneColorButton(x, y, w, h, borderWidth, clr)
    local bw = borderWidth or 1
    surface.SetDrawColor(clr)
    surface.DrawRect(x, y, w, h)

    if bw > 0 then
        surface.SetDrawColor(clr)
        surface.DrawRect(x, y, w, bw)
        surface.DrawRect(x, y + bw, bw, h - bw * 2)
        surface.DrawRect(x, y + h - bw, w, bw)
        surface.DrawRect(x + w - bw + 1, y, bw, h)
    end

    return shouldAcceptInput() and adraw.IsHovering(x, y, w, h) and gState.pressed
end

function adraw.xCursor(x, y, w, h)
    local fgColor = adraw.IsPressing() and adraw.skin.foregroundPress or adraw.skin.foreground
    local mx, my = gState.mx, gState.my
    if not mx or not my then return end
    if x and w and (mx < x or mx > x + w) then return end
    if y and h and (my < y or my > y + h) then return end
    local cursorSize = math.ceil(0.3 / gState.scale)
    surface.SetDrawColor(fgColor)
    surface.DrawLine(mx - cursorSize, my, mx + cursorSize, my)
    surface.DrawLine(mx, my - cursorSize, mx, my + cursorSize)
end

function adraw.xTextButton(text, font, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    font = adraw.xFont(font, math.floor(h * 0.618))
    draw.SimpleText(text, font, x + w / 2, y + h / 2, fgColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

    return clicked
end

function adraw.xConButton(x, y, w, h, borderWidth, color, hoverClr, pressColor, conColor, condition)
    local fgColor
    local clicked
    if condition then
        fgColor = conColor
        clicked = adraw.xOneColorButton(x, y, w, h, borderWidth, conColor)
    else
        fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
        clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    end

    return clicked
end

function adraw.xSymbolButton(symbol, x, y, w, h, borderWidth, color, hoverClr, pressColor)
    local fgColor = ((adraw.IsPressing() and adraw.IsHovering(x, y, w, h)) and (pressColor or adraw.skin.foregroundPress)) or (adraw.IsHovering(x, y, w, h) and (hoverClr or adraw.skin.foregroundHover)) or (color or adraw.skin.foreground)
    local clicked = adraw.xButton(x, y, w, h, borderWidth, color, hoverClr, pressColor)
    surface.SetMaterial(symbol)
    surface.SetDrawColor(fgColor)
    surface.DrawTexturedRect(x, y, w, h)

    return clicked
end

function adraw.xDrawLine(x, y, x2, y2, sz)
    local midX = (x + x2) / 2
    local midY = (y + y2) / 2

    local dx = x2 - x
    local dy = y2 - y
    local ang = -math.deg(math.atan2(dy, dx))

    local len = math.sqrt((x2 - x) ^ 2 + (y2 - y) ^ 2)
    draw.NoTexture()
    surface.DrawTexturedRectRotated(midX, midY, len, sz, ang)
end

local cached = {}

function adraw.Arc(cx, cy, radius, thickness, startang, endang, roughness, color)
    local arc = tostring(cx) .. tostring(cy) .. tostring(radius) .. tostring(thickness) .. tostring(startang) .. tostring(endang) .. tostring(roughness)
    surface.SetDrawColor(color)
    draw.NoTexture()

    if (cached[arc] == nil) then
        cached[arc] = adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    end

    adraw.DrawArc(cached[arc])
end

function adraw.PrecacheArc(cx, cy, radius, thickness, startang, endang, roughness)
    local triarc = {}
    local roughness = math.max(roughness or 1, 1)
    local step = roughness
    local startang, endang = startang or 0, endang or 0

    if startang > endang then
        step = math.abs(step) * -1
    end

    local inner = {}
    local r = radius - thickness

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * r), cy + (-math.sin(rad) * r)

        table.insert(inner, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    local outer = {}

    for deg = startang, endang, step do
        local rad = math.rad(deg)
        local ox, oy = cx + (math.cos(rad) * radius), cy + (-math.sin(rad) * radius)

        table.insert(outer, {
            x = ox,
            y = oy,
            u = (ox - cx) / radius + .5,
            v = (oy - cy) / radius + .5,
        })
    end

    for tri = 1, #inner * 2 do
        local p1, p2, p3
        p1 = outer[math.floor(tri / 2) + 1]
        p3 = inner[math.floor((tri + 1) / 2) + 1]

        if tri % 2 == 0 then
            p2 = outer[math.floor((tri + 1) / 2)]
        else
            p2 = inner[math.floor((tri + 1) / 2)]
        end

        table.insert(triarc, {p1, p2, p3})
    end

    return triarc
end

function adraw.DrawArc(arc)
    for _, v in ipairs(arc) do
        surface.DrawPoly(v)
    end
end

function adraw.DrawTexturedRectRotatedPoint( x, y, w, h, rot, x0, y0 )
    local c = math.cos( math.rad( rot ) )
    local s = math.sin( math.rad( rot ) )

    local newx = y0 * s - x0 * c
    local newy = y0 * c + x0 * s

    surface.DrawTexturedRectRotated( x + newx, y + newy, w, h, rot )
end

local matBlurScreen = Material("pp/blurscreen")
function adraw.Derma_DrawPanelBlur(panel, color)
    color = color or Color(10,10,10,100)
    local x, y = panel:LocalToScreen( 0, 0 )

    -- Menu cannot do blur
    if ( not MENU_DLL ) then
        surface.SetMaterial( matBlurScreen )
        surface.SetDrawColor( 255, 255, 255, 255 )

        for i = 0.33, 1, 0.33 do
            matBlurScreen:SetFloat( "$blur", 5 * i )
            matBlurScreen:Recompute()
            if ( render ) then
                render.UpdateScreenEffectTexture()
            end
            surface.DrawTexturedRect( x * -1, y * -1, ScrW(), ScrH() )
        end
    end

    surface.SetDrawColor(color)
    surface.DrawRect( x * -1, y * -1, ScrW(), ScrH() )
end

return adraw

--addons/starwars_universe/lua/entities/swu_rotation_controller/cl_init.lua:
include("shared.lua")
local adraw = include("libs/advanceddraw.lua")

SWU = SWU or {}

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Initialize()
    self.Scale = 100
    self.ButtonWidth = 120
    self.ButtonHeight = 120
    self.ButtonMarginVertical = 20
    self.ButtonMarginHorizontal = 15

    self:SetupUsedKeys()
end

function ENT:Draw()
    self:DrawModel()
end

local mat = Material("the-coding-ducks/swu/ship-icon.png")

function ENT:DrawTranslucent()
    if not IsValid(SWU.Controller) then return end
    local curShipAngle = SWU.Controller:GetShipAngles().y
    if adraw.Entity3D2D(self, Vector(2.5, 3, 45.5), Angle(0, 90, 61), 1 / self.Scale) then
        local w, h = 12 * self.Scale, 10 * self.Scale

        local isLocked = SWU.Controller:GetTargetShipAccelerationLimit() == 0
        local color = isLocked and SWU.Colors.Default.error or Color(255, 255, 255, 255)

        draw.SimpleText(self:GetCurrentRotation(), SWU.Fonts.AurabeshRotation, w * 0.49, h * 0.7, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText(math.Round(curShipAngle % 360, 3), SWU.Fonts.AurabeshRotation, w * 0.1, h * 0.1, color, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        draw.SimpleText(math.Round(SWU.Controller:GetTargetShipAngles().y % 360, 3), SWU.Fonts.AurabeshRotation, w * 0.9, h * 0.1, color, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

        surface.SetMaterial(mat)
        surface.SetDrawColor(color)
        adraw.DrawTexturedRectRotatedPoint(w * 0.5 - 10, h * 0.5, 200, 200, curShipAngle * -1 - 90, 0,0)

        adraw.End3D2D()
    end

    if adraw.Entity3D2D(self, Vector(11.5, 8.15, 33.3), Angle(0, 90, 15), 1 / self.Scale) then
        local w, h = self.ButtonWidth, self.ButtonHeight
        local x, y = 0, 0

        for i = 0, 2 do
            for j = 1, 3 do
                local number = math.abs(i - 2) * 3 + j
                if adraw.xTextButton(number, SWU.Fonts.AurabeshRotation, x, y, w, h, 4, SWU.Colors.Default.passive, SWU.Colors.Default.primary, SWU.Colors.Default.accent) then
                    self:StartNetAction()
                    net.WriteUInt(number, 4)
                    net.SendToServer()
                end
                x = x + w + self.ButtonMarginHorizontal
            end
            x = 0
            y = y + h + self.ButtonMarginVertical
        end

        if adraw.xTextButton("+/-", SWU.Fonts.AurabeshRotation, w * .01, 3 * 140, self.ButtonWidth, self.ButtonHeight, 4, SWU.Colors.Default.passive, SWU.Colors.Default.primary, SWU.Colors.Default.accent) then
            self:StartNetAction()
            net.WriteUInt(12, 4)
            net.SendToServer()
        end
        if adraw.xTextButton(0, SWU.Fonts.AurabeshRotation, w + self.ButtonMarginHorizontal, 3 * 140, self.ButtonWidth, self.ButtonHeight, 4, SWU.Colors.Default.passive, SWU.Colors.Default.primary, SWU.Colors.Default.accent) then
            self:StartNetAction()
            net.WriteUInt(0, 4)
            net.SendToServer()
        end
        if adraw.xTextButton(".", SWU.Fonts.AurabeshRotation, w + self.ButtonMarginHorizontal * 10, 3 * 140, self.ButtonWidth, self.ButtonHeight, 4, SWU.Colors.Default.passive, SWU.Colors.Default.primary, SWU.Colors.Default.accent) then
            self:StartNetAction()
            net.WriteUInt(13, 4)
            net.SendToServer()
        end
        if adraw.xTextButton("DEL", SWU.Fonts.PlainRotation, w * .01, 4 * 140, self.ButtonWidth * 1.5, self.ButtonHeight, 4, SWU.Colors.Default.passive, SWU.Colors.Default.primary, SWU.Colors.Default.accent) then
            self:StartNetAction()
            net.WriteUInt(14, 4)
            net.SendToServer()
        end

        local isLocked = SWU.Controller:GetTargetShipAccelerationLimit() == 0
        local color = isLocked and SWU.Colors.Default.error or SWU.Colors.Default.passive
        local hover = isLocked and SWU.Colors.Default.dark or SWU.Colors.Default.primary

        if adraw.xTextButton("Lock In", SWU.Fonts.PlainRotation, w + self.ButtonMarginHorizontal * 6, 4 * 140, self.ButtonWidth * 1.5, self.ButtonHeight, 4, color, hover, SWU.Colors.Default.accent) then
            self:StartNetAction()
            net.WriteUInt(15, 4)
            net.SendToServer()
        end
        adraw.End3D2D()
    end
end

--addons/starwars_universe/lua/entities/swu_speed_controller/shared.lua:
ENT.Type        = "anim"
ENT.PrintName   = "[SWU] Speed Controller"
ENT.Author      = "The Coding Ducks"
ENT.Information = ""
ENT.Category    = "[SWU] Universe"

ENT.Spawnable	= false

ENT.SWU_Interactable = true

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "MaxPower")
end

function ENT:SharedInitialize()
    self.StartLever = Vector(18.5, -2.8, 30)
    self.StopLever = Vector(12, -3, 32)
end

function ENT:SetupUsedKeys()
    self.SWU_UsedKeys = {
        [KEY_UP] = SWU.Util:InteractableServer(self.ChangeSpeed, true),
        [KEY_DOWN] = SWU.Util:InteractableServer(self.ChangeSpeed),
    }
end

--addons/egm_tfa_grenades/lua/entities/tfa_csgo_fire_2/shared.lua:
AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false
ENT.AdminSpawnable = false


function ENT:Draw()
	
end

function ENT:Initialize()
	self:SetNWBool("extinguished",false)
	if SERVER then
		self:SetModel( "models/weapons/tfa_starwars/w_incendiary.mdl" )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_NONE )
		self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
		self:DrawShadow( false )
	end
	ParticleEffect( "molotov_explosion", self:GetPos(), self:GetAngles() )
	self:EmitSound( "TFA_CSGO_Inferno.Loop" )
end

function ENT:Think()
	if self:GetNWBool("extinguished",true) then
		ParticleEffect( "extinguish_fire", self:GetPos(), self:GetAngles() )
		self:Remove()
	end
end

function ENT:OnRemove()
	self:EmitSound( "TFA_CSGO_Inferno.FadeOut" )
	self:StopSound( "TFA_CSGO_Inferno.Loop" )
end
--addons/tfa_base/lua/entities/tfa_exp_contact.lua:
AddCSLuaFile()

ENT.Base = "tfa_exp_base"
ENT.PrintName = "Contact Explosive"

function ENT:PhysicsCollide(data, phys)
	if data.Speed > 60 then
		self.killtime = -1
	end
end
--addons/tfa_base/lua/entities/tfa_exp_timed.lua:
AddCSLuaFile()

ENT.Base = "tfa_exp_base"
ENT.PrintName = "Timed Explosive"

ENT.BounceSound = Sound("HEGrenade.Bounce")

function ENT:PhysicsCollide(data, phys)
	if data.Speed > 60 then
		if self.BounceSound then
			self:EmitSoundNet(self.BounceSound)
		end

		local impulse = (data.OurOldVelocity - 2 * data.OurOldVelocity:Dot(data.HitNormal) * data.HitNormal) * 0.25
		phys:ApplyForceCenter(impulse)
	end
end
--addons/emplacements/lua/entities/turret_rail_deployable/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
	self.MuzzleAttachment=self:LookupAttachment("muzzle")
	self.shootPos=self:GetDTEntity(1)
	
end

function ENT:Draw()
	
	self:DrawModel()
	
	local p = self:GetPos()

	local ang = self:GetAngles()
	ang:RotateAroundAxis( ang:Forward(), 90 )
	ang:RotateAroundAxis( ang:Up(), 90 )
	ang.y = LocalPlayer():EyeAngles().y - 90
	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 250 * 250 then
		cam.Start3D2D( p + Vector( 0, 0, -10 ), Angle( 0, ang.y, 90 ), .15 )
			draw.RoundedBox( 5, - 180, - 400, 350, 105, Color( 0, 0, 0, 230 ) )
			draw.RoundedBox( 5, - 180, - 350 + 2, math.Clamp( self:Health() / self:GetMaxHealth() * 350, 0, 350 ), 50 - 2, Color( 150, 0, 0, 230 ) )
			--draw.DrawText( self:Health(), "BlahBlah2", 5, - 740, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
			draw.DrawText( "Anti Vehicle Cannon", "header", -1, - 395, Color( 52, 235, 146, 255 ), TEXT_ALIGN_CENTER )

		cam.End3D2D()
	end

end
--lua/entities/vfire_ball/shared.lua:
--[[-------------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

vFire by Vioxtar

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
---------------------------------------------------------------------------]]

AddCSLuaFile()

DEFINE_BASECLASS( "base_anim" )

function ENT:SetupDataTables()
	 -- 1 is Tiny, 7 is Inferno
	self:NetworkVar("Int", 0, "FireState")
end

--[[-------------------------------------------------------------------------
In charge of updating particle systems
---------------------------------------------------------------------------]]
if CLIENT then
	function ENT:RedoParticles(state)

		if !IsValid(self) then return end

		-- Store the state that's actually visible for consistent animations
		self.visState = state

		if self.flames then
			if self.flames:IsValid() then 
				self.flames:StopEmission()
			end
		end

		local size = vFireStateToSize(state)

		self.visLOD = false
		local LODStr = ""
		if self.LOD then
			LODStr = "_LOD"
			self.visLOD = true
		end

		self.flames = CreateParticleSystem(
			self,
			"vFire_Flames_"..size..LODStr,
			1,
			0,
			Vector(0, 0, 0)
		)
	end

	
	local pullForceControlPointIndex = 2
	-- The stateMul table defines how far to set the pull control point for each state
	-- The bigger the distance, the less effect the control point has
	local stateMul = {30, 45, 65, 115, 245, 345, 400}
	-- The minimum flame pull strength, used to avoid dividing by zero
	local minStrength = 1 / 1000000000
	-- Pulls the flames towards a direction, with an optional strength ranging between [0, 1]
	function ENT:FlameSetDirection(dir, strength)
		if IsValid(self.flames) then
			dir:Normalize()
			dir = dir * stateMul[self:GetFireState()]
			local pos
			if strength then
				pos = self:GetPos() + dir / math.Clamp(strength, minStrength, 1)
			else
				pos = self:GetPos() + dir
			end
			self.flames:SetControlPoint(pullForceControlPointIndex, pos)
		end
	end
end

if SERVER then
	--[[-------------------------------------------------------------------------
	Change life without exceeding max life
	---------------------------------------------------------------------------]]
	function ENT:ChangeLife(newLife)
		self.life = math.min(newLife, vFireMaxLife)
		self:SetFireState(vFireLifeToState(self.life))

		if self.life <= 0 then
			self:Remove()
		end
	end

	function ENT:Ignore(ent)
		self.ignore[ent] = true
	end
	function ENT:StopIgnoring(ent)
		if self.ignore[ent] then
			self.ignore[ent] = nil
		end
	end

	function ENT:RandomStickSkip()
		return math.Rand(0, 1) >= self.stickProbability
	end

	function ENT:TimedRemoval(time)

		if !time then time = math.Rand(0.3, 0.8) end

		-- Timed removal
		timer.Simple(time, function()
			if IsValid(self) then self:Remove() end
		end)
	end

	function ENT:StickFire(parent, pos, normal)

		local feedFactor = math.Rand(0.5, 1)

		timer.Simple(0, function() -- Time it to avoid changing any sort of collision rules on a collision hook
			if !IsValid(parent) and !parent:IsWorld() then return end
			if !self.feedCarry then return end
			local fire = CreateVFire(parent, pos, normal, self.feedCarry * feedFactor, self)

			if IsValid(fire) then
				fire:ChangeLife(self.life * (1 - feedFactor))
			end
		end)

		-- Dampen the ball and add a random velocity
		if IsValid(self) then
			local phys = self:GetPhysicsObject()
			phys:SetDamping(math.Rand(2, 8), 1)
			phys:AddVelocity(VectorRand() * phys:GetEnergy() * 0.002)
		end

		self:TimedRemoval()
	end

	--[[-------------------------------------------------------------------------
	Attempt to stick to surfaces via a trace
	---------------------------------------------------------------------------]]
	function ENT:AttemptFireStick()
		local vel = self.oldVel or self:GetVelocity()
		local tr = util.QuickTrace(self:GetPos(), vel, self)
		if tr.Hit and !tr.HitSky then

			local ent = tr.Entity
			if vFireIsVFireEnt(ent) then return false end

			self:StickFire(ent, tr.HitPos, tr.HitNormal)

			return true
		end

		return false
	end

	--[[-------------------------------------------------------------------------
	Call the attempt fire stick function on touching or collisions
	---------------------------------------------------------------------------]]
	function ENT:StartTouch(ent)
		if self.stuck then return end

		-- Every third fire ball should bounce off the surface
		if self:RandomStickSkip() then return end

		if ent then
			if self.ignore[ent] or vFireIsVFireEnt(ent) then return end
		end

		-- We can completely skip the attempt itself if we're burning a character
		if vFireIsCharacter(ent) then
			self:StickFire(ent, ent:GetPos(), VectorRand())
			self.stuck = true
		else
			self.stuck = self:AttemptFireStick()
		end

		if self.stuck then
			hook.Run("vFireBallStuckFire", self, ent)
		end
	end

	function ENT:PhysicsCollide(colData, collider)
		if self.stuck then return end

		-- Every third fire ball should bounce off the surface
		if self:RandomStickSkip() then return end

		local ent = colData.HitEntity
		
		if ent then
			if self.ignore[ent] or vFireIsVFireEnt(ent) then return end
		end

		-- We can completely skip the attempt itself if we're burning a character
		if vFireIsCharacter(ent) then
			self:StickFire(ent, ent:GetPos(), VectorRand())
			self.stuck = true
		else
			self.stuck = self:AttemptFireStick()
		end
		
		if self.stuck then
			hook.Run("vFireBallStuckFire", self, ent)
		end
	end

	--[[-------------------------------------------------------------------------
	Update our old velocity to be used for correct fire stick attempts
	---------------------------------------------------------------------------]]
	function ENT:PhysicsUpdate()

		if self:WaterLevel() > 0 then
			timer.Simple(0, function()
				if IsValid(self) then
					self:Remove()
				end
			end)
		end

		if self.stuck then return end
		self.oldVel = self:GetVelocity()
	end

	--[[-------------------------------------------------------------------------
	Set the sticking probability
	---------------------------------------------------------------------------]]
	function ENT:SetStickProbability(prob)
		self.stickProbability = prob
	end
end


--[[-------------------------------------------------------------------------
Set starting parameters of a fire entity
---------------------------------------------------------------------------]]
local radius = 0.01
function ENT:Initialize()

	-- Make sure it's not directly seen
	self:DrawShadow(false)

	-- Make sure it's not directly interactable
	self:SetCollisionGroup(COLLISION_GROUP_DEBRIS_TRIGGER)


	if SERVER then
		-- The ignore table
		self.ignore = {}
		self:Ignore(self:GetOwner())

		-- What is the probability of sticking fire? Default is skip every 3rd impact
		self.stickProbability = 2/3

		-- We are essentially a small sphere
		self:PhysicsInitSphere(radius, "default_silent")

		-- Dampen ourselves
		local phys = self:GetPhysicsObject()
		phys:SetDamping(0.85, 0)
		phys:SetMass(1)
		phys:Wake()

		-- Use triggers to access the StartTouch hook
		self:SetTrigger(true)

		self:SetCollisionBounds(Vector(-radius, -radius, -radius), Vector(radius, radius, radius))
		self:UseTriggerBounds(true, radius)

		-- Our conditions
		self.life = 0
		self.stuck = false
		self.feedCarry = 0
	end

	if CLIENT then
		local state = 1
		self.lastState = 1
		self.visState = 1

		self.LOD = false
		self.visLOD = false
	
		-- Start working
		self:RedoParticles(1)
		self:Think()
	end
end


--[[-------------------------------------------------------------------------
Remove ourselves from needed tables
---------------------------------------------------------------------------]]
function ENT:OnRemove()
	-- This may not be necessary, but just in case: destroy all particle systems
	if CLIENT then
		if self.flames then
			if self.flames:IsValid() then self.flames:StopEmission() end
		end
		if self.base then
			if self.base:IsValid() then self.base:StopEmission() end
		end
	end
end

--[[-------------------------------------------------------------------------
Handles life, spreads, feeds, decal placement, networking and calling new particle system updates
---------------------------------------------------------------------------]]
local serverTickRate = 0.2
local clientTickRate = 0.3
function ENT:Think()

	if CLIENT then

		self.LOD = vFireGetLOD(self)

		local shouldRedoParticles = false

		-- Handle state changes
		local lastState = self.lastState
		local state = self:GetFireState()
		self.lastState = state
		if state != lastState then -- We changed states
	
			shouldRedoParticles = true
			
			-- Make sure we'll always draw ourselves
			local renderSize = state * 20
			self:SetRenderBounds(Vector(0, 0, 0), Vector(0, 0, 0), Vector(renderSize, renderSize, renderSize))

			self:FlameSetDirection(self:GetVelocity(), 1)

		end

		local LODActive = false
		if self.LOD then LODActive = true end

		if LODActive != self.visLOD then
			shouldRedoParticles = true
		end

		if shouldRedoParticles and self.RedoParticles then
			self:RedoParticles(state)
		end


	end

	if SERVER then

		-- Decrease life
		self:ChangeLife(self.life - 1)


	end

	if SERVER then self:NextThink(CurTime() + serverTickRate) end
	if CLIENT then self:SetNextClientThink(CurTime() + clientTickRate) end

	return true -- We wish to override ticking rate
end


if CLIENT then
	function ENT:Draw()
		-- Do nothing
	end
end
--addons/wos-alcs-custom/lua/entities/wos_item_base/cl_init.lua:
include('shared.lua')
ENT.RenderGroup 		= RENDERGROUP_OPAQUE

function ENT:Draw()
	self.Entity:DrawModel()
end

function ENT:GetRarityColor()
	local col = self:GetRColor()
	return Color( col.x, col.y, col.z )
end
--addons/wos-alcs-custom/lua/entities/wos_kyber_slam/cl_init.lua:
include('shared.lua')


function ENT:Initialize()
	
end

function ENT:CreateBoom()

   
end

function ENT:OnRemove()

end

function ENT:Think()

end

function ENT:Draw()
	
end


--addons/wos-alcs-custom/lua/entities/wos_legacy_saberstation/shared.lua:
ENT.Type 		= "anim"
ENT.PrintName	= "Legacy Lightsaber Bench"
ENT.Author		= "King David"
ENT.Contact		= ""
ENT.Category = "wiltOS Technologies"
ENT.Spawnable			= false
ENT.AdminSpawnable		= true

function ENT:Think()
	if not self.BuildingSound then
		self.BuildingSound = CreateSound( self.Entity, "ambient/machines/combine_shield_loop3.wav" )
		self.BuildingSound:Play()
	end
end

function ENT:OnRemove()
	self.BuildingSound:Stop()
end
--addons/wos-alcs-custom/lua/entities/wos_lightning_coil/cl_init.lua:
include('shared.lua')

local model_orb = Model("models/Combine_Helicopter/helicopter_bomb01.mdl")
local mat_orb = "models/alyx/emptool_glow"
local r = 28 / 4

ENT.Radius = 100
ENT.LifeSpan = 0

function ENT:Initialize()
	
	self:CreateBoom()		
end

function ENT:CreateBoom()

   if IsValid( self.Orb ) then self.Orb:Remove() end
   self.StartLife = CurTime()
   self.LifeSpan = CurTime() + 0.5
   self.Orb = ClientsideModel(model_orb, RENDERGROUP_OPAQUE )
   self.Orb:SetRenderMode( RENDERMODE_TRANSALPHA )
   self.Orb:SetPos( self.Owner:GetPos() )
   self.Orb:SetColor( Color( 255, 255, 255, 100 ) )
   self.Orb:SetModelScale( 0, 0 )
   self.Orb:SetMaterial( "models/effects/splodearc_sheet" ) 
   self:EmitSound( "weapons/physcannon/energy_sing_explosion2.wav", 100, math.random( 65, 135 ) )
end

function ENT:OnRemove()

	if IsValid( self.Orb ) then
		self.Orb:Remove()
	end

end

function ENT:Think()
	if IsValid( self.Orb ) then
	
       local ratio = ( CurTime() - self.StartLife ) / 0.01
	   self.Orb:SetModelScale( ratio, 0 ) 
	   self.Orb:SetMaterial( mat_orb )
	   self.Orb:SetPos( self.Owner:GetPos() )	   
	   if self.LifeSpan <= CurTime() then
			self:CreateBoom()
	   end
	end
	
end

function ENT:Draw()
	
end


--addons/wos-passiveevent/lua/entities/wos_pes_capture_point/cl_init.lua:
include("shared.lua")

surface.CreateFont( "wOS.PES.CapturePoint", {
	font = "Arial",
	extended = false,
	size = 35,
	weight = 1000,
    shadow = true,
    outline = false
} )

surface.CreateFont( "wOS.PES.3DFont", {
	font = "Arial",
	extended = false,
	size = 100,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

function ENT:Initialize()
    self:SharedInit()
    timer.Simple(0, function()
        local mins = self:OBBMins()
        local maxs = self:OBBMaxs()
        maxs.z = maxs.z + 30
        self:SetRenderBounds(mins, maxs)
    end)
end

function ENT:Draw()
    self:DrawModel()

    local p = self:GetPos()

    p.z = p.z + self:OBBMaxs().z

    local radS = self:GetCaptureRange()*self:GetCaptureRange()

    if LocalPlayer():GetPos():DistToSqr(p) < radS then

        local ang = self:GetAngles()
        ang:RotateAroundAxis( ang:Forward(), 90 )
        ang:RotateAroundAxis( ang:Up(), 90 )
        ang.y = LocalPlayer():EyeAngles().y - 90

        if !self.currentValue then self.currentValue = self:GetCaptureValue() end

        self.currentValue = math.Approach( self.currentValue, self:GetCaptureValue(), FrameTime() * 20 )

        local maxValue = self:GetMaxCaptureValue()

        local size = 400
        local height = 50

        cam.Start3D2D( p + Vector( 0, 0, 30 ), Angle( 0, ang.y, 90 ), .15 )
            draw.RoundedBox( 5, -size/2, 0, size, height, Color( 0, 0, 0, 230 ) )
            draw.RoundedBox( 5, - size/2 + 2, 2, math.Clamp( self.currentValue/maxValue , 0, 1 ) * (size-4), height -4, Color( 0, 0, 100, 230 ) )

            if self:GetCaptureValue() == self:GetMaxCaptureValue() then
                draw.DrawText( "Captured", "wOS.PES.CapturePoint", 0, 2, Color( 255, 255, 255, 255 ), 1, 1 )
            else
                draw.DrawText( "Capturing...", "wOS.PES.CapturePoint", 0, 2, Color( 255, 255, 255, 255 ), 1, 1 )
            end
        cam.End3D2D()
    end
end

--lua/entities/yoda_council_chair.lua:
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Base = "base_anim"
ENT.Type = "vehicle"

ENT.PrintName = "Yoda Council Chair"
ENT.Author = "Syphadias, Liam0102s Help"
ENT.Category = "Star Wars Vehicles: Chairs"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false;
ENT.AdminSpawnable = false;
ENT.EntModel = "models/starwars/syphadias/jedi_knight_jedi_academy/council_chairs/yoda_council_chair.mdl";

list.Set("SWVehicles", ENT.PrintName, ENT);
if SERVER then



AddCSLuaFile();
function ENT:SpawnFunction(pl, tr)
	local e = ents.Create("yoda_council_chair");
	e:SetPos(tr.HitPos + Vector(0,0,20));
	e:SetAngles(Angle(0,pl:GetAimVector():Angle().Yaw,0));
	e:Spawn();
	e:Activate();
	return e;
end

function ENT:Initialize()

	self:SetModel(self.EntModel);
	self:PhysicsInit(SOLID_VPHYSICS);
	self:SetMoveType(MOVETYPE_VPHYSICS);
	self:SetSolid(SOLID_VPHYSICS);
	self:StartMotionController();
	self:SetUseType(SIMPLE_USE);
	self:SetRenderMode(RENDERMODE_TRANSALPHA);

	self:SecretChair(self:GetPos()+self:GetUp()*10+self:GetForward()*4,self:GetAngles()+Angle(0,-90,15)); // Will most likely require tinkering for position
	
	local phys = self:GetPhysicsObject()

	if(phys:IsValid()) then
		phys:Wake()
		phys:SetMass(100000)
	end
end

function ENT:SecretChair(pos,ang)

	local e = ents.Create("prop_vehicle_prisoner_pod");
	e:SetPos(pos);
	e:SetAngles(ang);
	e:SetParent(self);
	e:SetModel("models/nova/airboat_seat.mdl");
	e:SetRenderMode(RENDERMODE_TRANSALPHA);
	e:SetColor(Color(255,255,255,0));
	e:Spawn();
	e:Activate();
	e.IsSyphSeat = true;
	self.Chair = e;
end

hook.Add("PlayerEnteredVehicle","SyphSeatEnter", function(p,v)
	if(IsValid(p) and IsValid(v)) then
		if(v.IsSyphSeat) then
			p:SetNWEntity("SyphSeat",v)
		end
	end
end)

hook.Add("PlayerLeaveVehicle","SyphSeatExit", function(p,v)
	if(IsValid(p) and IsValid(v)) then
		if(v.IsSyphSeat) then
			p:SetNWEntity("SyphSeat",NULL)
		end
		p:SetPos(v:GetPos()+v:GetUp()*10+v:GetForward()*50)
		p:SetEyeAngles(Angle(0,v:GetAngles().y+90,0))
	end
end)

function ENT:Use(p)
	
	if(!IsValid(self.Chair)) then return end;
	p:EnterVehicle(self.Chair);

end

end

if CLIENT then
	
	function ENT:Draw() self:DrawModel() end
	
	local View = {}
	hook.Add("CalcView", "SyphSeatView", function()

		local p = LocalPlayer();
		local Seat = p:GetNWEntity("SyphSeat",NULL);

		if(IsValid(Seat)) then
			if(Seat:GetThirdPersonMode()) then
				local pos = Seat:GetPos()+LocalPlayer():GetAimVector():GetNormal()*-100+Seat:GetUp()*175;
				local face = ((Seat:GetPos() + Vector(0,0,100))- pos):Angle();
					View.origin = pos;
					View.angles = face;
				return View;
			end
		end
	end)
	
	hook.Add( "ShouldDrawLocalPlayer", "SyphSeatPlayerDraw", function( p )
		local Seat = p:GetNWEntity("SyphSeat",NULL);
		if(IsValid(Seat)) then
			if(Seat:GetThirdPersonMode()) then
				return true;
			end
		end
	end);
end
--addons/wos-alcs-blades-anzati/lua/effects/anzati_swtor3/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "wos/lightsabers/effects/anzati/swtor3", pos2 )		
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/wos-alcs-blades-anzati/lua/effects/anzati_swtor5/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "wos/lightsabers/effects/anzati/swtor5", pos2 )		
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/wos-alcs-blades-anzati/lua/effects/anzati_wosweek/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "wos/lightsabers/effects/anzati/wiltosweek2019", pos2 )		
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/bkeypads_cracker/lua/effects/bkeypads_panel_attach.lua:
local SOUND = {}
SOUND.STEAM_RELEASE = Sound("ambient/machines/steam_release_2.wav")
SOUND.CLICK = Sound("weapons/shotgun/shotgun_empty.wav")
SOUND.YES = Sound("npc/roller/remote_yes.wav")

function EFFECT:Init(data)
	local target = data:GetEntity()
	local origin = target:WorldSpaceCenter()

	target:EmitSound(SOUND.STEAM_RELEASE, 60, 135, 0.5)
	target:EmitSound(SOUND.CLICK, 60, 125)
	target:EmitSound(SOUND.YES, 60)

	if EyePos():DistToSqr(origin) >= 50000 then return end

	local emitter = ParticleEmitter(origin)
	local mins, maxs = target:GetModelBounds()
	for theta = 0, 360 do
		local pi2 = math.pi * 2
		while (theta < -math.pi) do
			theta = theta + pi2
		end
		while (theta > math.pi) do
			theta = theta - pi2
		end

		local w = (maxs.y - mins.y) * 0.94
		local h = (maxs.z - mins.z) * 0.92

		local rectAtan = math.atan2(h, w)
		local tanTheta = math.tan(theta)

		local region
		if theta > -rectAtan and theta <= rectAtan then                             region = 1
		elseif theta > rectAtan and theta <= (math.pi - rectAtan) then              region = 2
		elseif theta > (math.pi - rectAtan) or theta <= -(math.pi - rectAtan) then  region = 3
		else                                                                        region = 4
		end

		local edgePoint = Vector(origin)
		local yFactor = (region == 1 or region == 2) and -1 or 1
		local xFactor = (region == 3 or region == 4) and -1 or 1

		if region == 1 or region == 3 then
			edgePoint = edgePoint - (target:GetRight() * (xFactor * (w / 2)))
			edgePoint = edgePoint - (target:GetUp() * (yFactor * (w / 2) * tanTheta))
		else
			edgePoint = edgePoint - (target:GetRight() * (xFactor * (h / (2 * tanTheta))))
			edgePoint = edgePoint - (target:GetUp() * (yFactor * (h /  2)))
		end

		local particle = emitter:Add("particle/particle_smokegrenade", edgePoint)
		if particle then
			particle:SetVelocity((edgePoint - origin) * math.Rand(0.25, 0.4))
			particle:SetLifeTime(0)
			particle:SetDieTime(2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(0)
			particle:SetEndSize(.75)
			particle:SetAirResistance(math.Rand(100, 300))
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render() end
--addons/mortar/lua/effects/effect_smokenade_smoke/init.lua:
function EFFECT:Init(data)

	local emitter = ParticleEmitter(data:GetOrigin())

		for i = 0, 128 do

			if !emitter then return end

			local Pos = (data:GetOrigin() + Vector( math.Rand(-32,32), math.Rand(-32,32), math.Rand(-32,32) ) + Vector(0,0,64))

			local particle = emitter:Add( "particle/particle_smokegrenade", Pos )
			if (particle) then

				particle:SetVelocity(VectorRand() * math.Rand(1420,5200))

				particle:SetLifeTime(0)
				particle:SetDieTime(math.Rand(16, 18))

				local rand = math.random(242,255)
				if math.random(1,10) == 10 then rand = math.random(210,232) end
				particle:SetColor(rand,rand,rand)

				particle:SetStartAlpha(math.Rand(242,255))
				particle:SetEndAlpha(0)

				local Size = math.Rand(132,162)
				particle:SetStartSize(Size)
				particle:SetEndSize(Size)

				particle:SetRoll(math.Rand(-360, 360))
				particle:SetRollDelta(math.Rand(-0.21, 0.21))

				particle:SetAirResistance(math.Rand(520,620))

				particle:SetGravity( Vector(0, 0, math.Rand(-42, -82)) )

				particle:SetCollide(true)
				particle:SetBounce(0.42)

				particle:SetLighting(1)

			end

		end

	emitter:Finish()

end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--lua/effects/effect_sw_laser_green/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6500
EFFECT.Length				= 64
//EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72

local MaterialMain			= Material( "effects/sw_laser_green_main" )
local MaterialFront			= Material( "effects/sw_laser_green_front" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 204
			dlight.b = 0
			dlight.brightness = 3
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--lua/effects/effect_sw_laser_white_old/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6500
EFFECT.Length				= 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72

local MaterialMain			= Material( "effects/sw_laser_white_main" )
local MaterialFront			= Material( "effects/sw_laser_white_front" )

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--lua/effects/effect_sw_laser_yellow/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 6500
EFFECT.Length				= 64
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72

local MaterialMain			= Material( "effects/sw_laser_yellow_main" )
local MaterialFront			= Material( "effects/sw_laser_yellow_front" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 255
			dlight.b = 0
			dlight.brightness = 3
			dlight.Decay = 1000
			dlight.Size = 300
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 8, 8, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end
--addons/wos-alcs-custom/lua/effects/force_lightning_hit.lua:
--DO NOT EDIT OR REUPLOAD THIS FILE

local DecalMat = Material( util.DecalMaterial( "FadingScorch" ) )
function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.mat = Material( "sprites/light_glow02_add" )

	self.LifeTime = 1
	self.DieTime = CurTime() + self.LifeTime
	self.DieTimeGlow = CurTime() + 0.2

	local Col = self.Col
	local Pos = self.Pos
	local Dir = data:GetNormal()

	local emitter = ParticleEmitter( Pos, false )

	local trace = util.TraceLine( {
		start = Pos - Dir * 5,
		endpos = Pos + Dir * 5,
	} )

	if trace.Hit and not trace.HitNonWorld then
		util.DecalEx( DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), math.Rand(0.4,0.8), math.Rand(0.4,0.8) )
	end

	for i = 0, 3 do
		local particle = emitter:Add( "sprites/rico1", Pos )

		local vel = VectorRand() * 100 + Dir * math.Rand(120,140)

		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(1,2) )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 1 )
			particle:SetEndSize( 0.5 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
			particle:SetAirResistance( 0 )
			particle:SetColor( 255, 255, 255 )
			particle:SetGravity( Vector(0,0,-600) )
		end
	end

	self.Emitter = emitter
end

function EFFECT:Think()
	if self.DieTime < CurTime() then 
		if self.Emitter then
			self.Emitter:Finish()
		end

		if self.snd then
			self.snd:Stop()
		end

		return false
	end

	return true
end

local Mat = Material("particle/particle_glow_05_addnofog")
function EFFECT:Render()
	local Scale = (self.DieTimeGlow - CurTime()) / 0.2
	if Scale > 0 then
		render.SetMaterial( self.mat )
		render.DrawSprite( self.Pos, 24 * Scale, 24 * Scale, Color( 150, 150, 255, 255) )
	end
end

--lua/effects/lfs_fb_ballturret_left_projector.lua:
EFFECT.Mat = Material("effects/lfs_base/ballturret_projectorbeam")
EFFECT.HitMat = Material("sprites/light_glow02_add")

function EFFECT:Init( data )
	self.Entity = data:GetEntity()
	
	if IsValid(self.Entity) then
		self.ID = self.Entity:LookupAttachment("L_Ball_Attachement")
		
		if self.ID then
			local Muzzle = self.Entity:GetAttachment(self.ID)

			self:SetRenderBoundsWS(self.Entity:GetPos(), Muzzle.Ang:Up() * 50000)
		end
	end
end

function EFFECT:Think()
	if not IsValid(self.Entity) or not self.ID or not self.Entity:GetBTLFire() then
		return false
	end
	
	return true
end

function EFFECT:Render()
	if not self.ID or not IsValid(self.Entity) then return end
	
	local Muzzle = self.Entity:GetAttachment( self.ID )
	
	local Dir = Muzzle.Ang:Forward()
	local Up = Muzzle.Ang:Up()
	local StartPos = Muzzle.Pos + Up * 18 + Dir * 60
	local Trace = util.TraceLine( { start = StartPos, endpos = StartPos + Dir * 50000, filter = self } )
	local EndPos = Trace.HitPos
	
	self:SetRenderBoundsWS(StartPos, EndPos)
	
	render.SetMaterial(self.Mat)
	render.DrawBeam(StartPos, EndPos, 14 + math.random(0,4), 1, 0, Color(0, 255, 0, 255))
	render.DrawBeam(StartPos, EndPos, 3 + math.random(0,4), 1, 0, Color(255, 255, 255, 255))
	
	render.SetMaterial( self.HitMat )
	local A = 150 + math.random(0,20)
	local B = 70 + math.random(0,20)
	render.DrawSprite( StartPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( StartPos, B, B, Color(255,255,255,255) )
	
	render.DrawSprite( EndPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( EndPos + VectorRand() * 10, B, B, Color(255,255,255,255) )
	
	if math.random(0,5) == 1 then
		local emitter = ParticleEmitter( EndPos, false )
		local dir = (self.Entity:GetPos() - EndPos):GetNormalized()
		
		for i = 0, 10 do
			local particle = emitter:Add( "sprites/rico1", EndPos )
			
			local vel = VectorRand()  * 100 + dir * 40
			
			if particle then
				particle:SetVelocity( vel )
				particle:SetAngles( vel:Angle() + Angle(0,90,0) )
				particle:SetDieTime( math.Rand(0.1,0.3) * 0.5 )
				particle:SetStartAlpha( math.Rand( 200, 255 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(1,30) )
				particle:SetEndSize( 0 )
				particle:SetRoll( math.Rand(-100,100) )
				particle:SetRollDelta( math.Rand(-100,100) )

				particle:SetAirResistance( 0 )
			end
		end
		
		emitter:Finish()
	end
end

--addons/lvs_base/lua/effects/lvs_bullet_impact_explosive.lua:

EFFECT.GlowMat = Material( "sprites/light_glow02_add" )
EFFECT.SmokeMat = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.DustMat = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

EFFECT.DecalMat = Material( util.DecalMaterial( "Scorch" ) )

function EFFECT:Init( data )
	self.Dir = data:GetNormal()
	self.Pos = data:GetOrigin()

	self.LifeTime = 0.35
	self.DieTime = CurTime() + self.LifeTime

	local scale = data:GetMagnitude() * 0.5

	self.Scale = 3 * scale

	local emitter = ParticleEmitter( self.Pos, false )

	local VecCol = (render.GetLightColor( self.Pos + self.Dir ) * 0.5 + Vector(0.1,0.09,0.075)) * 255

	local DieTime = math.Rand(0.8,1.6)

	local traceSky = util.TraceLine( {
		start = self.Pos,
		endpos = self.Pos + Vector(0,0,50000),
		filter = self,
	} )

	local traceWater = util.TraceLine( {
		start = traceSky.HitPos,
		endpos = self.Pos - Vector(0,0,100),
		filter = self,
		mask = MASK_WATER,
	} )

	if traceWater.Hit then
		local effectdata = EffectData()
		effectdata:SetOrigin( traceWater.HitPos )
		effectdata:SetScale( 100 )
		effectdata:SetFlags( 2 )
		util.Effect( "WaterSplash", effectdata, true, true )
	end

	local Pos = self.Pos
	local Dist = (traceWater.HitPos - Pos):Length()
	local ply = LocalPlayer():GetViewEntity()

	if not IsValid( ply ) then return end

	local delay = (Pos - ply:GetPos()):Length() / 13503.9

	if traceWater.Hit and Dist > 150 then
		timer.Simple( delay, function()
			local effectdata = EffectData()
			effectdata:SetOrigin( Pos )
			util.Effect( "WaterSurfaceExplosion", effectdata, true, true )
		end )

		if Dist > 300 then return end
	else
		timer.Simple( delay, function()
			sound.Play( "LVS.BULLET_EXPLOSION", Pos )
			sound.Play( "LVS.BULLET_EXPLOSION_DYNAMIC", Pos )
		end )

		local trace = util.TraceLine( {
			start = self.Pos + Vector(0,0,100),
			endpos = self.Pos - Vector(0,0,100),
			mask = MASK_SOLID_BRUSHONLY,
		} )

		if trace.Hit and not trace.HitNonWorld then
			util.DecalEx( self.DecalMat, trace.Entity, trace.HitPos + trace.HitNormal, trace.HitNormal, Color(255,255,255,255), self.Scale * 2.5, self.Scale * 2.5 )
		end
	end

	if self.Dir.z > 0.8 then
		for i = 1, 10 do
			for n = 0,6 do
				local particle = emitter:Add( self.DustMat[ math.random(1,#self.DustMat) ], self.Pos )

				if not particle then continue end

				particle:SetVelocity( (self.Dir * 50 * i + VectorRand() * 25) * self.Scale )
				particle:SetDieTime( (i / 8) * DieTime )
				particle:SetAirResistance( 10 ) 
				particle:SetStartAlpha( 255 )
				particle:SetStartSize( 10 * self.Scale )
				particle:SetEndSize( 20 * i * self.Scale )
				particle:SetRollDelta( math.Rand(-1,1) )
				particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
				particle:SetGravity( Vector(0,0,-600) * self.Scale )
				particle:SetCollide( false )
			end
		end

		for i = 1, 10 do
			local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ], self.Pos )

			if not particle then continue end

			particle:SetVelocity( (self.Dir * 50 * i + VectorRand() * 40) * self.Scale )
			particle:SetDieTime( (i / 8) * DieTime )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 * self.Scale )
			particle:SetEndSize( 20 * i * self.Scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-600) * self.Scale )
			particle:SetCollide( false )
		end
	end

	for i = 1,24 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ] , self.Pos )
		
		if not particle then continue end

		local ang = i * 15
		local X = math.cos( math.rad(ang) )
		local Y = math.sin( math.rad(ang) )

		local Vel = Vector(X,Y,0) * math.Rand(800,1200)
		Vel:Rotate( self.Dir:Angle() + Angle(90,0,0) )

		particle:SetVelocity( Vel * self.Scale )
		particle:SetDieTime( math.Rand(1,3) )
		particle:SetAirResistance( 600 ) 
		particle:SetStartAlpha( 100 )
		particle:SetStartSize( 40 * self.Scale )
		particle:SetEndSize( 140 * self.Scale )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
		particle:SetGravity( Vector(0,0,60) * self.Scale )
		particle:SetCollide( true )
	end

	for i = 0, 15 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1, #self.SmokeMat ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 1000 * scale )
			particle:SetDieTime( math.Rand(2,3) )
			particle:SetAirResistance( 200 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 200 * scale )
			particle:SetEndSize( 600 * scale )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector( 0, 0, -600 ) * scale )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 800 * scale )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( 120 * scale )
		particle:SetEndSize( 20 * scale )
		particle:SetColor( 255, 255, 255 )
		particle:SetGravity( self.Dir * 2500 )
		particle:SetRollDelta( math.Rand(-5,5) )
		particle:SetAirResistance( 300 )
	end

	for i = 0, 5 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )

		if not particle then continue end

		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetColor( 255, 255, 255 )
		particle:SetGravity( Vector(0,0,0) )

		local size = math.Rand(8, 24) * scale
		particle:SetEndSize( size )
		particle:SetStartSize( size )

		particle:SetStartLength( 400 * scale )
		particle:SetEndLength( size )

		particle:SetDieTime( math.Rand(0.1,0.2) )
		particle:SetVelocity( (self.Dir * 4000 + VectorRand() * 2000) * scale )

		particle:SetAirResistance( 0 )
	end

	for i = 0, 40 do
		local particle = emitter:Add( "effects/fire_embers"..math.random(1,2), self.Pos )

		if not particle then continue end

		particle:SetVelocity( VectorRand() * 800 * scale )
		particle:SetDieTime( math.Rand(0.4,0.6) )
		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )
		particle:SetStartSize( 40 * scale )
		particle:SetEndSize( 0 )
		particle:SetColor( 255, 255, 255 )
		particle:SetGravity( Vector(0,0,600) )
		particle:SetRollDelta( math.Rand(-8,8) )
		particle:SetAirResistance( 300 )
	end

	emitter:Finish()
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )
	
	if not IsValid( emitter ) then return end

	for i = 0, 40 do
		local particle = emitter:Add( "particles/flamelet"..math.random(1,5), pos )

		if particle then
			particle:SetVelocity( VectorRand() * 1500 * scale )
			particle:SetDieTime( 0.2 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 20 * scale )
			particle:SetEndSize( math.Rand(180,240) * scale )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	if not self.Scale then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	local R1 = 800 * self.Scale
	render.SetMaterial( self.GlowMat )
	render.DrawSprite( self.Pos, R1 * Scale, R1 * Scale, Color( 255, 200, 150, 255) )
end

--addons/lvs_base/lua/effects/lvs_engine_blacksmoke.lua:

local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin() + VectorRand() * 25
	local Ent = data:GetEntity()

	if not IsValid( Ent ) then return end

	local emitter = Ent:GetParticleEmitter( Pos )

	if not IsValid( emitter ) then return end

	local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], Pos )
	
	if particle then
		particle:SetVelocity( VectorRand() * 100 )
		particle:SetDieTime( 2 )
		particle:SetAirResistance( 600 ) 
		particle:SetStartAlpha( 50 )
		particle:SetStartSize( 60 )
		particle:SetEndSize( 200 )
		particle:SetRoll( math.Rand(-1,1) * math.pi )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( 60, 60, 60 )
		particle:SetGravity( Vector( 0, 0, 600 ) )
		particle:SetCollide( false )
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_base/lua/effects/lvs_explosion_small.lua:

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.LifeTime = 0.35
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	for i = 0, 15 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 1000 )
			particle:SetDieTime( math.Rand(2,3) )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 200 )
			particle:SetStartSize( 120 )
			particle:SetEndSize( 300 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( 50,50,50 )
			particle:SetGravity( Vector( 0, 0, 600 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 15 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( math.Rand(0.15,0.3) )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 25 )
			particle:SetEndSize( math.Rand(70,100) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/rico1", self.Pos )
		
		local vel = VectorRand() * 800
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(20,40) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( 0 )
			particle:SetColor( 255, 255, 255 )

			particle:SetAirResistance( 0 )
		end
	end

	emitter:Finish()

	local Pos = self.Pos
	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		if delay <= 0.11 then
			sound.Play( "ambient/explosions/explode_9.wav", Pos, 85, 100, 1 - delay * 8 )
		end

		timer.Simple( delay, function()
			sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 2000 * Scale, 2000 * Scale, Color( 255, 200, 150, 255) )
end

--addons/lvs_starwars/lua/effects/lvs_laat_left_projector.lua:
EFFECT.Mat = Material( "effects/lvs/ballturret_projectorbeam" )
EFFECT.HitMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Entity = data:GetEntity()

	if IsValid( self.Entity ) then
		self.ID = self.Entity:LookupAttachment( "muzzle_ballturret_left" )

		if self.ID then
			local Muzzle = self.Entity:GetAttachment( self.ID )

			self:SetRenderBoundsWS( self.Entity:GetPos(), Muzzle.Ang:Up() * 50000 )
		end
	end
end

function EFFECT:Think()
	if not IsValid( self.Entity ) or not self.ID or not self.Entity:GetBTLFire() then
		return false
	end

	return true
end


function EFFECT:Render()
	if not self.ID or not IsValid( self.Entity ) then return end

	local Muzzle = self.Entity:GetAttachment( self.ID )

	local Dir = Muzzle.Ang:Up()
	local StartPos = Muzzle.Pos + Dir * 14
	local Trace = util.TraceLine( { start = StartPos, endpos = StartPos + Dir * 50000, filter = self } )
	local EndPos = Trace.HitPos

	self:SetRenderBoundsWS( StartPos, EndPos )

	render.SetMaterial( self.Mat )
	render.DrawBeam( StartPos, EndPos, 14 + math.random(0,4), 1, 0, Color(0,255,0,255) )
	render.DrawBeam( StartPos, EndPos, 3 + math.random(0,4), 1, 0, Color(255,255,255,255) )

	render.SetMaterial( self.HitMat )
	local A = 150 + math.random(0,20)
	local B = 70 + math.random(0,20)
	render.DrawSprite( StartPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( StartPos, B, B, Color(255,255,255,255) )

	render.DrawSprite( EndPos, A, A, Color(0,255,0,255) )
	render.DrawSprite( EndPos + VectorRand() * 10, B, B, Color(255,255,255,255) )

	if math.random(0,5) == 1 then
		local emitter = ParticleEmitter( EndPos, false )
		local dir = (self.Entity:GetPos() - EndPos):GetNormalized()
		
		for i = 0, 10 do
			local particle = emitter:Add( "sprites/rico1", EndPos )
			
			local vel = VectorRand()  * 100 + dir * 40
			
			if not particle then continue end

			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.1,0.3) * 0.5 )
			particle:SetStartAlpha( math.Rand( 200, 255 ) )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(1,30) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )

			particle:SetAirResistance( 0 )
		end
		
		emitter:Finish()
	end
end

--addons/egm_lvs_ships/lua/effects/lvs_laat_wing_projector.lua:
EFFECT.Mat = Material("effects/lvs/ballturret_projectorbeam")
EFFECT.HitMat = Material("sprites/light_glow02_add")

function EFFECT:Init(data)
	self.Entity = data:GetEntity()

	self.DownPos = Vector(-55, 350, 90)
	self.UpPos = Vector(-55, 370, 125)
	self.StartPos = self.DownPos
	self.EndPos = self.Entity:GetWingTurretTarget()
end

function EFFECT:Think()
	if not IsValid(self.Entity) or not self.Entity:GetWingTurretFire() then
		return false
	end

	self.EndPosDesired = self.Entity:GetWingTurretTarget()
	self:SetRenderBoundsWS(self.Entity:GetPos(), self.EndPosDesired)

	return true

end

function EFFECT:Render()
	if not self.EndPosDesired then return end

	self.EndPos = self.EndPos + (self.EndPosDesired - self.EndPos) * FrameTime() * 10

	for i = -1, 1, 2 do
		local StartPos = self.Entity:LocalToWorld( self.StartPos * Vector(1,i,1) )

		local Trace = util.TraceLine({start = StartPos, endpos = self.EndPos})
		local EndPos = Trace.HitPos

		if self.Entity:WorldToLocal( EndPos ).z < 0 then
			self.StartPos = self.DownPos
		else
			self.StartPos = self.UpPos
		end

		if Trace.Entity == self.Entity then continue end

		render.SetMaterial(self.Mat)
		render.DrawBeam(StartPos, EndPos, 14 + math.random(0,4), 1, 0, Color(0,255,0,255))
		render.DrawBeam(StartPos, EndPos, 3 + math.random(0,4), 1, 0, Color(255,255,255,255))

		render.SetMaterial(self.HitMat)
		local A = 150 + math.random(0,20)
		local B = 70 + math.random(0,20)
		render.DrawSprite(StartPos, A, A, Color(0,255,0,255))
		render.DrawSprite(StartPos, B, B, Color(255,255,255,255))

		render.DrawSprite(EndPos, A, A, Color(0,255,0,255))
		render.DrawSprite(EndPos + VectorRand() * 10, B, B, Color(255,255,255,255))

		if math.random(0, 5) == 1 then
			local emitter = ParticleEmitter( EndPos, false )
			local dir = (self.Entity:GetPos() - EndPos):GetNormalized()

			for i = 0, 10 do
				local particle = emitter:Add("sprites/rico1", EndPos)
				if not particle then continue end

				local vel = VectorRand()  * 100 + dir * 40

				particle:SetVelocity( vel )
				particle:SetAngles( vel:Angle() + Angle(0,90,0) )
				particle:SetDieTime( math.Rand(0.1,0.3) * 0.5 )
				particle:SetStartAlpha( math.Rand( 200, 255 ) )
				particle:SetEndAlpha( 0 )
				particle:SetStartSize( math.Rand(1,30) )
				particle:SetEndSize( 0 )
				particle:SetRoll( math.Rand(-100,100) )
				particle:SetRollDelta( math.Rand(-100,100) )

				particle:SetAirResistance( 0 )
			end

			emitter:Finish()
		end
	end
end
--addons/lvs_starwars/lua/effects/lvs_laser_blue_long.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 2500 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 2, endpos + dir * len * 2, 200, 1, 0, Color( 0, 0, 255, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 45, 1, 0, Color( 0, 0, 255, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 15, 1, 0, Color( 255, 255, 255, 255 ) )
end

--addons/lvs_starwars/lua/effects/lvs_laser_explosion.lua:

local GlowMat = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()
	self.Col = data:GetStart() or Vector(255,100,0)

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/light_glow02_add", self.Pos )
		
		local vel = VectorRand() * 400
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.4,0.8) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(24,48) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( self.Col.x,self.Col.y,self.Col.z )
			particle:SetGravity( Vector(0,0,-600) )

			particle:SetAirResistance( 0 )
			
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end
	
	for i = 0, 20 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( 0.15 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 )
			particle:SetEndSize( 32 )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetRollDelta( math.Rand( -1, 1 ) * 100 )
			particle:SetColor( self.Col.x,self.Col.y,self.Col.z )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	if not self.Col then return end

	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 400 * Scale, 400 * Scale, Color( self.Col.x,self.Col.y,self.Col.z, 255) )
	render.DrawSprite( self.Pos, 100 * Scale, 100 * Scale, Color( 255, 255, 255, 255) )
end

--addons/lvs_starwars/lua/effects/lvs_laser_red_aat.lua:

EFFECT.MatBeam = Material( "effects/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then return false end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local endpos = bullet:GetPos()
	local dir = bullet:GetDir()

	local len = 100 * bullet:GetLength()

	render.SetMaterial( self.MatSprite ) 
	render.DrawBeam( endpos - dir * len * 8, endpos + dir * len * 8, 200, 1, 0, Color( 255, 0, 0, 255 ) )

	render.SetMaterial( self.MatBeam )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 60, 1, 0, Color( 255, 0, 0, 255 ) )
	render.DrawBeam( endpos - dir * len, endpos + dir * len, 30, 1, 0, Color( 255, 255, 255, 255 ) )
end

--addons/lvs_base/lua/effects/lvs_muzzle_colorable.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Dir = data:GetNormal()
	local Ent = data:GetEntity()
	local Col = data:GetStart() or Vector(255,255,255)
	local Vel = Dir * 10

	if IsValid( Ent ) then
		Vel = Ent:GetVelocity()
	end

	local emitter = ParticleEmitter( Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0, 12 do
		local particle = emitter:Add( "effects/muzzleflash2", Pos + Dir * i * 0.7 * math.random(1,2) * 0.5 )
		local Size = 1

		if not particle then continue end

		particle:SetVelocity( Dir * 800 + Vel )
		particle:SetDieTime( 0.05 )
		particle:SetStartAlpha( 255 * Size )
		particle:SetStartSize( math.max( math.random(10,24) - i * 0.5,0.1 ) * Size )
		particle:SetEndSize( 0 )
		particle:SetRoll( math.Rand( -1, 1 ) )
		particle:SetColor( Col.x, Col.y, Col.z )
		particle:SetCollide( false )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/lvs_starwars/lua/effects/lvs_proton_explosion.lua:

local GlowMat = Material( "sprites/light_glow02_add" )
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	self.Pos = data:GetOrigin()

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	local emitter = ParticleEmitter( self.Pos, false )

	if not IsValid( emitter ) then return end

	for i = 0,30 do
		local particle = emitter:Add(  Materials[ math.random(1, #Materials ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 800 )
			particle:SetDieTime( math.Rand(4,6) )
			particle:SetAirResistance( math.Rand(200,600) ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( math.Rand(30,60) )
			particle:SetEndSize( math.Rand(100,150) )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 50,50,50 )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/light_glow02_add", self.Pos )
		
		local vel = VectorRand() * 400
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.4,0.8) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(24,48) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( math.Rand(-100,100) )
			particle:SetColor( 0,127,255 )
			particle:SetGravity( Vector(0,0,-600) )

			particle:SetAirResistance( 0 )
			
			particle:SetCollide( true )
			particle:SetBounce( 0.5 )
		end
	end
	
	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( 0.14 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 )
			particle:SetEndSize( math.Rand(30,60) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local Pos = self.Pos
	local ply = LocalPlayer():GetViewEntity()
	if IsValid( ply ) then
		local delay = (Pos - ply:GetPos()):Length() / 13503.9
		if delay <= 0.11 then
			sound.Play( "ambient/explosions/explode_9.wav", Pos, 85, 100, 1 - delay * 8 )
		end

		timer.Simple( delay, function()
			sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
		end )
	else
		sound.Play( "LVS.MISSILE_EXPLOSION", Pos )
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( GlowMat )
	render.DrawSprite( self.Pos, 400 * Scale, 400 * Scale, Color( 0, 127, 255, 255) )
	render.DrawSprite( self.Pos, 100 * Scale, 100 * Scale, Color( 255, 255, 255, 255) )
end

--addons/lvs_base/lua/effects/lvs_tracer_missile.lua:

EFFECT.MatBeam = Material( "effects/lvs_base/spark" )
EFFECT.MatSprite = Material( "sprites/light_glow02_add" )

EFFECT.MatSmoke = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local pos  = data:GetOrigin()
	local dir = data:GetNormal()

	self.ID = data:GetMaterialIndex()

	self:SetRenderBoundsWS( pos, pos + dir * 50000 )

	self.emitter = ParticleEmitter( pos, false )

	self.OldPos = pos
	self.Dir = dir
end

function EFFECT:doFX( pos, curpos )
	if not IsValid( self.emitter ) then return end

	local particle = self.emitter:Add( self.MatSmoke[ math.random(1, #self.MatSmoke ) ], pos )
	if particle then
		particle:SetGravity( Vector(0,0,100) + VectorRand() * 50 ) 
		particle:SetVelocity( -self.Dir * 200  )
		particle:SetAirResistance( 600 ) 
		particle:SetDieTime( math.Rand(1.5,2) )
		particle:SetStartAlpha( 50 )
		particle:SetStartSize( 20 )
		particle:SetEndSize( 60 )
		particle:SetRoll( math.Rand( -1, 1 ) )
		particle:SetRollDelta( math.Rand( -1, 1 ) )
		particle:SetColor(40,40,40)
		particle:SetCollide( false )
	end

	local particle = self.emitter:Add( "particles/flamelet"..math.random(1,5), pos )
	if particle then
		particle:SetVelocity( -self.Dir * math.Rand(250,800) + self.Dir * 1500 )
		particle:SetDieTime( math.Rand(0.2,0.4) )
		particle:SetAirResistance( 0 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 8 )
		particle:SetEndSize( 1 )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 255,255,255 )
		particle:SetGravity( Vector( 0, 0, 0 ) )
		particle:SetCollide( false )
	end

	local particle = self.emitter:Add( "particles/flamelet"..math.random(1,5), curpos )
	if particle then
		particle:SetVelocity( -self.Dir * 200 + VectorRand() * 50 )
		particle:SetDieTime( 0.25 )
		particle:SetAirResistance( 600 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 6 )
		particle:SetEndSize( 2 )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 255,255,255 )
		particle:SetGravity( Vector( 0, 0, 0 ) )
		particle:SetCollide( false )
	end
end

function EFFECT:Think()
	if not LVS:GetBullet( self.ID ) then
		if self.emitter then
			self.emitter:Finish()
		end

		return false
	end

	if not self.emitter then return true end

	local T = CurTime()

	if (self.nextDFX or 0) <= T then
		self.nextDFX = T + 0.02
		
		local bullet = LVS:GetBullet( self.ID )

		local Pos = bullet:GetPos()

		local Sub = self.OldPos - Pos
		local Dist = Sub:Length()
		local Dir = Sub:GetNormalized()

		for i = 0, Dist, 45 do
			local cur_pos = self.OldPos + Dir * i

			self:doFX( cur_pos, Pos )
		end

		self.OldPos = Pos
	end

	return true
end

function EFFECT:Render()
	local bullet = LVS:GetBullet( self.ID )

	local pos = bullet:GetPos()

	render.SetMaterial( self.MatSprite )
	render.DrawSprite( pos, 100, 100, Color( 255, 200, 150, 255 ) )
end

--addons/lvs_starwars/lua/effects/lvs_walker_stomp.lua:
local Materials = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	
	local emitter = ParticleEmitter( pos, false )

	for i = 1,12 do
		local particle = emitter:Add( Materials[ math.random(1, #Materials ) ],pos )
		
		if not particle then continue end

		local ang = i * 30
		local X = math.cos( math.rad(ang) )
		local Y = math.sin( math.rad(ang) )
			
		particle:SetVelocity( Vector(X,Y,0) * math.Rand(3000,4000) )
		particle:SetDieTime( math.Rand(0.5,1) )
		particle:SetAirResistance( math.Rand(3000,5000) ) 
		particle:SetStartAlpha( 100 )
		particle:SetStartSize( 20 )
		particle:SetEndSize( math.Rand(30,40) )
		particle:SetRoll( math.Rand(-1,1) )
		particle:SetColor( 60,60,60 )
		particle:SetGravity( VectorRand() * 200 + Vector(0,0,1000) )
		particle:SetCollide( false )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--lua/effects/m9k_gdcw_cinematicboom/init.lua:

					//Sound,Impact

					// 1        2       3      4      5
					//Dirt, Concrete, Metal, Glass, Flesh

					// 1     2     3      4      5      6      7      8         9
					//Dust, Dirt, Sand, Metal, Smoke, Wood,  Glass, Blood, YellowBlood
local mats={				
	[MAT_ALIENFLESH]		={5,9},
	[MAT_ANTLION]			={5,9},
	[MAT_BLOODYFLESH]		={5,8},
	[45]				={5,8},	// Metrocop heads are a source glitch, they have no enumeration
	[MAT_CLIP]			={3,5},
	[MAT_COMPUTER]			={4,5},
	[MAT_FLESH]			={5,8},
	[MAT_GRATE]			={3,4},
	[MAT_METAL]			={3,4},
	[MAT_PLASTIC]			={2,5},
	[MAT_SLOSH]			={5,5},
	[MAT_VENT]			={3,4},
	[MAT_FOLIAGE]			={1,5},
	[MAT_TILE]			={2,5},
	[MAT_CONCRETE]			={2,1},
	[MAT_DIRT]			={1,2},
	[MAT_SAND]			={1,3},
	[MAT_WOOD]			={2,6},
	[MAT_GLASS]			={4,7},
}

local sounds={
	[1]={"Bullet.Dirt",},
	[2]={"Bullet.Concrete",},
	[3]={"Bullet.Metal",},
	[4]={"Bullet.Glass",},
	[5]={"Bullet.Flesh",},
}

function EFFECT:Init(data)
self.Entity 		= data:GetEntity()		// Entity determines what is creating the dynamic light			//
self.Pos 		= data:GetOrigin()		// Origin determines the global position of the effect			//
self.Scale 		= data:GetScale()		// Scale determines how large the effect is				//
self.Radius 		= data:GetRadius() or 1		// Radius determines what type of effect to create, default is Concrete	//
self.DirVec 		= data:GetNormal()		// Normal determines the direction of impact for the effect		//
self.PenVec 		= data:GetStart()		// PenVec determines the direction of the round for penetrations	//
self.Particles 		= data:GetMagnitude()		// Particles determines how many puffs to make, primarily for "trails"	//
self.Angle 		= self.DirVec:Angle()		// Angle is the angle of impact from Normal				//
self.DebrizzlemyNizzle 	= 10+data:GetScale()		// Debrizzle my Nizzle is how many "trails" to make			//
self.Size 		= 5*self.Scale			// Size is exclusively for the explosion "trails" size			//
self.Emitter 		= ParticleEmitter( self.Pos )	// Emitter must be there so you don't get an error			//
	

			if self.Scale<1.2 then
			sound.Play( "ambient/explosions/explode_" .. math.random(1, 4) .. ".wav", self.Pos, 100, 100 )
			else
			sound.Play( "Explosion.Boom", self.Pos)
			sound.Play( "ambient/explosions/explode_" .. math.random(1, 4) .. ".wav", self.Pos, 100, 100 )
			end


	self.Mat=math.ceil(self.Radius)


 
	if     mats[self.Mat][2]==1 then	self:Dust()	
	elseif mats[self.Mat][2]==2 then	self:Dirt()
	elseif mats[self.Mat][2]==3 then	self:Sand()
	elseif mats[self.Mat][2]==4 then	self:Metal()
	elseif mats[self.Mat][2]==5 then	self:Smoke()
	elseif mats[self.Mat][2]==6 then	self:Wood()
	elseif mats[self.Mat][2]==7 then	self:Glass()
	elseif mats[self.Mat][2]==8 then	self:Blood()
	elseif mats[self.Mat][2]==9 then	self:YellowBlood()
	else 					self:Smoke()
	end

end
 
 function EFFECT:Dust()

		for i=1,5 do 
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*300 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=1, 20*self.Scale do
		local Dust = self.Emitter:Add( "particle/particle_composite", self.Pos )	
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,400)*self.Scale + ((VectorRand():GetNormalized()*300)*self.Scale) )
		Dust:SetDieTime( math.Rand( 2 , 3 ) )
		Dust:SetStartAlpha( 230 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( (50*self.Scale) )
		Dust:SetEndSize( (100*self.Scale) )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 150 ) 			 
		Dust:SetGravity( Vector( 0, 0, math.Rand(-100, -400) ) ) 			
		Dust:SetColor( 80,80,80 )
		end
		end

		for i=1, 15*self.Scale do
		local Dust = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,400)*self.Scale + ((VectorRand():GetNormalized()*400)*self.Scale) )
		Dust:SetDieTime( math.Rand( 1 , 5 )*self.Scale )
		Dust:SetStartAlpha( 50 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( (80*self.Scale) )
		Dust:SetEndSize( (100*self.Scale) )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 250 ) 			 
		Dust:SetGravity( Vector( math.Rand( -200 , 200 ), math.Rand( -200 , 200 ), math.Rand( 10 , 100 ) ) )		
		Dust:SetColor( 90,85,75 )
		end
		end

		for i=1, 25*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(0,700)*self.Scale + VectorRand():GetNormalized() * math.random(0,700)*self.Scale )
		Debris:SetDieTime( math.random( 1, 2) * self.Scale )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(5,10)*self.Scale)
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 40 ) 			 			
		Debris:SetColor( 60,60,60 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 	
		end
		end

		local Angle = self.DirVec:Angle()
		for i = 1, self.DebrizzlemyNizzle do 					/// This part makes the trailers ///
		Angle:RotateAroundAxis(Angle:Forward(), (360/self.DebrizzlemyNizzle))
		local DustRing = Angle:Up()
		local RanVec = self.DirVec*math.Rand(1, 5) + (DustRing*math.Rand(2, 5))

			for k = 3, self.Particles do
			local Rcolor = math.random(-20,20)
			local particle1 = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )				
			particle1:SetVelocity((VectorRand():GetNormalized()*math.Rand(1, 2) * self.Size) + (RanVec*self.Size*k*3.5))	
			particle1:SetDieTime( math.Rand( 0.5, 4 )*self.Scale )	
			particle1:SetStartAlpha( math.Rand( 90, 100 ) )			
			particle1:SetEndAlpha(0)	
			particle1:SetGravity((VectorRand():GetNormalized()*math.Rand(5, 10)* self.Size) + Vector(0,0,-50))
			particle1:SetAirResistance( 200+self.Scale*20 ) 		
			particle1:SetStartSize( (5*self.Size)-((k/self.Particles)*self.Size*3) )	
			particle1:SetEndSize( (20*self.Size)-((k/self.Particles)*self.Size) )
			particle1:SetRoll( math.random( -500, 500 )/100 )	
			particle1:SetRollDelta( math.random( -0.5, 0.5 ) )	
			particle1:SetColor( 90+Rcolor,87+Rcolor,80+Rcolor )
			end
		end
 end
 
function EFFECT:Dirt()

		for i=1,5 do 
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*300 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=1, 20*self.Scale do
		local Dust = self.Emitter:Add( "particle/particle_composite", self.Pos )	
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,400)*self.Scale + ((VectorRand():GetNormalized()*300)*self.Scale) )
		Dust:SetDieTime( math.Rand( 2 , 3 ) )
		Dust:SetStartAlpha( 230 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( (50*self.Scale) )
		Dust:SetEndSize( (100*self.Scale) )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 150 ) 			 
		Dust:SetGravity( Vector( 0, 0, math.Rand(-100, -400) ) ) 			
		Dust:SetColor( 90,83,68 )
		end
		end

		for i=1, 15*self.Scale do
		local Dust = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,400)*self.Scale + ((VectorRand():GetNormalized()*400)*self.Scale) )
		Dust:SetDieTime( math.Rand( 1 , 5 )*self.Scale )
		Dust:SetStartAlpha( 50 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( (80*self.Scale) )
		Dust:SetEndSize( (100*self.Scale) )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 250 ) 			 
		Dust:SetGravity( Vector( math.Rand( -200 , 200 ), math.Rand( -200 , 200 ), math.Rand( 10 , 100 ) ) )		
		Dust:SetColor( 90,83,68 )
		end
		end

		for i=1, 25*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(0,700)*self.Scale + VectorRand():GetNormalized() * math.random(0,700)*self.Scale )
		Debris:SetDieTime( math.random( 1, 2) * self.Scale )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(5,10)*self.Scale)
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 40 ) 			 			
		Debris:SetColor( 50,53,45 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 	
		end
		end

		local Angle = self.DirVec:Angle()
		for i = 1, self.DebrizzlemyNizzle do 					/// This part makes the trailers ///
		Angle:RotateAroundAxis(Angle:Forward(), (360/self.DebrizzlemyNizzle))
		local DustRing = Angle:Up()
		local RanVec = self.DirVec*math.Rand(2, 6) + (DustRing*math.Rand(1, 4))	

			for k = 3, self.Particles do
			local Rcolor = math.random(-20,20)
			local particle1 = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )				
			particle1:SetVelocity((VectorRand():GetNormalized()*math.Rand(1, 2) * self.Size) + (RanVec*self.Size*k*3.5))	
			particle1:SetDieTime( math.Rand( 0.5, 4 )*self.Scale )	
			particle1:SetStartAlpha( math.Rand( 90, 100 ) )			
			particle1:SetEndAlpha(0)	
			particle1:SetGravity((VectorRand():GetNormalized()*math.Rand(5, 10)* self.Size) + Vector(0,0,-50))
			particle1:SetAirResistance( 200+self.Scale*20 ) 		
			particle1:SetStartSize( (5*self.Size)-((k/self.Particles)*self.Size*3) )	
			particle1:SetEndSize( (20*self.Size)-((k/self.Particles)*self.Size) )
			particle1:SetRoll( math.random( -500, 500 )/100 )	
			particle1:SetRollDelta( math.random( -0.5, 0.5 ) )	
			particle1:SetColor( 90+Rcolor,83+Rcolor,68+Rcolor )
			end
		end
 end

 function EFFECT:Sand()

		for i=0, 45*self.Scale do		// This is the main plume
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( self.DirVec * math.random( 50,1000*self.Scale) + VectorRand():GetNormalized()*300*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 5 )*self.Scale )
		Smoke:SetStartAlpha( math.Rand( 100, 120 ) )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 50*self.Scale )
		Smoke:SetEndSize( 120*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-1, 1) )			
		Smoke:SetAirResistance( 200 ) 			 
		Smoke:SetGravity( Vector( 0, 0, math.Rand(-100, -400) ) ) 			
		Smoke:SetColor( 90,83,68 )
		end
		end

		for i=0, 20*self.Scale do		// This is the dirt kickup
		local Dust = self.Emitter:Add( "particle/particle_composite", self.Pos )
		if (Dust) then
		Dust:SetVelocity( self.DirVec * math.random( 100,700)*self.Scale + VectorRand():GetNormalized()*250*self.Scale )
		Dust:SetDieTime( math.Rand( 0.5 , 1,5 ) )
		Dust:SetStartAlpha( 200 )
		Dust:SetEndAlpha( 0 )
		Dust:SetStartSize( 60*self.Scale )
		Dust:SetEndSize( 90*self.Scale )
		Dust:SetRoll( math.Rand(150, 360) )
		Dust:SetRollDelta( math.Rand(-1, 1) )			
		Dust:SetAirResistance( 200 ) 			 
		Dust:SetGravity( Vector( 0, 0, math.Rand(-100, -400) ) ) 			
		Dust:SetColor( 90,83,68 )
		end
		end

		for i=0, 25*self.Scale do		// Chunkage
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(50,900)*self.Scale + VectorRand():GetNormalized() * math.random(0,700)*self.Scale )
		Debris:SetDieTime( math.random( 1, 2) * self.Scale )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(5,8)*self.Scale )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 40 ) 			 			
		Debris:SetColor( 53,50,45 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 		
		end
		end

		for i=0, 25*self.Scale do		// Shrapnel
		local Shrapnel = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos+self.DirVec )
		if (Shrapnel) then
		Shrapnel:SetVelocity ( (self.DirVec*700*self.Scale) + (VectorRand():GetNormalized() * 1000*self.Scale) )
		Shrapnel:SetDieTime( math.random( 0.3, 0.5) * self.Scale )
		Shrapnel:SetStartAlpha( 255 )
		Shrapnel:SetEndAlpha( 0 )
		Shrapnel:SetStartSize( math.random(4,7)*self.Scale )
		Shrapnel:SetRoll( math.Rand(0, 360) )
		Shrapnel:SetRollDelta( math.Rand(-5, 5) )			
		Shrapnel:SetAirResistance( 10 ) 			 			
		Shrapnel:SetColor( 53,50,45 )
		Shrapnel:SetGravity( Vector( 0, 0, -600) ) 
		Shrapnel:SetCollide( true )
		Shrapnel:SetBounce( 0.8 )			
		end
		end

		for i=1,5 do 				// Blast flash
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.10 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=0, 10*self.Scale do		
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( self.DirVec * math.random( 30,120*self.Scale) + VectorRand():GetNormalized() * math.random( 50,100*self.Scale) )
		Smoke:SetDieTime( math.Rand( 0.5 , 1 )*self.Scale  )
		Smoke:SetStartAlpha( math.Rand( 80, 100 ) )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 10*self.Scale )
		Smoke:SetEndSize( 30*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 100 ) 			 
		Smoke:SetGravity( Vector( math.random(-20,20)*self.Scale, math.random(-20,20)*self.Scale, 250 ) ) 			
		Smoke:SetColor( 90,83,68 )
		end
		end
		
	
		for i=0, 5*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 300,600*self.Scale) )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 30, 40 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 150,150,150 )
		end
		end


				local Density = 40*self.Scale					/// This part is for the dust ring ///
				local Angle = self.DirVec:Angle()
				for i=0, Density do	
				Angle:RotateAroundAxis(Angle:Forward(), (360/Density))
				local ShootVector = Angle:Up()
				local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
				if (Smoke) then
				Smoke:SetVelocity( ShootVector * math.Rand(50,700*self.Scale) )
				Smoke:SetDieTime( math.Rand( 1 , 4 )*self.Scale  )
				Smoke:SetStartAlpha( math.Rand( 90, 120 ) )
				Smoke:SetEndAlpha( 0 )
				Smoke:SetStartSize( 40*self.Scale )
				Smoke:SetEndSize( 70*self.Scale )
				Smoke:SetRoll( math.Rand(0, 360) )
				Smoke:SetRollDelta( math.Rand(-1, 1) )			
				Smoke:SetAirResistance( 200 ) 			 
				Smoke:SetGravity( Vector( math.Rand( -200 , 200 ), math.Rand( -200 , 200 ), math.Rand( 10 , 100 ) ) )			
				Smoke:SetColor( 90,83,68 )
				end	
				end
 end

 function EFFECT:Metal()
			sound.Play( "Bullet.Impact", self.Pos)

		for i=1,5 do 				// Blast flash
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=0, 30*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 200,1000*self.Scale) )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 50, 70 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 120,120,120 )
		end
		end

 		for i=0, 30*self.Scale do 
 		local Sparks = self.Emitter:Add( "effects/spark", self.Pos ) 
 		if (Sparks) then 
 		Sparks:SetVelocity( ((self.DirVec*0.75)+VectorRand()) * math.Rand(200, 600)*self.Scale ) 
 		Sparks:SetDieTime( math.Rand(0.3, 1) ) 				 
 		Sparks:SetStartAlpha( 255 )  				 
 		Sparks:SetStartSize( math.Rand(7, 15)*self.Scale ) 
 		Sparks:SetEndSize( 0 ) 				 
 		Sparks:SetRoll( math.Rand(0, 360) ) 
 		Sparks:SetRollDelta( math.Rand(-5, 5) ) 				 
 		Sparks:SetAirResistance( 20 ) 
 		Sparks:SetGravity( Vector( 0, 0, -600 ) ) 
 		end 	
		end 

 		for i=0, 10*self.Scale do 
 		local Sparks = self.Emitter:Add( "effects/yellowflare", self.Pos ) 
 		if (Sparks) then 
 		Sparks:SetVelocity( VectorRand() * math.Rand(200, 600)*self.Scale ) 
 		Sparks:SetDieTime( math.Rand(1, 1.7) ) 				 
 		Sparks:SetStartAlpha( 200 )  				 
 		Sparks:SetStartSize( math.Rand(10, 13)*self.Scale ) 
 		Sparks:SetEndSize( 0 ) 				 
 		Sparks:SetRoll( math.Rand(0, 360) ) 
 		Sparks:SetRollDelta( math.Rand(-5, 5) ) 				 
 		Sparks:SetAirResistance( 100 ) 
 		Sparks:SetGravity( Vector( 0, 0, -60 ) ) 
 		end 	
		end 

end


 function EFFECT:Smoke()
				sound.Play( "Bullet.Impact", self.Pos)

		for i=1,5 do 				// Blast flash
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=0, 30*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 200,1200*self.Scale) )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 35, 50 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 120,120,120 )
		end
		end


		for i=1, 25*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_tile"..math.random(1,2), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( self.DirVec * math.random(100,600)*self.Scale + VectorRand():GetNormalized() * math.random(100,1200)*self.Scale )
		Debris:SetDieTime( math.random( 1, 3) * self.Scale )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(5,10)*self.Scale)
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 40 ) 			 			
		Debris:SetColor( 70,70,70 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 	
		end
		end

		local Angle = self.DirVec:Angle()
		for i = 1, self.DebrizzlemyNizzle do 					/// This part makes the trailers ///
		Angle:RotateAroundAxis(Angle:Forward(), (360/self.DebrizzlemyNizzle))
		local DustRing = Angle:Up()
		local RanVec = self.DirVec*math.Rand(1, 4) + (DustRing*math.Rand(3, 4))

			for k = 3, self.Particles do
			local Rcolor = math.random(-20,20)
			local particle1 = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )				
			particle1:SetVelocity((VectorRand():GetNormalized()*math.Rand(1, 2) * self.Size) + (RanVec*self.Size*k*3.5))	
			particle1:SetDieTime( math.Rand( 0, 3 )*self.Scale )	
			particle1:SetStartAlpha( math.Rand( 90, 100 ) )			
			particle1:SetEndAlpha(0)	
			particle1:SetGravity((VectorRand():GetNormalized()*math.Rand(5, 10)* self.Size) + Vector(0,0,-50))
			particle1:SetAirResistance( 200+self.Scale*20 ) 		
			particle1:SetStartSize( (5*self.Size)-((k/self.Particles)*self.Size*3) )	
			particle1:SetEndSize( (20*self.Size)-((k/self.Particles)*self.Size) )
			particle1:SetRoll( math.random( -500, 500 )/100 )	
			particle1:SetRollDelta( math.random( -0.5, 0.5 ) )	
			particle1:SetColor( 90+Rcolor,85+Rcolor,75+Rcolor )
			end
		end
end

 function EFFECT:Wood()

		for i=1,5 do 				
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=0, 30*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 200,1000)*self.Scale )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 70, 90 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 90,85,75 )
		end
		end

		for i=0, 20*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_wood"..math.random(1,2), self.Pos+self.DirVec )
		if (Debris) then
		Debris:SetVelocity( self.DirVec * math.random(50,500)*self.Scale + VectorRand():GetNormalized() * math.random(200,900)*self.Scale )
		Debris:SetDieTime( math.random( 0.75, 2) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(10,15)*self.Scale )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 70 ) 			 			
		Debris:SetColor( 90,85,75 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 		
		end
		end
end

 function EFFECT:Glass()

		for i=1,5 do 				// Blast flash
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*200 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=0, 30*self.Scale do
		local Debris = self.Emitter:Add( "effects/fleck_glass"..math.random(1,3), self.Pos )
		if (Debris) then
		Debris:SetVelocity ( VectorRand():GetNormalized() * math.random(100,600)*self.Scale )
		Debris:SetDieTime( math.random( 1, 2.5) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( math.random(3,7)*self.Scale )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-15, 15) )			
		Debris:SetAirResistance( 50 ) 			 			
		Debris:SetColor( 200,200,200 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 
		Debris:SetCollide( true )
		Debris:SetBounce( 0.5 )				
		end
		end


		for i=0, 30*self.Scale do
		local Whisp = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Whisp) then
		Whisp:SetVelocity(VectorRand():GetNormalized() * math.random( 200,800*self.Scale) )
		Whisp:SetDieTime( math.Rand( 4 , 10 )*self.Scale/2  )
		Whisp:SetStartAlpha( math.Rand( 35, 50 ) )
		Whisp:SetEndAlpha( 0 )
		Whisp:SetStartSize( 70*self.Scale )
		Whisp:SetEndSize( 100*self.Scale )
		Whisp:SetRoll( math.Rand(150, 360) )
		Whisp:SetRollDelta( math.Rand(-2, 2) )			
		Whisp:SetAirResistance( 300 ) 			 
		Whisp:SetGravity( Vector( math.random(-40,40)*self.Scale, math.random(-40,40)*self.Scale, 0 ) ) 			
		Whisp:SetColor( 150,150,150 )
		end
		end
		
end

 function EFFECT:Blood()
		for i=0, 30*self.Scale do		// If you recieve over 50,000 joules of energy, you become red mist.
		local Smoke = self.Emitter:Add( "particle/particle_composite", self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(100,600)*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 2 ) )
		Smoke:SetStartAlpha( 80 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 30*self.Scale )
		Smoke:SetEndSize( 100*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(0, -200) ) ) 			
		Smoke:SetColor( 70,35,35 )
		end
		end

		for i=0, 20*self.Scale do		// Add some finer details....
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(200,600)*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 4 ) )
		Smoke:SetStartAlpha( 120 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 30*self.Scale )
		Smoke:SetEndSize( 100*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(-50, -300) ) ) 			
		Smoke:SetColor( 70,35,35 )
		end
		end

		for i=1,5 do 				// Into the flash!
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*300 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=1, 20*self.Scale do		// Chunkage NOT contained
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos-(self.DirVec*5) )
		if (Debris) then
		Debris:SetVelocity ( VectorRand():GetNormalized() * 400*self.Scale )
		Debris:SetDieTime( math.random( 0.3, 0.6) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( 8 )
		Debris:SetEndSize( 9 )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 30 ) 			 			
		Debris:SetColor( 70,35,35 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 
		Debris:SetCollide( true )
		Debris:SetBounce( 0.2 )			
		end
		end

end

 function EFFECT:YellowBlood()
		for i=0, 30*self.Scale do		// If you recieve over 50,000 joules of energy, you become red mist.
		local Smoke = self.Emitter:Add( "particle/particle_composite", self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(100,600)*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 2 ) )
		Smoke:SetStartAlpha( 80 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 30*self.Scale )
		Smoke:SetEndSize( 100*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(0, -200) ) ) 			
		Smoke:SetColor( 120,120,0 )
		end
		end

		for i=0, 20*self.Scale do		// Add some finer details....
		local Smoke = self.Emitter:Add( "particle/smokesprites_000"..math.random(1,9), self.Pos )
		if (Smoke) then
		Smoke:SetVelocity( VectorRand():GetNormalized()*math.random(200,600)*self.Scale )
		Smoke:SetDieTime( math.Rand( 1 , 4 ) )
		Smoke:SetStartAlpha( 120 )
		Smoke:SetEndAlpha( 0 )
		Smoke:SetStartSize( 30*self.Scale )
		Smoke:SetEndSize( 100*self.Scale )
		Smoke:SetRoll( math.Rand(150, 360) )
		Smoke:SetRollDelta( math.Rand(-2, 2) )			
		Smoke:SetAirResistance( 400 ) 			 
		Smoke:SetGravity( Vector( math.Rand(-50, 50) * self.Scale, math.Rand(-50, 50) * self.Scale, math.Rand(-50, -300) ) ) 			
		Smoke:SetColor( 120,120,0 )
		end
		end

		for i=1,5 do 				// Into the flash!
		local Flash = self.Emitter:Add( "effects/muzzleflash"..math.random(1,4), self.Pos )
		if (Flash) then
		Flash:SetVelocity( self.DirVec*100 )
		Flash:SetAirResistance( 200 )
		Flash:SetDieTime( 0.15 )
		Flash:SetStartAlpha( 255 )
		Flash:SetEndAlpha( 0 )
		Flash:SetStartSize( self.Scale*300 )
		Flash:SetEndSize( 0 )
		Flash:SetRoll( math.Rand(180,480) )
		Flash:SetRollDelta( math.Rand(-1,1) )
		Flash:SetColor(255,255,255)	
		end
		end

		for i=1, 20*self.Scale do		// Chunkage NOT contained
		local Debris = self.Emitter:Add( "effects/fleck_cement"..math.random(1,2), self.Pos-(self.DirVec*5) )
		if (Debris) then
		Debris:SetVelocity ( VectorRand():GetNormalized() * 400*self.Scale )
		Debris:SetDieTime( math.random( 0.3, 0.6) )
		Debris:SetStartAlpha( 255 )
		Debris:SetEndAlpha( 0 )
		Debris:SetStartSize( 8 )
		Debris:SetEndSize( 9 )
		Debris:SetRoll( math.Rand(0, 360) )
		Debris:SetRollDelta( math.Rand(-5, 5) )			
		Debris:SetAirResistance( 30 ) 			 			
		Debris:SetColor( 120,120,0 )
		Debris:SetGravity( Vector( 0, 0, -600) ) 
		Debris:SetCollide( true )
		Debris:SetBounce( 0.2 )			
		end
		end
end
 

function EFFECT:Think( )
return false
end

function EFFECT:Render()
end
--addons/wos-grandmaster-einf/lua/effects/rb655_force_lighting.lua:

local function GetRandomPositionInBox( mins, maxs, ang )
	return ang:Up() * math.random( mins.z, maxs.z ) + ang:Right() * math.random( mins.y, maxs.y ) + ang:Forward() * math.random( mins.x, maxs.x )
end

local function GenerateLighting( from, to, deviations, power )
	local start = from
	if ( isentity( start ) ) then start = from:GetPos() end
	local endpos = to:GetPos()

	--render.DrawWireframeBox( start, Angle(0, 0, 0),from:OBBMins(), from:OBBMaxs(), Color(255, 0, 0), true )
	--render.DrawWireframeBox( start, to:GetAngles(),from:OBBMins(), from:OBBMaxs(), Color(0, 255, 0), true )

	--start = start + GetRandomPositionInBox( from:OBBMins(), from:OBBMaxs(), from:GetAngles() )
	endpos = endpos + GetRandomPositionInBox( to:OBBMins(), to:OBBMaxs(), to:GetAngles() )

	local right = (start - endpos):Angle():Right()
	local up = (start - endpos):Angle():Up()
	local segments = {
		{ start, endpos }
	}
	for i = 0, power do
		local newsegs = {}
		for id, seg in pairs( segments ) do
			local mid = Vector( (seg[1].x + seg[2].x) / 2, (seg[1].y + seg[2].y) / 2, (seg[1].z + seg[2].z) / 2 )
			local offsetpos = mid + right * math.random( -deviations, deviations ) + up * math.random( -deviations, deviations )
			table.insert( newsegs, {seg[1], offsetpos} )
			table.insert( newsegs, {offsetpos, seg[2]} )
		end
		segments = newsegs
	end
	return segments
end

local function GenerateLightingSegs( from, to, deviations, segs )
	local start = from
	if ( isentity( start ) ) then start = from:GetPos() end
	local endpos = to:GetPos()

	--render.DrawWireframeBox( start, Angle(0, 0, 0),from:OBBMins(), from:OBBMaxs(), Color(255, 0, 0), true )
	--render.DrawWireframeBox( start, to:GetAngles(),from:OBBMins(), from:OBBMaxs(), Color(0, 255, 0), true )

	--start = start + GetRandomPositionInBox( from:OBBMins(), from:OBBMaxs(), from:GetAngles() )
	endpos = endpos + GetRandomPositionInBox( to:OBBMins(), to:OBBMaxs(), to:GetAngles() )

	local right = (start - endpos):Angle():Right()
	local up = (start - endpos):Angle():Up()
	local fwd = (start - endpos):Angle():Forward()
	local step = (1 / segs) * start:Distance( endpos )

	local lastpos = start
	local segments = {}
	for i = 1, segs do
		local a = lastpos - fwd * step
		table.insert( segments, { lastpos, a } )
		lastpos = a
	end

	for k, v in pairs( segments ) do
		if ( k == 1 || k == #segments ) then continue end

		segments[ k ][ 1 ] = segments[ k ][ 1 ] + right * math.random( -deviations, deviations ) + up * math.random( -deviations, deviations )
		segments[ k - 1 ][ 2 ] = segments[ k ][ 1 ]
	end

	for k, v in pairs( segments ) do
		if ( k == 1 || k == #segments ) then continue end

		if ( math.random( 0, 100 ) > 75 ) then
			local dir = AngleRand():Forward()
			table.insert( segments, { segments[ k ][ 1 ], segments[ k ][ 1 ] + dir * ( step * math.Rand( 0.2, 0.6 ) ) } )
		end
	end

	return segments
end

local mats = {
	(Material( "cable/blue_elec" )),
	/*(Material( "cable/hydra" )),
	(Material( "cable/redlaser" )),
	(Material( "cable/crystal_beam1" )),
	(Material( "cable/physbeam" )),
	(Material( "cable/smoke" )),
	(Material( "cable/xbeam" )),*/
}

local segments = {}
--local n = 0
local tiem = .2
hook.Add( "PostDrawTranslucentRenderables", "", function()
	--if ( #segments < 1 || n < CurTime() ) then
		--
		/*for i = 0, 1 do
			table.insert( segments, {
				segs = GenerateLighting( table.Random( ents.FindByClass( "prop_physics" ) ), table.Random( ents.FindByClass( "prop_physics" ) ), math.random( 10, 20 ), 3 ),
				mat = table.Random( mats ),
				time = CurTime() + tiem,
				w = math.random( 20, 50 )
			} )
		end*/
		--n = CurTime() + .01
	--end

	for id, t in pairs( segments ) do
		if ( t.time < CurTime() ) then table.remove( segments, id ) continue end
		render.SetMaterial( t.mat )
		for id, seg in pairs( t.segs ) do
			render.DrawBeam( seg[1], seg[2], ( math.max( t.startpos:Distance( t.endpos ) - seg[1]:Distance( t.endpos ), 20) / ( t.startpos:Distance( t.endpos ) ) * t.w ) * ( (t.time - CurTime() ) / tiem ), 0, seg[1]:Distance( seg[2] ) / 25, Color( 255, 255, 255 ) )
			--render.DrawBeam( seg[1], seg[2], (id / #t.segs * t.w ) * ((t.time - CurTime()) / tiem), 0, seg[1]:Distance( seg[2] ) / 25, Color( 255, 255, 255 ) )
		end
	end
end )


function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local ent = data:GetEntity()

	if ( !IsValid( ent ) ) then return end

	table.insert( segments, {
		--segs = GenerateLighting( pos, ent, math.random( 10, 20 ), 3 ),
		segs = GenerateLightingSegs( pos, ent, math.random( 10, 20 ), pos:Distance( ent:GetPos() ) / 48 ), --math.random( 5, 10 ) ),
		mat = table.Random( mats ),
		time = CurTime() + tiem,
		w = math.random( 20, 50 ),
		startpos = pos,
		endpos = ent:GetPos()
	} )
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
	/*for id, t in pairs( segments ) do
		if (t.time < CurTime() ) then table.remove( segments, id ) continue end
		render.SetMaterial( t.mat )
		for id, seg in pairs( t.segs ) do
			render.DrawBeam( seg[1], seg[2], (id / #t.segs * t.w ) * ((t.time - CurTime()) / tiem), 0, seg[1]:Distance( seg[2] ) / 25, Color( 255, 255, 255 ) )
		end
	end*/
end

--addons/wos-grandmaster-einf/lua/effects/rb655_force_repulse_out.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local rad = data:GetRadius()
	local emitter = ParticleEmitter( pos )

	if ( !emitter ) then return end

	local particle = emitter:Add( "effects/rb655_conc_warp", pos )
	if ( particle ) then
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.25 * 5 )

		particle:SetGravity( Vector( 0, 0, 0 ) )
		particle:SetVelocity( Vector( 0, 0, 0 ) )

		particle:SetStartSize( 0 )
		particle:SetEndSize( rad * 2 ) --math.random( 1000, 2000 ) )

		particle:SetStartAlpha( math.random( 128, 200 ) )
		particle:SetEndAlpha( 0 )

		particle:SetColor( 255, 255, 255 )
	end

	local particle = emitter:Add( "effects/rb655_splash_warpring1", pos )
	if ( particle ) then
		particle:SetLifeTime( 0 )
		particle:SetDieTime( 0.25 * 5 )

		particle:SetGravity( Vector( 0, 0, 0 ) )
		particle:SetVelocity( Vector( 0, 0, 0 ) )

		particle:SetStartSize( 0 )
		particle:SetEndSize( rad * 2 ) --math.random( 1000, 2000 ) )

		particle:SetStartAlpha( math.random( 128, 200 ) )
		particle:SetEndAlpha( 0 )

		particle:SetColor( 255, 255, 255 )
	end

	/*local particle = emitter:Add( "effects/select_ring", pos )
	if ( particle ) then
		particle:SetLifeTime( 0 )
		particle:SetDieTime( .5 )

		particle:SetGravity( Vector( 0, 0, 0 ) )
		particle:SetVelocity( Vector( 0, 0, 0 ) )

		particle:SetStartSize( 0 )
		particle:SetEndSize( rad )--math.random( 1000, 2000 ) )

		particle:SetStartAlpha( 255 )
		particle:SetEndAlpha( 0 )

		particle:SetColor( 0, 255, 255 )
		--particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
	end*/

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--lua/effects/rw_sw_dual_laser_aqua.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_l/rw_sw_laser_m_aqua")
local MaterialFront 		= Material("effects/sw_l/rw_sw_laser_f_aqua")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 255
			dlight.b = 160
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_dual_laser_purple.lua:
TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_laser_purple_main")
local MaterialFront 		= Material("effects/sw_laser_purple_front")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.WeaponEntOG = data:GetEntity()
	self.Attachment = data:GetAttachment()
	local owent
	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt.Owner or self.WeaponEnt:GetOwner()
		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end
	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			self.WeaponEnt = owent:GetViewModel()
			local theirweapon = owent:GetActiveWeapon()
			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end
			if not IsValid(self.WeaponEnt) then return end
		end
	end
	if IsValid(self.WeaponEntOG) and self.WeaponEntOG.MuzzleAttachment then
		self.Attachment = self.WeaponEnt:LookupAttachment(self.WeaponEntOG.MuzzleAttachment)
		if not self.Attachment or self.Attachment <= 0 then
			self.Attachment = 1
		end
		if self.WeaponEntOG.Akimbo then
			if game.SinglePlayer() then
				self.WeaponEntOG.AnimCycle = self.WeaponEntOG:GetNW2Int("AnimCycle") or 0
			end
			self.Attachment = 1 + self.WeaponEntOG.AnimCycle
		end
	end
	local angpos
	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end
	if not angpos or not angpos.Pos then
		angpos = {
			Pos = bvec,
			Ang = uAng
		}
	end
	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		self.Dir = localang:Forward()
	end
	if IsValid(owent) and self.Position:Distance(owent:GetShootPos()) > 72 then
		self.WeaponEnt = nil
	end
	
	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	local diff = self.EndPos - self.StartPos
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed
	self.data = data
	self.rot = nil
	weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 125
			dlight.g = 0
			dlight.b = 255
			dlight.brightness = 3
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_impact_redpink.lua:
local MaterialGlow		= Material( "effects/sw_i/sw_laser_bit_redpink" );
function EFFECT:Init( data )
	local bit_amount = GetConVar("rw_sw_bit_amount"):GetInt()
	local smoke_amount = GetConVar("rw_sw_smoke_amount"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	self.Position = data:GetOrigin();
	self.Normal = data:GetNormal();
	self.LifeTime = duration;
	local emitter = ParticleEmitter( self.Position );
	if( emitter ) then
		for i = 1, bit_amount do
			local particle = emitter:Add( MaterialGlow, self.Position + self.Normal * 2 );
			particle:SetVelocity( ( self.Normal + VectorRand() * 0.75 ):GetNormal() * math.Rand( 75, 125 ) );
			particle:SetDieTime( math.Rand( 0.5, 1.25 ) );
			particle:SetStartAlpha( 255 );
			particle:SetEndAlpha( 0 );
			particle:SetStartSize( math.Rand( 4, 8 ) );
			particle:SetEndSize( 0 );
			particle:SetRoll( 0 );
			particle:SetGravity( Vector( 0, 0, -250 ) );
			particle:SetCollide( true );
			particle:SetBounce( 0.3 );
			particle:SetAirResistance( 5 );
		end
		emitter:Finish();
	end
	local emitter_s = ParticleEmitter( self.Position );
	if( emitter_s ) then
		for i = 1, smoke_amount do
			local smokeTexture	= "effects/smoke"
			local particle_s = emitter_s:Add(smokeTexture, self.Position+self.Normal*2);
			particle_s:SetVelocity((self.Normal+VectorRand()*0.10):GetNormal()*math.Rand(400, 900));
			particle_s:SetDieTime(math.Rand(2.1, 2.7));
			particle_s:SetStartAlpha(50);
			particle_s:SetEndAlpha(0);
			particle_s:SetStartSize(math.Rand(8, 16));
			particle_s:SetEndSize(math.Rand(0, 4));
			particle_s:SetGravity(Vector(math.Rand(0, 500), math.Rand(250, 1000), math.Rand(-250, 250)));
			particle_s:SetRoll(math.Rand(0, 360));
			particle_s:SetRollDelta(math.Rand(-0.5, 0.5));
			local colour = math.Rand(110, 130);
			particle_s:SetColor(colour, colour, colour, 100);
			particle_s:SetCollide(true);
			particle_s:SetAirResistance(2000);
		end
		emitter_s:Finish();
	end
end
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime();
	return self.LifeTime > 0;
end
function EFFECT:Render()
	local size = GetConVar("rw_sw_impact_size"):GetInt()
	local duration = GetConVar("rw_sw_impact_duration"):GetInt()
	local frac = math.max( 0, self.LifeTime / duration);
	local rgb = 255 * frac;
	local color = Color( rgb, rgb, rgb, 255 );
	render.SetMaterial( MaterialGlow );
	render.DrawQuadEasy( self.Position + self.Normal, self.Normal, size, size, color );
end
--lua/effects/rw_sw_laser_black.lua:

TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD 			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 95

local MaterialMain 			= Material("effects/sw_l/rw_sw_laser_m_black")
local MaterialFront 		= Material("effects/sw_l/rw_sw_laser_f_black")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end
		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()
			if (IsValid(pl)) then
				local vm = pl:GetViewModel()
				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end
	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed 	--self.LifeTime = (diff:Length() - (self.Length/2) ) / self.Speed
	local weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 0
			dlight.g = 0
			dlight.b = 0
			dlight.brightness = 2
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_laser_orange.lua:

TRACER_FLAG_USEATTACHMENT 	= 0x0002
SOUND_FROM_WORLD 			= 0
CHAN_STATIC 				= 6

EFFECT.Speed 				= 16384
EFFECT.Length 				= 175

local MaterialMain 			= Material("effects/sw_l/rw_sw_laser_m_orange")
local MaterialFront 		= Material("effects/sw_l/rw_sw_laser_f_orange")
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin()
			-- if( origin ) then
			-- 	return origin, angle, entity
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

--concommand.Add("sv_dlight")
function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance

		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 90
			dlight.b = 0
			dlight.brightness = 5
			dlight.Decay = 1000
			dlight.Size = 200
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 6, 6, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 6, 0, 1, color_white)
end
--lua/effects/rw_sw_laser_white.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002
SOUND_FROM_WORLD			= 0
CHAN_STATIC					= 6

EFFECT.Speed				= 16384
EFFECT.Length				= 95

local MaterialMain			= Material( "effects/sw_laser_white_main" )
local MaterialFront			= Material( "effects/sw_laser_white_front" )
local DynamicTracer 		= GetConVar("cl_dynamic_tracer")

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end
		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()
			if (IsValid(pl)) then
				local vm = pl:GetViewModel()
				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end
	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = self.EndPos - self.StartPos
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() - self.Length/2 ) / self.Speed 	--self.LifeTime = (diff:Length() - (self.Length/2) ) / self.Speed
	local weapon = data:GetEntity()
	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	if DynamicTracer:GetBool() then
		local spawn = util.CRC(tostring(self:GetPos()))
		local dlight = DynamicLight(self:EntIndex() + spawn)
		local endDistance = self.Speed * self.StartTime
		local endPos = self.StartPos + self.Normal * endDistance
		if (dlight) then
			dlight.pos = endPos
			dlight.r = 255
			dlight.g = 255
			dlight.b = 255
			dlight.brightness = 2
			dlight.Decay = 1500
			dlight.Size = 300
			dlight.nomodel = 1
			dlight.style = 6
			dlight.DieTime = CurTime() + 3
		end
	end
	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 9, 9, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 7, 0, 0, color_white)
end
--lua/effects/rw_sw_muzzleflash_red.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(255,0,0)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--lua/effects/rw_sw_muzzleflash_redpink.lua:
EFFECT.Life = 0.12
EFFECT.XFlashSize = 0.55
EFFECT.FlashSize = 0.5
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 2.5
EFFECT.Color = Color(255,0,50)
EFFECT.ColorSprites = true

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt:GetOwner():GetViewModel()
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:GetShootPos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 150
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local smokeCount = math.ceil(self.SmokeSize * 6)

	for _ = 0, smokeCount do
		local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

		if (particle) then
			particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
			particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
			particle:SetStartAlpha(math.Rand(12, 24))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
			particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.Rand(-0.8, 0.8))
			particle:SetLighting(true)
			particle:SetAirResistance(20)
			particle:SetGravity(Vector(0, 0, 60))
			particle:SetColor(255, 255, 255)
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > self.DieTime then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
			self.DLight.pos = self.OwnerEnt:GetShootPos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--lua/effects/rw_sw_stunwave_blue.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 4500;
EFFECT.Length				= 64;

local MaterialFront			= Material( "cs574/stun_tracers/sw_stunwave_blue" );

function EFFECT:GetTracerOrigin(data)
	local start = data:GetStart()
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end
		local attachment = entity:GetAttachment(data:GetAttachment())
		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

EFFECT.WaveSize = 0

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	if (self.WaveSize < 45) then
		self.WaveSize = self.WaveSize + 1
	end

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(startPos, 1 + self.WaveSize, 1 + self.WaveSize, color_white)
end

--lua/effects/servius_stun/init.lua:

TRACER_FLAG_USEATTACHMENT	= 0x0002;
SOUND_FROM_WORLD			= 0;
CHAN_STATIC					= 6;

EFFECT.Speed				= 6500;
EFFECT.Length				= 64;
--EFFECT.WhizSound			= Sound( "nomad/whiz.wav" );		-- by Robinhood76 (http:--www.freesound.org/people/Robinhood76/sounds/96556/)
EFFECT.WhizDistance			= 72;

local MaterialMain			= Material( "star/effects/blue_shockwave" );
local MaterialFront			= Material( "star/effects/blue_shockwave" );

function EFFECT:GetTracerOrigin(data)
	-- this is almost a direct port of GetTracerOrigin in fx_tracer.cpp
	local start = data:GetStart()

	-- use attachment?
	if (bit.band(data:GetFlags(), TRACER_FLAG_USEATTACHMENT) == TRACER_FLAG_USEATTACHMENT) then
		local entity = data:GetEntity()
		if (not IsValid(entity)) then return start end
		if (not game.SinglePlayer() and entity:IsEFlagSet(EFL_DORMANT)) then return start end

		if (entity:IsWeapon() and entity:IsCarriedByLocalPlayer()) then
			-- can't be done, can't call the real function
			-- local origin = weapon:GetTracerOrigin();
			-- if( origin ) then
			-- 	return origin, angle, entity;
			-- end
			-- use the view model
			local pl = entity:GetOwner()

			if (IsValid(pl)) then
				local vm = pl:GetViewModel()

				if (IsValid(vm) and not LocalPlayer():ShouldDrawLocalPlayer()) then
					entity = vm
					-- HACK: fix the model in multiplayer
				else
					if (entity.WorldModel) then
						entity:SetModel(entity.WorldModel)
					end
				end
			end
		end

		local attachment = entity:GetAttachment(data:GetAttachment())

		if (attachment) then
			start = attachment.Pos
		end
	end

	return start
end

function EFFECT:Init(data)
	self.StartPos = self:GetTracerOrigin(data)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	local diff = (self.EndPos - self.StartPos)
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = (diff:Length() + self.Length) / self.Speed
	-- whiz by sound
	local weapon = data:GetEntity()

	if (IsValid(weapon) and (not weapon:IsWeapon() or not weapon:IsCarriedByLocalPlayer())) then
		local dist, pos, time = util.DistanceToLine(self.StartPos, self.EndPos, EyePos())
	end
end

function EFFECT:Think()
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

function EFFECT:Render()
	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	startDistance = math.max(0, startDistance)
	endDistance = math.max(0, endDistance)
	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	render.SetMaterial(MaterialFront)
	render.DrawSprite(endPos, 35, 35, color_white)
	render.SetMaterial(MaterialMain)
	render.DrawBeam(startPos, endPos, 10, 0, 1, color_white)
end

--lua/effects/swep_flamethrower_explosion/init.lua:
//Main function
function EFFECT:Init(data)


//Default performance settings
local DrawFlame = 1
local DrawSmoke = 1
local DrawRefraction = 0

//Adjust performance depending on user settings
local PerfIndex = GetConVar("flamethrower_fx"):GetInt()
if PerfIndex == 3 then DrawRefraction = 1 end


//Play impact sound
sound.Play("ambient/fire/ignite.wav", self:GetPos(), 54, math.random(82,112))


	//Draw burst of flame
	if DrawFlame == 1 then

	//Create particle emmiter
	local FlameEmitter = ParticleEmitter(data:GetOrigin())

		//Amount of particles to create
		for i=0, 16 do

			//Safeguard
			if !FlameEmitter then return end

			//Pool of flame sprites
			local FlameMat = {}
			FlameMat[1] = "effects/muzzleflash2"
			FlameMat[2] = "effects/muzzleflash2edit"
			FlameMat[3] = "effects/muzzleflash3"

			local FlameParticle = FlameEmitter:Add( FlameMat[math.random(1,3)], data:GetOrigin() )

			//Refraction is too expensive to render on most machines
			if DrawRefraction == 1 then
			if math.random(1,12) == 12 then
			FlameParticle = FlameEmitter:Add( "sprites/heatwave", data:GetOrigin() )
			end
			end

			if (FlameParticle) then

				FlameParticle:SetVelocity( VectorRand() * 172 )
				
				FlameParticle:SetLifeTime(0)
				FlameParticle:SetDieTime(0.72)
				
				FlameParticle:SetStartAlpha(210)
				FlameParticle:SetEndAlpha(0)
				
				FlameParticle:SetStartSize(0)
				FlameParticle:SetEndSize(64)
				
				FlameParticle:SetRoll(math.Rand(-210, 210))
				FlameParticle:SetRollDelta(math.Rand(-3.2, 3.2))
				
				FlameParticle:SetAirResistance(350)
				
				FlameParticle:SetGravity(Vector(0, 0, 64))

			end
		end

	//We're done with this emmiter
	FlameEmitter:Finish()

	//Finished with flame
	end


	//Draw stream of smoke
	if DrawSmoke == 1 then

	//Create particle emmiter
	local SmokeEmitter = ParticleEmitter(data:GetOrigin())

		//Amount of particles to create
		for i=0, 4 do

			//Safeguard
			if !SmokeEmitter then return end

			SmokeParticle = SmokeEmitter:Add( "particle/smokesprites_000" .. math.random(1,8) .. "", data:GetOrigin() )

			if (SmokeParticle) then

				SmokeParticle:SetVelocity( VectorRand() * 210 )
				
				SmokeParticle:SetLifeTime(0)
				SmokeParticle:SetDieTime( math.Rand(1.92, 2.82) )
				
				SmokeParticle:SetStartAlpha(82)
				SmokeParticle:SetEndAlpha(0)
				
				SmokeParticle:SetStartSize(21)
				SmokeParticle:SetEndSize(82)
				
				SmokeParticle:SetRoll(math.Rand(-320, 320))
				SmokeParticle:SetRollDelta(math.Rand(-1.32, 1.32))
				
				SmokeParticle:SetAirResistance(420)
				
				SmokeParticle:SetGravity(Vector( 0, 0, math.random(112, 132) ))

				SmokeParticle:SetLighting(1)

			end
		end

	//We're done with this emmiter
	SmokeEmitter:Finish()

	//Finished with smoke
	end


end

//Kill effect
function EFFECT:Think()
return false
end

//Unused
function EFFECT:Render()
end
--lua/effects/swep_flamethrower_flame2/init.lua:
//Main function
function EFFECT:Init(data)


//Default performance settings
local DrawFlame = 1
local DrawSmoke = 1
local DrawRefraction = 0

//Adjust performance depending on user settings
local PerfIndex = GetConVar("flamethrower_fx"):GetInt()
if PerfIndex == 1 then DrawSmoke = 0 end
if PerfIndex == 3 then DrawRefraction = 1 end


//Muzzle and desired position vectors
local StartPos = self:GetTracerShootPos(self.Position, data:GetEntity(), data:GetAttachment())
local HitPos = data:GetOrigin()

//Check if the weapon is still there
if data:GetEntity():IsValid() && StartPos && HitPos then


	//Draw burst of flame
	if DrawFlame == 1 then

	//Create particle emmiter
	local FlameEmitter = ParticleEmitter(StartPos)

		//Amount of particles to create
		for i=0, 8 do

			//Safeguard
			if !FlameEmitter then return end

			//Pool of flame sprites
			local FlameMat = {}
			FlameMat[1] = "effects/muzzleflash2"
			FlameMat[2] = "effects/muzzleflash2edit"
			FlameMat[3] = "effects/muzzleflash3"

			local FlameParticle = FlameEmitter:Add( FlameMat[math.random(1,3)], StartPos )

			//Refraction is too expensive to render on most machines
			if DrawRefraction == 1 then
			if math.random(1,16) == 16 then
			FlameParticle = FlameEmitter:Add( "sprites/heatwave", StartPos )
			end
			end

			if (FlameParticle) then

				FlameParticle:SetVelocity( ((HitPos - StartPos):GetNormal() * math.random(1720,1820)) + (VectorRand() * math.random(142,172)) )

				FlameParticle:SetLifeTime(0)
				FlameParticle:SetDieTime(.52)

				FlameParticle:SetStartAlpha(math.random(92,132))
				FlameParticle:SetEndAlpha(0)

				FlameParticle:SetStartSize(math.random(4,6))
				FlameParticle:SetEndSize(math.random(32,52))

				FlameParticle:SetRoll(math.Rand(-360, 360))
				FlameParticle:SetRollDelta(math.Rand(-7.2, 7.2))

				FlameParticle:SetAirResistance(math.random(128, 256))

				FlameParticle:SetCollide(true)

				FlameParticle:SetGravity( Vector(0, 0, -5) )

			end
		end

	//We're done with this emmiter
	FlameEmitter:Finish()

	//Finished with flame
	end


	//Draw stream of smoke
	if DrawSmoke == 1 then

	//Create particle emmiter
	local SmokeEmitter = ParticleEmitter(StartPos)

		//Amount of particles to create
		for i=0, 2 do

			//Safeguard
			if !SmokeEmitter then return end

			SmokeParticle = SmokeEmitter:Add( "particle/smokesprites_000" .. math.random(1,8) .. "", StartPos )

			if (SmokeParticle) then

				SmokeParticle:SetVelocity( ((HitPos - StartPos):GetNormal() * math.random(1720,1820)) + (VectorRand() * math.random(152,182)) )

				SmokeParticle:SetLifeTime(0)
				SmokeParticle:SetDieTime( math.Rand(0.92, 1.72) )

				SmokeParticle:SetStartAlpha(math.random(52,92))
				SmokeParticle:SetEndAlpha(0)

				SmokeParticle:SetStartSize(math.random(8,10))
				SmokeParticle:SetEndSize(math.random(62,82))

				SmokeParticle:SetRoll(math.Rand(-360, 360))
				SmokeParticle:SetRollDelta(math.Rand(-5.2, 5.2))

				SmokeParticle:SetAirResistance(math.random(132, 262))

				SmokeParticle:SetCollide(true)

				SmokeParticle:SetGravity( Vector(0, 0, -92) )

				SmokeParticle:SetLighting(1)

			end
		end

	//We're done with this emmiter
	SmokeEmitter:Finish()

	//Finished with smoke
	end


end
end

//Kill effect
function EFFECT:Think()
return false
end

//Unused
function EFFECT:Render()
end
--gamemodes/starwarsrp/entities/effects/swrp_cinematicboom/init.lua:
function EFFECT:Init(data)
	self.Entity = data:GetEntity() --Entity determines what is creating the dynamic light

	self.Pos = data:GetOrigin() --Origin determines the global position of the effect

	self.Scale = data:GetScale() --Scale determines how large the effect is
	self.Radius = data:GetRadius() or 1 --Radius determines what type of effect to create, default is Concrete

	self.DirVec = data:GetNormal() --Normal determines the direction of impact for the effect
	self.PenVec = data:GetStart() --PenVec determines the direction of the round for penetrations
	self.Particles = data:GetMagnitude() --Particles determines how many puffs to make, primarily for "trails"
	self.Angle = self.DirVec:Angle() --Angle is the angle of impact from Normal
	self.DebrizzlemyNizzle = 10 + data:GetScale() --Debrizzle my Nizzle is how many "trails" to make
	self.Size = 5 * self.Scale --Size is exclusively for the explosion "trails" size

	self.Emitter = ParticleEmitter( self.Pos ) --Emitter must be there so you don't get an error

	sound.Play("ambient/explosions/explode_" .. math.random(1, 4) .. ".wav", self.Pos, 100, 100)

	if self.Scale >= 1.2 then
		sound.Play("Explosion.Boom", self.Pos)
	end

	self:Explosion()
end

function EFFECT:Explosion()
	ParticleEffect("har_explosion_a", self.Pos, self:GetAngles(), nil)
	ParticleEffect("har_explosion_b", self.Pos, self:GetAngles(), nil)
	ParticleEffect("har_explosion_c", self.Pos, self:GetAngles(), nil)

	local spawn = util.CRC(tostring(self.Pos))
	local dlight = DynamicLight(self:EntIndex() + spawn)

	if (dlight) then
		dlight.pos = self.Pos
		dlight.r = 255
		dlight.g = 200
		dlight.b = 127
		dlight.brightness = 5
		dlight.Decay = 1000
		dlight.Size = 750
		dlight.DieTime = CurTime() + 3
	end

	for i = 1, 5 do
		local Flash = self.Emitter:Add("effects/muzzleflash" .. math.random(1,4), self.Pos)

		if Flash then
			Flash:SetVelocity(self.DirVec * 100)
			Flash:SetAirResistance(200)
			Flash:SetDieTime(0.15)
			Flash:SetStartAlpha(255)
			Flash:SetEndAlpha(0)
			Flash:SetStartSize(self.Scale * 300)
			Flash:SetEndSize(0)
			Flash:SetRoll(math.Rand(180, 480))
			Flash:SetRollDelta(math.Rand(-1, 1))
			Flash:SetColor(255, 255, 255)
		end
	end

	for i = 1, 20 * self.Scale do
		local Dust = self.Emitter:Add("particle/particle_composite", self.Pos)

		if Dust then
			Dust:SetVelocity(self.DirVec * math.random(100, 400) * self.Scale + ((VectorRand():GetNormalized() * 300) * self.Scale))
			Dust:SetDieTime(math.Rand( 2, 3 ))
			Dust:SetStartAlpha(230)
			Dust:SetEndAlpha(0)
			Dust:SetStartSize(50 * self.Scale)
			Dust:SetEndSize(100 * self.Scale)
			Dust:SetRoll(math.Rand(150, 360))
			Dust:SetRollDelta(math.Rand(-1, 1))
			Dust:SetAirResistance(150)
			Dust:SetGravity(Vector(0, 0, math.Rand(-100, -400)))
			Dust:SetColor(80, 80, 80)
		end
	end

	for i = 1, 15 * self.Scale do
		local Dust = self.Emitter:Add("particle/smokesprites_000" .. math.random(1, 9), self.Pos)

		if Dust then
			Dust:SetVelocity(self.DirVec * math.random(100, 400) * self.Scale + ((VectorRand():GetNormalized() * 400) * self.Scale))
			Dust:SetDieTime(math.Rand(1, 5) * self.Scale)
			Dust:SetStartAlpha(50)
			Dust:SetEndAlpha(0)
			Dust:SetStartSize(80 * self.Scale)
			Dust:SetEndSize(100 * self.Scale)
			Dust:SetRoll(math.Rand(150, 360))
			Dust:SetRollDelta(math.Rand(-1, 1))
			Dust:SetAirResistance(250)
			Dust:SetGravity(Vector(math.Rand(-200, 200), math.Rand(-200, 200 ), math.Rand(10, 100 )))
			Dust:SetColor(90, 85, 75)
		end
	end

	for i = 1, 25 * self.Scale do
		local Debris = self.Emitter:Add("effects/fleck_cement" .. math.random(1, 2), self.Pos)

		if Debris then
			Debris:SetVelocity(self.DirVec * math.random(0, 700) * self.Scale + VectorRand():GetNormalized() * math.random(0, 700) * self.Scale)
			Debris:SetDieTime(math.random(1, 2) * self.Scale)
			Debris:SetStartAlpha(255)
			Debris:SetEndAlpha(0)
			Debris:SetStartSize(math.random(5, 10) * self.Scale)
			Debris:SetRoll(math.Rand(0, 360))
			Debris:SetRollDelta(math.Rand(-5, 5))
			Debris:SetAirResistance(40)
			Debris:SetColor(60, 60, 60)
			Debris:SetGravity(Vector(0, 0, -600))
		end
	end

	local Angle = self.DirVec:Angle()

	for i = 1, self.DebrizzlemyNizzle do --This part makes the trailers
		Angle:RotateAroundAxis(Angle:Forward(), 360 / self.DebrizzlemyNizzle)

		local DustRing = Angle:Up()
		local RanVec = self.DirVec * math.Rand(1, 5) + (DustRing * math.Rand(2, 5))

		for k = 3, self.Particles do
			local Rcolor = math.random(-20, 20)

			local particle = self.Emitter:Add( "particle/smokesprites_000" .. math.random(1, 9), self.Pos)
			particle:SetVelocity((VectorRand():GetNormalized() * math.Rand(1, 2) * self.Size) + (RanVec * self.Size * k * 3.5))
			particle:SetDieTime(math.Rand(0.5, 4) * self.Scale)

			particle:SetStartAlpha(math.Rand(90, 100))
			particle:SetEndAlpha(0)
			particle:SetGravity((VectorRand():GetNormalized() * math.Rand(5, 10) * self.Size) + Vector(0, 0, -50))
			particle:SetAirResistance(200 + self.Scale * 20)
			particle:SetStartSize((5 * self.Size) - ((k / self.Particles) * self.Size * 3))
			particle:SetEndSize((20 * self.Size) - ((k / self.Particles) * self.Size))
			particle:SetRoll(math.random(-500, 500) / 100)

			particle:SetRollDelta(math.random(-0.5, 0.5))
			particle:SetColor(90 + Rcolor, 87 + Rcolor, 80 + Rcolor)
		end
	end
 end

function EFFECT:Think( )
	return false
end

function EFFECT:Render()
end
--addons/egm_tfa_grenades/lua/effects/tfa_csgo_poisonade/init.lua:
--Thanks Inconceivable/Generic Default
function EFFECT:Init(data)
	self.Entity = data:GetEntity()
	if not IsValid(self.Entity) then return end

	self.Duration = self.Entity:GetNWInt("duration", 5)

	pos = data:GetOrigin()
	self.Emitter = ParticleEmitter(pos)

	for i = 1, 25 do
		local particle = self.Emitter:Add( "tfa_csgo/particle/particle_smokegrenade", pos)
		if (particle) then
			particle:SetVelocity(VectorRand():GetNormalized() * math.Rand(150, 300) )
			particle:SetDieTime(math.Rand(self.Duration, self.Duration * 1.25))
			particle:SetStartAlpha(math.Rand( 116, 216 ))
			particle:SetEndAlpha(0)
			particle:SetStartSize(116)
			particle:SetEndSize(216)
			particle:SetRoll(math.Rand(0, 360) )
			particle:SetRollDelta(math.Rand(-1, 1) / 3)
			particle:SetColor(140, 40, 40)
			particle:SetAirResistance(82)
			particle:SetCollide(true)
			particle:SetBounce(1)
		end
	end
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()

end
--addons/tfa_base/lua/effects/tfa_muzzle_smoketrail/init.lua:
local vector_origin = Vector()

local smokecol = Color(225, 225, 225, 200)
local smokemat = Material("trails/smoke")
smokemat:SetInt("$nocull", 1)

function EFFECT:AddPart()
	local pos, rawdat, norm
	pos = self.startpos
	norm = self.startnormal

	if self.targent and self.targatt then
		--pos = self:GetTracerShootPos(self.startpos, self.targent, self.targatt)
		rawdat = self.targent:GetAttachment(self.targatt)

		if rawdat then
			pos = rawdat.Pos
			norm = rawdat.Ang:Forward()
		end
	end

	local p = {}
	p.position = pos
	p.normal = norm
	p.velocity = p.normal * 5
	p.startlife = CurTime()
	p.lifetime = self.lifetime
	p.radius = self.radius

	if self.vparticles then
		table.insert(self.vparticles, #self.vparticles + 1, p)
	end
end

function EFFECT:ProcessFakeParticles()
	self.stepcount = self.stepcount + 1

	if self.vparticles then
		if CurTime() < self.emittime and self.stepcount % self.partinterval == 0 then
			self:AddPart()
		end

		for k, v in ipairs(self.vparticles) do
			v.position = v.position + v.velocity * FrameTime()
			v.velocity = v.velocity + self.grav * FrameTime()

			if CurTime() > v.startlife + v.lifetime then
				--print("Curtime:"..CurTime())
				--print("Lifetime:"..v.lifetime)
				--print("CTime:"..v.startlife)
				table.remove(self.vparticles, k)
			end
		end

		if #self.vparticles <= 0 then
			return false
		else
			return true
		end
	else
		return true
	end
end

local cv_gr = GetConVar("sv_gravity")

function EFFECT:Init(ef)
	self.lifetime = 1
	self.stepcount = 0
	self.partinterval = 3
	self.emittime = CurTime() + 3
	self.targent = ef:GetEntity()
	self.targatt = ef:GetAttachment()
	self.startpos = ef:GetOrigin()
	self.startnormal = ef:GetNormal()
	self.radius = ef:GetRadius()
	self.grav = Vector(0, 0, cv_gr:GetFloat() * 0.2)
	self.randfac = 1

	if not self.startpos then
		self.startpos = vector_origin

		if LocalPlayer():IsValid() then
			self.startpos = LocalPlayer():GetShootPos()
		end
	end

	if not self.startnormal then
		self.startnormal = vector_origin
	end

	if not self.radius or self.radius == 0 then
		self.radius = 1
	end

	self.vparticles = {}
	self:AddPart()
end

function EFFECT:Think()
	if self.vparticles and #self.vparticles <= 0 then return false end

	return true
end

function EFFECT:DrawBeam()
	render.StartBeam(#self.vparticles)

	for k, v in ipairs(self.vparticles) do
		local alphac = ColorAlpha(smokecol, (1 - (CurTime() - v.startlife) / v.lifetime) * 64)
		render.AddBeam(v.position, v.radius * (1 - k / #self.vparticles), k / #self.vparticles, alphac)
	end

	render.EndBeam()
end

function EFFECT:Render()
	self:ProcessFakeParticles()

	if self.vparticles and #self.vparticles >= 2 then
		render.SetMaterial(smokemat)
		self:DrawBeam()
	end
end

--addons/tfa_base/lua/effects/tfa_muzzleflash_energy/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.15
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 0
EFFECT.SparkSize = 1.25
EFFECT.HeatSize = 1
EFFECT.Color = Color(128,192,255)
EFFECT.ColorSprites = true

--addons/tfa_base/lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 96
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--addons/tfa_base/lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 96
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--addons/tfa_base/lua/effects/tfa_muzzleflash_silenced/init.lua:
include("tfa/muzzleflash_base.lua")

EFFECT.Life = 0.1
EFFECT.XFlashSize = 0
EFFECT.FlashSize = 0.1
EFFECT.SmokeSize = 2
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 225, 128)
EFFECT.ColorSprites = false


--addons/tfa_base/lua/tfa/muzzleflash_base.lua:
local vector_origin = Vector()

EFFECT.Life = 0.1
EFFECT.XFlashSize = 1
EFFECT.FlashSize = 1
EFFECT.SmokeSize = 1
EFFECT.SparkSize = 1
EFFECT.HeatSize = 1
EFFECT.Color = Color(255, 192, 64)
EFFECT.ColorSprites = false

local AddVel = Vector()
local ang

function EFFECT:Init(data)
	self.WeaponEnt = data:GetEntity()
	if not IsValid(self.WeaponEnt) then return end
	self.Attachment = data:GetAttachment()
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)

	if IsValid(self.WeaponEnt:GetOwner()) then
		if self.WeaponEnt:GetOwner() == LocalPlayer() then
			if self.WeaponEnt:GetOwner():ShouldDrawLocalPlayer() then
				ang = self.WeaponEnt:GetOwner():EyeAngles()
				ang:Normalize()
				--ang.p = math.max(math.min(ang.p,55),-55)
				self.Forward = ang:Forward()
			else
				self.WeaponEnt = self.WeaponEnt.OwnerViewModel
			end
			--ang.p = math.max(math.min(ang.p,55),-55)
		else
			ang = self.WeaponEnt:GetOwner():EyeAngles()
			ang:Normalize()
			self.Forward = ang:Forward()
		end
	end

	self.Forward = self.Forward or data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	self.vOffset = self.Position
	local dir = self.Forward
	local ownerent = self.WeaponEnt:GetOwner()

	if not IsValid(ownerent) then
		ownerent = LocalPlayer()
	end

	AddVel = ownerent:GetVelocity()
	self.vOffset = self.Position
	AddVel = AddVel * 0.05
	local dot = dir:GetNormalized():Dot(GetViewEntity():EyeAngles():Forward())
	local halofac = math.abs(dot)
	local epos = ownerent:EyePos()
	local dlight = DynamicLight(ownerent:EntIndex())

	if (dlight) then
		dlight.pos = epos + ownerent:EyeAngles():Forward() * self.vOffset:Distance(epos) --self.vOffset - ownerent:EyeAngles():Right() * 5 + 1.05 * ownerent:GetVelocity() * FrameTime()
		dlight.r = self.Color.r
		dlight.g = self.Color.g
		dlight.b = self.Color.b
		dlight.brightness = 4.5
		dlight.decay = 200 / self.Life
		dlight.size = self.FlashSize * 96
		dlight.dietime = CurTime() + self.Life
	end

	self.Dist = self.vOffset:Distance(epos)
	self.DLight = dlight
	self.DieTime = CurTime() + self.Life
	self.OwnerEnt = ownerent
	local emitter = ParticleEmitter(self.vOffset)
	local sval = 1 - math.random(0, 1) * 2

	if self.WeaponEnt.XTick == nil then
		self.WeaponEnt.XTick = 0
	end

	self.WeaponEnt.XTick = 1 - self.WeaponEnt.XTick

	if self.WeaponEnt.XTick == 1 and self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.XFlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(3 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			particle:SetEndSize(15 * (halofac * 0.8 + 0.2) * self.XFlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
		--particle:SetStartSize( 8 * (halofac*0.8+0.2), 0, 1)
		--particle:SetEndSize( 0 )
	elseif self.XFlashSize > 0 then
		local particle = emitter:Add(self.ColorSprites and "effects/muzzleflashx_nemole_w" or "effects/muzzleflashx_nemole", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 4 * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life / 2)
			particle:SetStartAlpha(math.Rand(200, 255))
			particle:SetEndAlpha(0)
			particle:SetStartSize(2 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			particle:SetEndSize(6 * (halofac * 0.8 + 0.2) * 0.3 * self.FlashSize)
			local r = math.Rand(-10, 10) * 3.14 / 180
			particle:SetRoll(r)
			particle:SetRollDelta(r / 5)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
			particle:SetPos(vector_origin)
		end
	end

	local flashCount = math.Round(self.FlashSize * 8)

	for i = 1, flashCount do
		local particle = emitter:Add(self.ColorSprites and "effects/scotchmuzzleflashw" or "effects/scotchmuzzleflash4", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 300 * (0.2 + (i / flashCount) * 0.8) * self.FlashSize)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(math.Rand(128, 255))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			local szsc = 1 + (flashCount - i) * math.pow(1 / flashCount * 0.9,0.8)
			particle:SetStartSize(1.25 * math.Rand(1, 1.5) * szsc * self.FlashSize)
			particle:SetEndSize(6 * math.Rand(0.75, 1) * szsc * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	for _ = 1, flashCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + FrameTime() * AddVel)

		if (particle) then
			particle:SetVelocity(dir * 6 * self.FlashSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 1)
			particle:SetStartAlpha(math.Rand(40, 140))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(2 * math.Rand(1, 1.5) * self.FlashSize)
			particle:SetEndSize(20 * math.Rand(0.5, 1) * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(30, 60)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			--TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	local glowCount = math.ceil(self.FlashSize * 3)

	for i = 1, glowCount do
		local particle = emitter:Add("effects/scotchmuzzleflash1", self.vOffset + dir * 0.9 * i)

		if (particle) then
			--particle:SetVelocity(dir * 32 )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * 0.75)
			particle:SetStartAlpha(255 * (1 - halofac))
			particle:SetEndAlpha(0)
			--particle:SetStartSize( 7.5 * (halofac*0.8+0.2), 0, 1)
			--particle:SetEndSize( 0 )
			particle:SetStartSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.2 * self.FlashSize)
			particle:SetEndSize(math.max(12 - 12 / glowCount * i * 0.5, 1) * 0.6 * self.FlashSize)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetRollDelta(math.rad(math.Rand(15, 30)) * sval)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, 255, 255)
			end

			particle:SetLighting(false)
			particle.FollowEnt = self.WeaponEnt
			particle.Att = self.Attachment
			TFA.Particles.RegisterParticleThink(particle, TFA.Particles.FollowMuzzle)
		end
	end

	if TFA.GetMZFSmokeEnabled() then
		local smokeCount = math.ceil(self.SmokeSize * 6)

		for _ = 0, smokeCount do
			local particle = emitter:Add("particles/smokey", self.vOffset + dir * math.Rand(3, 14))

			if (particle) then
				particle:SetVelocity(VectorRand() * 10 * self.SmokeSize + dir * math.Rand(35, 50) * self.SmokeSize + 1.05 * AddVel)
				particle:SetDieTime(math.Rand(0.6, 1) * self.Life * 6)
				particle:SetStartAlpha(math.Rand(12, 24))
				particle:SetEndAlpha(0)
				particle:SetStartSize(math.Rand(5, 7) * self.SmokeSize)
				particle:SetEndSize(math.Rand(15, 20) * self.SmokeSize)
				particle:SetRoll(math.rad(math.Rand(0, 360)))
				particle:SetRollDelta(math.Rand(-0.8, 0.8))
				particle:SetLighting(true)
				particle:SetAirResistance(20)
				particle:SetGravity(Vector(0, 0, 60))
				particle:SetColor(255, 255, 255)
			end
		end
	end

	local sparkcount = math.Round(math.random(8, 12) * self.SparkSize)

	for _ = 0, sparkcount do
		local particle = emitter:Add("effects/yellowflare", self.Position)

		if (particle) then
			particle:SetVelocity( VectorRand() * 30 * self.SparkSize)
			particle:SetVelocity(particle:GetVelocity() + 1.15 * AddVel )
			particle:SetVelocity( particle:GetVelocity() + dir * math.Rand(80, 100) * (1-math.abs(math.max(particle:GetVelocity():GetNormalized():Dot(-dir),0))) * self.SparkSize )
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life * math.Rand(0.9,1.1))
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(0.6)
			particle:SetEndSize(1)
			particle:SetRoll(math.rad(math.Rand(0, 360)))
			particle:SetGravity(vector_origin)
			particle:SetAirResistance(1)
			particle:SetStartLength(0.1)
			particle:SetEndLength(0.05)

			if self.ColorSprites then
				particle:SetColor(self.Color.r, self.Color.g, self.Color.b)
			else
				particle:SetColor(255, math.random(192, 225), math.random(140, 192))
			end

			particle:SetVelocityScale(true)
			local sl = self.SparkSize

			particle:SetThinkFunction(function(pa)
				math.randomseed(SysTime())
				local spd = pa:GetVelocity():Length()*12
				pa.ranvel = pa.ranvel or VectorRand() * spd
				pa.ranvel:Add(VectorRand() * spd * math.sqrt(FrameTime()))
				pa:SetVelocity(pa:GetVelocity() + pa.ranvel * sl * FrameTime() )
				pa:SetNextThink(CurTime())
			end)

			particle:SetNextThink(CurTime() + 0.01)
		end
	end

	if TFA.GetGasEnabled() then
		local particle = emitter:Add("sprites/heatwave", self.vOffset + dir*2)

		if (particle) then
			particle:SetVelocity(dir * 25 * self.HeatSize + 1.05 * AddVel)
			particle:SetLifeTime(0)
			particle:SetDieTime(self.Life)
			particle:SetStartAlpha(math.Rand(200, 225))
			particle:SetEndAlpha(0)
			particle:SetStartSize(math.Rand(3, 5) * self.HeatSize)
			particle:SetEndSize(math.Rand(8, 12) * self.HeatSize)
			particle:SetRoll(math.Rand(0, 360))
			particle:SetRollDelta(math.Rand(-2, 2))
			particle:SetAirResistance(5)
			particle:SetGravity(Vector(0, 0, 40))
			particle:SetColor(255, 255, 255)
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	if CurTime() > (self.DieTime or 0) then
		return false
	elseif self.DLight and IsValid(self.OwnerEnt) then
		self.DLight.pos = self.OwnerEnt:EyePos() + self.OwnerEnt:EyeAngles():Forward() * self.Dist
	end

	return true
end

function EFFECT:Render()
end
--lua/effects/tfa_tracer_fubar_aq/init.lua:
TRACER_FLAG_USEATTACHMENT       = 0x0002;
SOUND_FROM_WORLD                        = 0;
CHAN_STATIC                                     = 6;

EFFECT.InValid = false;

function EFFECT:Init( data )	

		self.Position = data:GetStart()
		self.WeaponEnt = data:GetEntity()
		self.Attachment = data:GetAttachment()
		
		-- Keep the start and end pos - we're going to interpolate between them
		self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
		
        self.EndPos = data:GetOrigin()
		
        util.ParticleTracerEx("weapon_fubar_trail_aq", self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)

end

function EFFECT:Think()
 
        return false
 
end

function EFFECT:Render()
		
		if self.InValid then return false end
		
end
--lua/effects/tfa_tracer_fubar_light_aq/init.lua:
TRACER_FLAG_USEATTACHMENT       = 0x0002;
SOUND_FROM_WORLD                        = 0;
CHAN_STATIC                                     = 6;

EFFECT.InValid = false;

function EFFECT:Init( data )	

		self.Position = data:GetStart()
		self.WeaponEnt = data:GetEntity()
		self.Attachment = data:GetAttachment()
		
		-- Keep the start and end pos - we're going to interpolate between them
		self.StartPos = self:GetTracerShootPos( self.Position, self.WeaponEnt, self.Attachment )
		
        self.EndPos = data:GetOrigin()
		
        util.ParticleTracerEx("weapon_fubar_beam_aq", self.StartPos, self.EndPos, false, self:EntIndex(), self.Attachment)

end

function EFFECT:Think()
 
        return false
 
end

function EFFECT:Render()
		
		if self.InValid then return false end
		
end
--addons/tfa_base/lua/effects/tfa_tracer_gauss/init.lua:
local vector_origin = Vector()

EFFECT.Thickness = 16
EFFECT.Life = 0.25
EFFECT.RotVelocity = 30
EFFECT.InValid = false
local Mat_Impact = Material("effects/combinemuzzle2")
local Mat_Beam = Material("effects/tool_tracer")
local Mat_TracePart = Material("effects/select_ring")

function EFFECT:Init(data)
	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()

	if IsValid(self.WeaponEnt) and self.WeaponEnt.GetMuzzleAttachment then
		self.Attachment = self.WeaponEnt:GetMuzzleAttachment()
	end

	local owent

	if IsValid(self.WeaponEnt) then
		owent = self.WeaponEnt:GetOwner()

		if not IsValid(owent) then
			owent = self.WeaponEnt:GetParent()
		end
	end

	if IsValid(owent) and owent:IsPlayer() then
		if owent ~= LocalPlayer() or owent:ShouldDrawLocalPlayer() then
			self.WeaponEnt = owent:GetActiveWeapon()
			if not IsValid(self.WeaponEnt) then return end
		else
			local theirweapon = self.WeaponEnt
			self.WeaponEnt = self.WeaponEnt.OwnerViewModel

			if IsValid(theirweapon) and theirweapon.ViewModelFlip or theirweapon.ViewModelFlipped then
				self.Flipped = true
			end

			if not IsValid(self.WeaponEnt) then return end
		end
	end

	local angpos

	if IsValid(self.WeaponEnt) then
		angpos = self.WeaponEnt:GetAttachment(self.Attachment)
	end

	if not angpos or not angpos.Pos then
		angpos = {
			Pos = vector_origin,
			Ang = angle_zero
		}
	end


	if self.Flipped then
		local tmpang = (self.Dir or angpos.Ang:Forward()):Angle()
		local localang = self.WeaponEnt:WorldToLocalAngles(tmpang)
		localang.y = localang.y + 180
		localang = self.WeaponEnt:LocalToWorldAngles(localang)
		--localang:RotateAroundAxis(localang:Up(),180)
		--tmpang:RotateAroundAxis(tmpang:Up(),180)
		self.Dir = localang:Forward()
	end

	-- Keep the start and end Pos - we're going to interpolate between them
	if IsValid(owent) and self.Position:Distance(owent:EyePos()) > 72 then
		self.WeaponEnt = nil
	end

	self.StartPos = self:GetTracerShootPos(self.WeaponEnt and angpos.Pos or self.Position, self.WeaponEnt, self.Attachment)
	self.EndPos = data:GetOrigin()
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	self.Normal = (self.EndPos - self.StartPos):GetNormalized()
	self.StartTime = 0
	self.LifeTime = self.Life
	self.data = data
	self.rot = 0
end

function EFFECT:Think()
	if self.InValid then return false end
	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()

	return self.LifeTime > 0
end

local beamcol = table.Copy(color_white)
local beamcol2 = Color(0, 225, 255, 255)

function EFFECT:Render()
	if self.InValid then return false end
	self.StartPos = self:GetTracerShootPos(self.StartPos, self.WeaponEnt, self.Attachment)
	local startPos = self.StartPos
	local endPos = self.EndPos
	local tracerpos
	beamcol.a = self.LifeTime / self.Life * 255
	self.rot = self.rot + FrameTime() * self.RotVelocity
	render.SetMaterial(Mat_Impact)
	render.DrawSprite(endPos, 12, 12, ColorAlpha(color_white, beamcol.a))
	render.SetMaterial(Mat_TracePart)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life - 0.1, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot - 60)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life - 0.05, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot - 30)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life + 0.05, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot + 30)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life + 0.1, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot + 60)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life + 0.15, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot + 30)
	tracerpos = Lerp(math.Clamp(self.LifeTime / self.Life + 0.2, 0, 1), endPos, startPos)
	render.DrawQuadEasy(tracerpos, self.Normal, 12, 12, beamcol2, self.rot + 60)
	render.SetMaterial(Mat_Beam)
	render.DrawBeam(startPos, endPos, self.Thickness, 0 + beamcol.a / 128, endPos:Distance(startPos) / 64 + beamcol.a / 128, beamcol)
end

--addons/wos-grandmaster-einf/lua/effects/thor_storm/init.lua:

EFFECT.Mat = Material( "trails/electric" )

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	
	self.StartPos = self.Position
	self.EndPos = data:GetOrigin()
	
	local dir = self.StartPos - self.EndPos
	dir:Normalize()
	
	self.Dir = dir
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )
	
	self.Alpha = 100
	self.Color = Color( 0, 255, 255, self.Alpha )
	
	local dlight = DynamicLight( self:EntIndex() )
	
	if dlight then
	
		dlight.Pos = self.StartPos
		dlight.r = 255
		dlight.g = 150
		dlight.b = 50
		dlight.Brightness = 3
		dlight.Decay = 256
		dlight.size = 256 * math.Rand( 0.5, 1.0 )
		dlight.DieTime = CurTime() + 5
		
	end

end

function EFFECT:Think( )

	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Alpha = self.Alpha - FrameTime() * 200
	self.Color = Color( 255, 255, 255, self.Alpha )
	
	return self.Alpha > 0

end

function EFFECT:Render( )

	if self.Alpha < 1 then return end
	
	--[[self.Length = ( self.StartPos - self.EndPos ):Length()
	
	render.SetMaterial( self.Mat )
	render.DrawBeam( self.StartPos, self.EndPos, ( 100 / self.Alpha ) * 0.5 + 0.5, 0, 0, self.Color )]]
	
	if ( self.Alpha < 1 ) then return end

	self.Length = (self.StartPos - self.EndPos):Length()
		
	local texcoord = CurTime() * -0.2
	
	for i = 1, 10 do
	
		render.SetMaterial( self.Mat )
		
		texcoord = texcoord + i * 0.05 * texcoord
	
		render.DrawBeam( self.StartPos, 										
						self.EndPos,											
						i * self.Alpha * 0.03,									
						texcoord,												
						texcoord + (self.Length / (128 + self.Alpha)),		
						self.Color )
						

		render.DrawSprite( self.StartPos + self.Dir * i, i * 5, i * 5, Color( self.Color.r, self.Color.g, self.Color.b, self.Alpha ) )
		render.DrawSprite( self.EndPos, i * 5, i * 5, Color( self.Color.r, self.Color.g, self.Color.b, self.Alpha ) )
	
	end

end

--addons/wos-grandmaster-einf/lua/effects/thor_strike/init.lua:

EFFECT.Mat = Material( "trails/electric" )

function EFFECT:Init( data )

	self.Position = data:GetStart()
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	
	self.StartPos = data:GetOrigin()
	self.EndPos = data:GetStart()
	
	local dir = self.StartPos - self.EndPos
	dir:Normalize()
	
	self.Dir = dir
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )
	
	self.Alpha = 100
	self.Color = Color( 0, 255, 255, self.Alpha )
	
	local dlight = DynamicLight( self:EntIndex() )
	
	if dlight then
	
		dlight.Pos = self.StartPos
		dlight.r = 255
		dlight.g = 150
		dlight.b = 50
		dlight.Brightness = 3
		dlight.Decay = 256
		dlight.size = 256 * math.Rand( 0.5, 1.0 )
		dlight.DieTime = CurTime() + 5
		
	end

end

function EFFECT:Think( )

	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	self.Alpha = self.Alpha - FrameTime() * 200
	self.Color = Color( 255, 255, 255, self.Alpha )
	
	return self.Alpha > 0

end

function EFFECT:Render( )

	if self.Alpha < 1 then return end
	
	--[[self.Length = ( self.StartPos - self.EndPos ):Length()
	
	render.SetMaterial( self.Mat )
	render.DrawBeam( self.StartPos, self.EndPos, ( 100 / self.Alpha ) * 0.5 + 0.5, 0, 0, self.Color )]]
	
	if ( self.Alpha < 1 ) then return end

	self.Length = (self.StartPos - self.EndPos):Length()
		
	local texcoord = CurTime() * -0.2
	
	for i = 1, 10 do
	
		render.SetMaterial( self.Mat )
		
		texcoord = texcoord + i * 0.05 * texcoord
	
		render.DrawBeam( self.StartPos, 										
						self.EndPos,											
						i * self.Alpha * 0.03,									
						texcoord,												
						texcoord + (self.Length / (128 + self.Alpha)),		
						self.Color )
						

		render.DrawSprite( self.StartPos + self.Dir * i, i * 5, i * 5, Color( self.Color.r, self.Color.g, self.Color.b, self.Alpha ) )
		render.DrawSprite( self.EndPos, i * 5, i * 5, Color( self.Color.r, self.Color.g, self.Color.b, self.Alpha ) )
	
	end

end

--addons/wos-alcs-darkaspp/lua/effects/wos_alcs_beamdrive/init.lua:

PrecacheParticleSystem( "[4]b1_m" )

function EFFECT:Init( data )

	local ent = data:GetEntity()
	local vec = data:GetAngles()
	
	self.Particle = CreateParticleSystem( ent, "[4]b1_m", PATTACH_POINT, ent:LookupAttachment( "anim_attachment_RH" ) ) 
	self.Particle:SetControlPointOrientation( 0, vec:Forward(), vec:Right(), vec:Up() )
	self.LifeTime = CurTime() + 0.25
	
end

function EFFECT:Think()
	if self.LifeTime < CurTime() then
		self.Particle:StopEmission( false, true )
		return false
	end
	return true
end

function EFFECT:Render()
end

--addons/wos-grandmaster-einf/lua/effects/wos_corrupted_burn/init.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()
	local len = data:GetRadius()
	local color = data:GetAngles()
	local emitter = ParticleEmitter( pos )

	local number_lol = 1

	if ( !emitter ) then return end

	for i = 0, len / number_lol do
		local pos2 = pos + dir * ( len - i * number_lol )
		--local particle = emitter:Add( "effects/muzzleflash"..math.random(1,4), pos2 )
		local particle = emitter:Add( "particle/bendibeam", pos2 )
		if ( particle ) then
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 0.3 )

			particle:SetGravity( Vector( 0, 0, math.random( 32, 128 ) ) )
			particle:SetVelocity( Vector( math.random( -8, 8 ), math.random( -8, 8 ), math.random( -8, 8 ) ) )

			particle:SetStartSize( 1 )
			particle:SetEndSize( 0 )

			particle:SetStartAlpha( math.random( 100, 200 ) )
			particle:SetEndAlpha( 0 )

			particle:SetColor( color.p, color.y, color.r )
			particle:SetAngleVelocity( Angle( math.Rand( -180, 180 ), math.Rand( -180, 180 ), math.Rand( -180, 180 ) ) )
			//particle:SetLighting( true )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--addons/wos-alcs-icefusepp/lua/effects/wos_emerald_lightning.lua:

local function GetRandomPositionInBox( mins, maxs, ang )
	return ang:Up() * math.random( mins.z, maxs.z ) + ang:Right() * math.random( mins.y, maxs.y ) + ang:Forward() * math.random( mins.x, maxs.x )
end

local function GenerateLighting( from, to, deviations, power )
	local start = from
	if ( isentity( start ) ) then start = from:GetPos() end
	local endpos = to:GetPos()
	local wep = to:GetActiveWeapon() 
	--render.DrawWireframeBox( start, Angle(0, 0, 0),from:OBBMins(), from:OBBMaxs(), Color(255, 0, 0), true )
	--render.DrawWireframeBox( start, to:GetAngles(),from:OBBMins(), from:OBBMaxs(), Color(0, 255, 0), true )

	--start = start + GetRandomPositionInBox( from:OBBMins(), from:OBBMaxs(), from:GetAngles() )
	endpos = endpos + GetRandomPositionInBox( to:OBBMins(), to:OBBMaxs(), to:GetAngles() )
	if to:GetNWFloat( "BlockTime", 0 ) >= CurTime() then
		if IsValid( wep ) then
			if wep.IsLightsaber then
				local len = wep:GetMaxLength()
				local pos, dir = wep:GetSaberPosAng()
				endpos = wep:GetSaberPosAng() + dir*len/2
			end
		end
	end
	
	local right = (start - endpos):Angle():Right()
	local up = (start - endpos):Angle():Up()
	local segments = {
		{ start, endpos }
	}
	for i = 0, power do
		local newsegs = {}
		for id, seg in pairs( segments ) do
			local mid = Vector( (seg[1].x + seg[2].x) / 2, (seg[1].y + seg[2].y) / 2, (seg[1].z + seg[2].z) / 2 )
			local offsetpos = mid + right * math.random( -deviations, deviations ) + up * math.random( -deviations, deviations )
			table.insert( newsegs, {seg[1], offsetpos} )
			table.insert( newsegs, {offsetpos, seg[2]} )
		end
		segments = newsegs
	end
	return segments
end

local function GenerateLightingSegs( from, to, deviations, segs )
	local start = from
	if ( isentity( start ) ) then start = from:GetPos() end
	local endpos = to:GetPos()

	--render.DrawWireframeBox( start, Angle(0, 0, 0),from:OBBMins(), from:OBBMaxs(), Color(255, 0, 0), true )
	--render.DrawWireframeBox( start, to:GetAngles(),from:OBBMins(), from:OBBMaxs(), Color(0, 255, 0), true )

	--start = start + GetRandomPositionInBox( from:OBBMins(), from:OBBMaxs(), from:GetAngles() )
	endpos = endpos + GetRandomPositionInBox( to:OBBMins(), to:OBBMaxs(), to:GetAngles() )

	local right = (start - endpos):Angle():Right()
	local up = (start - endpos):Angle():Up()
	local fwd = (start - endpos):Angle():Forward()
	local step = (1 / segs) * start:Distance( endpos )

	local lastpos = start
	local segments = {}
	for i = 1, segs do
		local a = lastpos - fwd * step
		table.insert( segments, { lastpos, a } )
		lastpos = a
	end

	for k, v in pairs( segments ) do
		if ( k == 1 || k == #segments ) then continue end

		segments[ k ][ 1 ] = segments[ k ][ 1 ] + right * math.random( -deviations, deviations ) + up * math.random( -deviations, deviations )
		segments[ k - 1 ][ 2 ] = segments[ k ][ 1 ]
	end

	for k, v in pairs( segments ) do
		if ( k == 1 || k == #segments ) then continue end

		if ( math.random( 0, 100 ) > 75 ) then
			local dir = AngleRand():Forward()
			table.insert( segments, { segments[ k ][ 1 ], segments[ k ][ 1 ] + dir * ( step * math.Rand( 0.2, 0.6 ) ) } )
		end
	end

	return segments
end

local mats = {
	(Material( "cable/crystal_beam1" )),
	/*(Material( "cable/hydra" )),
	(Material( "cable/redlaser" )),
	(Material( "cable/crystal_beam1" )),
	(Material( "cable/physbeam" )),
	(Material( "cable/smoke" )),
	(Material( "cable/xbeam" )),*/
}

local segments = {}
--local n = 0
local tiem = .2
hook.Add( "PostDrawTranslucentRenderables", "wOS.EmeraldLightningDrawShit", function()
	--if ( #segments < 1 || n < CurTime() ) then
		--
		/*for i = 0, 1 do
			table.insert( segments, {
				segs = GenerateLighting( table.Random( ents.FindByClass( "prop_physics" ) ), table.Random( ents.FindByClass( "prop_physics" ) ), math.random( 10, 20 ), 3 ),
				mat = table.Random( mats ),
				time = CurTime() + tiem,
				w = math.random( 20, 50 )
			} )
		end*/
		--n = CurTime() + .01
	--end

	for id, t in pairs( segments ) do
		if ( t.time < CurTime() ) then table.remove( segments, id ) continue end
		render.SetMaterial( t.mat )
		for id, seg in pairs( t.segs ) do
			render.DrawBeam( seg[1], seg[2], ( math.max( t.startpos:Distance( t.endpos ) - seg[1]:Distance( t.endpos ), 20) / ( t.startpos:Distance( t.endpos ) ) * t.w ) * ( (t.time - CurTime() ) / tiem ), 0, seg[1]:Distance( seg[2] ) / 25, Color( 255, 255, 0, 255 ) )
			--render.DrawBeam( seg[1], seg[2], (id / #t.segs * t.w ) * ((t.time - CurTime()) / tiem), 0, seg[1]:Distance( seg[2] ) / 25, Color( 255, 255, 255 ) )
		end
	end
end )


function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local ent = data:GetEntity()

	if ( !IsValid( ent ) ) then return end

	table.insert( segments, {
		--segs = GenerateLighting( pos, ent, math.random( 10, 20 ), 3 ),
		segs = GenerateLightingSegs( pos, ent, math.random( 10, 20 ), pos:Distance( ent:GetPos() ) / 48 ), --math.random( 5, 10 ) ),
		mat = table.Random( mats ),
		time = CurTime() + tiem,
		w = math.random( 20, 50 ),
		startpos = pos,
		endpos = ent:GetPos()
	} )
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
	/*for id, t in pairs( segments ) do
		if (t.time < CurTime() ) then table.remove( segments, id ) continue end
		render.SetMaterial( t.mat )
		for id, seg in pairs( t.segs ) do
			render.DrawBeam( seg[1], seg[2], (id / #t.segs * t.w ) * ((t.time - CurTime()) / tiem), 0, seg[1]:Distance( seg[2] ) / 25, Color( 255, 255, 255 ) )
		end
	end*/
end

--addons/wos-grandmaster-einf/lua/effects/wos_exec_playergib/init.lua:

function EFFECT:Init( data )	
	local scale = data:GetScale()
	if scale < 2 then
		self:SetModel( table.Random( wOS.ALCS.ExecSys.SmallGibTable ) )
	else
		self:SetModel( table.Random( wOS.ALCS.ExecSys.BigGibTable ) ) 
	end
	self:PhysicsInit( SOLID_VPHYSICS )	self:SetMoveType( MOVETYPE_VPHYSICS )	
	self:SetMaterial( "models/flesh" )
	self:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
	self:SetCollisionBounds( Vector( -128 -128, -128 ), Vector( 128, 128, 128 ) )
	self:SetAngles( Angle( math.Rand(0,360), math.Rand(0,360), math.Rand(0,360) ) )
	local phys = self:GetPhysicsObject()
	if IsValid( phys ) then
		local vec = VectorRand()
		vec.z = math.Clamp( vec.z, -0.4, 0.8 )		
		phys:Wake()
		phys:SetMass( 100 )
		phys:AddAngleVelocity( VectorRand() * 500 )
		phys:SetMaterial( "gmod_silent" )		
		if scale < 2 then
			phys:SetVelocity( vec * math.Rand( 100, 200 ) )
		else
			phys:SetVelocity( vec * math.Rand( 300, 600 ) )
		end
	end
	self.LifeTime = CurTime() + 8	self.SoundTime = CurTime() + math.Rand( 0.2, 0.6 )
end

function EFFECT:Think()
	return self.LifeTime > CurTime()
end
function EFFECT:PhysicsCollide()end
function EFFECT:Render()
	self:DrawModel()
end


--gamemodes/egmrp/gamemode/core/localization/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Localization index         --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

local language = Config.Language
Localization = {}

if SERVER then
    AddCSLuaFile("localization/" .. language .. ".lua")

    -- Load EGM:RP localization.
    include("localization/" .. language .. ".lua")

    AddCSLuaFile("sh_localization.lua")
    include("sh_localization.lua")
end

if CLIENT then
    -- Load EGM:RP localization.
    include("localization/" .. language .. ".lua")

    -- Load derived Gamemode localization.
    --include("../../../localization/" .. language .. ".lua")

    include("sh_localization.lua")
end
--gamemodes/egmrp/gamemode/core/propertymodel/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Property model index        --
---------------------------------------

PropertyModel = PropertyModel or {}
PropertyList = PropertyList or {}

if SERVER then
    AddCSLuaFile("sh_propertymodel.lua")
    AddCSLuaFile("sh_propertymodel_meta.lua")
    AddCSLuaFile("cl_propertymodel.lua")
    AddCSLuaFile("cl_propertymodel_meta.lua")

    AddCSLuaFile("cl_propertylist.lua")

    local propertyListFiles = file.Find("egmrp/gamemode/core/propertymodel/propertylist/*", "LUA")
    for _, propertyListFile in pairs(propertyListFiles) do
        AddCSLuaFile("propertylist/" .. propertyListFile)
    end

    include("sh_propertymodel.lua")
    include("sh_propertymodel_meta.lua")

    InitServersidePropertyModel()
    InitServersidePropertyModelMeta()
end

if CLIENT then
    include("sh_propertymodel.lua")
    include("sh_propertymodel_meta.lua")
    include("cl_propertymodel.lua")
    include("cl_propertymodel_meta.lua")

    include("cl_propertylist.lua")
end
--gamemodes/egmrp/gamemode/core/propertymodel/cl_propertymodel_meta.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Client | Property model meta   --
---------------------------------------

-- Initializes a data value. Called on property model Init, Load and Create.
-- Checks whether the key and value are valid.
-- The only (but important) difference from SetData is that DataChanged is not called.
--
-- @param String key
-- @param Any value
-- @param? Boolean skipValidation - whether to skip validating of the value. false by default.
-- @return Boolean success
function PropertyModel.Meta:InitData(key, value, skipValidation)
    if self:GetModel():HasData(key) then
        if not skipValidation and not self:IsDataValid(key, value) then
            return false
        end

        self.data[key] = value

        return true
    end

    return false
end

-- Returns the value of the key in the property model's data.
-- Returns the fallback, if the data value is nil.
--
-- @param String key
-- @param? Any fallback
-- @return Any value
function PropertyModel.Meta:Get(key, fallback)
    local value = self.data[key]

    if value == nil then
        return fallback
    end

    return value
end

-- Initializes a property. Called on property model Init, Load and Create.
-- Checks whether the key and value are valid.
-- The only (but important) difference from SetProperty is that PropertyChanged is not called.
--
-- @param String key
-- @param Any value
-- @param? Boolean skipValidation - whether to skip validating of the value. false by default.
-- @return Boolean success
function PropertyModel.Meta:InitProperty(key, value, skipValidation)
    if self:GetModel():HasProperty(key) then
        if not skipValidation and not self:IsPropertyValid(key, value) then
            return false
        end

        self.properties[key] = value

        return true
    end

    return false
end

-- Gets the value associated with the key.
-- Returns the fallback, if the property value is nil or the property does not exist.
--
-- @param String key
-- @param? Any fallback
-- @return Any value
function PropertyModel.Meta:GetProperty(key, fallback)
    local value = self.properties[key]

    if value == nil then
        return fallback
    end

    return value
end

-- Sets a value if it differs from the current value and calls the data changed hook afterwards.
-- Can't check whether a table changed, so tables will always be set.
--
-- @param String key
-- @param Any value
-- @param? Boolean skipValidation - whether to skip the validation process. false by default.
-- @return Boolean success
-- @return? String error
function PropertyModel.Meta:SetData(key, value, skipValidation)
    if not skipValidation then
        local valid, error = self:IsDataValid(key, value)

        if not valid then
            return false, error
        end
    elseif not self:GetModel():HasData(key) then
        return false, egmt("propertymodel.error_no_exist", key)
    end

    local oldValue = self:Get(key)

    if oldValue == value then
        return false, egmt("propertymodel.error_not_changed")
    end

    self.data[key] = value

    hook.Run(self:GetModel().Name .. ".DataChanged", self, key, value, oldValue)

    return true
end

-- Sets the value of the key after validating and calls the property changed hook afterwards.
--
-- @param String key
-- @param Any value
-- @param? Boolean skipValidation - whether to skip the validation process. false by default.
-- @return Boolean success
-- @return? String error
function PropertyModel.Meta:SetProperty(key, value, skipValidation)
    if not skipValidation then
        local valid, error = self:IsPropertyValid(key, value)

        if not valid then
            return false, error
        end
    elseif not self:GetModel():HasProperty(key) then
        return false, egmt("propertymodel.no_exist", key)
    end

    local oldValue = self:GetProperty(key)

    if not self:PropertyValueDiffers(key, value) then
        return false, egmt("propertymodel.not_changed")
    end

    self.properties[key] = value

    hook.Run(self:GetModel().Name .. ".PropertyChanged", self, key, value, oldValue)

    return true
end

-- Tells the server to edit the property model's data.
--
-- @param Table data
-- @return Boolean success
-- @return? Table errors
function PropertyModel.Meta:EditData(data)
    local success, errors = self:IsAllDataValid(false, data)
    if not success then
        return false, errors
    end

    if not self:CanPlayerEditMultipleData(LocalPlayer(), data) then
        return false, {egmt("propertymodel.cant_edit")}
    end

    if self:GetModel().EditNetworkingInitialized then
        -- Do not send unchanged data.
        local toBeDeleted = {}
        for k, v in pairs(data) do
            if not self:DataValueDiffers(k, v) then
                table.insert(toBeDeleted, k)
            end
        end

        for k, v in ipairs(toBeDeleted) do
            data[v] = nil
        end

        if table.Count(data) == 0 then
            return false, {egmt("propertymodel.no_change")}
        end

        data = CompressTable(self:GetModel():ValuesToString(data))

        net.Start(self:GetModel().Name .. ".EditData")
            net.WriteInt(self:GetId(), 32)
            net.WriteInt(#data, 32)
            net.WriteData(data, #data)
        net.SendToServer()

        return true
    end

    return false
end

-- Tells the server to edit a single property.
--
-- @param String key
-- @param Any value
-- @return Boolean success
-- @return? String error
function PropertyModel.Meta:EditProperty(key, value)
    if not self:GetModel().EditNetworkingInitialized then
        return false, egmt("propertymodel.edit_network_not")
    end

    local success, error = self:IsPropertyValid(key, value)
    if not success then
        return false, error
    end

    if not self:CanPlayerEditProperty(LocalPlayer(), key, value) then
        return false, egmt("propertymodel.no_permission")
    end

    if not self:PropertyValueDiffers(key, value) then
        return false, egmt("propertymodel.no_change")
    end

    local properties = CompressTable(self:GetModel():ValuesToString({[key] = value}))

    net.Start(self:GetModel().Name .. ".EditProperties")
        net.WriteInt(self:GetId(), 32)
        net.WriteInt(#properties, 32)
        net.WriteData(properties, #properties)
    net.SendToServer()

    return true
end

-- Tells the server to edit the property model's properties.
--
-- @param Table properties
-- @return Boolean success
-- @return? Table errors
function PropertyModel.Meta:EditProperties(properties)
    if not self:GetModel().EditNetworkingInitialized then
        return false, {egmt("propertymodel.edit_network_not")}
    end

    local success, errors = self:ArePropertiesValid(properties)
    if not success then
        return false, errors
    end

    -- Do not send or check permissions on unchanged properties.
    local toBeDeleted = {}
    for k, v in pairs(properties) do
        if not self:PropertyValueDiffers(k, v) then
            table.insert(toBeDeleted, k)
        end
    end

    for k, v in ipairs(toBeDeleted) do
        properties[v] = nil
    end

    if not self:CanPlayerEditProperties(LocalPlayer(), properties) then
        return false, {egmt("propertymodel.no_permission")}
    end

    if table.Count(properties) == 0 then
        return false, {egmt("propertymodel.no_change")}
    end

    properties = CompressTable(self:GetModel():ValuesToString(properties))

    net.Start(self:GetModel().Name .. ".EditProperties")
        net.WriteInt(self:GetId(), 32)
        net.WriteInt(#properties, 32)
        net.WriteData(properties, #properties)
    net.SendToServer()

    return true
end

-- Removes the property model from cache and tells the server to delete it.
--
-- @return Boolean success
function PropertyModel.Meta:Delete()
    if not self:CanPlayerDelete(LocalPlayer()) then
        return false
    end

    hook.Run(self:GetModel().Name .. ".Delete", self)

    if self:GetModel().DeletionNetworkingInitialized then
        net.Start(self:GetModel().Name .. ".Delete")
            net.WriteInt(self:GetId(), 32)
        net.SendToServer()
    end

    self:RemoveFromCache()

    hook.Run(self:GetModel().Name .. ".PostDelete", self)

    return true
end
--gamemodes/egmrp/gamemode/core/propertymodel/propertylist/color.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Client | Property List      --
---------------------------------------

function PROPERTY_TYPE:CreatePanel(propertyPanel, propertyListData, propertyModel, canEdit)
	local key = propertyListData.key

	local currentValue = propertyListData.default or Color(255, 255, 255, 255)
	if propertyModel then
		currentValue = propertyModel:GetProperty(key, currentValue)
	end

	local colorProperty = vgui.Create("DColorMixer", propertyPanel)
	propertyPanel.ColorProperty = colorProperty

	colorProperty:SetHeight(ScrH() * 0.1)
	colorProperty:Dock(FILL)

	colorProperty:SetColor(Color(currentValue.r, currentValue.g, currentValue.b, currentValue.a))
	colorProperty:SetDisabled(not canEdit)

	colorProperty.Palette:SetButtonSize(ScrH() * 0.015)
	colorProperty.Palette:Dock(LEFT)
	colorProperty.Palette:SetWidth(ScrW() * 0.1)
	colorProperty.Palette:DockMargin( 0, 0, 16, 0 )

	colorProperty.WangsPanel:SetWidth(ScrW() * 0.03)
	colorProperty.WangsPanel:DockMargin( 16, 0, 0, 0 )

	colorProperty.txtR:SetHeight(ScrH() * 0.024)
	colorProperty.txtG:SetHeight(ScrH() * 0.024)
	colorProperty.txtB:SetHeight(ScrH() * 0.024)
	colorProperty.txtA:SetHeight(ScrH() * 0.024)

	colorProperty.txtR:SetFont("EGMText6")
	colorProperty.txtG:SetFont("EGMText6")
	colorProperty.txtB:SetFont("EGMText6")
	colorProperty.txtA:SetFont("EGMText6")

	colorProperty.RGB:SetWidth(ScrW() * 0.02)
	colorProperty.Alpha:SetWidth(ScrW() * 0.02)
end

function PROPERTY_TYPE:GetValue(propertyPanel)
	if not IsValid(propertyPanel.ColorProperty) then
		return Color(255, 255, 255, 255)
	end

	local color = propertyPanel.ColorProperty:GetColor()
	return Color(color.r, color.g, color.b, color.a)
end

-- Check, if the player can edit the propertyListData in some way.
--
-- @param table propertyListData
-- @param Player ply
-- @param PropertyModel propertyModel
function PROPERTY_TYPE:CanEdit(ply, propertyListData, propertyModel)
	-- Checking white should be sufficient.
	-- If the player can edit white, he can edit all colors.
	if propertyModel:CanPlayerEditProperty(ply, propertyListData.key, propertyListData.default or Color(255, 255, 255, 255)) then
		return true
	end

	return false
end
--gamemodes/egmrp/gamemode/core/loading/cl_loadingscreen.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Loading Screen | Client      --
---------------------------------------

function Loading:IsPackageLeft()
    if self.CurrentPackageType == 0 then
        return true
    end

    if self.CurrentPackageType < #self.PackageTypeCounts then
        return true
    end

    if self.CurrentPackageIndex < self.PackageTypeCounts[self.CurrentPackageType].Count then
        return true
    end

    return false
end

function Loading:IsFinished()
    if self.CurrentPackageType == nil then
        return true
    end

    return false
end

function Loading:GetCurrentProgress()
    if self.CurrentPackageType == 0 then
        return 0
    end

    if not istable(self.PackageTypeCounts) then
        return 0
    end

    if self:IsFinished() then
        return 1
    end

    return (self.CurrentPackageType - 1) / #self.PackageTypeCounts
end

function Loading:GetTimePast()
	local startTime = self.StartTime or SysTime()

    return math.Round(SysTime() - startTime, 3)
end

function Loading:GetCurrentPackageName()
    if self.CurrentPackageType == 0 then
        return ""
    end

    local typeName = self.PackageTypeCounts[self.CurrentPackageType].TypeName

    return self.PackageTypes[typeName].Name
end

-- Writes the log Message to the Log
--
-- @param String message
-- @param String color - utilizes GetColor2
-- @param? Number time - overwrites GetTimePast, used for pre window log.
function Loading:WriteLogMessage(message, color, time)
    if not time then
        time = self:GetTimePast()
    end

    local timePrefix = "[" .. time .. "s] "

    self.Menu.Log:AppendText("\n")

    self.Menu.Log:InsertColorChange(GetColor2("lightgray"))
    self.Menu.Log:AppendText(timePrefix)

    self.Menu.Log:InsertColorChange(GetColor2(color or "lightgray"))
    self.Menu.Log:AppendText(message)
end

-- Appends a log message if the loading screen is opened.
-- Uses self.PreWindowLog to store log messages that got generated, before the menu was open.
--
-- @param String message
-- @param String color - utilizes GetColor2
function Loading:AppendLog(message, color)
    if self.Menu and IsValid(self.Menu.Log) then
        if self.PreWindowLog then
            for k, v in pairs(self.PreWindowLog) do
                self:WriteLogMessage(v.message, v.color, v.time)
            end

            self.PreWindowLog = nil
        end

        self:WriteLogMessage(message, color)
    else
        self.PreWindowLog = self.PreWindowLog or {}

        self.PreWindowLog[#self.PreWindowLog + 1] = {message = message, color = color, time = self:GetTimePast()}
    end
end

-- Updates the progress bar if the loading screen is open.
function Loading:UpdateProgress()
    if self.Menu and IsValid(self.Menu.Frame) then
        self.Menu.ProgressBar:SetProgress(self:GetCurrentProgress())

        if self:IsFinished() then
            self.Menu.ProgressBar:SetText(egmt("loading.data_loaded"))
        elseif self:IsPackageLeft() then
            self.Menu.ProgressBar:SetText(egmt("loading.data_loading", self:GetCurrentPackageName()))
        else
            self.Menu.ProgressBar:SetText(egmt("loading.waiting"))
        end
    end
end

-- Opens the loading screen.
function Loading:OpenMenu()
    self:CloseMenu()

    self.StartTime = SysTime()

    self.Menu = {}

    self.Menu.Frame = vgui.Create("EGMFrame")
    self.Menu.Frame:SetBackground(self.Background)
    self.Menu.Frame:EnableCloseButton(false)
    self.Menu.Frame:SetSubTitle(egmt("loading.initialise"))

    self.Menu.ProgressBarBox = vgui.Create("DPanel", self.Menu.Frame)
    self.Menu.ProgressBarBox:SetPos(ScrW() * 0.15, ScrH() * 0.4)
    self.Menu.ProgressBarBox:SetSize(ScrW() * 0.7, ScrH() * 0.12)
    function self.Menu.ProgressBarBox:Paint(width, height)
        draw.RoundedBox(5, 0, 0, width, height, UI.BackgroundColor2)
        draw.SimpleText(
            egmt("loading.percentage", math.Round(Loading:GetCurrentProgress() * 100)),
            "EGMText12",
            width * 0.01,
            height * 0.05, UI.TextColor,
            TEXT_ALIGN_LEFT
        )
    end

    self.Menu.ProgressBar = vgui.Create("EGMProgressBar", self.Menu.ProgressBarBox)
    self.Menu.ProgressBar:SetPos(ScrW() * 0.01, ScrH() * 0.045)
    self.Menu.ProgressBar:SetSize(ScrW() * 0.68, ScrH() * 0.06)
    self.Menu.ProgressBar:SetBackgroundColor(UI.BackgroundColor)
    self.Menu.ProgressBar:SetProgressColor(UI.ForegroundColor)
    self.Menu.ProgressBar:SetTextColor(UI.TextColor)
    self:UpdateProgress()

    self.Menu.LogBox = vgui.Create("DPanel", self.Menu.Frame)
    self.Menu.LogBox:SetPos(ScrW() * 0.1, ScrH() * 0.55)
    self.Menu.LogBox:SetSize(ScrW() * 0.38, ScrH() * 0.4)
    function self.Menu.LogBox:Paint(width, height)
        draw.RoundedBox(5, 0, 0, width, height, UI.BackgroundColor2)
    end

    self.Menu.Log = vgui.Create("Richtext", self.Menu.LogBox)
    self.Menu.Log:SetPos(ScrW() * 0.005, ScrH() * 0.005)
    self.Menu.Log:SetSize(ScrW() * 0.372, ScrH() * 0.39)
    function self.Menu.Log:PerformLayout()
        self:SetFontInternal("EGMText8")
    end

    self.Menu.Play = vgui.Create("EGMButton", self.Menu.Frame)
    self.Menu.Play:SetSize(ScrW() * 0.3, ScrH() * 0.1)
    self.Menu.Play:SetPos(ScrW() * 0.55, ScrH() * 0.7)
    self.Menu.Play:SetTextColor(UI.TextColor)
    self.Menu.Play:SetFont("EGMText15")
    self.Menu.Play:SetText(egmt("loading.play"))
    self.Menu.Play:SetButtonColor(GetColor("green"))
    self.Menu.Play:SetButtonCornerRadius(10)
    self.Menu.Play:SetEnabled(Loading:IsFinished() or false)
    function self.Menu.Play:Think()
        self:SetEnabled(Loading:IsFinished())
    end
    function self.Menu.Play:DoClick()
        CharacterSelection:Open(true)
        Loading:CloseMenu()
    end

    self.Menu.Reconnect = vgui.Create("EGMButton", self.Menu.Frame)
    self.Menu.Reconnect:SetSize(ScrW() * 0.2, ScrH() * 0.05)
    self.Menu.Reconnect:SetPos(ScrW() * 0.49, ScrH() * 0.9)
    self.Menu.Reconnect:SetTextColor(UI.TextColor)
    self.Menu.Reconnect:SetFont("EGMText12")
    self.Menu.Reconnect:SetText(egmt("loading.reconnect"))
    self.Menu.Reconnect:SetButtonCornerRadius(5)
    function self.Menu.Reconnect:DoClick()
        RunConsoleCommand("retry")
    end

    self.Menu.Quit = vgui.Create("EGMButton", self.Menu.Frame)
    self.Menu.Quit:SetSize(ScrW() * 0.2, ScrH() * 0.05)
    self.Menu.Quit:SetPos(ScrW() * 0.7, ScrH() * 0.9)
    self.Menu.Quit:SetTextColor(UI.TextColor)
    self.Menu.Quit:SetFont("EGMText12")
    self.Menu.Quit:SetText(egmt("loading.leave"))
    self.Menu.Quit:SetButtonColor(UI.ForegroundColor)
    self.Menu.Quit:SetButtonCornerRadius(5)
    function self.Menu.Quit:DoClick()
        RunConsoleCommand("disconnect")
    end

    self.Menu.Frame:MakePopup()
end

-- Closes the loading screen.
function Loading:CloseMenu()
    if self.Menu and IsValid(self.Menu.Frame) then
        self.Menu.Frame:Close()
    end
end
--gamemodes/egmrp/gamemode/core/util/sh_hook.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Hook Utilities | Shared      --
---------------------------------------

-- Call all hooks with the given identifier recursively.
-- The return value of the previous hook will be passed to the next hook.
-- The return value of the last hook will be returned.
-- 
-- @param table hooks
-- @param any lastKey
-- @param vararg ...
-- @return vararg ...
local function callRecursive(hooks, lastKey, ...)
    local key, func = next(hooks, lastKey)
    if key ~= nil then
        return callRecursive(hooks, key, func(...))
    end

    return ...
end

-- Call all hooks with the given identifier recursively.
-- 
-- @param string identifier
-- @param vararg ...
function hook.RunRecursive(identifier, ...)
    local hooks = hook.GetTable()[identifier]
    if istable(hooks) then
        return callRecursive(hooks, nil, ...)
    end
end

--gamemodes/egmrp/gamemode/core/ui/sh_ui.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--            UI | Shared            --
---------------------------------------

-- Load an VGUI element from the active style.
--
-- @param string elementDirectory
-- @param string elementName
-- @return Boolean success
-- @return? String error
function UI:LoadVGUIElement(elementDirectory, elementName)
	ELEMENT = {}
	ELEMENT.Name = elementName

	local success = pcall(function()
		if SERVER then
			AddCSLuaFile(elementDirectory .. elementName .. ".lua")
		else
			include(elementDirectory .. elementName .. ".lua")
		end
	end)
	if not success then
		return false, "Cannot load VGUI Element \"" .. elementName .. "\""
	end

	if CLIENT then
		vgui.Register(ELEMENT.Name, ELEMENT, ELEMENT.Base)
	end

	ELEMENT = nil

	return true
end

-- Load all VGUI elements.
--
-- @param String moduleDirectory
function UI:LoadVGUIElements(moduleDirectory)
	self.VGUIElements = self.VGUIElements or {}

	local selectedStyle = self.SelectedStyle or "default"
	local elementDirectory = moduleDirectory .. "styles/" .. selectedStyle .. "/vgui/"

	local elementFiles, _ = file.Find(elementDirectory .. "*.lua", "LUA")
	for _, fileName in ipairs(elementFiles) do
		local elementName = string.StripExtension(fileName)

		self.VGUIElements[elementName] = nil
		local success, error = self:LoadVGUIElement(elementDirectory, elementName)
		if success then
			LogInfo("|-- Loaded VGUI Element \"" .. elementName .. "\"")
		else
			LogWarning("|-- " .. error)
		end
	end
end

-- Load an HUD element from the active style.
--
-- @param string elementDirectory
-- @param string elementName
-- @return Boolean success
-- @return? String error
function UI:LoadHUDElement(elementDirectory, elementName)
	ELEMENT = {}
	ELEMENT.Name = elementName

	local success = pcall(function()
		if SERVER then
			AddCSLuaFile(elementDirectory .. elementName .. ".lua")
		else
			include(elementDirectory .. elementName .. ".lua")
		end
	end)
	if not success then
		return false, "Cannot load HUD Element \"" .. elementName .. "\""
	end

	self.HUDElements[elementName] = ELEMENT
	ELEMENT = nil

	return true
end

-- Load all HUD elements.
--
-- @param String moduleDirectory
function UI:LoadHUDElements(moduleDirectory)
	self.HUDElements = self.HUDElements or {}

	local selectedStyle = self.SelectedStyle or "default"
	local elementDirectory = moduleDirectory .. "styles/" .. selectedStyle .. "/hud/"

	local elementFiles, _ = file.Find(elementDirectory .. "*.lua", "LUA")
	for _, fileName in ipairs(elementFiles) do
		local elementName = string.StripExtension(fileName)

		self.HUDElements[elementName] = nil
		local success, error = self:LoadHUDElement(elementDirectory, elementName)
		if success then
			LogInfo("|-- Loaded HUD Element \"" .. elementName .. "\"")
		else
			LogWarning("|-- " .. error)
		end
	end
end

-- Load the selected style from the given module.
--
-- @param String moduleDirectory
function UI:LoadStyle(moduleDirectory)
	local selectedStyle = self.SelectedStyle or "default"
	local styleDirectory = moduleDirectory .. "styles/" .. selectedStyle .. "/"

	-- Load base style files.
	local styleFiles, _ = file.Find(styleDirectory .. "*.lua", "LUA")
	for _, fileName in ipairs(styleFiles) do
		if SERVER then
			AddCSLuaFile(styleDirectory .. fileName)
		else
			include(styleDirectory .. fileName)
		end
	end

	-- Load HUD elements.
	self:LoadHUDElements(moduleDirectory)

	-- Load VGUI elements.
	self:LoadVGUIElements(moduleDirectory)
end



---------------------------------------
--             Load Hooks            --
---------------------------------------

-- Load all the styles from the given module.
hook.Add("EGMRP.ModuleLoaded", "UI.LoadClasses", function(_, folderPath)
	UI:LoadStyle(folderPath)
end)
--gamemodes/egmrp/gamemode/core/ui/styles/default/hud/base.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         HUD Element | Base        --
---------------------------------------

-- Draw the HUD Element
--
-- @param Player ply
function ELEMENT:Draw(ply)
	local w, h = ScrW(), ScrH()
	local barHeight = math.ceil(ScrH() * 0.03)
	local hPadding = math.ceil(ScrH() * 0.005)

	local bgColor = UI.BackgroundColor
	local barColor = ColorAlpha(UI.BackgroundColor, 255)
	local textColor = UI.TextColor

	-- Draw Bottom Bar
	draw.RoundedBox(0, 0, h - barHeight, w, barHeight, bgColor)

	local barWidth = w * 0.1
	local wPadding = w * 0.01

	-- Draw Health Bar
	local health, maxHealth = self:GetPlayerHealth(ply)
	local healthPercent = math.Clamp(health / maxHealth, 0, 1)

	local healthBarX = wPadding
	local healthBarY = h - barHeight + hPadding
	local healthBarH = barHeight - hPadding * 2

	draw.RoundedBox(0, healthBarX, healthBarY, barWidth, healthBarH, barColor)
	draw.RoundedBox(0, healthBarX, healthBarY, barWidth * healthPercent, healthBarH, GetColor("red", 40))
	draw.SimpleText(health, "EGMText10", healthBarX + barWidth * 0.5, healthBarY + healthBarH * 0.5, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

	-- Draw Armor Bar
	local armor, maxArmor = self:GetPlayerArmor(ply)
	local armorPercent = math.Clamp(armor / maxArmor, 0, 1)

	local armorBarX = wPadding + barWidth + wPadding * 2

	draw.RoundedBox(0, armorBarX, healthBarY, barWidth, healthBarH, barColor)
	draw.RoundedBox(0, armorBarX, healthBarY, barWidth * armorPercent, healthBarH, GetColor("blue", 40))
	draw.SimpleText(armor, "EGMText10", armorBarX + barWidth * 0.5, healthBarY + healthBarH * 0.5, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

	-- Draw Name
	draw.SimpleText(ply:GetCurrentCharacterFullName(), "EGMText14", w * 0.5, h - barHeight * 0.5, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

	-- Ammo Bar
	local clipAmmo, maxClipAmmo, fullAmmo = self:GetPlayerWeaponAmmo(ply)
	draw.SimpleText(clipAmmo .. " / " .. maxClipAmmo, "EGMText14", w * 0.925, h - barHeight * 0.5, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	draw.SimpleText(fullAmmo, "EGMText14", w * 0.975, h - barHeight * 0.5, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end



---------------------------------------
--          Helper Functions         --
---------------------------------------

-- Helper Function for getting current player health
--
-- @param Player ply
-- @return Number health
-- @return Number maxHealth
function ELEMENT:GetPlayerHealth(ply)
	local health = math.max(ply:Health(), 0)
	local maxHealth = ply:GetMaxHealth()

	return health, maxHealth
end

-- Helper Function for getting current player armor
--
-- @param Player ply
-- @return Number armor
-- @return Number maxArmor
function ELEMENT:GetPlayerArmor(ply)
	local armor = math.max(ply:Armor(), 0)
	local maxArmor = ply:GetMaxArmor()

	return armor, maxArmor
end

-- Helper function for getting the current players weapon ammo
--
-- @param Player ply
-- @return Number clipAmmo
-- @return Number maxClipAmmo
-- @return Number fullAmmo
function ELEMENT:GetPlayerWeaponAmmo(ply)
	local weapon = ply:GetActiveWeapon()
	if not IsValid(weapon) then return 0, 0 end

	local clipAmmo = weapon:Clip1()
	local maxClipAmmo = weapon:GetMaxClip1()
	local fullAmmo = ply:GetAmmoCount(weapon:GetPrimaryAmmoType())

	return clipAmmo, maxClipAmmo, fullAmmo
end
--gamemodes/egmrp/gamemode/core/ui/styles/default/vgui/egmlistview.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          VGUI | EGMListView       --
---------------------------------------

ELEMENT.Name = "EGMListView"
ELEMENT.Base = "DListView"

-- Initializes the EGMListView.
function ELEMENT:Init()
    self.backgroundColor = GetColor("darkgray")
    self.scrollbarColor = GetColor("darkgray")
    self.scrollbarGripColor = UI.ForegroundColor
    self.scrollbarBtnUpColor = GetColor("black")
    self.scrollbarBtnUpBgColor = UI.ForegroundColor
    self.scrollbarBtnDownColor = GetColor("black")
    self.scrollbarBtnDownBgColor = UI.ForegroundColor
    self.lineBgColor = GetColor("gray")
    self.lineAltBgColor = GetColor("darkgray")
    self.lineSelectedBgColor = ColorAlpha(UI.ForegroundColor2 , 50)
    self.lineTextColor = GetColor("white")
    self.dataFont = "EGMText6"
    self.columnBgColor = UI.ForegroundColor
    self.columnTextColor = GetColor("white")
    self.headerFont = "EGMText8"
end

-- Adds customlines to the listview.
--
-- Same arguments as AddLine(...)
function ELEMENT:AddCustomLine(...)
    local listView = self
    local line = self:AddLine(...)
    local lineColumns = line.Columns

    for k, lineColumn in pairs(lineColumns) do
        lineColumn:SetText("")
        function lineColumn:Paint(width, height)
            -- self.Value it already set by the ListView_line object when the line is created.
            draw.SimpleText(self.Value, listView.dataFont, width * 0.5, height * 0.5, line.CustomTextColor or listView.lineTextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end

    function line:Paint(width, height)
        if self:IsSelected() then
            draw.RoundedBox(0, 0, 0, width, height, listView.lineSelectedBgColor)
        else
            if self:GetAltLine() then
                draw.RoundedBox(0, 0, 0, width, height, listView.lineAltBgColor)
            else
                draw.RoundedBox(0, 0, 0, width, height, listView.lineBgColor)
            end
        end
    end

    -- Sets the color of the text of this one line.
    function line:SetCustomTextColor(color)
        self.CustomTextColor = color
    end

    return line
end

-- Adds customeline to the listview with each value also having a sort Value.
--
-- Arguments are interlieved like following:
-- text1, sort1, text2, sort2, text3, sort3, etc...
function ELEMENT:AddSortedLine(...)
    local texts = {}
    local sorts = {}

    for i, v in pairs{...} do
        if i % 2 == 1 then
            texts[math.ceil(i / 2)] = v
        else
            sorts[math.ceil(i / 2)] = v
        end
    end

    local line = self:AddCustomLine(unpack(texts))

    function line:GetSortValue(id)
        return sorts[id]
    end

    return line
end

-- Clear the EGMListView.
function ELEMENT:Clear()
    for k, v in pairs( self.Lines ) do
        v:Remove()
    end

    self.Lines = {}
    self.Sorted = {}

    self:SetDirty( true )

    -- Resets the scrollbar.
    self.VBar:SetScroll(0)
end

-- Adds a custom column.
--
-- Same arguments as AddColumn(...)
function ELEMENT:AddCustomColumn(...)
    local listView = self

    local column = self:AddColumn(...)
    local header = column.Header
    header:SetFont(self.headerFont)
    header:SetTextColor(self.columnTextColor)

    function column:DoClick()
        self:SetDescending(!self:GetDescending())
        listView:SortByColumns( self:GetColumnID(), self:GetDescending() )
    end

    function header:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, listView.columnBgColor)
    end

    return column
end

-- Draws the EGMListView.
--
-- @param Number width
-- @param Number height
function ELEMENT:Paint(width, height)
    local listView = self

    draw.RoundedBox(0, 0, 0, width, height, self.backgroundColor)

    function self.VBar:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, listView.scrollbarColor)

        function self.btnUp:Paint(width, height)
            draw.RoundedBox(0, 0, 0, width, height, listView.scrollbarBtnUpBgColor)

            surface.SetDrawColor(listView.scrollbarBtnUpColor)
            draw.NoTexture()
            surface.DrawPoly({
                {x = 3, y = 11.5},
                {x = 7.5, y = 3.5},
                {x = 12, y = 11.5}
            })
        end

        function self.btnDown:Paint(width, height)
            draw.RoundedBox(0, 0, 0, width, height, listView.scrollbarBtnDownBgColor)

            surface.SetDrawColor(listView.scrollbarBtnDownColor)
            draw.NoTexture()
            surface.DrawPoly({
                {x = 12, y = 3.5},
                {x = 7.5, y = 11.5},
                {x = 3, y = 3.5}
            })
        end

        function self.btnGrip:Paint(width, height)
            draw.RoundedBox(0, 0, 0, width, height, listView.scrollbarGripColor)
        end
    end
end

-- Sorts by multiple columns. Improved from the base variant.
--
-- columnid1, desc1, columnid2, desc2, ...
function ELEMENT:SortByColumns(...)
    local args = {...}

    table.Copy( self.Sorted, self.Lines )

    table.sort( self.Sorted, function( a, b )
        if ( !IsValid( a ) ) then return true end
        if ( !IsValid( b ) ) then return false end

        for i = 1, #args, 2 do
            columnid = args[i]
            desc = args[i + 1]

            if columnid then
                aValue = a:GetSortValue(columnid)
                bValue = b:GetSortValue(columnid)

                if aValue and bValue and aValue ~= bValue then
                    return (aValue < bValue) ~= desc
                end
            end
        end

        for i = 1, #args, 2 do
            columnid = args[i]
            desc = args[i + 1]

            if columnid then
                aValue = a:GetColumnText(columnid)
                bValue = b:GetColumnText(columnid)

                if isstring(aValue) and isstring(bValue) and aValue ~= bValue then
                    return (aValue < bValue) ~= desc
                end
            end
        end

        return false
    end)

    self:SetDirty( true )
    self:InvalidateLayout()

end

-- Sets the background color.
--
-- @param Color color
function ELEMENT:SetBackgroundColor(color)
    self.backgroundColor = color
end

-- Sets the color of the scrollbar.
--
-- @param Color color
function ELEMENT:SetScrollbarColor(color)
    self.scrollbarColor = color
end

-- Sets the color of the up-button.
--
-- @param Color color
function ELEMENT:SetBtnUpColor(color)
    self.scrollbarBtnUpColor = color
end

-- Sets the backgroundcolor of the up-botton.
--
-- @param Color color
function ELEMENT:SetBtnUpBgColor(color)
    self.scrollbarBtnUpBgColor = color
end

-- Sets the color of the down-button.
--
-- @param Color color
function ELEMENT:SetBtnDownColor(color)
    self.scrollbarBtnDownColor = color
end

-- Sets the backgroundcolor of the down-botton.
--
-- @param Color color
function ELEMENT:SetBtnDownBgColor(color)
    self.scrollbarBtnDownBgColor = color
end

-- Sets the color of the scollbar-grip.
--
-- @param Color color
function ELEMENT:SetGripColor(color)
    self.scrollbarGripColor = color
end

-- Sets the backgroundcolor of the lines.
--
-- @param Color color
function ELEMENT:SetLineBgColor(color)
    self.lineBgColor = color
end

-- Sets the second backgroundcolor of the lines.
--
-- @param Color color
function ELEMENT:SetLineAltBgColor(color)
    self.lineAltBgColor = color
end

-- Sets the backgroundcolor of selected lines.
--
-- @param Color color
function ELEMENT:SetLineSelectedBgColor(color)
    self.lineSelectedBgColor = color
end

-- Sets the backgroundcolor for columns.
--
-- @param Color color
function ELEMENT:SetColumnBgColor(color)
    self.columnBgColor = color
end

-- Sets the textcolor of columntext.
--
-- @param Color color
function ELEMENT:SetColumnTextColor(color)
    self.columnTextColor = color
end

-- Sets the font of headertext.
--
-- @param String font
function ELEMENT:SetHeaderFont(font)
    self.headerFont = font
end

-- Sets the textcolor of the text in lines.
--
-- @param Color color
function ELEMENT:SetLineTextColor(color)
    self.lineTextColor = color
end

-- Sets the font of the linetext.
--
-- @param String font
function ELEMENT:SetDataFont(font)
    self.dataFont = font
end
--gamemodes/egmrp/gamemode/core/ui/styles/default/vgui/egmmodelicon.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        VGUI | EGMModelIcon        --
---------------------------------------

ELEMENT.Name = "EGMModelIcon"
ELEMENT.Base = "DButton"

local GEN_DELAY = 0.1
local COOLDOWN_DELAY = 2

-- RT Material Cache
local rtMaterial = {}

-- RT Material Generation Queue
local rtMaterialQueue = {}

if IsValid(ELEMENT.ModelPanel) then
	ELEMENT.ModelPanel:Remove()
end

-- Model Panel
local modelPanel = vgui.Create("DModelPanel", nil)
ELEMENT.ModelPanel = modelPanel

modelPanel:SetPos(0, 0)
modelPanel:SetSize(64, 64)
modelPanel:SetPaintedManually(true)

modelPanel:SetFOV(5)
modelPanel:SetModel("models/player/alyx.mdl")

modelPanel:SetAmbientLight(Color(255, 255, 255))
modelPanel.DirectionalLight = {}

-- Stop Animations
function modelPanel:LayoutEntity(ent)
end

file.CreateDir("egmrp/modelicons")

timer.Remove("EGMModelIcon.HandleQueue")

local lastSysTime = 0
local coolDownUntil = 0

-- Render one RT Material from the queue.
--
-- @return Boolean finished
local function handleQueue()
	local sysTime = SysTime()
	local diff = sysTime - lastSysTime
	lastSysTime = sysTime

	if sysTime < coolDownUntil then
		return false
	end

	if diff > (GEN_DELAY * 2) then
		coolDownUntil = sysTime + COOLDOWN_DELAY

		return false
	end

	local nextEntry = table.remove(rtMaterialQueue, 1)
	if not nextEntry then
		return true
	end

	local rt = nextEntry.Rt

	local model = nextEntry.Model
	local skinId = nextEntry.SkinId
	local bodygroups = nextEntry.Bodygroups

	local displayType = nextEntry.DisplayType
	local w = nextEntry.W
	local h = nextEntry.H

	modelPanel:SetSize(w, h)
	modelPanel:SetModel(model)

	local ent = modelPanel:GetEntity()
	if IsValid(ent) then
		if isnumber(skinId) then
			ent:SetSkin(skinId)
		end

		hook.Run("EGMModelIcon.OverrideModel", model, skinId, ent)
	end

	local validDisplay = false
	if displayType == "Default" then
		local headBone = ent:LookupBone("ValveBiped.Bip01_Head1")
		if headBone then
			validDisplay = true

			local headPos = ent:GetBonePosition(headBone)

			modelPanel:SetLookAt(headPos)
			modelPanel:SetCamPos(headPos + Vector(250, 0, 0))
		end
	elseif displayType == "Body" then
		local bodyBone = ent:LookupBone("ValveBiped.Bip01_Spine2")
		if bodyBone then
			validDisplay = true

			local bodyPos = ent:GetBonePosition(bodyBone)

			modelPanel:SetLookAt(bodyPos)
			modelPanel:SetCamPos(bodyPos + Vector(650, 0, 0))
		end
	elseif displayType == "Weapon" then
		validDisplay = true

		local min, max = ent:GetRenderBounds()
		local longestSide = math.max(max.x - min.x, max.y - min.y, max.z - min.z)
		local center = (min + max) / 2

		local distance = longestSide / 2 / math.tan(math.rad(modelPanel:GetFOV() / 2))

		modelPanel:SetLookAt(center)
		modelPanel:SetCamPos(center + Vector(0, distance, 0))
	end

	local override = hook.Run("EGMModelIcon.OverrideDisplay", displayType, modelPanel, ent)
	if override then
		validDisplay = true
	end

	if not validDisplay then
		local min, max = ent:GetRenderBounds()
		local longestSide = math.max(max.x - min.x, max.y - min.y, max.z - min.z)
		local center = (min + max) / 2

		local distance = longestSide / 2 / math.tan(math.rad(modelPanel:GetFOV() / 2))

		modelPanel:SetLookAt(center)
		modelPanel:SetCamPos(center + Vector(distance, 0, 0))
	end

	local captureData
	render.PushRenderTarget(rt, 0, 0, w, h)
		cam.Start2D()
			modelPanel:PaintManual(true)

			captureData = render.Capture({
				format = "png",
				x = 0,
				y = 0,
				w = w,
				h = h,
			})
		cam.End2D()
	render.PopRenderTarget()

	local fileName = nextEntry.FileName
	file.Write(fileName, captureData)

	return false
end

-- Requests the rtMaterial for the model to be rendered.
--
-- @param String model
-- @param Number skinId
-- @param Table bodygroups
-- @param String displayType
-- @param Number w
-- @param Number h
-- @return Material rtMaterial
local function requestRT(model, skinId, bodygroups, displayType, w, h)
	local id = util.SHA1(model .. skinId .. displayType .. w .. h)

	local fileName = "egmrp/modelicons/icon_" .. id .. ".png"

	if not file.Exists(model, "GAME") and not hook.Run("EGMModelIcon.OverrideModel", model, skinId) then
		file.Delete(fileName, "DATA")

		return Material("error")
	end

	local mat = rtMaterial[id]
	if mat ~= nil then
		return mat
	end

	local timeBorder = os.time() - 60 * 60 * 24 * 7 -- 7 Days
	if file.Exists(fileName, "DATA") and file.Time(fileName, "DATA") > timeBorder then
		return Material("data/" .. fileName)
	end

	local materialName = "EGMModelIcon_" .. id

	local rt = GetRenderTarget(materialName, w, h)
	mat = CreateMaterial(materialName, "UnlitGeneric", {
		["$basetexture"] = rt:GetName(),
		["$vertexcolor"] = 1,
		["$vertexalpha"] = 0,
	})

	render.PushRenderTarget(rt, 0, 0, w, h)
		render.Clear(0, 0, 0, 0, true, true)
	render.PopRenderTarget()

	rtMaterial[id] = mat
	table.insert(rtMaterialQueue, {
		Rt = rt,
		FileName = fileName,

		Model = model,
		SkinId = skinId,
		Bodygroups = bodygroups,

		DisplayType = displayType,
		W = w,
		H = h,
	})

	local timerName = "EGMModelIcon.HandleQueue"
	if not timer.Exists(timerName) then
		lastSysTime = SysTime()

		timer.Create(timerName, GEN_DELAY, 0, function()
			local finished = handleQueue()

			if finished then
				timer.Remove(timerName)
			end
		end)
	end

	return mat
end

-- Initializes the EGMModelIcon
function ELEMENT:Init()
	self:SetDoubleClickingEnabled(false)
	self:SetText("")

	self:SetSize(64, 64)

	self.Model = ""
	self.SkinId = nil
	self.Bodygroups = nil
end

-- Sets the model of the EGMModelIcon
--
-- @param String model
-- @param? Number skinId
-- @param? Table bodygroups
function ELEMENT:SetModel(model, skinId, bodygroups)
	local override = hook.Run("EGMModelIcon.OverrideSetModel", self, model, skinId)
	if override then
		return
	end

	self.Model = model or ""
	self.SkinId = skinId or 0
	self.Bodygroups = bodygroups or {}
end

-- Gets the model of the EGMModelIcon
--
-- @return String model
function ELEMENT:GetModel()
	return self.Model
end

-- Gets the skinId of the EGMModelIcon
--
-- @return Number skinId
function ELEMENT:GetSkinId()
	return self.SkinId
end

-- Sets the display type of the EGMModelIcon
--
-- @param String displayType
function ELEMENT:SetDisplayType(displayType)
	self.DisplayType = displayType
end

-- Generates the icon
function ELEMENT:GenerateIcon()
	local model = self.Model or ""
	local skinId = self.SkinId or 0
	local bodygroups = self.Bodygroups or {}

	local displayType = self.DisplayType or "Default"
	local w, h = self:GetSize()

	-- Generate the rtMaterial for the model.
	self.Material = requestRT(model, skinId, bodygroups, displayType, w, h)
end

function ELEMENT:Paint(ww, hh)
	local mat = self.Material
	if mat then
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetMaterial(mat)
		surface.DrawTexturedRect(0, 0, ww, hh)
	end
end

-- Paints the EGMModelIcon
function ELEMENT:PaintOver(ww, hh)
	if self:IsHovered() then
		draw.RoundedBox(0, 0, 0, ww, 2, UI.ForegroundColor)
		draw.RoundedBox(0, 0, 0, 2, hh, UI.ForegroundColor)

		draw.RoundedBox(0, 0, hh - 2, ww, 2, UI.ForegroundColor)
		draw.RoundedBox(0, ww - 2, 0, 2, hh, UI.ForegroundColor)
	end
end
--gamemodes/egmrp/gamemode/core/settings/cl_settingsmenu.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Settings Menu | Client      --
---------------------------------------

-- Opens the Settings menu.
function Settings:OpenMenu()
    self:CloseMenu()

    local w, h = ScrW() * 0.3, ScrH() * 0.7

    self.Frame = vgui.Create("DFrame")
    self.Frame:SetPos((ScrW() - w) / 2, (ScrH() - h) / 2)
    self.Frame:SetSize(w, h)
    self.Frame:SetTitle("")
    self.Frame:ShowCloseButton(false)
    function self.Frame:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, ColorAlpha(UI.BackgroundColor, 255))
        draw.DrawText(egmt("settings.settings"), "EGMText12", width * 0.025, height * 0.01, UI.ForegroundColor, TEXT_ALIGN_LEFT)
    end

    self.Close = vgui.Create("EGMCloseButton", self.Frame)
    self.Close:SetPanel(self.Frame)
    self.Close:SetPos(w * 0.9, h * 0.0175)
    self.Close:SetSize(ScrH() * 0.03, ScrH() * 0.03)

    self.ScrollPanel = vgui.Create("EGMScrollPanel", Settings.Frame)
    self.ScrollPanel:SetPos(w * 0.025, h * 0.075)
    self.ScrollPanel:SetSize(w * 0.95, h * 0.85)

    self.CheckBoxes = {}

    for key, category in SortedPairsByValue(Settings.Categories) do
        local categorylabel = vgui.Create("DLabel", self.ScrollPanel)
        categorylabel:SetSize(w * 0.9, h * 0.05)
        categorylabel:Dock(TOP)
        categorylabel:DockMargin(ScrW() * 0.005, ScrH() * 0.01, ScrW() * 0.005, 0)
        categorylabel:SetTextColor(UI.TextColor)
        categorylabel:SetFont("EGMText12")
        categorylabel:SetText(category)

        for name, option in SortedPairsByMemberValue(Settings.Options, "displayName") do
            if category == option.category  and LocalPlayer():IsAtLeast(option.usergroup) then
                local entry = vgui.Create("DPanel", self.ScrollPanel)
                entry:SetSize(w * 0.9, h * 0.05)
                entry:Dock(TOP)
                entry:DockMargin(ScrW() * 0.005, ScrH() * 0.01, ScrW() * 0.005, 0)
                entry:SetTooltip(name)
                function entry:Paint(width, height)
                    draw.RoundedBox(0, 0, 0, width, height, UI.BackgroundColor2)
                    draw.DrawText(name, "EGMText12", width * 0.025, height * 0.01, UI.ForegroundColor, TEXT_ALIGN_LEFT)
                end

                local checkbox = vgui.Create("EGMCheckBox", entry)
                checkbox:SetSize(w * 0.065, h * 0.03)
                checkbox:Dock(RIGHT)
                checkbox.name = name
                checkbox:SetChecked(option.value)
                function checkbox:OnChange(value)
                    Settings:Set(self.name, value)
                    option.func()
                end

                self.CheckBoxes[name] = checkbox
            end
        end
    end

    self.ResetButton = vgui.Create("EGMButton", self.Frame)
    self.ResetButton:Dock(BOTTOM)
    self.ResetButton:SetHeight(ScrH() * 0.035)
    self.ResetButton:SetTextColor(UI.TextColor)
    self.ResetButton:SetFont("EGMText10")
    self.ResetButton:SetText("Einstellungen zurücksetzen")
    self.ResetButton:SetButtonCornerRadius(5)
    function self.ResetButton:DoClick()
        local modal = vgui.Create("EGMModal")
		modal:SetCustomTitle(egmt("shared.are_you_sure"))
        modal:Confirm(egmt("settings.settings_removed_permanently"), function()
            for name, option in pairs(Settings.Options) do
                option:Set(name, option.default)
                option.CheckBoxes[name]:SetValue(option.default)
            end
        end)
    end

    Settings.Frame:MakePopup()
end

-- Closes the Settings menu.
function Settings:CloseMenu()
    if IsValid(self.Frame) then
        self.Frame:Close()
    end
end

-- Register the Settings menu keybind.
KeyBind:Register("Settings Menu", "Menüs", function()
    Settings:OpenMenu()
end)
--gamemodes/egmrp/gamemode/core/scoreboard/cl_scoreboard.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Scoreboard | Client         --
---------------------------------------

local EGMRP = GM or GAMEMODE

Scoreboard.SortCriteria = ""
Scoreboard.SortDescending = false

local spaceLeftRight = Scoreboard.Width * 0.011
local rowWidth = Scoreboard.Width - spaceLeftRight * 2
local afterDonator = 100
local beforeMute = rowWidth * 0.07

-- Adds a column to the Scoreboard
--
-- @param String name
-- @param Number width
-- @param Table data
-- @param Boolean defaultSort
function Scoreboard:AddScoreColumn(name, width, data, defaultSort)
    table.insert(Scoreboard.Columns, {["name"] = name, ["width"] = width, ["data"] = data})

    if defaultSort then
        Scoreboard.SortCriteria = name
    end
end

-- Returns the position of a column.
--
-- @param Number column
-- @return Number pos
function Scoreboard:GetScoreColumnHeaderPos(column)
    local pos = spaceLeftRight + afterDonator
    local width = Scoreboard.Width - Scoreboard.Padding * (#Scoreboard.Columns - 1) - pos - spaceLeftRight - beforeMute

    for i = 1, column - 1 do
        pos = pos + width * Scoreboard.Columns[i]["width"] + Scoreboard.Padding
    end

    return pos
end

-- Returns the size of a column.
--
-- @param Number column
-- @return Number size
function Scoreboard:GetScoreColumnHeaderSize(column)
    return (Scoreboard.Width - Scoreboard.Padding * (#Scoreboard.Columns - 1) - afterDonator - beforeMute - spaceLeftRight * 2) * Scoreboard.Columns[column]["width"]
end

function Scoreboard:GetScoreColumnDataPos(column)
    return self:GetScoreColumnHeaderPos(column) + self:GetScoreColumnHeaderSize(column) / 2 - spaceLeftRight
end

-- Returns a color based on a players ping.
--
--@param Number ping
--@return Color color
function Scoreboard:GetPingColor(ping)
    if ping < 75 then
        return GetColor("green")
    elseif ping < 150 then
        return GetColor("yellow")
    else
        return GetColor("red")
    end
end

-- Returns the amount of players on the server, that should be shown.
--
--@return Number plyAmount
function Scoreboard:GetPlayerCount()
    local removeAmount = 0

    for k, ply in pairs(player.GetAll()) do
        if Config.Modules["developer"] and ply:Vanished() then
            removeAmount = removeAmount + 1
        end
    end

    local playerCount = hook.Run("Scoreboard.GetPlayerCount") or #player.GetAll()

    return playerCount - removeAmount
end

Scoreboard:AddScoreColumn(egmt("scoreboard.column_name"), 0.25, function(ply)
    return ply:GetCurrentCharacterFullName(), UI.TextColor
end)

Scoreboard:AddScoreColumn(egmt("scoreboard.column_faction"), 0.25, function(ply)
    if ply:IsBot() then
        return "Klokrieger", Color(255, 0, 0, 255)
    end

    local factionName = hook.Run("Scoreboard.GetFactionName", ply)
    if not factionName then
        factionName = ply:GetCurrentCharacterFactionName()
    end

    return factionName, ply:GetCurrentCharacterFactionColor()
end, true)

Scoreboard:AddScoreColumn(egmt("scoreboard.column_rank"), 0.25, function(ply)
    if ply:IsBot() then
        return "Commander", Color(255, 0, 0, 255)
    end

    local rankName = hook.Run("Scoreboard.GetRankName", ply)

    if not rankName then
        rankName = ply:GetCurrentCharacterRankName()
    end

    return rankName, ply:GetCurrentCharacterRankColor()
end)

Scoreboard:AddScoreColumn(egmt("scoreboard.column_group"), 0.175, function(ply)
    if ply:IsBot() then
        return egmt("scoreboard.bot"), Color(255, 0, 0, 255)
    end

    return ply:GetUserGroupName(), ply:GetUserGroupColor()
end)

Scoreboard:AddScoreColumn(egmt("scoreboard.column_ping"), 0.075, function(ply)
    local ping = ply:Ping()

    return "" .. ping, Scoreboard:GetPingColor(ping)
end)

Scoreboard.Options = {}

-- Adds an option to the right-click menu of the scoreboard.
--
-- @param String name - The name displayed on the option.
-- @param String icon - path to the icon of the option.
-- @param Number order - The position of the option. Steps in this value > 50 will generate a seperating tab line.
-- @param Function callback(target) - Called when the option is pressed.
-- @param Function shouldShow(target) - Returns if the option should be shown for the given player. Can also be true to always show.
function Scoreboard:AddOption(name, icon, order, callback, shouldShow)
    table.insert(Scoreboard.Options, {
        name = name,
        icon = icon,
        order = order,
        callback = callback,
        shouldShow = shouldShow
    })
end

-- Opens the Steam Profile of a player.
Scoreboard:AddOption(
    egmt("scoreboard.steam_profile"),
    "icon16/user.png",
    0,
    function(target)
        target:ShowProfile()
    end,
    true
)

-- Copies the SteamID of a player to the clipboard.
Scoreboard:AddOption(
    egmt("scoreboard.copy_steamid"),
    "icon16/paste_plain.png",
    1,
    function(target)
        SetClipboardText(target:SteamID64())
    end,
    true
)

-- Uses the ulx or sam goto command to teleport to another.
Scoreboard:AddOption(
    egmt("scoreboard.teleport_to"),
    "icon16/arrow_right.png",
    998,
    function(target)
        if ULib then
            RunConsoleCommand("ulx", "goto", target:Name())
        elseif sam then
            RunConsoleCommand("sam", "goto", target:SteamID64())
        end
    end,
    function(target)
        return LocalPlayer():IsTeamMember()
    end
)

-- Uses the ulx or sam bring command to teleport another player to you.
Scoreboard:AddOption(
    egmt("scoreboard.bring"),
    "icon16/arrow_left.png",
    999,
    function(target)
        if ULib then
            RunConsoleCommand("ulx", "bring", target:Name())
        elseif sam then
            RunConsoleCommand("sam", "bring", target:SteamID64())
        end
    end,
    function(target)
        return target:Alive() and LocalPlayer():IsTeamMember()
    end
)

-- Uses the ulx return command to return a player to his previous location.
Scoreboard:AddOption(
    egmt("scoreboard.return"),
    "icon16/arrow_rotate_anticlockwise.png",
    1000,
    function(target)
        if ULib then
            RunConsoleCommand("ulx", "return", target:Name())
        elseif sam then
            RunConsoleCommand("sam", "return", target:SteamID64())
        end
    end,
    function(target)
        return target:Alive() and LocalPlayer():IsTeamMember()
    end
)

function EGMRP:ScoreboardShow()
    -- if EGM.IntroPlaying then return end

    local w, h = Scoreboard.Width, Scoreboard.Height

    Scoreboard.Panel = vgui.Create("DPanel")
    Scoreboard.Panel:SetSize(w, h)
    Scoreboard.Panel:Center()
    Scoreboard.Panel:SetAlpha(0)
    function Scoreboard.Panel:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, UI.BackgroundColor)

        surface.SetDrawColor(UI.BackgroundColor)
        self:DrawOutlinedRect()
    end

    local columns = vgui.Create("DPanel", Scoreboard.Panel)
    columns:SetPos(0, 0)
    columns:SetSize(w, h * 0.07)
    function columns:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, ColorAlpha(UI.BackgroundColor, 220))

        local thickness = width * 0.0015
        surface.SetDrawColor(UI.ForegroundColor)
        surface.DrawRect(0, height - thickness, width, height)

        draw.SimpleText(Scoreboard:GetPlayerCount() .. " | " .. game.MaxPlayers(), "EGMText12", width * 0.02, height / 2, UI.ForegroundColor2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    local playerList = vgui.Create("EGMScrollPanel", Scoreboard.Panel)
    playerList:SetPos(0, h * 0.07)
    playerList:SetSize(w, h * 0.93)
    playerList:SetBackgroundColor(Color(0, 0, 0, 0))
    playerList.NextThink = CurTime()
    function playerList:Think()
        if CurTime() >= self.NextThink then
            local players = {}

            for k, ply in pairs(player.GetAll()) do
                if IsValid(ply.ScoreRow) then continue end
                if Config.Modules["developer"] and ply:Vanished() then continue end

                players[#players + 1] = {["ply"] = ply}

                for _, v in pairs(Scoreboard.Columns) do
                    players[#players][v.name] = v.data(ply)
                end
            end

            for k, plyData in SortedPairsByMemberValue(players, Scoreboard.SortCriteria, Scoreboard.SortDescending) do
                local scoreRow = vgui.Create("EGMScoreRow", playerList)
                scoreRow:SetPlayer(plyData.ply)
                scoreRow:SetBackgroundColor(Color(20, 20, 20, 180))
            end

            self.NextThink = CurTime() + 1
        end
    end
    function playerList:Refresh()
        for k, ply in pairs(player.GetAll()) do
            if IsValid(ply.ScoreRow) then
                ply.ScoreRow:Remove()
            end

            ply.ScoreRow = nil
        end

        playerList.NextThink = CurTime()
    end

    for k, v in SortedPairs(Scoreboard.Columns) do
        local btn = vgui.Create("DButton", columns)
        btn:SetPos(Scoreboard:GetScoreColumnHeaderPos(k), 0)
        btn:SetText("")
        btn:SetSize(Scoreboard:GetScoreColumnHeaderSize(k), h * 0.07)
        btn.name = v.name
        function btn:Paint(width, height)
            surface.SetDrawColor(UI.TextColor)
            draw.NoTexture()
            draw.SimpleText(self.name, "EGMText12", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end

        function btn:DoClick()
            if UI.ButtonSound then
                surface.PlaySound(UI.ButtonSound)
            end

            if Scoreboard.SortCriteria == self.name then
                Scoreboard.SortDescending = not Scoreboard.SortDescending
            else
                Scoreboard.SortDescending = false
            end

            Scoreboard.SortCriteria = self.name

            playerList:Refresh()
        end
    end

    Scoreboard.Panel:AlphaTo(255, 0.25, 0)
    gui.EnableScreenClicker(true)


    Scoreboard.Uptime = vgui.Create("DPanel")
    Scoreboard.Uptime:SetPos(ScrW() * 0.3, ScrH() * 0.911)
    Scoreboard.Uptime:SetSize(ScrW() * 0.4, ScrH() * 0.05)
    local text = string.EvenNicerTime(CurTime())
    local color
    if CurTime() >= (60 * 60 * 10) then
        color = GetColor("red")
    elseif CurTime() >= (60 * 60 * 5) then
        color = GetColor("orange")
    else
        color = UI.ForegroundColor
    end
    function Scoreboard.Uptime:Paint(width, height)
        draw.RoundedBox(5, 0, 0, width, height, ColorAlpha(UI.BackgroundColor, 220))
        draw.DrawText(egmt("scoreboard.on_map_since", text), "EGMText8", width * 0.5, height * 0.3, color, TEXT_ALIGN_CENTER)
    end
    function Scoreboard.Uptime:Think()
        text = string.EvenNicerTime(CurTime())
        if CurTime() >= (60 * 60 * 10) then
            color = GetColor("red")
        elseif CurTime() >= (60 * 60 * 5) then
            color = GetColor("orange")
        else
            color = UI.ForegroundColor
        end
    end
end

function EGMRP:ScoreboardHide()
    if IsValid(Scoreboard.Panel) then
        Scoreboard.Panel:Remove()
    end

    if IsValid(Scoreboard.Uptime) then
        Scoreboard.Uptime:Remove()
    end

    gui.EnableScreenClicker(false)
end
--gamemodes/egmrp/gamemode/core/performance/sh_performance.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Performance | Shared       --
---------------------------------------

-- Lag fix. For more info: https://github.com/Facepunch/garrysmod-issues/issues/2902
hook.Remove("PlayerTick", "TickWidgets")

-- Seat network optimizer is set.
hook.Add("OnEntityCreated", "seats_network_optimizer", function(seat)
    if seat:GetClass() == "prop_vehicle_prisoner_pod" then
        seat:AddEFlags(EFL_NO_THINK_FUNCTION) -- disable seat's Think
        seat.seats_network_optimizer = true -- Now we know that this seat has been processed by this addon.
    end
end)

local i
local seats
local last_enabled -- previously processed seat
-- This function enables the Think of one seat during each frame to save network traffic.
-- The Think of seats is only needed for animation handling.
hook.Add("Think", "seats_network_optimizer", function()
    -- Make list:
    if not seats or not seats[i] then
        -- Begin a new loop, with a new seats list.
        i = 1
        seats = {}
        for _,seat in ipairs(ents.FindByClass("prop_vehicle_prisoner_pod")) do
            if seat.seats_network_optimizer then
                table.insert(seats, seat)
            end
        end
    end
    -- Find a valid seat:
    while seats[i] and not IsValid(seats[i]) do
        -- Jump to the next valid seat.
        i = i + 1
    end
    local seat = seats[i]
    -- Disable the previously processed seat's Think if ready:
    if last_enabled ~= seat and IsValid(last_enabled) then -- ignore a seat's Think that is gonna be re-enabled
        -- last_enabled's Think is kept enabled until m_bEnterAnimOn and m_bExitAnimOn are reset.
        local saved = last_enabled:GetSaveTable()
        if not saved["m_bEnterAnimOn"] and not saved["m_bExitAnimOn"] then
            last_enabled:AddEFlags(EFL_NO_THINK_FUNCTION) -- disable last_enabled's Think
            last_enabled = nil
        end
    end
    -- Enable a seat's Think:
    if IsValid(seat) then
        -- seat's Think is enabled, letting the values m_bEnterAnimOn and m_bExitAnimOn being updated.
        seat:RemoveEFlags(EFL_NO_THINK_FUNCTION)
        last_enabled = seat
    end
    i = i + 1
end)

local function EnteredOrLeaved(ply, seat)
    if IsValid(seat) and seat.seats_network_optimizer then
        table.insert(seats, i, seat) -- seat's Think will be enabled on next game's Think
    end
end
hook.Add("PlayerEnteredVehicle", "seats_network_optimizer", EnteredOrLeaved)
hook.Add("PlayerLeaveVehicle", "seats_network_optimizer", EnteredOrLeaved)
--gamemodes/egmrp/gamemode/core/joinmanager/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Joinmanager index          --
---------------------------------------

if SERVER then
    JoinManager = {}

    include("sv_config.lua")
    include("sv_joinmanager.lua")
end

--gamemodes/egmrp/gamemode/core/manager/cl_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Manager | Config         --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Background for the manager.
Manager.Background = "backgrounds/piggo_flight_of_the_construct.jpg"

-- Default keybind for opening the manager.
Manager.DefaultKey = KEY_F6

-- Minimum group, for accessing the manager.
-- Access to actually change the properties is still required, to do anything.
Manager.MinAccessGroup = "admin"

-- Default category for the manager.
Manager.DefaultCategory = "Faction"

-- Hides all weapons, that do not have the "spawnable" flag.
Manager.HideUnspawnableWeapons = true

--gamemodes/egmrp/gamemode/core/faction/sh_faction.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Shared | Faction         --
---------------------------------------

-- Set sharedside property variables.
Faction.Name = "Faction"

-- Initialize networking.
Faction:InitCreationNetworking()
Faction:InitEditNetworking()
Faction:InitDeletionNetworking()

-- Add faction property: parentId
Faction:AddProperty("parentId", "number", -1, function(faction, value)
    if value == -1 then
        return true
    end

    if not isnumber(value) then
        return false, egmt("shared.invalid_type")
    end

    -- Check if the parent faction exists, and if it is not the same faction.
    local parent = Faction:GetCached(value)
    if not parent or parent == faction then
        return false, egmt("faction.invalid_parent")
    end

    -- Recursively check.
    while (true) do
        parent = parent:GetParent()
        if not parent then
            break
        end

        if parent == faction then
            return false, egmt("faction.recursion_parent")
        end
    end

    return true
end,
function(faction, ply)
    return true
end)

-- Returns the parent faction of the faction.
--
-- @return Faction parent
function Faction.Meta:GetParent()
    local parentId = self:GetProperty("parentId")
    if parentId == nil then
        return false
    end

    return Faction:GetCached(parentId)
end

-- Returns all children of the faction.
--
-- @return Table children
function Faction.Meta:GetChildren()
    local children = {}

    for _, faction in pairs(Faction:GetCache()) do
        if faction:GetParent() == self then
            table.insert(children, faction)
        end
    end

    return children
end

-- Returns all children of the faction, and their children, and so on.
--
-- @param Faction? faction
-- @return Table children
function Faction.Meta:GetChildrenRecursive()
    local children = self:GetChildren()

    for _, faction in pairs(children) do
        MergeTableByValue(children, faction:GetChildrenRecursive())
    end

    return children
end

-- Add faction property: name
Faction:AddProperty("name", "string", nil, function(faction, value)
    if not isstring(value) or #value < 3 then
        return false, egmt("faction.invalid_name")
    end

    return true
end,
function(faction, ply)
    return true
end)

-- Used to get the name of a faction. Will use the name property or the id as a fallback.
--
-- @return String name
function Faction.Meta:GetName()
    return self:GetProperty("name") or egmt("shared.faction") .. " " .. self:GetId()
end

-- Override the getSort function to sort by name.
function Faction.Meta:GetSort()
    return self:GetName()
end

-- Add faction property: prefix
Faction:AddProperty("prefix", "string", "", function(faction, value)
    if not isstring(value) or #value > 20 then
        return false, egmt("faction.invalid_prefix")
    end

    return true
end,
function(faction, ply)
    return true
end)

-- Used to get the prefix of a faction. Will use the prefix property or an empty string as a fallback.
--
-- @return String prefix
function Faction.Meta:GetPrefix()
    return self:GetProperty("prefix", "")
end

-- Add faction property: color
Faction:AddProperty("color", "color", Color(255, 255, 255), function(faction, value)
    if not IsColor(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(faction, ply)
    return true
end)

-- Used to get the color of a faction. Will use the color property or white as a fallback.
--
-- @return Color color
function Faction.Meta:GetColor()
    return self:GetProperty("color", Color(255, 255, 255))
end

-- Add faction property: description
Faction:AddProperty("description", "string", "", function(faction, value)
    if not isstring(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(faction, ply)
    return true
end)

-- Add faction property: models
Faction:AddProperty("models", "table", {}, function(faction, value)
    if not istable(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(faction, ply)
    return true
end)

-- Returns all models, that are available for that faction.
--
-- @returns Table factionModels
function Faction.Meta:GetModels()
    local factionModels = {}
    for _, model in pairs(self:GetProperty("models", {})) do
        if isstring(model) then
            table.insert(factionModels, model)
        elseif istable(model) then
            -- Check, if one skin is available.
            for _, selected in pairs(model.Skins) do
                if selected then
                    table.insert(factionModels, model.Model)
                    break
                end
            end
        end
    end

    local parentFaction = self:GetParent()
    if parentFaction then
        MergeTableByValue(factionModels, parentFaction:GetModels())
    end

    return FilterBlacklist(factionModels)
end

-- Returns all skins, that are available for that faction given a model.
--
-- @param String model
-- @return Boolean allSkins
-- @return? Table factionSkins
function Faction.Meta:GetSkins(model)
    if not isstring(model) then return false end

    for _, modelData in pairs(self:GetProperty("models", {})) do
        if isstring(modelData) and modelData == model then
            return true
        end

        local factionSkins = {}
        if istable(modelData) and modelData.Model == model then
            for skin, selected in pairs(modelData.Skins) do
                if selected then
                    table.insert(factionSkins, skin)
                end
            end

            return false, factionSkins
        end
    end

    -- Model not found, check parent.
    local parentFaction = self:GetParent()
    if parentFaction then
        return parentFaction:GetSkins(model)
    end

    -- Model not available.
    return false
end

-- Add faction property: weapons
Faction:AddProperty("weapons", "table", {}, function(faction, value)
    if not istable(value) then
        return false, egmt("shared.invalid_type")
    end

    return true
end,
function(faction, ply)
    return true
end)

-- Returns all weapons, that are available for that faction.
--
-- @returns Table factionWeapons
function Faction.Meta:GetWeapons()
    local factionWeapons = table.Copy(self:GetProperty("weapons", {}))

    local parentFaction = self:GetParent()
    if parentFaction then
        MergeTableByValue(factionWeapons, parentFaction:GetWeapons())
    end

    return FilterBlacklist(factionWeapons)
end

-- Limit access to the edit functions.
hook.Add("Faction.CanPlayerEditProperties", "Faction.EditPropertiesPermissions", function(ply, rank, properties)
    return ply:IsAtLeast(Faction.MinAccessGroup)
end)

hook.Add("Faction.CanPlayerCreate", "Faction.CreatePermissions", function(ply, data, properties)
    return ply:IsAtLeast(Faction.MinAccessGroup)
end)

hook.Add("Faction.CanPlayerDelete", "Faction.DeletePermissions", function(ply, faction)
    return ply:IsAtLeast(Faction.MinAccessGroup)
end)

-- Sets up the custom gmod Team on load. (Used for chat)
hook.Add("Faction.Load", "Faction.LoadTeam", function(faction)
    team.SetUp(faction:GetId() + 64, faction:GetName(), faction:GetProperty("color", Color(255, 255, 255)), false)
end)

-- Sets up the custom gmod Team on create. (Used for chat)
hook.Add("Faction.Created", "Faction.CreateTeam", function(faction)
    team.SetUp(faction:GetId() + 64, faction:GetName(), faction:GetProperty("color", Color(255, 255, 255)), false)
end)

-- Set a new color for the team when the color is changed.
hook.Add("Faction.PropertyChanged", "Faction.UpdateTeamColor", function(faction, key, value, oldValue)
    if key == "color" then
        team.SetColor(faction:GetId() + 64, value)
    end
end)
--gamemodes/egmrp/gamemode/core/rank/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--            Rank | Index           --
---------------------------------------

Rank = Rank or table.Copy(PropertyModel)

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("sh_rank.lua")
    AddCSLuaFile("cl_rank.lua")

    AddCSLuaFile("cl_manager.lua")

    include("sh_config.lua")
    include("sh_rank.lua")
    include("sv_rank.lua")

    include("sv_eventlog.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("sh_rank.lua")
    include("cl_rank.lua")

    include("cl_manager.lua")
end
--gamemodes/egmrp/gamemode/core/equipment/cl_manager.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Faction Manager     --
---------------------------------------

-- Add the equipment type to the faction manager.
Manager:RegisterObjectType(
    Faction.Name,
    Equipment.Name,
    egmt("shared.equipment"),
    function(faction)
        return faction:GetEquipment()
    end,
    function(faction)
        return Equipment:Create({factionId = faction:GetId()}, {})
    end,
    function(faction, equip)
        return equip:GetModel():GetPropertyList(faction, equip)
    end,
    egmt("equipment.duplicate"),
    egmt("equipment.delete"),
    egmt("equipment.delete_warning"),
    egmt("equipment.add"),
    egmt("equipment.save")
)
--gamemodes/egmrp/gamemode/core/character/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Charactersystem index       --
---------------------------------------

Character = Character or table.Copy(PropertyModel)
CharacterCreation = CharacterCreation or {}
CharacterSelection = CharacterSelection or {}
CharacterManager = CharacterManager or {}

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("sh_character.lua")
    AddCSLuaFile("cl_character.lua")
    AddCSLuaFile("sh_playerintegration.lua")
    AddCSLuaFile("cl_charactercreation.lua")
    AddCSLuaFile("cl_characterselection.lua")
    AddCSLuaFile("cl_manager.lua")
    AddCSLuaFile("cl_keybinds.lua")
    AddCSLuaFile("cl_scoreboard.lua")

    include("sh_config.lua")
    include("sh_character.lua")
    include("sv_character.lua")
    include("sh_playerintegration.lua")
    include("sv_playerintegration.lua")
    include("sv_manager.lua") -- TODO
    include("sv_chats.lua")
    include("sv_eventlog.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("sh_character.lua")
    include("cl_character.lua")
    include("sh_playerintegration.lua")
    include("cl_charactercreation.lua")
    include("cl_characterselection.lua")
    include("cl_manager.lua") -- TODO
    include("cl_keybinds.lua")
    include("cl_scoreboard.lua")
end
--gamemodes/egmrp/gamemode/core/character/cl_character.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Client | Character        --
---------------------------------------



---------------------------------------
--       Character PropertyList      --
---------------------------------------

-- Clear property list to avoid duplicate entries.
Character.PropertyList = {}

-- Add character properties to list. These are editable in character creation and edit.
Character:AddPropertyToList("name", egmt("shared.name"), egmt("character.name_description"), "string")

Character:AddPropertyToList("modelSkin", egmt("character.model_name"), egmt("character.model_description"), "model", function(rank, faction, character)
    local validModelSkinCombos = {}

    -- Get all models, that are valid first.
    local relevantEquipment = Character:GetRelevantEquipment(character, faction, rank)
    local validModels = Character:GetValidModels(faction, rank, relevantEquipment)

    -- Now we have all valid models, that can be used by the character.
    -- Now we need to get all valid skins for each model.
    for _, model in pairs(validModels) do
        local override = hook.Run("Character.CreationSkipModel", model, faction, rank, relevantEquipment)
        if override then
            continue
        end

        local allSkins, validSkins = Character:GetValidSkins(model, faction, rank, relevantEquipment)

		if allSkins then
			for i = 0, GetModelSkinCount(model) - 1 do
				table.insert(validSkins, i)
			end
		end

		hook.Run("Character.GetValidSkins", character, model, faction, rank, relevantEquipment, validSkins)
		hook.Run("Character.RemoveValidSkins", character, model, faction, rank, relevantEquipment, validSkins)

		-- Add all skins as seperate options.
		for _, skinId in pairs(validSkins or {}) do
			table.insert(validModelSkinCombos, {
				Model = model,
				SkinId = skinId
			})
		end
    end

    return validModelSkinCombos
end, function(rank, faction, character)
    -- Only show Model Selection in the Character Creation
    if IsValid(CharacterCreation.Frame) then
        return true
    end

    return false
end)



---------------------------------------
--        Character Networking       --
---------------------------------------

-- Load and cache a new character data.
net.Receive("Character.Load", function()
    local len = net.ReadInt(32)
    local data = DecompressTable(net.ReadData(len))

    Character:Load(data.data, data.properties):Cache()
end)

-- Remove characters owned by disconnected player from cache.
gameevent.Listen("player_disconnect")
hook.Add("player_disconnect", "Character.RemoveOnDisconnect", function(data)
    local steamId64 = util.SteamIDTo64(data.networkid)

    for k, character in pairs(Character:GetCache()) do
        if character:Get("playerSteamId64") == steamId64 then
            character:RemoveFromCache()
        end
    end
end)

-- Register character package type.
Loading:RegisterPackageType("character", egmt("character.package_name"), function(packageData)
    for k, cData in pairs(packageData) do
        Character:Load(cData.data, cData.properties):Cache()
    end
end)



---------------------------------------
--         Character Editing         --
---------------------------------------

-- Open the character promotion / demotion menu.
function Character.Meta:OpenEditRankMenu()
    local ply = LocalPlayer()

    local faction = self:GetFaction()
    if not faction then return end

    local options = {}
    for _, rank in pairs(faction:GetRanks()) do
        if ply:CanChangeFactionRank(self, rank:GetId()) then
            table.insert(options, {
                text = rank:GetName(),
                data = rank:GetId(),
                authorityLevel = rank:GetProperty("authorityLevel", 0),
            })
        end
    end

    table.SortByMember(options, "authorityLevel")

	local modal = vgui.Create("EGMModal")
	modal:SetCustomTitle(egmt("character.editing"))
	modal:Selection(egmt("character.here_edit_rank_long"), egmt("character.select_rank"), options, function(rankId)
		local success, errors = self:EditData({rankId = rankId})
		if not success then
			for _, error in pairs(errors or {}) do
				Notify:Danger(egmt("shared.error"), error)
			end
		end
	end, nil, egmt("character.set_rank"))
end

-- Open the character faction and rank editing menu.
function Character.Meta:OpenEditFactionMenu()
    local ply = LocalPlayer()

    local currentFaction = self:GetFaction()
    if not currentFaction then return end

	local currentRank = self:GetRank()
	if not currentRank then return end

    local factionOptions = {}
    for _, faction in pairs(Faction:GetCache()) do
        if faction:GetId() == currentFaction:GetId() then continue end

        local ranks = {}
        for _, rank in pairs(faction:GetRanks()) do
            if ply:CanChangeFactionRank(self, rank:GetId(), faction:GetId()) then
                table.insert(ranks, rank)
            end
        end

        if #ranks > 0 then
            table.insert(factionOptions, {
                text = faction:GetName(),
                data = {faction:GetId(), ranks},
            })
        end
    end

    table.SortByMember(factionOptions, "text", true)

	local factionModal = vgui.Create("EGMModal")
	factionModal:SetCustomTitle(egmt("character.editing"))
	factionModal:Selection(egmt("character.here_edit_faction"), egmt("character.select_faction"), factionOptions, function(data)
		local rankOptions = {}
		for _, rank in pairs(data[2]) do
			table.insert(rankOptions, {
				text = rank:GetName(),
				data = rank:GetId(),
				authorityLevel = rank:GetProperty("authorityLevel", 0),
				selected = rank:GetId() == currentRank:GetId()
			})
		end

		table.SortByMember(rankOptions, "authorityLevel")

		local rankModal = vgui.Create("EGMModal")
		rankModal:SetCustomTitle(egmt("character.editing"))
		rankModal:Selection(egmt("character.here_edit_rank"), egmt("character.select_rank"), rankOptions, function(rankId)
			local success, errors = self:EditData({factionId = data[1], rankId = rankId})
			if not success then
				for _, error in pairs(errors or {}) do
					Notify:Danger(egmt("shared.error"), error)
				end
			end
		end, nil, egmt("character.set_rank"))
	end, nil, egmt("character.set_faction"))
end

-- Open the character kicking menu.
-- You can only kick to non-inherited ranks.
function Character.Meta:OpenKickMenu()
    local ply = LocalPlayer()

    local options = {}
    for _, rank in pairs(Rank:GetCache()) do
        if not rank:CanBeKickedOnto() then continue end

        if ply:CanChangeFactionRank(self, rank:GetId(), rank:GetFaction():GetId()) then
            table.insert(options, {
                text = rank:GetFaction():GetProperty("prefix", "") .. " " .. rank:GetName(),
                data = {rank:GetFaction():GetId(), rank:GetId()},
                authorityLevel = rank:GetProperty("authorityLevel", 0),
            })
        end
    end

    table.SortByMember(options, "authorityLevel")

	local modal = vgui.Create("EGMModal")
	modal:SetCustomTitle(egmt("instructor.kick"))
	modal:Selection(egmt("instructor.kick_description"), egmt("character.select_rank"), options, function(data)
		local success, errors = self:EditData({factionId = data[1], rankId = data[2]})
		if not success then
			for _, error in pairs(errors or {}) do
				Notify:Danger(egmt("shared.error"), error)
			end
		end
	end, nil, egmt("character.set_rank"))
end

-- Open the character invitation menu.
function Character.Meta:OpenInviteMenu()
    local ply = LocalPlayer()

    local playerCharacter = ply:GetCurrentCharacter()
    if not playerCharacter then return end

    local playerFaction = playerCharacter:GetFaction()
    if not playerFaction then return end

    local options = {}
    for _, rank in pairs(playerFaction:GetRanks()) do
        if ply:CanChangeFactionRank(self, rank:GetId(), playerFaction:GetId(), true) then
            table.insert(options, {
                text = playerFaction:GetProperty("prefix", "") .. " " .. rank:GetName(),
                data = rank:GetId(),
                authorityLevel = rank:GetProperty("authorityLevel", 0),
            })
        end
    end

    table.SortByMember(options, "authorityLevel")

	local modal = vgui.Create("EGMModal")
	modal:SetCustomTitle(egmt("character.invite"))
	modal:Selection(egmt("character.invite_to_faction"), egmt("character.select_rank"), options, function(rankId)
		net.Start("Character.Invite")
			net.WriteInt(self:GetId(), 32)
			net.WriteInt(playerFaction:GetId(), 32)
			net.WriteInt(rankId, 32)
		net.SendToServer()
	end, nil, egmt("character.invite"))
end

-- Open the character invitation response menu.
--
-- @param Faction faction
-- @param Rank rank
function Character.Meta:OpenInviteResponseMenu(faction, rank)
	local modal = vgui.Create("EGMModal")
	modal:SetCustomTitle(egmt("character.invite"))
	modal:Confirm(egmt("character.confirm_invite", faction:GetName(), rank:GetName()), function()
		net.Start("Character.ConfirmInvite")
			net.WriteBool(true)
		net.SendToServer()
	end,
	function()
		net.Start("Character.ConfirmInvite")
			net.WriteBool(false)
		net.SendToServer()
	end, egmt("shared.accept"), egmt("shared.deny"))
end

net.Receive("Character.Invite", function(len, ply)
    local factionId = net.ReadInt(32)
    local rankId = net.ReadInt(32)

    local faction = Faction:GetCached(factionId)
    if not faction then return end

    local rank = Rank:GetCached(rankId)
    if not rank then return end

    local character = LocalPlayer():GetCurrentCharacter()
    if not character then return end

    character:OpenInviteResponseMenu(faction, rank)
end)
--gamemodes/egmrp/gamemode/core/character/sh_playerintegration.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--  Shared | Char Player Integration --
---------------------------------------

local Player = FindMetaTable("Player")

-- Alias function for Character:GetOwnedByPlayer.
--
-- @return Table characters
function Player:GetCharacters()
    return Character:GetOwnedByPlayer(self)
end



---------------------------------------
--           Character Name          --
---------------------------------------

-- Copies the old Name function into SteamName.
if not Player.SteamName then
    Player.SteamName = Player.Name
end

-- Overrides the GetName of player, so it displayes the name of the character if needed.
function Player:Name()
    local currentCharacter = self:GetCurrentCharacter()

    if currentCharacter then
        return currentCharacter:GetName()
    end

    return self:SteamName()
end

-- Copies to the aliases of GetName
Player.GetName = Player.Name
Player.Nick = Player.Name



---------------------------------------
--         Current Character         --
---------------------------------------

-- Tries to get the current character id from the player.
--
-- @return Number currentCharacterId
function Player:GetCurrentCharacterId()
    return self:GetNWInt("CurrentCharacterId", -1)
end

-- Tries to get the current character of the player from cache.
--
-- @return Table character or false
function Player:GetCurrentCharacter()
    return Character:GetCached(self:GetCurrentCharacterId()) or false
end

-- Checks whether the character is the current character of the owner.
--
-- @return Boolean isCurrentCharacter
function Character.Meta:IsCurrentCharacter()
    local ply = self:GetOwner()

    if ply then
        return ply:GetCurrentCharacterId() == self:GetId()
    end

    return false
end

-- Returns the roleplay name of the player.
--
-- @return String name
function Player:GetCurrentCharacterFullName()
    local character = self:GetCurrentCharacter()

    if character then
        return character:GetFullName()
    end

    return self:SteamName()
end

-- Returns the name of the faction of the player.
--
-- @return String name
function Player:GetCurrentCharacterFactionName()
    local character = self:GetCurrentCharacter()

    if character then
        return character:GetFactionName()
    end

    return ""
end

-- Returns the color of the faction of the player.
--
-- @return String name
function Player:GetCurrentCharacterFactionColor()
    local character = self:GetCurrentCharacter()

    if character then
        return character:GetFactionColor()
    end

    return Color(255, 255, 255, 255)
end

-- Returns the name of the rank of the player.
--
-- @return String name
function Player:GetCurrentCharacterRankName()
    local character = self:GetCurrentCharacter()

    if character then
        return character:GetRankName()
    end

    return ""
end

-- Returns the color of the rank of the player.
--
-- @return String name
function Player:GetCurrentCharacterRankColor()
    local character = self:GetCurrentCharacter()

    if character then
        return character:GetRankColor()
    end

    return Color(255, 255, 255, 255)
end



---------------------------------------
--       Character Permissions       --
---------------------------------------

-- Checks, whether the player can create a character with the given rank.
--
-- @param Number rank
-- @return Boolean canCreate
function Player:CanCreateCharacter(rank)
	-- Check slot limits.
	local success = self:IsSlotFree(rank)
	if not success then
		return false
	end

	local override = hook.Run("Player.CanCreateCharacter", self, rank)
	if override ~= nil then
		return override
	end

	if rank:IsStartRank() then
		return true
	end

	return false
end

-- Only allow creation of own characters.
hook.Add("Character.CanPlayerCreate", "Character.CreatePermissions", function(ply, data, properties)
    if data.playerSteamId64 ~= ply:SteamID64() then
        return false
    end

    local rank = Rank:GetCached(data["rankId"])
    if not rank then
        return false
    end

    return ply:CanCreateCharacter(rank)
end)

-- Only allow staff and character owners to delete characters.
hook.Add("Character.CanPlayerDelete", "Character.DeletePermissions", function(ply, character)
    if ply:IsAtLeast(Character.MinAccessGroup) then
        return true
    end

    if Character.CanDeleteOwnCharacter and character:Get("playerSteamId64") == ply:SteamID64() then
        return true
    end
end)

-- Only superadmins should be allowed to edit character properties.
hook.Add("Character.CanPlayerEditProperties", "Character.EditPropertiesPermissions", function(ply, character, properties)
    if ply:IsAtLeast(Character.MinFullAccessGroup) then
        return true
    end
end)

hook.Add("Character.CanPlayerEditProperty.name", "Character.EditNamePermissions", function(ply, character, value)
    if ply:IsAtLeast(Character.MinAccessGroup) or (Character.CanSelfEdit  and character:BelongsTo(ply)) then
        return true
    end
end)

hook.Add("Character.CanPlayerEditProperty.modelSkin", "Character.EditModelPermissions", function(ply, character, value)
    if ply:IsAtLeast(Character.MinAccessGroup) or character:BelongsTo(ply) then
        return true
    end
end)

-- Check if a rank has the authority to change another person rank to a specific rank.
--
-- @param Faction playerFaction
-- @param Rank playerRank
-- @param Faction currentFaction
-- @param Rank currentRank
-- @param Faction targetFaction
-- @param Rank targetRank
-- @param Boolean? inviteConfirmed
-- @return Boolean canChangeRank
function Player:CanChangeRankInternal(playerFaction, playerRank, currentFaction, currentRank, targetFaction, targetRank, inviteConfirmed)
	-- print("\nPlayer:CanChangeRankInternal", self, playerFaction, playerRank, currentFaction, currentRank, targetFaction, targetRank, inviteConfirmed)

	if not targetFaction or not targetRank or not targetFaction:HasRank(targetRank) then
		return false
	end

	local override = hook.Run("Player.CanChangeRankInternal", self, playerFaction, playerRank, currentFaction, currentRank, targetFaction, targetRank, inviteConfirmed)
	if isbool(override) then
		return override
	end

	-- Staff members can always change ranks.
	if self:IsAtLeast(Character.MinAccessGroup) then
		return true
	end

	if not playerFaction or not playerRank or not playerFaction:HasRank(playerRank) then
		return false
	end

	-- Invite to the faction.
	-- Specialized case moved up here and made compatible with inviting even if there is no current rank or faction.
	if (not istable(currentFaction) or currentFaction:GetId() ~= targetFaction:GetId())
	and playerFaction:GetId() == targetFaction:GetId() then
		-- Only allow invite permisions, if they are through the invite system.
		-- The target needs to accept the invite, before the rank can be changed.
		if not inviteConfirmed then
			return false
		end

		-- Check Permission.
		if not playerRank:HasPermission(RANK_PERMISSION_INVITE) then
			return false
		end

		-- Compare the authority levels after inviting.
		if playerRank:GetAuthorityLevel() <= targetRank:GetAuthorityLevel() then
			return false
		end

		return true
	end

	if not currentFaction or not currentRank or not currentFaction:HasRank(currentRank) then
		return false
	end

	-- There are multiple operations, that can be performed.
	-- 1. Promote / Demote in the faction.
	-- 2. Kick from the faction.
	-- 3. Invite to the faction.

	-- Check, if we are promoting, demoting or kicking.
	if playerFaction:GetId() == currentFaction:GetId() then
		-- Promote / Demote in the faction.
		if playerFaction:GetId() == targetFaction:GetId() then
			-- Check Permission.
			if not playerRank:HasPermission(RANK_PERMISSION_PROMOTE) then
				return false
			end

			-- Check authority levels before promoting.
			if playerRank:GetAuthorityLevel() <= currentRank:GetAuthorityLevel() then
				return false
			end

			-- Check authority levels after promoting.
			if playerRank:GetAuthorityLevel() <= targetRank:GetAuthorityLevel() then
				return false
			end

			return true

		-- Kick from the faction.
		else
			-- Check, if we are already on the lowest rank, but only if we are on the base faction of the rank.
			if currentRank:CanBeKickedOnto() and currentRank:GetFaction() == currentFaction then
				return false
			end

			-- Check, if the target rank can be kicked onto.
			if not targetRank:CanBeKickedOnto() then
				return false
			end

			-- Only allow kicking, if the faction matches the ranks original faction.
			if targetRank:GetFaction() ~= targetFaction then
				return false
			end

			-- Check Permission.
			if not playerRank:HasPermission(RANK_PERMISSION_KICK) then
				return false
			end

			-- Compare the authority levels before kicking.
			if playerRank:GetAuthorityLevel() <= currentRank:GetAuthorityLevel() then
				return false
			end

			-- Compare the authority levels after kicking.
			if playerRank:GetAuthorityLevel() <= targetRank:GetAuthorityLevel() then
				return false
			end

			return true
		end
	end

	return false
end

-- Checks, whether the player can set a character to a rank in a faction.
--
-- @param Character character
-- @param Number rankId
-- @param? Number factionId
-- @param? Boolean inviteConfirmed
-- @return Boolean canChangeFactionRank
function Player:CanChangeFactionRank(character, rankId, factionId, inviteConfirmed)
	-- print("\nPlayer:CanChangeFactionRank", self, character, rankId, factionId, inviteConfirmed)

	-- Hooks, to overwrite this function.
	local blockOverride = hook.Run("Player.BlockChangeFactionRank", self, character, rankId, factionId, inviteConfirmed)
	if isbool(blockOverride) then
		return false
	end

	local override = hook.Run("Player.CanChangeFactionRank", self, character, rankId, factionId, inviteConfirmed)
	if isbool(override) then
		return override
	end

	local playerCharacter = self:GetCurrentCharacter()
	if not playerCharacter then
		return false
	end

	local playerFaction = playerCharacter:GetFaction()
	local playerRank = playerCharacter:GetRank()

	local currentFaction = character:GetFaction()
	local currentRank = character:GetRank()

	local targetFaction = currentFaction
	if isnumber(factionId) then
		targetFaction = Faction:GetCached(factionId)
	end

	local targetRank = Rank:GetCached(rankId)

	return self:CanChangeRankInternal(playerFaction, playerRank, currentFaction, currentRank, targetFaction, targetRank, inviteConfirmed)
end

-- Permission check for editing character data.
hook.Add("Character.CanPlayerEditData", "Character.CheckPermissions", function(ply, character, data)
	local rankId = data["rankId"]
	if not isnumber(rankId) then
		rankId = character:Get("rankId", -1)
	end

	local factionId = data["factionId"]

	if ply:CanChangeFactionRank(character, rankId, factionId) then
		return true
	end
end)
--gamemodes/egmrp/gamemode/core/character/cl_manager.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
---------------------------------------
--    Client | Character Manager     --
---------------------------------------

-- Opens the character manager.
function CharacterManager:Open()
    self:CloseMenu()

    self.Frame = vgui.Create("EGMFrame")
    self.Frame:SetBackground(self.Background)
    self.Frame:SetSubTitle(egmt("character.manager"))
    function self.Frame:OnClose()
        -- Reset runtime variables on close.
        CharacterManager.CurrentCharacter = nil
        CharacterManager.Loading = nil
    end

    -- Faction selection.
    self.FactionSelection = vgui.Create("DPanel", self.Frame)
    self.FactionSelection:SetPos(ScrW() * 0.1, ScrH() * 0.25)
    self.FactionSelection:SetSize(ScrW() * 0.18, ScrH() * 0.575)
    function self.FactionSelection:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, ColorAlpha(UI.BackgroundColor, 255))
    end

    self.FactionList = vgui.Create("EGMListView", self.FactionSelection)
    self.FactionList:Dock(FILL)
    self.FactionList:SetHeaderHeight(ScrH() * 0.05)
    self.FactionList:SetDataHeight(ScrH() * 0.03)
    self.FactionList:SetMultiSelect(false)
    self.FactionList:AddCustomColumn(egmt("character.faction_selection"))
    function self.FactionList:OnRowSelected(index, line)
        -- Reset load offline players when changing the faction.
        CharacterManager.LoadOfflineCharactersCheckBox:SetChecked(false)

        -- Reset page when changing the faction.
        CharacterManager.PageSelection:SetPage(1)
        CharacterManager.PageSelection:SetPageCount(1)

        -- Reset rank selection.
        CharacterManager.SelectedRank = nil
        CharacterManager.RankSelection:Clear()
        CharacterManager.RankSelection:SetValue(egmt("character.rank_selection"))
        CharacterManager.RankSelection:AddChoice(egmt("character.nofilter"), nil)
        for k, rank in pairs(line.faction:GetRanks()) do
            if rank:IsValid() then
                CharacterManager.RankSelection:AddChoice(rank:GetName(), rank)
            end
        end

        local success, errors = line.faction:IsValid()

        if not success then
            for k, v in pairs(errors) do
                Notify:Danger(egmt("character.faction_invalid"), v)
            end
        end

        CharacterManager.SelectedFaction = line.faction
        CharacterManager:LoadCharacters()
    end
    function self.FactionList:Think()
        if CharacterManager.Loading then
            self:SetEnabled(false)
        else
            self:SetEnabled(true)
        end
    end

    -- Add every faction to the faction selection.
    for k, faction in pairs(Faction:GetCache()) do
        local line = self.FactionList:AddCustomLine(faction:GetName())
        line.faction = faction

        if not faction:IsValid() then
            line:SetCustomTextColor(GetColor("red"))
        end
    end

    self.FactionList:SortByColumn(1)

    self.FactionFilter = vgui.Create("DTextEntry", self.FactionSelection)
    self.FactionFilter:SetHeight(ScrH() * 0.025)
    self.FactionFilter:Dock(BOTTOM)
    self.FactionFilter:SetPlaceholderText(egmt("shared.searching"))
    function self.FactionFilter:OnValueChange(newFilter)
        CharacterManager.FactionList:Clear()

        for k, faction in pairs(Faction:GetCache()) do
            if string.find(string.lower(faction:GetName()), string.lower(newFilter)) then
                local line = CharacterManager.FactionList:AddCustomLine(faction:GetName())
                line.faction = faction

                if not faction:IsValid() then
                    line:SetCustomTextColor(GetColor("red"))
                end
            end
        end
    end
    function self.FactionFilter:Think()
        if CharacterManager.Loading then
            self:SetEnabled(false)
        else
            self:SetEnabled(true)
        end
    end

    self.RankSelection = vgui.Create("DComboBox", self.Frame)
    self.RankSelection:SetPos(ScrW() * 0.1, ScrH() * 0.85)
    self.RankSelection:SetSize(ScrW() * 0.18, ScrH() * 0.05)
    self.RankSelection:SetValue(egmt("character.rank_selection"))
    function self.RankSelection:OnSelect(index, value, data)
        CharacterManager.SelectedRank = data
        CharacterManager:LoadCharacters()
    end

    -- Character selection.
    self.CharacterSelection = vgui.Create("DPanel", self.Frame)
    self.CharacterSelection:SetPos(ScrW() * 0.3, ScrH() * 0.25)
    self.CharacterSelection:SetSize(ScrW() * 0.18, ScrH() * 0.65)
    self.CharacterSelection:SetVisible(false)
    function self.CharacterSelection:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, ColorAlpha(UI.BackgroundColor, 255))
    end

    self.CharacterList = vgui.Create("EGMListView", self.CharacterSelection)
    self.CharacterList:Dock(FILL)
    self.CharacterList:SetHeaderHeight(ScrH() * 0.05)
    self.CharacterList:SetDataHeight(ScrH() * 0.03)
    self.CharacterList:SetMultiSelect(false)

    self.CharacterList:AddCustomColumn(egmt("character.selection"))
    function self.CharacterList:OnRowSelected(index, line)
        CharacterManager:ShowCharacter(line.character)
    end

    self.CharacterListLoadingHint = vgui.Create("DLabel", self.CharacterList)
    self.CharacterListLoadingHint:Dock(FILL)
    self.CharacterListLoadingHint:SetText("")
    function self.CharacterListLoadingHint:Paint(width, height)
        if CharacterManager.Loading then
            draw.SimpleText(egmt("shared.loading_content"), "EGMText12", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER)
        elseif #CharacterManager.CharacterList:GetLines() == 0 then
            if CharacterManager.LoadOfflineCharactersCheckBox:GetChecked() then
                draw.SimpleText(egmt("shared.no_results"), "EGMText12", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER)
            else
                draw.SimpleText(egmt("character.none_online"), "EGMText12", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER)
            end
        end
    end

    self.LoadOfflineCharactersCheckBox = vgui.Create("EGMCheckBox", self.CharacterSelection)
    self.LoadOfflineCharactersCheckBox:SetPos(ScrW() * 0.15, ScrH() * 0.0125)
    self.LoadOfflineCharactersCheckBox:SetSize(ScrH() * 0.025, ScrH() * 0.025)
    self.LoadOfflineCharactersCheckBox:SetChecked(false)
    self.LoadOfflineCharactersCheckBox:SetTooltip(egmt("character.load_offline"))
    function self.LoadOfflineCharactersCheckBox:OnChange()
        -- Reset pages when loading offline.
        CharacterManager.PageSelection:SetPage(1)
        CharacterManager.PageSelection:SetPageCount(1)

        CharacterManager:LoadCharacters()
    end
    function self.LoadOfflineCharactersCheckBox:Think()
        if CharacterManager.Loading then
            self:SetEnabled(false)
        else
            self:SetEnabled(true)
        end
    end

    self.CharacterFilter = vgui.Create("DTextEntry", self.CharacterSelection)
    self.CharacterFilter:SetHeight(ScrH() * 0.025)
    self.CharacterFilter:Dock(BOTTOM)
    self.CharacterFilter:SetPlaceholderText(egmt("shared.searching"))
    function self.CharacterFilter:OnValueChange(newFilter)
        -- Reset pages when selecting a new filter.
        CharacterManager.PageSelection:SetPage(1)
        CharacterManager.PageSelection:SetPageCount(1)

        CharacterManager:LoadCharacters()
    end
    function self.CharacterFilter:Think()
        if CharacterManager.Loading then
            self:SetEnabled(false)
        else
            self:SetEnabled(true)
        end
    end

    self.PageSelection = vgui.Create("EGMPageSelector", self.CharacterSelection)
    self.PageSelection:SetHeight(ScrH() * 0.025)
    self.PageSelection:Dock(BOTTOM)
    self.PageSelection:SetPage(1)
    self.PageSelection:SetPageCount(1)
    self.PageSelection:SetCallback(function(newPage)
        CharacterManager:LoadCharacters()
    end)
    function self.PageSelection:Think()
        if CharacterManager.Loading then
            self:SetEnabled(false)
        else
            self:SetEnabled(true)
        end
    end

    -- Character Panel
    local w, h = ScrW() * 0.4, ScrH() * 0.65 -- Size of the character panel.

    self.CharacterPanel = vgui.Create("DPanel", self.Frame)
    self.CharacterPanel:SetPos(ScrW() * 0.5, ScrH() * 0.25)
    self.CharacterPanel:SetSize(w, h)
    self.CharacterPanel:SetVisible(false)
    function self.CharacterPanel:Paint(width, height)
        draw.RoundedBox(5, 0, 0, width, height, UI.BackgroundColor2)
    end

    self.CharacterName = vgui.Create("DLabel", self.CharacterPanel)
    self.CharacterName:SetPos(w * 0.05, h * 0.05)
    self.CharacterName:SetTextColor(UI.TextColor)
    self.CharacterName:SetFont("EGMText15")

    self.CharacterDeleteButton = vgui.Create("EGMButton", self.CharacterPanel)
    self.CharacterDeleteButton:SetPos(w * 0.75, h * 0.055)
    self.CharacterDeleteButton:SetSize(w * 0.2, h * 0.05)
    self.CharacterDeleteButton:SetTextColor(UI.TextColor)
    self.CharacterDeleteButton:SetFont("EGMText10")
    self.CharacterDeleteButton:SetText(egmt("shared.delete"))
    self.CharacterDeleteButton:SetButtonColor(GetColor("red"))
    function self.CharacterDeleteButton:DoClick()
		local modal = vgui.Create("EGMModal")
		modal:SetCustomTitle(egmt("shared.are_you_sure"))
		modal:Confirm(egmt("character.delete_warning"), function()
			CharacterManager.CurrentCharacter:Delete()

			local modal2 = vgui.Create("EGMModal")
			modal2:SetCustomTitle(egmt("shared.please_wait"))
			modal2:Notify(egmt("character.deletion_process"), false)
			CharacterManager.CharacterDeletionModal = modal2
		end)
    end

    self.CharacterProperties = vgui.Create("DPanel", self.CharacterPanel)
    self.CharacterProperties:SetPos(w * 0.05, h * 0.15)
    self.CharacterProperties:SetSize(w * 0.45, h * 0.8)
    function self.CharacterProperties:Paint(width, height)
    end

    self.CharacterPropertiesList = vgui.Create("EGMScrollPanel", self.CharacterProperties)
    self.CharacterPropertiesList:Dock(FILL)
    self.CharacterPropertiesList:SetBackgroundColor(Color(0, 0, 0, 0))

    self.CharacterPropertiesSave = vgui.Create("EGMButton", self.CharacterProperties)
    self.CharacterPropertiesSave:SetHeight(h * 0.05)
    self.CharacterPropertiesSave:Dock(BOTTOM)
    self.CharacterPropertiesSave:SetTextColor(UI.TextColor)
    self.CharacterPropertiesSave:SetFont("EGMText10")
    self.CharacterPropertiesSave:SetText(egmt("character.save"))
    function self.CharacterPropertiesSave:DoClick()
        local properties = {}
        for k, v in pairs(CharacterManager.CharacterPropertiesList.Values) do
            properties[k] = v()
        end

        local success, errors = CharacterManager.CurrentCharacter:EditProperties(properties)
        if success then
			local modal = vgui.Create("EGMModal")
			modal:SetCustomTitle(egmt("shared.please_wait"))
			modal:Notify(egmt("character.saving_process"), false)
			CharacterManager.CharacterEditModal = modal
        else
            if errors then
                for k, v in pairs(errors) do
                    Notify:Danger(egmt("shared.invalid_property"), v)
                end
            else
                Notify:Danger(egmt("shared.unknown_error"))
            end
        end
    end

    self.CharacterInfoPanel = vgui.Create("RichText", self.CharacterPanel)
    self.CharacterInfoPanel:SetPos(w * 0.55, h * 0.15)
    self.CharacterInfoPanel:SetSize(w * 0.4, h * 0.35)
    function self.CharacterInfoPanel:PerformLayout()
        self:SetFontInternal("EGMText8")
    end

    self.ShowPlayerButton = vgui.Create("EGMButton", self.CharacterPanel)
    self.ShowPlayerButton:SetPos(w * 0.55, h * 0.55)
    self.ShowPlayerButton:SetSize(w * 0.4, h * 0.05)
    self.ShowPlayerButton:SetTextColor(UI.TextColor)
    self.ShowPlayerButton:SetFont("EGMText10")
    self.ShowPlayerButton:SetText(egmt("character.display_owner"))
    function self.ShowPlayerButton:DoClick()
        local character = CharacterManager.CurrentCharacter

        -- Open the player manager
        PlayerManager:Open()

        -- Enable offline loading if the character owner is not online.
        if not character:GetOwner() then
            PlayerManager.LoadOfflineCheckBox:SetChecked(true)
        end

        -- Fill the steamid to the search field (searching is done automatically because of OnValueChange).
        PlayerManager.Filter:SetValue(character:Get("playerSteamId64"))

        -- Now close the character manager.
        CharacterManager:CloseMenu()
    end

    self.EditFactionButton = vgui.Create("EGMButton", self.CharacterPanel)
    self.EditFactionButton:SetPos(w * 0.55, h * 0.625)
    self.EditFactionButton:SetSize(w * 0.4, h * 0.05)
    self.EditFactionButton:SetTextColor(UI.TextColor)
    self.EditFactionButton:SetFont("EGMText10")
    self.EditFactionButton:SetText(egmt("character.set_faction"))
    function self.EditFactionButton:DoClick()
        CharacterManager.CurrentCharacter:OpenEditFactionMenu()
    end

    self.KickButton = vgui.Create("EGMButton", self.CharacterPanel)
    self.KickButton:SetPos(w * 0.55, h * 0.675)
    self.KickButton:SetSize(w * 0.4, h * 0.05)
    self.KickButton:SetTextColor(UI.TextColor)
    self.KickButton:SetFont("EGMText10")
    self.KickButton:SetText(egmt("permission.kick"))
    self.KickButton:SetButtonColor(GetColor("red"))
    function self.KickButton:DoClick()
        CharacterManager.CurrentCharacter:OpenKickMenu()
    end

    self.PromoteDemoteButton = vgui.Create("EGMButton", self.CharacterPanel)
    self.PromoteDemoteButton:SetPos(w * 0.55, h * 0.725)
    self.PromoteDemoteButton:SetSize(w * 0.4, h * 0.05)
    self.PromoteDemoteButton:SetTextColor(UI.TextColor)
    self.PromoteDemoteButton:SetFont("EGMText10")
    self.PromoteDemoteButton:SetText(egmt("character.set_rank"))
    self.PromoteDemoteButton:SetButtonColor(GetColor("green"))
    function self.PromoteDemoteButton:DoClick()
        CharacterManager.CurrentCharacter:OpenEditRankMenu()
    end

    hook.Run("CharacterManager.Open", self, w, h)

    self.Frame:MakePopup()
end

-- Inform about successfull character deletion.
hook.Add("Character.DeletionSuccess", "Character.CharacterDeletionSuccess", function()
    if CharacterManager.CharacterDeletionModal then
        CharacterManager.CharacterDeletionModal:SetCustomTitle(egmt("shared.success"))
        CharacterManager.CharacterDeletionModal:SetBarColor(GetColor("green"))
        CharacterManager.CharacterDeletionModal:Notify(egmt("character.deletion_successfull"), nil, nil, GetColor("lightgray"), function()
            -- Remove currently selected (deleted) character from list.
            CharacterManager.CharacterList:RemoveLine(CharacterManager.CharacterList:GetSelectedLine())

            -- Show player info.
            CharacterManager.CharacterPanel:SetVisible(false)

            CharacterManager.CharacterDeletionModal = nil
        end)
    end
end)

-- Inform about character deletion error.
hook.Add("Character.DeletionError", "Character.CharacterDeletionError", function()
    if CharacterManager.CharacterDeletionModal then
        CharacterManager.CharacterDeletionModal:SetCustomTitle(egmt("shared.error"))
        CharacterManager.CharacterDeletionModal:SetBarColor(GetColor("red"))
        CharacterManager.CharacterDeletionModal:Notify(egmt("character.deletion_error"), nil, nil, GetColor("lightgray"), function()
            CharacterManager.CharacterDeletionModal = nil
        end)
    end
end)

-- Inform about successfull character edit.
hook.Add("Character.EditDataSuccess", "CharacterManager.CharacterEditPropertiesSuccess", function()
    if CharacterManager.CharacterEditDataModal then
        CharacterManager.CharacterEditDataModal:SetCustomTitle(egmt("shared.success"))
        CharacterManager.CharacterEditDataModal:SetBarColor(GetColor("green"))
        CharacterManager.CharacterEditDataModal:Notify(egmt("character.saving_successfull"), nil, nil, GetColor("lightgray"), function()
            -- Manually set the changed rankId for offline characters.
            -- This is not done automatically, because changes of offline data is not synced.
            local character = CharacterManager.CurrentCharacter
            if character and not character:GetOwner() then
                -- The rankId to which we changed is saved in the modal.
                local targetRankId = CharacterManager.CharacterEditDataModal.rankId
                if targetRankId then
                    character:SetData("rankId", targetRankId, true)

                    -- Call this hook so that the menu gets refreshed.
                    hook.Run("Character.DataChanged", character)
                end
            end

            CharacterManager.CharacterEditDataModal = nil
        end)
    end
end)

-- Inform about character edit error.
hook.Add("Character.EditDataError", "CharacterManager.CharacterEditError", function()
    if CharacterManager.CharacterEditDataModal then
        CharacterManager.CharacterEditDataModal:SetCustomTitle(egmt("shared.error"))
        CharacterManager.CharacterEditDataModal:SetBarColor(GetColor("red"))
        CharacterManager.CharacterEditDataModal:Notify(egmt("character.saving_error"), nil, nil, GetColor("lightgray"), function()
            CharacterManager.CharacterEditDataModal = nil
        end)
    end
end)

-- Inform about successfull character edit.
hook.Add("Character.EditPropertiesSuccess", "CharacterManager.CharacterEditPropertiesSuccess", function()
    if CharacterManager.CharacterEditModal then
        CharacterManager.CharacterEditModal:SetCustomTitle(egmt("shared.success"))
        CharacterManager.CharacterEditModal:SetBarColor(GetColor("green"))
        CharacterManager.CharacterEditModal:Notify(egmt("character.saving_successfull"), nil, nil, GetColor("lightgray"), function()
            CharacterManager.CharacterEditModal = nil

            -- Manually update properties of offline characters. This is not done automatically, because changes of offline data is not synced.
            local character = CharacterManager.CurrentCharacter
            if character and not character:GetOwner() then
                 -- Collect changed properties from the propertylist and assign them.
                local properties = {}
                for k, v in pairs(CharacterManager.CharacterPropertiesList.Values) do
                    properties[k] = v()
                end

                character:SetProperties(properties, true)

                -- Call this hook so that the menu gets refreshed.
                hook.Run("Character.PropertyChanged", character)
            end
        end)
    end
end)

-- Inform about character edit error.
hook.Add("Character.EditPropertiesError", "CharacterManager.CharacterEditError", function()
    if CharacterManager.CharacterEditModal then
        CharacterManager.CharacterEditModal:SetCustomTitle(egmt("shared.error"))
        CharacterManager.CharacterEditModal:SetBarColor(GetColor("red"))
        CharacterManager.CharacterEditModal:Notify(egmt("character.saving_error"), nil, nil, GetColor("lightgray"), function()
            CharacterManager.CharacterEditModal = nil
        end)
    end
end)

-- Loads the characters based on the current selected faction, page, filter and loadOffline value.
-- Called when the selected faction, load offline, character page or character filter got changed.
--
-- @param Boolean preventAutoSelection - disables the feature to select the first item, if there is only one. Used for the player manager integration.
function CharacterManager:LoadCharacters(preventAutoSelection)
    self.CharacterList:Clear()
    self.CharacterSelection:SetVisible(true)
    self.CharacterPanel:SetVisible(false)
    self.CurrentCharacter = nil

    local faction = self.SelectedFaction
    local rank = self.SelectedRank
    local loadOffline = self.LoadOfflineCharactersCheckBox:GetChecked()
    local filter = self.CharacterFilter:GetValue()
    local page = self.PageSelection:GetPage()
    local id = faction:GetId()
    local loadByFaction = true

    if rank then
        id = rank:GetId()
        loadByFaction = false
    end

    if not loadOffline then
        local characters = {}

		if loadByFaction then
			for k, character in pairs(Character:GetByFaction(id)) do
				if string.find(string.lower(character:GetName()), string.lower(filter)) then
					table.insert(characters, character)
				end
			end

			-- Allow other modules, to add characters to the list.
			hook.Run("CharacterManager.LoadByFaction", characters, id, filter)
		else
			for k, character in pairs(Character:GetByRank(id)) do
				if character:GetFaction():GetId() ~= faction:GetId() then continue end

				if string.find(string.lower(character:GetName()), string.lower(filter)) then
					table.insert(characters, character)
				end
			end

			-- Allow other modules, to add characters to the list.
			hook.Run("CharacterManager.LoadByRank", characters, faction:GetId(), id, filter)
		end

        -- Set the number of pages.
        local pages = math.max(math.ceil(#characters / self.PageSize), 1)
        self.PageSelection:SetPageCount(pages)

        -- Add every character to the list.
        for k, character in SortedPairs(characters) do
            if not character:GetRank() then continue end

            if k > (page - 1) * self.PageSize and k <= page * self.PageSize then
                local name = character:GetRank():GetProperty("prefix", "") .. " " .. character:GetName()
                local line = self.CharacterList:AddSortedLine(name, character:GetRank():GetAuthorityLevel())
                line.character = character

                if character:GetFaction() ~= faction then
                    line:SetCustomTextColor(GetColor("green"))
                end
                if not character:IsValid() then
                    line:SetCustomTextColor(GetColor("red"))
                end
            end
        end

        -- Sort characters by permission level.
        self.CharacterList:SortByColumns(1, false)

        -- Automatically select the first item, if there is only one.
        if not preventAutoSelection and #self.CharacterList:GetLines() == 1 then
            self.CharacterList:SelectFirstItem()
        end
    else
        self.Loading = true

        net.Start("CharacterManager.OfflineCharacters")
            net.WriteString(filter)
            net.WriteInt(page, 32)
            net.WriteInt(faction:GetId(), 32)
            net.WriteInt(loadByFaction and -1 or rank:GetId(), 32)
        net.SendToServer()
    end
end

-- Net Receiver for offline characters.
net.Receive("CharacterManager.OfflineCharacters", function()
	if not IsValid(CharacterManager.Frame) then return end

    CharacterManager.Loading = false

    local len = net.ReadInt(32)
    local characterData = DecompressTable(net.ReadData(len))
    local pages = net.ReadInt(32)
    for k, data in pairs(characterData) do
        local character = Character:Load(data.data, data.properties)

        local prefix = ""
        local authorityLevel = 0

		local rank = character:GetRank()
        if rank then
            prefix = rank:GetProperty("prefix", "") .. " "
            authorityLevel = rank:GetAuthorityLevel()
        end

        local name = prefix .. character:GetName()

        local line = CharacterManager.CharacterList:AddSortedLine(name, authorityLevel)
        line.character = character

        if character:GetFaction() ~= CharacterManager.SelectedFaction then
            line:SetCustomTextColor(GetColor("green"))
        end
        if not character:IsValid() then
            line:SetCustomTextColor(GetColor("red"))
        end
    end

    -- Sort characters by permission level.
    CharacterManager.CharacterList:SortByColumns(1, false)

    -- Automatically select the first item, if there is only one.
     if #CharacterManager.CharacterList:GetLines() == 1 then
        CharacterManager.CharacterList:SelectFirstItem()
    end

    CharacterManager.PageSelection:SetPageCount(pages)
end)

-- Net receiver for loading errors.
net.Receive("CharacterManager.OfflineCharactersError", function(len, ply)
    CharacterManager:CloseMenu()
    Notify:Danger(egmt("shared.error"), egmt("shared.offline_error"))
end)

-- Shows the given character in the character panel.
--
-- @param Table character
function CharacterManager:ShowCharacter(character)
    self.CharacterPanel:SetVisible(true)

    local success, errors = character:IsValid()

    if not success then
        for k, v in pairs(errors) do
            Notify:Danger(egmt("character.invalid"), v)
        end
    end

    self.CurrentCharacter = character
    local faction = character:GetFaction()
    local rank = character:GetRank()

    self.CharacterName:SetText(character:GetFullName())
    self.CharacterName:SizeToContents()

    local globalCanEdit = false
    self.CharacterPropertiesList.Values, globalCanEdit = CreatePropertyList(
        self.CharacterPropertiesList,
        Character:GetPropertyList(character:GetRank(), character:GetFaction(), character),
        character
    )
    self.CharacterPropertiesSave:SetDisabled(not globalCanEdit)

    self.CharacterInfoPanel:SetText("")

    self.CharacterInfoPanel:InsertColorChange(GetColor2("blue"))
    self.CharacterInfoPanel:AppendText(egmt("character.created_on"))
    self.CharacterInfoPanel:InsertColorChange(GetColor2("white"))
    self.CharacterInfoPanel:AppendText(os.date(egmt("shared.date_time"), character:Get("created", 0)) .. "\n\n")

    self.CharacterInfoPanel:InsertColorChange(GetColor2("blue"))
    self.CharacterInfoPanel:AppendText(egmt("character.lastplayed_at"))
    self.CharacterInfoPanel:InsertColorChange(GetColor2("white"))
    self.CharacterInfoPanel:AppendText(os.date(egmt("shared.date_time"), character:GetProperty("lastplayed", 0)) .. "\n\n")

    self.CharacterDeleteButton:SetEnabled(character:CanPlayerDelete(LocalPlayer()))

    -- Only enable the edit buttons, if we can change to at least one rank.
    self.EditFactionButton:SetEnabled(false)
    self.KickButton:SetEnabled(false)
    self.PromoteDemoteButton:SetEnabled(false)

    -- Check if we can change the faction and rank. (This includes inviting and kicking.)
    for _, otherFaction in pairs(Faction:GetCache()) do
        for _, targetRank in pairs(otherFaction:GetRanks()) do
            if LocalPlayer():CanChangeFactionRank(character, targetRank:GetId(), otherFaction:GetId()) then
                self.EditFactionButton:SetEnabled(true)

                -- If the rank can be kicked onto, enable the kick button.
                if targetRank:CanBeKickedOnto() then
                    self.KickButton:SetEnabled(true)
                end

                break
            end
        end
    end

    -- Check if we can promote or demote the character.
    if faction then
        for _, targetRank in pairs(faction:GetRanks()) do
            if LocalPlayer():CanChangeFactionRank(character, targetRank:GetId()) then
                self.PromoteDemoteButton:SetEnabled(true)
                break
            end
        end
    end

    hook.Run("CharcterManager.ShowCharacter", self, character, faction, rank)

    --[[
    if Config.Modules["stnotes"] then
        self.CharacterInfoPanel:InsertColorChange(GetColor2("blue"))
        self.CharacterInfoPanel:AppendText(egmt("character.jailtime"))
        self.CharacterInfoPanel:InsertColorChange(GetColor2("white"))
        self.CharacterInfoPanel:AppendText(character:GetProperty("jailtime", 0))
    end
    ]]
end

-- Closes the character manager.
function CharacterManager:CloseMenu()
    if IsValid(self.Frame) then
        self.Frame:Close()
    end
end

------------------------------------------
--    The following code is for live    --
--     refreshing. If any data gets     --
--  changed, it is updated in the menu. --
------------------------------------------

-- Refresh menu when a character property / data got changed.
-- Only works for online players.
--
-- @param Character character
local function refreshCharacter(character)
    if IsValid(CharacterManager.Frame) then
        if CharacterManager.CurrentCharacter and CharacterManager.CurrentCharacter:GetId() == character:GetId() then
            CharacterManager:ShowCharacter(character)
        end

        -- Update entry in list.
        for k, line in pairs(CharacterManager.CharacterList:GetLines()) do
            if line.character and line.character:GetId() == character:GetId() then
                -- Update the character set in the line. This allows the data to be updated when the line is clicked.
                line.character = character

                local rank = character:GetRank()
                if character:GetFaction():GetId() == CharacterManager.SelectedFaction:GetId() then
                    -- Update text in the EGMListView.
                    line.Columns[1].Value = rank:GetProperty("prefix", "") .. " " .. character:GetName()

                    -- Sort again, because sorting values might have changed.
                    CharacterManager.CharacterList:SortByColumns(1, false)
                else
                    -- Remove characters from list when they are now in a new faction.
                    CharacterManager.CharacterList:RemoveLine(k)
                end

                return
            end
        end
    end
end

hook.Add("Character.PropertyChanged", "CharacterManager.RefreshCharacterProperties", refreshCharacter)
hook.Add("Character.DataChanged", "CharacterManager.RefreshCharacterData", refreshCharacter)
--gamemodes/egmrp/gamemode/core/character/cl_keybinds.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Client | Character Keybinds    --
---------------------------------------

-- Add a keybind for the roll command.
KeyBind:Register(egmt("character.keybinds_roll"), egmt("character.keybinds_cat_rp"), function()
    RunConsoleCommand("say", "/roll")
end)

-- Add a keybind for opening the character manager.
KeyBind:Register(egmt("character.manager"), egmt("shared.team"), function()
    CharacterManager:Open()
end, CharacterManager.DefaultKey)

-- Keybind to open the character selection.
KeyBind:Register(egmt("character.selection"), egmt("shared.normal"), function()
    CharacterSelection:Open()
end, CharacterSelection.DefaultBind)

--gamemodes/egmrp/gamemode/core/deathsystem/cl_scoreboard.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
-- Deathsystem - Scoreboard | Client --
---------------------------------------

-- Add the respawn option to the scoreboard.
Scoreboard:AddOption(
    egmt("deathsystem.respawn"),
    "icon16/arrow_refresh.png",
    995,
    function(target)
        net.Start("DeathSystem.RespawnPlayer")
            net.WriteEntity(target)
        net.SendToServer()
    end,
    function(target)
        return LocalPlayer():IsAtLeast(DeathSystem.RespawnAccess) and IsValid(target)
    end
)

-- Add the revive option to the scoreboard.
Scoreboard:AddOption(
	egmt("deathsystem.revive_scoreboard"),
	"icon16/heart.png",
	996,
	function(target)
		net.Start("DeathSystem.RevivePlayer")
			net.WriteEntity(target)
		net.SendToServer()
	end,
	function(target)
		return LocalPlayer():IsAtLeast(DeathSystem.RespawnAccess) and IsValid(target) and not target:Alive()
	end
)
--gamemodes/egmrp/gamemode/core/deathsystem/weapons/egmrp_defibrilator.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Defibrilator | Shared       --
---------------------------------------

SWEP.Author = "P4sca1 & Oninoni"
SWEP.Contact = "https://einfach-gmod.de"
SWEP.Purpose = "Eine Waffe für den EGM:RP Spielmodus"
SWEP.Instructions = "Linksklick zum Wiederbeleben"

SWEP.Category = "EGM:RP"

SWEP.PrintName = "Defibrilator"

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModelFOV = 70
SWEP.Slot = 5
SWEP.SlotPos = 0

SWEP.DefaultHoldType = "slam"

SWEP.Scope = true
SWEP.ScopeFOV = 20

SWEP.ViewModel = ""
SWEP.WorldModel = ""

SWEP.Primary = {}
SWEP.Primary.Recoil = 0
SWEP.Primary.Damage = 0
SWEP.Primary.NumShots = 0
SWEP.Primary.Cone = 0.15
SWEP.Primary.ClipSize = 0
SWEP.Primary.Delay = 2
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

function SWEP:PrimaryAttack()
    if !IsValid(self:GetOwner()) then return end

    local ent = self:GetOwner():GetEyeTrace().Entity
    local dist = self:GetOwner():GetPos():Distance(ent:GetPos())

    if SERVER and IsValid(ent) and ent:IsRagdoll() and dist < 60 then
        local targ = ent:GetOwner()
        if IsValid(targ) then
            DeathSystem:Revive(targ)
        end
    end

    self:GetOwner():SetAnimation(PLAYER_ATTACK1)
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
end
--gamemodes/egmrp/gamemode/modules/interact/cl_keybinds.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | Interact Keybinds    --
---------------------------------------

-- Add a keybind for opening the interact interface.
KeyBind:Register(egmt("interact.interact"), egmt("shared.normal"), function()
    if LocalPlayer():KeyDown(IN_SPEED) then
        Interact:Open()
    end
end, KEY_R)

--gamemodes/egmrp/gamemode/modules/unarmed/cl_unarmed.lua:
---------------------------------------
---------------------------------------
--	     	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Created by             --
--       Jan 'Oninoni' Ziegler       --
--       		Deltaa       		 --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
---------------------------------------
---------------------------------------

---------------------------------------
--          Unarmed | Client         --
---------------------------------------

hook.Add("Think", "Unarmed.UpdateAnimation", function()
	for _, ply in ipairs(player.GetHumans()) do
		local animationActive = ply:GetNWBool("Unarmed.AnimationActive", false)

		local animationId = ply:GetNWInt("Unarmed.AnimationId", 0)
		if animationId == 0 then continue end

		local animationData = Unarmed.Animations[animationId]
		if not istable(animationData) then continue end

		local targetProgress = 1
		if not animationActive then
			targetProgress = 0
		end

		-- Compare with rounded values to prevent animation from getting stuck.
		local progress = ply.AnimationProgress or 0
		if math.Round(progress, 2) == targetProgress then continue end

		progress = Lerp(FrameTime() * (animationData.PlaybackSpeed or 6), progress, targetProgress)
		ply.AnimationProgress = progress

		for boneName, boneAngle in pairs(animationData.Bones) do
			local override = hook.Run("Unarmed.OverrideAnimation", ply, animationId, boneName, boneAngle)
			if isvector(override) or isangle(override) then
				boneAngle = override
			end

			local boneId = ply:LookupBone(boneName)
			if boneId then
				if isvector(boneAngle) then
					ply:ManipulateBonePosition(boneId, boneAngle * progress)
				else
					ply:ManipulateBoneAngles(boneId, boneAngle * progress)
				end
			end
		end
	end
end)

-- Attach all models for a character on Spawn.
gameevent.Listen("player_spawn")
hook.Add("player_spawn", "Unarmed.ResetAnimation", function(data)
	local ply = Player(data.userid)
	if not IsValid(ply) then return end

	-- Reset Animation Progress
	ply.AnimationProgress = 0

	-- Reset bones
	for boneId = 0, ply:GetBoneCount() - 1 do
		ply:ManipulateBonePosition(boneId, Vector(0, 0, 0))
		ply:ManipulateBoneAngles(boneId, Angle(0, 0, 0))
	end
end)
--gamemodes/egmrp/gamemode/modules/unarmed/cl_interact.lua:
---------------------------------------
---------------------------------------
--	     	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Created by             --
--       Jan 'Oninoni' Ziegler       --
--       		Deltaa       		 --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
---------------------------------------
---------------------------------------

---------------------------------------
--         Unarmed | Interact        --
---------------------------------------

Interact:RegisterCategory("animations", "nil", egmt("unarmed.animations"), 2, 12)

-- Add the Animations after the config has been loaded.
hook.Add("EGMRP.Loaded", "Unarmed.AddInteract", function()
	for animationId, animationData in SortedPairs(Unarmed.Animations) do
		if animationData.Hide then continue end

		Interact:RegisterOption("animations", animationData.Name, animationId, function()
			net.Start("Unarmed.SetAnimation")
				net.WriteInt(animationId, 32)
			net.SendToServer()

			Interact.Menu:Remove()
		end)
	end
end)

Interact:RegisterOption(nil, egmt("unarmed.pick_up_shoulder"), 1, function()
	net.Start("Unarmed.PickUpPlayer")
	net.SendToServer()

	Interact.Menu:Remove()
end, function()
	local canPickup, target = Unarmed:CanPlayerPickup(LocalPlayer())
	if not canPickup then
		return false
	end

	for _, weaponClass in pairs(Unarmed.PickupNoAskWeapons) do
		if target:HasWeapon(weaponClass) then
			return true
		end
	end

	local wep = target:GetActiveWeapon()
	local weaponClass = wep:GetClass()
	if weaponClass ~= "egmrp_unarmed" then
		return false
	end

	return true
end)
--gamemodes/egmrp/gamemode/modules/inventory/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Config | Inventory        --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Minimum user groups that is allowed, to edit item types.
ItemType.MinAccessGroup = "superadmin"

-- Minimum delay between inventory actions.
Inventory.NetworkDelay = 0.5

-- Timeframe in which the player should not drop > 10 items.
Inventory.DropDelay = 60

-- Slots for the player inventory.
Inventory.PlayerInventorySlots = {
	body = {
		Type = "body",

		X = 0,
		Y = 1,
		Align = ITEM_SLOT_LEFT,
	},

	bigL = {
		Type = "weapon_big",

		X = 0,
		Y = 2,
		Align = ITEM_SLOT_LEFT,

		HolsterBone = "ValveBiped.Bip01_Spine2",
		HolsterOffset = Vector(8, 0, -6),
		HolsterAngle = Angle(180, 0, 90),
		HolsterAlign = ITEM_SLOT_RIGHT,
	},
	bigR = {
		Type = "weapon_big",

		X = 5,
		Y = 2,
		Align = ITEM_SLOT_RIGHT,

		HolsterBone = "ValveBiped.Bip01_Spine2",
		HolsterOffset = Vector(8, 0, 6),
		HolsterAngle = Angle(180, 0, 90),
		HolsterAlign = ITEM_SLOT_LEFT,
	},

	beltL = {
		Type = "belt",

		X = 0,
		Y = 3,
		Align = ITEM_SLOT_LEFT,
	},
	beltR = {
		Type = "belt",

		X = 5,
		Y = 3,
		Align = ITEM_SLOT_RIGHT,
	},

	smallL = {
		Type = "weapon_small",

		X = 0,
		Y = 4,
		Align = ITEM_SLOT_LEFT,

		HolsterBone = "ValveBiped.Bip01_R_Thigh",
		HolsterOffset = Vector(2, -2, -4),
		HolsterAngle = Angle(180, 0, 90),
		HolsterAlign = ITEM_SLOT_RIGHT,
	},
	smallR = {
		Type = "weapon_small",

		X = 5,
		Y = 4,
		Align = ITEM_SLOT_RIGHT,

		HolsterBone = "ValveBiped.Bip01_L_Thigh",
		HolsterOffset = Vector(2, -2, 4),
		HolsterAngle = Angle(180, 0, 90),
		HolsterAlign = ITEM_SLOT_LEFT,
	},

	weapon_consealed = {
		Type = "weapon_consealed",
		Hidden = true,

		X = 2.5,
		Y = 4,
		Align = ITEM_SLOT_CENTER,
	},

	backpack = {
		Type = "backpack",
		Hidden = true,
		MinimumCount = 5,

		X = 0,
		Y = 6,
		Align = ITEM_SLOT_LEFT_TOP,
	}
}

-- Default key for opening the inventory.
Inventory.DefaultKey = KEY_I

-- Fallback models for weapons, if the model is not found.
-- Used by default for the non-scripted weapons.
Inventory.FallbackWeaponModel = {
	["weapon_357"] = "models/weapons/w_357.mdl",
	["weapon_pistol"] = "models/weapons/w_pistol.mdl",
	["weapon_crossbow"] = "models/weapons/w_crossbow.mdl",
	["weapon_ar2"] = "models/weapons/w_irifle.mdl",
	["weapon_rpg"] = "models/weapons/w_rocket_launcher.mdl",
	["weapon_shotgun"] = "models/weapons/w_shotgun.mdl",
	["weapon_smg1"] = "models/weapons/w_smg1.mdl",

	["weapon_frag"] = "models/weapons/w_grenade.mdl",
	["weapon_slam"] = "models/weapons/w_slam.mdl",

	["weapon_crowbar"] = "models/weapons/melee/w_crowbar.mdl",
	["weapon_stunstick"] = "models/weapons/w_stunbaton.mdl",
}

-- Fallback offsets and angles for the holsters.
-- Used by default for the non-scripted weapons.
Inventory.FallbackWeaponHolster = {}

-- List of rarity names and their colors.
Inventory.Rarities = {
	[1] = {
		Name = egmt("inventory.rarity.common"),
		Color = Color(21, 101, 192)
	},
	[2] = {
		Name = egmt("inventory.rarity.uncommon"),
		Color = Color(75, 213, 238)
	},
	[3] = {
		Name = egmt("inventory.rarity.rare"),
		Color = Color(0, 255, 0)
	},
	[4] = {
		Name = egmt("inventory.rarity.epic"),
		Color = Color(255, 0, 255)
	},
	[5] = {
		Name = egmt("inventory.rarity.legendary"),
		Color = Color(255, 128, 0)
	}
}

-- Should weapons be exclusive to a single item type?
Inventory.ExclusiveWeapons = true

-- Can a player access another players inventory by default?
Inventory.DefaultAccessPlayer = false

-- Can a player access a corpses inventory by default?
Inventory.DefaultAccessCorpse = true
--gamemodes/egmrp/gamemode/modules/inventory/sh_inventory.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Shared | Inventory        --
---------------------------------------

-- Add character property: inventory
Character:AddProperty("inventory", "table", {}, function(character, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(character, ply)
	return true
end)

-- Get the inventory of a character.
--
-- @return Table inventory
function Character.Meta:GetInventory()
	return self:GetProperty("inventory", {})
end



---------------------------------------
--        Inventory Managment        --
---------------------------------------

-- Get the Item Type of an item.
--
-- @param Table itemData
-- @return Boolean success
-- @return Table/String itemType/err
function Inventory:GetItemType(itemData)
	if not istable(itemData) then
		return false, egmt("inventory.invalid_item")
	end

	local typeId = itemData.TypeId
	local itemType = ItemType:GetCached(typeId)
	if not itemType then
		return false, egmt("inventory.invalid_item_type")
	end

	return true, itemType
end

-- Get the information and object relating to an item.
--
-- @param Table itemData
-- @param? Table itemType
-- @return Boolean success
-- @return Table/String itemClass/err
-- @return? Table itemType
function Inventory:GetItemClass(itemData, itemType)
	if not istable(itemData) then
		return false, egmt("inventory.invalid_item")
	end

	if not istable(itemType) then
		local success, itemType2 = self:GetItemType(itemData)
		if not success then
			return false, itemType2
		end

		itemType = itemType2
	end

	local itemClass = itemType:GetItemClass()
	if not istable(itemClass) then
		return false, egmt("inventory.invalid_item_class")
	end

	return true, itemClass, itemType
end

-- Get all available slots for a character.
--
-- @param Table inventory
-- @return Table availableSlots
function Inventory:GetAvailableSlots(inventory)
	local availableSlots = {}

	-- Unlock all slots, that are not hidden.
	for slotId, slotData in pairs(Inventory.PlayerInventorySlots) do
		local slotTypeClass = Inventory:GetItemSlotClass(slotData.Type)
		if not slotTypeClass then
			continue
		end

		local maxCount = slotTypeClass.Count

		-- If the slot is not hidden, it is always available.
		local count = 0
		if not slotData.Hidden then
			count = maxCount
		else
			-- You can set a minimum count for hidden slots.
			local minimumCount = slotData.MinimumCount
			if isnumber(minimumCount) then
				count = math.max(count, minimumCount)
			end
		end

		availableSlots[slotId] = {
			Count = math.min(count, maxCount),
			MaxCount = maxCount,
		}
	end

	-- Search for items, that unlock hidden slots.
	for slotId, slotItemData in pairs(inventory) do
		-- Prevent unlocking with non-equipment slots
		if not Inventory:IsEquipmentSlot(slotId) then
			continue
		end

		for _, itemData in pairs(slotItemData) do
			local success, itemClass, itemType = Inventory:GetItemClass(itemData)
			if not success then
				continue
			end

			local unlockedSlots = itemClass:UnLockSlots(inventory, itemType, itemData)

			-- Add the slots to the available slots.
			for slotId2, slotCount in pairs(unlockedSlots) do
				local availableSlotData = availableSlots[slotId2]

				local count = availableSlotData.Count
				count = math.min(count + slotCount, availableSlotData.MaxCount)

				availableSlotData.Count = count
			end
		end
	end

	return availableSlots
end

-- Internal helper function, to check if a slot is hidden and if it is available.
--
-- @param Table inventory
-- @param String slotId
-- @param? Number subId
-- @return Boolean isAvailable
-- @return? String err
function Inventory:IsSlotAvailable(inventory, slotId, subId)
	local availableSlots = Inventory:GetAvailableSlots(inventory)

	local availableSlotData = availableSlots[slotId]
	if not istable(availableSlotData) then
		return false, egmt("inventory.invalid_slot")
	end

	local count = availableSlotData.Count
	if count <= 0 then
		return false, egmt("inventory.no_empty_slot")
	end

	if isnumber(subId) and subId > count then
		return false, egmt("inventory.invalid_sub_slot")
	end

	return true
end

-- Is a slot, that is hidden by default, currently available?
--
-- @param String slotId
-- @param? Number subId
-- @param? Table ignoreItemData
-- @param? Table newItemData
-- @return Boolean isAvailable
-- @return? String err
function Character.Meta:IsSlotAvailable(slotId, subId)
	local inventory = self:GetInventory()

	return Inventory:IsSlotAvailable(inventory, slotId, subId)
end

-- Check, if the slot type is an equipment slot.
--
-- @param String slotType
-- @return? Boolean isEquipmentSlot
function Inventory:IsEquipmentSlotType(slotType)
	local slotTypeClass = Inventory:GetItemSlotClass(slotType)
	if not slotTypeClass then
		return false
	end

	return slotTypeClass.Equipment
end

-- Check, if the item slot is an equipment slot.
--
-- @param String slotId
-- @return Boolean isEquipmentSlot
function Inventory:IsEquipmentSlot(slotId)
	local slotData = Inventory.PlayerInventorySlots[slotId]
	if not istable(slotData) then
		return false
	end

	return self:IsEquipmentSlotType(slotData.Type)
end

-- Check, if the item can stack with the target slot.
--
-- @param Table itemData
-- @param Table targetItemData
-- @return Boolean canStack
function Inventory:CanStack(itemData, targetItemData)
	if not istable(targetItemData) or not istable(itemData) then
		return false
	end

	-- Is it the same type?
	if targetItemData.TypeId ~= itemData.TypeId then
		return false
	end

	-- Check, if all values are the same.
	for key, value in pairs(itemData) do
		if key == "StackSize" then continue end
		if key == "SlotId" or key == "SubId" then continue end

		local currentValue = targetItemData[key]
		if currentValue == value then continue end

		-- Compare table content 1 level deep.
		if istable(currentValue) and istable(value) then
			local diff = CompareTableRecursive(value, currentValue)
			if not diff then continue end
		end

		return false
	end

	-- Check, if there are values on the target item, that are not on the item.
	for key, value in pairs(targetItemData) do
		if key == "StackSize" then continue end
		if key == "SlotId" or key == "SubId" then continue end

		local currentValue = itemData[key]
		if currentValue ~= nil then continue end

		return false
	end

	return true
end

-- Can a character add an item to his inventory?
--
-- @param Table inventory
-- @param Table itemData
-- @param String slotId
-- @param? Number subId
-- @return Boolean canAdd
-- @return? String err / String slotId
-- @return? Number subId
function Inventory:CanAddItem(inventory, itemData, slotId, subId)
	-- print("\nCanAddItem", inventory, itemData, slotId, subId)

	if not istable(inventory) then
		return false, egmt("inventory.invalid_inventory")
	end

	if not istable(itemData) then
		return false, egmt("inventory.invalid_item")
	end

	-- If a slot is given, it will check, if the item is allowed to be added to the slot.
	if isstring(slotId) then
		-- Get the slot data of the slot.
		local slotData = Inventory.PlayerInventorySlots[slotId]
		if not istable(slotData) then
			return false, egmt("inventory.invalid_slot")
		end

		local slotType = slotData.Type
		local slotTypeClass = Inventory:GetItemSlotClass(slotType)
		if not slotTypeClass then
			return false, egmt("inventory.invalid_slot_type")
		end

		-- If no subId is given, it will search for an empty sub-slot.
		-- If the subId is give, emptyness will not be checked for swapping items.
		if not isnumber(subId) then
			local slotItemData = inventory[slotId] or {}

			-- Search for an empty sub-slot.
			local count = slotTypeClass.Count
			for sId = 1, count do
				if slotData.Hidden then
					local isAvailable, _ = self:IsSlotAvailable(inventory, slotId, sId)
					if not isAvailable then
						continue
					end
				end

				local currentIteamData = slotItemData[sId]
				if not istable(currentIteamData) then
					subId = sId

					break
				end
			end

			-- If no empty sub-slot was found, return false.
			if not isnumber(subId) then
				return false, egmt("inventory.no_empty_slot")
			end
		end

		-- Check if the slot is above the max count.
		local count = slotTypeClass.Count
		if subId > count then
			return false, egmt("inventory.invalid_sub_slot")
		end

		-- Check, if the slot is hidden and if it is available.
		if slotData.Hidden then
			local success, err = self:IsSlotAvailable(inventory, slotId, subId)
			if not success then
				return false, err
			end
		end

		-- Get the item class of the item.
		local success, itemClass, itemType = Inventory:GetItemClass(itemData)
		if not success then
			return false, itemClass
		end

		-- Check, if the slot is compatible with the item.
		local canEquip, canEquipError = itemClass:CanEquipInto(inventory, itemType, itemData, slotType)
		if not canEquip then
			return false, canEquipError
		end

		return true, slotId, subId
	end

	-- If a slotId is missing, but a subId is given, something is wrong.
	if isnumber(subId) then
		return false, egmt("inventory.missing_sub_slot")
	end

	-- If no slot is given, it will search for an empty slot:

	-- Check equipment slots first.
	for otherSlotId, slotData in pairs(Inventory.PlayerInventorySlots) do
		if not Inventory:IsEquipmentSlot(otherSlotId) then
			continue
		end

		-- Recursively call this function, to check if the item can be equipped into the slot.
		local success, _, otherSubId = self:CanAddItem(inventory, itemData, otherSlotId, nil)
		if success then
			return true, otherSlotId, otherSubId
		end
	end

	-- Check normal slots.
	for otherSlotId, slotData in pairs(Inventory.PlayerInventorySlots) do
		if Inventory:IsEquipmentSlot(otherSlotId) then
			continue
		end

		-- Recursively call this function, to check if the item can be equipped into the slot.
		local success, _, otherSubId = self:CanAddItem(inventory, itemData, otherSlotId, nil)
		if success then
			return true, otherSlotId, otherSubId
		end
	end

	return false, egmt("inventory.no_empty_slot")
end

-- Can a character add an item to his inventory?
--
-- @param Table itemData
-- @param? String slotId
-- @param? Number subId
-- @return Boolean canAdd
-- @return? String err / String slotId
-- @return? Number subId
function Character.Meta:CanAddItem(itemData, slotId, subId)
	local canAdd, slotId2, subId2 = Inventory:CanAddItem(self:GetInventory(), itemData, slotId, subId)
	if not canAdd then
		return false, slotId2
	end

	-- Set a found slotId and subId, if they were returned.
	if not isstring(slotId) then
		slotId = slotId2
	end
	if not isnumber(subId) then
		subId = subId2
	end

	-- Call a hook, to override the result.
	local override, err = hook.Run("Inventory.CanAddItem", self, itemData, slotId, subId)
	if isbool(override) then
		return override, err
	end

	return true, slotId, subId
end

-- Can a character add multiple items to his inventory?
-- Simulates adding the items to the inventory on a temporary table.
--
-- @param Table itemList
-- @param? Boolean ignoreSlots
-- @param? String lastSlotId
-- @param? Number lastSubId
-- @return Boolean canAdd
-- @return? String err
function Character.Meta:CanAddItems(itemList, ignoreSlots, lastSlotId, lastSubId)
	-- print("\nCanAddItems", itemList, ignoreSlots, lastSlotId, lastSubId)

	if not istable(itemList) then
		return false, egmt("inventory.invalid_item_list")
	end

	itemList = table.Copy(itemList)

	local inventory = self:GetInventory()

	-- Create a temporary table, to simulate adding the items.
	local tempInventory = table.Copy(inventory)

	-- If a slot is given, try to add last item to this slot.
	if isstring(lastSlotId) and isnumber(lastSubId) then
		local lastItemData = itemList[#itemList]
		local success, err, subId2 = Inventory:CanAddItem(tempInventory, lastItemData, lastSlotId, lastSubId)
		if not success then
			return false, err
		end

		-- Override the subId, if it was returned.
		if isnumber(subId2) then
			lastSlotId = err
			lastSubId = subId2
		end

		-- Call a hook, to override the result.
		local override, err2 = hook.Run("Inventory.CanAddItem", self, lastItemData, lastSlotId, lastSubId)
		if isbool(override) then
			return override, err2
		end

		table.remove(itemList, #itemList)
	end

	for _, itemData in SortedPairs(itemList) do
		local slotId = itemData.SlotId
		local subId = itemData.SubId

		if ignoreSlots then
			slotId = nil
			subId = nil
		end

		-- If the slot is already filled, search for an empty sub-slot.
		local inventorySlotItemData = tempInventory[slotId] or {}
		if inventorySlotItemData[subId] ~= nil then
			subId = nil
		end

		local success, err, subId2 = Inventory:CanAddItem(tempInventory, itemData, slotId, subId)
		if not success then
			return false, err
		end

		-- Override the subId, if it was returned.
		if isnumber(subId2) then
			slotId = err
			subId = subId2
		end

		-- Call a hook, to override the result.
		local override, err2 = hook.Run("Inventory.CanAddItem", self, itemData, slotId, subId)
		if isbool(override) then
			return override, err2
		end

		-- Add the item to the temporary inventory.
		local tempSlotItemData = tempInventory[slotId] or {}
		tempSlotItemData[subId] = itemData
		tempInventory[slotId] = tempSlotItemData
	end

	return true
end
--gamemodes/egmrp/gamemode/modules/inventory/item_classes/weapon/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Weapon Item       --
---------------------------------------

-- This Item Class is used for weapons, which can be equipped and used by the player.
-- A single weapon cannot be equipped more than once, but multiple weapons can be equipped together, depending on the slots.

local ITEM_CLASS = ITEM_CLASS

-- Base Item class, from which functions and such should be inherited.
ITEM_CLASS.BaseItemClass = "base"

-- List of item slots, which the item can be equipped to.
ITEM_CLASS.Slots = {}

-- Sorting order of the item.
ITEM_CLASS.Sort = 100

-- Helper boolean to check if the item is a weapon item.
ITEM_CLASS.IsWeapon = true



---------------------------------------
--        Item Class Function        --
---------------------------------------

-- Validate the item data.
--
-- @param itemType
-- @param itemData
-- @return Boolean success
-- @return String error
function ITEM_CLASS:Validate(itemType, itemData)
	local weaponClass = itemData.WeaponClass

	-- Check if the weapon class is a string
	if not isstring(weaponClass) then
		return false, egmt("inventory.no_weapon_class")
	end

	-- Check if the weapon class is valid.
	local weapon = list.Get("Weapon")[weaponClass]
	if not istable(weapon) then
		return false, egmt("inventory.invalid_weapon_class")
	end

	-- Check if the weapon is whitelisted for the item type.
	local weaponList = itemType:GetWeapons()
	if not istable(weaponList) or not table.HasValue(weaponList, weaponClass) then
		return false, egmt("inventory.weapon_not_whitelisted") -- TODO: Localize
	end

	return true
end

-- Helper function, to find other items with the same weapon class.
--
-- @param Table inventory
-- @param Table itemData
-- @param? Boolean onlyEquipped
-- @param? Boolean count
-- @return Boolean success
-- @return? Number ammount
function ITEM_CLASS:FindOtherItem(inventory, itemData, onlyEquipped, count)
	local weaponClass = itemData.WeaponClass
	local currentSlotId = itemData.SlotId
	local currentSubId = itemData.SubId

	local ammount = 0

	for slotId, slotItemData in pairs(inventory) do
		if onlyEquipped and not Inventory:IsEquipmentSlot(slotId) then
			continue
		end

		for subId, otherItemData in pairs(slotItemData) do
			if slotId == currentSlotId and subId == currentSubId then continue end
			if otherItemData == itemData then continue end

			local otherWeaponClass = otherItemData.WeaponClass
			if isstring(otherWeaponClass) and otherWeaponClass == weaponClass then
				if count then
					ammount = ammount + 1
				else
					return true
				end
			end
		end
	end

	if count and ammount > 0 then
		return true, ammount
	end

	return false
end

-- Check, if the item can be added to the given slot.
--
-- @param Table inventory
-- @param ItemType itemType
-- @param Table itemData
-- @param? String slotType
-- @return Boolean canAdd
-- @return? String error
function ITEM_CLASS:CanEquipInto(inventory, itemType, itemData, slotType)
	local valid, valErr = self:Validate(itemType, itemData)
	if not valid then
		return false, valErr
	end

	local success, err = ITEM_CLASS.Base.CanEquipInto(self, inventory, itemType, itemData, slotType)
	if not success then
		return false, err
	end

	return true
end

-- Helper function to get the name of the item.
--
-- @param String weaponClass
-- @return String name
function ITEM_CLASS:GetWeaponName(weaponClass)
	local weapon = weapons.Get(weaponClass)
	if istable(weapon) then
		return weapon.PrintName
	end
	weapon = list.Get("Weapon")[weaponClass]
	if istable(weapon) then
		return weapon.PrintName
	end

	return weaponClass
end

-- Get all variants of the item as a table.
--
-- @param ItemType itemType
-- @return Table itemVariants
function ITEM_CLASS:GetVariants(itemType)
	local itemVariants = {}

	for _, weaponClass in ipairs(itemType:GetWeapons()) do
		itemVariants[weaponClass] = self:GetWeaponName(weaponClass)
	end

	hook.Run("Inventory.GetWeaponVariants", self, itemType, itemVariants)

	return itemVariants
end

-- Get item data from variant string.
--
-- @param ItemType itemType
-- @param String variant
-- @return? Table itemData
function ITEM_CLASS:GetVariantData(itemType, variant)
	if isstring(variant) then
		if variant ~= "" then
			return {
				TypeId = itemType:GetId(),

				WeaponClass = variant
			}
		end

		-- Random weapon if no variant is given.
		local weaponList = itemType:GetWeapons()
		return {
			TypeId = itemType:GetId(),

			WeaponClass = table.Random(weaponList)
		}
	end

	return false
end



---------------------------------------
--              Tooltip              --
---------------------------------------

-- Gets the name for the item.
--
-- @param ItemType itemType
function ITEM_CLASS:GetName(itemType, itemData)
	local weaponClass = itemData.WeaponClass

	return self:GetWeaponName(weaponClass)
end
--gamemodes/egmrp/gamemode/modules/inventory/item_classes/weapon/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Weapon Item       --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Display name for the type used in UI elements.
ITEM_CLASS.Name = egmt("inventory.item_class_weapon")

-- List of properties that should be shown in the manager, if this item class is used.
ITEM_CLASS.PropertyList = {"weapons"}

-- Helper function for getting the model of a weapon.
--
-- @param String weaponClass
-- @param? Player ply
-- @return String model
-- @return? Number skin
-- @return? Table bodygroups
-- @return? Number scale
-- @return? Color color
function ITEM_CLASS:GetWeaponModel(weaponClass, ply)
	ply = ply or LocalPlayer()
	if not IsValid(ply) then
		return ""
	end

	local weapon = ply:GetWeapon(weaponClass)
	if not IsValid(weapon) then
		weapon = weapons.Get(weaponClass)
	end

	if IsValid(weapon) or istable(weapon) then
		-- TFA/EGM:RP weapon implementation.
		if weapon.IsTFAWeapon then
			for _, entry in pairs(weapon.WElements or {}) do
				if entry.active == false then continue end
				if entry.type ~= "Model" then continue end
				if isstring(entry.rel) and entry.rel ~= "" then continue end

				if isstring(entry.model) then
					local scale = entry.size or Vector(1, 1, 1)

					return entry.model, entry.skin, entry.bodygroup, scale.x, entry.color
				end
			end
		end


		if isfunction(weapon.GetModel) then
			return weapon:GetModel()
		end

		return weapon.WorldModel
	end

	local fallback = Inventory.FallbackWeaponModel[weaponClass]
	if isstring(fallback) then
		return fallback
	end

	return ""
end

-- Helper function for getting the holster position and angle offset of a weapon.
--
-- @param String weaponClass
-- @return Vector position
-- @return Angle angle
function ITEM_CLASS:GetWeaponHolster(weaponClass)
	local offset = Vector()
	local angle = Angle()

	local weapon = weapons.Get(weaponClass)
	if istable(weapon) then
		offset = weapon.HolsterOffset or offset
		angle = weapon.HolsterAngle or angle
	end

	local fallback = Inventory.FallbackWeaponHolster[weaponClass]
	if istable(fallback) then
		offset = fallback.Offset or offset
		angle = fallback.Angle or angle
	end

	return offset, angle
end

-- Create the item panel for the item.
-- Displays a centered, properly zoomed in model of the swep.
--
-- @param Panel parent
-- @param Table itemData
function ITEM_CLASS:CreateItemPanel(parent, itemData)
	ITEM_CLASS.Base.CreateItemPanel(self, parent, itemData)
	function parent:Paint(ww, hh)
	end

	local model, skinId, bodygroups = self:GetWeaponModel(itemData.WeaponClass)
	if model == "" then
		ITEM_CLASS.Base.CreateItemPanel(self, parent, itemData)

		return
	end

	local modelIcon = vgui.Create("EGMModelIcon", parent)
	modelIcon:Dock(FILL)
	modelIcon:SetMouseInputEnabled(false)

	modelIcon:SetModel(model, skinId, bodygroups)
	modelIcon:SetDisplayType("Weapon")

	modelIcon:SetSize(math.floor(ScrW() * 0.1), math.floor(ScrW() * 0.1))
	modelIcon:GenerateIcon()

	parent.ModelIcon = modelIcon
end

-- Callback run, when the item is equipped.
--
-- @param Player ply
-- @param Character char
-- @param ItemType itemType
-- @param Table itemData
function ITEM_CLASS:OnEquip(ply, char, itemType, itemData)
	-- print("\n SWEP:OnEquip")

	-- Only equip valid weapons.
	if not self:Validate(itemType, itemData) then
		return
	end

	local weaponClass = itemData.WeaponClass

	local model, skinId, bodygroups, scale, color = self:GetWeaponModel(weaponClass, ply)
	if model == "" then
		return
	end

	local slotId = itemData.SlotId
	if not isstring(slotId) then
		return
	end

	local slotData = Inventory.PlayerInventorySlots[slotId]
	if not istable(slotData) then
		return
	end

	local slotType = slotData.Type
	if not isstring(slotType) then
		return
	end

	-- Should the weapon be shown in the holster?
	local blockHolster = hook.Run("Inventory.BlockHolster", self, ply, char, itemType, itemData)
	if blockHolster then
		return
	end

	local holsterOffset = slotData.HolsterOffset
	local holsterAngle = slotData.HolsterAngle
	local holsterBone = slotData.HolsterBone
	if not isvector(holsterOffset) or not isangle(holsterAngle) or not isstring(holsterBone) then
		return
	end

	local weaponOffset, weaponAngle = self:GetWeaponHolster(weaponClass)
	local transformedOffset, transformedAngle = LocalToWorld(weaponOffset, weaponAngle, holsterOffset, holsterAngle)

	ply.HolsteredWeapons = ply.HolsteredWeapons or {}
	local oldholsteredWeapon = ply.HolsteredWeapons[slotId]
	if IsValid(oldholsteredWeapon) then
		oldholsteredWeapon:Remove()
	end

	local holsteredWeapon = ClientsideModel(model, RENDERGROUP_OPAQUE)
	if not IsValid(holsteredWeapon) then
		return
	end

	-- The model itself should not be drawn, it is drawn later manually in PostPlayerDraw.
	holsteredWeapon:SetNoDraw(true)

	if isnumber(skinId) and skinId ~= 0 then
		holsteredWeapon:SetSkin(skinId)
	end

	if istable(bodygroups) then
		for k, v in pairs(bodygroups) do
			holsteredWeapon:SetBodygroup(k, v)
		end
	end

	if isnumber(scale) and scale ~= 1 then
		holsteredWeapon:SetModelScale(scale)
	end

	if IsColor(color) then
		holsteredWeapon:SetColor(color)
	end

	-- holsteredWeapon.DebugOffset = holsterOffset
	-- holsteredWeapon.DebugAngle = holsterAngle

	holsteredWeapon.HolsterBone = holsterBone
	holsteredWeapon.BoneOffset = transformedOffset
	holsteredWeapon.BoneAngle = transformedAngle
	holsteredWeapon.WeaponClass = weaponClass

	-- Allow other modules to modify the holstered weapon.
	hook.Run("Inventory.PostHolsterWeapon", self, ply, char, itemType, itemData, holsteredWeapon)

	ply.HolsteredWeapons[slotId] = holsteredWeapon
end

-- Callback run, when the item is unequipped.
-- Clientside this includes the item being dropped.
--
-- @param Player ply
-- @param Character char
-- @param ItemType itemType
-- @param Table itemData
function ITEM_CLASS:OnUnequip(ply, char, itemType, itemData)
	-- print("\n SWEP:OnUnequip")

	-- Only unequip valid weapons.
	if not self:Validate(itemType, itemData) then
		return
	end

	local slotId = itemData.SlotId
	if not isstring(slotId) then
		return
	end

	local slotData = Inventory.PlayerInventorySlots[slotId]
	if not istable(slotData) then
		return
	end

	local slotType = slotData.Type
	if not isstring(slotType) then
		return
	end

	ply.HolsteredWeapons = ply.HolsteredWeapons or {}
	local holsteredWeapon = ply.HolsteredWeapons[slotType]
	if IsValid(holsteredWeapon) then
		holsteredWeapon:Remove()
	end

	ply.HolsteredWeapons[slotId] = nil
end

-- Draw the holstered weapon.
--
-- @param Player ply
-- @param Table holsteredWeapon
function Inventory:DrawHolsterWeapon(ply, holsteredWeapon)
	if not IsValid(holsteredWeapon) then
		return
	end

	local boneId = ply:LookupBone(holsteredWeapon.HolsterBone)
	if not isnumber(boneId) then
		return
	end

	local pos, ang = ply:GetBonePosition(boneId)

	-- local debugOffset, debugAngle = LocalToWorld(holsteredWeapon.DebugOffset, holsteredWeapon.DebugAngle, pos, ang)
	-- render.SetColorMaterial()
	-- render.DrawLine(pos, debugOffset, Color(255, 0, 0), false)

	pos, ang = LocalToWorld(holsteredWeapon.BoneOffset, holsteredWeapon.BoneAngle, pos, ang)

	holsteredWeapon:SetRenderOrigin(pos)
	holsteredWeapon:SetRenderAngles(ang)

	local color = holsteredWeapon:GetColor()
	render.SetColorModulation(color.r / 255, color.g / 255, color.b / 255)

	holsteredWeapon:DrawModel()

	render.SetColorModulation(1, 1, 1)
end



---------------------------------------
--              Tooltip              --
---------------------------------------

-- Callback run, when the item is showing in the inventory tooltip.
--
-- @param ItemType itemType
-- @param Table itemData
-- @param Table lines
function ITEM_CLASS:AddDescriptionLines(itemType, itemData, lines)
	table.insert(lines, {
		Text = itemType:GetName(),
		Color = UI.ForegroundColor2,
		Align = TEXT_ALIGN_LEFT
	})
end



---------------------------------------
--               Hooks               --
---------------------------------------

local EGMRP = GM or GAMEMODE

-- Remove the default HUD weapon pickup.
function EGMRP:HUDDrawPickupHistory()
	return
end

-- Draw holstered weapons on every player.
hook.Add("PostPlayerDraw", "WeaponHolsters.Draw", function(ply)
	if ply:GetNoDraw() then return end
	local c = ply:GetColor()
	if c.a == 0 then return end

	for _, holsteredWeapon in pairs(ply.HolsteredWeapons or {}) do
		local activeWeapon = ply:GetActiveWeapon()
		if not IsValid(activeWeapon) then continue end

		local shouldShow = true

		-- Do not draw the holstered weapon, if the player is holding it.
		if activeWeapon:GetClass() == holsteredWeapon.WeaponClass then
			shouldShow = false
		end

		-- Allow other modules to override the drawing of the holstered weapon.
		local override = hook.Run("Inventory.OverrideDrawHolsterWeapon", ply, activeWeapon, holsteredWeapon)
		if isbool(override) then
			shouldShow = override
		end

		-- Draw the holstered weapon.
		if shouldShow then
			Inventory:DrawHolsterWeapon(ply, holsteredWeapon)
		end
	end
end)
--gamemodes/egmrp/gamemode/modules/inventory/item_classes/weapon_small/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Weapon Item       --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Display name for the type used in UI elements.
ITEM_CLASS.Name = egmt("inventory.item_class_weapon_small")

-- List of properties that should be shown in the manager, if this item class is used.
ITEM_CLASS.PropertyList = {"weapons"}
--gamemodes/egmrp/gamemode/modules/inventory/item_slots/base/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Base Item Slot      --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Base Item slot, from which functions and such should be inherited.
ITEM_SLOT.BaseItemSlot = false

-- Number of items that can be stored in this slot.
ITEM_SLOT.Count = 1

-- Are items equipped as useable items?
ITEM_SLOT.Equipment = false
--gamemodes/egmrp/gamemode/modules/inventory/item_slots/base/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Base Item Slot      --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

local dragPanel
local dermaMenu

-- Name of the item slot displayed in the inventory.
ITEM_SLOT.Name = "Base Item Slot"

-- Number of rows, the items should be displayed in.
-- If set to true, the count is used as a per count for the rows and as many rows as needed are created.
ITEM_SLOT.Rows = 1

-- Create the tooltip for the given item slot.
--
-- @param DPanel slot
-- @param Boolean detailed
function ITEM_SLOT:CreateTooltip(slot, detailed)
	if IsValid(dragPanel) or IsValid(dermaMenu) then return end

	local itemData = slot.ItemData
	if not istable(itemData) then return end

	local success, itemClass, itemType = Inventory:GetItemClass(itemData)
	if not success then
		return
	end

	local tooltipLines = itemClass:GetTooltipLines(itemType, itemData, detailed) or {}
	local rarityColor = itemClass:GetRarityColor(itemType, itemData) or UI.ForegroundColor

	local w = 0
	surface.SetFont("EGMText6")
	for _, tooltipLine in pairs(tooltipLines) do
		local text = tooltipLine.Text
		if not isstring(text) then continue end

		local textW, _ = surface.GetTextSize(text)
		w = math.max(w, textW)
	end
	local h = table.Count(tooltipLines) * 20 + 20

	local toolTipPanel = vgui.Create("DPanel", nil)
	toolTipPanel.Detailed = detailed

	local mX, mY = gui.MousePos()
	toolTipPanel:SetPos(mX + 8, mY + 8)
	toolTipPanel:SetSize(w + 16, h)

	toolTipPanel:MakePopup()
	toolTipPanel:SetMouseInputEnabled(false)

	function toolTipPanel:Think()
		if IsValid(dragPanel) or IsValid(dermaMenu) then
			self:Remove()

			return
		end

		self:MoveToFront()

		mX, mY = gui.MousePos()
		self:SetPos(mX + 8, mY + 8)

		if not slot:IsHovered() then
			self:Remove()
		end
	end

	function toolTipPanel:Paint(ww, hh)
		draw.RoundedBox(0, 0, 0, ww, hh, ColorAlpha(UI.BackgroundColor, 255))

		-- Draw Frame around the Detail Panel.
		draw.RoundedBox(0, 0, 0,      ww, 4, rarityColor)
		draw.RoundedBox(0, 0, hh - 4, ww, 4, rarityColor)

		draw.RoundedBox(0, 0,      0, 4, hh, rarityColor)
		draw.RoundedBox(0, ww - 4, 0, 4, hh, rarityColor)

		for i, toolTipLine in pairs(tooltipLines) do
			local text = toolTipLine.Text
			if not isstring(text) then continue end

			local align = toolTipLine.Align or TEXT_ALIGN_LEFT
			if align == TEXT_ALIGN_LEFT then
				draw.SimpleText(text, "EGMText6", 8, 10 + 20 * (i - 1), toolTipLine.Color or UI.ForegroundColor2, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
			elseif align == TEXT_ALIGN_CENTER then
				draw.SimpleText(text, "EGMText6", ww / 2, 10 + 20 * (i - 1), toolTipLine.Color or UI.ForegroundColor2, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
			elseif align == TEXT_ALIGN_RIGHT then
				draw.SimpleText(text, "EGMText6", ww - 8, 10 + 20 * (i - 1), toolTipLine.Color or UI.ForegroundColor2, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)
			end
		end
	end

	return toolTipPanel
end

-- Creates the drag panel for the given item slot.
--
-- @param DPanel slot
function ITEM_SLOT:CreateDragPanel(slot)
	local xOffset, yOffset = slot:LocalCursorPos()

	dragPanel = vgui.Create("DPanel", nil)
	local w, h = slot:GetSize()
	dragPanel:SetSize(w, h)

	dragPanel:MakePopup()
	dragPanel:SetMouseInputEnabled(false)

	function dragPanel:Think()
		if not IsValid(slot) then
			self:Remove()
			return
		end

		self:MoveToFront()

		if not input.IsMouseDown(MOUSE_LEFT) then
			local slotId, subId, context = slot:GetId()

			local hoveredPanel = vgui.GetHoveredPanel()
			if not IsValid(hoveredPanel) or hoveredPanel:GetName() == "GModBase" then
				local curTime = CurTime()
				if (Inventory.LastNetMessage or 0) + Inventory.NetworkDelay < curTime then
					net.Start("Inventory.DropItem")
						net.WriteString(slotId)
						net.WriteUInt(subId, 16)
						net.WriteString(context)
					net.SendToServer()
				end

				Inventory.LastNetMessage = curTime
			end

			self:Remove()
			return
		end

		local x, y = gui.MousePos()
		self:SetPos(x - xOffset, y - yOffset)
	end

	function dragPanel:Paint(ww, hh)
		if not IsValid(slot) then
			self:Remove()
			return
		end

		local x, y = self:GetPos()

		slot:PaintAt(x, y, ww, hh)

		local color = UI.TextColor

		local hoveredPanel = vgui.GetHoveredPanel()
		if not IsValid(hoveredPanel) or hoveredPanel:GetName() == "GModBase" then
			color = GetColor("red")
		end

		-- Paint Border around the Drag Panel.
		draw.RoundedBox(0, 0, 0,      ww, 4, color)
		draw.RoundedBox(0, 0, hh - 4, ww, 4, color)

		draw.RoundedBox(0, 0,      0, 4, hh, color)
		draw.RoundedBox(0, ww - 4, 0, 4, hh, color)
	end

	dragPanel.Slot = slot
end

-- Creates the item panel for the given item slot.
--
-- @param DPanel slot
-- @param Table itemData
function ITEM_SLOT:CreateItemPanel(slot, itemData)
	if not istable(itemData) then
		return
	end

	local itemPanel = vgui.Create("DPanel", slot)
	slot.ItemPanel = itemPanel

	itemPanel:Dock(FILL)
	itemPanel:SetMouseInputEnabled(false)

	local success, itemClass = Inventory:GetItemClass(itemData)
	if not success then
		return
	end

	itemClass:CreateItemPanel(itemPanel, itemData)
	slot.ItemData = itemData
end

-- Creates the UI element for the given item slot.
--
-- @param Panel parent
-- @param String slotId
-- @param Table slotData
-- @param Number gridScale
-- @param Table inventory
-- @param? Color slotColor
-- @param String context
-- @return Table panels
function ITEM_SLOT:CreateUI(parent, slotId, slotData, gridScale, inventory, slotColor, context)
	local _self = self

	local x = slotData.X or 0
	local y = slotData.Y or 0
	local align = slotData.Align or ITEM_SLOT_CENTER

	local panels = {}

	local count = self.Count
	local rows = self.Rows

	local slotItemData = inventory[slotId]

	-- Check, if the rows should be calculated automatically.
	if rows == true then
		if istable(slotItemData) then
			local itemCount = table.Count(slotItemData)
			if itemCount > 0 then
				rows = math.ceil((itemCount + 1) / count)
				count = count * rows
			else
				rows = 1
			end
		else
			rows = 1
		end
	end

	local frame = vgui.Create("DPanel", parent)

	local frameX = (x * 2 + 0.5) * gridScale
	local frameY = (y * 2 + 0.5) * gridScale

	local frameW = (count / rows) * gridScale
	local frameH = gridScale * rows

	if align == ITEM_SLOT_RIGHT then
		frameX = frameX - frameW + gridScale
	end

	frame:SetPos(frameX, frameY)
	frame:SetSize(frameW, frameH)
	function frame:Paint(ww, hh)
	end

	local label = vgui.Create("DLabel", parent)

	local labelX = frameX
	local labelY = frameY + frameH

	local labelW = gridScale * 8
	local labelH = gridScale * 0.5

	if align == ITEM_SLOT_CENTER then
		labelX = labelX + frameW / 2 - labelW / 2
		labelY = labelY - frameH - labelH
	elseif align == ITEM_SLOT_RIGHT then
		labelX = labelX - labelW + frameW
	elseif align == ITEM_SLOT_LEFT_TOP then
		labelY = labelY - frameH - labelH
	end

	label:SetPos(labelX, labelY)
	label:SetSize(labelW, labelH)

	label:SetText("")

	function label:Paint(ww, hh)
		if align == ITEM_SLOT_CENTER then
			draw.SimpleText(_self.Name, "EGMText8", ww / 2, hh, UI.ForegroundColor2, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
		elseif align == ITEM_SLOT_RIGHT then
			draw.SimpleText(_self.Name, "EGMText8", ww, 0, UI.ForegroundColor2, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)
		else
			draw.SimpleText(_self.Name, "EGMText8", 0, 0, UI.ForegroundColor2, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		end
	end

	panels.Frame = frame
	panels.Label = label
	panels.Slots = {}

	for subId = 1, count do
		if slotData.Hidden and istable(inventory) then
			local slotAvailable, _ = Inventory:IsSlotAvailable(inventory, slotId, subId)
			if not slotAvailable then
				continue
			end
		end

		local slot = vgui.Create("DPanel", frame)

		-- Return the id and the sub id of the slot.
		--
		-- @return String slotId
		-- @return Number subId
		-- @return String context
		function slot:GetId()
			local contextString = context

			if isfunction(context) then
				contextString = context()
			end

			return slotId, subId, contextString
		end

		local slotX = ((subId - 1) % (count / rows)) * gridScale
		local slotY = math.floor((subId - 1) / (count / rows)) * gridScale
		slot:SetPos(slotX, slotY)
		slot:SetSize(gridScale, gridScale)

		function slot:Think()
			if self:IsHovered() then
				local detailed = input.IsKeyDown(KEY_LSHIFT)

				if not IsValid(self.TooltipPanel) or self.TooltipPanel.Detailed ~= detailed then
					if IsValid(self.TooltipPanel) then
						self.TooltipPanel:Remove()
					end

					self.TooltipPanel = _self:CreateTooltip(slot, detailed)
				end
			end
		end

		function slot:GetSlotColor()
			local color = slotColor or UI.ForegroundColor

			if not IsValid(dragPanel) then
				return color
			end

			local dragSlot = dragPanel.Slot
			if dragSlot == slot then
				return GetColor("red")
			end

			local itemData = dragPanel.Slot.ItemData
			if not istable(itemData) then
				return color
			end

			local itemTypeId = itemData.TypeId
			local itemType = ItemType:GetCached(itemTypeId)
			if not itemType then
				return color
			end

			local itemClass = itemType:GetItemClass()
			if not itemClass then
				return color
			end

			local slotType = slotData.Type
			if table.HasValue(itemClass.Slots, slotType) then
				color = GetColor("green")
			end

			local colorOverride = hook.Run("Inventory.GetSlotColor", itemData, slotData, subId)
			if colorOverride then
				color = colorOverride
			end

			return color
		end

		function slot:Paint(ww, hh)
			draw.RoundedBox(0, 0, 0, ww, hh, UI.BackgroundColor)
		end

		function slot:PaintOver(ww, hh)
			if self:IsHovered() then
				draw.RoundedBox(0, 0, 0,      ww, 4, UI.TextColor)
				draw.RoundedBox(0, 0, hh - 4, ww, 4, UI.TextColor)

				draw.RoundedBox(0, 0,      0, 4, hh, UI.TextColor)
				draw.RoundedBox(0, ww - 4, 0, 4, hh, UI.TextColor)
			else
				local color = self:GetSlotColor(slot)
				draw.RoundedBox(0, 0, 0,      ww, 2, color)
				draw.RoundedBox(0, 0, hh - 2, ww, 2, color)

				draw.RoundedBox(0, 0,      0, 2, hh, color)
				draw.RoundedBox(0, ww - 2, 0, 2, hh, color)
			end
		end

		function slot:OnMousePressed(keyCode)
			if keyCode == MOUSE_LEFT then
				-- Register Shift Click as Double Click.
				if input.IsKeyDown(KEY_LSHIFT) then
					_self:OnShiftClick(self)

					return
				end

				local curTime = CurTime()
				if curTime < (self.LastPressed or 0) + 0.5 then
					_self:OnShiftClick(self)

					return
				end

				_self:OnClick(self)
				self.LastPressed = curTime
			elseif keyCode == MOUSE_RIGHT then
				_self:OnRightClick(self)
			end
		end

		function slot:OnMouseReleased(keyCode)
			if keyCode == MOUSE_LEFT then
				_self:OnRelease(self)
			end
		end

		if istable(slotItemData) then
			local itemData = slotItemData[subId]
			self:CreateItemPanel(slot, itemData)
		end

		table.insert(panels.Slots, slot)
	end

	if table.Count(panels.Slots) == 0 then
		frame:Remove()
		label:Remove()

		return
	end

	return panels
end

-- Callback when the item slot is clicked.
--
-- @param Table slot
function ITEM_SLOT:OnClick(slot)
	if IsValid(dragPanel) then
		return
	end

	-- Prevent dragging empty slots.
	if not IsValid(slot.ItemPanel) then
		return
	end

	self:CreateDragPanel(slot)
end

-- Callback when the item slot is released.
--
-- @param Table slot
function ITEM_SLOT:OnRelease(slot)
	if not IsValid(dragPanel) then
		return
	end

	local dragSlot = dragPanel.Slot
	if not IsValid(dragSlot) then
		return
	end

	if slot == dragSlot then
		return
	end

	-- Dragging no source item is pointless.
	local itemData = dragSlot.ItemData
	if not istable(itemData) then
		return
	end

	-- Allow the item override drag and drop.
	local success, itemClass, itemType = Inventory:GetItemClass(itemData)
	if success then
		local override = itemClass:OnDragDrop(slot, dragSlot, itemType, itemData)
		if override then
			return
		end
	end
end

-- Callback when the item slot is right clicked.
--
-- @param Table slot
function ITEM_SLOT:OnRightClick(slot)
	local itemData = slot.ItemData
	if not istable(itemData) then
		return
	end

	dermaMenu = DermaMenu()

	-- Get additional options from the item class.
	local success, itemClass, itemType = Inventory:GetItemClass(itemData)
	if success then
		itemClass:AddContextMenuOptions(slot, dermaMenu, itemType, itemData)
	end

	-- Do not show the context menu, if it is empty.
	if dermaMenu:ChildCount() == 0 then
		dermaMenu:Remove()

		return
	end

	-- Open the context menu.
	dermaMenu:Open()
end

-- Callback when the item slot is double clicked.
--
-- @param Table slot
function ITEM_SLOT:OnShiftClick(slot)
	local slotId, subId, context = slot:GetId()

	local curTime = CurTime()
	if (Inventory.LastNetMessage or 0) + Inventory.NetworkDelay < curTime then
		net.Start("Inventory.ShiftClickItem")
			net.WriteString(slotId)
			net.WriteUInt(subId, 16)
			net.WriteString(context)
		net.SendToServer()
	end

	Inventory.LastNetMessage = curTime
end
--gamemodes/egmrp/gamemode/modules/inventory/item_slots/belt/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Pistol Item Slot     --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Base Item slot, from which functions and such should be inherited.
ITEM_SLOT.BaseItemSlot = "base"

-- Number of items that can be stored in this slot.
ITEM_SLOT.Count = 4

-- Are items equipped as useable items?
ITEM_SLOT.Equipment = true
--gamemodes/egmrp/gamemode/modules/inventory/item_slots/belt/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Client | Pistol Item Slot     --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Name of the item slot displayed in the inventory.
ITEM_SLOT.Name = egmt("inventory.belt_slot")

-- Number of rows, the items should be displayed in.
ITEM_SLOT.Rows = 1
--gamemodes/egmrp/gamemode/modules/inventory/item_slots/weapon_big/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Pistol Item Slot     --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Base Item slot, from which functions and such should be inherited.
ITEM_SLOT.BaseItemSlot = "base"

-- Number of items that can be stored in this slot.
ITEM_SLOT.Count = 1

-- Are items equipped as useable items?
ITEM_SLOT.Equipment = true
--gamemodes/egmrp/gamemode/modules/inventory/item_slots/weapon_consealed/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Pistol Item Slot     --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Base Item slot, from which functions and such should be inherited.
ITEM_SLOT.BaseItemSlot = "base"

-- Number of items that can be stored in this slot.
ITEM_SLOT.Count = 1

-- Are items equipped as useable items?
ITEM_SLOT.Equipment = true
--gamemodes/egmrp/gamemode/modules/comlink/sh_comchannel.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | ComChannel        --
---------------------------------------

-- Set sharedside property variables.
ComChannel.Name = "ComChannel"

-- Initialize networking.
ComChannel:InitCreationNetworking()
ComChannel:InitEditNetworking()
ComChannel:InitDeletionNetworking()

-- Add com channel property: name
ComChannel:AddProperty("name", "string", nil, function(comChannel, value)
	if not isstring(value) or #value < 3 then
		return false, egmt("comChannel.invalid_name")
	end

	return true
end,
function(comChannel, ply)
	return true
end)

-- Used to get the name of a com channel. Will use the name property or the id as a fallback.
--
-- return String name
function ComChannel.Meta:GetName()
	return self:GetProperty("name") or egmt("comlink.channel_short") .. " " .. self:GetId()
end

-- Override the getSort function to sort by name.
function ComChannel.Meta:GetSort()
	return self:GetName()
end

-- Add item type property: factions
ComChannel:AddProperty("factions", "table", {}, function(comChannel, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(comChannel, ply)
	return true
end)

-- Returns the factions that have access to the com channel.
--
-- return Table factions
function ComChannel.Meta:GetFactions()
	return self:GetProperty("factions", {})
end

-- Add item type property: weapons
ComChannel:AddProperty("announcement", "boolean", false, function(comChannel, value)
	if not isbool(value) then
		return false, egmt("comChannel.invalid_bool")
	end

	return true
end,
function(comChannel, ply)
	return true
end)

-- Returns if the com channel is an announcement channel.
--
-- return Boolean announcement
function ComChannel.Meta:IsAnnouncement()
	return self:GetProperty("announcement", false)
end

-- Limit access to the edit functions.
hook.Add("ComChannel.CanPlayerEditProperties", "ComChannel.EditPropertiesPermissions", function(ply, comChannel, properties)
	return ply:IsAtLeast(ComChannel.MinAccessGroup)
end)

hook.Add("ComChannel.CanPlayerCreate", "ComChannel.CreatePermissions", function(ply, data, properties)
	return ply:IsAtLeast(ComChannel.MinAccessGroup)
end)

hook.Add("ComChannel.CanPlayerDelete", "ComChannel.DeletePermissions", function(ply, character)
	return ply:IsAtLeast(ComChannel.MinAccessGroup)
end)



---------------------------------------
--        Filtered Properties        --
---------------------------------------

-- Add item type property: receiveFactions
ComChannel:AddProperty("receiveFactions", "table", {}, function(comChannel, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(comChannel, ply)
	return true
end)

-- Returns the factions that can receive the announcements of the com channel.
--
-- return Table receiveFactions
function ComChannel.Meta:GetReceiveFactions()
	if not self:IsAnnouncement() then
		return {}
	end

	return self:GetProperty("receiveFactions", {})
end



---------------------------------------
--          Comlink Channels         --
---------------------------------------

-- Create a custom comlink channel.
--
-- @param ComChannel comChannel
-- @return Table comlinkData
function Comlink:CreateCustomChannel(comChannel)
	local comlinkData = Comlink:RegisterChannel("custom", comChannel:GetId(), comChannel:GetName())

	-- Get all factions that have access to the com channel.
	for _, factionId in pairs(comChannel:GetFactions()) do
		comlinkData.AccessFactions[factionId] = true
	end

	-- Store, if the com channel is an announcement channel.
	local isAnnouncement = comChannel:IsAnnouncement()
	if isAnnouncement then
		comlinkData.ReceiveFactions = {}

		for _, factionId in pairs(comChannel:GetReceiveFactions()) do
			comlinkData.ReceiveFactions[factionId] = true
		end

		comlinkData.Announcement = true
	end

	return comlinkData
end

-- Create a comlink channel for every custom comChannel on load.
hook.Add("ComChannel.Load", "Comlink.AddCustomChannel", function(comChannel)
	Comlink:CreateCustomChannel(comChannel)
end)

-- Create a comlink channel for a custom comChannel on creation.
hook.Add("ComChannel.Created", "Comlink.CreateCustomChannel", function(comChannel)
	Comlink:CreateCustomChannel(comChannel)
end)

-- Remove a comlink channel for a custom comChannel on deletion.
hook.Add("ComChannel.Delete", "Comlink.RemoveCustomChannel", function(comChannel)
	Comlink.Channels["custom_" .. comChannel:GetId()] = nil
end)

-- Update comlink channel for a custom comChannel on property change.
hook.Add("ComChannel.PropertyChanged", "Comlink.AddCustomChannel", function(comChannel,  key, value)
	Comlink.Channels["custom_" .. comChannel:GetId()] = nil

	Comlink:CreateCustomChannel(comChannel)
end)
--gamemodes/egmrp/gamemode/modules/bonemerge/cl_modelpanel.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Client | BoneMerge        --
---------------------------------------

-- Create bone merged entities for model panels.
hook.Add("EGMModelPanel.SetCharacter", "BoneMerge.Attach", function(panel, char)
	local ent = panel.Entity
	if not IsValid(ent) then return end

	panel.BoneMergeModels = panel.BoneMergeModels or {}
	for id, modelData in pairs(BoneMerge.CharacterModels) do
		-- Add the new model.
		local success, clientEnt = BoneMerge:Attach(ent, id, modelData.GetModel(char))
		if not success then
			continue
		end

		if IsValid(clientEnt) then
			clientEnt:SetNoDraw(true)
		end

		-- Apply the model.
		local applyModel = modelData.ApplyModel
		if isfunction(applyModel) then
			applyModel(char, clientEnt)
		end

		panel.BoneMergeModels[id] = clientEnt
	end
end)

-- Remove the bone merged entities.
hook.Add("EGMModelPanel.OnRemove", "BoneMerge.DetachAll", function(panel)
	local ent = panel.Entity
	if not IsValid(ent) then return end

	BoneMerge:DetachAll(ent)

	panel.BoneMergeModels = nil
end)

-- Draw the attached models.
hook.Add("EGMModelPanel.PostDrawModel", "BoneMerge.DrawAttached", function(panel, ent)
	for _, clientEnt in pairs(panel.BoneMergeModels or {}) do
		if not IsValid(clientEnt) then continue end

		clientEnt:DrawModel()
	end
end)



---------------------------------------
--       Inventory Integration       --
---------------------------------------

-- Copy the players bone merge models into the panel.
-- Needs specialized integration, since the player entity is used directly.
-- There are not generalizable hooks for this in the EGMModelPanel.
hook.Add("Inventory.CreatePlayerPreview", "Bonemerge.RegisterModels", function(panel, charEnt)
	panel.BoneMergeModels = BoneMerge.Models[charEnt]
end)

-- Copy the players bone merge models into the panel.
-- Needs specialized integration, since the container entity is used directly.
-- There are not generalizable hooks for this in the EGMModelPanel.
hook.Add("Inventory.CreateContainerPreview", "Bonemerge.RegisterModels", function(panel, containerEnt)
	panel.BoneMergeModels = BoneMerge.Models[containerEnt]
end)
--gamemodes/starwarsrp/gamemode/modules/base_model/cl_inventory_integration.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Base Model        --
---------------------------------------

ItemType:AddPropertyToList("materialSets", "Material Sets", "Material Gruppen, die die benutzten Texturen auf einem Basemodel ändern.", "models", function(itemType)
	local validModels = BaseModel:GetMaterialSets(itemType:GetModels(), true)

	local removedModels = {}
	for modelName, modelString in pairs(validModels) do
		local model = modelString
		local skinId = 0

		local splitModelString = string.Split(modelString, ".mdl_")
		if #splitModelString == 2 then
			model = splitModelString[1] .. ".mdl"
			skinId = splitModelString[2]
		end

		if not itemType:IsModelFree(model, skinId) then
			removedModels[modelName] = modelName
		end
	end
	for _, modelName in pairs(removedModels) do
		validModels[modelName] = nil
	end

	return {
		validModels = validModels,
		inheritedModels = {},
	}
end, nil, 3, egmt("equipment.category"))

-- Add Material Sets to Armour
hook.Add("ItemClass.ShouldShowProperty", "BaseModel.AddPropertyToArmour", function(itemClass, propertyName)
	if propertyName ~= "materialSets" then return end

	if itemClass.IsArmor then
		return true
	end
end)
--gamemodes/starwarsrp/gamemode/modules/base_model/cl_corpse_integration.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Base Model        --
---------------------------------------

hook.Add("Morgue.ApplyModel", "BaseModel.ApplyModel", function(panel, ent, corpseData)
	local materialSetId = corpseData.MaterialSetId
	if not isstring(materialSetId) then return end

	ent.MaterialSetId = materialSetId

	local success, err = BaseModel:ApplyBaseModel(ent, ent:GetModel(), materialSetId)
	if not success then
		LogInfo("BaseModel.RetrieveCorpse: " .. err)
	end
end)
--gamemodes/starwarsrp/gamemode/modules/cwutils/sh_index.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            CW:RP Utils            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       CW:RP Utils | SH Index      --
---------------------------------------

if not RequireModules({"extrarank"}) then
	return false
end

if SERVER then
	AddCSLuaFile("sh_keycards.lua")
	AddCSLuaFile("cl_utils.lua")

	include("sh_keycards.lua")
	include("sv_utils.lua")
end

if CLIENT then
	include("sh_keycards.lua")
	include("cl_utils.lua")
end
--gamemodes/egmrp/gamemode/modules/extrarank/sh_extra_rank.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Extra Rank        --
---------------------------------------

-- Add character property: eFaction
Character:AddProperty("eFaction", "number", -1, function(character, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	local factionId = character:GetFaction():GetId()
	if factionId == value then
		return false, egmt("shared.invalid_value")
	end

	return true
end,
function(character, ply)
	return true
end)

-- Get the extra faction of a character.
--
-- @return? Faction faction
function Character.Meta:GetExtraFaction()
	local factionId = self:GetProperty("eFaction", -1)

	return Faction:GetCached(factionId)
end

-- Add character property: eRank
Character:AddProperty("eRank", "number", -1, function(character, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(character, ply)
	return true
end)

-- Should the character have an extra rank or use the normal rank for both factions?
--
-- @param? Faction extraFaction
-- @return Boolean shouldHaveExtraRank
function Character.Meta:ShouldHaveExtraRank(extraFaction)
	extraFaction = extraFaction or self:GetExtraFaction()
	if not extraFaction then
		return false
	end

	local rank = self:GetRank()
	if not rank then
		return false
	end

	-- Always allow the extra rank, if the rank allows it.
	if self:CanAlwaysHaveExtraRank() then
		return true
	end

	-- If the extra faction has the rank, the character should not have an extra rank.
	if extraFaction:HasRank(rank) then
		return false
	end

	return true
end

-- Get the extra rank of a character.
--
-- @return? Rank rank
function Character.Meta:GetExtraRank()
	local rankId = self:GetProperty("eRank", -1)

	-- If the character should not have an extra rank, return the normal rank.
	if not self:ShouldHaveExtraRank() then
		return self:GetRank()
	end

	return Rank:GetCached(rankId)
end

-- Add rank property: allowERank
Rank:AddProperty("allowERank", "boolean", false, function(rank, value)
	if not isbool(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Is the character allowed to have an extra rank, if he usually should not have one?
--
-- @return Boolean allowed
function Character.Meta:CanAlwaysHaveExtraRank()
	local rank = self:GetRank()
	if not rank then return false end

	return rank:GetProperty("allowERank", false)
end

-- Add equipment property: onMain
Equipment:AddProperty("onMain", "boolean", true, function(equipment, value)
	if not isbool(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(equipment, ply)
	return true
end)

-- Is the equipment relevant for the main faction?
--
-- @return Boolean isOnMain
function Equipment.Meta:IsOnMain()
	return self:GetProperty("onMain", true)
end

-- Add equipment property: onExtra
Equipment:AddProperty("onExtra", "boolean", false, function(equipment, value)
	if not isbool(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(equipment, ply)
	return true
end)

-- Is the equipment relevant for the extra faction?
--
-- @return Boolean isOnExtra
function Equipment.Meta:IsOnExtra()
	return self:GetProperty("onExtra", false)
end

local Player = FindMetaTable("Player")

-- Checks, whether the player can set a character to an extra rank in a faction.
--
-- @param Character character
-- @param Number rankId
-- @param? Number factionId
-- @param? Boolean inviteConfirmed
-- @return Boolean canChangeFactionRank
function Player:CanChangeExtraFactionRank(character, rankId, factionId, inviteConfirmed)
	-- print("\nPlayer:CanChangeExtraFactionRank", self, character, rankId, factionId, inviteConfirmed)

	-- Hooks, to overwrite this function.
	local blockOverride = hook.Run("Player.BlockChangeExtraFactionRank", self, character, rankId, factionId, inviteConfirmed)
	if isbool(blockOverride) then
		return false
	end

	local override = hook.Run("Player.CanChangeExtraFactionRank", self, character, rankId, factionId, inviteConfirmed)
	if isbool(override) then
		return override
	end

	local playerCharacter = self:GetCurrentCharacter()
	if not playerCharacter then
		return false
	end

	local playerFaction = playerCharacter:GetFaction()
	local playerRank = playerCharacter:GetRank()

	local playerExtraFaction = playerCharacter:GetExtraFaction()
	local playerExtraRank = playerCharacter:GetExtraRank()

	local currentExtraFaction = character:GetExtraFaction()
	local currentExtraRank = character:GetExtraRank()

	local targetFaction = currentExtraFaction
	if isnumber(factionId) then
		targetFaction = Faction:GetCached(factionId)
	end

	local targetRank = Rank:GetCached(rankId)

	self.DebugOut = true

	-- Permission Check when the setter is main faction.
	if self:CanChangeRankInternal(playerFaction, playerRank, currentExtraFaction, currentExtraRank, targetFaction, targetRank, inviteConfirmed) then
		return true
	end

	self.DebugOut = nil

	-- Permission Check when the setter is extra faction.
	if self:CanChangeRankInternal(playerExtraFaction, playerExtraRank, currentExtraFaction, currentExtraRank, targetFaction, targetRank, inviteConfirmed) then
		return true
	end

	return false
end

-- Allow characters with high enough normal or extra rank, to change the extra faction rank of other characters.
hook.Add("Character.CanPlayerEditProperties", "ExtraFaction.CanEdit", function(ply, character, properties)
	local extraRankId = properties["eRank"]
	if not isnumber(extraRankId) then
		extraRankId = character:GetProperty("eRank", -1)
	end

	local extraFactionId = properties["eFaction"]

	-- Check, if anything else is being changed.
	for key, _ in pairs(properties) do
		if key ~= "eRank" and key ~= "eFaction" then
			return
		end
	end

	-- If we want to remove the extra faction, we need to find a "Fake" faction and rank to kick to.
	-- This allows kicking from the extra faction.
	if (not isnumber(extraFactionId) or extraFactionId == -1) then
		for _, rank in pairs(Rank:GetCache()) do
			if not rank:CanBeKickedOnto() then continue end

			extraFactionId = rank:GetFaction():GetId()
			extraRankId = rank:GetId()

			break
		end
	end

	-- If we want to set the extra faction, but not the rank, we need to find a rank to pretent to set.
	if not isnumber(extraRankId) or extraRankId == -1 then
		local authorityLevel = math.huge

		-- Find the lowest rank in the faction.
		local faction = Faction:GetCached(extraFactionId)
		if faction then
			for _, rank in pairs(faction:GetRanks()) do
				if rank:GetAuthorityLevel() < authorityLevel then
					extraRankId = rank:GetId()
					authorityLevel = rank:GetAuthorityLevel()
				end
			end
		end
	end

	-- Call the regular permission check function, that already includes the extra rank and faction.
	if ply:CanChangeExtraFactionRank(character, extraRankId, extraFactionId) then
		return true
	end
end)

-- Allow characters with high enough extra rank, to change the main faction rank of other characters.
hook.Add("Player.CanChangeFactionRank", "ExtraRank.ExternalAccess", function(ply, character, rankId, factionId, inviteConfirmed)
	local playerCharacter = ply:GetCurrentCharacter()
	if not playerCharacter then
		return
	end

	local playerExtraFaction = playerCharacter:GetExtraFaction()
	local playerExtraRank = playerCharacter:GetExtraRank()

	local currentFaction = character:GetFaction()
	local currentRank = character:GetRank()

	local targetFaction = currentFaction
	if isnumber(factionId) then
		targetFaction = Faction:GetCached(factionId)
	end

	local targetRank = Rank:GetCached(rankId)

	if ply:CanChangeRankInternal(playerExtraFaction, playerExtraRank, currentFaction, currentRank, targetFaction, targetRank, inviteConfirmed) then
		return true
	end
end)



---------------------------------------
--               Hooks               --
---------------------------------------

-- Override the faction name to include the extra faction.
hook.Add("Character.GetFactionName", "ExtraRank.AddInfo", function(character, factionNameTable)
	local faction = character:GetFaction()
	local extraFaction = character:GetExtraFaction()
	if not faction or not extraFaction then return end

	local factionName = faction:GetName()
	local extraName = extraFaction:GetName()
	local extraPrefix = extraFaction:GetPrefix()

	-- Build the faction string.
	local factionString = factionName
	if factionString == "" then
		factionString = extraPrefix
	elseif extraPrefix ~= "" and extraName ~= factionName then
		factionString = factionName .. "/" .. extraPrefix
	end

	factionNameTable[0] = factionString
end)

-- Override the faction prefix to include the extra faction.
hook.Add("Character.GetFactionPrefix", "ExtraRank.AddInfo", function(character, factionPrefixTable)
	local faction = character:GetFaction()
	local extraFaction = character:GetExtraFaction()
	if not faction or not extraFaction then return end

	local factionPrefix = faction:GetPrefix()
	local extraPrefix = extraFaction:GetPrefix()

	-- Build the faction string.
	local factionString = factionPrefix
	if factionString == "" then
		factionString = extraPrefix
	elseif extraPrefix ~= "" and extraPrefix ~= factionPrefix then
		factionString = factionPrefix .. "/" .. extraPrefix
	end

	factionPrefixTable[0] = factionString
end)

-- Override the rank name to include the extra rank.
hook.Add("Character.GetRankName", "ExtraRank.AddInfo", function(character, rankNameTable)
	local rank = character:GetRank()
	local extraRank = character:GetExtraRank()
	if not rank or not extraRank then return end

	local rankName = rank:GetName()
	local extraName = extraRank:GetName()
	local extraPrefix = extraRank:GetPrefix()

	-- Build the rank string.
	local rankString = rankName
	if rankString == "" then
		rankString = extraPrefix
	elseif extraPrefix ~= "" and extraName ~= rankName then
		rankString = rankName .. "/" .. extraPrefix
	end

	rankNameTable[0] = rankString
end)

-- Override the rank prefix to include the extra rank.
hook.Add("Character.GetRankPrefix", "ExtraRank.AddInfo", function(character, rankPrefixTable)
	local rank = character:GetRank()
	local extraRank = character:GetExtraRank()
	if not rank or not extraRank then return end

	local rankPrefix = rank:GetPrefix()
	local extraPrefix = extraRank:GetPrefix()

	-- Build the rank string.
	local rankString = rankPrefix
	if rankString == "" then
		rankString = extraPrefix
	elseif extraPrefix ~= "" and extraPrefix ~= rankPrefix then
		rankString = rankPrefix .. "/" .. extraPrefix
	end

	rankPrefixTable[0] = rankString
end)

-- Give access to the faction storage to the extra faction.
hook.Add("Character.GetFactionStorages", "ExtraRank.AddStorages",function(self, storages)
	local extraFaction = self:GetExtraFaction()
	if not extraFaction then return end

	local extraRank = self:GetExtraRank()
	if not extraRank then return end

	local extraStorages = {}

	if extraFaction and extraRank:HasPermission(STORAGE_PERMISSION_ACCESS) then
		extraStorages = extraFaction:GetStorages()
	end

	-- Check for Logs access.
	for _, storageData in pairs(extraStorages) do
		if extraRank:HasPermission(STORAGE_PERMISSION_LOGS) then
			storageData.LogsAccess = true
		end
	end

	-- Integrating the extra faction storages.
	for i, storageData in pairs(extraStorages) do
		local currentStorage = storages[i]
		if not currentStorage then
			storages[i] = storageData
		else
			currentStorage.LogsAccess = currentStorage.LogsAccess or storageData.LogsAccess
		end
	end
end)

-- Integrate into "IsSeller"
hook.Add("Character.IsSeller", "ExtraRank.Integration", function(character)
	local extraRank = character:GetExtraRank()
	if not extraRank then return end

	if extraRank:IsSeller() then
		return true
	end
end)

-- Integrate into "HasShopEntryAccess"
hook.Add("Character.HasShopEntryAccess", "ExtraRank.Integration", function(character, shopEntry)
	local extraRank = character:GetExtraRank()
	if not extraRank then return end

	if extraRank:HasShopEntryAccess(shopEntry) then
		return true
	end
end)

-- Add Courses to the character from the extra faction.
hook.Add("Character.GetCourses", "ExtraRank.GetExtraFactionCourses", function(character, courses)
	local extraFaction = character:GetExtraFaction()
	if not extraFaction then return end

	local extraCourses = extraFaction:GetCourses()

	for _, course in pairs(extraCourses) do
		if not table.HasValue(courses, course) then
			table.insert(courses, course)
		end
	end
end)

-- Allow access for extra factions to equipment.
hook.Add("Character.GetRelevantEquipment", "ExtraRank.AddEquipment", function(char, relevantEquipment)
	local extraFaction = char:GetExtraFaction()
	if not extraFaction then return end

	local extraRank = char:GetExtraRank()
	if not extraRank then return end

	local equipment = extraFaction:GetEquipment()
	for _, equip in ipairs(equipment) do
		if not equip:IsRankWhitelisted(extraRank) then
			continue
		end

		local overrideBlock = hook.Run("Character.BlockEquipment", equip, char, extraFaction, extraRank, true)
		if overrideBlock then
			continue
		end

		table.insert(relevantEquipment, equip)
	end
end)

-- Block Equipement, if the equipment should not be used by the normal faction.
hook.Add("Character.BlockEquipment", "ExtraRank.BlockEquipment", function(equip, char, faction, rank, isExtra)
	if isExtra then
		if not equip:IsOnExtra() then
			return true
		end
	else
		if not equip:IsOnMain() then
			return true
		end
	end
end)

-- Add the extra faction marker to the name of the equipment.
hook.Add("Equipment.AddAffectedBonus", "ExtraRank.AddExtraFactionMarker", function(equip, affectedBonus)
	if equip:IsOnExtra() then
		table.insert(affectedBonus, egmt("shared.equip_extra"))
	end

	if equip:IsOnMain() then
		table.insert(affectedBonus, egmt("shared.equip_main"))
	end
end)

-- Add Extra Faction access to the comlink.
hook.Add("Comlink.AddCustomAccess", "ExtraFaction.AccessChannel", function(ply, currentCharacter, comlinkData)
	local extraFaction = currentCharacter:GetExtraFaction()
	if not extraFaction then return end

	-- Allow access to the channel for factions
	if comlinkData.AccessFactions[extraFaction:GetId()] then
		return true
	end
end)

-- Permission Check, to assign courses.
hook.Add("Character.CanPlayerEditProperty.courses", "ExtraFaction.CanEdit", function(ply, character, value)
	local playerCharacter = ply:GetCurrentCharacter()
	local playerFaction, playerRank, playerExtraFaction, playerExtraRank
	if playerCharacter then
		playerFaction = playerCharacter:GetFaction()
		playerRank = playerCharacter:GetRank()

		playerExtraFaction = playerCharacter:GetExtraFaction()
		playerExtraRank = playerCharacter:GetExtraRank()
	end

	local currentFaction = character:GetFaction()
	local currentRank = character:GetRank()
	local currentExtraFaction = character:GetExtraFaction()
	local currentExtraRank = character:GetExtraRank()

	local currentValue = character:GetCourses()

	-- Check, if an extra faction can change the courses of another character's normal faction courses.
	if ply:CanChangeCoursesInternal(playerExtraFaction, playerExtraRank, currentFaction, currentRank, currentValue, value, playerCharacter == character) then
		return true
	end

	-- Check, if a normal faction can change the courses of another character's extra faction courses.
	if ply:CanChangeCoursesInternal(playerFaction, playerRank, currentExtraFaction, currentExtraRank, currentValue, value, playerCharacter == character) then
		return true
	end

	-- Check, if an extra faction can change the courses of another character's extra faction courses.
	if ply:CanChangeCoursesInternal(playerExtraFaction, playerExtraRank, currentExtraFaction, currentExtraRank, currentValue, value, playerCharacter == character) then
		return true
	end
end)

-- Add Extra Faction access to the report viewing.
hook.Add("Reports.CanViewReports", "ExtraFaction.CanView", function(playerCharacter, character)
	local playerFaction = playerCharacter:GetFaction()
	local playerRank = playerCharacter:GetRank()

	local playerExtraFaction = playerCharacter:GetExtraFaction()
	local playerExtraRank = playerCharacter:GetExtraRank()

	local targetFaction = character:GetFaction()
	local targetRank = character:GetRank()

	local targetExtraFaction = character:GetExtraFaction()
	local targetExtraRank = character:GetExtraRank()

	if Reports:CanViewReportsInternal(playerFaction, playerRank, targetExtraFaction, targetExtraRank) then
		return true
	end

	if Reports:CanViewReportsInternal(playerExtraFaction, playerExtraRank, targetFaction, targetRank) then
		return true
	end

	if Reports:CanViewReportsInternal(playerExtraFaction, playerExtraRank, targetExtraFaction, targetExtraRank) then
		return true
	end
end)

-- Add Extra Faction access to the report adding.
hook.Add("Reports.CanAddReport", "ExtraFaction.CanAdd", function(playerCharacter, character)
	local playerFaction = playerCharacter:GetFaction()
	local playerRank = playerCharacter:GetRank()

	local playerExtraFaction = playerCharacter:GetExtraFaction()
	local playerExtraRank = playerCharacter:GetExtraRank()

	local targetFaction = character:GetFaction()
	local targetRank = character:GetRank()

	local targetExtraFaction = character:GetExtraFaction()
	local targetExtraRank = character:GetExtraRank()

	if Reports:CanViewReportsInternal(playerFaction, playerRank, targetExtraFaction, targetExtraRank) then
		return true
	end

	if Reports:CanViewReportsInternal(playerExtraFaction, playerExtraRank, targetFaction, targetRank) then
		return true
	end

	if Reports:CanViewReportsInternal(playerExtraFaction, playerExtraRank, targetExtraFaction, targetExtraRank) then
		return true
	end
end)
--gamemodes/egmrp/gamemode/modules/extrarank/cl_extra_rank.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Extra Rank        --
---------------------------------------

Character:AddPropertyToList("eFaction", egmt("extra_rank.eFaction_name"), egmt("extra_rank.eFaction_description"), "dropdown", function(rank, faction, character)
	local factions = {}

	for _, eFaction in pairs(Faction:GetCache()) do
		if eFaction == faction then continue end

		table.insert(factions, {
			text = eFaction:GetName(),
			data = eFaction:GetId(),
		})
	end

	table.insert(factions, {text = egmt("extra_rank.no_faction"), data = -1})

	return factions
end, function(rank, faction, character)
	if not character then
		return false
	end

	return true
end, 1, egmt("extra_rank.title"))

Character:AddPropertyToList("eRank", egmt("extra_rank.eRank_name"), egmt("extra_rank.eRank_description"), "dropdown", function(rank, faction, character)
	local ranks = {}

	if not character:ShouldHaveExtraRank() then return ranks end

	local extraFaction = character:GetExtraFaction()
	if not extraFaction then return ranks end

	for _, eRank in pairs(extraFaction:GetRanks()) do
		if eRank == rank then continue end

		table.insert(ranks, {
			text = eRank:GetName(),
			data = eRank:GetId(),
		})
	end

	table.insert(ranks, {text = egmt("extra_rank.no_rank"), data = -1})

	return ranks
end, function(rank, faction, character)
	if not character then
		return false
	end

	if not character:ShouldHaveExtraRank() then
		return false
	end

	return true
end, 2, egmt("extra_rank.title"))

Rank:AddPropertyToList("allowERank", egmt("extra_rank.allowERank_name"), egmt("extra_rank.allowERank_description"), "boolean", nil, nil, 1, egmt("extra_rank.title"))

Equipment:AddPropertyToList("onMain", egmt("extra_rank.onMain_name"), egmt("extra_rank.onMain_description"), "boolean", nil, nil, 1, egmt("extra_rank.title"))

Equipment:AddPropertyToList("onExtra", egmt("extra_rank.onExtra_name"), egmt("extra_rank.onExtra_description"), "boolean", nil, nil, 2, egmt("extra_rank.title"))



---------------------------------------
--                Util               --
---------------------------------------

-- Open a menu, to promote or demote a character on their extra rank.
function Character.Meta:OpenExtraRankMenu()
	local ply = LocalPlayer()

	local extraFaction = self:GetExtraFaction()
	if not extraFaction then return end

	local options = {}
	for _, rank in pairs(extraFaction:GetRanks()) do
		if ply:CanChangeExtraFactionRank(self, rank:GetId(), extraFaction:GetId()) then
			table.insert(options, {
				text = rank:GetName(),
				data = rank:GetId(),
				authorityLevel = rank:GetSort(),
			})
		end
	end

	table.SortByMember(options, "authorityLevel")

	local modal = vgui.Create("EGMModal")
	modal:SetCustomTitle(egmt("extra_rank.edit_rank"))
	modal:Selection(egmt("extra_rank.edit_rank_long"), egmt("character.select_rank"), options, function(rankId)
		local success, errors = self:EditProperties({eRank = rankId})
		if not success then
			for _, error in pairs(errors or {}) do
				Notify:Danger(egmt("shared.error"), error)
			end
		end
	end, nil, egmt("character.set_rank"))
end

-- Open a menu, to invite a character to an extra faction.
-- This can either be the local players faction or extra faction.
function Character.Meta:OpenExtraInviteMenu()
	local ply = LocalPlayer()

	local playerCharacter = ply:GetCurrentCharacter()
	if not playerCharacter then return end

	local playerFaction = playerCharacter:GetFaction()
	if not playerFaction then return end

	local factionOptions = {}

	for _, rank in pairs(playerFaction:GetRanks()) do
		if ply:CanChangeExtraFactionRank(self, rank:GetId(), playerFaction:GetId(), true) then
			local factionData = factionOptions[playerFaction:GetId()] or {
				text = playerFaction:GetName(),
				data = {}
			}

			table.insert(factionData.data, {
				text = rank:GetName(),
				data = {RankId = rank:GetId(), FactionId = playerFaction:GetId()},
				authorityLevel = rank:GetSort(),
			})

			factionOptions[playerFaction:GetId()] = factionData
		end
	end

	local extraFaction = playerCharacter:GetExtraFaction()
	if extraFaction then
		for _, rank in pairs(extraFaction:GetRanks()) do
			if ply:CanChangeExtraFactionRank(self, rank:GetId(), extraFaction:GetId(), true) then
				local factionData = factionOptions[extraFaction:GetId()] or {
					text = extraFaction:GetName(),
					data = {}
				}

				table.insert(factionData.data, {
					text = rank:GetName(),
					data = {RankId = rank:GetId(), FactionId = extraFaction:GetId()},
					authorityLevel = rank:GetSort(),
				})

				factionOptions[extraFaction:GetId()] = factionData
			end
		end
	end

	table.SortByMember(factionOptions, "text")

	local modal = vgui.Create("EGMModal")
	modal:SetCustomTitle(egmt("extra_rank.invite"))
	modal:Selection(egmt("extra_rank.invite_long"), egmt("character.select_faction"), factionOptions, function(rankOptions)
		table.SortByMember(rankOptions, "authorityLevel")

		local first = rankOptions[1]
		local factionId = first.data.FactionId

		local faction = Faction:GetCached(factionId)
		if not faction then return end

		if not self:ShouldHaveExtraRank(faction) then
			local rank = self:GetRank()

			rankOptions = {}

			table.insert(rankOptions, {
				text = rank:GetName(),
				data = {RankId = rank:GetId(), FactionId = first.data.FactionId},
				selected = true,
			})
		end

		local rankModal = vgui.Create("EGMModal")
		rankModal:SetCustomTitle(egmt("extra_rank.invite"))
		rankModal:Selection(egmt("extra_rank.invite_long"), egmt("character.select_rank"), rankOptions, function(data)
			if not istable(data) then return end

			net.Start("ExtraRank.Invite")
				net.WriteInt(self:GetId(), 32)
				net.WriteInt(data.FactionId, 32)
				net.WriteInt(data.RankId, 32)
			net.SendToServer()
		end, nil, egmt("character.set_rank"))
	end, nil, egmt("character.set_faction"))
end

-- Open the character invitation response menu.
--
-- @param Faction faction
-- @param Rank rank
function ExtraRank:OpenInviteResponseMenu(faction, rank)
	local modal = vgui.Create("EGMModal")
	modal:SetCustomTitle(egmt("extra_rank.invite"))
	modal:Confirm(egmt("extra_rank.confirm_invite", faction:GetName(), rank:GetName()), function()
		net.Start("ExtraRank.ConfirmInvite")
			net.WriteBool(true)
		net.SendToServer()
	end,
	function()
		net.Start("ExtraRank.ConfirmInvite")
			net.WriteBool(false)
		net.SendToServer()
	end, egmt("shared.accept"), egmt("shared.deny"))
end

net.Receive("ExtraRank.Invite", function(len, ply)
	local factionId = net.ReadInt(32)
	local rankId = net.ReadInt(32)

	local faction = Faction:GetCached(factionId)
	if not faction then return end

	local rank = Rank:GetCached(rankId)
	if not rank then return end

	ExtraRank:OpenInviteResponseMenu(faction, rank)
end)

-- Open the character invitation menu.
function Character.Meta:OpenInviteMenu()
	local ply = LocalPlayer()

	local playerCharacter = ply:GetCurrentCharacter()
	if not playerCharacter then return end

	local playerFaction = playerCharacter:GetFaction()
	if not playerFaction then return end

	local factionOptions = {}

	for _, rank in pairs(playerFaction:GetRanks()) do
		if ply:CanChangeFactionRank(self, rank:GetId(), playerFaction:GetId(), true) then
			local factionData = factionOptions[playerFaction:GetId()] or {
				text = playerFaction:GetName(),
				data = {}
			}

			table.insert(factionData.data, {
				text = rank:GetName(),
				data = {RankId = rank:GetId(), FactionId = playerFaction:GetId()},
				authorityLevel = rank:GetSort(),
			})

			factionOptions[playerFaction:GetId()] = factionData
		end
	end

	local extraFaction = playerCharacter:GetExtraFaction()
	if extraFaction then
		for _, rank in pairs(extraFaction:GetRanks()) do
			if ply:CanChangeFactionRank(self, rank:GetId(), extraFaction:GetId(), true) then
				local factionData = factionOptions[extraFaction:GetId()] or {
					text = extraFaction:GetName(),
					data = {}
				}

				table.insert(factionData.data, {
					text = rank:GetName(),
					data = {RankId = rank:GetId(), FactionId = extraFaction:GetId()},
					authorityLevel = rank:GetSort(),
				})

				factionOptions[extraFaction:GetId()] = factionData
			end
		end
	end

	PrintTable(factionOptions)

	table.SortByMember(factionOptions, "text")

	local modal = vgui.Create("EGMModal")
	modal:SetCustomTitle(egmt("character.invite"))
	modal:Selection(egmt("character.invite_to_faction"), egmt("character.select_faction"), factionOptions, function(rankOptions)
		table.SortByMember(rankOptions, "authorityLevel")

		local rankModal = vgui.Create("EGMModal")
		rankModal:SetCustomTitle(egmt("character.invite"))
		rankModal:Selection(egmt("character.invite_to_faction"), egmt("character.select_rank"), rankOptions, function(data)
			net.Start("Character.Invite")
				net.WriteInt(self:GetId(), 32)
				net.WriteInt(data.FactionId, 32)
				net.WriteInt(data.RankId, 32)
			net.SendToServer()
		end, nil, egmt("character.set_rank"))
	end, nil, egmt("character.set_faction"))
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Show full name of other characters that in some way belong to your extra faction.
hook.Add("UI.ShouldDrawFullName", "ExtraRank.ShowInternal", function(currentCharacter, currentFaction, targetCharacter, targetFaction)
	local currentExtraFaction = currentCharacter:GetExtraFaction()
	local targetExtraFaction = targetCharacter:GetExtraFaction()

	-- currentFaction == targetExtraFaction
	if targetExtraFaction and currentFaction:GetId() == targetExtraFaction:GetId() then
		return true
	end

	-- currentExtraFaction == targetFaction
	if currentExtraFaction and targetFaction:GetId() == currentExtraFaction:GetId() then
		return true
	end

	-- currentExtraFaction == targetExtraFaction
	if currentExtraFaction and targetExtraFaction and currentExtraFaction:GetId() == targetExtraFaction:GetId() then
		return true
	end
end)

-- Add extra faction characters to the CharacterManager.
hook.Add("CharacterManager.LoadByFaction", "ExtraRank.AddCharacters", function(characters, id, filter)
	for _, character in pairs(Character:GetCache()) do
		if table.HasValue(characters, character) then continue end

		local extraFaction = character:GetExtraFaction()
		if extraFaction then
			if extraFaction:GetId() ~= id then continue end

			if string.find(string.lower(character:GetName()), string.lower(filter)) then
				table.insert(characters, character)
			end
		end
	end
end)

-- Add extra rank characters to the CharacterManager.
hook.Add("CharacterManager.LoadByRank", "ExtraRank.AddCharacters", function(characters, factionId, rankId, filter)
	for _, character in pairs(Character:GetCache()) do
		if table.HasValue(characters, character) then continue end

		local extraFaction = character:GetExtraFaction()
		if extraFaction then
			if extraFaction:GetId() ~= factionId then continue end

			local extraRank = character:GetExtraRank()
			if extraRank then
				if extraRank:GetId() ~= rankId then continue end

				if string.find(string.lower(character:GetName()), string.lower(filter)) then
					table.insert(characters, character)
				end
			end
		end
	end
end)

-- Show the invite button, even if you are just an extra faction member.
hook.Add("Character.CanInvite", "ExtraRank.ExtendInvite", function(ply, character)
	local targetFaction = character:GetFaction()
	if not targetFaction then return false end

	local playerCharacter = ply:GetCurrentCharacter()
	if not playerCharacter then return false end

	local extraFaction = playerCharacter:GetExtraFaction()
	if not extraFaction then return end

	if extraFaction:GetId() == targetFaction:GetId() then return end

	-- Only show the invite button if we can invite to at least one rank.
	for k, rank in pairs(extraFaction:GetRanks()) do
		if ply:CanChangeFactionRank(character, rank:GetId(), extraFaction:GetId(), true) then
			return true
		end
	end
end)

--gamemodes/starwarsrp/gamemode/modules/spectate/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Spectate index           --
---------------------------------------

SpectatePlayer = SpectatePlayer or {}

if SERVER then
	include("sv_spectate.lua")
end
--gamemodes/egmrp/gamemode/modules/species/sh_species.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Species System      --
---------------------------------------

-- List of all head models used for species application.
Species.HeadModels = Species.HeadModels or {}

-- List of all headless models used for species application.
Species.BodyModels = Species.BodyModels or {}
Species.BodyModelCache = Species.BodyModelCache or {}

-- Set sharedside property variables.
Species.Name = "Species"

-- Initialize networking.
Species:InitCreationNetworking()
Species:InitEditNetworking()
Species:InitDeletionNetworking()

-- Add species property: name
Species:AddProperty("name", "string", nil, function(species, value)
	if not isstring(value) or #value < 3 then
		return false, egmt("species.invalid_name")
	end

	return true
end,
function(species, ply)
	return true
end)

-- Used to get the name of a species. Will use the name property or the id as a fallback.
--
-- @return String name
function Species.Meta:GetName()
	return self:GetProperty("name") or egmt("shared.species") .. " " .. self:GetId()
end

-- Override the getSort function to sort by name.
function Species.Meta:GetSort()
	return self:GetName()
end

-- Limit on how many members of that species can be played at once in a faction.
Species:AddProperty("factionLimit", "number", 0, function(species, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	if value < 0 or value > 32 then
		return false, "Invalid Faction Limit"
	end

	return true
end,
function(species, ply)
	return true
end)

-- Get the faction limit of a species.
--
-- @return Number factionLimit
function Species.Meta:GetFactionLimit()
	return self:GetProperty("factionLimit", 0)
end

-- Limit on how many members of that species a player can create.
Species:AddProperty("characterLimit", "number", 0, function(species, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	if value < 0 or value > 8 then
		return false, "Invalid Character Limit"
	end

	return true
end,
function(species, ply)
	return true
end)

-- Get the character limit of a species.
--
-- @return Number characterLimit
function Species.Meta:GetCharacterLimit()
	return self:GetProperty("characterLimit", 0)
end

-- Limit on how many members of that species a player can create.
Species:AddProperty("bloodColor", "number", 0, function(species, value)
	value = value or 0
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	if not (
		value == DONT_BLEED
	or value == BLOOD_COLOR_RED
	or value == BLOOD_COLOR_YELLOW
	or value == BLOOD_COLOR_GREEN
	or value == BLOOD_COLOR_MECH
	or value == BLOOD_COLOR_ANTLION
	or value == BLOOD_COLOR_ZOMBIE
	or value == BLOOD_COLOR_ANTLION_WORKER
	) then
		return false, egmt("species.invalid_blood_color")
	end

	return true
end,
function(species, ply)
	return true
end)

-- Get the blood color of a species.
--
-- @return Number bloodColor
function Species.Meta:GetBloodColor()
	return self:GetProperty("bloodColor", 0)
end

-- Add species property: headModels
Species:AddProperty("headModels", "table", {}, function(species, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(species, ply)
	return true
end)

-- Get the head models of a species.
--
-- @return Table headModels
function Species.Meta:GetHeadModels()
	return self:GetProperty("headModels", {})
end

-- Add species property: bodyModelGroup
Species:AddProperty("bodyModelGroup", "string", "", function(species, value)
	if value == "" then
		return true
	end

	if not isstring(value) then
		return false, egmt("shared.invalid_type")
	end

	if not istable(Species.BodyModels[value]) then
		return false, egmt("faction.invalid_id")
	end

	return true
end,
function(species, ply)
	return true
end)

-- Get the body model group of a species.
--
-- @return String bodyModelGroup
function Species.Meta:GetBodyModelGroup()
	return self:GetProperty("bodyModelGroup", "")
end

-- Get the models of the selected body model group.
--
-- @return Table bodyModels
function Species.Meta:GetBodyModelGroupModels()
	local bodyModelGroup = self:GetBodyModelGroup()
	if bodyModelGroup == "" then
		return {}
	end

	return Species.BodyModels[bodyModelGroup] or {}
end

-- Add species property: bodyModels
Species:AddProperty("bodyModels", "table", {}, function(species, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(species, ply)
	return true
end)

-- Get the body models of a species.
--
-- @return Table bodyModels
function Species.Meta:GetBodyModels()
	return self:GetProperty("bodyModels", {})
end

-- Get all body models of a species including the body model group.
--
-- @return Table bodyModels
function Species.Meta:GetAllBodyModels()
	local bodyModels = table.Copy(self:GetBodyModels())

	local additionalBodyModels = self:GetBodyModelGroupModels()
	MergeTableByValue(bodyModels, additionalBodyModels)

	bodyModels = FilterBlacklist(bodyModels)

	return bodyModels
end

-- Add species property: healthBonus
Species:AddProperty("healthBonus", "number", 0, function(species, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(species, ply)
	return true
end)

-- Get the health bonus of a species.
--
-- @return Number healthBonus
function Species.Meta:GetHealthBonus()
	return self:GetProperty("healthBonus", 0)
end

-- Add species property: armorBonus
Species:AddProperty("armorBonus", "number", 0, function(species, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(species, ply)
	return true
end)

-- Get the armor bonus of a species.
--
-- @return Number armorBonus
function Species.Meta:GetArmorBonus()
	return self:GetProperty("armorBonus", 0)
end

-- Add species property: speedBonus
Species:AddProperty("speedBonus", "number", 0, function(species, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(species, ply)
	return true
end)

-- Get the speed bonus of a species.
--
-- @return Number speedBonus
function Species.Meta:GetSpeedBonus()
	return self:GetProperty("speedBonus", 0)
end

-- Add species property: jumpBonus
Species:AddProperty("jumpBonus", "number", 0, function(species, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(species, ply)
	return true
end)

-- Get the jump bonus of a species.
--
-- @return Number jumpBonus
function Species.Meta:GetJumpBonus()
	return self:GetProperty("jumpBonus", 0)
end

-- Add species property: scaleModifier
Species:AddProperty("scaleModifier", "number", 1, function(species, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(species, ply)
	return true
end)

-- Get the scale modifier of a species.
--
-- @return Number scaleModifier
function Species.Meta:GetScaleModifier()
	return self:GetProperty("scaleModifier", 1)
end

-- Add species property: damageImmunities
Species:AddProperty("damageImmunities", "table", {}, function(species, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(species, ply)
	return true
end)

-- Get the damage immunities of a species.
--
-- @return Table damageImmunities
function Species.Meta:GetDamageImmunities()
	return self:GetProperty("damageImmunities", {})
end

-- Limit access to the edit functions.
hook.Add("Species.CanPlayerEditProperties", "Species.EditPropertiesPermissions", function(ply, rank, properties)
	return ply:IsAtLeast(Species.MinAccessGroup)
end)

hook.Add("Species.CanPlayerEditData.factionId", "Species.EditFactionIdPermissions", function(ply, rank, rankId)
	return ply:IsAtLeast(Species.MinAccessGroup)
end)

hook.Add("Species.CanPlayerCreate", "Species.CreatePermissions", function(ply, data, properties)
	return ply:IsAtLeast(Species.MinAccessGroup)
end)

hook.Add("Species.CanPlayerDelete", "Species.DeletePermissions", function(ply, character)
	return ply:IsAtLeast(Species.MinAccessGroup)
end)

-- Allow Staff to edit species.
hook.Add("Character.CanPlayerEditProperty.species", "Species.EditSpeciesPermissions", function(ply, character, value)
	if ply:IsAtLeast(Species.MinAccessGroup) then
		return true
	end
end)

-- Allow Staff to edit head model.
hook.Add("Character.CanPlayerEditProperty.headModel", "Species.EditHeadModelPermissions", function(ply, character, value)
	if ply:IsAtLeast(Species.MinAccessGroup) then
		return true
	end
end)



---------------------------------------
--         Model Registration        --
---------------------------------------

-- Register a body model as a headless model.
--
-- @param String model
-- @param? String category
function Species:RegisterHeadlessModel(model, category)
	category = category or ""

	local modelTable = Species.BodyModels[category] or {}

	if not table.HasValue(modelTable, model) then
		table.insert(modelTable, model)
	end

	Species.BodyModels[category] = modelTable

	-- Write to cache.
	if not table.HasValue(Species.BodyModelCache, model) then
		table.insert(Species.BodyModelCache, model)
	end
end

-- Register a head model for a species.
--
-- @param String name
function Species:RegisterHeadModel(name, model)
	Species.HeadModels[name] = model
end



---------------------------------------
--       Character Integration       --
---------------------------------------

-- Add rank property: speciesWhitelist
Rank:AddProperty("speciesWhitelist", "table", {}, function(rank, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	for _, speciesId in pairs(value) do
		local species = Species:GetCached(speciesId)
		if not species then
			return false, egmt("species.invalid")
		end
	end

	return true
end,
function(rank, ply)
	return true
end)

-- Get the species whitelist of a rank.
--
-- @return Table speciesWhitelist
function Rank.Meta:GetSpeciesWhitelist()
	return self:GetProperty("speciesWhitelist", {})
end

-- Check, if a species is whitelisted for a rank.
--
-- @param Species species
-- @return Boolean isWhitelisted
function Rank.Meta:IsSpeciesWhitelisted(species)
	local speciesWhitelist = self:GetSpeciesWhitelist()

	-- If the whitelist is empty, all species are whitelisted.
	if #speciesWhitelist == 0 then
		return true
	end

	return table.HasValue(speciesWhitelist, species:GetId())
end

-- Add Equipment property: speciesWhitelist
Equipment:AddProperty("speciesWhitelist", "table", {}, function(equipment, value)
	if not istable(value) then
		return false, egmt("shared.invalid_type")
	end

	for _, speciesId in pairs(value) do
		local species = Species:GetCached(speciesId)
		if not species then
			return false, egmt("species.invalid")
		end
	end

	return true
end,
function(equipment, ply)
	return true
end)

-- Get the species whitelist of a equipment.
--
-- @return Table speciesWhitelist
function Equipment.Meta:GetSpeciesWhitelist()
	return self:GetProperty("speciesWhitelist", {})
end

-- Check, if a species is whitelisted for a equipment.
--
-- @param Species species
-- @return Boolean isWhitelisted
function Equipment.Meta:IsSpeciesWhitelisted(species)
	local speciesWhitelist = self:GetSpeciesWhitelist()

	-- If the whitelist is empty, all species are whitelisted.
	if #speciesWhitelist == 0 then
		return true
	end

	return table.HasValue(speciesWhitelist, species:GetId())
end

Character:AddProperty("species", "number", -1, function(character, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	local rank = character:GetRank()
	if not rank then
		return false, egmt("character.invalid_rank")
	end

	local species = Species:GetCached(value)
	if not species then
		return false, egmt("species.invalid")
	end

	return true
end,
function(character, ply)
	return true
end)

-- Get the species of a character.
--
-- @return Species species
function Character.Meta:GetSpecies()
	local rank = self:GetRank()
	if not rank  then
		return false
	end

	local override = hook.Run("Species.GetCharacterSpecies", self)
	if override then
		return override
	end

	return Species:GetCached(self:GetProperty("species", -1))
end

-- Add character property: headModel
Character:AddProperty("headModel", "string", "", function(character, value)
	if not isstring(value) then
		return false, egmt("shared.invalid_type")
	end

	local rank = character:GetRank()
	if not rank then
		return false, egmt("inventory_loadout.invalid_rank")
	end

	local species = character:GetSpecies()
	if not species then
		return false, egmt("species.invalid")
	end

	-- Allow headless species.
	local headModels = species:GetProperty("headModels", {})
	if #headModels == 0 then
		return true
	end

	if not table.HasValue(headModels, value) then
		return false, egmt("species.invalid_head")
	end

	return true
end,
function(character, ply)
	return true
end)

-- Get the head model of a character.
--
-- @param String model
-- @param Number skinId
-- @return String headModel
function Character.Meta:GetHeadModel(model, skinId)
	local species = self:GetSpecies()
	if not species then return end

	-- Hide head models, if the species has no head models.
	local headModels = species:GetProperty("headModels", {})
	if #headModels == 0 then return end

	-- Hide head models, if the model is not a body model.
	if not table.HasValue(Species.BodyModelCache, model) then
		return
	end

	local blockHeadModel = hook.Run("Species.HideHeadModel", self, species, model, skinId)
	if blockHeadModel then
		return
	end

	local override = hook.Run("Species.OverrideHeadModel", self, species, model, skinId)
	if isstring(override) then
		return override
	end

	local headModel = self:GetProperty("headModel", "")
	if not table.HasValue(headModels, headModel) then
		headModel = headModels[1]
	end

	return headModel
end

-- Add properties to creation whitelist, so they can be set on character creation.
table.insert(Character.PropertiesAllowedOnCreationWhitelist, "species")
table.insert(Character.PropertiesAllowedOnCreationWhitelist, "headModel")



---------------------------------------
--               Hooks               --
---------------------------------------

-- Add Hooks for registering models.
hook.Add("EGMRP.Loaded", "Species.RegisterObjects", function()
	hook.Run("Species.RegisterModels")
end)

-- Prevent too many characters from being created.
hook.Add("Character.CanPlayerCreate", "Species.CreatePermissions", function(ply, data, properties)
	local speciesId = properties.species
	local species = Species:GetCached(speciesId)
	if species then
		local characterLimit = species:GetProperty("characterLimit", 0)
		if characterLimit == 0 then
			return
		end

		local count = 0
		for _, character in pairs(ply:GetCharacters()) do
			local characterSpecies = character:GetSpecies()
			if characterSpecies and characterSpecies == species then
				count = count + 1
			end
		end

		if count >= characterLimit then
			return false, egmt("species.characterLimit_error", species:GetName())
		end
	end
end)

-- Add species validation to Character.IsPlayable, so the player can't play a character if the limit is reached.
hook.Add("Character.IsPlayable", "Species.IsPlayable", function(character)
	local ply = character:GetOwner()
	if not IsValid(ply) then
		return
	end

	local species = character:GetSpecies()
	if species then

		-- Now we search for a whitelist, beginning with the rank and checking equipment afterwards.
		local rank = character:GetRank()
		if rank and not rank:IsSpeciesWhitelisted(species) then
			local relevantEquipment = character:GetRelevantEquipment()

			local oneFound = false
			for _, equip in pairs(relevantEquipment) do
				if equip:IsSpeciesWhitelisted(species) then
					oneFound = true
					break
				end
			end

			if not oneFound then
				return false, egmt("species.not_whitelisted")
			end
		end

		local characterLimit = species:GetProperty("characterLimit", 0)
		if characterLimit > 0 then
			local count = 0

			for _, otherCharacter in pairs(ply:GetCharacters()) do
				local characterSpecies = otherCharacter:GetSpecies()
				if not characterSpecies then
					continue
				end

				if characterSpecies == species then
					count = count + 1
				end
			end

			if count > characterLimit then
				return false, egmt("species.characterLimit_error", species:GetName())
			end
		end

		local factionLimit = species:GetProperty("factionLimit", 0)
		if factionLimit > 0 then
			local count = 0

			local faction = character:GetFaction()

			for _, otherPly in pairs(player.GetHumans()) do
				local otherCharacter = otherPly:GetCurrentCharacter()
				if not otherCharacter then
					continue
				end

				if otherCharacter:GetFaction() ~= faction then
					continue
				end

				local characterSpecies = otherCharacter:GetSpecies()
				if not characterSpecies then
					continue
				end

				if characterSpecies == species then
					count = count + 1
				end
			end

			if count > factionLimit then
				return false, egmt("species.factionLimit_error", species:GetName())
			end
		end
	end
end)

-- Remove body models that are not allowed for the species.
hook.Add("Character.RemoveValidModels", "Species.BlockModels", function(character, validModels)
	local species = character:GetSpecies()
	if not species then return end

	-- If the species has no head models, remove all body models.
	local headModels = species:GetHeadModels()
	if #headModels == 0 then
		for _, model in pairs(Species.BodyModelCache) do
			if table.HasValue(validModels, model) then
				table.RemoveByValue(validModels, model)
			end
		end
	end

	local bodyModels = species:GetAllBodyModels()

	-- Remove all non-available body models.
	local removedModels = {}
	for _, model in pairs(validModels) do
		if not table.HasValue(bodyModels, model) then
			table.insert(removedModels, model)
		end
	end

	for _, model in pairs(removedModels) do
		table.RemoveByValue(validModels, model)
	end
end)

-- Apply species health and armor bonuses.
hook.Add("Character.GetStats", "Species.ApplyStats", function(char, stats)
	local species = char:GetSpecies()
	if not species then return end

	local healthBonus = species:GetHealthBonus()
	local armorBonus = species:GetArmorBonus()

	stats[1] = stats[1] + healthBonus
	stats[2] = stats[2] + armorBonus
end)

-- Apply species speed and jump bonuses.
hook.Add("Character.GetMovement", "Species.ApplyMovement", function(char, movement)
	local species = char:GetSpecies()
	if not species then return end

	local speedBonus = species:GetSpeedBonus()
	local jumpBonus = species:GetJumpBonus()

	movement[1] = movement[1] + speedBonus
	movement[2] = movement[2] + jumpBonus
end)

-- Apply species scale modifier.
hook.Add("Character.GetScale", "Species.ApplyScale", function(char, scale)
	local species = char:GetSpecies()
	if not species then return end

	local scaleModifier = species:GetScaleModifier()

	scale[1] = scale[1] * scaleModifier
end)

-- Block changing rank if the species is not whitelisted.
hook.Add("Player.BlockChangeFactionRank", "Species.BlockInvalid", function(ply, character, rankId, factionId, inviteConfirmed, isExtra)
	if isExtra then return end

	local species = character:GetSpecies()
	if not species then return end

	local rank = Rank:GetCached(rankId)
	if not rank then return end

	-- Check if the species is whitelisted for the rank.
	if not rank:IsSpeciesWhitelisted(species) then
		return true
	end
end)
--gamemodes/egmrp/gamemode/modules/species/cl_corpse.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Species System      --
---------------------------------------

-- Set the species head model for the corpse of a respawned player.
hook.Add("BoneMerge.GetRespawnedCorpseModel", "Species.OverrideHeadModel", function(ent, id)
	if id ~= "Head" then return end

	local headModel = ent:GetNWString("headModel", "")
	if not isstring(headModel) or headModel == "" then return end

	local skip = hook.Run("Species.SkipCorpseHeadModel", ent, headModel)
	if skip then return end

	return headModel
end)

-- Apply the species head model to the corpse preview in the morgue.
hook.Add("Morgue.ApplyModel", "Species.ApplyModel", function(panel, ent, corpseData)
	local headModel = corpseData.HeadModel
	if not isstring(headModel) or headModel == "" then return end

	local success, clientEnt = BoneMerge:Attach(ent, "Head", headModel)
	if not success then
		return
	end

	panel.BoneMergeModels = panel.BoneMergeModels or {}
	panel.BoneMergeModels["Head"] = clientEnt
end)
--gamemodes/egmrp/gamemode/modules/species/cl_manager.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Manager | Species System     --
---------------------------------------

Manager:RegisterObjectCategory(
    Species.Name,
    egmt("shared.species"),
    function()
        return Species:GetCache()
    end,
    function()
        return Species:Create({}, {name = egmt("species.new")})
    end,
    nil,
    egmt("species.duplicate_long"),
    egmt("species.delete"),
    egmt("species.delete_warning"),
    egmt("species.add"),
    egmt("species.save")
)
--gamemodes/egmrp/gamemode/modules/species/sh_inv_integration.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Shared | Species System      --
---------------------------------------

if not Config.Modules["inventory"] then return end

-- Add Species property: weightBonus
Species:AddProperty("weightBonus", "number", 0, function(species, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(species, ply)
	return true
end)

-- Get the weight bonus of an species.
--
-- @return Number weightBonus
function Species.Meta:GetWeightBonus()
	return self:GetProperty("weightBonus", 0)
end



---------------------------------------
--               Hooks               --
---------------------------------------

-- Add the weight bonus of the species to the max weight of the character.
hook.Add("Inventory.GetMaxWeight", "Species.AddWeightBonus", function(character, weightData)
	local species = character:GetSpecies()
	if not species then return end

	weightData[1] = weightData[1] + species:GetWeightBonus()
end)
--gamemodes/egmrp/gamemode/modules/inventory_storage/item_slots/storage/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Shared | Storage Item Slot    --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Base Item slot, from which functions and such should be inherited.
ITEM_SLOT.BaseItemSlot = "base"

-- Number of items that can be stored in this slot.
ITEM_SLOT.Count = 15

-- Are items equipped as useable items?
ITEM_SLOT.Equipment = false
--gamemodes/egmrp/gamemode/modules/inventory_storage/item_slots/trash/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Trash Item Slot     --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Name of the item slot displayed in the inventory.
ITEM_SLOT.Name = ""

-- Number of rows, the items should be displayed in.
ITEM_SLOT.Rows = 1

-- Prevent Right Click Interaction on supply slots.
function ITEM_SLOT:OnRightClick(slot)
end
--gamemodes/egmrp/gamemode/modules/inventory_money/cl_money.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | InventoryMoney      --
---------------------------------------

Rank:AddPropertyToList("paycheck", egmt("money.paycheck"), egmt("money.peycheck_description"), "slider", function()
    return {min = 0, max = 10000}
end, nil, 2, egmt("inventory.title"))
--gamemodes/starwarsrp/gamemode/modules/jetpack/item_classes/jetboot/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Shared | Jetpack Item       --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Base Item class, from which functions and such should be inherited.
ITEM_CLASS.BaseItemClass = "jetpack"

-- List of item slots, which the item can be equipped to.
ITEM_CLASS.Slots = {
	"belt",
	"backpack",
}

-- Sorting order of the item.
ITEM_CLASS.Sort = 3
--gamemodes/starwarsrp/gamemode/modules/jetpack/item_classes/jetpack/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Shared | Jetpack Item       --
---------------------------------------

local ITEM_CLASS = ITEM_CLASS

-- Base Item class, from which functions and such should be inherited.
ITEM_CLASS.BaseItemClass = "bonemerge"

-- List of item slots, which the item can be equipped to.
ITEM_CLASS.Slots = {
	"back",
	"backpack",
}

-- Sorting order of the item.
ITEM_CLASS.Sort = 3

-- Check, if the item can be added to the given slot.
--
-- @param Table inventory
-- @param ItemType itemType
-- @param Table itemData
-- @param? String slotType
-- @return Boolean canAdd
-- @return? String error
function ITEM_CLASS:CanEquipInto(inventory, itemType, itemData, slotType)
	local currentJetpack = Inventory:GetCurrentJetpack(nil, inventory)

	-- Check if the player already has a jetpack equipped.
	if currentJetpack and Inventory:IsEquipmentSlotType(slotType) then
		return false, "You already have a jetpack like item equipped."
	end

	local success, err = ITEM_CLASS.Base.CanEquipInto(self, inventory, itemType, itemData, slotType)
	if not success then
		return false, err
	end

	return true
end

---------------------------------------
--           Util Functions          --
---------------------------------------

-- Gets the current jetpack of the character.
--
-- @param? Character char
-- @param? Table inventory
-- @return? Table itemData
function Inventory:GetCurrentJetpack(char, inventory)
	return InventoryBoneMerge:GetCurrentItem("Jetpack", char, inventory)
end
--gamemodes/starwarsrp/gamemode/modules/medicsystem/sh_config.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Config        --
---------------------------------------

-- Max distance for some security checks
Medicsystem.MaxDistance = 10000

-- Experience for treatment
Medicsystem.Experience = 30

-- Refill crate model
Medicsystem.RefillModel = "models/starwars/syphadias/props/hoth_barrack/small_box.mdl"

-- Damagetypes that do not result in injury
Medicsystem.DamageModelResistance = {
	-- Example Damage Type
	-- [DMG_TYPE] = {
	-- 	["Model Path here"] = true,
	-- },
}

Medicsystem.Hitgroups = {
	[HITGROUP_HEAD] = "Kopf",
	[HITGROUP_CHEST] = "Thorax",
	[HITGROUP_STOMACH] = "Abdomen",
	[HITGROUP_LEFTARM] = "Linker Arm",
	[HITGROUP_RIGHTARM] = "Rechter Arm",
	[HITGROUP_LEFTLEG] = "Linkes Bein",
	[HITGROUP_RIGHTLEG] = "Rechtes Bein",

	[0] = "Nicht definiert"
}

-- Multiplies for kill check
Medicsystem.DeathMultiplies = {
	["Kopf"] = 1,
	["Thorax"] = 2,
	["Abdomen"] = 3,
	["Linker Arm"] = 4,
	["Rechter Arm"] = 4,
	["Linkes Bein"] = 4,
	["Rechtes Bein"] = 4
}

-- The injury severities are listed here
--
Medicsystem.InjurySeverities = {
	"Gering",
	"Ernsthaft",
	"Schwer",
	"Sehr schwer",
	"Kritisch",
	"Fatal"
}

--gamemodes/starwarsrp/gamemode/modules/medicsystem/weapons/weapon_swrp_medic_base/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Medicsystem | Base         --
---------------------------------------

SWEP.Base 					= "weapon_swrp_egm_base"

SWEP.PrintName 				= "Injektor"
SWEP.Category 				= "SW:RP (Medicsystem)"
SWEP.Type				   	= "Medical Supply Equipment"
SWEP.Manufacturer		   	= "Bac-Tech Industries"

SWEP.Slot 					= 2
SWEP.SlotPos 				= 0

SWEP.Author 				= "Deltaa"
SWEP.Purpose 				= "Wähle mit 'R' eine Behandlung aus."
SWEP.Instructions 			= "Linksklick zur Anwendung bei jemand anderem \nRechtsklick zur Eigenanwendung"
SWEP.Spawnable				= false

SWEP.HoldType 				= "slam"
SWEP.UseHands 				= true
SWEP.ShowWorldModel 		= false

SWEP.DefaultFireMode 		= "Normal"
SWEP.Attachments 			= {}

SWEP.NextUse 				= 0

SWEP.treatmentCurrentlyAppling = false
SWEP.treatmentAppliedTime 	= 0
SWEP.treatmentFinishedTime 	= 0

SWEP.treatmentInfo = {
	targetEntity = nil,
	hitGroup = nil,
	injuryName = nil,
	treatment = nil
}

SWEP.ViewModelBoneMods = {
	["v_scoutblaster_reference001"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, -0.3, 0), angle = Angle(0, 0, 0) }
}

function SWEP:Holster()
	if self:GetNextPrimaryFire() > CurTime() then return end
	if self:GetNextSecondaryFire() > CurTime() then return end

	return true
end

function SWEP:PrimaryAttack()
	if self:GetNextPrimaryFire() > CurTime() then return end
	if self.NextUse > CurTime() then return end
	self.NextUse = CurTime() + 1

	local owner = self:GetOwner()
	if not IsValid(owner) then return end

	local trace = owner:GetEyeTrace()
	local entity = trace.Entity

	-- Check whether the entity is valid
	if not IsValid(entity) then return end

	-- Checks whether the player is too far away from the entity
	if trace.HitPos:DistToSqr(owner:GetShootPos()) > Medicsystem.MaxDistance then return end

	-- Check, whether the character has access to the used SWEP, when required
	if self.NeedsKnowledge then
		local character = owner:GetCurrentCharacter()
		if not character then return end

		local validWeapons = character:GetValidWeapons()
		if not table.HasValue(validWeapons, self:GetClass()) then
			if CLIENT then
				Notify:Warning("Fehler!", "Du hast nicht die nötigen Kenntnisse, um dieses Werkzeug zu benutzen.", 4)
			end

			return
		end
	end

	if CLIENT and Medicsystem:IsValidEntity(entity) then
		entity = Medicsystem:IsValidEntity(entity)

		if not self.selectedTreatment then
			Notify:Warning("Fehler!", "Du hast keine Behandlung ausgewählt.", 4)
			return
		end

		if trace.HitGroup != 0 then
			Medicsystem:SelectInjury(entity, Medicsystem.Hitgroups[trace.HitGroup], self.selectedTreatment, function(selectedInjury)
				Medicsystem:SelectTreatment(entity, Medicsystem.Hitgroups[trace.HitGroup], selectedInjury, self.selectedTreatment)
			end)
		else
			-- If the entity is a ragdoll, select hitgroup via menu, because ragdolls dont have hitgroups
			Medicsystem:SelectHitgroup(entity, self.selectedTreatment, function(hitGroup)
				Medicsystem:SelectInjury(entity, hitGroup, self.selectedTreatment, function(selectedInjury)
					Medicsystem:SelectTreatment(entity, hitGroup, selectedInjury, self.selectedTreatment)
				end)
			end)
		end
	end
end

function SWEP:SecondaryAttack()
	if self:GetNextSecondaryFire() > CurTime() then return end
	if self.NextUse > CurTime() then return end
	self.NextUse = CurTime() + 1

	-- Check, whether the character has access to the used SWEP, when required
	if self.NeedsKnowledge then
		local character = self:GetOwner():GetCurrentCharacter()
		if not character then return end

		local validWeapons = character:GetValidWeapons()
		if not table.HasValue(validWeapons, self:GetClass()) then
			Notify:Warning("Fehler!", "Du hast nicht die nötigen Kenntnisse, um dieses Werkzeug zu benutzen.", 4)

			return
		end
	end

	if CLIENT then
		local ply = self:GetOwner()

		if not self.selectedTreatment then
			Notify:Warning("Fehler!", "Du hast keine Behandlung ausgewählt.", 4)
			return
		end

		Medicsystem:SelectHitgroup(ply, self.selectedTreatment, function(hitGroup)
			Medicsystem:SelectInjury(ply, hitGroup, self.selectedTreatment, function(selectedInjury)
				Medicsystem:SelectTreatment(ply, hitGroup, selectedInjury, self.selectedTreatment)
			end)
		end)

		self:SetNextSecondaryFire(CurTime() + 2)
	end
end

function SWEP:Reload()
	if self:GetNextSecondaryFire() > CurTime() then return end

	if CLIENT then
		Medicsystem:OpenTreatments(self.ItemType, function(selectedTreatment)
			self.selectedTreatment = selectedTreatment
		end)
	end
end

local nextThink = 0
function SWEP:Think()
	if SERVER then
		local targetEntity = self.treatmentInfo.targetEntity
		local treatment = self.treatmentInfo.treatment
		local hitGroup = self.treatmentInfo.hitGroup
		local injuryName = self.treatmentInfo.injuryName

		if CurTime() >= nextThink and IsValid(targetEntity) and timer.Exists("TreatInjuryTimer_" .. treatment .. "_" .. hitGroup .. "_" .. injuryName .. "_" .. self:GetOwner():SteamID64()) then
			local trace = self:GetOwner():GetEyeTrace()
			local entity = trace.Entity

			if targetEntity ~= self:GetOwner() and IsValid(entity) and (entity:IsPlayer() or entity:IsRagdoll()) and trace.HitPos:DistToSqr(self:GetOwner():GetShootPos()) > Medicsystem.MaxDistance then
				timer.Remove("TreatInjuryTimer_" .. treatment .. "_" .. hitGroup .. "_" .. injuryName .. "_" .. self:GetOwner():SteamID64())
			end

			nextThink = CurTime() + 0.1
		end
	else
		if CurTime() >= nextThink and self.treatmentCurrentlyAppling then
			if CurTime() > self.treatmentFinishedTime then
				self.treatmentCurrentlyAppling = false
				self.treatmentAppliedTime = 0
				self.treatmentFinishedTime = 0
			end

			nextThink = CurTime() + 0.1
		end
	end
end

function SWEP:ProcessFireMode()
end

function SWEP:IronSights()
end

function SWEP:DrawHUD()
	local trace = self:GetOwner():GetEyeTrace()

	if trace.HitGroup ~= 0 then
		draw.RoundedBox(0, ScrW() - (ScrW() * 0.12), ScrH() * 0.8, ScrW() * 0.12, math.ceil(ScrH() * 0.03), GetColor("darkgray", 200))

		draw.SimpleText(Medicsystem.Hitgroups[trace.HitGroup], "EGMText12", ScrW() * 0.89, ScrH() * 0.815, GetColor("yellow"), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end

	draw.RoundedBox(0, ScrW() - (ScrW() * 0.12), ScrH() * 0.85, ScrW() * 0.12, math.ceil(ScrH() * 0.03), GetColor("darkgray", 200))

	if self.selectedTreatment then
		draw.SimpleText(Medicsystem.Treatments[self.selectedTreatment].Name, "EGMText8", ScrW() * 0.89, ScrH() * 0.865, GetColor("yellow"), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	else
		draw.SimpleText("Keine Behandlung ausgewählt", "EGMText6", ScrW() * 0.89, ScrH() * 0.865, GetColor("yellow"), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end

	if self.treatmentCurrentlyAppling and self.treatmentFinishedTime >= CurTime() then
		local progress = (CurTime() - self.treatmentAppliedTime) / (self.treatmentFinishedTime - self.treatmentAppliedTime)

		draw.RoundedBox(0, ScrW() * 0.25, ScrH() * 0.85, ScrW() / 2, math.ceil(ScrH() * 0.03), GetColor("darkgray", 200))

		draw.RoundedBox(0, ScrW() * 0.25, ScrH() * 0.85, (ScrW() / 2) * progress, math.ceil(ScrH() * 0.03), GetColor("green", 200))

		draw.SimpleText(math.Round(self.treatmentFinishedTime - CurTime(), 1) .. "s", "EGMText12", ScrW() / 2, ScrH() * 0.85, GetColor("white"), TEXT_ALIGN_CENTER)
	end
end

function SWEP:DrawHUDAmmo()
	return false
end
--gamemodes/starwarsrp/gamemode/modules/medicsystem_droid/sh_medicsystem.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Medicsystem | SH        	 --
---------------------------------------

-- Checks whether the player is a droid
local Player = FindMetaTable("Player")
function Player:IsDroid()
	local character = self:GetCurrentCharacter()
	if not character then return Realism.Droids[self:GetModel()] end

	local modelSkin = character:GetProperty("modelSkin", {Model = Character.FallbackModel})
	return Realism.Droids[modelSkin.Model or ""]
end

local Entity = FindMetaTable("Entity")
function Entity:IsDroid()
	return Realism.Droids[self:GetModel()]
end
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/entities/medicsystem_refill_pack/cl_init.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--     Medicsystem | Refill Pack     --
---------------------------------------

include("shared.lua")

function ENT:Draw()
	self:DrawModel()

	if LocalPlayer():GetPos():DistToSqr(self:GetPos()) < 512 * 512 then
		local plyAng = self:GetAngles()

		local ang = Angle(plyAng.x, plyAng.y, plyAng.z)
		ang:RotateAroundAxis(ang:Forward(), 90)
		ang:RotateAroundAxis(ang:Right(), -90)

		cam.Start3D2D(self:GetPos() + self:GetForward() + self:GetUp() * 3, ang, .15)
			draw.RoundedBox(5, -180, -200, 350, 45, Color(0, 0, 0, 230))
			draw.DrawText("Medizinische Vorräte", "header", -1, -195, Color(66, 224, 245, 255), TEXT_ALIGN_CENTER)
		cam.End3D2D()
	end
end
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/weapons/weapon_swrp_medic_opkit/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--    Medicsystem | Treatment Kit    --
---------------------------------------

SWEP.Base 					= "weapon_swrp_medic_base"

SWEP.PrintName			  	= "Operationskit"
SWEP.Category			   	= "SW:RP (Medicsystem)"
SWEP.Type				   	= "Medical Supply Equipment"
SWEP.Manufacturer		   	= "Bac-Tech Industries"

SWEP.Author 				= "Deltaa"
SWEP.Purpose 				= "Wähle mit 'R' eine Behandlung aus."
SWEP.Contact 				= "https://www.einfach-gaming.de/user/4179-deltaa/"
SWEP.Instructions 			= "Linksklick zur Anwendung bei jemand anderem"
SWEP.Spawnable 				= true

SWEP.ViewModelFOV 			= 80
SWEP.ViewModelFlip			= false
SWEP.ViewModel 				= "models/bf2017/c_scoutblaster.mdl"
SWEP.WorldModel 			= "models/shells/pellet.mdl"

SWEP.Slot 					= 2
SWEP.SlotPos 				= 0

SWEP.ItemType 				= "Opkit"
SWEP.UseHands 				= false
SWEP.NeedsKnowledge 		= true

SWEP.VElements = {
	["Tube"] = {
		type = "Model",
		model = "models/lt_c/sci_fi/coffee_mug.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "",
		pos = Vector(-1, 17, 2),
		angle = Angle(17, 10, -31),
		size = Vector(0.4, 0.4, 0.4),
		color = Color(255, 0, 0, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},
	["tip"] = {
		type = "Model",
		model = "models/lt_c/sci_fi/am_container.mdl",
		bone = "v_scoutblaster_reference001",
		rel = "Tube",
		pos = Vector(0, 0, 3.5),
		angle = Angle(0, 54, 0),
		size = Vector(0.039, 0.039, 0.039),
		color = Color(0, 255, 0, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

SWEP.WElements = {
	["Tube"] = {
		type = "Model",
		model = "models/lt_c/sci_fi/coffee_mug.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(2.599, 1.6, 1),
		angle = Angle(29.221, -8.183, 180),
		size = Vector(0.699, 0.699, 0.699),
		color = Color(255, 0, 0, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	},

	["tip"] = {
		type = "Model",
		model = "models/lt_c/sci_fi/am_container.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "Tube",
		pos = Vector(0, 0, 5.8),
		angle = Angle(0, 54.935, 0),
		size = Vector(0.07, 0.07, 0.07),
		color = Color(0, 255, 0, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

SWEP.Primary.ClipSize = 40
SWEP.Primary.DefaultClip = 40
SWEP.Primary.Ammo = "none"

-- Aiming
SWEP.IronSightsPos = Vector(0, 0, -2)
SWEP.IronSightsAng = Vector(0, 0, 0)

-- Running
SWEP.RunSightsPos = Vector(0, 0, -2)
SWEP.RunSightsAng = Vector(0, 0, 0)

-- Inspecting
SWEP.InspectPos = Vector(0, 0, -2)
SWEP.InspectAng = Vector(0, 0, 0)

function SWEP:SecondaryAttack()

end
--gamemodes/starwarsrp/gamemode/modules/gravitylock/sh_index.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Gravity Lock            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        G ravity Lock | SH         --
---------------------------------------


Gravitylock = Gravitylock || {}
Gravitylock.Config = Gravitylock.Config || {}

if SERVER then
	AddCSLuaFile("sh_config.lua")

	include("sh_config.lua")
	include("sv_gravitylock.lua")
end

if CLIENT then
	include("sh_config.lua")
end
--gamemodes/starwarsrp/gamemode/modules/gravitylock/entities/swrp_gravitylock_small/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Gravity Locks           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Gravity Locks | SH         --
---------------------------------------

ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Gravity Lock (Klein)"
ENT.Author = "Deltaa"
ENT.Category = "SW:RP (Republik)"

ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = false

ENT.IsGravitylocker = true
--gamemodes/starwarsrp/gamemode/modules/gravitylock/weapons/weapon_swrp_pad_locker/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Gravity Lock            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Gravity Lock | SH         --
---------------------------------------

SWEP.Base = "weapon_swrp_egm_base"

SWEP.PrintName = "Gravity Lock"
SWEP.Author = "Deltaa"
SWEP.Contact = "https://einfach-gaming.de"
SWEP.Purpose = "Eine Waffe für den SW:RP Spielmodus"
SWEP.Instructions = "Linksklick: Platziert/entfernt einen Gravity Lock an/von einem Fahrzeug. \nNachladen: Wechselt zwischen 'Platzieren' und 'Entfernen'"

SWEP.Category = "SW:RP (Sonstiges)"
SWEP.Type = "Portable tractor beam"
SWEP.Manufacturer = "Deltaa Industries"

SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.ViewModelFOV = 60
SWEP.Slot = 3
SWEP.SlotPos = 0

SWEP.HoldType = "slam"
SWEP.UseHands = true

SWEP.NextReload = 0

SWEP.Mode = "Platzieren"

SWEP.Primary.ClipSize = 5
SWEP.Primary.DefaultClip = 5
SWEP.Primary.Ammo = "none"

SWEP.data = {}
SWEP.data.ironsights = 0

SWEP.DefaultFireMode = "Normal"

SWEP.ViewModel = "models/weapons/c_bugbait.mdl"
SWEP.WorldModel = "models/weapons/w_datapad.mdl"

function SWEP:PreDrawViewModel()
	render.SetBlend(0)
end

SWEP.VElements = {
	["element_scope"] = {
		type = "Model",
		model = "models/weapons/w_datapad.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(1, 4, 1),
		angle = Angle(-160, -160, -45),
		size = Vector(1.2, 1.2, 1.2),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

if CLIENT then
	SWEP.PreviewModelSmall = ClientsideModel("models/niksacokica/tech/tech_support.mdl")
	SWEP.PreviewModelSmall:SetNoDraw(true)
	SWEP.PreviewModelSmall:SetMaterial("models/wireframe")

	SWEP.PreviewModelBig = ClientsideModel("models/niksacokica/tech/tech_support_02.mdl")
	SWEP.PreviewModelBig:SetNoDraw(true)
	SWEP.PreviewModelBig:SetModelScale(1.5)
	SWEP.PreviewModelBig:SetMaterial("models/wireframe")
end

-- Switches between the available options
--
function SWEP:Reload()
	if self.NextReload >= CurTime() then return end

	if self.Mode == "Platzieren" then
		self.Mode = "Entfernen"
	elseif self.Mode == "Entfernen" then
		self.Mode = "Platzieren"
	end

	self.NextReload = CurTime() + 2

	if CLIENT then
		surface.PlaySound("UI/buttonclick.wav")
	end
end

-- Depending on the mode, selects the corresponding function
--
function SWEP:PrimaryAttack()
	if self:GetNextPrimaryFire() > CurTime() then return end
	self:SetNextPrimaryFire(CurTime() + 3)

	if self.Mode == "Platzieren" then
		self:PlaceLock()
	elseif self.Mode == "Entfernen" then
		self:RemoveLock()
	end
end

function SWEP:SecondaryAttack()
	self:PrimaryAttack()
end

-- Places a Gravity Lock
--
function SWEP:PlaceLock()
	if CLIENT then return end

	local ply = self:GetOwner()

	if self:Clip1() < 1 then
		Notify:Danger(self:GetOwner(), "Fehler!", "Du kannst keine weiteren Gravity Locks platzieren!")
		return
	end

	ply:LagCompensation(true)
	local trace = ply:GetEyeTrace()
	ply:LagCompensation(false)

	local ent = trace.Entity
	if not IsValid(ent) then return end

	if trace.HitPos:DistToSqr(ply:GetShootPos()) > 20000 then return end

	if ent.IsLocked then
		Notify:Danger(ply, "Fehler!", "Dieses Fahrzeug ist bereits verschlossen!")
		return
	end

	if Gravitylock.Config.Vehicles["Big"][ent:GetClass()] then
		local vehicleTable = Gravitylock.Config.Vehicles["Big"][ent:GetClass()]

		local gravLock = ents.Create("swrp_gravitylock_big")
		gravLock:SetPos( ent:LocalToWorld(vehicleTable.pos or Vector(0, 0, 0) ) + ent:GetVelocity() * FrameTime() )
		gravLock:SetAngles( ent:LocalToWorldAngles(vehicleTable.angles or Angle(0, 0, 0) ) )
		gravLock:Spawn()

		Gravitylock:LockVehicle(gravLock, ent)
	elseif Gravitylock.Config.Vehicles["Small"][ent:GetClass()] then
		local vehicleTable = Gravitylock.Config.Vehicles["Small"][ent:GetClass()]

		local gravLock = ents.Create("swrp_gravitylock_small")
		gravLock:SetPos( ent:LocalToWorld(vehicleTable.pos or Vector(120, 0, -45) ) + ent:GetVelocity() * FrameTime() )
		gravLock:SetAngles( ent:LocalToWorldAngles(vehicleTable.angles or Angle(0, 180, 0) ) )
		gravLock:Spawn()

		Gravitylock:LockVehicle(gravLock, ent)
	end

	self:SetClip1(self:Clip1() - 1)
end

-- Removes a Gravity Lock
--
function SWEP:RemoveLock()
	if CLIENT then return end

	self:GetOwner():LagCompensation(true)
	local trace = self:GetOwner():GetEyeTrace()
	self:GetOwner():LagCompensation(false)

	local ent = trace.Entity
	if not IsValid(ent) then return end

	if (ent:GetClass() == "swrp_gravitylock_big") or (ent:GetClass() == "swrp_gravitylock_small") then
		if trace.HitPos:DistToSqr(self:GetOwner():GetShootPos()) > 5000 then return end

		if ent.IsLocked and IsValid(ent.IsLocked) then
			ent:EmitSound("physics/metal/metal_box_strain4.wav")
			Gravitylock:Unlock(ent, ent.IsLocked)

			self:SetClip1(math.min(self.Primary.ClipSize, self:Clip1() + 1))

			SafeRemoveEntity(ent)
		end
	end
end

-- Draws the mode
--
function SWEP:DrawHUD()
	draw.RoundedBox(0, 0, ScrH() * 0.90, ScrW() * 0.13, ScrH() * 0.03, GetColor("darkgray", 200))
	draw.SimpleText("Modus: " .. self.Mode, "EGMText12", ScrW() * 0.065, ScrH() * 0.9, GetColor("yellow"), TEXT_ALIGN_CENTER)
end

-- Draws the gravity lock preview on the model
--
hook.Add("PostDrawOpaqueRenderables", "Gravitylocker:PreDrawModel", function ()
	local ply = LocalPlayer()
	local weapon = ply:GetActiveWeapon()

	if not ply:Alive() then return end
	if ply:InVehicle() then return end

	if IsValid(weapon) and weapon:GetClass() == "weapon_swrp_pad_locker" then
		if weapon.Mode != "Platzieren" then return end

		local trace = LocalPlayer():GetEyeTrace()

		if trace.HitPos:DistToSqr(ply:GetShootPos()) > 20000 then return end
		if not IsValid(trace.Entity) then return end

		local ent = trace.Entity
		if ent.IsLocked then return end

		if Gravitylock.Config.Vehicles["Big"][ent:GetClass()] then
			local vehicleTable = Gravitylock.Config.Vehicles["Big"][ent:GetClass()]

			weapon.PreviewModelBig:SetPos(ent:LocalToWorld(vehicleTable.pos or Vector(120, 0, -45) ) + ent:GetVelocity() * FrameTime())
			weapon.PreviewModelBig:SetAngles( ent:LocalToWorldAngles(vehicleTable.angles or Angle(0, 180, 0) ) )

			weapon.PreviewModelBig:DrawModel()
			render.SetColorModulation(0,0,0)
		elseif Gravitylock.Config.Vehicles["Small"][ent:GetClass()] then
			local vehicleTable = Gravitylock.Config.Vehicles["Small"][ent:GetClass()]

			weapon.PreviewModelSmall:SetPos( ent:LocalToWorld(vehicleTable.pos or Vector(120, 0, -45) ) + ent:GetVelocity() * FrameTime() )
			weapon.PreviewModelSmall:SetAngles( ent:LocalToWorldAngles(vehicleTable.angles or Angle(0, 180, 0) ) )

			weapon.PreviewModelSmall:DrawModel()
			render.SetColorModulation(0,0,0)
		end
	end
end)


function SWEP:ProcessFireMode()

end

function SWEP:IronSights()

end

function SWEP:DrawHUDAmmo()
	return false
end
--gamemodes/egmrp/gamemode/modules/escapescreen/cl_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--   Client | Escape screen config   --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- The background used in the escape screen.
EscapeScreen.Background = "backgrounds/shut_up_bofreemian_rhapsody.jpg"

-- The buttons in the escape screen.
EscapeScreen.Buttons = {
    {
        name = egmt("escapescreen.continue_playing"),
        func = function()
            EscapeScreen:Close()
        end
    },
    {
        name = egmt("escapescreen.server_browser"),
        func = function()
            RunConsoleCommand("gamemenucommand", "openserverbrowser")
            gui.ActivateGameUI()
        end
    },
    {
        name = egmt("escapescreen.keybinds"),
        dockTop = 0.03,
        func = function()
            KeyBind:OpenMenu()
        end
    },
    {
        name = egmt("escapescreen.custom_settings"),
        func = function()
            Settings:OpenMenu()
        end
    },
    {
        name = egmt("escapescreen.settings"),
        dockTop = 0.03,
        func = function()
            RunConsoleCommand("gamemenucommand", "openoptionsdialog")
            gui.ActivateGameUI()
        end
    },
    {
        name = egmt("escapescreen.console"),
        func = function()
            RunConsoleCommand("showconsole")
            gui.ActivateGameUI()
        end
    },
    {
        name = egmt("escapescreen.leave"),
        func = function()
            RunConsoleCommand("disconnect")
        end
    }
}
--gamemodes/egmrp/gamemode/modules/morgue/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Morgue | Config          --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Model for the mourge, to dispose of corpses.
Morgue.Model = "models/props_wasteland/laundry_washer003.mdl"

-- If you should be able to take the corpse out of the morgue.
Morgue.TakeBackOut = true

-- If the corpse of a player is put into the morgue, the player can immediately respawn.
Morgue.AllowRespawnWhenMorgue = true

-- List of all body bags and their settings.
-- Models used should be ragdolls.
-- Default uses this addon: https://steamcommunity.com/sharedfiles/filedetails/?id=909047837
Morgue.BodyBagModels = {
	--[[
	["modelpath/to/ragdoll.mdl"] = { -- Example
		Name = "Bodybag", -- Name of the bodybag, that will be displayed on the SWEP.
		Category = "EGM:RP", -- Category of the bodybag SWEP.
		ClassName = "egmrp_bodybag_default", -- Class Name of the bodybag.

		BagCount = 1, -- How many bags are given on equip, 0 is infinite.

		RagdollOffset = Vector(-50, 0, 0), -- Offset of the ragdoll to the bodybag, when its being wrapped.
		RagdollAngle = Angle(0, 90, 90), -- Angle of the ragdoll to the bodybag, when its being wrapped.
		RagdollBone = "ValveBiped.Bip01_Spine2", -- Bone of the ragdoll, that should be used to place the bodybag onto the ragdoll.

		BodyBagOffset = Vector(0, 0, 0), -- Offset of the bodybag to the ragdoll, when its being unwrapped.
		BodyBagAngle = Angle(0, 0, 0), -- Angle of the bodybag to the ragdoll, when its being unwrapped.
		BodyBagBone = "midup", -- Bone of the bodybag, that should be used to place the ragdoll onto the bodybag.

		CreateMorgue = true, -- If a morgue should be created, where the bodybag can be taken from.
		MorgueModel = "models/props_wasteland/laundry_washer003.mdl", -- Model of the custom morgue, if CreateMorgue is true, if not set, the default morgue model will be used.
	},
	]]
}

-- The offset, that is used, to carry ragdoll.
Morgue.BodyBagCarryOffset = Vector(0, 0, 0)
Morgue.BodyBagCarryAngle = Angle(0, 0, 0)

-- Body bag bone mods if they are carried by a player.
Morgue.BodyBagCarryBoneMods = {
--[[
	["bottom"] = Angle(0, 0, 0),
	["midlow"] = Angle(0, 0, 0),
	["midup"] = Angle(90, 0, 0),
	["top"] = Angle(90, 0, 0),
]]
}
--gamemodes/egmrp/gamemode/modules/morgue/cl_morgue.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Morgue | Client          --
---------------------------------------

-- Opens the morgue menu.
net.Receive("Morgue.OpenMenu", function()
	local ent = net.ReadEntity()
	local len = net.ReadInt(32)
	local bodies = DecompressTable(net.ReadData(len))

	Morgue:OpenMenu(ent, bodies)
end)

-- Opens the morgue menu.
function Morgue:OpenMenu(ent, bodies)
	self:CloseMenu()

	self.Frame = vgui.Create("EGMSmallFrame")
	self.Frame:SetCustomTitle(egmt("morgue.title"))
	local w, h = self.Frame:GetSize()

	self.ScrollPanel = vgui.Create("EGMScrollPanel", self.Frame)
	self.ScrollPanel:Dock(FILL)

	local bodyBagClass = ent.BodyBagClass
	if isstring(bodyBagClass) then
		self.GetBodyBagButton = vgui.Create("EGMButton", self.Frame)
		self.GetBodyBagButton:Dock(BOTTOM)
		self.GetBodyBagButton:SetHeight(h * 0.05)
		self.GetBodyBagButton:SetTextColor(UI.TextColor)
		self.GetBodyBagButton:SetFont("EGMText10")
		self.GetBodyBagButton:SetText(egmt("morgue.get_body_bag"))
		function self.GetBodyBagButton:DoClick()
			net.Start("Morgue.RetrieveBodyBag")
				net.WriteEntity(ent)
			net.SendToServer()

			Morgue:CloseMenu()
		end
	end

	for id, corpseData in pairs(bodies) do
		local panel = vgui.Create("DPanel", self.ScrollPanel)
		panel:SetHeight(h * 0.2)
		panel:DockMargin(5, 5, 5, 5)
		panel:Dock(TOP)
		function panel:Paint(w, h)
			draw.RoundedBox(5, 0, 0, w, h, UI.BackgroundColor2)
		end

		local modelPanel = vgui.Create("EGMModelPanel", panel)
		modelPanel:SetSize(w * 0.3 , w * 0.2)
		modelPanel:Dock(LEFT)
		modelPanel:SetMouseInputEnabled(false)

		modelPanel:SetModel(corpseData.Model)
		local previewCorpse = modelPanel:GetEntity()
		if IsValid(previewCorpse) then
			previewCorpse:SetSkin(corpseData.SkinId)
			for i, v in ipairs(corpseData.BodyGroups) do
				previewCorpse:SetBodygroup(i, v)
			end

			previewCorpse:SetColor(corpseData.Color)
			previewCorpse:SetMaterial(corpseData.Material)

			hook.Run("Morgue.ApplyModel", modelPanel, previewCorpse, corpseData)
		end

		local button = vgui.Create("EGMButton", panel)
		button:SetWidth(w * 0.5)
		button:DockMargin(5, h * 0.05, 5, h * 0.05)
		button:Dock(RIGHT)
		button:SetTextColor(UI.TextColor)
		button:SetFont("EGMText10")
		button:SetText(egmt("morgue.pickup_body"))
		function button:DoClick()
			net.Start("Morgue.RetrieveCorpse")
				net.WriteEntity(ent)
				net.WriteUInt(id, 32)
			net.SendToServer()

			Morgue:CloseMenu()
		end

		if not self.TakeBackOut then
			button:SetDisabled(true)
		end
	end

	self.Frame:MakePopup()
end

-- Closes the morgue menu.
function Morgue:CloseMenu()
	if IsValid(self.Frame) then
		self.Frame:Close()
	end
end
--gamemodes/egmrp/gamemode/modules/morgue/weapons/egmrp_bodybag/shared.lua:
---------------------------------------
---------------------------------------
--	     	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Created by             --
--       Jan 'Oninoni' Ziegler       --
--       		Deltaa       		 --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
---------------------------------------
---------------------------------------

---------------------------------------
--       Bodybag SWEP | Shared       --
---------------------------------------

AddCSLuaFile()

SWEP.PrintName  = egmt("morgue.bodybag")

-- Spawnable disabled for inherting.
SWEP.Spawnable  = false
SWEP.AdminOnly  = false

SWEP.Slot       = 4
SWEP.SlotPos    = 0

SWEP.ViewModelFOV = 70

SWEP.ViewModel = "models/weapons/c_medkit.mdl"
SWEP.WorldModel = "models/weapons/w_package.mdl"

SWEP.Primary.Ammo           = ""
SWEP.Primary.ClipSize       = 0
SWEP.Primary.DefaultClip    = 0
SWEP.Primary.Automatic      = false

SWEP.Secondary.Ammo         = ""
SWEP.Secondary.ClipSize     = 0
SWEP.Secondary.DefaultClip  = 0
SWEP.Secondary.Automatic    = false

-- Custom Variables set by the derived SWEP
SWEP.BodyBagModel = ""
SWEP.BagCount = 1
SWEP.RagdollOffset = Vector(0, 0, 0)
SWEP.RagdollAngle = Angle(0, 0, 0)
SWEP.RagdollBone = "ValveBiped.Bip01_Head1"
--gamemodes/egmrp/gamemode/modules/reports/cl_reports.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Client | Reports System      --
---------------------------------------

-- Opens the Reports of a specified character.
function Reports:Open(character)
    self:Close()

    if not LocalPlayer():CanViewReports(character) then return end

    local _, h = ScrW() * 0.9, ScrH() * 0.8

    self.Frame = vgui.Create("EGMFrame")
    self.Frame:SetBackground(self.Background)
    self.Frame:SetSubTitle(egmt("reports.name") .. " - " .. character:GetFullName())
    self.Frame:ShowCloseButton(false)
    function self.Frame:OnClose()
        -- Clear runtime variables.
        Reports.Data = nil
    end

    self.ActivityDisplay = vgui.Create("DPanel", self.Frame)
    self.ActivityDisplay:SetPos(ScrW() * 0.1, ScrH() * 0.25)
    self.ActivityDisplay:SetSize(ScrW() * 0.8, ScrH() * 0.2)
    self.ActivityDisplay:SetHeight(h * 0.3)
    function self.ActivityDisplay:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, UI.BackgroundColor2)

        if not Reports.Data then return end

        local w16 = width / 14
        local w17 = width / 15
        local wDotSize = (w16 - w17)
        local wOffset = wDotSize / 2
        local wOffset2 = (w16 / 2) - wOffset

        local h098 = height * 0.98
        -- Only 18 Hours, so it is displayed bigger. If sb plays more than 18 hours it will cut.
        local dayMinutes = 18 * 60

        local data = Reports.Data.Activity
        local lastValue = 0

        for i = 0, 13, 1 do
            local x = w16 * (13 - i)
            draw.RoundedBox(0, x + wOffset, 0, w17, height, ColorAlpha(UI.BackgroundColor, 255))

            local value = 0
            if data and data[i] then
                value = math.floor(data[i])
            end

            local hours = math.floor(value / 60)
            local minutes = value - hours * 60

            local timeString = hours .. egmt("reports.hour") .. ":"

            if minutes < 10 then
                timeString = timeString .. "0" .. minutes
            else
                timeString = timeString .. minutes
            end

            timeString = timeString .. egmt("reports.minute")

            draw.DrawText(timeString, "EGMText8", x + wOffset2, 0, UI.ForegroundColor, TEXT_ALIGN_CENTER)

            draw.RoundedBox(0, x + wOffset2, h098 - (value / dayMinutes) * h098, wDotSize, wDotSize, UI.ForegroundColor2)

            if i ~= 0 then
                surface.DrawLine(
                    (w16 * (13 - (i - 1))) + wOffset2 + (wDotSize / 2),
                    h098 - (lastValue / dayMinutes) * h098 + (wDotSize / 2),

                    x + wOffset2 + (wDotSize / 2),
                    h098 - (value / dayMinutes) * h098 + (wDotSize / 2)
                )
            end

            lastValue = value

            if i == 0 then
                draw.DrawText(egmt("reports.today"), "EGMText6", x + wOffset2, height * 0.9, UI.ForegroundColor, TEXT_ALIGN_CENTER)
            elseif i == 1 then
                draw.DrawText(egmt("reports.one_day_ago"), "EGMText6", x + wOffset2, height * 0.9, UI.ForegroundColor, TEXT_ALIGN_CENTER)
            elseif i == 7 then
                draw.DrawText(egmt("reports.one_week_ago"), "EGMText6", x + wOffset2, height * 0.9, UI.ForegroundColor, TEXT_ALIGN_CENTER)
            else
                draw.DrawText(egmt("reports.days_ago", i), "EGMText6", x + wOffset2, height * 0.9, UI.ForegroundColor, TEXT_ALIGN_CENTER)
            end
        end
    end

    self.ReportList = vgui.Create("EGMListView", self.Frame)
    self.ReportList:SetPos(ScrW() * 0.1, ScrH() * 0.5)
    self.ReportList:SetSize(ScrW() * 0.8, ScrH() * 0.425)
    self.ReportList:SetHeaderHeight(h * 0.05)
    self.ReportList:SetDataHeight(h * 0.05)
    self.ReportList:SetHeaderFont("EGMText10")
    self.ReportList:SetDataFont("EGMText8")
    self.ReportList:SetMultiSelect(false)
    self.ReportList:AddCustomColumn(egmt("reports.entry"))
    self.ReportList:AddCustomColumn(egmt("reports.date")):SetFixedWidth(ScrW() * 0.125)
    function self.ReportList:Refresh()
        if not Reports.Data then return end

        for k, entry in pairs(Reports.Data) do
            if k == "Activity" then continue end

            local line = self:AddSortedLine(entry.text, nil, os.date(egmt("shared.date_time"), entry.created), entry.created)
            if LocalPlayer():IsTeamMember() then
                local deleteButton = vgui.Create("EGMButton", line)
                deleteButton:SetButtonCornerRadius(5)
                deleteButton:SetSize(ScrW() * 0.05, ScrH() * 0.025)
                deleteButton:SetPos(ScrW() * 0.01, ScrH() * 0.008)
                deleteButton:SetTextColor(UI.TextColor)
                deleteButton:SetText(egmt("shared.delete"))
                deleteButton:SetFont("EGMText7")
                function deleteButton:DoClick()
                    local modal = vgui.Create("EGMModal")
					modal:SetCustomTitle(egmt("reports.delete_entry"))

                    modal:Confirm(egmt("shared.are_you_sure"), function()
                    net.Start("Character.RemoveReport")
                        net.WriteInt(character:GetId(), 32)
                        net.WriteInt(k, 32)
                        net.WriteString(util.TableToJSON(entry))
                    net.SendToServer()
                    end)
                end
            end
        end

        self:SortByColumn(2, true)
    end

    self.AddEntryPanel = vgui.Create("DPanel", self.Frame)
    self.AddEntryPanel:SetPos(ScrW() * 0.1, ScrH() * 0.925)
    self.AddEntryPanel:SetSize(ScrW() * 0.8, ScrH() * 0.05)
    function self.AddEntryPanel:Paint() end

    self.AddEntryText = vgui.Create("DTextEntry", self.AddEntryPanel)
    self.AddEntryText:Dock(FILL)
    self.AddEntryText:SetFont("EGMText10")
    self.AddEntryText:SetPlaceholderText(egmt("reports.entry"))
    self.AddEntryText:SetVisible(LocalPlayer():CanAddReport(character))

    self.AddEntryButton = vgui.Create("EGMButton", self.AddEntryPanel)
    self.AddEntryButton:Dock(RIGHT)
    self.AddEntryButton:SetWidth(ScrW() * 0.2)
    self.AddEntryButton:SetText(egmt("reports.add_entry"))
    self.AddEntryButton:SetFont("EGMText10")
    self.AddEntryButton:SetTextColor(UI.TextColor)
    self.AddEntryButton:SetVisible(LocalPlayer():CanAddReport(character))
    function self.AddEntryButton:DoClick()
        Reports:Add(character, Reports.AddEntryText:GetValue())
    end

    self:Load(character)
    self.Frame:MakePopup()
end


hook.Add("CharacterManager.Open", "Reports.AddButton", function(self, w, h)
    self.EditReportButton = vgui.Create("EGMButton", self.CharacterPanel)
    self.EditReportButton:SetPos(w * 0.55, h * 0.8)
    self.EditReportButton:SetSize(w * 0.4, h * 0.075)
    self.EditReportButton:SetTextColor(UI.TextColor)
    self.EditReportButton:SetFont("EGMText10")
    self.EditReportButton:SetText(egmt("character.dossier"))
    self.EditReportButton:SetEnabled(false)
    function self.EditReportButton:DoClick()
        Reports:Open(CharacterManager.CurrentCharacter)
    end
end)

hook.Add("CharcterManager.ShowCharacter", "Reports.UnlockButton", function(self, character, faction, rank)
    if LocalPlayer():CanViewReports(character) then
        self.EditReportButton:SetEnabled(true)
    end
end)

-- Requests adding a report to the reports of the character.
--
-- @param Character character
-- @param String text
function Reports:Add(character, text)
    if not LocalPlayer():CanAddReport(character) then return end

    net.Start("Character.AddReport")
        net.WriteInt(character:GetId(), 32)
        net.WriteString(text)
    net.SendToServer()
end

-- Loads all Reports of a player.
--
-- @param Character character
function Reports:Load(character)
    if not LocalPlayer():CanViewReports(character) then return end

    net.Start("Character.ViewReports")
        net.WriteInt(character:GetId(), 32)
    net.SendToServer()
end

-- Receives all Reports of a player
net.Receive("Character.ViewReports", function()
    local length = net.ReadInt(32)
    local data = DecompressTable(net.ReadData(length))
    Reports.ReportList:Clear()

    Reports.Data = data
    Reports.ReportList:Refresh()
end)

-- Closes the character manager.
function Reports:Close()
    if IsValid(self.Frame) then
        self.Frame:Close()
    end
end

--gamemodes/starwarsrp/gamemode/modules/medicsystem_jedi/weapons/weapon_swrp_medic_jedi/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--    Medicsystem | Treatment Kit    --
---------------------------------------

SWEP.Base 					= "weapon_swrp_medic_base"

SWEP.PrintName			  	= "Machtheilung"
SWEP.Category			   	= "SW:RP (Medicsystem)"
SWEP.Type				   	= "Medical Supply Equipment"
SWEP.Manufacturer		   	= "Die Macht"

SWEP.Author 				= "Deltaa"
SWEP.Purpose 				= "Wähle mit 'R' eine Behandlung aus."
SWEP.Contact 				= "https://www.einfach-gaming.de/user/4179-deltaa/"
SWEP.Instructions 			= "Linksklick zur Anwendung bei jemand anderem \nRechtsklick zur Eigenanwendung"
SWEP.Spawnable 				= true

SWEP.ViewModelFOV 			= 80
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= ""
SWEP.WorldModel				= ""

SWEP.Slot 					= 2
SWEP.SlotPos 				= 0

SWEP.ItemType 				= "Force"
SWEP.UseHands 				= false
SWEP.IsMedicScanner 		= true
SWEP.HoldType 				= "magic"

SWEP.VElements = {}

SWEP.WElements = {}

SWEP.Primary.ClipSize = 100
SWEP.Primary.DefaultClip = 100
SWEP.Primary.Ammo = "none"

-- Aiming
SWEP.IronSightsPos = Vector(0, 0, -2)
SWEP.IronSightsAng = Vector(0, 0, 0)

-- Running
SWEP.RunSightsPos = Vector(0, 0, -2)
SWEP.RunSightsAng = Vector(0, 0, 0)

-- Inspecting
SWEP.InspectPos = Vector(0, 0, -2)
SWEP.InspectAng = Vector(0, 0, 0)
--gamemodes/egmrp/gamemode/modules/experience/cl_perks.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Client | Perks           --
---------------------------------------

-- Opens the perk menu.
-- TODO: Reload + notify when skilling
function Experience:OpenPerkMenu()
    self:ClosePerkMenu()

    local char = LocalPlayer():GetCurrentCharacter()
    if not char then return end

    local pointsAvailable = char:GetAvailableSkillPoints()
    local perks = char:GetProperty("perks", {})

    self.PerkMenu = vgui.Create("EGMFrame")
    self.PerkMenu:SetBackground(self.PerkMenuBackground)
    self.PerkMenu:SetSubTitle(egmt("experience.skilltree", pointsAvailable))

    self.PerkScroller = vgui.Create("DHorizontalScroller", self.PerkMenu)
    self.PerkScroller:SetPos(ScrW() * 0.1, ScrH() * 0.25)
    self.PerkScroller:SetSize(ScrW() * 0.8, ScrH() * 0.7)
    self.PerkScroller:SetOverlap(ScrW() * 0.003) -- thin line between every panel.
    function self.PerkScroller.btnLeft:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, UI.ForegroundColor)
        draw.SimpleText("<", "EGMText6", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    function self.PerkScroller.btnRight:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, UI.ForegroundColor)
        draw.SimpleText(">", "EGMText6", width / 2, height / 2, UI.TextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    for perk, data in pairs(self.Perks) do
        local perkScrollPanel = vgui.Create("EGMScrollPanel", self.PerkScroller)
        perkScrollPanel:SetSize(ScrW() * 0.8 / 3, ScrH() * 0.7)
        function perkScrollPanel:Paint(width, height)
            draw.RoundedBox(5, 0, 0, width, height, UI.BackgroundColor2)
        end

        local perkCategoryTitle = vgui.Create("DLabel", perkScrollPanel)
        perkCategoryTitle:DockMargin(0, ScrH() * 0.01, 0, ScrH() * 0.03)
        perkCategoryTitle:Dock(TOP)
        perkCategoryTitle:SetContentAlignment(8)
        perkCategoryTitle:SetFont("EGMText15")
        perkCategoryTitle:SetTextColor(UI.ForegroundColor)
        perkCategoryTitle:SetText(data.name)
        perkCategoryTitle:SizeToContents()

        local perkValue = perks[perk] or 0
        for i = 1, perkValue + 2 do
            local perkData = data.values[i]
            if not perkData then break end

            local w, h = perkScrollPanel:GetWide(), ScrH() * 0.1

            local perkPanel = vgui.Create("DPanel", perkScrollPanel)
            perkPanel:SetSize(w, h)
            perkPanel:Dock(TOP)
            function perkPanel:Paint()
            end

            local perkButton = vgui.Create("DButton", perkPanel)
            perkButton:SetPos(w * 0.1, h * 0.05)
            perkButton:SetSize(h * 0.9, h * 0.9)
            function perkButton:Paint()
            end
            function perkButton:DoClick()
                net.Start("Experience.AddPerk")
                    net.WriteString(perk)
                net.SendToServer()

                pointsAvailable = pointsAvailable - 1
            end
            function perkButton:Think()
                if pointsAvailable > 0 and i == perkValue + 1 then
                    self:SetEnabled(true)
                else
                    self:SetEnabled(false)
                end
            end

            local perkTitle = vgui.Create("DLabel", perkPanel)
            perkTitle:SetPos(w * 0.35, h * 0.1)
            perkTitle:SetTextColor(Color(127, 0, 0))
            perkTitle:SetFont("EGMText12")
            function perkTitle:Think()
                if i <= perkValue + 1 then
                    self:SetText(perkData.name)
                else
                    self:SetText(egmt("experience.unknown"))
                end

                self:SizeToContents()
            end

            local perkDescription = vgui.Create("DLabel", perkPanel)
            perkDescription:SetPos(w * 0.35, h * 0.45)
            perkDescription:SetFont("EGMText8")
            perkDescription:SetTextColor(UI.TextColor)
            function perkDescription:Think()
                if i <= perkValue + 1 then
                    self:SetText(perkData.description)
                else
                    self:SetText(egmt("experience.unknown"))
                end

                self:SizeToContents()
            end

            local perkImage = vgui.Create("DImage", perkButton)
            perkImage:Dock(FILL)
            function perkImage:Think()
                if i <= perkValue + 1 then
                    if i == perkValue then
                        self:SetImage(data.imageCurrent)
                    else
                        self:SetImage(data.image)
                    end
                else
                    self:SetImage(Experience.UnknownPerkImage)
                end
            end
        end

        self.PerkScroller:AddPanel(perkScrollPanel)
    end

    self.PerkResetButton = vgui.Create("EGMButton", self.PerkMenu)
    self.PerkResetButton:SetPos(ScrW() * 0.775, ScrH() * 0.875)
    self.PerkResetButton:SetSize(ScrW() * 0.1, ScrH() * 0.05)
    self.PerkResetButton:SetFont("EGMText8")
    self.PerkResetButton:SetTextColor(UI.TextColor)
    self.PerkResetButton:SetText(egmt("experience.reset"))
    self.PerkResetButton:SetButtonCornerRadius(5)
    function self.PerkResetButton:DoClick()
        surface.PlaySound(UI.ButtonSound)

        net.Start("Character.ResetPerks")
        net.SendToServer()
    end

    self.PerkMenu:MakePopup()
end

-- Inform about new perks and reopen the menu when the perks property was changed.
hook.Add("Character.PropertyChanged", "Experience.PerkAdded", function(character, key, value)
    if key == "perks" and character:BelongsTo(LocalPlayer()) and IsValid(Experience.PerkMenu) then
        -- Reopen the menu if open to refresh the perk display.
        local offsetX = Experience.PerkScroller.OffsetX -- Save scroll offset.
        Experience:OpenPerkMenu()

        -- Apply olf scroll offset.
        Experience.PerkScroller.OffsetX = offsetX
        Experience.PerkScroller:InvalidateLayout(true)
    end
end)

-- Closes the perk menu.
function Experience:ClosePerkMenu()
    if IsValid(self.PerkMenu) then
        self.PerkMenu:Close()
    end
end

-- Inform about new skillpoints.
hook.Add("Character.PropertyChanged", "Character.NewSkillPoint", function(character, key, value)
    if key == "level" and character:BelongsTo(LocalPlayer()) and value % Experience.LevelPerSkillPoint == 0 then
        Notify:Success(egmt("experience.new_skill"), egmt("experience.new_skill_description"))
    end
end)
--gamemodes/egmrp/gamemode/modules/inventory_container/item_slots/container/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Client | Container Item Slot   --
---------------------------------------

local ITEM_SLOT = ITEM_SLOT

-- Name of the item slot displayed in the inventory.
ITEM_SLOT.Name = egmt("inventory.container_slot")

-- Number of rows, the items should be displayed in.
ITEM_SLOT.Rows = 4
--gamemodes/starwarsrp/gamemode/modules/soundboard/sh_config.lua:
--------------------------------
--       Einfach-Gaming       --
--        Soundboard          --
--                            --
--     Created by Deltaa      --
--------------------------------

--------------------------------
--		  SH | Config		  --
--------------------------------

Soundboard.Config.Cooldown = 5

Soundboard.Config.Sounds = {
	-- Wookie Warriors
	["Wookie 1"] = {
		soundpath = "cwrp/nextbot/wookie/wookie1.wav",
		models = {
			["models/player/chewie.mdl"] = true,
			["models/player/strasser/wookie_warrior/wookie_warrior.mdl"] = true,
		},
	},

	["Wookie 2"] = {
		soundpath = "cwrp/nextbot/wookie/wookie2.wav",
		models = {
			["models/player/chewie.mdl"] = true,
			["models/player/strasser/wookie_warrior/wookie_warrior.mdl"] = true,
		},
	},

	["Wookie 3"] = {
		soundpath = "cwrp/nextbot/wookie/wookie3.wav",
		models = {
			["models/player/chewie.mdl"] = true,
			["models/player/strasser/wookie_warrior/wookie_warrior.mdl"] = true,
		},
	},

	["Wookie 4"] = {
		soundpath = "cwrp/nextbot/wookie/wookie4.wav",
		models = {
			["models/player/chewie.mdl"] = true,
			["models/player/strasser/wookie_warrior/wookie_warrior.mdl"] = true,
		},
	},

	["Wookie 5"] = {
		soundpath = "cwrp/nextbot/wookie/wookie5.wav",
		models = {
			["models/player/chewie.mdl"] = true,
			["models/player/strasser/wookie_warrior/wookie_warrior.mdl"] = true,
		},
	},

	-- Astromech Droids
	["Astromech 1"] = {
		soundpath = "cwrp/nextbot/astromech/astro1.wav",
		models = {
			["models/KingPommes/starwars/playermodels/astromech.mdl"] = true,
			["models/ace/sw/r2.mdl"] = true,
			["models/ace/sw/r4.mdl"] = true,
			["models/ace/sw/r5.mdl"] = true,
			["models/player/t3_01.mdl"] = true,
			["models/player/t3_02.mdl"] = true,
			["models/player/t3_03.mdl"] = true,
			["models/player/t3_04.mdl"] = true,
		},
	},

	["Astromech 2"] = {
		soundpath = "cwrp/nextbot/astromech/astro2.wav",
		models = {
			["models/KingPommes/starwars/playermodels/astromech.mdl"] = true,
			["models/ace/sw/r2.mdl"] = true,
			["models/ace/sw/r4.mdl"] = true,
			["models/ace/sw/r5.mdl"] = true,
			["models/player/t3_01.mdl"] = true,
			["models/player/t3_02.mdl"] = true,
			["models/player/t3_03.mdl"] = true,
			["models/player/t3_04.mdl"] = true,
		},
	},

	["Astromech 3"] = {
		soundpath = "cwrp/nextbot/astromech/astro3.wav",
		models = {
			["models/KingPommes/starwars/playermodels/astromech.mdl"] = true,
			["models/ace/sw/r2.mdl"] = true,
			["models/ace/sw/r4.mdl"] = true,
			["models/ace/sw/r5.mdl"] = true,
			["models/player/t3_01.mdl"] = true,
			["models/player/t3_02.mdl"] = true,
			["models/player/t3_03.mdl"] = true,
			["models/player/t3_04.mdl"] = true,
		},
	},

	["Astromech 4"] = {
		soundpath = "cwrp/nextbot/astromech/astro4.wav",
		models = {
			["models/KingPommes/starwars/playermodels/astromech.mdl"] = true,
			["models/ace/sw/r2.mdl"] = true,
			["models/ace/sw/r4.mdl"] = true,
			["models/ace/sw/r5.mdl"] = true,
			["models/player/t3_01.mdl"] = true,
			["models/player/t3_02.mdl"] = true,
			["models/player/t3_03.mdl"] = true,
			["models/player/t3_04.mdl"] = true,
		},
	},

	["Astromech 5"] = {
		soundpath = "cwrp/nextbot/astromech/astro5.wav",
		models = {
			["models/KingPommes/starwars/playermodels/astromech.mdl"] = true,
			["models/ace/sw/r2.mdl"] = true,
			["models/ace/sw/r4.mdl"] = true,
			["models/ace/sw/r5.mdl"] = true,
			["models/player/t3_01.mdl"] = true,
			["models/player/t3_02.mdl"] = true,
			["models/player/t3_03.mdl"] = true,
			["models/player/t3_04.mdl"] = true,
		},
	},

	["Astromech 6"] = {
		soundpath = "cwrp/nextbot/astromech/astro6.wav",
		models = {
			["models/KingPommes/starwars/playermodels/astromech.mdl"] = true,
			["models/ace/sw/r2.mdl"] = true,
			["models/ace/sw/r4.mdl"] = true,
			["models/ace/sw/r5.mdl"] = true,
			["models/player/t3_01.mdl"] = true,
			["models/player/t3_02.mdl"] = true,
			["models/player/t3_03.mdl"] = true,
			["models/player/t3_04.mdl"] = true,
		},
	},

	["Astromech 7"] = {
		soundpath = "cwrp/nextbot/astromech/astro7.wav",
		models = {
			["models/KingPommes/starwars/playermodels/astromech.mdl"] = true,
			["models/ace/sw/r2.mdl"] = true,
			["models/ace/sw/r4.mdl"] = true,
			["models/ace/sw/r5.mdl"] = true,
			["models/player/t3_01.mdl"] = true,
			["models/player/t3_02.mdl"] = true,
			["models/player/t3_03.mdl"] = true,
			["models/player/t3_04.mdl"] = true,
		},
	},

	-- B1 Droiden Sounds
	["Auslöschen!"] = {
		soundpath = "cwrp/nextbot/b1/attack/ausloeschen.wav",
		models = {
			["models/player/b1battledroids/b1_base_aatdriver.mdl"] = true,
			["models/player/b1battledroids/b1_base.mdl"] = true,
			["models/player/b1battledroids/b1_base_com.mdl"] = true,
			["models/player/b1battledroids/b1_base_com.mdl"] = true,
			["models/player/b1battledroids/b1_geo.mdl"] = true,
			["models/player/b1battledroids/b1_geo_com.mdl"] = true,
			["models/player/b1battledroids/b1_base_pilot.mdl"] = true,
			["models/player/b1battledroids/b1_rocket.mdl"] = true,
			["models/player/b1battledroids/b1_base_security.mdl"] = true,
			["models/player/b1battledroids/b1_base_training.mdl"] = true,
		},
	},

	["Scanne das Ziel!"] = {
		soundpath = "cwrp/nextbot/b1/attack/scanne-das-ziel.wav",
		models = {
			["models/player/b1battledroids/b1_base_aatdriver.mdl"] = true,
			["models/player/b1battledroids/b1_base.mdl"] = true,
			["models/player/b1battledroids/b1_base_com.mdl"] = true,
			["models/player/b1battledroids/b1_base_com.mdl"] = true,
			["models/player/b1battledroids/b1_geo.mdl"] = true,
			["models/player/b1battledroids/b1_geo_com.mdl"] = true,
			["models/player/b1battledroids/b1_base_pilot.mdl"] = true,
			["models/player/b1battledroids/b1_rocket.mdl"] = true,
			["models/player/b1battledroids/b1_base_security.mdl"] = true,
			["models/player/b1battledroids/b1_base_training.mdl"] = true,
		},
	},

	["Scanne Feindeinheit!"] = {
		soundpath = "cwrp/nextbot/b1/attack/scanne-feindeinheit.wav",
		models = {
			["models/player/b1battledroids/b1_base_aatdriver.mdl"] = true,
			["models/player/b1battledroids/b1_base.mdl"] = true,
			["models/player/b1battledroids/b1_base_com.mdl"] = true,
			["models/player/b1battledroids/b1_base_com.mdl"] = true,
			["models/player/b1battledroids/b1_geo.mdl"] = true,
			["models/player/b1battledroids/b1_geo_com.mdl"] = true,
			["models/player/b1battledroids/b1_base_pilot.mdl"] = true,
			["models/player/b1battledroids/b1_rocket.mdl"] = true,
			["models/player/b1battledroids/b1_base_security.mdl"] = true,
			["models/player/b1battledroids/b1_base_training.mdl"] = true,
		},
	},

	["Siegt!"] = {
		soundpath = "cwrp/nextbot/b1/attack/siegt.wav",
		models = {
			["models/player/b1battledroids/b1_base_aatdriver.mdl"] = true,
			["models/player/b1battledroids/b1_base.mdl"] = true,
			["models/player/b1battledroids/b1_base_com.mdl"] = true,
			["models/player/b1battledroids/b1_base_com.mdl"] = true,
			["models/player/b1battledroids/b1_geo.mdl"] = true,
			["models/player/b1battledroids/b1_geo_com.mdl"] = true,
			["models/player/b1battledroids/b1_base_pilot.mdl"] = true,
			["models/player/b1battledroids/b1_rocket.mdl"] = true,
			["models/player/b1battledroids/b1_base_security.mdl"] = true,
			["models/player/b1battledroids/b1_base_training.mdl"] = true,
		},
	},

	["Ziel erfasst!"] = {
		soundpath = "cwrp/nextbot/b1/attack/ziel-erfasst.wav",
		models = {
			["models/player/b1battledroids/b1_base_aatdriver.mdl"] = true,
			["models/player/b1battledroids/b1_base.mdl"] = true,
			["models/player/b1battledroids/b1_base_com.mdl"] = true,
			["models/player/b1battledroids/b1_base_com.mdl"] = true,
			["models/player/b1battledroids/b1_geo.mdl"] = true,
			["models/player/b1battledroids/b1_geo_com.mdl"] = true,
			["models/player/b1battledroids/b1_base_pilot.mdl"] = true,
			["models/player/b1battledroids/b1_rocket.mdl"] = true,
			["models/player/b1battledroids/b1_base_security.mdl"] = true,
			["models/player/b1battledroids/b1_base_training.mdl"] = true,
		},
	},

	["Roger-Roger!"] = {
		soundpath = "cwrp/nextbot/b1/attack/roger-roger.wav",
		models = {
			["models/player/b1battledroids/b1_base_aatdriver.mdl"] = true,
			["models/player/b1battledroids/b1_base.mdl"] = true,
			["models/player/b1battledroids/b1_base_com.mdl"] = true,
			["models/player/b1battledroids/b1_base_com.mdl"] = true,
			["models/player/b1battledroids/b1_geo.mdl"] = true,
			["models/player/b1battledroids/b1_geo_com.mdl"] = true,
			["models/player/b1battledroids/b1_base_pilot.mdl"] = true,
			["models/player/b1battledroids/b1_rocket.mdl"] = true,
			["models/player/b1battledroids/b1_firefighter.mdl"] = true,
			["models/player/b1battledroids/b1_base_security.mdl"] = true,
			["models/player/b1battledroids/b1_base_training.mdl"] = true,
		},
	},

	["Yeah!"] = {
		soundpath = "cwrp/nextbot/b1/kill/yeah.wav",
		models = {
			["models/player/b1battledroids/b1_base_aatdriver.mdl"] = true,
			["models/player/b1battledroids/b1_base.mdl"] = true,
			["models/player/b1battledroids/b1_base_com.mdl"] = true,
			["models/player/b1battledroids/b1_base_com.mdl"] = true,
			["models/player/b1battledroids/b1_geo.mdl"] = true,
			["models/player/b1battledroids/b1_geo_com.mdl"] = true,
			["models/player/b1battledroids/b1_base_pilot.mdl"] = true,
			["models/player/b1battledroids/b1_rocket.mdl"] = true,
			["models/player/b1battledroids/b1_firefighter.mdl"] = true,
			["models/player/b1battledroids/b1_base_security.mdl"] = true,
			["models/player/b1battledroids/b1_base_training.mdl"] = true,
		},
	},

	["Nimm das!"] = {
		soundpath = "cwrp/nextbot/b1/kill/nimm-das.wav",
		models = {
			["models/player/b1battledroids/b1_base_aatdriver.mdl"] = true,
			["models/player/b1battledroids/b1_base.mdl"] = true,
			["models/player/b1battledroids/b1_base_com.mdl"] = true,
			["models/player/b1battledroids/b1_base_com.mdl"] = true,
			["models/player/b1battledroids/b1_geo.mdl"] = true,
			["models/player/b1battledroids/b1_geo_com.mdl"] = true,
			["models/player/b1battledroids/b1_base_pilot.mdl"] = true,
			["models/player/b1battledroids/b1_rocket.mdl"] = true,
			["models/player/b1battledroids/b1_base_security.mdl"] = true,
			["models/player/b1battledroids/b1_base_training.mdl"] = true,
		},
	},

	["Schrei"] = {
		soundpath = "cwrp/nextbot/b1/killed/cry3.wav",
		models = {
			["models/player/b1battledroids/b1_base_aatdriver.mdl"] = true,
			["models/player/b1battledroids/b1_base.mdl"] = true,
			["models/player/b1battledroids/b1_base_com.mdl"] = true,
			["models/player/b1battledroids/b1_base_com.mdl"] = true,
			["models/player/b1battledroids/b1_geo.mdl"] = true,
			["models/player/b1battledroids/b1_geo_com.mdl"] = true,
			["models/player/b1battledroids/b1_base_pilot.mdl"] = true,
			["models/player/b1battledroids/b1_rocket.mdl"] = true,
			["models/player/b1battledroids/b1_firefighter.mdl"] = true,
			["models/player/b1battledroids/b1_base_security.mdl"] = true,
			["models/player/b1battledroids/b1_base_training.mdl"] = true,
		},
	},

	-- BX Droide
	["Ausradieren!"] = {
		soundpath = "cwrp/nextbot/bx/attack/ausradieren.wav",
		models = {
			["models/sally/tkaro/bx_commando_droid.mdl"] = true,
		},
	},

	["Voraus!"] = {
		soundpath = "cwrp/nextbot/bx/attack/ich-gehe-voraus.wav",
		models = {
			["models/sally/tkaro/bx_commando_droid.mdl"] = true,
		},
	},

	["Tötet die Klone!"] = {
		soundpath = "cwrp/nextbot/bx/attack/toetet-die-klone.wav",
		models = {
			["models/sally/tkaro/bx_commando_droid.mdl"] = true,
		},
	},

	["Problem gelöst!"] = {
		soundpath = "cwrp/nextbot/bx/kill/problem-geloest.wav",
		models = {
			["models/sally/tkaro/bx_commando_droid.mdl"] = true,
		},
	},

	-- B2
	["Nimm das!"] = {
		soundpath = "cwrp/nextbot/b2/kill/nimm-das.wav",
		models = {
			["models/player/hydro/b2_battledroid/b2_battledroid.mdl"] = true,
		},
	},

	["Problem gelöst!"] = {
		soundpath = "cwrp/nextbot/b2/kill/problem-geloest.wav",
		models = {
			["models/player/hydro/b2_battledroid/b2_battledroid.mdl"] = true,
		},
	},

	-- Yoda
	["Größe"] = {
		soundpath = "cwrp/soundboard/yoda/groesse.wav",
		models = {
			["models/egm/jedi/yoda.mdl"] = true,
		},
	},

	["Kein Leid!"] = {
		soundpath = "cwrp/soundboard/yoda/kein-leid.wav",
		models = {
			["models/egm/jedi/yoda.mdl"] = true,
		},
	},

	["Kein versuchen!"] = {
		soundpath = "cwrp/soundboard/yoda/kein-versuchen.wav",
		models = {
			["models/egm/jedi/yoda.mdl"] = true,
		},
	},

	["Zu schnell?"] = {
		soundpath = "cwrp/soundboard/yoda/schnell.wav",
		models = {
			["models/egm/jedi/yoda.mdl"] = true,
		},
	},

	["Mein Verbündeter!"] = {
		soundpath = "cwrp/soundboard/yoda/verbuendeter.wav",
		models = {
			["models/egm/jedi/yoda.mdl"] = true,
		},
	},

	["*Lachen*"] = {
		soundpath = "cwrp/soundboard/yoda/lachen.wav",
		models = {
			["models/egm/jedi/yoda.mdl"] = true,
		},
	},

	["*Schreien*"] = {
		soundpath = "cwrp/soundboard/yoda/schrei.wav",
		models = {
			["models/egm/jedi/yoda.mdl"] = true,
		},
	},

	-- Obi-Wan Kenobi
	["Kein Anakin!"] = {
		soundpath = "cwrp/soundboard/obi-wan/anakin.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Schlechter Killer!"] = {
		soundpath = "cwrp/soundboard/obi-wan/bad-killer.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Bereits besiegt"] = {
		soundpath = "cwrp/soundboard/obi-wan/bereits-besiegt.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Davonlaufen"] = {
		soundpath = "cwrp/soundboard/obi-wan/davonlaufen.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Ergebt euch!"] = {
		soundpath = "cwrp/soundboard/obi-wan/ergebt-euch.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Extreme"] = {
		soundpath = "cwrp/soundboard/obi-wan/extreme.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Kopf abschlagen"] = {
		soundpath = "cwrp/soundboard/obi-wan/hals.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Hello there."] = {
		soundpath = "cwrp/soundboard/obi-wan/hello-there.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Kein Entkommen"] = {
		soundpath = "cwrp/soundboard/obi-wan/kein-entkommen.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Kodex"] = {
		soundpath = "cwrp/soundboard/obi-wan/kodex.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Kopfschmerzen..."] = {
		soundpath = "cwrp/soundboard/obi-wan/kopfschmerzen.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Die Macht"] = {
		soundpath = "cwrp/soundboard/obi-wan/macht.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Mieses Gefühl"] = {
		soundpath = "cwrp/soundboard/obi-wan/mieses-gefuehl.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Prahlerischer Roboter"] = {
		soundpath = "cwrp/soundboard/obi-wan/prahlerische-roboter.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Realität mit 4 Armen"] = {
		soundpath = "cwrp/soundboard/obi-wan/realitaet.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Rücken kehren"] = {
		soundpath = "cwrp/soundboard/obi-wan/ruecken-kehren.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Sonniges Gemüt"] = {
		soundpath = "cwrp/soundboard/obi-wan/sonniges-gemuet.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Spezialität"] = {
		soundpath = "cwrp/soundboard/obi-wan/spezialitaet.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Sternen sei Dank"] = {
		soundpath = "cwrp/soundboard/obi-wan/sterne.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	["Verräter"] = {
		soundpath = "cwrp/soundboard/obi-wan/verraeter.wav",
		models = {
			["models/kaiido/obi_wan.mdl"] = true,
			["models/kaiido/gnl/jedi_general_male_01.mdl"] = true,
		},
	},

	-- Anakin Skywalker
	["Spaß anfangen!"] = {
		soundpath = "cwrp/soundboard/anakin/anfangen.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Diplomatische Lösung"] = {
		soundpath = "cwrp/soundboard/anakin/diplomatische-loesung.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Dooku!"] = {
		soundpath = "cwrp/soundboard/anakin/dooku.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Einfach"] = {
		soundpath = "cwrp/soundboard/anakin/einfach.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Eingebrockt"] = {
		soundpath = "cwrp/soundboard/anakin/eingebrockt.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Ergebt euch!"] = {
		soundpath = "cwrp/soundboard/anakin/ergeben.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Flucht-General"] = {
		soundpath = "cwrp/soundboard/anakin/general-flucht.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Gewarnt!"] = {
		soundpath = "cwrp/soundboard/anakin/gewarnt.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Grievous!"] = {
		soundpath = "cwrp/soundboard/anakin/grievous.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Hallo, General!"] = {
		soundpath = "cwrp/soundboard/anakin/hallo-general.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Nicht herausfordern!"] = {
		soundpath = "cwrp/soundboard/anakin/herausfordern.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Kein Zufall"] = {
		soundpath = "cwrp/soundboard/anakin/kein-zufall.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Verdoppelte Kräfte"] = {
		soundpath = "cwrp/soundboard/anakin/kraefte-verdoppelt.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Langsamer Grievous"] = {
		soundpath = "cwrp/soundboard/anakin/langsam-general.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Mieses Gefühl"] = {
		soundpath = "cwrp/soundboard/anakin/mieses-gefuehl.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Obi der Killer"] = {
		soundpath = "cwrp/soundboard/anakin/obiwan-killer.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Problem"] = {
		soundpath = "cwrp/soundboard/anakin/problem.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Schlimmer als Padawan?"] = {
		soundpath = "cwrp/soundboard/anakin/schlimmer-padawan.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Darth Tyrannus"] = {
		soundpath = "cwrp/soundboard/anakin/tyrannus.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Vergeltung für Jedi"] = {
		soundpath = "cwrp/soundboard/anakin/vergeltung.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Kein Versteck?"] = {
		soundpath = "cwrp/soundboard/anakin/versteck.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	["Wütend!"] = {
		soundpath = "cwrp/soundboard/anakin/wuetend.wav",
		models = {
			["models/cyanblue/sw/anakin/anakin.mdl"] = true,
			["models/kaiido/anakin/anakin.mdl"] = true
		},
	},

	-- Maul
	["Ich spüre Angst"] = {
		soundpath = "cwrp/soundboard/maul/angst.wav",
		models = {
			["models/player/darth/maul.mdl"] = true,
		},
	},

	["Erstickt!"] = {
		soundpath = "cwrp/soundboard/maul/erstickt.wav",
		models = {
			["models/player/darth/maul.mdl"] = true,
		},
	},

	["Flieht doch..."] = {
		soundpath = "cwrp/soundboard/maul/flieht.wav",
		models = {
			["models/player/darth/maul.mdl"] = true,
		},
	},

	["Hilflos"] = {
		soundpath = "cwrp/soundboard/maul/hilflos.wav",
		models = {
			["models/player/darth/maul.mdl"] = true,
		},
	},

	["Kein Gegner!"] = {
		soundpath = "cwrp/soundboard/maul/kein-gegner.wav",
		models = {
			["models/player/darth/maul.mdl"] = true,
		},
	},

	["Kenobiiiii"] = {
		soundpath = "cwrp/soundboard/maul/kenobi.wav",
		models = {
			["models/player/darth/maul.mdl"] = true,
		},
	},

	["Nehmt euch in Acht"] = {
		soundpath = "cwrp/soundboard/maul/nehmt-euch-in-acht.wav",
		models = {
			["models/player/darth/maul.mdl"] = true,
		},
	},

	["Ihr seid nichts"] = {
		soundpath = "cwrp/soundboard/maul/nichts.wav",
		models = {
			["models/player/darth/maul.mdl"] = true,
		},
	},

	["Immer überleben"] = {
		soundpath = "cwrp/soundboard/maul/ueberleben.wav",
		models = {
			["models/player/darth/maul.mdl"] = true,
		},
	},

	-- Grievous
	["Vorhergesagt!"] = {
		soundpath = "cwrp/soundboard/grievous/dooku-hats-vorhergesagt.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	["Du bist dran!"] = {
		soundpath = "cwrp/soundboard/grievous/du-bist-dran.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	["Du verlierst!"] = {
		soundpath = "cwrp/soundboard/grievous/du-verlierst.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	["Ergieb dich!"] = {
		soundpath = "cwrp/soundboard/grievous/ergieb-dich.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	["Euer Ende!"] = {
		soundpath = "cwrp/soundboard/grievous/euer-ende.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	["Greif an, Kenobi!"] = {
		soundpath = "cwrp/soundboard/grievous/greift-an-kenobi.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	["Jedi Abschaum!"] = {
		soundpath = "cwrp/soundboard/grievous/jedi-abschaum.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	["Kenobi!"] = {
		soundpath = "cwrp/soundboard/grievous/kenobi.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	["Kommt her!"] = {
		soundpath = "cwrp/soundboard/grievous/kommt-her.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	["Lauft weg!"] = {
		soundpath = "cwrp/soundboard/grievous/lauft-weg.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	["Musik"] = {
		soundpath = "cwrp/soundboard/grievous/musik.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	["Richtig mutig!"] = {
		soundpath = "cwrp/soundboard/grievous/mutig.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	["Suchst du mich?"] = {
		soundpath = "cwrp/soundboard/grievous/suchst-du-mich.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	["Überraschung!"] = {
		soundpath = "cwrp/soundboard/grievous/ueberraschung.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	["So unverschämt!"] = {
		soundpath = "cwrp/soundboard/grievous/unverschaemtheiten.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	["Versteck dich!"] = {
		soundpath = "cwrp/soundboard/grievous/verstecken.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	["Wähle Lichtschwert"] = {
		soundpath = "cwrp/soundboard/grievous/welches-lichtschwert.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	["Willkommen, Feind!"] = {
		soundpath = "cwrp/soundboard/grievous/willkommen-feind.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	["Zermalmt sie!"] = {
		soundpath = "cwrp/soundboard/grievous/zermalmt-sie.wav",
		models = {
			["models/aussisengels/grievous/general_grievous.mdl"] = true,
		},
	},

	-- Dooku
	["Du wagst es?"] = {
		soundpath = "cwrp/soundboard/dooku/du-wagst-es.wav",
		models = {
			["models/sirris_sw/dooku_pm.mdl"] = true,
		},
	},

	["Enorme Macht"] = {
		soundpath = "cwrp/soundboard/dooku/enorme-macht.wav",
		models = {
			["models/sirris_sw/dooku_pm.mdl"] = true,
		},
	},

	["Enttäuschend..."] = {
		soundpath = "cwrp/soundboard/dooku/enttaueschend.wav",
		models = {
			["models/sirris_sw/dooku_pm.mdl"] = true,
		},
	},

	["Ergebt euch!"] = {
		soundpath = "cwrp/soundboard/dooku/ergebt-euch.wav",
		models = {
			["models/sirris_sw/dooku_pm.mdl"] = true,
		},
	},

	["Ich freue mich"] = {
		soundpath = "cwrp/soundboard/dooku/freue-mich-lange.wav",
		models = {
			["models/sirris_sw/dooku_pm.mdl"] = true,
		},
	},

	["Du hast Hass"] = {
		soundpath = "cwrp/soundboard/dooku/hass-wut.wav",
		models = {
			["models/sirris_sw/dooku_pm.mdl"] = true,
		},
	},

	["Hochmut"] = {
		soundpath = "cwrp/soundboard/dooku/hochmut.wav",
		models = {
			["models/sirris_sw/dooku_pm.mdl"] = true,
		},
	},

	["Jedi sind egoistisch"] = {
		soundpath = "cwrp/soundboard/dooku/jedi-egoistisch.wav",
		models = {
			["models/sirris_sw/dooku_pm.mdl"] = true,
		},
	},

	["Kenobi, enttäuschend."] = {
		soundpath = "cwrp/soundboard/dooku/kenobi.wav",
		models = {
			["models/sirris_sw/dooku_pm.mdl"] = true,
		},
	},

	["Eine Lektion"] = {
		soundpath = "cwrp/soundboard/dooku/lektion.wav",
		models = {
			["models/sirris_sw/dooku_pm.mdl"] = true,
		},
	},

	["Mächtiger als jeder Jedi"] = {
		soundpath = "cwrp/soundboard/dooku/maechtiger-als-jedi.wav",
		models = {
			["models/sirris_sw/dooku_pm.mdl"] = true,
		},
	},

	["Nie besiegt"] = {
		soundpath = "cwrp/soundboard/dooku/nie-besiegt.wav",
		models = {
			["models/sirris_sw/dooku_pm.mdl"] = true,
		},
	},

	["Qui-Gon vertaute mir"] = {
		soundpath = "cwrp/soundboard/dooku/qui-gon.wav",
		models = {
			["models/sirris_sw/dooku_pm.mdl"] = true,
		},
	},

	["Sehr tapfer..."] = {
		soundpath = "cwrp/soundboard/dooku/sehr-tapfer.wav",
		models = {
			["models/sirris_sw/dooku_pm.mdl"] = true,
		},
	},

	["Endlich, Skywalker!"] = {
		soundpath = "cwrp/soundboard/dooku/skywalker.wav",
		models = {
			["models/sirris_sw/dooku_pm.mdl"] = true,
		},
	},

	["Überheblichkeit"] = {
		soundpath = "cwrp/soundboard/dooku/ueberheblichkeit.wav",
		models = {
			["models/sirris_sw/dooku_pm.mdl"] = true,
		},
	},

	["Du übernimmst dich"] = {
		soundpath = "cwrp/soundboard/dooku/uebernehmen.wav",
		models = {
			["models/sirris_sw/dooku_pm.mdl"] = true,
		},
	},

	-- Dengar
	["Abschaum!"] = {
		soundpath = "cwrp/soundboard/dengar/abschaum.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Als nächstes dein Schädel!"] = {
		soundpath = "cwrp/soundboard/dengar/schaedel.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Bringen wir es hinter uns!"] = {
		soundpath = "cwrp/soundboard/dengar/hinteruns.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Kopfschmerzen"] = {
		soundpath = "cwrp/soundboard/dengar/kopfschmerzen.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Ganz ruhig..."] = {
		soundpath = "cwrp/soundboard/dengar/kumpel.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Ich liebe es!"] = {
		soundpath = "cwrp/soundboard/dengar/liebe.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Weh getan"] = {
		soundpath = "cwrp/soundboard/dengar/weh.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Plattmachen"] = {
		soundpath = "cwrp/soundboard/dengar/plattmachen.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Credits"] = {
		soundpath = "cwrp/soundboard/dengar/credits.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Ärger"] = {
		soundpath = "cwrp/soundboard/dengar/aerger.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Letztes Stündlein"] = {
		soundpath = "cwrp/soundboard/dengar/stuendlein.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Kinderspiel"] = {
		soundpath = "cwrp/soundboard/dengar/kinderspiel.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Knochen gebrochen"] = {
		soundpath = "cwrp/soundboard/dengar/knochen.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Party"] = {
		soundpath = "cwrp/soundboard/dengar/party.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Schmerz"] = {
		soundpath = "cwrp/soundboard/dengar/schmerz.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Prächtiges Paar"] = {
		soundpath = "cwrp/soundboard/dengar/paar.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Angst"] = {
		soundpath = "cwrp/soundboard/dengar/angst.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Unfassbar..."] = {
		soundpath = "cwrp/soundboard/dengar/unfassbar.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Zur Ruhe setzen"] = {
		soundpath = "cwrp/soundboard/dengar/ruhe.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	["Ärger hab ich schon"] = {
		soundpath = "cwrp/soundboard/dengar/habichschon.wav",
		models = {
			["models/player/hydro/swbf_dengar/swbf_dengar.mdl"] = true,
		},
	},

	----Jawa
	["Hey!"] = {
		soundpath = "cwrp/soundboard/jawa/hey.wav",
		models = {
			["models/egm/event/jawa.mdl"] = true,
		},
	},
	["Jubeln"] = {
		soundpath = "cwrp/soundboard/jawa/jubeln.wav",
		models = {
			["models/egm/event/jawa.mdl"] = true,
		},
	},

	["Kreischen"] = {
		soundpath = "cwrp/soundboard/jawa/kreischen.wav",
		models = {
			["models/egm/event/jawa.mdl"] = true,
		},
	},

	["Reden"] = {
		soundpath = "cwrp/soundboard/jawa/reden.wav",
		models = {
			["models/egm/event/jawa.mdl"] = true,
		},
	},

	["Sauer 1"] = {
		soundpath = "cwrp/soundboard/jawa/sauer_1.wav",
		models = {
			["models/egm/event/jawa.mdl"] = true,
		},
	},
	["Sauer 2"] = {
		soundpath = "cwrp/soundboard/jawa/sauer_2.wav",
		models = {
			["models/egm/event/jawa.mdl"] = true,
		},
	},

	["Utini"] = {
		soundpath = "cwrp/soundboard/jawa/utini.wav",
		models = {
			["models/egm/event/jawa.mdl"] = true,
		},
	},
}
--gamemodes/starwarsrp/gamemode/modules/fcmenu/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           FCMenu index            --
---------------------------------------

if not RequireModules({"keybinds"}) then
	return false
end

FCMenu = FCMenu or {}
FCMenu.Config = FCMenu.Config or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_fcmenu.lua")
	AddCSLuaFile("cl_fcmenu.lua")

	include("sh_config.lua")
	include("sh_fcmenu.lua")
	include("sv_fcmenu.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_fcmenu.lua")
	include("cl_fcmenu.lua")
end
--gamemodes/egmrp/gamemode/modules/spawnpoints/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Spawnpoints index         --
---------------------------------------

Spawnpoints = Spawnpoints or {}

if SERVER then
    include("sh_config.lua")
    include("sh_spawnpoints.lua")
    include("sv_spawnpoints.lua")

    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("sh_spawnpoints.lua")
    AddCSLuaFile("cl_spawnpoints.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("sh_spawnpoints.lua")
    include("cl_spawnpoints.lua")
end
--gamemodes/egmrp/gamemode/modules/spawnpoints/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Config | Spawnpoints       --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Minimum Usergroup that is required to change spawnpoints.
Spawnpoints.MinAccessGroup = "operator"
--gamemodes/egmrp/gamemode/modules/spawnpoints/sh_spawnpoints.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Spawnpoints       --
---------------------------------------

-- Checks whether a player is allowed to edit the spawnpoints.
--
-- @param Player ply
-- @return Boolean canEdit
function Spawnpoints:CanPlayerEdit(ply)
	if hook.Run("Spawnpoints.CanPlayerEdit", ply) then
		return true
	end

	if ply:IsAtLeast(Spawnpoints.MinAccessGroup) then
		return true
	end

	return false
end
--gamemodes/starwarsrp/gamemode/modules/helmet/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Index | Helmet          --
---------------------------------------

if not RequireModules({"base_model"}) then
	return false
end

Helmet = Helmet or {}

if SERVER then
	AddCSLuaFile("sh_helmet.lua")
	AddCSLuaFile("cl_helmet.lua")

	include("sh_helmet.lua")
	include("sv_helmet.lua")
end

if CLIENT then
	include("sh_helmet.lua")
	include("cl_helmet.lua")
end
--gamemodes/starwarsrp/gamemode/modules/charban/sh_index.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Character Ban           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Character Ban | SH Index     --
---------------------------------------

if not RequireModules({"chat", "medicsystem"}) then
	return false
end

if SERVER then
	AddCSLuaFile("sh_charban.lua")
	AddCSLuaFile("cl_charban.lua")

	include("sh_charban.lua")
	include("sv_charban.lua")
end

if CLIENT then
	include("sh_charban.lua")
	include("cl_charban.lua")
end
--gamemodes/starwarsrp/gamemode/modules/charban/sh_charban.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--           Character Ban           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--        Character Ban | SH         --
---------------------------------------

-- Adds a character property for the unban time.
Character:AddProperty("charban", "number", 0, function(character, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(character, ply)
	return true
end)

-- Adds a faction property for an death cooldown
Faction:AddProperty("charban", "number", 0, function(faction, value)
	if not isnumber(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(faction, ply)
	return true
end)

-- Check if the character is banned
hook.Add("Character.IsPlayable", "Character.CheckBan", function(character)
	if character:GetProperty("charban") then
		local unbanTime = character:GetProperty("charban", 0)

		if unbanTime > os.time() then
			return false, "Bis zum " .. os.date( "%d/%m/%Y - %H:%M:%S " , unbanTime) .. " gesperrt."
		end
	end
end)

hook.Add("Character.CanPlayerEditProperty.charban", "Character.EditBanPermissions", function(ply, character, value)
	if ply:IsAtLeast(Character.MinAccessGroup) then
		return true
	end
end)
--gamemodes/starwarsrp/gamemode/modules/extendeddonator/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Index | Extended Donator     --
---------------------------------------

if not RequireModules({"donator"}) then
	return false
end

if SERVER then
	AddCSLuaFile("sh_extendeddonator.lua")

	include("sh_extendeddonator.lua")
end

if CLIENT then
	include("sh_extendeddonator.lua")
end
--gamemodes/egmrp/gamemode/modules/donator/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Donator System index        --
---------------------------------------

Donator = Donator or {}

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("sh_donator.lua")
    AddCSLuaFile("cl_donator.lua")

    include("sh_config.lua")
    include("sh_donator.lua")
    include("sv_donator.lua")
    include("sv_eventlog.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("sh_donator.lua")
    include("cl_donator.lua")
end
--gamemodes/egmrp/gamemode/modules/donator/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--  Shared | Donator System Config   --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Name of the default donator rank.
Donator.Name = egmt("donator.donator_name")

-- Minimum rank, to be able to use the donator system.
Donator.MinAccessGroup = "superadmin"
--gamemodes/egmrp/gamemode/modules/ammosystem/sh_config.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        AmmoSystem | Config        --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Background for the menu
AmmoSystem.MenuBackground = "backgrounds/noga_gm.jpg"

-- Model for the Ammo box.
AmmoSystem.Model = "models/Items/ammocrate_smg1.mdl"

-- Configure all Ammo Types you want in the box here. ["weight"] is only usefull if you use ammo weight from realism module but it is required to be a value
AmmoSystem.AmmoTypes = {
    ["rpg_round"] = {["name"] = egmt("ammosystem.explosive_ammo"), ["weight"] = 5, ["limit"] = 150},
    ["ar2"] = {["name"] = egmt("ammosystem.energetic_ammo"), ["weight"] = 0.5, ["limit"] = 1500}
}
--gamemodes/egmrp/gamemode/modules/signs/entities/egmrp_signs/cl_init.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Sign Entity       --
---------------------------------------

include("shared.lua")

ENT.RenderGroup = RENDERGROUP_BOTH

-- Initializes the Clientside data.
function ENT:Initialize()
    self:SetRenderMode(RENDERMODE_TRANSCOLOR)

    self:SetRenderBounds(Vector(-256, -256, -256), Vector(256, 256, 256))
end

-- Draw the sign of the entity.
function ENT:Draw()
    local ply = LocalPlayer()
    local wep = ply:GetActiveWeapon()
    if not IsValid(wep) then return end

    local class = wep:GetClass()
    local preview = false
    if class == "weapon_physgun" or class == "gmod_tool" then
        preview = true

        self:DrawModel()
    end

    local pos = self:GetPos()
    local ang = self:GetUp():AngleEx(self:GetForward())

    local uuid = self:GetNWString("UUID", "")
    local signData = Signs.SignDataCache[uuid]
    if not istable(signData) then return end

    local trace = ply:GetEyeTrace()
    if trace.Entity == self and class == "gmod_tool" and wep:GetMode() == "egmrp_signs" then
        signData = Signs:GetToolData()
        uuid = Signs:HashSignData(signData)
    end

    Signs:RenderSign(pos, ang, preview, uuid, signData)
end

-- Receive the sign data from the server.
net.Receive("Signs.SetData", function()
    local uuid = net.ReadString()
    local data = net.ReadTable()

    Signs.SignDataCache[uuid] = data
end)
--gamemodes/starwarsrp/gamemode/modules/garage/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Index | Garage          --
---------------------------------------

---------------------------------------
--         Special Thanks to         --
--      Fabian 'Mekphen' Zimber      --
---------------------------------------

Garage = Garage or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_garage.lua")
	AddCSLuaFile("cl_garage.lua")

	include("sh_config.lua")
	include("sh_garage.lua")
	include("sv_garage.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_garage.lua")
	include("cl_garage.lua")
end
--gamemodes/starwarsrp/gamemode/modules/garage/cl_garage.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Client | Garage          --
---------------------------------------

---------------------------------------
--         Special Thanks to         --
--      Fabian 'Mekphen' Zimber      --
---------------------------------------

-- Opens the Inventory of the player.
function Garage:OpenMenu(ent)
    self:CloseMenu()

    self.Frame = vgui.Create("EGMFrame")
    self.Frame:SetBackground(self.Background)
    self.Frame:SetSubTitle("Garage")
    function self.Frame:OnClose()
    end

    self.Selection = vgui.Create("DScrollPanel", self.Frame)
    self.Selection:SetPos(ScrW() * 0.1, ScrH() * 0.25)
    self.Selection:SetSize(ScrW() * 0.2, ScrH() * 0.575)
    function self.Selection:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, ColorAlpha(UI.BackgroundColor, 220))
    end

    function self.Selection:Update()
        local ply = LocalPlayer()
        local character = ply:GetCurrentCharacter()
        if not character then return end

        local garage = character:GetProperty("garage", {})

        for id, vehicleData in pairs(garage) do
            local vehicleTable = scripted_ents.GetStored(vehicleData.Class)

            if istable(vehicleTable) and istable(vehicleTable.t) then
            	vehicleTable = vehicleTable.t
            else
				local vehicleList = list.Get("Vehicles")
				local vehicleTable2 = vehicleList[vehicleData.Class]
				if istable(vehicleTable2) then
					vehicleTable = {
						PrintName = vehicleTable2.Name,
						MDL = vehicleTable2.Model,
					}
				else
					vehicleTable = {
						PrintName = "Invalid Vehicle",
						MDL = "models/error/error.mdl",
					}
				end
            end

            local icon = Garage.Selection:Add("EGMModelIcon")
            icon:SetWidth(ScrW() * 0.2)
            icon:SetHeight(ScrW() * 0.2 / 2)
            icon:Dock( TOP )
            icon:DockMargin( 0, 0, 0, 5 )

			icon:SetModel(vehicleTable.MDL)
			icon:SetDisplayType("Weapon")

			icon:GenerateIcon()

            function icon:DoClick()
                Garage.VehiclePanel:SetVehicle(id)
            end
        end
    end
    self.Selection:Update()

    self.StoreButton = vgui.Create("EGMButton", self.Frame)
    self.StoreButton:SetPos(ScrW() * 0.1, ScrH() * 0.85)
    self.StoreButton:SetSize(ScrW() * 0.2, ScrH() * 0.05)
    self.StoreButton:SetTextColor(UI.TextColor)
    self.StoreButton:SetFont("EGMText10")
    self.StoreButton:SetText("Fahrzeug lagern")
    self.StoreButton:SetButtonColor(GetColor("yellow"))
    function self.StoreButton:DoClick()
        net.Start("Garage.StoreVehicle")
        net.SendToServer()

        Garage:CloseMenu()
    end

 	self.VehiclePanel = vgui.Create("DPanel", self.Frame)
    self.VehiclePanel:SetPos(ScrW() * 0.35, ScrH() * 0.25)
    self.VehiclePanel:SetSize(ScrW() * 0.55, ScrH() * 0.65)
    self.VehiclePanel:SetVisible(false)
    function self.VehiclePanel:Paint(width, height)
        draw.RoundedBox(0, 0, 0, width, height, ColorAlpha(UI.BackgroundColor2, 220))

        if isstring(self.VehicleName) then
            draw.SimpleText(self.VehicleName, "EGMText12", width / 2, height / 32, UI.ForegroundColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end
    function self.VehiclePanel:SetVehicle(id)
        self:SetVisible(true)

        local ply = LocalPlayer()
        local character = ply:GetCurrentCharacter()
        if not character then return end

        local garage = character:GetProperty("garage", {})
        self.VehicleId = id
        self.VehicleData = garage[id]

        local vehicleTable = scripted_ents.GetStored(self.VehicleData.Class)
        if istable(vehicleTable) then
            vehicleTable = vehicleTable.t
        else
			local vehicleList = list.Get("Vehicles")
			local vehicleTable2 = vehicleList[self.VehicleData.Class]
			if istable(vehicleTable2) then
				vehicleTable = {
					PrintName = vehicleTable2.Name,
					MDL = vehicleTable2.Model,
				}
			else
				vehicleTable = {
					PrintName = "Invalid Vehicle",
					MDL = "models/error/error.mdl",
				}
			end

        end

        self.VehicleName = vehicleTable.PrintName

        Garage.VehicleModelPanel:SetModel(vehicleTable.MDL)
        local entity = Garage.VehicleModelPanel:GetEntity()
        local min, max = entity:GetModelBounds()
        local diff = max - min
        local scale = math.max(diff.x, diff.y, diff.z)

        Garage.VehicleModelPanel:SetCamPos(Vector(-scale * 0.8, -scale * 0.8, scale / 2))
        Garage.VehicleModelPanel:SetLookAt(Vector(0, 0, 25))
    end

    self.VehicleModelPanel = vgui.Create("DModelPanel", self.VehiclePanel)
    self.VehicleModelPanel:Dock(FILL)

    self.StoreButton = vgui.Create("EGMButton", self.VehiclePanel)
    self.StoreButton:SetPos(ScrW() * 0.175, ScrH() * 0.6)
    self.StoreButton:SetSize(ScrW() * 0.2, ScrH() * 0.05)
    self.StoreButton:SetTextColor(UI.TextColor)
    self.StoreButton:SetFont("EGMText10")
    self.StoreButton:SetText("Fahrzeug entlagern")
    self.StoreButton:SetButtonColor(GetColor("yellow"))
    function self.StoreButton:DoClick()
        net.Start("Garage.UnStoreVehicle")
            net.WriteInt(Garage.VehiclePanel.VehicleId, 32)
            net.WriteEntity(ent)
        net.SendToServer()

        Garage:CloseMenu()
    end

    self.Frame:MakePopup()
end

-- Closes the character manager.
function Garage:CloseMenu()
    if IsValid(self.Frame) then
        self.Frame:Close()
    end
end

net.Receive("Garage.OpenMenu", function()
    Garage:OpenMenu(net.ReadEntity())
end)

--gamemodes/starwarsrp/gamemode/modules/garage/entities/egmrp_garage/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Shared | Garage Entity      --
---------------------------------------

---------------------------------------
--         Special Thanks to         --
--      Fabian 'Mekphen' Zimber      --
---------------------------------------

ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Garage"
ENT.Category = "EGM:RP"
ENT.Author = "Oninoni"
ENT.Purpose = ""

ENT.Spawnable = true
ENT.AdminOnly = false

ENT.WorldModel = Garage.Model

-- Initializes the entity.
function ENT:Initialize()
    self.WorldModel = Garage.Model

    if util.IsValidModel(self.WorldModel) then
        self:SetModel(self.WorldModel)
    else
        self:SetModel("models/props_combine/combine_interface001.mdl")
    end
    self:SetMoveType(MOVETYPE_VPHYSICS)
    self:SetSolid(SOLID_VPHYSICS)

    if SERVER then
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetUseType(SIMPLE_USE)
    end

    local phys = self:GetPhysicsObject()

    if phys:IsValid() then
        phys:Wake()
        phys:SetMass(50)
    end
end
--gamemodes/egmrp/gamemode/modules/inventory_weight/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Index | Inventory Weight     --
---------------------------------------

if not RequireModules({"inventory"}) then
	return false
end

InventoryWeight = InventoryWeight or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_inventory_weight.lua")
	AddCSLuaFile("cl_inventory_weight.lua")

	include("sh_config.lua")
	include("sh_inventory_weight.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_inventory_weight.lua")
	include("cl_inventory_weight.lua")
end
--gamemodes/egmrp/gamemode/modules/compass/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Compass | Index          --
---------------------------------------

Compass = Compass or {}

if SERVER then
    AddCSLuaFile("cl_config.lua")
    AddCSLuaFile("cl_compass.lua")
end

if CLIENT then
    include("cl_config.lua")
    include("cl_compass.lua")
end
--gamemodes/egmrp/gamemode/modules/inventory_shop/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Index | Inventory Shop      --
---------------------------------------

if not RequireModules({"inventory_money"}) then
	return false
end

InventoryShop = InventoryShop or {}
ShopEntry = ShopEntry or table.Copy(PropertyModel)

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_loaders.lua")

	AddCSLuaFile("sh_inventory_shop.lua")
	AddCSLuaFile("cl_inventory_shop.lua")
	AddCSLuaFile("sh_shop_entry.lua")
	AddCSLuaFile("cl_shop_entry.lua")

	AddCSLuaFile("cl_manager.lua")
	AddCSLuaFile("cl_net.lua")

	include("sh_config.lua")
	include("sh_loaders.lua")

	include("sh_inventory_shop.lua")
	include("sv_inventory_shop.lua")
	include("sh_shop_entry.lua")
	include("sv_shop_entry.lua")

	include("sv_net.lua")
	include("sv_eventlog.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_loaders.lua")

	include("sh_inventory_shop.lua")
	include("cl_inventory_shop.lua")
	include("sh_shop_entry.lua")
	include("cl_shop_entry.lua")

	include("cl_manager.lua")
	include("cl_net.lua")
end
--gamemodes/egmrp/gamemode/modules/inventory_shop/cl_manager.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Manager | Shop Entry       --
---------------------------------------

Manager:RegisterObjectCategory(
    ShopEntry.Name,
    egmt("shopEntry.name"),
    function()
        return ShopEntry:GetCache()
    end,
    function()
        return ShopEntry:Create({}, {name = egmt("shopEntry.new")})
    end,
    nil,
    egmt("shopEntry.duplicate_long"),
    egmt("shopEntry.delete"),
    egmt("shopEntry.delete_warning"),
    egmt("shopEntry.add"),
    egmt("shopEntry.save")
)
--gamemodes/egmrp/gamemode/modules/inventory_shop/entities/egmrp_shop/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Shop Entity       --
---------------------------------------

ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = egmt("inventory_shop.entity")
ENT.Category = "EGM:RP"
ENT.Author = "Oninoni"
ENT.Purpose = ""

ENT.Spawnable = true
ENT.AdminOnly = false

ENT.IsInventoryShop = true

ENT.WorldModel = InventoryShop.Model

-- Initializes the entity.
function ENT:Initialize()
	self.WorldModel = InventoryShop.Model

	if util.IsValidModel(self.WorldModel) then
		self:SetModel(self.WorldModel)
	else
		self:SetModel("models/props_c17/display_cooler01a.mdl")
	end
	self:SetMoveType(MOVETYPE_VPHYSICS)
	self:SetSolid(SOLID_VPHYSICS)

	if SERVER then
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetUseType(SIMPLE_USE)
	end

	local phys = self:GetPhysicsObject()

	if IsValid(phys) then
		phys:Wake()
		phys:SetMass(50)
	end
end
--gamemodes/egmrp/gamemode/modules/inventory_shop/shop_classes/base/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Shared | Base Shop        --
---------------------------------------

local SHOP_CLASS = SHOP_CLASS

-- Base Shop class, from which functions and such should be inherited.
SHOP_CLASS.BaseShopClass = false

-- Check, if a character can buy a given shop entry.
--
-- @param Character char
-- @param ShopEntry shopEntry
-- @return Boolean canBuy
-- @return? String error
function SHOP_CLASS:CanBuy(char, shopEntry)
	return false, "Not implemented"
end

-- Get the name of the shop entry.
--
-- @param ShopEntry shopEntry
-- @return String name
function SHOP_CLASS:GetShopEntryName(shopEntry)
	return "???"
end
--gamemodes/starwarsrp/gamemode/modules/garage_shop/cl_garage_shop.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Client | Garage Shop       --
---------------------------------------

ShopEntry:AddPropertyToList("vehicle", "Entity Klasse", "Die Entity Klasse, die gespawnt werden soll.", "string", nil, nil, 1, "Fahrzeug")
--gamemodes/starwarsrp/gamemode/modules/shiputil/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          ShipUtil index           --
---------------------------------------

if not RequireModules({"experience"}) then
	return false
end

ShipUtil = ShipUtil or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_shiputil.lua")
	AddCSLuaFile("cl_shiputil.lua")
	AddCSLuaFile("cl_keybinds.lua")

	include("sh_config.lua")
	include("sh_shiputil.lua")
	include("sv_shiputil.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_shiputil.lua")
	include("cl_shiputil.lua")
	include("cl_keybinds.lua")
end
--gamemodes/starwarsrp/gamemode/modules/shiputil/cl_shiputil.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          ShipUtil Client          --
---------------------------------------

if Config.Modules["multiserver"] then
	function ShipUtil:OpenVehicleChangeServerMenu(lfs)
		local modal = vgui.Create("EGMModal")
		modal:SetCustomTitle("Auf anderen Server senden")

		-- Adds all available Servers to the list.
		local options = {}
		for id, server in pairs(Socket.GroupServers) do
			table.insert(options, {
				text = server.name,
				data = id
			})
		end

		modal:Selection("Wohin möchtest du deine Passagiere senden?", "Server auswählen", options, function(id)
			net.Start("MultiServer.ChangePassengers")
				net.WriteInt(id, 32)
				net.WriteBool(lfs or false)
			net.SendToServer()

			local modal2 = vgui.Create("EGMModal")
			modal2:SetCustomTitle("Server wechseln")
			modal2:Confirm("Möchtest du selbst auch den Server wechseln?", function()
				net.Start("MultiServer.ChangePilot")
					net.WriteInt(id, 32)
					net.WriteBool(lfs or false)
				net.SendToServer()
			end, nil, "Ja", "Nein")
		end, nil, "Senden")
	end
end
--gamemodes/egmrp/gamemode/modules/inventory_faction/cl_net.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--   Client Networking | Inventory   --
---------------------------------------

net.Receive("InventoryFaction.GetLogs", function()
	local factionId = net.ReadUInt(32)
	local page = net.ReadUInt(32)

	local len = net.ReadInt(32)
	local logs = DecompressTable(net.ReadData(len))
	local count = net.ReadInt(32)

	InventoryFaction:ApplyFactionStorageLogs(factionId, page, logs, math.ceil(count / InventoryFaction.LogPageSize))
end)
--gamemodes/egmrp/gamemode/modules/cloneid/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           CloneId index           --
---------------------------------------

-- Conditionally include the module if it is enabled.
if Config.Modules["special_character"] and not RequireModules({"special_character"}) then
	return false
end

CloneId = CloneId or {}

if SERVER then
	AddCSLuaFile("sh_cloneid.lua")
	AddCSLuaFile("cl_cloneid.lua")

	AddCSLuaFile("cl_keybinds.lua")

	include("sh_cloneid.lua")
	include("sv_chats.lua")
end

if CLIENT then
	include("sh_cloneid.lua")
	include("cl_cloneId.lua")

	include("cl_keybinds.lua")
end
--gamemodes/starwarsrp/gamemode/modules/cloakdisguise/cl_cloaking.lua:
---------------------------------------
---------------------------------------
--           Cloakdisguise           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--           CL | Cloaking           --
---------------------------------------

local CamoMat = Material("camo/camo_shade.vmt")
local colorMofify = {
	["$pp_colour_addr"] = 0,
	["$pp_colour_addg"] = 0,
	["$pp_colour_addb"] = 0,
	["$pp_colour_brightness"] = 0,
	["$pp_colour_contrast"] = 1,
	["$pp_colour_colour"] = .5,
	["$pp_colour_mulr"] = 0,
	["$pp_colour_mulg"] = 0,
	["$pp_colour_mulb"] = 0,
}

hook.Add("RenderScreenspaceEffects", "Cloaking.RenderScreenspaceEffects", function()
	if LocalPlayer():IsCloaked() then
		DrawColorModify(colorMofify)
	end
end)

hook.Add("PrePlayerDraw", "Cloaking.PrePlayerDraw", function(ply)
	if ply:IsCloaked() then
		render.ModelMaterialOverride(CamoMat)
	end
end)

hook.Add("PostPlayerDraw", "Cloaking.PostPlayerDraw", function(ply)
	render.ModelMaterialOverride()
end)

hook.Add("DrawPlayerInfo", "Cloaking.HideNameTag", function(ply)
	if ply:IsCloaked() then
		return LocalPlayer():HasWeapon("weapon_swrp_cloakingdevice_" .. Cloaking.Types[ply:GetCloakId()].class)
	end
end)

-- Draw Halos for Camo.
hook.Add("PreDrawHalos", "Cloaking.PreDrawHalos", function()
	local haloPlayers = {}

	for _, ply in pairs(player.GetHumans()) do
		if ply:IsCloaked() and LocalPlayer():HasWeapon("weapon_swrp_cloakingdevice_" .. Cloaking.Types[ply:GetCloakId()].class) then
			if Cloaking.Types[ply:GetCloakId()].whitelist and not Cloaking.Types[ply:GetCloakId()].whitelist[LocalPlayer():GetModel()] then return end
			if not Cloaking.Types[ply:GetCloakId()].drawHalo then return end
			if not ply:Alive() then continue end

			table.insert(haloPlayers, ply)
		end
	end

	halo.Add(haloPlayers, Color(255, 255, 255), 5, 5, 1, true, false)
end)

hook.Add("PreDrawHalos", "wOS.Cloaking.PreDrawHalos", function()
	if LocalPlayer():GetNW2Float("wOS.ForceSight", 0) >= CurTime() then
		local haloPlayers = {}

		for _, ply in pairs(ents.FindInSphere(LocalPlayer():GetPos(), 500)) do
			if not ply:IsPlayer() then continue end
			if not ply:Alive() then continue end

			if ply:IsCloaked() then
				table.insert(haloPlayers, ply)
			end
		end

		halo.Add(haloPlayers, Color(255, 50, 50), 5, 5, 1, true, false)
	end
end)
--gamemodes/starwarsrp/gamemode/modules/cloakdisguise/cl_disguise.lua:
---------------------------------------
---------------------------------------
--           Cloakdisguise           --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--           CL | Disguise           --
---------------------------------------

--[[

net.Receive("Disguise.OpenMenu", function()
	Disguise:OpenMenu()
end)

function Disguise:OpenMenu()
	if IsValid(self.Menu) then
		self.Menu:Remove()
	end

	self.Menu = vgui.Create("DFrame")
	self.Menu:SetSize(ScrW() * 0.25, ScrH() * 0.6)
	self.Menu:SetTitle("")
	self.Menu:SetPos(ScrW() * 0.4, ScrH() * 0.2)
	self.Menu:ShowCloseButton(false)
	self.Menu:SetDraggable(false)
	function self.Menu:Paint(width, height)
		draw.RoundedBox(2, 0, 0, width, height, GetColor("darkgray"))
	end
	function self.Menu:OnClose()
		self.selectedFaction = nil
		self.selectedRank = nil
		self.selectedModel = nil
		self.selectedBodygroups = nil

		if IsValid(Disguise.Bodygroups) then
			Disguise.Bodygroups:Remove()
		end
	end

	self.Title = vgui.Create("EGMCloseButton", self.Menu)
	self.Title:SetPos(0, 0)
	self.Title:SetSize(ScrW() * 0.25, ScrH() * 0.06)
	self.Title:SetPanel(self.Menu)
	function self.Title:Paint(width, height)
		draw.RoundedBox(0, ScrW() * 0.05, 0, width - ScrW() * 0.05 * 2, height, UI.BackgroundColor2)

		surface.SetDrawColor(UI.BackgroundColor2)
		draw.NoTexture()

		surface.DrawPoly({
			{x = 0, y = 0},
			{x = ScrW() * 0.051, y = 0},
			{x = ScrW() * 0.051, y = height}
		})
		surface.DrawPoly({
			{x = width - ScrW() * 0.051, y = 0},
			{x = width, y = 0},
			{x = width - ScrW() * 0.051, y = height}
		})

		draw.DrawText("Magnetplatten", "EGMText12", width / 2, height * 0.15, UI.ForegroundColor, TEXT_ALIGN_CENTER)
	end

	self.Scrollpanel = vgui.Create("EGMScrollPanel", self.Menu)
	self.Scrollpanel:Dock(TOP)
	self.Scrollpanel:DockMargin(0, ScrH() * 0.05, 0, 0)
	self.Scrollpanel:SetSize(0, ScrH() * 0.6)
	function self.Scrollpanel:Paint(width, height)
	end

	self.NameSelection = vgui.Create("DTextEntry", self.Scrollpanel)
	self.NameSelection:SetHeight(ScrH() * 0.04)
	self.NameSelection:Dock(TOP)
	self.NameSelection:DockMargin(0, ScrH() * 0.01, 0, 0)
	self.NameSelection:SetPlaceholderText("Wähle deinen Namen.")

	self.IdSelection = vgui.Create("DTextEntry", self.Scrollpanel)
	self.IdSelection:SetHeight(ScrH() * 0.04)
	self.IdSelection:Dock(TOP)
	self.IdSelection:DockMargin(0, ScrH() * 0.01, 0, 0)
	self.IdSelection:SetPlaceholderText("Wähle deine Custom ID.")

	self.FactionSelection = vgui.Create("DComboBox", self.Scrollpanel)
	self.FactionSelection:SetHeight(ScrH() * 0.04)
	self.FactionSelection:Dock(TOP)
	self.FactionSelection:DockMargin(0, ScrH() * 0.01, 0, 0)
	self.FactionSelection:SetText("Fraktion auswählen")
	for k, faction in pairs(Faction:GetCache()) do
		self.FactionSelection:AddChoice(faction:GetName(), faction:GetId())
	end
	function self.FactionSelection:OnSelect(index, value, data)
		self = Disguise.Menu
		self.selectedFaction = data

		Disguise.ConfirmButton:SetDisabled(true)

		if IsValid(Disguise.RankSelection) then
			Disguise.RankSelection:Remove()
		end

		if IsValid(Disguise.ModelSelection) then
			Disguise.ModelSelection:Remove()
			Disguise.ModelSelection = nil
			Disguise.selectedModel = nil
			Disguise.selectedBodygroups = nil
		end

		if IsValid(Disguise.Bodygroups) then
			Disguise.Bodygroups:Close()
		end

		Disguise.RankSelection = vgui.Create("DComboBox", Disguise.Scrollpanel)
		Disguise.RankSelection:SetHeight(ScrH() * 0.04)
		Disguise.RankSelection:Dock(TOP)
		Disguise.RankSelection:DockMargin(0, ScrH() * 0.01, 0, 0)
		Disguise.RankSelection:SetText("Rang auswählen")
		for k, rank in pairs(Rank:GetByFaction(data)) do
			Disguise.RankSelection:AddChoice(rank:GetName(), rank:GetId())
		end
		function Disguise.RankSelection:OnSelect(index, value, data)
			self = Disguise.Menu
			Disguise.selectedRank = data

			Disguise.ConfirmButton:SetDisabled(true)

			if IsValid(Disguise.ModelSelection) then
				Disguise.ModelSelection:Remove()
				Disguise.ModelSelection = nil
				Disguise.selectedModel = nil
				Disguise.selectedBodygroups = nil
			end

			local rank = Rank:GetCached(Disguise.selectedRank)
			if not rank then return end

			local faction = rank:GetFaction()
			if not faction then return end

			-- Loads the faction models
			local models = table.Copy(rank:GetProperty("models", {}))
			table.Add(models, faction:GetProperty("models", {}))

			-- Loads the specialisation models
			local specialisations = faction:GetSpecialisations()
			for _, specialisation in pairs(specialisations) do
				local specialisationModels = specialisation:GetProperty("modelsAdded", {})
				MergeTableByValue(models, specialisationModels)
			end

			local selectedId = table.GetKeys(models)[1]
			Disguise.selectedModel = models[selectedId]

			-- Create the Model Selection Panel
			Disguise.ModelSelection = vgui.Create("DPanel", Disguise.Scrollpanel)
			Disguise.ModelSelection:Dock(TOP)
			Disguise.ModelSelection:SetSize(0, ScrH() * 0.3)
			Disguise.ModelSelection:DockMargin(0, ScrH() * 0.01, 0, ScrH() * 0.01)
			function Disguise.ModelSelection:Paint(width, height)
			end

			Disguise.ModelIcon = vgui.Create("EGMModelPanel", Disguise.ModelSelection)
			Disguise.ModelIcon:SetModel(Disguise.selectedModel)

			-- For better resolution. For some reason does not update the rendered image on the time of creation correctly.
			timer.Simple(0, function()
				if Disguise.ModelIcon and IsValid(Disguise.ModelIcon) then
					Disguise.ModelIcon:SetModel(Disguise.selectedModel)
					Disguise:OpenBodygroups(Disguise.selectedModel)
				end
			end)

			-- Creates the left model switch button
			local leftButton = vgui.Create("DButton", Disguise.ModelSelection)
			leftButton:SetText("")
			function leftButton:Paint(width, height)
				draw.RoundedBox(5, 0, 0, width, height, GetColor("gray", 200))

				surface.SetDrawColor(GetColor("yellow"))
				draw.NoTexture()

				surface.DrawPoly({
					{x = width * 0.6, y = height * 0.5 - width * 0.3},
					{x = width * 0.6, y = height * 0.5 - width * 0.2},
					{x = width * 0.4, y = height * 0.5 + 0},
					{x = width * 0.3, y = height * 0.5 + 0}
				})
				surface.DrawPoly({
					{x = width * 0.4, y = height * 0.5 + 0},
					{x = width * 0.6, y = height * 0.5 + width * 0.2},
					{x = width * 0.6, y = height * 0.5 + width * 0.3},
					{x = width * 0.3, y = height * 0.5 + 0}
				})
			end
			function leftButton:DoClick()
				if selectedId - 1 <= 0 then
					selectedId = #models
				else
					selectedId = selectedId - 1
				end

				Disguise.selectedModel = models[selectedId]
				Disguise.ModelIcon:SetModel(Disguise.selectedModel)
				Disguise:OpenBodygroups(Disguise.selectedModel)
			end

			-- Creates the right model switch button
			local rightButton = vgui.Create("DButton", Disguise.ModelSelection)
			rightButton:SetText("")
			function rightButton:Paint(width, height)
				draw.RoundedBox(5, 0, 0, width, height, GetColor("gray", 200))

				surface.SetDrawColor(GetColor("yellow"))
				draw.NoTexture()

				surface.DrawPoly({
					{x = width * 0.6, y = height * 0.5 + 0},
					{x = width * 0.4, y = height * 0.5 - width * 0.2},
					{x = width * 0.4, y = height * 0.5 - width * 0.3},
					{x = width * 0.7, y = height * 0.5 + 0}
				})
				surface.DrawPoly({
					{x = width * 0.4, y = height * 0.5 + width * 0.3},
					{x = width * 0.4, y = height * 0.5 + width * 0.2},
					{x = width * 0.6, y = height * 0.5 + 0},
					{x = width * 0.7, y = height * 0.5 + 0}
				})
			end
			function rightButton:DoClick()
				if selectedId + 1 > #models then
					selectedId = 1
				else
					selectedId = selectedId + 1
				end

				Disguise.selectedModel = models[selectedId]
				Disguise.ModelIcon:SetModel(Disguise.selectedModel)
				Disguise:OpenBodygroups(Disguise.selectedModel)
			end

			function Disguise.ModelSelection:PerformLayout()
				local width, height = self:GetSize()

				Disguise.ModelIcon:SetSize(height, height)
				Disguise.ModelIcon:Center()

				leftButton:SetPos(0, 0)
				leftButton:SetSize(width * 0.15, height)

				rightButton:SetPos(width * 0.85, 0)
				rightButton:SetSize(width * 0.15, height)
			end

			Disguise.ConfirmButton:SetDisabled(false)
		end
	end

	self.ConfirmButton = vgui.Create("EGMButton", self.Menu)
	self.ConfirmButton:SetHeight(ScrH() * 0.05)
	self.ConfirmButton:SetDisabled(true)
	self.ConfirmButton:Dock(BOTTOM)
	self.ConfirmButton:SetText("Magnetplatten aktivieren")
	function self.ConfirmButton:DoClick()
		Disguise.Menu:Close()

		net.Start("Disguise.Cloak")
			net.WriteString(Disguise.selectedModel)
			net.WriteTable(Disguise.selectedBodygroups)
			net.WriteInt(Disguise.selectedRank, 32)
			net.WriteString(Disguise.NameSelection:GetValue() or "")
			net.WriteString(Disguise.IdSelection:GetValue() or "")
		net.SendToServer()
	end

	self.Menu:MakePopup()
end

function Disguise:OpenBodygroups(modelPath)
	if IsValid(self.Bodygroups) then
		self.Bodygroups:Remove()
	end

	local ent = Disguise.ModelIcon:GetEntity()
	local y = ScrH() * 0.01

	self.selectedBodygroups = {}

	self.Bodygroups = vgui.Create("DFrame")
	self.Bodygroups:SetSize(ScrW() * 0.25, ScrH() * 0.6)
	self.Bodygroups:SetTitle("")
	self.Bodygroups:SetPos(ScrW() * 0.55, ScrH() * 0.2)
	self.Bodygroups:ShowCloseButton(false)
	self.Bodygroups:SetDraggable(false)
	function self.Bodygroups:Paint(width, height)
		draw.RoundedBox(2, 0, 0, width, height, GetColor("darkgray"))
	end
	function self.Bodygroups:OnClose()
		self.selectedBodygroups = nil

		if not IsValid(Disguise.Menu) then return end
		Disguise.Menu:SetPos(ScrW() * 0.4, ScrH() * 0.2)
	end

	self.Title = vgui.Create("DPanel", self.Bodygroups)
	self.Title:SetPos(0, 0)
	self.Title:SetSize(ScrW() * 0.25, ScrH() * 0.06)
	function self.Title:Paint(width, height)
		draw.RoundedBox(0, ScrW() * 0.05, 0, width - ScrW() * 0.05 * 2, height, UI.BackgroundColor2)

		surface.SetDrawColor(UI.BackgroundColor2)
		draw.NoTexture()

		surface.DrawPoly({
			{x = 0, y = 0},
			{x = ScrW() * 0.051, y = 0},
			{x = ScrW() * 0.051, y = height}
		})

		surface.DrawPoly({
			{x = width - ScrW() * 0.051, y = 0},
			{x = width, y = 0},
			{x = width - ScrW() * 0.051, y = height}
		})

		draw.DrawText("Bodygroups", "EGMText12", width / 2, height * 0.15, UI.ForegroundColor, TEXT_ALIGN_CENTER)
	end

	Disguise.BodygroupSelection = vgui.Create("EGMScrollPanel", self.Bodygroups)
	Disguise.BodygroupSelection:SetPos(0, ScrH() * 0.1)
	Disguise.BodygroupSelection:SetSize(ScrW() * 0.25, ScrH() * 0.5)
	Disguise.BodygroupSelection:BackgroundColor(UI.BackgroundColor)

	-- Load the changeable Bodygroups.
	local bodyGroups = {}
	for _, bodyGroup in pairs(ent:GetBodyGroups()) do
		local bodyGroupData = {}
		for k, submodel in pairs(bodyGroup.submodels) do
			table.insert(bodyGroupData, k)
		end

		if table.Count(bodyGroupData) > 1 then
			bodyGroups[bodyGroup.name] = bodyGroupData
		end
	end

	-- Create the Bodygroups Panels
	for name, subModels in pairs(bodyGroups) do
		x = ScrW() * 0.01

		local heading = vgui.Create("DLabel", Disguise.BodygroupSelection)
		heading:SetPos(x, y)
		heading:SetFont("EGMText12")
		heading:SetTextColor(UI.TextColor)
		heading:SetText(name)
		heading:SizeToContents()

		y = y + ScrH() * 0.04

		for k, subModel in pairs(subModels) do
			local button = vgui.Create("DButton", Disguise.BodygroupSelection)
			button:SetPos(x, y)
			button:SetSize(ScrW() * 0.05, ScrH() * 0.025)
			button:SetFont("EGMText12")
			button:SetTextColor(UI.TextColor)
			button:SetText(subModel)
			function button:Paint(width, height)
				if ent:GetBodygroup(ent:FindBodygroupByName(name)) == subModel then
					draw.RoundedBox(5, 0, 0, width, height, GetColor("green", 200))
				else
					draw.RoundedBox(5, 0, 0, width, height, GetColor("gray", 100))
				end
			end
			function button:DoClick()
				surface.PlaySound(UI.ButtonSound)

				Disguise.selectedBodygroups[name] = subModel
				ent:SetBodygroup(ent:FindBodygroupByName(name), subModel)
			end

			x = x + ScrW() * 0.055

			if x > ScrW() * 0.2 then
				x = ScrW() * 0.01
				y = y + ScrH() * 0.025
			end

			if ent:GetBodygroup(ent:FindBodygroupByName(name)) == subModel then
				Disguise.selectedBodygroups[name] = subModel
			end
		end

		y = y + ScrH() * 0.04
	end

	self.Menu:SetPos(ScrW() * 0.25, ScrH() * 0.2)
	self.Bodygroups:MakePopup()
end

hook.Add("Scoreboard.GetFactionName", "Disguise.GetFactionName", function(ply)
	if ply:IsDisguised() then
		local rank = Rank:GetCached(ply:GetDisguiseRank())
		if not rank then return end

		local faction = rank:GetFaction()
		if not faction then return end

		return faction:GetName()
	end
end)

hook.Add("Scoreboard.GetRankName", "Disguise.GetRankName", function(ply)
	if ply:IsDisguised() then
		local rank = Rank:GetCached(ply:GetDisguiseRank())
		if not rank then return end

		return rank:GetName()
	end
end)

-- Don't show the extra faction while disguised.
if Config.Modules["extrafaction"] then
	hook.Remove("Scoreboard.GetFactionName", "ExtraFaction.GetScoreboardFactionName")
	hook.Add("Scoreboard.GetFactionName", "ExtraFaction.GetScoreboardFactionName", function(ply)
		if ply:IsDisguised() then return end

		local extraFactionName = ply:GetCurrentCharacterExtraFactionPrefix()

		if extraFactionName and extraFactionName ~= "" then
			return ply:GetCurrentCharacterFactionName() .. " | " .. extraFactionName
		end
	end)
end


hook.Add("GetPlayerInfo", "Disguise.GetPlayerInfo", function(ply)
	if ply:IsDisguised() then
		-- Local Character
		local localCharacter = LocalPlayer():GetCurrentCharacter()
		if not localCharacter then return end

		local localRank = localCharacter:GetRank()
		if not localRank then return end

		local localFaction = localRank:GetFaction()
		if not localFaction then return end

		local localExtraFaction = false
		if Config.Modules["extrafaction"] and localCharacter:GetExtraFaction() then
			localExtraFaction = localCharacter:GetExtraFaction()
		end

		-- Player Character
		local character = ply:GetCurrentCharacter()
		if not character then return end

		local rank = character:GetRank()
		if not rank then return end

		local faction = rank:GetFaction()
		if not faction then return end

		if ply:IsDisguised() then
			rank = Rank:GetCached(ply:GetDisguiseRank())
			faction = rank:GetFaction()
		end

		local name = ""

		-- Override Internal View
		if localFaction == faction
		or Config.Modules["extrafaction"] and localExtraFaction == faction then
			local rankPrefix = character:GetRankPrefix()
			if rankPrefix ~= "" then
				name = rankPrefix .. " "
			end

			local factionPrefix = character:GetFactionPrefix()
			if factionPrefix ~= "" then
				name = name .. factionPrefix .. " "
			end

			if Config.Modules["cloneid"] and rank:GetProperty("cloneIdEnabled", false) and character:GetCloneId() then
				name = name .. character:GetCloneId() ..  " "
			end

			local rpName = ply:GetDisguiseName() ~= "" and ply:GetDisguiseName() or ply:GetCurrentCharacter():GetRPName()
			name = name .. rpName
		else -- Override External View
			if Config.Modules["hud"] then
				-- Checks whether the faction has a faction alias
				if faction:GetProperty("factionAlias", -1) ~= -1 then
					faction = Faction:GetCached(faction:GetProperty("factionAlias", -1))
				end

				-- Checks whether the rank has a faction alias
				if rank:GetProperty("factionAlias", -1) ~= -1 then
					faction = Faction:GetCached(rank:GetProperty("factionAlias", -1))
				end

				if not localCharacter:GetRank():GetFaction():GetProperty("isCloneFaction", false)
				or localCharacter:GetRank():GetFaction():GetProperty("isCloneFaction", false) == true and not faction:GetProperty("isCloneFaction", false) then
					return faction:GetName(), faction:GetProperty("color", Color(255, 255, 255, 255))
				end
			end

			local factionPrefix = character:GetFactionPrefix()
			if factionPrefix ~= "" then
				name = factionPrefix .. " "
			end

			name = name .. rank:GetName() .. " "

			if Config.Modules["cloneid"] and rank:GetProperty("cloneIdEnabled", false) and character:GetCloneId() then
				name = name .. character:GetCloneId()
			end
		end

		return name, character:GetFactionColor()
	end
end)

hook.Add("WeaponSlots.AddWeaponsToBox", "Disguise.AddWeaponsToBox", function(ply, availableWeaponClasses)
	if ply:IsDisguised() then
		local rank = Rank:GetCached(ply:GetDisguiseRank())
		if not rank then return end

		local validWeapons = rank:GetWeapons()
		MergeTableByValue(availableWeaponClasses, validWeapons)

		local faction = rank:GetFaction()
		if not faction then return end

		local specialisations = faction:GetSpecialisations()
		for _, specialisation in pairs(specialisations) do
			local specialisationWeapons = specialisation:GetProperty("weaponsAdded", {})
			MergeTableByValue(availableWeaponClasses, specialisationWeapons)
		end
	end
end)

-- Draw Halos for Disguise.
hook.Add("PreDrawHalos", "Disguise.ShowHalos", function()
	local haloPlayers = {}

	for _, ply in pairs(player.GetHumans()) do
		if ply:IsDisguised() and LocalPlayer():HasWeapon("weapon_swrp_cloakingdevice_" .. Cloaking.Types[ply:GetDisguiseId()].class) then
			if Cloaking.Types[ply:GetDisguiseId()].whitelist and not Cloaking.Types[ply:GetDisguiseId()].whitelist[LocalPlayer():GetModel()] then return end
			if not Cloaking.Types[ply:GetDisguiseId()].drawHalo then return end
			if not ply:Alive() then continue end

			table.insert(haloPlayers, ply)
		end
	end

	halo.Add(haloPlayers, Color(255, 255, 255), 5, 5, 1, true, false)
end)

-- Adds an option to open a player scan menu
--
Interact:RegisterOption(nil, "Enttarnen", 1, function()
	local trace = LocalPlayer():GetEyeTrace()
	local entity = trace.Entity

	-- Check if the entity is valid
	if IsValid(entity) then return end

	-- The entity must be a ragdoll
	if not LocalPlayer():IsDisguised() then return end

	net.Start("Disguise.Uncloak")
	net.SendToServer()

	Interact.Menu:Remove()
end, function()
	local trace = LocalPlayer():GetEyeTrace()
	local entity = trace.Entity

	-- Check if the entity is valid
	if IsValid(entity) then return false end

	-- The entity must be a ragdoll
	if not LocalPlayer():IsDisguised() then return false end

	return true
end)

]]
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/entities/npc_swrp_dwarf/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

if SERVER then
	AddCSLuaFile()
end

ENT.Base   = "npc_swrp_nextbot_base"

ENT.PrintName = "Dwarf Spider Droid"
ENT.Author = "Deltaa"
ENT.Information = ""
ENT.Category = "SW:RP (NPCs)"

ENT.Spawnable		= false
ENT.AdminOnly		= false

ENT.IsSWRPNextbot = true

ENT.AnimIdle = 0
ENT.AnimWalk = "walk"
ENT.AnimIdleAim = 0
ENT.AnimWalkAim = "walk"
ENT.AnimReload = 0

ENT.MaxHealth = 600

-- Speed value of the character. Scales running aswell.
ENT.WalkSpeed = 80

if SERVER then
	function ENT:Initialize()
		self.BehaviourState = 0

		self.TargetRelationships = {}
		self.TargetMemory = {}

		self.HomePos = self:GetPos()
		self.TargetPos = self.TargetPos or self.HomePos

		self:SetModel(self.DefaultModel)
		self:Give(self.DefaultWeapon)

		self:SetMaxHealth(self.MaxHealth)
		self:SetHealth(self.MaxHealth)

		self:SetCollisionGroup(COLLISION_GROUP_NPC_SCRIPTED)

		self.loco:SetDesiredSpeed(self.WalkSpeed)
		self.loco:SetAcceleration(1000)
		self:ChangeActivity(self.AnimIdle)

		self:SetKeyValue( "spawnflags", bit.bor( SF_NPC_NO_WEAPON_DROP, SF_NPC_FADE_CORPSE, SF_NPC_LONG_RANGE ) )

		self:SetFOV(self.FOV)
		self:SetMaxVisionRange(3000)

		self.Reloading = CurTime()
	end

	function ENT:OnKilled(dmgInfo)
		hook.Call( "OnNPCKilled", GAMEMODE, self, dmgInfo:GetAttacker(), dmgInfo:GetInflictor() )

		local oldWeapon = self:GetNWEntity("ActiveWeapon")
		if IsValid(oldWeapon) then
			SafeRemoveEntity(oldWeapon)
		end

		self:EmitSound("ambient/levels/labs/electric_explosion1.wav")

		SafeRemoveEntity(self)
	end

	function ENT:ChangeActivity(sequence)
		if self.LastAnimation == sequence then return end

		self:SetSequence(sequence)
		self.LastAnimation = sequence

		self.ResetSequences = true
	end
end
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/entities/npc_swrp_nextbot_base/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--				Oninoni				 --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

ENT.Base = "base_nextbot"

ENT.PrintName = "EGM NPC Base"
ENT.Author = "Oninoni"
ENT.Information = ""
ENT.Category = "EGM:RP"

ENT.Spawnable        = false
ENT.AdminOnly        = false

ENT.IsSWRPNextbot = true

-- Default model the npc uses.
ENT.DefaultModel = "models/player/alyx.mdl"

-- Default weapon the npc uses.
ENT.DefaultWeapon = "weapon_npc_e5"

-- How much Health the NPC should have.
ENT.MaxHealth = 200

-- Speed value of the character. Scales running aswell.
ENT.WalkSpeed = 120

-- ACT Enums Used for animation.
ENT.AnimIdle = ACT_HL2MP_IDLE_PASSIVE
ENT.AnimWalk = ACT_HL2MP_WALK_PASSIVE
ENT.AnimIdleAim = ACT_HL2MP_IDLE_SMG1
ENT.AnimWalkAim = ACT_HL2MP_RUN_SMG1
ENT.AnimReload = ACT_HL2MP_GESTURE_RELOAD_SMG1

-- Behaviour Settings

-- How far the enemy has to be before we lose them
ENT.LoseTargetDist = 30000

-- How far to search for enemies
ENT.SearchRadius = 12000

-- The Distance at which we actually shoot.
ENT.AttackRange = 15000

-- Behaviour Types
BEHAVIOUR_STUPID    = 0 -- Attacks Everything it sees and follows targets blindly.
BEHAVIOUR_DEFENSIVE = 1 -- Defends a point to wich it always returns. (Defined by Spawn Position)
BEHAVIOUR_PATROL    = 2 -- Patrols an area (Between Spawn Position and Spawn Tool Secondary).
BEHAVIOUR_ATTACK    = 3 -- Attacks a marked point. (Defined by Spawn Tool Secondary)

-- Behaviour of the NPC
ENT.Behaviour = BEHAVIOUR_STUPID

-- If the NPC should throw grenades
ENT.ShouldThrowGrenades = false

-- Grenades the NPC can throw
ENT.Grenades = {}

-- How precise should it be. (0 = Aimbot)
ENT.Precision = 0

-- Time in seconds it takes from seeing a target to shooting at it.
ENT.ReactionTime = 1

-- Time in seconds it gives up shooting at somebody.
ENT.Patience = 5

-- Field of View, to find droids.
ENT.FOV = 360

ENT.Sounds = {}
ENT.SoundCooldown = 0

-- NPC Interfacing Functions
ENT.ShouldReturnTrue = true
if not ShouldReturnTrueIsSetInMetaTable985403684956 then
	local EntMeta = FindMetaTable( "Entity" )
	local oldisnpc = EntMeta.IsNPC
	function EntMeta:IsNPC()
		if self.ShouldReturnTrue then
			return true
		else
			return oldisnpc(self)
		end
	end
end
ShouldReturnTrueIsSetInMetaTable985403684956 = true

function ENT:GetViewModel()
	return self
end

function ENT:GetWalkSpeed()
	return self.WalkSpeed
end

function ENT:GetRunSpeed()
	return self.WalkSpeed * 1.5
end

function ENT:GetInfoNum(...)
	return 0
end

function ENT:GetEyeTrace()
	local dir = self:GetAimVector()
	local trace = {}
	trace.start = self:GetShootPos()
	trace.endpos = trace.start + ( dir * ( 4096 * 8 ) )
	trace.filter = ply

	return util.TraceLine(trace)
end

-- Initialize
function ENT:Initialize()
	if SERVER then
		self.BehaviourState = 0

		self.TargetRelationships = {}
		self.TargetMemory = {}

		self.HomePos = self:GetPos()
		self.TargetPos = self.TargetPos or self.HomePos

		self:SetModel(self.DefaultModel)
		self:Give(self.DefaultWeapon)

		self:SetMaxHealth(self.MaxHealth)
		self:SetHealth(self.MaxHealth)

		self:SetCollisionGroup(COLLISION_GROUP_NPC_SCRIPTED)

		self.loco:SetDesiredSpeed(self.WalkSpeed)
		self.loco:SetAcceleration(1000)
		self:StartActivity(self.AnimIdle)

		self:SetKeyValue( "spawnflags", bit.bor( SF_NPC_NO_WEAPON_DROP, SF_NPC_FADE_CORPSE, SF_NPC_LONG_RANGE ) )

		self:SetFOV(self.FOV)
		self:SetMaxVisionRange(3000)
		self:DrawShadow(false)

		self.Reloading = CurTime()
		self.GrenadeCooldown = CurTime()
	end
end

function ENT:GetActiveWeapon()
	return self:GetNWEntity("ActiveWeapon")
end

--[[
TODO:

Wander around Spawn Point Option?
Reload bei unter Hälfte wenn kein Ziel mehr vor der Nase
Reload Sound

Flashbang?
Smoke?
]]

function ENT:GetViewPunchAngles()
	return Angle()
end

function ENT:ViewPunch(punchAngle)
	-- TODO: Maybe?
end

function ENT:Crouching()
	return false
end

function ENT:IsSprinting()
	return false
end

function ENT:RemoveAmmo(...)
end
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/weapons/weapon_npc_cr2.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

AddCSLuaFile()

SWEP.Base   = "weapon_npcbase"

SWEP.PrintName = "NPC: CR2"
SWEP.Spawnable = false
SWEP.Author = "Deltaa"

SWEP.WorldModel = "models/sw_battlefront/weapons/cr2_pistol.mdl"
SWEP.Weight = 3

SWEP.NextShoot = 0.2
SWEP.Sound = "w/cr2.wav"
SWEP.ReloadSound = "w/pistols.wav"
SWEP.ClipSize = 30
SWEP.Damage = 20
SWEP.NumOfShots = 1
--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/weapons/weapon_npc_dwarf.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

AddCSLuaFile()

SWEP.Base   = "weapon_npcbase"

SWEP.PrintName = "NPC: Crap-Droid"
SWEP.Spawnable = false
SWEP.Author = "Deltaa"

SWEP.WorldModel = false
SWEP.Weight = 3

SWEP.NextShoot = 0.3
SWEP.Sound = "av7fire.wav"
SWEP.ClipSize = 20
SWEP.Damage = 30
SWEP.NumOfShots = 1

function SWEP:Reload()
	self:SetClip1(self.ClipSize or 40)

	self:EmitSound(self.ReloadSound or "w/heavy.wav")

	self:SetNextPrimaryFire(CurTime() + 3)
	self:SetNextSecondaryFire(CurTime() + 3)
end

--gamemodes/starwarsrp/gamemode/modules/nextbotspawner/weapons/weapon_npc_verpine.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--				(CW:RP)		 	 	 --
--                                   --
--           NextBot Spawner         --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

AddCSLuaFile()

SWEP.Base   = "weapon_npcbase"

SWEP.PrintName = "NPC: Verpinengewehr"
SWEP.Spawnable = false
SWEP.Author = "Deltaa"

SWEP.WorldModel = "models/sw_battlefront/weapons/nt242_longblaster.mdl"
SWEP.Weight = 3

SWEP.NextShoot = 0.5
SWEP.Sound = "w/nn14.wav"
SWEP.ClipSize = 10
SWEP.Damage = 50
SWEP.NumOfShots = 1
--gamemodes/starwarsrp/gamemode/modules/eventspawns/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Eventspawns index         --
---------------------------------------

Eventspawns = Eventspawns or {}

if not RequireModules({"permaprops"}) then return end

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("sh_eventspawns.lua")
	AddCSLuaFile("cl_eventspawns.lua")

	include("sh_config.lua")
	include("sh_eventspawns.lua")
	include("sv_eventspawns.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("sh_eventspawns.lua")
	include("cl_eventspawns.lua")
end
--gamemodes/starwarsrp/gamemode/modules/education/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis   --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
---------------------------------------
---------------------------------------

---------------------------------------
--         Index | Education         --
---------------------------------------

Education = Education or {}

if SERVER then
	AddCSLuaFile("sh_config.lua")
	AddCSLuaFile("cl_education.lua")

	include("sh_config.lua")
	include("sv_education.lua")
end

if CLIENT then
	include("sh_config.lua")
	include("cl_education.lua")
end
--gamemodes/starwarsrp/gamemode/modules/voicenotify/cl_voicenotify.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Voicenotify            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Voicenotify | CL          --
---------------------------------------

--[[--------------------------------------
Overrides default Voice functions
-----------------------------------------]]

-- Overrides the default Start Voice function
--
-- @param? Player ply
function GAMEMODE:PlayerStartVoice( ply )
	if not IsValid(g_VoicePanelList) then return end

	-- There'd be an exta one if voice_loopback is on, so remove it.
	GAMEMODE:PlayerEndVoice(ply)

	-- Select the voice notify mode
	Voicenotify:SelectMode(ply)
end

-- Checks if the player can hear by comlink
--
-- @param? Player ply
function Voicenotify:CanComlinkHear(ply)
	if not ply:IsComlinkEnabled() then return false end

	local activeChannel = ply:GetNWString("Comlink.ActiveChannel", "")
	if activeChannel == "" then return false end

	if activeChannel == "announcement" then return true end
	if activeChannel == LocalPlayer():ActiveChannel() then return true end
	if activeChannel == LocalPlayer():PassiveChannel1() then return true end
	if activeChannel == LocalPlayer():PassiveChannel2() then return true end

	return false
end

-- Selects the voicebar mode
--
-- @param? Player ply
function Voicenotify:SelectMode(ply)
	if Voicenotify:CanComlinkHear(ply) == true then
		if IsValid(Voicenotify.ComlinkVoicePanels[ply]) then
			if Voicenotify.ComlinkVoicePanels[ply].fadeAnim  then
				Voicenotify.ComlinkVoicePanels[ply].fadeAnim:Stop()
				Voicenotify.ComlinkVoicePanels[ply].fadeAnim = nil
			end

			Voicenotify.ComlinkVoicePanels[ply]:SetAlpha( 255 )

			return
		end

		local pnl = Voicenotify.VoicePanelList:Add( "VoiceNotifyComlink" )
		pnl:Setup(ply)

		Voicenotify.ComlinkVoicePanels[ply] = pnl
	else
		if IsValid(Voicenotify.PlayerVoicePanels[ply]) then
			if Voicenotify.PlayerVoicePanels[ply].fadeAnim then
				Voicenotify.PlayerVoicePanels[ply].fadeAnim:Stop()
				Voicenotify.PlayerVoicePanels[ply].fadeAnim = nil
			end

			Voicenotify.PlayerVoicePanels[ ply ]:SetAlpha( 255 )

			return
		end

		if not IsValid( ply ) then return end

		local pnl = g_VoicePanelList:Add("VoiceNotify")
		pnl:Setup(ply)

		Voicenotify.PlayerVoicePanels[ply] = pnl
	end
end

-- Overrides the default End Voice function
--
-- @param? Player ply
function GAMEMODE:PlayerEndVoice(ply)
	if IsValid(Voicenotify.PlayerVoicePanels[ply]) then
		if Voicenotify.PlayerVoicePanels[ply].fadeAnim then return end

		Voicenotify.PlayerVoicePanels[ply].fadeAnim = Derma_Anim("FadeOut", Voicenotify.PlayerVoicePanels[ply], Voicenotify.PlayerVoicePanels[ply].FadeOut)
		Voicenotify.PlayerVoicePanels[ply].fadeAnim:Start( 2 )
	end

	if IsValid(Voicenotify.ComlinkVoicePanels[ply]) then
		if Voicenotify.ComlinkVoicePanels[ply].fadeAnim then return end

		Voicenotify.ComlinkVoicePanels[ply].fadeAnim = Derma_Anim("FadeOut", Voicenotify.ComlinkVoicePanels[ply], Voicenotify.ComlinkVoicePanels[ply].FadeOut)
		Voicenotify.ComlinkVoicePanels[ply].fadeAnim:Start(2)
	end
end

--[[--------------------------------------
Overrides comlink receive notify box
-----------------------------------------]]

-- Cleanup the voice fields every 10 seconds
--
local function VoiceClean()
	for k, v in pairs(Voicenotify.ComlinkVoicePanels) do
		if not IsValid(k) then
			hook.Run("PlayerEndVoice", k)
		end
	end

	for k, v in pairs(Voicenotify.PlayerVoicePanels) do
		if (not IsValid(k)) then
			hook.Run("PlayerEndVoice", k)
		end
	end
end
timer.Create("VoiceClean", 10, 0, VoiceClean )


function Voicenotify:CreateVoiceVGUI()
	Voicenotify.VoicePanelList = vgui.Create( "DPanel" )
	Voicenotify.VoicePanelList:ParentToHUD()
	Voicenotify.VoicePanelList:SetPos( ScrW() - 300, 100 )
	Voicenotify.VoicePanelList:SetSize( 250, ScrH() - 200 )
	Voicenotify.VoicePanelList:SetPaintBackground( false )
end
hook.Add("InitPostEntity", "Voicenotify.CreateVoiceVGUI", Voicenotify.CreateVoiceVGUI)

-- Generates the font for the display bar
--
-- @param? String text
-- @param? Number size
function Voicenotify:GetFont(text, size)
	local length = #tostring(text)

	local fontSize = math.min(math.max(math.Round(math.sqrt(size / length) * 1.75, 0), 1), 7)
	if fontSize < 7 then
		return "EGM" .. "Text" .. fontSize
	end

	return "EGMText7"
end
--gamemodes/starwarsrp/gamemode/modules/hud/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Shared | HUD            --
---------------------------------------

if not RequireModules({"extrarank"}) then
	return false
end

if SERVER then
	AddCSLuaFile("sh_hud.lua")
	AddCSLuaFile("cl_hud.lua")

	include("sh_hud.lua")
end

if CLIENT then
	include("sh_hud.lua")
	include("cl_hud.lua")
end
--gamemodes/starwarsrp/gamemode/modules/hud/sh_hud.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--    on official 'Einfach Gaming'   --
--     servers owned by 'P4sca1'     --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Shared | HUD            --
---------------------------------------

Faction:AddProperty("isCloneFaction", "boolean", false, function(faction, value)
	if not isbool(value) then
		return false, egmt("shared.invalid_type")
	end

	return true
end,
function(faction, ply)
	return true
end)

Faction:AddProperty("factionAlias", "number", -1, function(fact, value)
	if value == nil then
		value = -1
	end

	if not isnumber(value) then
		return false, egmt("extrafaction.id_no_number")
	end

	if value == -1 then
		return true
	end

	local faction = Faction:GetCached(value)

	if not faction then
		return false, egmt("extrafaction.not_valid")
	end

	return true
end,
function(faction, ply)
	return true
end)

Rank:AddProperty("factionAlias", "number", -1, function(rank, value)
	if value == nil then
		value = -1
	end

	if not isnumber(value) then
		return false, egmt("extrafaction.id_no_number")
	end

	if value == -1 then
		return true
	end

	local faction = Faction:GetCached(value)

	if not faction then
		return false, egmt("extrafaction.not_valid")
	end

	return true
end,
function(rank, ply)
	return true
end)
--gamemodes/starwarsrp/gamemode/modules/hud/styles/default/cl_colors.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Default UI | Colors        --
---------------------------------------

-- Main Background Color
UI.BackgroundColor = GetColor("darkgray", 200)

-- Secondary Background Color
UI.BackgroundColor2 = GetColor("gray", 250)

-- Main Foreground Color
UI.ForegroundColor = Color(21, 101, 192)

-- Secondary Foreground Color
UI.ForegroundColor2 = GetColor("blue")

-- Accent Color
UI.TextColor = GetColor("white")

-- Danger Color
UI.DangerColor = GetColor("red")

-- Success Color
UI.SuccessColor = GetColor("green")
--gamemodes/starwarsrp/gamemode/modules/ammoperk/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Index | Ammo Perk         --
---------------------------------------

AmmoPerk = AmmoPerk || {}

if SERVER then
	AddCSLuaFile("cl_perk.lua")
	AddCSLuaFile("sh_perk.lua")

	include("sh_perk.lua")
	include("sv_perk.lua")
end

if CLIENT then
	include("sh_perk.lua")
	include("cl_perk.lua")
end
--gamemodes/starwarsrp/gamemode/modules/ammoperk/sh_perk.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
-- Copyright © 2020 Pascal Sthamer,  --
--      Konstantin Zisiadis und      --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Ammo Perk | Shared         --
---------------------------------------

-- Calculates the ammo multiply
--
-- @param? Player ply
function AmmoPerk:GetAmmoMultiply(ply)
	local char = ply:GetCurrentCharacter()
	local ammoMultiply = 1 -- Default (100%)

	if not char then return end

	local perks = char:GetProperty("perks", {})

	if perks.ammo and Experience.Perks.ammo.values[perks.ammo] then
		ammoMultiply = Experience.Perks.ammo.values[perks.ammo].value || 1
	end

	return ammoMultiply
end
--gamemodes/egmrp/gamemode/modules/realism/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Realism index           --
---------------------------------------

Realism = Realism or {}

if SERVER then
    AddCSLuaFile("sh_config.lua")
    AddCSLuaFile("sh_movement.lua")
    AddCSLuaFile("sh_staminasystem.lua")
    AddCSLuaFile("sh_watersystem.lua")

    include("sh_config.lua")
    include("sh_movement.lua")
    include("sh_staminasystem.lua")
    include("sh_watersystem.lua")
    include("sv_realisticdamage.lua")
end

if CLIENT then
    include("sh_config.lua")
    include("sh_movement.lua")
    include("sh_staminasystem.lua")
    include("sh_watersystem.lua")
end
--gamemodes/starwarsrp/gamemode/modules/lightsaber_crafting/cl_adminmenu.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--        Lightsaber Crafting        --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--     Lightsaber Crafting | CL      --
---------------------------------------

local w,h = ScrW(), ScrH()

local blur = Material 'pp/blurscreen'
local function blurpanel (panel, amount )
    local x, y = panel:LocalToScreen(0, 0)
    surface.SetDrawColor(255, 255, 255)
    surface.SetMaterial(blur)
    for i = 1, 3 do
        blur:SetFloat('$blur', (i / 3) * (amount or 6))
        blur:Recompute()
        render.UpdateScreenEffectTexture()
        surface.DrawTexturedRect(x * -1, y * -1, ScrW(), ScrH())
    end
end

if not wOS or not wOS.ALCS then return end

function wOS.ALCS.Admin:OpenAdminMenu()
	if self.AdminMenu then
		if self.AdminMenu:IsVisible() then
			self.AdminMenu:Remove()
			self.AdminMenu = nil
			gui.EnableScreenClicker(false)
			return
		end
	end

	gui.EnableScreenClicker(true)
	wOS.ALCS.Admin.BufferInfo = {}

	local mw, mh = w*0.5, h*0.5

	local padx, pady = mw*0.01, mw*0.01
	local bpady = mh*0.01
	local basew, baseh = mw*0.25, mh
	local cw, ch = ( basew - 1.5*padx ), baseh - 2*pady

	self.AdminMenu = vgui.Create( "DPanel" )
	self.AdminMenu:SetSize( mw, mh )
	self.AdminMenu:Center()
	self.AdminMenu.Color = { r = 25, g = 25, b = 25, a = 155 }
	self.AdminMenu.Paint = function( pan, ww, hh )
		if not vgui.CursorVisible() then gui.EnableScreenClicker( true ) end
		blurpanel( pan )
		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )
		surface.SetDrawColor( color_white )
		surface.DrawOutlinedRect( padx, pady, ww*0.25, hh - 2*pady )
		surface.DrawOutlinedRect( ww*0.25 + 2*padx, pady, ww*0.75 - 3*padx, hh - 2*pady )
	end

	local PlayerKeys = {}
	local SelectedPlayer = nil
	local PlayerList = vgui.Create( "DListView", self.AdminMenu )
	PlayerList:SetMultiSelect( false )
	PlayerList:AddColumn( "Player" )
	PlayerList:AddColumn( "Steam64" )
	PlayerList:SetPos( mw*0.25 + 3*padx, 2*pady )
	PlayerList:SetSize( mw*0.33, mh - 4*pady )
	PlayerList.PlayerKeys = {}
	PlayerList.RePopulateList = function( pan )
		SelectedPlayer = nil
		pan:Clear()
		PlayerKeys = {}
		local i = 1
		for _, ply in pairs( player.GetAll() ) do
			PlayerKeys[ i ] = ply
			PlayerList:AddLine( ply:Nick(), ply:SteamID64() )
			i = i + 1
		end
	end

	self.DataTab = vgui.Create( "DPanel", self.AdminMenu )
	self.DataTab:SetPos( mw*0.58 + 4*padx, 2*pady )
	self.DataTab:SetSize( mw*0.33, mh - 4*pady )
	self.DataTab.Paint = function() end
	self.DataTab.SelectedTab = "OpenSkillLevelMenu"

	PlayerList.SelectedPlayer = nil
	PlayerList.OnRowSelected = function( lst, index, pnl )
		SelectedPlayer = PlayerKeys[ index ]
		wOS.ALCS.Admin.BufferInfo = {}
		if not self[ self.DataTab.SelectedTab ] then return end
		self[ self.DataTab.SelectedTab ]( self, SelectedPlayer )
	end
	PlayerList.Think = function( pan )
		if ( !SelectedPlayer or !SelectedPlayer:IsValid() ) and self[ self.DataTab.SelectedTab ] then
			self.DataTab:Clear()
		end
	end
	PlayerList.RePopulateList( PlayerList )

	local AScrollPan = vgui.Create( "DScrollPanel", self.AdminMenu )
	AScrollPan:SetSize( mw*0.25, mh - 2*pady )
	AScrollPan:SetPos( 2*padx, pady )
	AScrollPan.Paint = function( pan, ww, hh ) end

	local sbar = AScrollPan:GetVBar()
	function sbar:Paint( w, h ) end
	function sbar.btnUp:Paint( w, h ) end
	function sbar.btnDown:Paint( w, h ) end
	function sbar.btnGrip:Paint( w, h ) end

	local button = vgui.Create( "DButton", self.AdminMenu )
	button:SetSize( mw*0.025, mw*0.025 )
	button:SetPos( mw*0.96, mw*0.015 )
	button:SetText( "" )
	button.Paint = function( pan, ww, hh )
		surface.SetDrawColor( Color( 255, 0, 0, 255 ) )
		surface.DrawLine( 0, 0, ww, hh )
		surface.DrawLine( 0, hh, ww, 0 )
	end
	button.DoClick = function( pan )
		self:OpenAdminMenu()
		gui.EnableScreenClicker( false )
	end

	local base = 2*pady
	local aw, ah = AScrollPan:GetSize()

	local SkillTab = vgui.Create( "DButton", AScrollPan )
	SkillTab:SetPos( padx, base )
	SkillTab:SetSize( aw - 4*padx, mh*0.07 )
	SkillTab:SetText( "" )
	SkillTab.Paint = function( pan, ww, hh )
		local col = Color( 155, 155, 155, 155 )
		if pan:IsDown() then
			col = Color( 0, 55, 155, 155 )
		elseif self.DataTab.SelectedTab == "OpenSkillLevelMenu" then
			col = Color( 55, 110, 210, 155 )
		end
		draw.RoundedBox( 5, 0, 0, ww, hh, col  )
		draw.SimpleText( "Skills Menu", "wOS.AdminFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	SkillTab.DoClick = function()
		self.DataTab.SelectedTab = "OpenSkillLevelMenu"
		PlayerList.RePopulateList( PlayerList )
	end
	base = base + 2*pady + mh*0.07

	local CInvTab = vgui.Create( "DButton", AScrollPan )
	CInvTab:SetPos( padx, base )
	CInvTab:SetSize( aw - 4 * padx, mh * 0.07 )
	CInvTab:SetText( "" )
	CInvTab.Paint = function( pan, ww, hh )
		local col = Color( 155, 155, 155, 155 )
		if pan:IsDown() then
			col = Color( 0, 55, 155, 155 )
		elseif self.DataTab.SelectedTab == "OpenCraftInvMenu" then
			col = Color( 55, 110, 210, 155 )
		end
		draw.RoundedBox( 5, 0, 0, ww, hh, col  )
		draw.SimpleText( "Inventory Menu", "wOS.AdminFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	CInvTab.DoClick = function()
		self.DataTab.SelectedTab = "OpenCraftInvMenu"
		PlayerList.RePopulateList( PlayerList )
	end
end

function wOS.ALCS.Admin:OpenCraftInvMenu(ply)
	self.DataTab:Clear()

	local mw, mh = w*0.5, h*0.5
	local padx, pady = mw*0.01, mw*0.01
	local bpady = mh*0.01
	local basew, baseh = mw*0.25, mh
	local cw, ch = ( basew - 1.5*padx ), baseh - 2*pady
	local ww, hh = self.DataTab:GetSize()
	local posx, posy = self.DataTab:GetPos()
	local possx, possy = self.AdminMenu:GetPos()
	posx = possx + posx
	posy = possy + posy

	local ItemList = vgui.Create( "DListView", self.DataTab )
	ItemList:SetMultiSelect( false )
	ItemList:AddColumn( "Item Name" )
	ItemList:SetPos( padx, pady  )
	ItemList:SetSize( ww - 2*padx, hh*0.4 )

	//MANUAL SORTING SORT OF!!!
	//Could probably use a function in table.sort but whatever
	local lst = {}
	for item, dat in pairs( wOS.ItemList ) do
		if dat.Type == WOSTYPE.RAWMATERIAL then continue end
		if table.HasValue(LightsaberCrafting.DonatorPackets, dat.Name) then continue end

		lst[ #lst + 1 ] = item
	end

	table.sort(lst)

	for _, item in pairs( lst ) do
		ItemList:AddLine( item )
	end

	local AddL = vgui.Create( "DButton", self.DataTab )
	AddL:SetPos( padx, 2*pady + hh*0.4 )
	AddL:SetSize( ww - 2*padx, hh*0.05 )
	AddL:SetText( "" )
	AddL.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "GEGENSTAND HINZUFÜGEN", "wOS.ALCS.DescFont", ww / 2, hh / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	AddL.DoClick = function()
		local sel = ItemList:GetSelectedLine()
		if not sel or sel < 1 then return end

		local dat = ItemList:GetLine( sel )
		if not dat then return end

		local item = dat:GetColumnText( 1 )
		if not item or #item < 1 then return end

		wOS.ALCS.Admin.BufferInfo = {}

		net.Start( "LightsaberCrafting.AdminAddItem" )
			net.WriteString(item)
			net.WriteEntity(ply)
		net.SendToServer()
	end

	local InvenList = vgui.Create( "DListView", self.DataTab )
	InvenList:SetMultiSelect( false )
	InvenList:AddColumn( "Slot" )
	InvenList:AddColumn( "Item" )
	InvenList:SetPos( padx , 3 * pady + hh * 0.45 )
	InvenList:SetSize( ww - 2 * padx, hh * 0.4 - 3 * pady )
	InvenList.Think = function(pan)
		local character = ply:GetCurrentCharacter()
		if not character then return end

		local inventory = character:GetProperty("lightsaberInv", {})
		if not pan.Refreshed then
			InvenList:Clear()
			for i = 1, math.max(table.maxn(inventory), LightsaberCrafting.InventorySize) do
				local name = "Leer"
				if inventory[i] then
					name = inventory[i]
				end

				InvenList:AddLine(i, name)
			end
			pan.Refreshed = true
		end
	end

	local RemoveItem = vgui.Create( "DButton", self.DataTab )
	RemoveItem:SetPos( padx, hh*0.85 + pady )
	RemoveItem:SetSize( ww - 2*padx, hh*0.05 )
	RemoveItem:SetText( "" )
	RemoveItem.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText("GEGENSTAND ENTFERNEN", "wOS.ALCS.DescFont", ww/2, hh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	RemoveItem.DoClick = function()
		local sel = InvenList:GetSelectedLine()
		if not sel or sel < 1 then return end

		local dat = InvenList:GetLine( sel )
		if not dat then return end

		local id = dat:GetColumnText( 1 )
		if not id then return end

		net.Start("LightsaberCrafting.AdminRemoveItem")
			net.WriteInt(id, 6)
			net.WriteEntity(ply)
		net.SendToServer()
	end

	-- Refresh menu when a character property / data got changed.
	hook.Add("Character.PropertyChanged", "LightsaberCrafting.AdminInventoryUpdated", function(character, key, value, oldValue)
		if IsValid(wOS.ALCS.Admin.AdminMenu) and character:GetOwner() == ply and key == "lightsaberInv" then
			wOS.ALCS.Admin:OpenCraftInvMenu(ply)
		end
	end)
end
--gamemodes/egmrp/gamemode/modules/course/cl_course.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Course | Client          --
---------------------------------------

-- Clear property list to avoid duplicate entries.
Course.PropertyList = {}

-- Add course properties to list. These are editable in course creation and edit.
Course:AddPropertyToList("name", egmt("course.name"), egmt("course.name_description"), "string", nil, nil, 1, nil)

Course:AddPropertyToList("short", egmt("course.short"), egmt("course.short_description"), "string", nil, nil, 2, nil)

Course:AddPropertyToList("isPrefix", egmt("course.isPrefix"), egmt("course.isPrefix_description"), "boolean", function()
    return {egmt("course.isPrefix_yes"), egmt("course.isPrefix_no")}
end, nil, 3, nil)

Course:AddPropertyToList("shortOnName", egmt("course.shortOnName"), egmt("course.shortOnName_description"), "boolean", nil, nil, 4, nil)

Course:AddPropertyToList("shortOnPrefix", egmt("course.shortOnPrefix"), egmt("course.shortOnPrefix_description"), "boolean", nil, nil, 5, nil)

Course:AddPropertyToList("inheritCourse", egmt("course.inherit"), egmt("course.inherit_description"), "boolean", nil, nil, 6, nil)

Character:AddPropertyToList("courses", egmt("course.character"), egmt("course.character_description"), "table", function(rank, faction, character)
	local values = {
		validValues = {},
		detailedPermissions = true
	}

	for _, course in pairs(character:GetAvailableCourses()) do
		local name = course:GetName()

		if not faction:HasCourse(course) then
			local cFaction = course:GetFaction()
			if cFaction ~= faction then
				name = cFaction:GetName() .. " - " .. name
			end
		end

		values.validValues[course:GetId()] = name
	end

	return values
end, nil, 10, nil)

Equipment:AddPropertyToList("requiredCourses", egmt("course.equipment"), egmt("course.equipment_description"), "table", function(faction, equipment)
	local values = {
		validValues = {}
	}

	for _, course in pairs(faction:GetCourses()) do
		values.validValues[course:GetId()] = course:GetName()
	end

	return values
end, nil, 3, egmt("equipment.conditions"))

-- Register course package type.
Loading:RegisterPackageType("course", egmt("course.package"), function(packageData)
    for k, cData in pairs(packageData) do
        Course:Load(cData.data, cData.properties):Cache()
    end
end)
--gamemodes/starwarsrp/gamemode/modules/weaponutil/item_classes/weapon_dual/shared.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Shared | Weapon Item       --
---------------------------------------

-- This Item Class is used for weapons, which can be equipped and used by the player.
-- A single weapon cannot be equipped more than once, but multiple weapons can be equipped together, depending on the slots.

local ITEM_CLASS = ITEM_CLASS

-- Base Item class, from which functions and such should be inherited.
ITEM_CLASS.BaseItemClass = "weapon"

-- List of item slots, which the item can be equipped to.
ITEM_CLASS.Slots = {
	"weapon_small",
	"weapon_consealed",
	"backpack",
}

-- Sorting order of the item.
ITEM_CLASS.Sort = 120

-- Helper boolean to check if the item is a duals weapon item.
ITEM_CLASS.IsDuals = true



---------------------------------------
--        Item Class Function        --
---------------------------------------

-- Check, if the item can be added to the given slot.
--
-- @param Table inventory
-- @param ItemType itemType
-- @param Table itemData
-- @param? String slotType
-- @return Boolean canAdd
-- @return? String error
function ITEM_CLASS:CanEquipInto(inventory, itemType, itemData, slotType)
	-- Ignore other items if the target is not an equipment slot.
	local slotTypeClass = Inventory:GetItemSlotClass(slotType)
	if istable(slotTypeClass) and slotTypeClass.Equipment then
		-- Prevent the same weapon from being equipped twice.
		local successFind, ammount = self:FindOtherItem(inventory, itemData, true, true)
		if successFind and ammount > 1 then
			return false, "You can only equip two of this weapon."
		end
	end

	local success, err = ITEM_CLASS.Base.CanEquipInto(self, inventory, itemType, itemData, slotType)
	if not success then
		return false, err
	end

	return true
end
--gamemodes/egmrp/gamemode/modules/familyshare/sh_index.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--       Family Share | Index        --
---------------------------------------

FamilyShare = FamilyShare or {}

if SERVER then
    include("sv_familyshare.lua")
end
--gamemodes/starwarsrp/gamemode/modules/pronemod/cl_keybinds.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--         ProneMod Extension        --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      ProneMod Extension | CL      --
---------------------------------------

-- Add a keybind for opening the character manager.
KeyBind:Register("Hinlegen", egmt("shared.normal"), function() end, ProneMod.DefaultKey)
--gamemodes/starwarsrp/gamemode/modules/rakghoul/sh_rakghoul.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--             Rakghoul              --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--           Rakghoul | SH           --
---------------------------------------

local PLAYER = FindMetaTable("Player")

function PLAYER:IsImmune()
	return self:GetNWFloat("Rakghoul.Immunity", 0) >= CurTime()
end

function PLAYER:SetImmunity(time)
	self:SetNWFloat("Rakghoul.Immunity", time)
end

function PLAYER:SetRakghoul(rakghoul)
	self:SetNWBool("IsRakghoul", rakghoul)
end

function PLAYER:IsRakghoul()
	return self:GetNWBool("IsRakghoul", false)
end

function PLAYER:IsTransforming()
	return timer.Exists("Rakghoul.Transforming_" .. self:SteamID64())
end

-- Replaces the rakghoul footstep
--
-- @param? Player ply
hook.Add("PlayerFootstep", "Rakghoul:Footstep", function(ply)
	if ply:IsRakghoul() then
		return true
	end
end)
--gamemodes/starwarsrp/gamemode/modules/rakghoul/weapons/weapon_swrp_rakghoul_swep/shared.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--             Rakghoul              --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--           Rakghoul | SH           --
---------------------------------------

SWEP.Base 				= "weapon_base"

SWEP.PrintName			= "Rakghoul SWEP"
SWEP.Category			= "SW:RP (Sonstiges)"

SWEP.Author				= "Sargon & Deltaa"
SWEP.Purpose			= "Linksklick: Schlage einen Spieler \nRechtsklick: Springe!"
SWEP.Slot				= 0
SWEP.SlotPos			= 1
SWEP.DrawAmmo			= false

SWEP.Spawnable			= false
SWEP.AdminOnly			= true
SWEP.ViewModel 			= "models/weapons/c_arms_citizen.mdl"
SWEP.WorldModel			= ""
SWEP.ViewModelFOV 		= 50
SWEP.ViewModelFlip 		= false
SWEP.DrawCrosshair		= false

SWEP.Weight				= 1
SWEP.AutoSwitchTo		= true
SWEP.AutoSwitchFrom		= false

SWEP.Primary 			= {}
SWEP.Primary.Damage		= 50
SWEP.Primary.Automatic	= true

SWEP.AnimDelay      	= 0
SWEP.ReloadDelay    	= 0

SWEP.NextHealth 		= 0

SWEP.AttackAnims		= {
	"fists_left",
	"fists_right"
}

SWEP.FleshSound	= {
	"physics/flesh/flesh_squishy_impact_hard1.wav",
	"physics/flesh/flesh_squishy_impact_hard2.wav",
	"physics/flesh/flesh_squishy_impact_hard3.wav",
	"physics/flesh/flesh_squishy_impact_hard4.wav"
}

SWEP.AttackSound = {
	"npc/antlion_guard/angry1.wav",
	"npc/antlion_guard/angry2.wav",
	"npc/antlion_guard/angry3.wav"
}

SWEP.HitSound	= {
	"npc/zombie/claw_strike1.wav",
	"npc/zombie/claw_strike2.wav",
	"npc/zombie/claw_strike3.wav"
}

SWEP.SwingSound	= {
	"npc/zombie/claw_miss1.wav",
	"npc/zombie/claw_miss2.wav"
}

function SWEP:Initialize()
	self:SetHoldType("knife")
	self:SendWeaponAnim(ACT_HL2MP_IDLE_KNIFE)

	self.NextHealthReg = CurTime()
end

function SWEP:Think()
	if self.AnimDelay > CurTime() then return end

	local owner = self:GetOwner()

	if owner:KeyDown(IN_FORWARD) and !owner:KeyDown(IN_DUCK) and owner:IsOnGround() then
		owner:DoAnimationEvent(ACT_HL2MP_RUN_ZOMBIE_FAST)

		self.AnimDelay = CurTime() + 0.4
	elseif !owner:IsOnGround() then
		owner:DoAnimationEvent(ACT_ZOMBIE_LEAPING)

		self.AnimDelay = CurTime() + 0.4
	end

	if SERVER and self.NextHealthReg <= CurTime() then
		self:RegenerateHealth()
	end
end

function SWEP:Deploy()
	local vm = self:GetOwner():GetViewModel()
	vm:ResetSequence( vm:LookupSequence( "fists_draw" ) )
end



--gamemodes/starwarsrp/gamemode/config/cl_escapescreen.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--   Client | Escape screen config   --
---------------------------------------

-- The background used in the escape screen.
EscapeScreen.Background = "materials/wallpaper/final.jpg"

-- The buttons in the escape screen.
EscapeScreen.Buttons = {
	{
		name = "Weiterspielen",
		func = function()
			EscapeScreen:Close()
		end
	},
	{
		name = "Server Browser",
		func = function()
			RunConsoleCommand("gamemenucommand", "openserverbrowser")
			gui.ActivateGameUI()
		end
	},
	{
		name = "Keybinds",
		dockTop = 0.03,
		func = function()
			KeyBind:OpenMenu()
		end
	},
	{
		name = "EGM:RP Einstellungen",
		func = function()
			Settings:OpenMenu()
		end
	},
	{
		name = "Charakterauswahl",
		func = function()
			CharacterSelection:Open()
			EscapeScreen:Close()
		end
	},
	{
		name = "Forum",
		dockTop = 0.03,
		func = function()
			gui.OpenURL("https://www.einfach-gaming.de")
		end
	},
	{
		name = "Discord",
		func = function()
			gui.OpenURL("https://discord.com/invite/DnV5fhW")
		end
	},
	{
		name = "Steamgruppe",
		func = function()
			gui.OpenURL("https://steamcommunity.com/groups/egmcommunity")
		end
	},
	{
		name = "Regelwerk",
		func = function()
			gui.OpenURL("https://www.einfach-gaming.de/wiki/entry/77-regeln-cw-rp/")
		end
	},
	{
		name = "Einstellungen",
		dockTop = 0.03,
		func = function()
			RunConsoleCommand("gamemenucommand", "openoptionsdialog")
			gui.ActivateGameUI()
		end
	},
--	{
--		name = "Konsole",
--		func = function()
--			RunConsoleCommand("showconsole")
--			gui.ActivateGameUI()
--		end
--	},
	{
		name = "Server verlassen",
		func = function()
			RunConsoleCommand("disconnect")
		end
    }
}
--gamemodes/starwarsrp/gamemode/config/cl_manager.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Manager | Config         --
---------------------------------------

-- Background for the manager.
Manager.Background = "materials/wallpaper/final.jpg"

-- Default keybind for opening the manager.
Manager.DefaultKey = KEY_F6

-- Minimum group, for accessing the manager.
-- Access to actually change the properties is still required, to do anything.
Manager.MinAccessGroup = "admin"

-- Default category for the manager.
Manager.DefaultCategory = "Faction"

-- Hides all weapons, that do not have the "spawnable" flag.
Manager.HideUnspawnableWeapons = true

--gamemodes/starwarsrp/gamemode/config/sh_course.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Course | Config          --
---------------------------------------

-- Minimum usergroup to edit Courses.
Course.MinAccessGroup = "admin"

-- Minimum usergroup to assign Courses.
Course.MinAssignGroup = "testmoderator"
--gamemodes/starwarsrp/gamemode/config/sh_faction.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Factionrank Config         --
---------------------------------------

-- Minimum user groups that is allowed, to edit factions.
Faction.MinAccessGroup = "admin"
--gamemodes/starwarsrp/gamemode/config/sh_inventory.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--         Config | Inventory        --
---------------------------------------

-- Minimum user groups that is allowed, to edit item types.
ItemType.MinAccessGroup = "admin"

-- Minimum delay between inventory actions.
Inventory.NetworkDelay = 0.5

-- Timeframe in which the player should not drop > 10 items.
Inventory.DropDelay = 60

-- Slots for the player inventory.
Inventory.PlayerInventorySlots = {
	head = {
		Type = "head",
		Hidden = true,

		X = 0,
		Y = 0,
		Align = ITEM_SLOT_LEFT,
	},

	body = {
		Type = "body",

		X = 0,
		Y = 1,
		Align = ITEM_SLOT_LEFT,
	},
	back = {
		Type = "back",
		Hidden = true,

		X = 5,
		Y = 1,
		Align = ITEM_SLOT_RIGHT,

		HolsterBone = "ValveBiped.Bip01_Spine2",
		HolsterOffset = Vector(8, 0, 0),
		HolsterAngle = Angle(180, 0, 90),
		HolsterAlign = ITEM_SLOT_LEFT,
	},

	bigL = {
		Type = "weapon_big",

		X = 0,
		Y = 2,
		Align = ITEM_SLOT_LEFT,

		HolsterBone = "ValveBiped.Bip01_Spine2",
		HolsterOffset = Vector(2, -3, -5),
		HolsterAngle = Angle(178, 180, -90),
		HolsterAlign = ITEM_SLOT_RIGHT,
	},
	bigR = {
		Type = "weapon_big",

		X = 5,
		Y = 2,
		Align = ITEM_SLOT_RIGHT,

		HolsterBone = "ValveBiped.Bip01_Spine2",
		HolsterOffset = Vector(2, -3, 5),
		HolsterAngle = Angle(178, 180, -90),
		HolsterAlign = ITEM_SLOT_LEFT,
	},

	beltL = {
		Type = "belt",

		X = 0,
		Y = 3,
		Align = ITEM_SLOT_LEFT,
	},
	beltR = {
		Type = "belt",

		X = 5,
		Y = 3,
		Align = ITEM_SLOT_RIGHT,
	},

	smallL = {
		Type = "weapon_small",

		X = 0,
		Y = 4,
		Align = ITEM_SLOT_LEFT,

		HolsterBone = "ValveBiped.Bip01_R_Thigh",
		HolsterOffset = Vector(2.5, -1.5, -5.2),
		HolsterAngle = Angle(182.5, -3, 100),
		HolsterAlign = ITEM_SLOT_RIGHT,
	},
	smallR = {
		Type = "weapon_small",

		X = 5,
		Y = 4,
		Align = ITEM_SLOT_RIGHT,

		HolsterBone = "ValveBiped.Bip01_L_Thigh",
		HolsterOffset = Vector(2.5, -1.5, 5.6),
		HolsterAngle = Angle(178, -3, 80),
		HolsterAlign = ITEM_SLOT_LEFT,
	},

	weapon_consealed = {
		Type = "weapon_consealed",
		Hidden = true,

		X = 2.5,
		Y = 4,
		Align = ITEM_SLOT_CENTER,
	},

	backpack = {
		Type = "backpack",
		Hidden = true,
		MinimumCount = 5,

		X = 0,
		Y = 6,
		Align = ITEM_SLOT_LEFT_TOP,
	}
}

-- Default key for opening the inventory.
Inventory.DefaultKey = KEY_I

-- Fallback models for weapons, if the model is not found.
-- Used by default for the non-scripted weapons.
Inventory.FallbackWeaponModel = {
	["weapon_357"] = "models/weapons/w_357.mdl",
	["weapon_pistol"] = "models/weapons/w_pistol.mdl",
	["weapon_crossbow"] = "models/weapons/w_crossbow.mdl",
	["weapon_ar2"] = "models/weapons/w_irifle.mdl",
	["weapon_rpg"] = "models/weapons/w_rocket_launcher.mdl",
	["weapon_shotgun"] = "models/weapons/w_shotgun.mdl",
	["weapon_smg1"] = "models/weapons/w_smg1.mdl",

	["weapon_frag"] = "models/weapons/w_grenade.mdl",
	["weapon_slam"] = "models/weapons/w_slam.mdl",

	["weapon_crowbar"] = "models/weapons/melee/w_crowbar.mdl",
	["weapon_stunstick"] = "models/weapons/w_stunbaton.mdl",
}

-- Fallback offsets and angles for the holsters.
-- Used by default for the non-scripted weapons.
Inventory.FallbackWeaponHolster = {}

-- List of rarity names and their colors.
Inventory.Rarities = {
	[1] = {
		Name = egmt("inventory.rarity.common"),
		Color = Color(21, 101, 192)
	},
	[2] = {
		Name = egmt("inventory.rarity.uncommon"),
		Color = Color(75, 213, 238)
	},
	[3] = {
		Name = egmt("inventory.rarity.rare"),
		Color = Color(0, 255, 0)
	},
	[4] = {
		Name = egmt("inventory.rarity.epic"),
		Color = Color(255, 0, 255)
	},
	[5] = {
		Name = egmt("inventory.rarity.legendary"),
		Color = Color(255, 128, 0)
	}
}

-- Should weapons be exclusive to a single item type?
Inventory.ExclusiveWeapons = true

-- Can a player access another players inventory by default?
Inventory.DefaultAccessPlayer = false

-- Can a player access a corpses inventory by default?
Inventory.DefaultAccessCorpse = true
--gamemodes/starwarsrp/gamemode/config/sh_inventory_storage.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--     Config | Inventory Storage    --
---------------------------------------

-- Fallback model for the storage entity.
InventoryStorage.Model = "models/lordtrilobite/starwars/props/kyber_crate_phys.mdl"

-- Default mode for the storage entity.
InventoryStorage.DefaultMode = "supply"
--gamemodes/starwarsrp/gamemode/config/sh_multiserver.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--        Multiserver | Config       --
---------------------------------------

-- Message that is given when the group has reached it's maximum Capacity.
MultiServer.ServerFullMsg = [[
----------------------Servergruppe voll------------------------

Die Maximale Anzahl an Spielern dieser Servergruppe ist ereicht.

---------------------------------------------------------------]]

-- If the server allows normal connects.
-- If set to false only connects from another server in the group are allowed
MultiServer.AllowConnect = true

-- Message that is returned when connecting onto a server wich does not allow direct connect.
MultiServer.DenyConnectMessage = [[
-------------------------Eventserver---------------------------

Bitte verbinde dich mit dem Hauptserver.

---------------------------------------------------------------]]

-- Minimum Range at wich you are allowed so send somebody to another server.
MultiServer.MinimumChangeServerRank = "eventleiter"

-- Table of teammember ranks which should be able to join. (False to disable)
MultiServer.DirectJoinGroups = {
	"eventleiter",
	"testmoderator",
	"moderator",
	"seniormoderator",
	"admin",
	"superadmin",
	"communityleitung",
	"gruender"
}

-- Disable the Atlas Chat Join/Disconnect Message. Only needed when Atlas Chat is installed.
MultiServer.DisableAtlasChatMessages = false
--gamemodes/starwarsrp/gamemode/config/sh_rank.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--           Rank | Config           --
---------------------------------------

-- Every possible slot type a rank can have.
Rank.SlotTypes = {
	mainSlot = {
		name = "Hauptcharakter",
		usesGlobalSlot = true,
		slots = function(ply)
			local limit = 2

			-- Adds a non lore package for commanders
			if ply:IsDonator("nonlore") then
				limit = limit + 1
			end

			-- Adds a third character package
			if ply:IsDonator("mainChar") then
				limit = limit + 1
			end

			return limit
		end
	},
	sideSlot = {
		name = "Nebencharakter",
		usesGlobalSlot = true,
		slots = function(ply)
			return Rank.MaxGlobalSlots(ply)
		end
	},
	noSlot = {
		name = "Kein Slot",
		usesGlobalSlot = false,
		slots = function(ply)
			return -1
		end
	},
	event = {
		name = "Eventcharakter",
		usesGlobalSlot = false,
		slots = function(ply)
			return 3
		end
	}
}

-- The default slot type of a rank.
Rank.DefaultSlotType = "mainSlot"

-- Function to return the maximum number of slots.
Rank.MaxGlobalSlots = function(ply)
	local limit = 3

	if ply.IsDonator and (ply:IsDonator("donator") or ply:IsDonator("customChar") or ply:IsDonator("vip")) then
		limit = limit + 2
	end

	-- Adds a non lore package for commanders
	if ply:IsDonator("nonlore") then
		limit = limit + 1
	end

	-- Adds a third character package
	if ply:IsDonator("mainChar") then
		limit = limit + 1
	end

	return limit
end
--gamemodes/starwarsrp/gamemode/config/sh_realism.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--          Realism config           --
---------------------------------------

-- Whether to disable the ability to sprint backwards.
Realism.DisableBackwardSprinting = true

-- Whether to remove footstep sounds when crouching (holding ctrl by default).
Realism.RemoveFootstepsWhenCrouching = true

-- Velocity is divided by this value to calculate the falldamage.
Realism.FallDamageDividor = 8

-- Wheter to enable the stamina system.
Realism.StaminaSystemEnabled = false

-- Maximum amount of stamina.
Realism.MaxStamina = 100

-- Amount of stamina that gets lost per second while sprinting
Realism.StaminaLoose = 5

-- Amound of stamina the player regenerates per second when not in sprint
Realism.StaminaRegeneration = 10

-- Whether to enable the water (drowning and extinguish) system.
Realism.WaterSystemEnabled = false

-- Maximum amount of oxygen.
Realism.MaxOxygen = 600

-- Amount of oxygen that gets lost per second when under water
Realism.OxygenLoose = 1

-- Amound of oxygen the player regenerates per second when out of water.
Realism.OxygenRegeneration = 10

-- Amount of damage that the player takes per second while drowning.
Realism.DrowningDamage = 10

-- Whether the realistig damage system is enabled
Realism.DamageSystemEnabled = true

-- Realistic damage multipliers.
Realism.HeadDamageMultiplier = 2.5
Realism.ChestDamageMultiplier = 1
Realism.StomachDamageMultiplier = 0.75
Realism.ArmDamageMultiplier = 0.5
Realism.LegDamageMultiplier = 0.5

-- Whether the resistance system should be enabled.
Realism.ResistanceSystemEnabled = true

-- Player models that are resistant to specific damage types.
Realism.PlayerModelResistance = {
	[DMG_BURN] = {
		"models/egm/core/clone_synthmesh/clone_synthmesh.mdl", -- Synthmesh
		"models/egm/core/clone_commando/clone_commando.mdl", -- Clone Commando

		"models/egm/temp/mando_female/mando_female.mdl", -- Female Mandalorian Armor
		"models/egm/temp/mando_male/mando_male.mdl", -- Male Mandalorian Armor
	},
}

-- The time the breathing swep makes a player immune against the specified DMG_TYPES below
Realism.BreathingTime = 600

-- Against which DMG_Types  the Breathing SWEP makes resistant
Realism.BreathingResistance = {
	DMG_POISON,
	DMG_DROWN,
	DMG_NERVEGAS
}

-- Temporary list of droids since it is still in development
Realism.Droids = {
	["models/loic_buzzdroid/buzzdroid.mdl"] = true,
	["models/aussisengels/grievous/general_grievous.mdl"] = true,
	["models/player/b1battledroids/b1_base.mdl"] = true,
	["models/player/b1battledroids/b1_base_aatdriver.mdl"] = true,
	["models/player/b1battledroids/b1_base_com.mdl"] = true,
	["models/player/b1battledroids/b1_base_gen1.mdl"] = true,
	["models/player/b1battledroids/b1_base_pilot.mdl"] = true,
	["models/player/b1battledroids/b1_base_security.mdl"] = true,
	["models/player/b1battledroids/b1_base_training.mdl"] = true,
	["models/player/b1battledroids/b1_firefighter.mdl"] = true,
	["models/player/b1battledroids/b1_geo.mdl"] = true,
	["models/player/b1battledroids/b1_geo_com.mdl"] = true,
	["models/player/b1battledroids/b1_rocket.mdl"] = true,
	["models/sally/tkaro/bx_commando_droid.mdl"] = true,
	["models/player/hydro/b2_battledroid/b2_battledroid.mdl"] = true,
	["models/starwars/grady/protocol_droids/protocol-black.mdl"] = true,
	["models/player/tiki/proxy.mdl"] = true,
	["models/player/tiki/med_droid.mdl"] = true,
	["models/player/t3_01.mdl"] = true,
	["models/player/t3_02.mdl"] = true,
	["models/player/t3_03.mdl"] = true,
	["models/player/t3_04.mdl"] = true,
	["models/player/ig88/ig88.mdl"] = true,
	["models/player/jellik/starwars/highsinger.mdl"] = true,
	["models/player/valley/policedroid.mdl"] = true,
	["models/player/c3po.mdl"] = true,
	["models/player/r2d2.mdl"] = true,
	["models/kingpommes/starwars/misc/droids/gnk_550.mdl"] = true,
	["models/kingpommes/starwars/misc/droids/gnk_droid.mdl"] = true,
	["models/kingpommes/starwars/misc/droids/lin_droid.mdl"] = true,
	["models/kingpommes/starwars/misc/droids/mouse_droid.mdl"] = true,
	["models/kingpommes/starwars/misc/droids/r2_q5.mdl"] = true,
	["models/kingpommes/starwars/misc/droids/r4_i9.mdl"] = true,
	["models/kingpommes/starwars/misc/droids/r5_j2.mdl"] = true,
	["models/kingpommes/starwars/playermodels/astromech.mdl"] = true,
	["models/kingpommes/starwars/playermodels/gnk.mdl"] = true,
	["models/kingpommes/starwars/playermodels/lin.mdl"] = true,
	["models/kingpommes/starwars/playermodels/mouse.mdl"] = true,
	["models/kingpommes/starwars/playermodels/wed.mdl"] = true,
	["models/ace/sw/r2.mdl"] = true,
	["models/ace/sw/r4.mdl"] = true,
	["models/ace/sw/r5.mdl"] = true,
	["models/starwars/stan/droidekas/droideka.mdl"] = true,
	["models/npc/starwars/droidekas/droideka.mdl"] = true,
	["models/npc/starwars/crabby/crabdroid.mdl"] = true,
	["models/npc/starwars/dwarfspider/dwarfspiderdroid.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_magna_guard_trainer.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_magna_guard_combined.mdl"] = true,
	["models/tfa/comm/gg/pm_sw_magna_guard_season4.mdl"] = true,
	["models/player/swcw/std_kalani.mdl"] = true,
	["models/player/swcw/std_kraken.mdl"] = true,
	["models/player/swcw/std_auto.mdl"] = true,
	["models/npc_tactical_black/npc_droid_tactical_black_h.mdl"] = true,
	["models/npc_tactical_blue/npc_droid_tactical_blue_h.mdl"] = true,
	["models/npc_tactical_gold/npc_droid_tactical_gold_h.mdl"] = true,
	["models/npc_tactical_purple/npc_droid_tactical_purple_h.mdl"] = true,
	["models/npc_tactical_red/npc_droid_tactical_red_h.mdl"] = true,
	["models/dexton/91st/91st_pit_droid.mdl"] = true,
	["models/odd/nikout/swtor/player/hk51.mdl"] = true,
	["models/player/swtor/droids/bodyguard_droid.mdl"] = true,
	["models/player/swtor/droids/combat_medicaldroid.mdl"] = true,
	["models/player/swtor/droids/enforcerdroid.mdl"] = true,
	["models/player/swtor/droids/slicer_droid.mdl"] = true,
	["models/player/swtor/droids/worker_droid.mdl"] = true
}

--gamemodes/starwarsrp/gamemode/config/sh_reports.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--      Config | Reports System      --
---------------------------------------

-- Minimum group that has full access to the reports.
Reports.MinAccessGroup = "testmoderator"

-- Background for the reports menu.
Reports.Background = "materials/wallpaper/726it0u9h0j11.jpg"
--gamemodes/starwarsrp/gamemode/config/sh_special_character.lua:
---------------------------------------
---------------------------------------
--      Einfach Gaming Roleplay      --
--             (EGM:RP)              --
--                                   --
--            Created by             --
--      Pascal 'P4sca1' Sthamer,     --
--       Jan 'Oninoni' Ziegler,      --
--    Konstantin 'Airfox' Zisiadis,  --
--       Mattis 'Mattzi' Krämer      --
--                                   --
--   This software is only allowed   --
--  to be used with a valid license  --
--                                   --
--          Copyright ©2022          --
--         Mattis Krämer and         --
--          Jan Ziegler GbR          --
---------------------------------------
---------------------------------------

---------------------------------------
--    Config | Special Character    --
---------------------------------------
--  Variables should be overwritten  --
--     in the deriving gamemode!     --
---------------------------------------

-- Minimum usergroup to edit Courses.
SpecialCharacter.MinAccessGroup = "admin"

-- Minimum usergroup to assign Courses.
SpecialCharacter.MinAssignGroup = "testmoderator"
--addons/animations/lua/animations/cl_animations.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--             Jedi Bow            	 --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--         Client | Jedi Bow         --
---------------------------------------

-- Runs an animation
--
-- @param? String key
function Animations:RunAnim(key)
	if not Animations.Config[key] then return end

	net.Start("Animations.RunAnim")
		net.WriteString(key)
	net.SendToServer()
end

-- Setup the animation wheel
for anim, data in pairs(Animations.Config) do
	Interact:RegisterOption("emotes", data.name, data.sort, function()
		Animations:RunAnim(anim)
		Interact.Menu:Remove()
	end, function()
		if data.whitelist and not table.HasValue(data.whitelist, LocalPlayer():GetModel()) then
			return false
		end

		return true
	end)
end
--addons/wos-passiveevent/lua/wos/pes/vgui/wos_node.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































local PANEL = {}

function PANEL:DrawTriangleUp( cx, cy, w, h, color )

    local triangle = {
        { x = cx - w/2, y = cy + h/2 },
        { x = cx, y = cy - h/2 },
        { x = cx + w/2, y = cy + h/2 }
    }

    surface.SetDrawColor( color )
	draw.NoTexture()
	surface.DrawPoly( triangle )
end

function PANEL:DrawTriangleDown( cx, cy, w, h, color )

    local triangle = {
        { x = cx, y = cy + h/2 },
        { x = cx - w/2, y = cy - h/2 },
        { x = cx + w/2, y = cy - h/2 }
    }

    surface.SetDrawColor( color )
	draw.NoTexture()
	surface.DrawPoly( triangle )
end

function PANEL:DrawTriangleRight( cx, cy, w, h, color )

    local triangle = {
        { x = cx - w/2, y = cy - h/2 },
        { x = cx + w/2, y = cy },
        { x = cx - w/2, y = cy + h/2 },
    }

    surface.SetDrawColor( color )
	draw.NoTexture()
	surface.DrawPoly( triangle )
end

function PANEL:DrawTriangleLeft( cx, cy, w, h, color )

    local triangle = {
        { x = cx - w/2, y = cy },
        { x = cx + w/2, y = cy - h/2 },
        { x = cx + w/2, y = cy + h/2 },
    }

    surface.SetDrawColor( color )
	draw.NoTexture()
	surface.DrawPoly( triangle )
end

function PANEL:DrawRotatedBox( x, y, w, h, ang, color )
	draw.NoTexture()
	surface.SetDrawColor( color or color_white )
	surface.DrawTexturedRectRotated( x, y, w, h, ang )
end

PANEL.TriggerColorHierarchy = {
    Color( 0, 205, 0 ),
    Color( 50, 83, 205 ),   
    Color( 205, 0, 0 ),
    Color( 205, 205, 0 ),
    Color( 205, 0, 205 ),
    Color( 50, 205, 205 ),
}

// Applies to everything, including the current panel after INIT
local function ChildRecursive( self, child )
    child:NoClipping( false )
    child:SetPaintedManually( true )
    child.TestHover = self.TestHover
    child.GetBackground = function() return self:GetBackground() end
    child.GetCursorPos = self.GetCursorPos

    // If we start seeing issues with sub menus, fix this.
    if not child.DropButton then
        child.OnChildAdded = function( s, kid )
            ChildRecursive( s, kid )
        end
    end

    child.RecursiveManualPaint = function( pan )
        if not pan:IsVisible() then return end
        pan:PaintManual( true )
        for _, child in ipairs( pan:GetChildren() ) do
            if not child.RecursiveManualPaint then continue end
            if not child:IsVisible() then continue end
            child:RecursiveManualPaint()
        end        
    end

    for _, cpan in ipairs( child:GetChildren() ) do
        ChildRecursive( child, cpan )
    end

end

function PANEL:RecursiveManualPaint()
    if not self:IsVisible() then return end
    if not IsValid( self.vars ) then 
        self:PaintManual( true ) 
        for _, child in ipairs( self:GetChildren() ) do
            child:PaintManual( true )
        end
        return 
    end

    local dx, dy = self:GetPos()
    local px, py = self:GetParent():LocalToScreen( dx, dy )
    self.Matrix:SetTranslation( Vector( dx, dy, 0 ) )
    cam.PushModelMatrix(self.Matrix, true)
    self:Paint( self:GetWide(), self:GetTall() )
    cam.PopModelMatrix()

    for _, child in ipairs( self:GetChildren() ) do
        if child == self.vars then continue end
        if not child.Paint then continue end
        self.Matrix:SetTranslation( Vector( dx + child:GetX(), dy + child:GetY(), 0 ) )
        cam.PushModelMatrix(self.Matrix, true)
        child:Paint( child:GetWide(), child:GetTall() )
        cam.PopModelMatrix()
    end

    render.ClearStencil()
    render.SetStencilTestMask( 255 )
    render.SetStencilWriteMask( 255 )
    render.SetStencilPassOperation( STENCILOPERATION_KEEP )
    render.SetStencilZFailOperation( STENCILOPERATION_KEEP )
    render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_NEVER )

    // Now we render self.vars

    render.SetStencilEnable( true )
        render.SetStencilReferenceValue( 9 )
        render.SetStencilFailOperation( STENCILOPERATION_REPLACE )

        // Masked Draw
        dx, dy = self:LocalToScreen( self.vars:GetPos() )
        px, py = self:GetParent():ScreenToLocal( dx, dy )
        draw.RoundedBox(0, px, py, self.vars:GetWide(), self.vars:GetTall(), Color( 255, 0, 0 ) )
        /////////////////////////////////
        render.SetStencilFailOperation( STENCILOPERATION_KEEP )
        render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )

        // Main draw
        self.vars:RecursiveManualPaint( true )
        /////////////////////////////////
    render.SetStencilEnable( false )

end

function PANEL:OnChildAdded( child )
    ChildRecursive( self, child )
end

function PANEL:TestHover( mx, my )
    local bg = self:GetBackground()
    if IsValid( bg ) and bg:GetZoomScale() < 1 then
        mx, my = self:GetBackground():GetZoomedCursorPos(mx, my)
    end
    
    mx, my = self:ScreenToLocal( mx, my )
    local bx, by = self:GetSize()
    return ( mx >= 0 ) && ( my >= 0 ) && ( mx <= bx ) && ( my <= by )
end

function PANEL:Init()
    self.NextClick = 0
    self.MainLink = true
    self._vars = {}
    self._disablevars = {}
    self._checkboxes = {}
    self.Matrix = Matrix()


    self.wOSNode = true
    self:NodeClose(true)
    self:SetZPos( -5 )
    self:SetPaintedManually(true)

    self.DeleteButton = vgui.Create("DButton", self)
    self.DeleteButton:SetSize( self:GetTall()*0.15, self:GetTall()*0.15 )
    self.DeleteButton:SetPos( self:GetWide()*0.9 - self:GetTall()*0.0, self:GetTall()*0.925 )
    self.DeleteButton:SetText("")
    self.DeleteButton.DoClick = function(pan)
        self:GetBackground():NodeRemove(self)
        hook.Call( "wOS.PES.OnNodeDelete", nil, self )
    end
    self.DeleteButton.Paint = function(pan, ww, hh)
        //draw.RoundedBox(hh*0.3, 0, 0, ww, hh, Color( 200, 200, 200 ) )
        //draw.SimpleText("X", "DermaDefaultBold", ww/2, hh/2, Color(0, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        self:DrawRotatedBox( ww*0.5, hh*0.5, ww*2, hh*0.2, -45, color_white )
        self:DrawRotatedBox( ww*0.5, hh*0.5, ww*2, hh*0.2, 45, color_white )
    end

    self.ExpandButton = vgui.Create("DButton", self)
    self.ExpandButton:SetSize( self:GetTall()*0.15, self:GetTall()*0.15 )
    self.ExpandButton:SetPos( self:GetWide()*0.8 - self:GetTall()*0.075, self:GetTall()*0.925 )
    self.ExpandButton:SetText("")
    self.ExpandButton.DoClick = function(pan)
        if self.IsOpen then
            self:NodeClose()
        else
            self:Open()
        end
        self.NodeDirty = false
    end
    self.ExpandButton.Paint = function(pan, ww, hh)
        if self.IsOpen then
            self:DrawTriangleUp( ww*0.5, hh*0.3875, ww*0.75, hh*0.75, color_white )
            draw.RoundedBox(0, 0, hh*0.88, ww, hh*0.12, color_white )
        else
            draw.RoundedBox(0, 0, 0, ww, hh*0.12, color_white )
            self:DrawTriangleDown( ww*0.5, hh*0.6, ww*0.8, hh*0.8, color_white )
        end
    end
    self:SetText("")
    self:CreateLinks()

    // Legacy
    self:OnChildAdded( self.ExpandButton )
    self:OnChildAdded( self.DeleteButton )
end

function PANEL:OnSizeChanged( newWidth, newHeight )
	self:CreateLinks( true )
end

function PANEL:CreateLinks( recalc )
    if self.Links then
        for index, link in ipairs(self.Links) do
            if IsValid(link) then link:Remove() end
        end
    end

    self.Links = {}
    self.OtherLinks = {}

    local function makeOtherLink(name, oNode)
        if self.OtherLinks[oNode] and IsValid(self.OtherLinks[oNode][name]) then return end
        local link = vgui.Create("DButton", oNode)
        link:SetSize( self:GetWide()*0.08, self:GetWide()*0.08 )
        link:SetPos( link:GetWide()*-0.5, self:GetTall()*0.5 - link:GetTall()*0.5 )
        link:SetText( "" )
        link.Name = name or "Output"
        link.TriggerColor = Color( 255, 255, 255 )
        
        link.OldThink = link.Think
        link.Think = function( s )
            s:OldThink()
            s:SetPos( s:GetPos(), s:GetParent():GetTall()*0.5 - s:GetTall()*0.5 )
        end

        link.DoClick = function()
            self:GetBackground():RemoveLink(self, name, oNode)
            surface.PlaySound( "buttons/button15.wav" )
            link:Remove()
        end

        link.Paint = function(s, w, h)
            local wasEnabled = DisableClipping( true )            
            local col = s.TriggerColor
            if s.Hovered then col = Color(150,150,150) end
            draw.RoundedBox( h*0.3, 0, 0, w, h, col )
            DisableClipping( wasEnabled )
        end

        if IsValid(oNode) then
            self.OtherLinks[oNode] = self.OtherLinks[oNode] || {}
            self.OtherLinks[oNode][name] = link
        else
            self:GetBackground():RemoveLink(self, name, oNode)
        end
    end

    local function makeLink( name, label, desc )
        local link = vgui.Create("DButton", self)

        local t_pos, id, trigcol = self:GetTriggerPos( name )
        id = id or 1
        link.TriggerColor = trigcol or self.TriggerColorHierarchy[id]

        link:SetSize( self:GetWide()*0.08, self:GetWide()*0.08 )
        link:SetPos( self:GetWide() - link:GetWide()*0.5, t_pos - link:GetTall()*0.5 )
        link:SetText( "" )
        link.NLabel = label or name
        link.NDescription = desc or ""
        link.Name = name or "Output"

        link:SetToolTip( link.NDescription )

        link.OnDepressed = function( s )
            surface.PlaySound( "weapons/airboat/airboat_gun_lastshot2.wav" )
            s.Linking = true
        end

        link.OnReleased = function( s )
            s.Linking = false
            local x, y = self:GetCursorPos()

            timer.Simple(0, function()
                local a = vgui.GetHoveredPanel()

                local hoveredPanel = vgui.GetHoveredPanel()
                if not hoveredPanel then return end
                if not IsValid(hoveredPanel) then return end
                if not hoveredPanel.wOSNode then return end
                if hoveredPanel:IsStart() then return end
                self:GetBackground():MakeLink(self, hoveredPanel, link.Name)
                makeOtherLink(link.Name, hoveredPanel)
                surface.PlaySound( "weapons/airboat/airboat_gun_lastshot1.wav" )
            end)

            s.mousepos = {x = x, y= y}
            self.Links[#self.Links + 1] = link
        end

        link.Paint = function(s, w, h)

            local col = s.TriggerColor
            local wasEnabled = DisableClipping( true )
            if s.Hovered then col = Color(150,150,150) end

            self:DrawTriangleRight( w*0.5, h*0.5, w, h, col )
            draw.SimpleText( s.NLabel, "DermaDefaultBold", w*-0.2, h/2, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

            DisableClipping( wasEnabled )

            if not s.Linking then return end
            DisableClipping( true )

            local x,y = s:ScreenToLocal( self:GetCursorPos() )

            surface.DrawLine( w, h/2, x, y )

            DisableClipping( wasEnabled )
        end
        self.Links[#self.Links + 1] = link
    end

    local nodeLinks = self:GetBackground():GetLinks(self)

    if self.Type then
        local nodeData = wOS.PES.Nodes:Get(self.Type)
        if nodeData and nodeData.Triggers then
            for index, tdata in ipairs(nodeData.Triggers) do
                
                local name = tdata
                local trigger_label = name
                local trigger_description = "This will fire when this condition is met"
                if istable( tdata ) then
                    name = tdata.Type or name
                    trigger_label = tdata.Name or trigger_label
                    trigger_description = tdata.Description or trigger_description
                end

                makeLink(name, trigger_label, trigger_description )
                if recalc then return end
                if not nodeLinks[name] then continue end
                for index, node in pairs(nodeLinks[name]) do
                    makeOtherLink(name, node)
                end
            end
            return
        end
    end

    makeLink("Instant")
    if not nodeLinks["Instant"] then return end
    for index, node in pairs(nodeLinks["Instant"]) do
        makeOtherLink("Instant", node)
    end
end

function PANEL:ApproveVar( name, data, dirty )
    if not name then return true end
    if not data then return true end
    if data.Internal then return true end

    if ( self:GetVarDisabled( name ) ) then return true end

    //Dirty validation
    if dirty then
        local varType = wOS.PES.Vars:Get(data.Type)
        if varType then
            if varType.DirtyValidate then
                self._vars[name] = data.Default or nil
                return false 
            end
        end
    end

    if !data.Required then return true end
    if ( self._vars[name] != nil ) then return true end
    return false
end

function PANEL:GetCursorPos()
    local bg = self:GetBackground()
    if not IsValid( bg ) then return input.GetCursorPos() end
    return bg:GetZoomedCursorPos( input.GetCursorPos() )
end

function PANEL:RecalculateDirty( dirty )
    local final = false
    
    if self.Type then
        local nodeData = wOS.PES.Nodes:Get(self.Type)
        if nodeData then
            if nodeData.Vars then
                for _, name in pairs(nodeData.SortedVars) do
                    local data = nodeData.Vars[ name ]
                    if not data then continue end
                    if self:ApproveVar( name, data, dirty ) then continue end
                    final = true 
                end
            end

            for index, tdata in ipairs(nodeData.Triggers) do
                
                local name = tdata
                if istable( tdata ) then
                    name = tdata.Type or name
                end
                
                local triggerTable = wOS.PES.Triggers:Get(name)
                if not triggerTable then continue end
                if not triggerTable.Vars then continue end
                for name, data in pairs(triggerTable.Vars) do
                    if self:ApproveVar( name, data, dirty ) then continue end
                    final = true 
                end
            end
        end
    end

    self.NodeDirty = final
end

function PANEL:SetVars(tbl, dirty)
    tbl = tbl or {}
    self._vars = tbl
    self:RecalculateName()
    self:RecalculateDirty( dirty )
end

-- function PANEL:UpdateCheckbox( name )
--     if not self._checkboxes[ name ] then return end
--     self._checkboxes[ name ]( !self:GetVarDisabled( name ) )
-- end

function PANEL:SetDisableVars( tbl, dirty )
    tbl = tbl or {}
    self._disablevars = tbl
    self:RecalculateDirty( dirty )
    //self:RefreshCheckBoxes()
end

function PANEL:GetVars()
    return self._vars
end

function PANEL:GetCopy()
    local data = {}
    data.Vars = table.Copy( self._vars )
    data.Toggles = table.Copy( self._disablevars )
    data.Type = self.Type
    return data
end

function PANEL:GetVar(name)
    return self._vars[name]
end

function PANEL:GetVarDisabled(name)
    if self._disablevars[name] != nil then
        return self._disablevars[name]
    end
    return false
end

function PANEL:SetVarDisabled(name, bool)
    self._disablevars[name] = bool
end

function PANEL:SetVar(name, value)
    self._vars[name] = value
    self:RecalculateName()
end

function PANEL:SetMainLink(bool)
    self.MainLink = bool
end

function PANEL:GetMainLink()
    return self.MainLink
end

function PANEL:GetBackground()
    if self.TempBack then return self.TempBack:GetParent() end
    return self:GetParent():GetParent()
end

function PANEL:GetMaster()
    local pan = self:GetBackground()
    if not pan then return end
    return pan:GetParent()
end

function PANEL:OnDepressed()
    local x, y = self:GetCursorPos()
    self.mousepos = {x = x, y= y}

    if !input.IsMouseDown( MOUSE_LEFT ) then return end
    self.Dragging = true
    local back = self:GetBackground()
    if back.SelectedPanel == self then return end
    back:SelectNode( self )
end

function PANEL:OnReleased()
    self.Dragging = false
end

function PANEL:GetTriggerPos(triggerName)
    if self.Type then
        local nodeData = wOS.PES.Nodes:Get(self.Type)
        -- if check
		if nodeData then
			local maxTriggers = #nodeData.Triggers
            for index, tdata in ipairs(nodeData.Triggers) do
                local trigger = tdata
                if istable( tdata ) then
                    trigger = tdata.Type or trigger
                end

				if trigger == triggerName then
					return self:GetTall()*0.5 + self:GetTall()*0.13 * ( index - ( maxTriggers + 1 )*0.5 ), index, self.TriggerColorHierarchy[index]
				end
			end
		end
	end

    return self:GetTall() * 0.5, 1, self.TriggerColorHierarchy[1]
end

function PANEL:Think()

    if not self.Dragging then return end
    if not input.IsMouseDown(MOUSE_LEFT) then self.Dragging = false return end

    local cX, cY = self:ScreenToLocal( self.mousepos.x, self.mousepos.y )
    local mX, mY = self:GetCursorPos()
    self.mousepos = {x = mX, y = mY}
    mX, mY = self:ScreenToLocal( mX, mY )

    local x, y = self:GetPos()
    local dX, dY = mX - cX, mY - cY
    self:SetPos(x + dX, y + dY)

end

function PANEL:DoClick()
    if self.NextClick >= CurTime() then
        self.NextClick = CurTime() + 1
        return
    end

    local back = self:GetBackground()
    back:SelectNode( self )
end

function PANEL:SaveVars()
    if not self.Type then return end

    local nodeData = wOS.PES.Nodes:Get(self.Type)
    -- if no data then return
    local maxTriggers = #nodeData.Triggers

    if !self.varDerma then return end

    if nodeData.Vars then
        for name, varTable in pairs(nodeData.Vars) do
            if varTable.Internal then continue end
            local varType = wOS.PES.Vars:Get(varTable.Type)
            if not varType then continue end
            local element = self.varDerma[name]
            local value = varType.GetValue(element)
            if value == nil then continue end
            self:SetVar(name, value)
        end
    end

    for index, tdata in ipairs(nodeData.Triggers) do
        local name = tdata
        if istable( tdata ) then
            name = tdata.Type or name
        end
        local triggerTable = wOS.PES.Triggers:Get(name)
        if not triggerTable then continue end
        if not triggerTable.Vars then continue end
        for name, varTable in pairs(triggerTable.Vars) do
            if varTable.Internal then continue end
            local varType = wOS.PES.Vars:Get(varTable.Type)
            if not varType then continue end
            local element = self.varDerma[ name ]
            local value = varType.GetValue(element)
            if value == nil then continue end
            self:SetVar( name, value)
        end
    end
end

function PANEL:NodeClose(bool)
    -- remove extra elements
    self:SetZPos(20)
    self.IsOpen = false
    if !bool then
        self:SaveVars()
    end

    self:SetSize(self:GetWide(), self:GetWide()*0.8 )

    if IsValid(self.TypeComboBox) then
        self.TypeComboBox:Remove()
    end

    if IsValid(self.vars) then
        self.vars:Remove()
    end
end

function PANEL:Open()
    self:SetSize( self:GetWide(), self:GetWide() )
    self.IsOpen = true
    self:Populate()
    self:SetZPos(9999)
end

function PANEL:Populate()

    // Replace this with a label that makes sense
    local a = vgui.Create("DLabel", self)
    a:SetSize(190, 15)
    a:SetTextColor( Color( 0, 0, 0 ) )
    a:SetText( self:GetText() )
    a:SetPos(10, 10)
    self.TypeComboBox = a

    if self.Type then
        local scroll = vgui.Create("DCategoryList", self)
        scroll:SetPos( self:GetWide()*0.025, self.BoxTopSize + self:GetTall()*0.05 )
        scroll:SetSize( self:GetWide()*0.95, self:GetTall()*0.9 - self.BoxTopSize - self.BoxBottomSize )

        self.vars = scroll
        self.varDerma = {}
    end

    local makeVars = function(varTable, varData)
        local varType = wOS.PES.Vars:Get(varTable.Type)
        if varTable.Internal then return end

        local cat = self.vars:Add( varTable.Name )

        if !varType then
            cat:Add("This variable errored!")
            self.vars:InvalidateLayout( true )
            return
        end

        -- send in varData or the Default value
        local element = varType.DermaElement(varTable, varData)

        local back = vgui.Create("DPanel")

        if !IsValid(element) then
            element = vgui.Create("DPanel")
        end

        if element:GetClassName() == "TextEntry" then
            local old_func = element.OnGetFocus
            element.OnGetFocus = function( pan )
                self:GetBackground().SelectedPanel = nil
                old_func( pan )
            end
        end

        element:SetParent(back)
        element:Dock(TOP)
        element:DockMargin(2,2,2,2)
        element._catderma = cat
        element.varTable = varTable

        back.element = element

        self.varDerma[varTable.Name] = element

        if varType.UseTool then
            local useTool = vgui.Create("DButton", back)
            useTool:Dock(TOP)
            useTool:DockMargin(8,2,8,2)
            useTool:SetTall(30)
            useTool:SetText("Use Tool")
            useTool.DoClick = function( pan )
                wOS.PES:SetEditingVar(self, varTable)
                local bg = self:GetBackground()
                if not bg then return end
                bg:SetupTool()
            end
        end

        cat:SetContents(back)
        self.vars:InvalidateLayout( true )

        if varTable.ToggleVar then
            local header = cat.Header

            local checkbox = vgui.Create( "DCheckBox", header )
            local hew, heh = header:GetSize()
            local cw, ch = self.vars:GetSize()

            checkbox:DockMargin(heh*0.1, heh*0.10, heh*0.1, heh*0.1)
            checkbox:Dock( RIGHT )
            checkbox:SetSize( heh*0.7, heh*0.7 )
            checkbox.Variable = varTable.Name

            //checkbox:SetPos( cw - 40, heh*0.15 )

            //self:SetVarDisabled( varTable.Name, false )
            
            header.OriginalColor = header:GetTextColor()
            checkbox.OnChange = function( pan, chk )
                local color = Color( 0, 0, 0, 155 )
                if chk then
                    color = pan:GetParent().OriginalColor
                end
                header:SetTextColor( color )
                if pan.RecursivePrevention then return end
                self:SetVarDisabled( pan.Variable, !chk )
            end

            local state = !self:GetVarDisabled( checkbox.Variable )
            checkbox.RecursivePrevention = true
            checkbox:SetChecked( state )
            checkbox:OnChange( state )
            checkbox.RecursivePrevention = false
            
            -- self._checkboxes[ checkbox.Variable ]  = function( bool )
            --     checkbox.RecursivePrevention = true
            --     checkbox:SetChecked( bool )
            --     checkbox.RecursivePrevention = false
            -- end
        end


    end

    if self.vars then
        self:OnChildAdded( self.vars )
    end

    local nodeData = wOS.PES.Nodes:Get(self.Type)

    if nodeData then
        if nodeData.Vars then
            for _, name in pairs(nodeData.SortedVars) do
                local data = nodeData.Vars[ name ]
                if not data then continue end
                if self._vars[name] == nil then self._vars[name] = data.Default end
                makeVars(data, self._vars[name])
            end
        end

        for index, tdata in ipairs(nodeData.Triggers) do
            local name = tdata
            if istable( tdata ) then
                name = tdata.Type or name
            end
            local triggerTable = wOS.PES.Triggers:Get(name)
            if not triggerTable then continue end
            if not triggerTable.Vars then continue end
            for name, data in pairs(triggerTable.Vars) do
                if self._vars[name] == nil then self._vars[name] = data.Default end
                makeVars(data, self._vars[name])
            end
        end
    end
    
end

function PANEL:RecalculateName()
    if self:IsStart() then return end

    if self:GetVar("Event Label") and self:GetVar("Event Label") != "" then
        self.TextName = self:GetVar("Event Label")
        return
    end

    if self.Type then
        self.TextName = self.Type .. " " .. tostring(self.ID-1) 
    else
        self.TextName = "Node " .. tostring(self.ID-1) 
    end
end

function PANEL:Paint(w, h)


    local color = Color(0, 0, 0, 255)

    if self.EventViewerNode then
    
        if self.Active then
            color = Color(0, 255, 0, 255)
        end

    else

        // Regular usage ( CSS / PES CREATION )
        local back = self:GetBackground()
        if self.NodeDirty then 
            color = Color( 176, 66, 33 )
        elseif back.SelectedPanel == self then
            color = Color( 66, 117, 176 ) 
        end

    end
    draw.RoundedBox(w*0.1, 0, 0, w, h, color)
    draw.RoundedBox(w*0.1, w*0.015, w*0.015, w*0.97, h - w*0.03, Color(155, 155, 155, 88))

    if not self.TextName then return end
    local txt = wOS.PES.WrapText( self.TextName, "wOS.PES.NodeText", w*0.95 )
    surface.SetFont( "wOS.PES.NodeText" )
    local _, dH = surface.GetTextSize( txt )


    self.BoxTopSize = h*0.18
    self.BoxBottomSize = h*0.18
    self.BoxBottomPos = h - self.BoxBottomSize
    
    if dH > self.BoxTopSize*0.95 then
        self.BoxTopSize = self.BoxTopSize + dH*0.5
    end

	if IsValid(self.ExpandButton) then
        self.ExpandButton:SetSize( self.BoxBottomSize*0.6, self.BoxBottomSize*0.6 )
        self.ExpandButton:SetPos( self:GetWide()*0.75 - self.BoxBottomSize*0.3, self.BoxBottomPos + self.BoxBottomSize*0.2 )
	end

	if IsValid(self.DeleteButton) then
        self.DeleteButton:SetSize( self.BoxBottomSize*0.6, self.BoxBottomSize*0.6 )
        self.DeleteButton:SetPos( self:GetWide()*0.9 - self.BoxBottomSize*0.3, self.BoxBottomPos + self.BoxBottomSize*0.2 )
	end

    // Bottom Bar
    draw.RoundedBoxEx( w*0.1, 0, self.BoxBottomPos, w, self.BoxBottomSize, Color( 66, 0, 0 ), false, false, true, true )
    draw.RoundedBoxEx( w*0.1, w*0.015, self.BoxBottomPos + w*0.015, w*0.97, self.BoxBottomSize - w*0.03, Color( 125, 0, 0 ), false, false, true, true )

    // Top Bar
    draw.RoundedBoxEx( w*0.1, 0, 0, w, self.BoxTopSize, Color( 66, 0, 0 ), true, true, false, false )
    draw.RoundedBoxEx( w*0.1, w*0.015, w*0.015, w*0.97, self.BoxTopSize - w*0.03, Color( 125, 0, 0 ), true, true, false, false )

    draw.DrawText(txt, "wOS.PES.NodeText", w/2, self.BoxTopSize/2 - dH/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
end

function PANEL:SetAsStart( isstarter )
    self.IsStartNode = isstarter
end

function PANEL:IsStart()
    return self.IsStartNode
end

vgui.Register( "WOS_PES_NODE", PANEL, "DButton" )

--addons/wos-passiveevent/lua/wos/pes/vgui/wos_datacopy_editor.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2023
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


























































































































































local PANEL = {}

function PANEL:Init()

end

function PANEL:SetVariableData( data )
    self.VariableData = table.Copy( data )
    self:RebuildData()
end

function PANEL:SetBasePanel( pan )
    self.DataPanel = pan
end

function PANEL:GetVariableData()
    return self.VariableData
end
--
-- Clears and rebuilds the controls. Should only really be called internally.
--
function PANEL:RebuildData()

	--
	-- we're rebuilding - so clear all the old controls
	--
	self:Clear()

    if not self.VariableData then return end

    -- Enforces that it is at the top of the list
    self:GetCategory( "Base Entity Data", true )

	for name, data in pairs( self.VariableData ) do
		self:EditVariable( name, data )
	end

end

local function VarToPropertyType( var )
    if isbool( var ) then
        return "Bool"
    elseif IsColor( var ) then
        return "VectorColor"
    elseif isvector( var ) then
        return "Vector"
    elseif isangle( var ) then
        return "Angle"
    end

    return "String"
end

function PANEL:CreateNestedEditor( varname, editdata )
    local category = self:GetCategory( varname, true )
    local count = 0
    for val_name, val in pairs( editdata ) do
        if istable( val ) then continue end
        count = count + 1
        local row = self:CreateRow( varname, val_name )
        row:Setup( VarToPropertyType( val ) )
        row:SetValue( val )
        row:SetEnabled( true )

        row.DataUpdate = function( _ ) end
        row.DataChanged = function( _, vald )
            if not IsValid( self.DataPanel ) then return end
            self.VariableData[ varname ][ val_name ] = vald
        end
    end
    if count < 1 then category:Remove() end
end

--
-- Called internally. Adds an entity variable to watch.
--
function PANEL:EditVariable( varname, editdata )

	if ( istable( editdata ) ) then 
        /*
            Uncomment this function if you DARE. It will add some nested tables (only one layer of nest)
            Need to make a TABLE row type for PES, so we can ADD to tables. Only then will this official get added back
        */

        // self:CreateNestedEditor( varname, editdata ) 
        return 
    end

	local row = self:CreateRow( "Base Entity Data", varname )
	row:Setup( VarToPropertyType( editdata ) )
    row:SetValue( editdata )
    row:SetEnabled( true )

	row.DataUpdate = function( _ ) end
	row.DataChanged = function( _, val )
        if not IsValid( self.DataPanel ) then return end
        self.VariableData[ varname ] = val
	end

end

vgui.Register( "WOS_PES_DATACOPY_EDITOR", PANEL, "DProperties" )
--addons/wos-passiveevent/lua/wos/pes/addons/chat/cl_core.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































local addon = {}

net.Receive("wOS.PES.Chat", function(len)
	chat.PlaySound()
	chat.AddText(unpack(net.ReadTable()))
end)

wOS.PES.Modules:RegisterAddon( "chat", addon )
--addons/wos-passiveevent/lua/wos/pes/addons/io_logic/sh_logic_tables.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































local addon = {}


/*
Thank you Jazztronauts for this table of entclass to io inputs
https://github.com/Foohy/jazztronauts/blob/master/gamemodes/jazztronauts/gamemode/lib/sh_hacking.lua#L163-L394
*/

local io_functions = {
	logic_auto = {
		inputs = {},
		outputs = {
			"OnMapSpawn"
		},
	},
	logic_relay = {
		inputs = {
			"Enable",
			"Disable",
			"Trigger",
			"Toggle",
			"CancelPending",
			"EnableRefire",
			"Kill",
			"Use",
		},
		outputs = {
			"OnSpawn",
			"OnTrigger",
		},
	},
	logic_branch = {
		inputs = {
			"SetValue",
			"SetValueTest",
			"Toggle",
			"ToggleTest",
			"Test",
		},
		outputs = {
			"OnTrue",
			"OnFalse",
		},
	},
	logic_timer = {
		inputs = {
			"RefireTime",
			"ResetTimer",
			"FireTimer",
			"Enable",
			"Disable",
			"Toggle",
			"LowerRandomBound",
			"UpperRandomBound",
			"AddToTimer",
			"SubtractFromTimer",
		},
		outputs = {
			"OnTimer",
			"OnTimerHigh",
			"OnTimerLow",
		},
	},
	func_button = {
		inputs = {
			"Kill",
			"Use",
			"Lock",
			"Unlock",
			"Press",
			"PressIn",
			"PressOut",
		},
		outputs = {
			"OnDamaged",
			"OnPressed",
			"OnUseLocked",
			"OnIn",
			"OnOut",
		},
	},
	func_rot_button = {
		inputs = {
			"Kill",
			"Use",
			"Lock",
			"Unlock",
			"Press",
			"PressIn",
			"PressOut",
		},
		outputs = {
			"OnDamaged",
			"OnPressed",
			"OnUseLocked",
			"OnIn",
			"OnOut",
		},
	},
	func_door = {
		inputs = {
			"Open",
			"Close",
			"Toggle",
			"Lock",
			"Unlock",
			"SetSpeed",
		},
		outputs = {
			"OnClose",
			"OnOpen",
			"OnFullyClosed",
			"OnFullyOpen",
			"OnBlockedClosing",
			"OnBlockedOpening",
			"OnUnblockedClosing",
			"OnUnblockedOpening",
			"OnLockedUse",
		},
	},
	func_door_rotating = {
		inputs = {
			"Open",
			"Close",
			"Toggle",
			"Lock",
			"Unlock",
			"SetSpeed",
		},
		outputs = {
			"OnClose",
			"OnOpen",
			"OnFullyClosed",
			"OnFullyOpen",
			"OnBlockedClosing",
			"OnBlockedOpening",
			"OnUnblockedClosing",
			"OnUnblockedOpening",
			"OnLockedUse",
		},
	},
	prop_door_rotating = {
		inputs = {
			"Open",
			"Close",
			"Toggle",
			"Lock",
			"Unlock",
			"SetSpeed",
		},
		outputs = {
			"OnClose",
			"OnOpen",
			"OnFullyClosed",
			"OnFullyOpen",
			"OnBlockedClosing",
			"OnBlockedOpening",
			"OnUnblockedClosing",
			"OnUnblockedOpening",
			"OnLockedUse",
		},
	},
	func_rotating = {
		inputs = {
			"SetSpeed",
			"Start",
			"Stop",
			"StopAtStartPos",
			"StartForward",
			"StartBackward",
			"Toggle",
			"Reverse",
		},
		outputs = {
		},
	},
	prop_dynamic = {
		inputs = {
			"SetAnimation",
			"SetDefaultAnimation",
			"SetPlaybackRate",
			"SetBodyGroup",
			"TurnOn",
			"TurnOff",
			"EnableCollision",
			"DisableCollision",
			"BecomeRagdoll",
		},
		outputs = {
			"OnAnimationBegun",
			"OnAnimationDone",
		},
	},
	env_sprite = {
		inputs = {
			"SetScale",
			"HideSprite",
			"ShowSprite",
			"ToggleSprite",
			"ColorRedValue",
			"ColorGreenValue",
			"ColorBlueValue",
			"Alpha",
			"Color",
		},
		outputs = {

		},
	},
	env_spark = {
		inputs = {
			"StartSpark",
			"StopSpark",
			"ToggleSpark",
			"SparkOnce"
		},
		outputs = {

		},
	},
	trigger_once = {
		inputs = {
			"Toggle",
			"Enable",
			"Disable",
		},
		outputs = {
			"OnStartTouch",
			"OnTrigger",
		},
	},
	trigger_multiple = {
		inputs = {
			"TouchTest",
			"Toggle",
			"Enable",
			"Disable",
		},
		outputs = {
			"OnStartTouchAll",
			"OnEndTouch",
			"OnEndTouchAll",
			"OnStartTouch",
			"OnTrigger",
		},
	},
	ambient_generic = {
		inputs = {
			"Pitch",
			"PlaySound",
			"StopSound",
			"ToggleSound",
			"Volume",
			"FadeIn",
			"FadeOut"
		},
		outputs = {

		},
	},
}

function addon:GetIOTable(class, ent)
	local actions = {}

	if io_functions[ class ] then
		table.Add(actions, io_functions[ class ].inputs or {})
	end

	// Add any custom actions
	if ent and ent._pesIOLogic then
		table.Add(actions, ent._pesIOLogic)
	end

	return actions
end

wOS.PES.Modules:RegisterAddon( "io_logic", addon )
--addons/wos-passiveevent/lua/wos/pes/vars/float.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}
VAR.Name = "Float"

VAR.IsValid = function(varTable, value)
    if not isnumber(value) then
        return false
    end

    return true
end

VAR.DermaElement = function(varTable, value)
    local numSlider = vgui.Create("DNumSlider")
    numSlider.Label:SetColor( Color( 125, 0, 255 ) )

    if isnumber(varTable.Min) then
        numSlider:SetMin(varTable.Min)
    end

    if isnumber(varTable.Max) then
        numSlider:SetMax(varTable.Max)
    end

    if isnumber(value) then
        numSlider:SetValue(value)
    else
        numSlider:SetValue(varTable.Default)
    end

    return numSlider
end

VAR.GetValue = function(numSlider)
    return numSlider:GetValue()
end

return VAR

--addons/wos-passiveevent/lua/wos/pes/vars/int.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Int"

VAR.IsValid = function(varTable, value)
    if not isnumber(value) then
        return false
    end
    return true
end

VAR.DermaElement = function(varTable, value)
    local numberWang = vgui.Create("DNumberWang")
    numberWang:SetDecimals(0)

    if isnumber(varTable.Min) then
        numberWang:SetMin(varTable.Min)
    else
         numberWang:SetMin( 0 )
    end

    if isnumber(varTable.Max) then
        numberWang:SetMax(varTable.Max)
    else
        numberWang:SetMax( math.huge )
    end

    if isnumber(value) then
        numberWang:SetValue(value)
    else
        numberWang:SetValue(varTable.Default)
    end

    return numberWang
end

VAR.GetValue = function(numberWang)
    return numberWang:GetValue()
end

return VAR

--addons/wos-passiveevent/lua/wos/pes/vars/io_logic.lua:

local VAR = {}

VAR.Name = "IOLogic"
VAR.UseTool = true

VAR.ToolTips = {
    { text = "Select the entity to pull IO functions from", key = "gui/lmb.png", },
}

VAR.IsValid = function(varTable, value)
    if not istable(value) then return false end
	if not value.Function then return false end
	
	return true
end

VAR.DermaElement = function(varTable, varData)
	
	local DermaPanel = vgui.Create("DScrollPanel")
	DermaPanel:SetTall( 100 )
	DermaPanel.varData = varData or {}

	local ioLogic = wOS.PES.Modules:Get("io_logic")

	local rebuildOptions = function( class, ent )
		local actions = ioLogic:GetIOTable( class, ent )
		for _, name in ipairs(actions) do
			local button = vgui.Create("DButton", DermaPanel)	
			button:SetText(name)
			button:SetTall(20)
			button:Dock(TOP)
			button.FName = name
			button:DockMargin(0, 0, 5, 0)
			button.DoClick = function( pan )
				if not ent and not DermaPanel.varData.Class then return end
				local class = DermaPanel.varData.Class
				if ent then class = ent:GetClass() end
				DermaPanel.varData = { Class = class, Function = pan.FName }
				if DermaPanel.ClickedButton then
					DermaPanel.ClickedButton:SetText( DermaPanel.ClickedButton.FName )
				end
				pan:SetText( "->  " .. pan.FName .. " <-" )
				DermaPanel.ClickedButton = pan
			end

			if DermaPanel.varData.Function and DermaPanel.varData.Function == name then
				button:SetText( "->  " .. button.FName .. " <-" )
				DermaPanel.ClickedButton = button
			end

		end

	end

	local rebuildBase = function(ent)
		DermaPanel:Clear()

		if !IsValid(ent) then 
			local dlabel = vgui.Create("DLabel", DermaPanel)
			dlabel:SetText("No entity selected")
			dlabel:SetTall(20)
			dlabel:Dock(TOP)
			dlabel:DockMargin(0, 0, 5, 0)
			return 
		end
		
		rebuildOptions( ent:GetClass(), ent )
	end


	if DermaPanel.varData.Class then
		rebuildOptions( DermaPanel.varData.Class )
	end

	DermaPanel.RebuildBase = rebuildBase

	return DermaPanel
end

VAR.GetValue = function(element, varData)
	return element.varData
end

VAR.PrimaryAttack = function(wep, ply, dermaElement)
	local ent = ply:GetEyeTrace().Entity

	dermaElement.varData = {}
	dermaElement.RebuildBase(ent)
	ply:ChatPrint( "Entity Class Updated: " .. ent:GetClass() )
end

return VAR
--addons/wos-passiveevent/lua/wos/pes/vars/scene.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--


local VAR = {}

VAR.Name = "Scene"
VAR.DirtyValidate = true
VAR.IsValid = function(varTable, value)
	value = value or {}
	local a = {}
	for index, data in ipairs(value or {}) do
		// If we have old data, keep it.
		if istable(data) then 
			a[#a+1] = data 
			continue 
		end

		local ent = ents.GetByIndex(data)
		if not IsValid(ent) then continue end

		local data = wOS.PES.ReadEntity(ent)
		a[#a+1] = data
		ent:Remove()
	end

	-- who know that variable overrides don't update
	-- value = a doesn't work
	table.CopyFromTo( a, value )
	return true
end

VAR.DermaElement = function(varTable, value)
	local pnl = vgui.Create("DPanel")
	pnl.Paint = function() end
	local button = vgui.Create("DButton", pnl)

	button.data = value or {}
	button:SetText("Record") // Want to localise two variables here in the future to make maintaining easier

	pnl.button = button

	button:Dock(LEFT)
	
	button.DoClick = function(self)

		local scenemodule = wOS.PES.Modules:Get("scene")

		if button:GetText() == "Record" then
			button:SetText("Recording ...")
			wOS.PES:GetActiveMenu():Hide()
			if scenemodule and scenemodule.StartRecording then
				scenemodule.StartRecording(button)
				button.data = {}
			end
		else
			button:SetText("Record")
			if scenemodule and scenemodule.StopRecording then
				scenemodule.StopRecording(button)
			end
		end
	end

	local wipe = vgui.Create("DButton", pnl)
	wipe:Dock(LEFT)
	wipe:SetText("Reset")
	wipe.DoClick = function()
		button.data = {}
		if button:GetText() != "Record" then
			button:SetText("Record")
			if scenemodule and scenemodule.StopRecording then
				scenemodule.StopRecording(button)
			end
		end
	end

	return pnl
end

VAR.GetValue = function(dermaElement)
	return dermaElement.button.data
end

return VAR

--addons/wos-passiveevent/lua/wos/pes/core/cl_accessors.lua:
--[[-------------------------------------------------------------------]]--[[
							  
	Copyright wiltOS Technologies LLC, 2021
	
	Contact: www.wiltostech.com
		
----------------------------------------]]--

























































































































































wOS = wOS or {}
wOS.PES = wOS.PES or {}

wOS.PES.Triggers = wOS.PES.Triggers || {}
wOS.PES.Triggers.Data = wOS.PES.Triggers.Data || {}

wOS.PES.Nodes = wOS.PES.Nodes || {}
wOS.PES.Nodes.Data = wOS.PES.Nodes.Data || {}

function wOS.PES.Triggers:GetAll()
    return self.Data
end

function wOS.PES.Triggers:Get(name)
    if not name then return end
    return self.Data[name]
end

function wOS.PES.Nodes:GetAll()
    return self.Data
end

function wOS.PES.Nodes:Get(name)
    if not name then return end
    return self.Data[name]
end
--addons/scb_chatbox/lua/autorun/scb.lua:
if SCB_LOADED then return end

local types = {
	sv_ = SERVER and include or function() end,
	cl_ = SERVER and AddCSLuaFile or include,
	sh_ = function(name)
		if SERVER then
			AddCSLuaFile(name)
		end
		return include(name)
	end
}

local load_file = function(name, no, type)
	if not no then
		name = "scb/" .. name
	end

	local func = types[type or name:GetFileFromFilename():sub(1, 3)] or types["sh_"]
	if func then
		return func(name)
	end
end

scb = {
	config = {}
}

function scb.print(...)
	MsgC(
		Color(236, 240, 241), "(",
		Color(65, 185, 255), "SCB",
		Color(236, 240, 241), ") ",
		Color(236, 240, 241), ...
	) Msg("\n")
end

scb.print("Loading...")

	file.CreateDir("scb")

	require("sui")
	if CLIENT then
		scb.SUI = sui.new("SCB")
	end

	load_file("libs/sh_types.lua")
	scb.mp = load_file("libs/message_pack/sh_messagepack.lua")

	load_file("sh_scb_config.lua", true)

	for _, permissions in pairs(scb.config.permissions) do
		for k, v in ipairs(permissions) do
			if v ~= true then
				permissions[v], permissions[k] = true, nil
			end
		end
	end

	if SERVER then
		for _, f in ipairs(file.Find("scb/settings/tabs/*.lua", "LUA")) do
			AddCSLuaFile("scb/settings/tabs/" .. f)
		end
	end

	load_file("cl_util.lua")
	load_file("settings/cl_settings.lua")
	load_file("sh_chatbox.lua")
	load_file("sv_chatbox.lua")
	load_file("cl_chatbox.lua")
	load_file("cl_overrides.lua")

	if SERVER then
		AddCSLuaFile("scb/cl_emojis_data.lua", "GAME")

		-- emojis need to be loaded once the player joins, so things like this https://www.gmodstore.com/market/view/4868 could break it
		local AddWorkshop = resource.OldAddWorkshop or resource.AddWorkshop
		AddWorkshop("1998633255")
	end

	for _, f in ipairs(file.Find("scb/vgui/*.lua", "LUA")) do
		load_file("vgui/" .. f, false, "cl_")
	end

scb.print("Loaded!")

SCB_LOADED = true
--addons/sui/lua/sui/libs/gif_loader.lua:
local byte = string.byte
local sub = string.sub
local lshift = bit.lshift
local rshift = bit.rshift
local bor = bit.bor
local band = bit.band

local GIFDecoder = {}
local GIFDecoderMethods = {}
local GIFDecoder_meta = {__index = GIFDecoderMethods}

function GIFDecoder.new(buf)
	local buf_n = #buf
	local this = setmetatable({
		p = 1,
		buf = buf
	}, GIFDecoder_meta)

	local version = this:read(6)
	assert(version == "GIF89a" or version == "GIF87a", "wrong file format")

	this.width = this:word()
	this.height = this:word()

	local pf0 = this:byte()
	local global_palette_flag = rshift(pf0, 7)
	local num_global_colors_pow2 = band(pf0, 0x7)
	local num_global_colors = lshift(1, num_global_colors_pow2 + 1)
	this:skip(2)

	local global_palette_offset = nil
	local global_palette_size = nil

	if global_palette_flag > 0 then
		global_palette_offset = this.p
		this.global_palette_offset = global_palette_offset
		global_palette_size = num_global_colors
		this:skip(num_global_colors * 3)
	end

	local no_eof = true

	local frames = {}

	local delay = 0
	local transparent_index = nil
	local disposal = 1

	while no_eof and this.p <= buf_n do
		local b = this:byte()
		if b == 0x3b then
			no_eof = false
		elseif b == 0x2c then
			local x, y, w, h = this:word(), this:word(), this:word(), this:word()
			local pf2 = this:byte()
			local local_palette_flag = rshift(pf2, 7)
			local interlace_flag = band(rshift(pf2, 6), 1)
			local num_local_colors_pow2 = band(pf2, 0x7)
			local num_local_colors = lshift(1, num_local_colors_pow2 + 1)
			local palette_offset = global_palette_offset
			local palette_size = global_palette_size
			local has_local_palette = false
			if local_palette_flag ~= 0 then
				has_local_palette = true
				palette_offset = this.p
				palette_size = num_local_colors
				this:skip(num_local_colors * 3)
			end

			local data_offset = this.p

			this:skip(1)
			this:skip_eob()

			table.insert(frames, {
				x = x,
				y = y,
				width = w,
				height = h,
				has_local_palette = has_local_palette,
				palette_offset = palette_offset,
				palette_size = palette_size,
				data_offset = data_offset,
				data_length = this.p - data_offset,
				transparent_index = transparent_index,
				interlaced = interlace_flag > 0,
				delay = delay,
				disposal = disposal
			})
		elseif b == 0x21 then
			local b2 = this:byte()
			if b2 == 0xf9 then
				local len, flags = this:bytes(2)
				delay = this:word()
				local transparent, terminator = this:bytes(2)

				assert(len == 4 and terminator == 0, "Invalid graphics extension block.")

				if flags % 2 == 1 then
					transparent_index = transparent
				else
					transparent_index = nil
				end

				disposal = math.floor(flags / 4) % 8
			elseif b2 == 0xff then
				this:read(this:byte())
				this:skip_eob()
			else
				this:skip_eob()
			end
		end
	end

	this.frames = frames

	return this
end

function GIFDecoderMethods:skip(offset)
	self.p = self.p + offset
end

-- skip to end of block
function GIFDecoderMethods:skip_eob()
	repeat
		local size = self:byte()
		self:skip(size)
	until size == 0
end

function GIFDecoderMethods:byte()
	local b = byte(self.buf, self.p)
	self:skip(1)
	return b
end

function GIFDecoderMethods:bytes(len)
	local _p = self.p
	self:skip(len)
	return byte(self.buf, _p, len + _p - 1)
end

function GIFDecoderMethods:read(len)
	local _p = self.p
	self:skip(len)
	return sub(self.buf, _p, len + _p - 1)
end

function GIFDecoderMethods:word()
	return bor(self:byte(), lshift(self:byte(), 8))
end

local GifReaderLZWOutputIndexStream = function(this, output, output_length)
	local min_code_size = this:byte()
	local clear_code = lshift(1, min_code_size)
	local eoi_code = clear_code + 1
	local next_code = eoi_code + 1
	local cur_code_size = min_code_size + 1

	local code_mask = lshift(1, cur_code_size) - 1
	local cur_shift = 0
	local cur = 0
	local op = 0

	local subblock_size = this:byte()

	local code_table = {}

	local prev_code = nil

	while true do
		while cur_shift < 16 do
			if subblock_size == 0 then break end

			cur = bor(cur, lshift(this:byte(), cur_shift))
			cur_shift = cur_shift + 8

			if subblock_size == 1 then
				subblock_size = this:byte()
			else
				subblock_size = subblock_size - 1
			end
		end

		if cur_shift < cur_code_size then break end

		local code = band(cur, code_mask)
		cur = rshift(cur, cur_code_size)
		cur_shift = cur_shift - cur_code_size

		if code == clear_code then
			next_code = eoi_code + 1
			cur_code_size = min_code_size + 1
			code_mask = lshift(1, cur_code_size) - 1

			prev_code = null
			continue
		elseif code == eoi_code then
			break
		end

		local chase_code = code < next_code and code or prev_code
		local chase_length = 0
		local chase = chase_code
		while chase > clear_code do
			chase = rshift(code_table[chase], 8)
			chase_length = chase_length + 1
		end

		local k = chase
		local op_end = op + chase_length + (chase_code ~= code and 1 or 0)
		if op_end > output_length then
			Error("Warning, gif stream longer than expected.")
			return
		end

		output[op] = k; op = op + 1
		op = op + chase_length

		local b = op

		if chase_code ~= code then
			output[op] = k; op = op + 1
		end
		chase = chase_code

		while chase_length > 0 do
			chase_length = chase_length - 1
			chase = code_table[chase]
			b = b - 1
			output[b] = band(chase, 0xff)

			chase = rshift(chase, 8)
		end

		if prev_code ~= nil and next_code < 4096 then
			code_table[next_code] = bor(lshift(prev_code, 8), k)
			next_code = next_code + 1

			if next_code >= code_mask + 1 and cur_code_size < 12 then
				cur_code_size = cur_code_size + 1
				code_mask = bor(lshift(code_mask, 1), 1)
			end
		end

		prev_code = code
	end

	if op ~= output_length then
		Error("Warning, gif stream shorter than expected.")
	end

	return output
end

function GIFDecoderMethods:decode_and_blit_frame_RGBA(frame_num, pixels)
	local frame = self.frames[frame_num]
	local num_pixels = frame.width * frame.height
	local index_stream = {}

	self.p = frame.data_offset
	GifReaderLZWOutputIndexStream(self, index_stream, num_pixels)
	local palette_offset = frame.palette_offset

	local trans = frame.transparent_index
	if trans == nil then
		trans = 256
	end

	local width = self.width
	local framewidth = frame.width
	local framestride = width - framewidth
	local xleft = framewidth

	local opbeg = (frame.y * width + frame.x) * 4

	local opend = ((frame.y + frame.height) * width + frame.x) * 4
	local op = opbeg
	local scanstride = framestride * 4

	if frame.interlaced == true then
		scanstride = scanstride + (width * 4 * 7)
	end

	local interlaceskip = 8

	local i = 0
	local buf = self.buf
	while i < num_pixels do
		local index = index_stream[i]

		if xleft == 0 then
			op = op + scanstride
			xleft = framewidth

			if op >= opend then
				scanstride =
					framestride * 4 + width * 4 * (interlaceskip - 1)

				op =
					opbeg +
					(framewidth + framestride) * lshift(interlaceskip, 1)
				interlaceskip = rshift(interlaceskip, 1)
			end
		end

		if index ~= trans then
			index = palette_offset + index * 3
			pixels[op + 0] = byte(buf, index)
			pixels[op + 1] = byte(buf, index + 1)
			pixels[op + 2] = byte(buf, index + 2)
			pixels[op + 3] = 255
		end

		op = op + 4

		xleft = xleft - 1
		i = i + 1
	end
end

function GIFDecoderMethods:clear_frame(frame_num, pixels)
	local frame = self.frames[frame_num]

	self.p = frame.data_offset

	local width = self.width
	local framewidth = frame.width
	local framestride = width - framewidth
	local xleft = framewidth

	local opbeg = (frame.y * width + frame.x) * 4

	local opend = ((frame.y + frame.height) * width + frame.x) * 4
	local op = opbeg
	local scanstride = framestride * 4

	if frame.interlaced == true then
		scanstride = scanstride + (width * 4 * 7)
	end

	local interlaceskip = 8

	local i = 0
	local num_pixels = frame.width * frame.height
	while i < num_pixels do
		if xleft == 0 then
			op = op + scanstride
			xleft = framewidth

			if op >= opend then
				scanstride =
					framestride * 4 + width * 4 * (interlaceskip - 1)

				op =
					opbeg +
					(framewidth + framestride) * lshift(interlaceskip, 1)
				interlaceskip = rshift(interlaceskip, 1)
			end
		end

		pixels[op + 0] = 0
		pixels[op + 1] = 0
		pixels[op + 2] = 0
		pixels[op + 3] = 0
		op = op + 4

		xleft = xleft - 1
		i = i + 1
	end
end

function GIFDecoderMethods:get_frames()
	local num_pixels = self.width * self.height * 4 + 4
	local frames = {}
	local numFrames = #self.frames
	local last_frame
	local restore_from
	for i = 1, numFrames do
		local frame = self.frames[i]

		local data = {}

		if last_frame then
			local _data = last_frame.data
			for k = 0, num_pixels do
				data[k] = _data[k]
			end
		end

		if i > 1 then
			local last_disposal = last_frame.disposal
			if last_disposal == 3 then
				if restore_from then
					for k = 0, num_pixels do
						data[k] = restore_from[k]
					end
				else
					self:clear_frame(i - 1, data)
				end
			end

			if last_disposal == 2 then
				self:clear_frame(i - 1, data)
			end
		end

		self:decode_and_blit_frame_RGBA(i, data)

		local delay = frame.delay
		if delay < 2 then
			delay = 10
		end

		local disposal = frame.disposal
		last_frame = {
			data = data,
			delay = delay,
			disposal = disposal
		}
		frames[i] = last_frame

		if disposal ~= 3 then
			restore_from = data
		end
	end

	return frames
end

return GIFDecoder.new
--addons/sui/lua/sui/vgui/sui_label.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local MOUSE_LEFT = MOUSE_LEFT

local SysTime = SysTime

local PANEL = {}

AccessorFunc(PANEL, "m_colText", "TextColor")
AccessorFunc(PANEL, "m_colTextStyle", "TextStyleColor")
AccessorFunc(PANEL, "m_FontName", "Font")

AccessorFunc(PANEL, "m_bDoubleClicking", "DoubleClickingEnabled", FORCE_BOOL)
AccessorFunc(PANEL, "m_bAutoStretchVertical", "AutoStretchVertical", FORCE_BOOL)
AccessorFunc(PANEL, "m_bIsMenuComponent", "IsMenu", FORCE_BOOL)

AccessorFunc(PANEL, "m_bBackground", "PaintBackground",	FORCE_BOOL)
AccessorFunc(PANEL, "m_bBackground", "DrawBackground",	FORCE_BOOL)
AccessorFunc(PANEL, "m_bDisabled", "Disabled", FORCE_BOOL)

AccessorFunc(PANEL, "m_bIsToggle", "IsToggle", FORCE_BOOL)
AccessorFunc(PANEL, "m_bToggle", "Toggle", FORCE_BOOL)

AccessorFunc(PANEL, "m_bBright", "Bright", FORCE_BOOL)
AccessorFunc(PANEL, "m_bDark", "Dark", FORCE_BOOL)
AccessorFunc(PANEL, "m_bHighlight",	"Highlight", FORCE_BOOL)

PANEL:SetIsToggle(false)
PANEL:SetToggle(false)
PANEL:SetDisabled(false)
PANEL:SetDoubleClickingEnabled(true)

local Panel = FindMetaTable("Panel")
local SetMouseInputEnabled = Panel.SetMouseInputEnabled
local SetPaintBackgroundEnabled = Panel.SetPaintBackgroundEnabled
local SetPaintBorderEnabled = Panel.SetPaintBorderEnabled
local InvalidateLayout = Panel.InvalidateLayout
local SetFGColor = Panel.SetFGColor
function PANEL:Init()
	SetMouseInputEnabled(self, false)
	SetPaintBackgroundEnabled(self, false)
	SetPaintBorderEnabled(self, false)
end

function PANEL:AllowScale()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function PANEL:ScaleChanged()
	self:SizeToContents()
end

function PANEL:SetFont(font)
	if self.m_FontName == font then return end

	self.m_FontName = font
	self:SetFontInternal(self.m_FontName)
end

function PANEL:SetTextColor(col)
	if self.m_colText == col then return end

	self.m_colText = col
	SetFGColor(self, col.r, col.g, col.b, col.a)
end
PANEL.SetColor = PANEL.SetTextColor

function PANEL:GetColor()
	return self.m_colText or self.m_colTextStyle
end

function PANEL:Toggle()
	if not self:GetIsToggle() then return end

	self:SetToggle(not self:GetToggle())
	self:OnToggled(self:GetToggle())
end

function PANEL:SetDisabled(bDisabled)
	self.m_bDisabled = bDisabled
	InvalidateLayout(self)
end

function PANEL:SetEnabled(bEnabled)
	self:SetDisabled(not bEnabled)
end

function PANEL:IsEnabled()
	return not self:GetDisabled()
end

function PANEL:ApplySchemeSettings()
	local col = self:GetColor()
	if not col then return end

	self:SetFGColor(col.r, col.g, col.b, col.a)
end

function PANEL:AutoStretchVerticalThink()
	self:SizeToContentsY()
end

function PANEL:SetAutoStretchVertical(enable)
	self.m_bAutoStretchVertical = enable
	self.Think = enable and self.AutoStretchVerticalThink or nil
end

function PANEL:OnCursorEntered()
	InvalidateLayout(self, true)
end

function PANEL:OnCursorExited()
	InvalidateLayout(self, true)
end

function PANEL:OnMousePressed(mousecode)
	if self:GetDisabled() then return end

	if mousecode == MOUSE_LEFT and not dragndrop.IsDragging() and self.m_bDoubleClicking then
		if self.LastClickTime and SysTime() - self.LastClickTime < 0.2 then

			self:DoDoubleClickInternal()
			self:DoDoubleClick()
			return
		end

		self.LastClickTime = SysTime()
	end

	if self:IsSelectable() and mousecode == MOUSE_LEFT and input.IsShiftDown() then
		return self:StartBoxSelection()
	end

	self:MouseCapture(true)
	self.Depressed = true
	self:OnDepressed()
	InvalidateLayout(self, true)

	self:DragMousePress(mousecode)
end

function PANEL:OnMouseReleased(mousecode)
	self:MouseCapture(false)

	if self:GetDisabled() then return end
	if not self.Depressed and dragndrop.m_DraggingMain ~= self then return end

	if self.Depressed then
		self.Depressed = nil
		self:OnReleased()
		InvalidateLayout(self, true)
	end

	if self:DragMouseRelease(mousecode) then return end

	if self:IsSelectable() and mousecode == MOUSE_LEFT then
		local canvas = self:GetSelectionCanvas()
		if canvas then
			canvas:UnselectAll()
		end
	end

	if not self.Hovered then return end

	self.Depressed = true

	if mousecode == MOUSE_RIGHT then
		self:DoRightClick()
	end

	if mousecode == MOUSE_LEFT then
		self:DoClickInternal()
		self:DoClick()
	end

	if mousecode == MOUSE_MIDDLE then
		self:DoMiddleClick()
	end

	self.Depressed = nil
end

function PANEL:OnReleased()
end

function PANEL:OnDepressed()
end

function PANEL:OnToggled(bool)
end

function PANEL:DoClick()
	self:Toggle()
end

function PANEL:DoRightClick()
end

function PANEL:DoMiddleClick()
end

function PANEL:DoClickInternal()
end

function PANEL:DoDoubleClick()
end

function PANEL:DoDoubleClickInternal()
end

sui.register("Label", PANEL, "Label")
--addons/sui/lua/sui/vgui/sui_scroll_panel.lua:
local math = math
local table = table

local pairs = pairs
local RealFrameTime = RealFrameTime

local TDLib = sui.TDLib
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local RoundedBox = sui.TDLib.LibClasses.RoundedBox

local Panel = {}

AccessorFunc(Panel, "m_bFromBottom", "FromBottom", FORCE_BOOL)
AccessorFunc(Panel, "m_bVBarPadding", "VBarPadding", FORCE_NUMBER)

Panel:SetVBarPadding(0)

Panel.NoOverrideClear = true

-- VBar
local starting_scroll_speed = 3

local vbar_OnMouseWheeled = function(s, delta)
	s.scroll_speed = s.scroll_speed + (14 * RealFrameTime() --[[ slowly increase scroll speed ]])
	s:AddScroll(delta * -s.scroll_speed)
end

-- default set scroll clamps amount
local vbar_SetScroll = function(s, amount)
	if not s.Enabled then s.Scroll = 0 return end

	s.scroll_target = amount
	s:InvalidateLayout()
end

-- ¯\_(ツ)_/¯ https://github.com/Facepunch/garrysmod/blob/cd3d894288b847e3d081570129963d4089e36261/garrysmod/lua/vgui/dvscrollbar.lua#L234
local vbar_OnCursorMoved = function(s, _, y)
	if s.Dragging then
		y = y - s.HoldPos
		y = y / (s:GetTall() - s:GetWide() * 2 - s.btnGrip:GetTall())
		s.scroll_target = y * s.CanvasSize
	end
end

local vbar_Think = function(s)
	local frame_time = RealFrameTime() * 14
	local scroll_target = s.scroll_target

	s.Scroll = Lerp(frame_time, s.Scroll, scroll_target)

	if not s.Dragging then
		s.scroll_target = Lerp(frame_time, scroll_target, math.Clamp(scroll_target, 0, s.CanvasSize))
	end

	-- now start slowing it down!!!
	s.scroll_speed = Lerp(frame_time / 14, s.scroll_speed, starting_scroll_speed)
end

local vbar_Paint = function(s, w, h)
	TDLib.RoundedBox(s.vertices, 3, 0, 0, w, h, SUI.GetColor("scroll"))
end

local vbarGrip_Paint = function(s, w, h)
	TDLib.RoundedBox(s.vertices, 3, 0, 0, w, h, SUI.GetColor("scroll_grip"))
end

local vbar_PerformLayout = function(s, w, h)
	local scroll = s:GetScroll() / s.CanvasSize
	local bar_size = math.max(s:BarScale() * h, 10)

	local track = (h - bar_size) + 1
	scroll = scroll * track

	s.btnGrip.y = scroll
	s.btnGrip:SetSize(w, bar_size)
end
--

function Panel:Init()
	local canvas = self:GetCanvas()
	canvas:SUI_TDLib()

	local children = {}
	function canvas:OnChildAdded(child)
		table.insert(children, child)
	end
	function canvas:OnChildRemoved(child)
		for i = 1, #children do
			local v = children[i]
			if v == child then
				table.remove(children, i)
				return
			end
		end
	end
	canvas.GetChildren = function()
		return children
	end
	canvas.children = children

	local vbar = self.VBar
	vbar:SetHideButtons(true)
	vbar.btnUp:SetVisible(false)
	vbar.btnDown:SetVisible(false)

	vbar.vertices = {}
	vbar.scroll_target = 0
	vbar.scroll_speed = starting_scroll_speed

	vbar.OnMouseWheeled = vbar_OnMouseWheeled
	vbar.SetScroll = vbar_SetScroll
	vbar.OnCursorMoved = vbar_OnCursorMoved
	vbar.Think = vbar_Think
	vbar.Paint = vbar_Paint
	vbar.PerformLayout = vbar_PerformLayout

	vbar.btnGrip.vertices = {}
	vbar.btnGrip.Paint = vbarGrip_Paint

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function Panel:OnChildAdded(child)
	self:AddItem(child)
	self:ChildAdded(child)
end

function Panel:ChildAdded()
end

function Panel:ScaleChanged()
	local w = SUI.Scale(4)

	self.VBar:SetWide(w)
	self.VBar.btnDown:SetSize(w, 0)
	self.VBar.btnUp:SetSize(w, 0)
end

function Panel:Paint(w, h)
	local outline = SUI.GetColor("scroll_panel_outline")
	if outline then
		TDLib.DrawOutlinedBox(3, 0, 0, w, h, SUI.GetColor("scroll_panel"), outline, 1)
	else
		RoundedBox(self, "Background", 3, 0, 0, w, h, SUI.GetColor("scroll_panel"))
	end
end

function Panel:ScrollToBottom()
	local vbar = self.VBar
	for k, anim in pairs(vbar.m_AnimList or {}) do
		anim:Think(vbar, 1)
		vbar.m_AnimList[k] = nil
	end

	self:InvalidateParent(true)
	self:InvalidateChildren(true)

	vbar:SetScroll(vbar.CanvasSize)
end

function Panel:PerformLayoutInternal(w, h)
	w = w or self:GetWide()
	h = h or self:GetTall()

	local canvas = self.pnlCanvas

	self:Rebuild()

	local vbar = self.VBar
	vbar:SetUp(h, canvas:GetTall())

	if vbar.Enabled then
		w = w - vbar:GetWide() - self.m_bVBarPadding
	end

	canvas:SetWide(w)

	self:Rebuild()
end

function Panel:Think()
	local canvas = self.pnlCanvas

	local vbar = self.VBar
	if vbar.Enabled then
		canvas.y = -vbar.Scroll
	else
		if self:GetFromBottom() then
			canvas._y = Lerp(14 * RealFrameTime(), canvas._y or canvas.y, self:GetTall() - canvas:GetTall())
		else
			canvas._y = Lerp(14 * RealFrameTime(), canvas._y or canvas.y, -vbar.Scroll)
		end
		canvas.y = canvas._y
	end
end

sui.register("ScrollPanel", Panel, "DScrollPanel")
--addons/sui/lua/sui/vgui/sui_zbutton.lua:
local draw = draw
local render = render

local TDLib = sui.TDLib
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local lerp_color = sui.lerp_color
local contrast_color = sui.contrast_color

local BUTTON_FONT = SUI.CreateFont("Button", "Roboto Medium", 16)

local color_white = color_white
local color_transparent = Color(0, 0, 0, 0)

local PANEL = {}

AccessorFunc(PANEL, "m_Background", "Background")
AccessorFunc(PANEL, "m_bContained", "Contained", FORCE_BOOL)

sui.TDLib.Install(PANEL)
sui.scaling_functions(PANEL)

PANEL:ClearPaint()
PANEL:SetContained(true)

local Panel = FindMetaTable("Panel")
local SetMouseInputEnabled = Panel.SetMouseInputEnabled
local IsMouseInputEnabled = Panel.IsMouseInputEnabled
local SetCursor = Panel.SetCursor
local SetContentAlignment = Panel.SetContentAlignment
function PANEL:Init()
	self:ScaleInit()

	self.vertices, self.vertices_2 = {}, {}

	SetMouseInputEnabled(self, true)
	SetCursor(self, "hand")
	SetContentAlignment(self, 5)

	self:SetSize(90, 30)
	self:SetFont(BUTTON_FONT)

	self:CircleClick(nil, 7)

	self.OldPaint, self.Paint = self.Paint, self.Paint2

	self.cur_col = Color(0, 0, 0, 0)
end

function PANEL:SetEnabled(b)
	SetMouseInputEnabled(self, b)
end

function PANEL:IsEnabled()
	return IsMouseInputEnabled(self)
end

function PANEL:ContainedPaint(w, h)
	local enabled = self:IsEnabled()
	local col
	if enabled then
		col = self:GetBackground() or SUI.GetColor("button")
		self:SetTextColor(SUI.GetColor("button_text"))
	else
		col = SUI.GetColor("button_disabled")
		self:SetTextColor(SUI.GetColor("button_disabled_text"))
	end
	self:RoundedBox("Background", 4, 0, 0, w, h, col)

	if not enabled then return end

	self.circle_click_color = SUI.GetColor("button_click")

	if self.Hovered or self.Selected then
		self:RoundedBox("Hover", 4, 0, 0, w, h, SUI.GetColor("button_hover"))
	end
end

function PANEL:SetColors(hover_color, text_color)
	self.hover = hover_color
	self.text_color = text_color
end

function PANEL:Paint2(w, h)
	if self:GetContained() then
		self:ContainedPaint(w, h)
		self:OldPaint(w, h)
		return
	end

	render.ClearStencil()
	render.SetStencilEnable(true)

	render.SetStencilWriteMask(1)
	render.SetStencilTestMask(1)

	render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilPassOperation(STENCILOPERATION_ZERO)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
	render.SetStencilReferenceValue(1)

	TDLib.RoundedBox(self.vertices, 4, 0, 0, w, h, color_white)

	render.SetStencilFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	render.SetStencilReferenceValue(1)

	local cur_col = self.cur_col
	if self.Selected then
		lerp_color(cur_col, SUI.GetColor("button2_selected"))
	elseif self.Hovered then
		lerp_color(cur_col, self.hover or SUI.GetColor("button2_hover"))
	else
		lerp_color(cur_col, color_transparent)
	end

	TDLib.RoundedBox(self.vertices_2, 4, 0, 0, w, h, cur_col)

	if self.text_color then
		self.circle_click_color = self.text_color
		self:SetTextColor(self.text_color)
	else
		local col = contrast_color(cur_col)
		self.circle_click_color = col
		self:SetTextColor(col)
	end

	self:OldPaint(w, h)

	render.SetStencilEnable(false)
	render.ClearStencil()
end

sui.register("Button", PANEL, NAME .. ".Label")
--addons/sui/lua/sui/vgui/sui_zcollapse_category.lua:
local sui = sui

local draw_material = sui.draw_material

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local RoundedBox = sui.TDLib.LibClasses.RoundedBox
local TextColor = sui.TDLib.LibClasses.TextColor

local TABS_FONT = SUI.CreateFont("CategoryListTabs", "Roboto Bold", 13)
local ITEMS_FONT = SUI.CreateFont("CategoryListItems", "Roboto Medium", 14)

local Panel = {}

local item_OnRemove = function(s)
	local parent = s.parent

	local items = parent.items
	for k, v in ipairs(items) do
		if v == s then
			table.remove(items, k)
			break
		end
	end

	if #items == 0 then
		local category = s.category
		category:Remove()
		parent.categories[category.name] = nil
	end
end

local item_DoClick = function(s)
	local parent = s.parent
	parent:select_item(s)
end

function Panel:Init()
	local categories = {}
	local items = {}

	self.categories = categories
	self.items = items

	self:SetVBarPadding(1)

	local get_category = function(name)
		local category = categories[name]
		if category then return category end

		local expanded = false

		category = self:Add("Panel")
		category:Dock(TOP)
		category:DockMargin(0, 0, 0, 3)
		category.name = name

		local header = category:Add("DButton")
		header:Dock(TOP)
		header:DockMargin(0, 0, 0, 3)
		header:SetFont(TABS_FONT)
		header:SetContentAlignment(4)
		header:SetTextInset(6, 0)
		header:SetText(name)
		header:SizeToContentsY(SUI.Scale(14))

		local cur_col
		local cur_col_text = Color(GetColor("collapse_category_header_text"):Unpack())
		function header:Paint(w, h)
			if expanded then
				cur_col = GetColor("collapse_category_header_active")
				cur_col_text = GetColor("collapse_category_header_text_active")
			elseif self.Hovered then
				cur_col = GetColor("collapse_category_header_hover")
				cur_col_text = GetColor("collapse_category_header_text_hover")
			else
				cur_col = GetColor("collapse_category_header")
				cur_col_text = GetColor("collapse_category_header_text")
			end

			RoundedBox(self, "Background", 3, 0, 0, w, h, cur_col)
			TextColor(self, cur_col_text)
		end

		local image = header:Add(NAME .. ".Image")
		image:Dock(FILL)
		image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/arrow.png")

		function image:Draw(w, h)
			local size = SUI.ScaleEven(10)
			draw_material(nil, w - (size / 2) - 6, h / 2, size, cur_col_text, expanded and 180)
		end

		local current_h
		function category.RefreshHeight()
			local h
			if expanded then
				local _
				_, h = category:ChildrenSize()
				if self.searching and h == header:GetTall() then
					h = 0
				end
			else
				h = header:GetTall()
			end

			if current_h == h then return end

			if h > 0 then
				category:SetVisible(true)
			end

			current_h = h

			category:Stop()
			category:SizeTo(-1, h, 0.2, 0, -1, function()
				if h == 0 then
					category:SetVisible(false)
				end
			end)
		end

		function category.SetExpanded(_, set_expanded)
			if expanded == set_expanded then return end

			if sam.isbool(set_expanded) then
				expanded = set_expanded
			else
				expanded = not expanded
			end

			category.RefreshHeight()

			if expanded then
				self:OnCategoryExpanded(category)
			end

			self:InvalidateLayout(true)
		end
		header.DoClick = category.SetExpanded

		category:SetTall(header:GetTall())
		categories[name] = category

		return category
	end

	function self:add_item(name, category_name)
		local category = get_category(category_name)

		local item = category:Add("DButton")
		item:Dock(TOP)
		item:DockMargin(0, 0, 0, 3)
		item:SetFont(ITEMS_FONT)
		item:SetText(name)
		item:SizeToContentsY(SUI.Scale(3 * 2))
		item.name = name
		item.parent = self
		item.category = category

		local cur_col
		local cur_col_text = Color(GetColor("collapse_category_item_text"):Unpack())
		function item:Paint(w, h)
			if self.selected then
				cur_col = GetColor("collapse_category_item_active")
				cur_col_text = GetColor("collapse_category_item_text_active")
			elseif self.Hovered then
				cur_col = GetColor("collapse_category_item_hover")
				cur_col_text = GetColor("collapse_category_item_text_hover")
			else
				cur_col = GetColor("collapse_category_item")
				cur_col_text = GetColor("collapse_category_item_text")
			end

			RoundedBox(self, "Background", 4, 0, 0, w, h, cur_col)
			TextColor(self, cur_col_text)
		end

		item.DoClick = item_DoClick
		item.OnRemove = item_OnRemove

		table.insert(items, item)

		return item
	end
end

function Panel:OnCategoryExpanded(category)
end

function Panel:select_item(item)
	if self.selected_item ~= item then
		if IsValid(self.selected_item) then
			self.selected_item.selected = false
		end
		item.selected = true
		self.selected_item = item
		self:item_selected(item)
	end
end

function Panel:item_selected()
end

function Panel:Search(text, names)
	local items = self.items
	self.searching = true
	for i = 1, #items do
		local item = items[i]
		local category = item.category
		category:SetExpanded(true)

		if not names then
			if item.name:find(text, nil, true) then
				item:SetVisible(true)
			else
				item:SetVisible(false)
			end
		else
			local found = false
			for _, name in ipairs(item.names) do
				if name:find(text, nil, true) then
					found = true
					item:SetVisible(true)
				end
			end
			if not found then
				item:SetVisible(false)
			end
		end

		if text == "" then
			category:SetExpanded(false)
		end

		category:RefreshHeight()
		category:InvalidateLayout(true)
	end
	self.searching = false
end

sui.register("CollapseCategory", Panel, NAME .. ".ScrollPanel")
--addons/sui/lua/sui/vgui/sui_zcolumn_sheet.lua:
local IsValid = IsValid

local TDLib_Classes = sui.TDLib.LibClasses
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local Panel = {}

function Panel:Init()
	self.tabs = {}

	local tab_scroller = self:Add(NAME .. ".ScrollPanel")
	tab_scroller:Dock(LEFT)

	function tab_scroller:Paint(w, h)
		self:RoundedBox("Background", 1, 0, 0, w, h, GetColor("column_sheet_bar"))
	end

	self.tabs_wide = 48
	self.tab_scroller = tab_scroller

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function Panel:ScaleChanged()
	local tabs_wide = SUI.Scale(self.tabs_wide)
	self.tab_scroller:SetWide(tabs_wide)

	self:InvalidateLayout(true)

	local tabs = self.tabs
	for i = 1, #self.tabs do
		tabs[i].img:SetMinus(SUI.Scale(20))
	end
end

function Panel:Paint(w, h)
	self:RoundedBox("Background", 1, 0, 0, w, h, GetColor("column_sheet"))
end

local tab_DoClick = function(s)
	s.parent:SetActiveTab(s)
end

local tab_Paint = function(s, w, h)
	local cur_col
	if s.active then
		cur_col = GetColor("column_sheet_tab_active")
	elseif s.Hovered then
		cur_col = GetColor("column_sheet_tab_hover")
	else
		cur_col = GetColor("column_sheet_tab")
	end

	s:RoundedBox("Backgrounds", 0, 0, 0, w, h, cur_col)
end

local tab_OnRemove = function(s)
	table.RemoveByValue(s.parent.tabs, s)
end

function Panel:AddSheet(mat, load_func)
	local tab = self.tab_scroller:Add(NAME .. ".Button")
	tab:Dock(TOP)
	tab:SetText("")
	tab:SetTall(self.tabs_wide)

	tab.On = TDLib_Classes.On

	tab.DoClick = tab_DoClick
	tab.Paint = tab_Paint
	tab:On("OnRemove", tab_OnRemove)

	tab.parent = self
	tab.load_func = load_func

	local img = tab:Add(NAME .. ".Image")
	img:Dock(FILL)
	img:SetImage(mat)
	img:SetMinus(SUI.Scale(20))

	tab.img = img

	self.tab_scroller:AddItem(tab)

	if not self:GetActiveTab() then
		self:SetActiveTab(tab)
	end

	table.insert(self.tabs, tab)

	return tab
end

function Panel:GetActiveTab()
	return self.active_tab
end

function Panel:SetActiveTab(new_tab)
	if new_tab == self.active_tab then return end

	if not IsValid(new_tab.panel) then
		local panel = new_tab.load_func(self)
		panel:SetParent(self)
		panel:SetVisible(false)
		panel:SetAlpha(0)

		panel.tab = new_tab
		new_tab.panel = panel
	end

	local old_active_tab = self.active_tab
	local delay = 0
	if old_active_tab and IsValid(old_active_tab.panel) then
		old_active_tab.active = false
		delay = 0.2
		old_active_tab.panel:AlphaTo(0, delay, 0, function(_, p)
			if p:IsValid() then
				p:SetVisible(false)
			end
		end)
	end

	new_tab.active = true
	new_tab.panel:SetVisible(true)
	new_tab.panel:AlphaTo(255, 0.2, delay)
	self.active_tab = new_tab
end

sui.register("ColumnSheet", Panel, "EditablePanel")
--addons/scb_chatbox/lua/scb/settings/tabs/emojis.lua:
if SCB_LOADED then return end

local scb = scb
local SUI = scb.SUI
local language = scb.language

scb.emojis = include("scb/cl_emojis_data.lua")

do
	local set_material = surface.SetMaterial
	local i = 0
	for name in pairs(scb.emojis) do
		timer.Simple(i * 0.001, function()
			set_material(SUI.Material("scb/emojis/" .. name .. ".png"))
		end)
		i = i + 1
	end
end

net.Receive("SCB.SendEmojis", function()
	local emojis = net.ReadData(net.ReadUInt(17))
	emojis = util.Decompress(emojis)

	for k, v in pairs(scb.mp.unpack(emojis)) do
		scb.emojis[k] = v
	end

	hook.Call("SCB.EmojisModified")
end)

net.Receive("SCB.AddEmoji", function()
	local emoji = net.ReadString()
	local url = net.ReadString()
	scb.emojis[emoji] = url

	local old = net.ReadString()
	if old ~= "" then
		scb.emojis[old] = nil
	end

	hook.Call("SCB.EmojisModified")
end)

net.Receive("SCB.RemoveEmoji", function()
	scb.emojis[net.ReadString()] = nil
	hook.Call("SCB.EmojisModified")
end)

local emoji_menu = function(title, emoji_name, emoji_url)
	emoji_name = emoji_name or ""

	local options = sui.valid_options()

	local querybox = vgui.Create("SCB.QueryBox")
	querybox:SetTitle(title)
	querybox:SetWide(300)

	local name = querybox:Add("SCB.TextEntry")
	name:Dock(TOP)
	name:SetPlaceholder(language.emoji_name)
	name:SetValue(emoji_name)
	name:SetCheck(function(_name)
		if _name == "" or (scb.emojis[_name] and emoji_name ~= _name) then
			return false
		end
	end)

	function name:AllowInput(c)
		return not c:find("[%w_]")
	end

	options.Add(name)

	local url = querybox:Add("SCB.TextEntry")
	url:Dock(TOP)
	url:DockMargin(0, 4, 0, 0)
	url:SetPlaceholder(language.emoji_url)
	url:SetValue(emoji_url or "")
	url:SetCheck(function(_url)
		if not _url:find("^https?://") then
			_url = "http://" .. _url
		end

		if scb.find_url(_url) ~= 1 then
			return false
		end
	end)

	function url:AllowInput(c)
		return c:find("%s") and true or false
	end

	options.Add(url)

	querybox:SetCallback(function()
		local _name = name:GetText():lower()
		local _url = url:GetText()

		if not _url:find("^https?://") then
			_url = "http://" .. _url
		end

		net.Start("SCB.AddEmoji")
			net.WriteString(_name)
			net.WriteString(_url)
			net.WriteString(_name ~= emoji_name and emoji_name or "")
		net.SendToServer()
	end)

	querybox:Done()
	querybox.save:SetEnabled(true)

	function querybox.save:Think()
		self:SetEnabled(options.IsValid())
	end
end

return {
	title = language.emojis_title,
	pos = 3,
	func = function(parent)
		local body = parent:Add("Panel")
		body:Dock(FILL)
		body:DockMargin(0, 1, 0, 0)
		body:InvalidateParent(true)

		SUI.OnScaleChanged(body, function()
			body:Remove()
		end)

		local top_body = body:Add("Panel")
		top_body:Dock(FILL)
		top_body:InvalidateParent(true)

		local search_field = top_body:Add("SCB.TextEntry")
		search_field:Dock(TOP)
		search_field:SetPlaceholder(language.search)

		local emojis_list = top_body:Add("SCB.ThreeGrid")
		emojis_list:Dock(FILL)
		emojis_list:DockMargin(3, 3, 3, 3)
		emojis_list:InvalidateLayout(true)
		emojis_list:InvalidateParent(true)

		emojis_list:SetColumns(3)
		emojis_list:SetHorizontalMargin(2)
		emojis_list:SetVerticalMargin(2)

		top_body.Paint, emojis_list.Paint = emojis_list.Paint, nil

		local load_emojis = function(search_key)
			emojis_list:Clear()

			search_key = search_key:lower()

			for emoji_name, v in pairs(scb.emojis) do
				if not scb.is_custom_emoji(v) then
					continue
				end

				if not string.find(emoji_name:lower(), search_key, 1, true) then
					continue
				end

				local pnl = vgui.Create("DButton")
				pnl:SetText("")
				pnl:SetTall(SUI.Scale(30))
				pnl:SUI_TDLib()
					:ClearPaint()
					:FadeHover()

				function pnl:DoClick()
					emoji_menu(language.edit .. " '" .. emoji_name .. "'", emoji_name, v)
				end

				function pnl:DoRightClick()
					local d_menu = DermaMenu()

					d_menu:AddOption(language.remove, function()
						net.Start("SCB.RemoveEmoji")
							net.WriteString(emoji_name:lower())
						net.SendToServer()
					end)

					d_menu:Open()
					d_menu:MakePopup()

					function pnl:OnRemove()
						d_menu:Remove()
					end
				end

				local emoji = pnl:Add("SCB.ChatLine")
				emoji:Dock(NODOCK)
				emoji.x = 2

				emoji:NewEmoji(emoji_name, v, 26)
				emoji:Center()
				emoji:SetMouseInputEnabled(false)

				local name = pnl:Add("SCB.Label")
				name:Dock(FILL)
				name:DockMargin(SUI.ScaleEven(26) + 8, 0, 0, 0)
				name:SetFont(SCB_16)
				name:SetText(emoji_name)

				emojis_list:AddCell(pnl)
			end
		end
		load_emojis("")

		hook.Add("SCB.EmojisModified", emojis_list, function()
			load_emojis(search_field:GetValue())
		end)

		function search_field:OnValueChange(v)
			load_emojis(v)
		end

		local add_emoji = body:Add("SCB.Button")
		add_emoji:Dock(BOTTOM)
		add_emoji:DockMargin(0, 4, 0, 0)
		add_emoji:SetText(language.add_emoji:upper())

		add_emoji:On("DoClick", function()
			emoji_menu(language.add_emoji)
		end)

		return body
	end
}
--addons/scb_chatbox/lua/scb/cl_emojis_data.lua:
return {["jack_o_lantern"]="41",["sloth"]="254",["flag_nl"]="8179",["man_raising_hand"]="1240",["crossed_swords"]="6187",["flag_ck"]="853",["flag_mn"]="8160",["woman_kiss_man"]="1447",["heartpulse"]="1120",["man_girl"]="1472",["flag_se"]="8210",["woman_with_probing_cane"]="1372",["flag_bd"]="827",["rolled_up_newspaper"]="6117",["fog"]="5195",["flag_af"]="811",["aries"]="760",["japan"]="56",["arrow_forward"]="776",["stadium"]="517",["five"]="7139",["flag_kr"]="8135",["guitar"]="663",["woman_kiss_woman"]="1449",["flag_ro"]="8202",["man_getting_massage"]="1356",["exclamation"]="7127",["flag_gt"]="8103",["princess"]="1315",["skunk"]="256",["world_map"]="55",["flag_sm"]="8217",["crab"]="380",["flag_bl"]="834",["grey_exclamation"]="7126",["rainbow"]="5198",["woman_mountain_biking"]="1421",["racing_motorcycle"]="592",["deaf_person"]="1242",["kangaroo"]="257",["stethoscope"]="6212",["flag_cz"]="865",["spider"]="2101",["man_girl_boy"]="1473",["smirk"]="137",["ophiuchus"]="772",["flag_uy"]="8249",["cool"]="7154",["woman_getting_massage"]="1357",["whale"]="285",["frog"]="276",["man_standing"]="1365",["running_shirt_with_sash"]="451",["wind_chime"]="414",["imp"]="192",["thought_balloon"]="1148",["biohazard_sign"]="726",["m"]="7158",["sparkler"]="44",["jigsaw"]="465",["clock430"]="5149",["bust_in_silhouette"]="1481",["wine_glass"]="3105",["no_bicycles"]="718",["sneezing_face"]="152",["carousel_horse"]="558",["flag_ps"]="8196",["chipmunk"]="248",["ant"]="297",["man_running"]="1380",["nine"]="7143",["bamboo"]="411",["facepunch"]="1171",["earth_africa"]="51",["woman_running"]="1381",["lower_left_fountain_pen"]="6147",["wedding"]="538",["disappointed_relieved"]="176",["clock530"]="5151",["man_woman_girl_girl"]="1459",["computer"]="677",["mantelpiece_clock"]="5139",["woman_heart_woman"]="1453",["broom"]="6223",["trackball"]="682",["martial_arts_uniform"]="445",["lemon"]="35",["flag_qa"]="8200",["surfer"]="1401",["child"]="1199",["flag_cr"]="859",["male_singer"]="1288",["rice_scene"]="415",["metro"]="568",["flag_jo"]="8126",["drum_with_drumsticks"]="668",["black_right_pointing_double_triangle_with_vertical_bar"]="778",["blue_heart"]="1131",["house_buildings"]="521",["male_judge"]="1264",["wheelchair"]="74",["field_hockey_stick_and_ball"]="439",["fish_cake"]="374",["spoon"]="3119",["man_woman_boy_boy"]="1458",["dark_sunglasses"]="62",["lock_with_ink_pen"]="6177",["u5408"]="7178",["man_in_business_suit_levitating"]="1384",["raised_back_of_hand"]="1151",["probing_cane"]="6196",["currency_exchange"]="6130",["person_in_lotus_position"]="1437",["flag_pk"]="8191",["flag_ua"]="8244",["hot_pepper"]="323",["large_orange_circle"]="7185",["male_firefighter"]="1300",["paperclip"]="6167",["flag_km"]="8132",["pizza"]="346",["massage"]="1355",["female_astronaut"]="1298",["postbox"]="6143",["railway_track"]="5102",["label"]="6120",["microscope"]="6205",["mask"]="147",["ramen"]="368",["boxing_glove"]="444",["man_walking"]="1362",["jeans"]="68",["flag_iq"]="8120",["statue_of_liberty"]="540",["flag_bw"]="843",["flag_my"]="8171",["axe"]="6182",["money_with_wings"]="6126",["tophat"]="636",["flag_no"]="8180",["milky_way"]="5184",["flag_cu"]="860",["on"]="745",["flag_tk"]="8234",["high_brightness"]="793",["flag_eh"]="877",["arrow_double_up"]="784",["white_flower"]="2108",["flag_gb"]="889",["male_astronaut"]="1297",["face_palm"]="1248",["llama"]="237",["bald_man"]="1209",["angel"]="1325",["female_doctor"]="1256",["flag_om"]="8185",["abacus"]="687",["abcd"]="7146",["printer"]="679",["man_kiss_man"]="1448",["moyai"]="6233",["construction"]="5109",["arrow_upper_right"]="728",["man_dancing"]="1383",["female_artist"]="1292",["smile_cat"]="1104",["pig"]="228",["flag_sl"]="8216",["star2"]="5182",["tennis"]="435",["radio"]="661",["beers"]="3109",["custard"]="397",["blue_book"]="6108",["flag_bo"]="837",["flag_mq"]="8163",["flag_ls"]="8145",["flag_hk"]="8107",["volcano"]="510",["weary"]="184",["spider_web"]="2102",["sweat_smile"]="16",["leaves"]="2127",["car"]="585",["white_haired_man"]="1208",["flag_cm"]="855",["flag_tz"]="8243",["art"]="477",["pouch"]="623",["flag_ng"]="8177",["rooster"]="262",["boom"]="1138",["supervillain"]="1331",["u7121"]="7174",["earth_americas"]="52",["clock11"]="5162",["six"]="7140",["shopping_bags"]="624",["mushroom"]="329",["wc"]="79",["ng"]="7160",["flag_lc"]="8141",["flag_ge"]="891",["hatched_chick"]="265",["flag_pr"]="8195",["clock3"]="5146",["diamonds"]="469",["unlock"]="6176",["o"]="7106",["credit_card"]="6127",["flags"]="413",["mailbox_with_no_mail"]="6142",["softball"]="430",["melon"]="32",["bride_with_veil"]="1322",["unamused"]="138",["taco"]="349",["helicopter"]="5124",["snow_cloud"]="5192",["nazar_amulet"]="460",["goat"]="234",["flag_aq"]="817",["repeat_one"]="775",["astonished"]="169",["newspaper"]="6116",["speaking_head_in_silhouette"]="1480",["lower_left_crayon"]="6150",["purple_heart"]="1132",["athletic_shoe"]="627",["dancers"]="1385",["large_blue_circle"]="7188",["fries"]="345",["flag_lk"]="8143",["u7533"]="7177",["cinema"]="791",["flag_tr"]="8239",["pray"]="1179",["man_playing_water_polo"]="1429",["womans_clothes"]="620",["musical_note"]="654",["confused"]="163",["no_entry_sign"]="717",["calling"]="670",["cookie"]="389",["pushpin"]="6165",["female_pilot"]="1295",["weight_lifter"]="1413",["admission_tickets"]="420",["gift"]="418",["lightning"]="5193",["restroom"]="77",["broccoli"]="326",["manual_wheelchair"]="594",["sagittarius"]="768",["no_mobile_phones"]="723",["purse"]="621",["sunflower"]="2113",["double_vertical_bar"]="787",["om_symbol"]="750",["flag_za"]="8263",["flushed"]="170",["male_pilot"]="1294",["curry"]="367",["chair"]="6216",["panda_face"]="253",["large_blue_square"]="7197",["lollipop"]="396",["oden"]="371",["flying_disc"]="436",["flag_ai"]="813",["ice_cream"]="387",["flag_gg"]="893",["cow2"]="227",["sleuth_or_spy"]="1305",["high_heel"]="630",["flag_hr"]="8110",["fearful"]="174",["flag_mx"]="8170",["flag_nf"]="8176",["person_in_steamy_room"]="1388",["joystick"]="462",["garlic"]="327",["speaker"]="645",["video_camera"]="695",["male_farmer"]="1267",["flag_tj"]="8233",["female_detective"]="1307",["see_no_evil"]="1112",["dromedary_camel"]="235",["ear_of_rice"]="2121",["heavy_minus_sign"]="7114",["male_supervillain"]="1332",["straight_ruler"]="6169",["robot_face"]="1102",["flag_bv"]="842",["sparkling_heart"]="1119",["trumpet"]="665",["no_entry"]="716",["up"]="7165",["flag_dk"]="869",["ledger"]="6112",["headphones"]="660",["full_moon"]="5168",["no_smoking"]="719",["flag_pm"]="8193",["couplekiss"]="1446",["flag_cd"]="848",["chart_with_upwards_trend"]="6161",["two_women_holding_hands"]="1443",["man_woman_boy"]="1455",["tiger2"]="217",["sunrise_over_mountains"]="552",["flag_bf"]="829",["man_woman_girl"]="1456",["flag_so"]="8219",["hugging_face"]="128",["flag_mp"]="8162",["clock1030"]="5161",["yum"]="122",["chart"]="6129",["ox"]="225",["camping"]="512",["bath"]="1440",["onion"]="328",["rice_cracker"]="364",["beverage_box"]="3113",["flag_hu"]="8112",["clock830"]="5157",["flag_cl"]="854",["large_yellow_circle"]="7186",["last_quarter_moon_with_face"]="5175",["handball"]="1431",["spiral_note_pad"]="6158",["flag_tm"]="8236",["female_construction_worker"]="1313",["female_office_worker"]="1280",["yellow_heart"]="1129",["hotsprings"]="557",["beach_with_umbrella"]="513",["flag_bn"]="836",["shield"]="6190",["film_projector"]="690",["o2"]="7161",["ok_woman"]="1233",["flag_lb"]="8140",["flag_gd"]="890",["package"]="6138",["clock2"]="5144",["candle"]="699",["clock10"]="5160",["person_with_blond_hair"]="1203",["elephant"]="239",["small_red_triangle_down"]="7213",["man_man_girl"]="1461",["koko"]="7167",["elf"]="1346",["clock630"]="5153",["camera"]="693",["money_mouth_face"]="127",["first_quarter_moon"]="5166",["male_sign"]="798",["duck"]="270",["snow_capped_mountain"]="58",["clown_face"]="196",["no_bell"]="652",["flag_kw"]="8136",["kiwifruit"]="315",["tanabata_tree"]="410",["eyeglasses"]="61",["ok_hand"]="1155",["last_quarter_moon"]="5170",["lower_left_paintbrush"]="6149",["anguished"]="173",["womans_hat"]="635",["parking"]="7163",["flag_sg"]="8211",["wrestlers"]="1425",["closed_lock_with_key"]="6178",["circus_tent"]="562",["expressionless"]="135",["symbols"]="7148",["wrench"]="6191",["flag_lu"]="8147",["fire"]="5208",["phone"]="671",["flag_gn"]="898",["scarf"]="69",["man_gesturing_no"]="1231",["two_hearts"]="1123",["arrows_clockwise"]="741",["airplane_arriving"]="5121",["movie_camera"]="688",["man_man_girl_girl"]="1464",["woman_frowning"]="1226",["orange_book"]="6109",["petri_dish"]="6203",["clipboard"]="6164",["clock130"]="5143",["question"]="7124",["flag_yt"]="8262",["iphone"]="669",["dolls"]="412",["tea"]="3102",["three"]="7137",["flag_pt"]="8197",["baby_bottle"]="399",["film_frames"]="689",["spiral_calendar_pad"]="6159",["waxing_crescent_moon"]="5165",["octagonal_sign"]="5108",["male_construction_worker"]="1312",["shirt"]="67",["maple_leaf"]="2125",["female_police_officer"]="1304",["barber"]="561",["man_wrestling"]="1426",["menorah_with_nine_branches"]="758",["woman"]="1210",["burrito"]="350",["ballot_box_with_ballot"]="6144",["bus"]="575",["bell"]="651",["hamster"]="245",["heart_decoration"]="1124",["grinning"]="11",["man_boy"]="1470",["bulb"]="6100",["small_orange_diamond"]="7210",["flag_tt"]="8240",["secret"]="7181",["congratulations"]="7180",["male_superhero"]="1329",["chart_with_downwards_trend"]="6162",["flag_sv"]="8223",["part_alternation_mark"]="7118",["wavy_dash"]="7128",["yo_yo"]="456",["white_large_square"]="7201",["black_large_square"]="7200",["left_luggage"]="713",["arrow_down"]="731",["flag_is"]="8122",["small_red_triangle"]="7212",["tractor"]="590",["green_book"]="6107",["sleeping_accommodation"]="1441",["baseball"]="429",["thumbsdown"]="1169",["arrow_up"]="727",["shell"]="293",["arrow_heading_down"]="740",["arrow_heading_up"]="739",["koala"]="252",["desert"]="514",["loop"]="7117",["flag_vi"]="8255",["flag_pl"]="8192",["children_crossing"]="715",["lizard"]="279",["curly_loop"]="7116",["arrow_right"]="729",["middle_finger"]="1165",["heavy_division_sign"]="7115",["second_place_medal"]="426",["rowboat"]="1404",["stars"]="5183",["heavy_heart_exclamation_mark_ornament"]="1125",["flag_td"]="8229",["grey_question"]="7125",["cat2"]="214",["flag_ne"]="8175",["x"]="7111",["sparkle"]="7121",["flag_ye"]="8261",["flag_kg"]="8129",["bar_chart"]="6163",["hocho"]="3120",["snowflake"]="5204",["potable_water"]="73",["flag_jp"]="8127",["santa"]="1326",["accept"]="7176",["star_of_david"]="751",["busts_in_silhouette"]="1482",["eyes"]="1194",["wave"]="1150",["heavy_multiplication_x"]="7110",["heavy_check_mark"]="7109",["cocktail"]="3106",["black_nib"]="6146",["full_moon_with_face"]="5178",["pencil2"]="6145",["thermometer"]="5176",["flag_de"]="866",["calendar"]="6157",["flag_gw"]="8105",["flag_ht"]="8111",["writing_hand"]="1180",["v"]="1157",["rocket"]="5129",["point_up"]="1167",["email"]="6132",["door"]="6213",["satellite"]="5128",["scissors"]="6171",["zap"]="5203",["clock5"]="5150",["loudspeaker"]="648",["flag_by"]="844",["church"]="541",["footprints"]="1483",["fuelpump"]="5104",["tent"]="548",["flag_sn"]="8218",["capricorn"]="769",["customs"]="711",["person_with_ball"]="1410",["rice"]="366",["smiley_cat"]="1103",["hotel"]="530",["woman_bouncing_ball"]="1412",["man_heart_man"]="1452",["ice_skate"]="448",["skier"]="1396",["boat"]="5111",["flag_ms"]="8165",["female_fairy"]="1339",["female_cook"]="1271",["snowman"]="5205",["woman_girl_girl"]="1479",["palm_tree"]="2119",["european_post_office"]="527",["ferry"]="5115",["dress"]="613",["flag_dm"]="870",["golf"]="447",["female_supervillain"]="1333",["flag_zm"]="8264",["vibration_mode"]="795",["flag_uz"]="8250",["flag_wf"]="8258",["umbrella_on_ground"]="5202",["ribbon"]="417",["point_left"]="1162",["mouse2"]="243",["mountain"]="59",["shinto_shrine"]="545",["blond_haired_woman"]="1219",["large_purple_circle"]="7189",["orange_heart"]="1128",["flag_scotland"]="8267",["sunrise"]="553",["helmet_with_white_cross"]="639",["man_wearing_turban"]="1317",["pick"]="6183",["anchor"]="5110",["partly_sunny"]="5186",["snowman_without_snow"]="5206",["busstop"]="5100",["flag_na"]="8173",["loud_sound"]="647",["rat"]="244",["file_cabinet"]="6173",["beginner"]="7105",["flag_mc"]="8151",["fleur_de_lis"]="7102",["musical_score"]="653",["desktop_computer"]="678",["kiss"]="1115",["frowning"]="172",["postal_horn"]="650",["coffin"]="6231",["linked_paperclips"]="6168",["man_boy_boy"]="1471",["black_circle"]="7191",["tooth"]="1192",["warning"]="714",["face_with_cowboy_hat"]="158",["clock230"]="5145",["four_leaf_clover"]="2124",["flag_lt"]="8146",["meat_on_bone"]="340",["flag_sc"]="8208",["first_place_medal"]="425",["kissing_closed_eyes"]="120",["alembic"]="6201",["ticket"]="421",["medical_symbol"]="799",["flag_bq"]="838",["hammer"]="6181",["thunder_cloud_and_rain"]="5187",["derelict_house_building"]="522",["waving_black_flag"]="84",["flag_as"]="819",["flag_cg"]="850",["hammer_and_pick"]="6184",["sandal"]="631",["gift_heart"]="1118",["dragon"]="282",["japanese_ogre"]="197",["infinity"]="7100",["champagne"]="3104",["recycle"]="7101",["hearts"]="468",["right_facing_fist"]="1173",["oncoming_police_car"]="582",["chess_pawn"]="471",["flag_ni"]="8178",["pisces"]="771",["tram"]="571",["diamond_shape_with_a_dot_inside"]="7214",["scorpius"]="767",["flag_mk"]="8157",["wheel_of_dharma"]="752",["libra"]="766",["mosque"]="542",["virgo"]="765",["one"]="7135",["shopping_trolley"]="6229",["woman_rowing_boat"]="1406",["vertical_traffic_light"]="5107",["revolving_hearts"]="1122",["sound"]="646",["bowl_with_spoon"]="357",["female_technologist"]="1286",["man_with_bunny_ears_partying"]="1386",["rewind"]="781",["flag_ba"]="825",["crying_cat_face"]="1110",["free"]="7155",["flag_pw"]="8198",["female_sign"]="797",["flag_ac"]="88",["arrow_double_down"]="786",["white_frowning_face"]="166",["heartbeat"]="1121",["small_airplane"]="5119",["peace_symbol"]="757",["star_and_crescent"]="756",["orthodox_cross"]="755",["monkey"]="22",["radioactive_sign"]="725",["mega"]="649",["skull_and_crossbones"]="194",["old_key"]="6180",["flag_es"]="879",["fist"]="1170",["shamrock"]="2123",["black_circle_for_record"]="789",["coffee"]="3101",["file_folder"]="6153",["man_mountain_biking"]="1420",["male_detective"]="1306",["ballot_box_with_check"]="7108",["candy"]="395",["comet"]="5207",["flag_in"]="8118",["cloud"]="5185",["sunny"]="5177",["flag_gq"]="8100",["woman_in_steamy_room"]="1390",["id"]="7157",["cricket_bat_and_ball"]="438",["female_zombie"]="1354",["nerd_face"]="161",["flag_kn"]="8133",["white_medium_small_square"]="7205",["flag_ag"]="812",["page_with_curl"]="6113",["white_medium_square"]="7203",["dumpling"]="377",["copyright"]="7129",["clock330"]="5147",["fried_shrimp"]="373",["arrow_backward"]="780",["flag_bi"]="832",["fish"]="288",["fax"]="674",["drop_of_blood"]="6209",["house"]="523",["woman_wearing_turban"]="1318",["bald_woman"]="1217",["low_brightness"]="792",["seven"]="7141",["flag_ec"]="874",["card_index_dividers"]="6155",["safety_vest"]="65",["flag_ir"]="8121",["timer_clock"]="5138",["mag_right"]="698",["otter"]="255",["flag_mz"]="8172",["stopwatch"]="5137",["takeout_box"]="379",["alarm_clock"]="5136",["ocean"]="5210",["black_right_pointing_triangle_with_double_vertical_bar"]="779",["cl"]="7153",["black_left_pointing_double_triangle_with_vertical_bar"]="782",["relaxed"]="119",["fast_forward"]="777",["registered"]="7130",["woman_in_manual_wheelchair"]="1378",["eject"]="790",["keyboard"]="680",["flag_cv"]="861",["aerial_tramway"]="5127",["ballet_shoes"]="632",["male_scientist"]="1282",["smoking"]="6230",["woman_walking"]="1363",["leftwards_arrow_with_hook"]="737",["badger"]="258",["swimmer"]="1407",["hourglass_flowing_sand"]="5134",["underage"]="724",["woman_juggling"]="1436",["flamingo"]="273",["one_piece_swimsuit"]="616",["left_right_arrow"]="736",["information_source"]="7156",["woman_in_lotus_position"]="1439",["clock1130"]="5163",["fallen_leaf"]="2126",["woman_biking"]="1418",["horse_racing"]="1395",["interrobang"]="7123",["hushed"]="168",["man_in_motorized_wheelchair"]="1374",["mrs_claus"]="1327",["closed_umbrella"]="5199",["lower_left_ballpoint_pen"]="6148",["razor"]="6220",["ringed_planet"]="5180",["woman_heart_man"]="1451",["parachute"]="5122",["raised_hand_with_fingers_splayed"]="1152",["kite"]="457",["male_police_officer"]="1303",["star"]="5181",["trident"]="7103",["mute"]="644",["balloon"]="47",["relieved"]="142",["flag_cf"]="849",["kaaba"]="546",["flag_gi"]="895",["flag_fk"]="884",["earth_asia"]="53",["ambulance"]="579",["date"]="6156",["flag_sy"]="8225",["clock4"]="5148",["partying_face"]="159",["speak_no_evil"]="1114",["adhesive_bandage"]="6211",["blond_haired_man"]="1220",["rugby_football"]="434",["notebook_with_decorative_cover"]="6104",["flag_az"]="824",["white_small_square"]="7207",["shorts"]="618",["flag_to"]="8238",["flag_bg"]="830",["arrow_up_down"]="735",["open_file_folder"]="6154",["flag_np"]="8181",["police_car"]="581",["watch"]="5135",["guide_dog"]="27",["sponge"]="6227",["flag_mr"]="8164",["soap"]="6226",["roll_of_paper"]="6225",["basket"]="6224",["tongue"]="1196",["teddy_bear"]="466",["penguin"]="267",["male_cook"]="1270",["e_mail"]="6133",["spaghetti"]="369",["flag_st"]="8222",["eight"]="7142",["thread"]="478",["sa"]="7168",["flag_cn"]="856",["clock12"]="5140",["face_with_hand_over_mouth"]="129",["vampire"]="1340",["service_dog"]="28",["bed"]="6214",["clapper"]="691",["female_superhero"]="1330",["flag_um"]="8246",["bricks"]="520",["link"]="6197",["snowboarder"]="1397",["flag_pg"]="8189",["crown"]="634",["laughing"]="15",["new_moon_with_face"]="5173",["toolbox"]="6199",["diving_mask"]="450",["fire_extinguisher"]="6228",["compass"]="57",["large_purple_square"]="7198",["baby"]="1198",["test_tube"]="6202",["woozy_face"]="155",["red_envelope"]="416",["socks"]="612",["coat"]="611",["flag_gf"]="892",["flag_us"]="8248",["aquarius"]="770",["brain"]="1191",["fried_egg"]="354",["male_zombie"]="1353",["genie"]="1349",["adult"]="1202",["flag_ie"]="8115",["female_genie"]="1351",["hibiscus"]="2112",["joy_cat"]="1105",["male_elf"]="1347",["female_elf"]="1348",["merperson"]="1343",["merman"]="1344",["mermaid"]="1345",["butterfly"]="295",["lotion_bottle"]="6221",["flag_cw"]="862",["person_with_pouting_face"]="1227",["national_park"]="516",["shushing_face"]="130",["male_fairy"]="1338",["mage"]="1334",["fishing_pole_and_fish"]="449",["female_mage"]="1336",["flag_ar"]="818",["pineapple"]="37",["safety_pin"]="6222",["tm"]="7131",["juggling"]="1434",["traffic_light"]="5106",["male_factory_worker"]="1276",["clock7"]="5154",["avocado"]="318",["video_game"]="461",["flag_tg"]="8231",["control_knobs"]="658",["eye"]="1195",["family"]="1454",["t_rex"]="284",["person_with_headscarf"]="1320",["rhinoceros"]="240",["bow_and_arrow"]="6189",["eggplant"]="319",["older_adult"]="1221",["male_genie"]="1350",["bikini"]="619",["flag_im"]="8117",["face_with_monocle"]="162",["icecream"]="385",["deaf_man"]="1243",["flag_mu"]="8167",["deaf_woman"]="1244",["man_swimming"]="1408",["kneeling_person"]="1367",["man_kneeling"]="1368",["flag_sa"]="8206",["clock9"]="5158",["mortar_board"]="637",["ship"]="5117",["standing_person"]="1364",["crossed_flags"]="83",["ice_cube"]="3115",["red_haired_man"]="1206",["pancakes"]="337",["mate_drink"]="3114",["black_joker"]="472",["woman_swimming"]="1409",["croissant"]="333",["bouquet"]="2106",["butter"]="360",["speech_balloon"]="1144",["factory"]="535",["man_with_turban"]="1316",["grimacing"]="140",["place_of_worship"]="748",["salt"]="361",["flag_er"]="878",["basketball"]="431",["cupcake"]="392",["parrot"]="275",["sushi"]="372",["globe_with_meridians"]="54",["monorail"]="572",["motorized_wheelchair"]="595",["ear_with_hearing_aid"]="1189",["arrow_lower_left"]="732",["fountain"]="547",["superhero"]="1328",["flag_ky"]="8137",["flag_me"]="8153",["performing_arts"]="475",["flag_fr"]="887",["magnet"]="6200",["white_circle"]="7192",["foot"]="1187",["falafel"]="352",["city_sunrise"]="555",["smirk_cat"]="1107",["banjo"]="667",["hospital"]="528",["watermelon"]="33",["receipt"]="6128",["water_buffalo"]="226",["sweet_potato"]="370",["hash"]="7132",["oyster"]="384",["flag_bh"]="831",["hotdog"]="347",["arrow_upper_left"]="734",["orangutan"]="24",["swan"]="271",["microbe"]="2105",["ice_hockey_stick_and_puck"]="440",["tada"]="48",["woman_woman_boy"]="1465",["briefs"]="617",["gem"]="643",["raccoon"]="212",["flag_au"]="821",["train"]="574",["flag_wales"]="8268",["cheese_wedge"]="339",["man_pouting"]="1228",["hippopotamus"]="241",["flag_vc"]="8252",["peacock"]="274",["cricket"]="2100",["man"]="1204",["man_in_steamy_room"]="1389",["boar"]="230",["flag_mm"]="8159",["sauropod"]="283",["reminder_ribbon"]="419",["hedgehog"]="249",["telescope"]="6206",["zebra_face"]="222",["woman_golfing"]="1400",["giraffe_face"]="238",["squid"]="383",["shrimp"]="382",["tiger"]="216",["izakaya_lantern"]="6102",["flag_zw"]="8265",["bearded_person"]="1205",["evergreen_tree"]="2117",["gun"]="6188",["gorilla"]="23",["potato"]="320",["deer"]="223",["fox_face"]="211",["barely_sunny"]="5189",["man_surfing"]="1402",["nut_and_bolt"]="6192",["mountain_railway"]="573",["owl"]="272",["shark"]="291",["bat"]="250",["flag_ae"]="810",["eagle"]="269",["pound"]="6125",["leopard"]="218",["boot"]="633",["first_quarter_moon_with_face"]="5174",["desert_island"]="515",["sled"]="453",["turkey"]="260",["repeat"]="774",["scorpion"]="2103",["mailbox_closed"]="6140",["person_climbing"]="1391",["flag_eu"]="881",["womans_flat_shoe"]="629",["fireworks"]="43",["hole"]="1142",["tumbler_glass"]="3111",["hiking_boot"]="628",["ram"]="232",["flag_gh"]="894",["flag_fj"]="883",["female_teacher"]="1262",["large_orange_square"]="7194",["goggles"]="63",["flag_sx"]="8224",["sports_medal"]="424",["flag_tf"]="8230",["sake"]="3103",["lab_coat"]="64",["cupid"]="1117",["left_facing_fist"]="1172",["water_polo"]="1428",["pleading_face"]="171",["moneybag"]="6121",["cold_face"]="154",["hot_face"]="153",["fortune_cookie"]="378",["dove_of_peace"]="268",["firecracker"]="45",["radio_button"]="7215",["flag_am"]="815",["three_button_mouse"]="681",["chopsticks"]="3116",["notebook"]="6111",["smiling_face_with_3_hearts"]="114",["trophy"]="423",["pretzel"]="335",["vhs"]="696",["moon_cake"]="375",["woman_lifting_weights"]="1415",["bowling"]="437",["flag_ee"]="875",["ab"]="7151",["canned_food"]="362",["flag_it"]="8123",["four"]="7138",["sandwich"]="348",["ear"]="1188",["woman_pouting"]="1229",["rosette"]="2109",["hankey"]="195",["flag_do"]="871",["euro"]="6124",["bagel"]="336",["pie"]="393",["lobster"]="381",["cup_with_straw"]="3112",["flag_tn"]="8237",["gemini"]="762",["yawning_face"]="186",["peanuts"]="330",["heart_eyes"]="115",["luggage"]="5132",["egg"]="353",["male_doctor"]="1255",["8ball"]="458",["stuffed_flatbread"]="351",["female_guard"]="1310",["green_salad"]="358",["baguette_bread"]="334",["carrot"]="321",["dango"]="376",["bacon"]="343",["kimono"]="614",["round_pushpin"]="6166",["tulip"]="2115",["cucumber"]="324",["knife_fork_plate"]="3117",["woman_climbing"]="1393",["sparkles"]="46",["bathtub"]="6219",["camera_with_flash"]="694",["flag_th"]="8232",["flag_id"]="8114",["medal"]="422",["third_place_medal"]="427",["bear"]="251",["flag_ki"]="8131",["chocolate_bar"]="394",["ok"]="7162",["birthday"]="390",["heavy_plus_sign"]="7113",["rose"]="2110",["clinking_glasses"]="3110",["hear_no_evil"]="1113",["man_playing_handball"]="1432",["chicken"]="261",["flag_fm"]="885",["crocodile"]="277",["sari"]="615",["feet"]="259",["doughnut"]="388",["woman_wrestling"]="1427",["oncoming_taxi"]="584",["fencer"]="1394",["man_juggling"]="1435",["arrow_lower_right"]="730",["fork_and_knife"]="3118",["flag_nc"]="8174",["clock6"]="5152",["classical_building"]="518",["person_doing_cartwheel"]="1422",["cityscape"]="551",["man_cartwheeling"]="1423",["woman_cartwheeling"]="1424",["night_with_stars"]="550",["shrug"]="1251",["man_shrugging"]="1252",["woman_shrugging"]="1253",["man_in_tuxedo"]="1321",["male_teacher"]="1261",["handshake"]="1178",["no_pedestrians"]="722",["man_gesturing_ok"]="1234",["flag_il"]="8116",["red_circle"]="7184",["prince"]="1314",["office"]="525",["flag_mt"]="8166",["flag_lv"]="8148",["selfie"]="1182",["flag_tv"]="8241",["breast_feeding"]="1324",["i_love_you_hand_sign"]="1159",["male_artist"]="1291",["exploding_head"]="157",["violin"]="666",["flag_bs"]="840",["flag_dg"]="867",["runner"]="1379",["arrow_down_small"]="785",["face_vomiting"]="151",["oncoming_bus"]="576",["joy"]="18",["strawberry"]="314",["face_with_symbols_on_mouth"]="190",["u7a7a"]="7179",["zany_face"]="125",["stew"]="356",["the_horns"]="1160",["man_facepalming"]="1249",["woman_facepalming"]="1250",["lying_face"]="141",["stuck_out_tongue_winking_eye"]="124",["briefcase"]="6152",["compression"]="6194",["rolling_on_the_floor_laughing"]="17",["nauseated_face"]="150",["atom_symbol"]="749",["flag_ca"]="846",["older_woman"]="1223",["pregnant_woman"]="1323",["school"]="533",["cactus"]="2120",["triangular_ruler"]="6170",["studio_microphone"]="656",["clock8"]="5156",["flag_md"]="8152",["crossed_fingers"]="1158",["clubs"]="470",["slot_machine"]="463",["call_me_hand"]="1161",["lock"]="6175",["face_with_raised_eyebrow"]="133",["bangbang"]="7122",["muscle"]="1183",["man_rowing_boat"]="1405",["zipper_mouth_face"]="132",["brown_heart"]="1133",["pinching_hand"]="1156",["white_heart"]="1135",["flag_sh"]="8212",["large_brown_square"]="7199",["large_green_square"]="7196",["large_yellow_square"]="7195",["microphone"]="659",["camel"]="236",["soon"]="746",["blush"]="112",["large_red_square"]="7193",["large_brown_circle"]="7190",["chains"]="6198",["lips"]="1197",["large_green_circle"]="7187",["scroll"]="6114",["cherries"]="313",["flag_at"]="820",["auto_rickshaw"]="596",["skateboard"]="599",["christmas_tree"]="42",["sleepy"]="144",["canoe"]="5112",["pig2"]="229",["flag_xk"]="8260",["motor_scooter"]="593",["flag_ru"]="8204",["scooter"]="598",["flag_ci"]="852",["flag_ml"]="8158",["envelope_with_arrow"]="6135",["keycap_ten"]="7144",["non_potable_water"]="721",["white_check_mark"]="7107",["airplane_departure"]="5120",["cop"]="1302",["yin_yang"]="753",["waning_gibbous_moon"]="5169",["pig_nose"]="231",["keycap_star"]="7133",["man_frowning"]="1225",["man_golfing"]="1399",["motorway"]="5101",["oil_drum"]="5103",["hammer_and_wrench"]="6185",["name_badge"]="7104",["hindu_temple"]="543",["cold_sweat"]="175",["flag_ga"]="888",["no_mouth"]="136",["necktie"]="66",["left_speech_bubble"]="1146",["clock730"]="5155",["baggage_claim"]="712",["walking"]="1361",["passport_control"]="710",["flag_ad"]="89",["fairy"]="1337",["ferris_wheel"]="559",["toilet"]="6217",["baby_symbol"]="78",["oncoming_automobile"]="586",["mens"]="75",["mountain_bicyclist"]="1419",["flag_py"]="8199",["flag_re"]="8201",["umbrella_with_rain_drops"]="5201",["flag_kp"]="8134",["man_man_boy"]="1460",["flag_et"]="880",["card_index"]="6160",["man_biking"]="1417",["flag_ma"]="8150",["passenger_ship"]="5114",["football"]="433",["eight_pointed_black_star"]="7120",["monkey_face"]="21",["do_not_litter"]="720",["flag_vu"]="8257",["dvd"]="686",["clock1230"]="5141",["lion_face"]="215",["airplane"]="5118",["no_good"]="1230",["rotating_light"]="5105",["put_litter_in_its_place"]="72",["tropical_drink"]="3107",["speedboat"]="5113",["face_with_thermometer"]="148",["cancer"]="763",["woman_kneeling"]="1369",["hourglass"]="5133",["mountain_cableway"]="5126",["flag_rw"]="8205",["shaved_ice"]="386",["mechanical_arm"]="1184",["articulated_lorry"]="589",["flag_al"]="814",["a"]="7150",["1234"]="7147",["blue_car"]="587",["green_apple"]="310",["key"]="6179",["womens"]="76",["couple_with_heart"]="1450",["female_scientist"]="1283",["older_man"]="1222",["flag_cx"]="863",["crystal_ball"]="459",["spades"]="467",["fire_engine"]="580",["minibus"]="578",["trolleybus"]="577",["table_tennis_paddle_and_ball"]="442",["grin"]="14",["train2"]="567",["light_rail"]="569",["flag_ve"]="8253",["bullettrain_front"]="566",["dart"]="455",["love_hotel"]="531",["baby_chick"]="264",["bullettrain_side"]="565",["railway_car"]="564",["flag_bz"]="845",["steam_locomotive"]="563",["hand"]="1153",["female_vampire"]="1342",["leg"]="1186",["skull"]="193",["motor_boat"]="5116",["raised_hands"]="1175",["white_haired_woman"]="1215",["raising_hand"]="1239",["woman_raising_hand"]="1241",["post_office"]="526",["flag_nr"]="8182",["wilted_flower"]="2111",["bow"]="1245",["man_bowing"]="1246",["woman_bowing"]="1247",["woman_gesturing_ok"]="1235",["triangular_flag_on_post"]="82",["black_square_button"]="7217",["woman_gesturing_no"]="1232",["face_with_rolling_eyes"]="139",["u7981"]="7175",["slightly_smiling_face"]="19",["slightly_frowning_face"]="165",["u6708"]="7169",["pouting_cat"]="1111",["point_down"]="1166",["kissing_cat"]="1108",["heart_eyes_cat"]="1106",["bee"]="298",["man_bouncing_ball"]="1411",["woman_woman_girl_girl"]="1469",["prayer_beads"]="640",["couch_and_lamp"]="6215",["chestnut"]="331",["male_technologist"]="1285",["scream"]="179",["bellhop_bell"]="5131",["face_with_head_bandage"]="149",["open_mouth"]="167",["sob"]="178",["poultry_leg"]="341",["flag_ea"]="873",["green_heart"]="1130",["flying_saucer"]="5130",["level_slider"]="657",["thumbsup"]="1168",["triumph"]="187",["bridge_at_night"]="556",["broken_heart"]="1126",["cry"]="177",["rage"]="188",["beer"]="3108",["amphora"]="3121",["disappointed"]="182",["stuck_out_tongue_closed_eyes"]="126",["stuck_out_tongue"]="123",["rabbit"]="246",["flag_pa"]="8186",["kissing_smiling_eyes"]="121",["flag_je"]="8124",["kissing_heart"]="117",["flag_cp"]="858",["kissing"]="118",["mans_shoe"]="626",["confounded"]="180",["pensive"]="143",["sweat"]="183",["neutral_face"]="134",["large_blue_diamond"]="7209",["memo"]="6151",["sunglasses"]="160",["house_with_garden"]="524",["wink"]="111",["flag_io"]="8119",["smiling_imp"]="191",["flag_ss"]="8221",["european_castle"]="537",["flag_mw"]="8169",["flag_br"]="839",["woman_getting_haircut"]="1360",["smile"]="13",["flag_co"]="857",["red_haired_woman"]="1211",["tokyo_tower"]="539",["mount_fuji"]="511",["tired_face"]="185",["dagger_knife"]="6186",["drooling_face"]="145",["male_student"]="1258",["wastebasket"]="6174",["pear"]="311",["u6709"]="7170",["flag_ug"]="8245",["moon"]="5167",["soccer"]="428",["card_file_box"]="6172",["new"]="7159",["deciduous_tree"]="2118",["blossom"]="2114",["frame_with_picture"]="476",["u55b6"]="7182",["tomato"]="316",["flag_mh"]="8156",["back"]="743",["flag_nu"]="8183",["flag_jm"]="8125",["clock930"]="5159",["bento"]="363",["cake"]="391",["flag_ta"]="8227",["zombie"]="1352",["curling_stone"]="454",["flag_tc"]="8228",["synagogue"]="544",["b"]="7152",["banana"]="36",["suspension_railway"]="5125",["flag_bb"]="826",["flag_si"]="8213",["negative_squared_cross_mark"]="7112",["black_square_for_stop"]="788",["inbox_tray"]="6137",["flag_kz"]="8138",["spock_hand"]="1154",["hamburger"]="344",["pager"]="673",["flag_pf"]="8188",["abc"]="7149",["taxi"]="583",["flag_cc"]="847",["leo"]="764",["tornado"]="5194",["dash"]="1141",["sun_with_face"]="5179",["goal_net"]="446",["yen"]="6122",["peach"]="312",["flag_be"]="828",["golfer"]="1398",["syringe"]="6208",["waving_white_flag"]="85",["cyclone"]="5197",["flag_ly"]="8149",["honey_pot"]="398",["grapes"]="31",["flag_aw"]="822",["flashlight"]="6101",["rainbow_flag"]="86",["flag_ch"]="851",["twisted_rightwards_arrows"]="773",["corn"]="322",["thinking_face"]="131",["flag_sd"]="8209",["two"]="7136",["black_small_square"]="7206",["man_in_lotus_position"]="1438",["flag_ke"]="8128",["flag_mo"]="8161",["flag_fi"]="882",["lacrosse"]="441",["roller_coaster"]="560",["mechanical_leg"]="1185",["flag_sk"]="8215",["flag_ax"]="823",["scream_cat"]="1109",["flag_bj"]="833",["smiley"]="12",["umbrella"]="5200",["pirate_flag"]="87",["truck"]="588",["flag_mg"]="8155",["gloves"]="610",["woman_woman_girl_boy"]="1467",["rain_cloud"]="5191",["flag_hn"]="8109",["arrow_up_small"]="783",["flag_tl"]="8235",["wind_blowing_face"]="5196",["flag_tw"]="8242",["bug"]="296",["woman_girl"]="1477",["mailbox"]="6139",["female_farmer"]="1268",["100"]="1136",["woman_tipping_hand"]="1238",["couple"]="1444",["angry"]="189",["female_student"]="1259",["bomb"]="1143",["bike"]="597",["snake"]="280",["bone"]="1193",["man_with_probing_cane"]="1371",["flag_gy"]="8106",["book"]="6106",["black_medium_square"]="7202",["gear"]="6193",["flag_li"]="8142",["floppy_disk"]="684",["crescent_moon"]="5172",["mostly_sunny"]="5188",["dizzy_face"]="156",["clock1"]="5142",["diya_lamp"]="6103",["new_moon"]="5164",["top"]="747",["ski"]="452",["dragon_face"]="281",["cow"]="224",["coconut"]="317",["person_frowning"]="1224",["tv"]="692",["flag_ic"]="8113",["waning_crescent_moon"]="5171",["shower"]="6218",["woman_standing"]="1366",["game_die"]="464",["flag_va"]="8251",["flag_dz"]="872",["poodle"]="29",["bird"]="266",["zero"]="7134",["male_mage"]="1335",["foggy"]="549",["flag_ws"]="8259",["flag_ao"]="816",["building_construction"]="519",["dog2"]="26",["flag_rs"]="8203",["anger"]="1137",["cherry_blossom"]="2107",["space_invader"]="1101",["man_man_boy_boy"]="1463",["mahjong"]="473",["flag_nz"]="8184",["herb"]="2122",["tangerine"]="34",["white_square_button"]="7216",["u6e80"]="7183",["school_satchel"]="625",["black_medium_small_square"]="7204",["flag_sz"]="8226",["atm"]="71",["flag_gu"]="8104",["zzz"]="1149",["flag_lr"]="8144",["love_letter"]="1116",["popcorn"]="359",["page_facing_up"]="6115",["flag_pn"]="8194",["ideograph_advantage"]="7172",["man_girl_girl"]="1474",["flag_bm"]="835",["apple"]="39",["male_guard"]="1309",["convenience_store"]="532",["boy"]="1200",["flag_england"]="8266",["department_store"]="534",["cut_of_meat"]="342",["badminton_racquet_and_shuttlecock"]="443",["flag_la"]="8139",["flower_playing_cards"]="474",["rabbit2"]="247",["pill"]="6210",["black_heart"]="1134",["whale2"]="286",["snail"]="294",["racehorse"]="220",["woman_playing_handball"]="1433",["glass_of_milk"]="3100",["woman_boy_boy"]="1476",["octopus"]="292",["arrow_left"]="733",["nail_care"]="1181",["persevere"]="181",["notes"]="655",["woman_woman_boy_boy"]="1468",["flag_dj"]="868",["beetle"]="299",["tropical_fish"]="289",["outbox_tray"]="6136",["seedling"]="2116",["flag_un"]="8247",["dolphin"]="287",["mouse"]="242",["bookmark"]="6119",["bread"]="332",["sos"]="7164",["male_vampire"]="1341",["six_pointed_star"]="759",["cat"]="213",["wolf"]="210",["books"]="6110",["latin_cross"]="754",["nose"]="1190",["end"]="744",["flag_gr"]="8101",["female_firefighter"]="1301",["point_up_2"]="1164",["point_right"]="1163",["innocent"]="113",["sheep"]="233",["upside_down_face"]="110",["open_hands"]="1176",["clap"]="1174",["ghost"]="199",["people_holding_hands"]="1442",["star_struck"]="116",["female_mechanic"]="1274",["unicorn_face"]="221",["lipstick"]="641",["japanese_castle"]="536",["arrows_counterclockwise"]="742",["bookmark_tabs"]="6118",["bicyclist"]="1416",["man_woman_girl_boy"]="1457",["sleeping"]="146",["shallow_pan_of_food"]="355",["arrow_right_hook"]="738",["woman_girl_boy"]="1478",["flag_sr"]="8220",["man_tipping_hand"]="1237",["flag_gm"]="897",["information_desk_person"]="1236",["flag_hm"]="8108",["female_singer"]="1289",["vs"]="7166",["woman_playing_water_polo"]="1430",["flag_vn"]="8256",["mag"]="697",["closed_book"]="6105",["woman_woman_girl"]="1466",["curly_haired_woman"]="1213",["flag_kh"]="8130",["japanese_goblin"]="198",["incoming_envelope"]="6134",["mailbox_with_mail"]="6141",["musical_keyboard"]="664",["hatching_chick"]="263",["taurus"]="761",["female_judge"]="1265",["minidisc"]="683",["handbag"]="622",["man_with_gua_pi_mao"]="1319",["dna"]="6204",["u6307"]="7171",["woman_in_motorized_wheelchair"]="1375",["mosquito"]="2104",["alien"]="1100",["u5272"]="7173",["flag_ph"]="8190",["eight_spoked_asterisk"]="7119",["male_mechanic"]="1273",["rice_ball"]="365",["flag_mv"]="8168",["scales"]="6195",["dancer"]="1382",["city_sunset"]="554",["two_men_holding_hands"]="1445",["flag_sb"]="8207",["ring"]="642",["haircut"]="1358",["flag_cy"]="864",["flag_eg"]="876",["woman_with_bunny_ears_partying"]="1387",["horse"]="219",["flag_pe"]="8187",["flag_gs"]="8102",["woman_surfing"]="1403",["right_anger_bubble"]="1147",["sweat_drops"]="1140",["partly_sunny_rain"]="5190",["battery"]="675",["waffle"]="338",["dollar"]="6123",["saxophone"]="662",["guardsman"]="1308",["seat"]="5123",["bank"]="529",["man_getting_haircut"]="1359",["man_in_manual_wheelchair"]="1377",["large_orange_diamond"]="7208",["male_office_worker"]="1279",["man_climbing"]="1392",["confetti_ball"]="49",["girl"]="1201",["flag_fo"]="886",["leafy_green"]="325",["woman_boy"]="1475",["telephone_receiver"]="672",["cd"]="685",["satellite_antenna"]="6207",["turtle"]="278",["flag_mf"]="8154",["female_factory_worker"]="1277",["racing_car"]="591",["funeral_urn"]="6232",["mobile_phone_off"]="796",["mango"]="38",["volleyball"]="432",["billed_cap"]="638",["man_man_girl_boy"]="1462",["blowfish"]="290",["palms_up_together"]="1177",["heart"]="1127",["flag_gp"]="899",["dizzy"]="1139",["flag_sj"]="8214",["electric_plug"]="676",["man_lifting_weights"]="1414",["yarn"]="479",["station"]="570",["construction_worker"]="1311",["droplet"]="5209",["capital_abcd"]="7145",["curly_haired_man"]="1207",["flag_vg"]="8254",["flag_bt"]="841",["checkered_flag"]="81",["heavy_dollar_sign"]="6131",["flag_gl"]="896",["small_blue_diamond"]="7211",["signal_strength"]="794",["dog"]="25",["worried"]="164",}
--addons/scb_chatbox/lua/scb/vgui/scb_emojis_select.lua:
if SCB_LOADED then return end

local draw = draw

local scb = scb
local sui = sui
local SUI = scb.SUI

local Panel = {}

AccessorFunc(Panel, "m_bTextEntry", "TextEntry")

function Panel:Init()
	self.emojis = {}
end

local line_DoClick = function(s)
	local parent = s:GetParent()
	parent[KEY_ENTER](parent)
end

local emoji_Paint = function(s, w, h)
	local parent = s.parent
	if parent.selected_emoji == s then
		draw.RoundedBox(0, 0, 0, w, h, SUI.GetColor("emoji_select_menu_selected"))
	end
end

local emoji_OnCursorEntered = function(s)
	s.parent.selected_emoji = s.emoji
end

function Panel:AddEmoji(name)
	local line = self:Add("DButton")
	line:Dock(TOP)
	line:SetTall(SUI.ScaleEven(22))
	line:InvalidateParent(true)
	line:SetText("")
	line.Paint = nil
	line.DoClick = line_DoClick
	line.parent = self
	line.OnCursorEntered = emoji_OnCursorEntered

	local emoji = line:Add("SCB.ChatLine")
	emoji:Dock(NODOCK)
	emoji:SetSize(line:GetSize())
	emoji:NewLabel(" ")
	emoji:NewEmoji(name, scb.emojis[name], 20)
	emoji:NewLabel(" :" .. name .. ":")
	emoji:Center()
	emoji:SetMouseInputEnabled(false)

	emoji.parent = self
	emoji.name = name
	emoji.Paint = emoji_Paint

	emoji.i = table.insert(self.emojis, emoji)

	if emoji.i == 1 then
		self.selected_emoji = emoji
	end

	line.emoji = emoji

	self:InvalidateLayout(true)
	self:SizeToChildren(false, true)

	return emoji
end

function Panel:SetStartEnd(start, _end)
	self.start, self._end = start, _end
end

function Panel:Paint(w, h)
	if SUI.GetColor("frame_blur") then
		sui.TDLib.BlurPanel(self)
	end

	draw.RoundedBox(3, 0, 0, w, h, SUI.GetColor("emoji_select_menu"))
end

Panel[KEY_UP] = function(self)
	self.selected_emoji = self.emojis[self.selected_emoji.i - 1] or self.emojis[#self.emojis]
	return true
end

Panel[KEY_DOWN] = function(self)
	self.selected_emoji = self.emojis[self.selected_emoji.i + 1] or self.emojis[1]
	return true
end

Panel[KEY_ENTER] = function(self)
	local text_entry = self:GetTextEntry()
	text_entry:RequestFocus()
	text_entry:AddValue(":" .. self.selected_emoji.name .. ": ", self.start - 1, self._end + 1)

	scb.emoji_set_used(self.selected_emoji.name)
	return true
end
Panel[KEY_TAB] = Panel[KEY_ENTER]

Panel[KEY_ESCAPE] = function(self)
	gui.HideGameUI()
	self:Remove()
end

sui.register("EmojisSelect", Panel, "Panel")
--gamemodes/starwarsrp/gamemode/modules/medicsystem_droid/treatments/welder.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Schweißgerät"
Treatment.Description = "Dies ist ein Schweißgerät."

Treatment.TreatmentTime = 2
Treatment.ForceCustomMessage = true

Treatment.Type = {["Repairkit"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "HL1/ambience/port_suckin1.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	if not patient:IsDroid() then return false end

	return true
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" verwendete ein Schweißgerät."
	})

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	if not patient:IsDroid() then return false end

	-- Patient must be a alive player
	if patient:IsPlayer() and patient:Alive() then
		return true
	end

	return false
end

Treatment.GlobalUseFunction = function(self, ply, patient, hitgroup)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" verwendete ein Schweißgerät."
	})

	patient:SetHealth(math.min(math.ceil(patient:Health() + 30), patient:GetMaxHealth()))

	return true
end

Medicsystem:RegisterTreatment("welder", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/bloodaspirator.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Blutabsauger"
Treatment.Description = "Mit diesem chirurgischen Gerät ist es möglich, angesammeltes Blut zu entfernen."

Treatment.TreatmentTime = 12
Treatment.UseMessage = "verwendet einen Blutabsauger."

Treatment.Type = {["Opkit"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/buzz.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	if injury.name == "Innere Blutung" then return true end

	return false
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	if injury.name == "Innere Blutung" then
		Medicsystem:SendMessage(ply, {
			team.GetColor(ply:Team()),
			ply:GetCurrentCharacterFullName(),
			" entfernt mit Hilfe des Blutabsaugers Blut aus der Wunde im ",
			hitgroup,
			" von ",
			Medicsystem:GetCurrentCharacterFullName(patient),
			"."
		})
	end

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("bloodaspirator", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/myocaine.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Myocaine"
Treatment.Description = "Myocaine ist ein Medikament, welches die Muskelne entspannt. Es hat weder Geruch, Geschmack, noch Farbe, wenn es flüssig verabreicht wird."

Treatment.TreatmentTime = 6
Treatment.UseMessage = "verwendet Myocaine."

Treatment.Type = {["Injector"] = true, ["SWT"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/squirt.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	return true
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" injizierte ",
		self.Name,
		" in ",
		injury.name,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return true
end

Treatment.GlobalUseFunction = function(self, ply, patient, hitgroup)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" injizierte ",
		self.Name,
		" in den/das ",
		hitgroup,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	return true
end

Medicsystem:RegisterTreatment("myocaine", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/radiation.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Strahlungsimpfung"
Treatment.Description = "Dies ist ein Mittel zur Behandlung von Strahlungseinwirkungen."

Treatment.TreatmentTime = 8
Treatment.UseMessage = "verwendet eine Strahlungsimpfung."

Treatment.Type = {["Injector"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/squirt.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return false
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	-- Patient mustn't be a droid
	if patient:IsDroid() then return false end

	return true
end

Treatment.GlobalUseFunction = function(self, ply, patient, hitgroup)
	Medicsystem:SendMessage(ply, {
		team.GetColor(ply:Team()),
		ply:GetCurrentCharacterFullName(),
		" injizierte die ",
		self.Name,
		" in den/das ",
		hitgroup,
		" von ",
		Medicsystem:GetCurrentCharacterFullName(patient),
		"."
	})

	return true
end

Medicsystem:RegisterTreatment("radiation", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/treatments/woundglue.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--      Medicsystem | Treatment      --
---------------------------------------

local Treatment = {}

Treatment.Name = "Wundkleber"
Treatment.Description = "Ein Wundverband, der eine offene Wunde verschließt."

Treatment.TreatmentTime = 6
Treatment.UseMessage = "verwendet Wundkleber."

Treatment.Type = {["Kit"] = true}

Treatment.TreatmentSound = function(self, ply)
	return "medkit/buzz.wav"
end

Treatment.CanLocalUse = function(self, ply, patient, hitgroup, injury)
	return true
end

Treatment.LocalUseFunction = function(self, ply, patient, hitgroup, injury)
	if injury == "innerbleeding" then
		Medicsystem:SendMessage(ply, {
			team.GetColor(ply:Team()),
			ply:GetCurrentCharacterFullName(),
			" verschloss den Schnitt am ",
			hitgroup,
			" von ",
			Medicsystem:GetCurrentCharacterFullName(patient),
			" mit ",
			self.Name,
			"."
		})
	else
		Medicsystem:SendMessage(ply, {
			team.GetColor(ply:Team()),
			ply:GetCurrentCharacterFullName(),
			" verschloss ",
			injury.name,
			" von ",
			Medicsystem:GetCurrentCharacterFullName(patient),
			" mit ",
			self.Name,
			"."
		})
	end

	return true
end

Treatment.CanGlobalUse = function(self, ply, patient, hitgroup)
	return false
end

Medicsystem:RegisterTreatment("woundglue", Treatment)




--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/injuries/contusion.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Prellung"
Injury.Treatments = {
	["anticeptind"] = true,
	["nullicaine"] = true,
	["bactabandage"] = true
}

-- Until which severity a single bacta can heal the injury
Injury.BactaHeal = 4

Injury.Detection = {
	["Medicsystem.AddInjury"] = function(ply, hitgroup, dmgInfo)
		-- Player mustn't be a droid
		if ply:IsDroid() then return end

		local hitgroups = {"Kopf", "Thorax", "Abdomen", "Rechter Arm", "Linker Arm", "Rechtes Bein", "Linkes Bein"}

		if dmgInfo:GetDamageType() == DMG_CLUB then
			local success, message = Medicsystem:AddInjury(ply, table.Random(hitgroups), dmgInfo:GetDamage(), "contusion")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'contusion' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end
	end
}

Medicsystem:RegisterInjury("contusion", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/injuries/innerbleeding.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Innere Blutung"
Injury.Treatments = {
	["anticeptind"] = true,
	["kouhunin"] = true,
	["laserscalpel"] = true,
	["bloodaspirator"] = true,
	["synthflesh"] = true,
	["woundglue"] = true,
	["bactabandage"] = true
}

Injury.scanNeeded = true

Injury.Detection = {
	["Medicsystem.AddedInjury"] = function(ply, hitgroup, injury, damage, severity)
		-- Player mustn't be a droid
		if ply:IsDroid() then return end

		-- Ragdolls cannot have internal bleeding
		if ply:IsRagdoll() then return end

		-- The player can only have an inner bleeding
		if ply:HasInjury("innerbleeding") then return end

		-- No inner bleeding in the head
		if hitgroup == "Kopf" then return end

		local injuries = {["explosivefragments"] = 4, ["openfracture"] = 2, ["cut"] = 5}
		if injuries[injury] and severity >= injuries[injury] then
			-- It is very unlikely that inner bleeding will occur.
			if math.random() > 0.1 then return end

			-- Adds the inner bleeding
			local success, message = Medicsystem:AddInjury(ply, hitgroup, damage, "innerbleeding")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'innerbleeding' to player " .. ply:Nick() .. "(" .. message .. ").")
				return
			end

			-- Activates the inner bleeding effect
			Medicsystem:ToggleEffect(ply, "innerbleeding", true)

			-- Creates the inner bleeding timer that deals 5 damage every 30 seconds
			timer.Create("Medicsystem_InnerBleeding_" .. ply:SteamID64(), 30, 0, function()
				-- This should not really happen, but as a precaution I'll keep this
				if not ply:HasInjury("innerbleeding") then
					timer.Remove("Medicsystem_InnerBleeding_" .. ply:SteamID64())
					return
				end

				-- If the player is dead, no HP can be taken from him
				if not ply:Alive() then return end
				ply:TakeDamage(5)
			end)
		end
	end,

	["Medicsystem.InjuryTreated"] = function(ply, hitgroup, injury)
		if injury == "innerbleeding" then
			-- For ragdolls, neither an effect nor a timer needs to be removed
			if ply:IsRagdoll() then return end

			-- Disables the inner bleeding effect
			Medicsystem:ToggleEffect(ply, "innerbleeding", false)

			-- Removes the inner bleeding timer
			timer.Remove("Medicsystem_InnerBleeding_" .. ply:SteamID64())
		end
	end,

	["PlayerSpawn"] = function(ply)
		-- If the injuries persist, nothing is removed.
		if ply.KeepInjured then return end

		-- Disables the inner bleeding effect
		Medicsystem:ToggleEffect(ply, "innerbleeding", false)

		-- Removes the inner bleeding timer
		timer.Remove("Medicsystem_InnerBleeding_" .. ply:SteamID64())
	end,

	["Medicsystem.AdminHealed"] = function(ply)
		-- Disables the inner bleeding effect
		Medicsystem:ToggleEffect(ply, "innerbleeding", false)

		-- Removes the inner bleeding timer
		timer.Remove("Medicsystem_InnerBleeding_" .. ply:SteamID64())
	end
}


Injury.Effect = {
	hookName = "RenderScreenspaceEffects",
	material = "models/shadertest/shader3",
	refract = -0.01
}

Medicsystem:RegisterInjury("innerbleeding", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/injuries/latheniol.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Latheniol"
Injury.Treatments = {}

Injury.Incurable = true

Injury.scanNeeded = true

Medicsystem:RegisterInjury("latheniol", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/injuries/legaffection.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Gehstörung"
Injury.Treatments = {}

Injury.Incurable = true

Injury.Detection = {
	["Medicsystem.AddedInjury"] = function(ply, hitgroup, injury, damage, severity)
		if not ply:IsPlayer() then return end
		if ply.Injuries[hitgroup]["legaffection"] then return end

		local hitgroups = {["Linkes Bein"] = true, ["Rechtes Bein"] = true}
		if hitgroups[hitgroup] and severity >= Medicsystem.LegAffect then
			if ply.Injuries[hitgroup][Injury.Name] then return end

			local success, message = Medicsystem:AddInjury(ply, hitgroup, damage, "legaffection")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'legaffection' to player " .. ply:Nick() .. "(" .. message .. ").")
				return
			end

			ply:SetRunSpeed(ply:GetWalkSpeed())
		end
	end,

	["Medicsystem.InjuryTreated"] = function(ply, hitgroup, injury)
		local hitgroups = {["Linkes Bein"] = {}, ["Rechtes Bein"] = {}}

		if hitgroups[hitgroup] then
			-- Checks if legaffect injuries exists
			for name, data in pairs(hitgroups) do
				if not ply.Injuries[name] then continue end

				for _, i in pairs(ply.Injuries[name]) do
					if i.name == Injury.Name then continue end

					if i.severity >= Medicsystem.LegAffect then
						return
					end
				end
			end

			-- Removes leg affection on every leg
			for name, data in pairs(hitgroups) do
				if not ply.Injuries[name] then continue end

				for _, i in pairs(ply.Injuries[name]) do
					if i.name == Injury.Name then
						ply.Injuries[name]["legaffection"] = nil
					end
				end
			end

			ply:SetRunSpeed(ply:GetWalkSpeed() * 1.5)
		end
	end,

	["PlayerSpawn"] = function(ply)
		timer.Simple(3, function()
			if ply:HasInjury("legaffection") then
				ply:SetRunSpeed(ply:GetWalkSpeed())
			end
		end)
	end,

	["Medicsystem.AdminHealed"] = function(ply)
		if ply:GetRunSpeed() == ply:GetWalkSpeed() then
			ply:SetRunSpeed(ply:GetWalkSpeed() * 1.5)
		end
	end
}

Medicsystem:RegisterInjury("legaffection", Injury)
--gamemodes/starwarsrp/gamemode/modules/medicsystem_cwrp/injuries/openfracture.lua:
---------------------------------------
---------------------------------------
--        	 Einfach Gaming	     	 --
-- 		   Clone Wars Roleplay		 --
--                                   --
--            Medicsystem            --
--                                   --
--            Created by             --
--       		Deltaa       		 --
---------------------------------------
---------------------------------------

---------------------------------------
--       Medicsystem | Injury        --
---------------------------------------

local Injury = {}

Injury.Name = "Offener Bruch"
Injury.Treatments = {
	["anticeptind"] = true,
	["nullicaine"] = true,
	["bonemer"] = true,
	["coagulin"] = true,
	["woundglue"] = true,
	["splint"] = true,
	["bactabandage"] = true
}

Injury.Detection = {
	["Medicsystem.AddInjury"] = function(ply, hitgroup, dmgInfo)
		-- Player mustn't be a droid
		if ply:IsDroid() then return end

		-- Custom damage: force crush / bloody sacrifice
		if dmgInfo:GetDamageCustom() == 0630 then
			hitgroup = table.Random({"Linker Arm", "Rechter Arm", "Rechtes Bein", "Linkes Bein"})

			local success, message = Medicsystem:AddInjury(ply, hitgroup, dmgInfo:GetDamage(), "openfracture")
			if not success and message then
				LogError("Medicsystem: Couldn't add injury 'openfracture' to player " .. ply:Nick() .. "(" .. message .. ").")
			end
		end
	end,
}

Medicsystem:RegisterInjury("openfracture", Injury)
--lua/prone/class_prone_statedata.lua:
-- The prone.PlayerStateData class simply stores some data about the given player's current prone state.
prone.PlayerStateDatas = prone.PlayerStateDatas or {}	-- Stores state data objects for players.

-- The class itself.
prone.PlayerStateData = {
	Player = 0,
	PlayerSteamID = "",
	OriginalViewOffset = Vector(0, 0, 64),
	OriginalViewOffsetDucked = Vector(0, 0, 28),
	StartTime = 0,
	GetDownTime = 0,
	EndTime = 0,
	GetUpTime = 0,
	EnterProneAnimLength = 0,
	EndProneAnimLength = 0
}

-- Generate simple getters and setters:
local preSettersGettersAdded = table.Copy(prone.PlayerStateData)
for k, v in pairs(preSettersGettersAdded) do
	prone.PlayerStateData["Get"..k] = function(self)
		return self[k]
	end
	prone.PlayerStateData["Set"..k] = function(self, newVal)
		self[k] = newVal
	end
end

function prone.PlayerStateData:__tostring()
	return "Prone state data for player '".. (IsValid(self.Player) and self.Player:Nick() or "INVALID PLAYER'")
end

------------------------------------------------
-- prone.PlayerStateData:UpdateDataOnProneEnter
------------------------------------------------
-- Desc:		Updates prone state data of a given player when they go to enter prone.
function prone.PlayerStateData:UpdateDataOnProneEnter()
	self.PlayerSteamID = self.Player:SteamID()
	self.OriginalViewOffset = self.Player:GetViewOffset()
	self.OriginalViewOffsetDucked = self.Player:GetViewOffsetDucked()
	self.StartTime = CurTime()

	local seq = prone.Animations.gettingdown

	self.EnterProneAnimLength = self.Player:SequenceDuration(self.Player:LookupSequence(seq))
	self.GetDownTime = self.EnterProneAnimLength + self.StartTime
end


------------------------------------------
-- prone.PlayerStateData:UpdateOnProneEnd
------------------------------------------
-- Desc:		Updates prone state data of a given player when they go to end prone.
-- Arg One:		Player.
function prone.PlayerStateData:UpdateOnProneEnd(ply)
	self.EndTime = CurTime()

	local seq = prone.Animations.gettingup

	self.EndProneAnimLength = self.Player:SequenceDuration(self.Player:LookupSequence(seq))
	self.GetUpTime = self.EndProneAnimLength + self.EndTime
end

-----------------------------
-- prone.PlayerStateData:New
-----------------------------
-- Desc:		Creates and returns a new prone.PlayerStateData object.
-- Arg One:		Player entity, whose state data this is.
-- Returns:		prone.PlayerStateData object.
function prone.PlayerStateData:New(ply)
	data = {Player = ply}
	setmetatable(data, self)
	self.__index = self
	return data
end
--addons/prone_mod_wos/lua/prone/cl_prone.lua:
hook.Add("EntityNetworkedVarChanged", "prone.DetectProneStateChanges", function(ply, nwVarName, oldVal, newVal)
	if nwVarName == "prone.AnimationState" then
		if newVal == PRONE_GETTINGDOWN or newVal == PRONE_GETTINGUP then
			ply:AnimRestartMainSequence()
			ply:SetCycle(0)
			ply:SetPlaybackRate(1)
		elseif newVal == PRONE_NOTINPRONE then
			ply:ResetHull()
		end
	end
end)

-- Called to inform the player that they can't get up.
local lastGetUpPrintTime = 0		-- Last time a print was made.
local getUpWarningPrintDelay = 2	-- Time it takes before allowing another print.
function prone.CantGetUpWarning()
	local ct = CurTime()

	if lastGetUpPrintTime < ct then
		Notify:Danger("Fehler!", "Hier ist nicht genug Platz, um aufzustehen!")
		lastGetUpPrintTime = ct + getUpWarningPrintDelay
	end
end

--------------------
-- prone.SetImpulse
--------------------
-- Desc:		This is the proper, predicted, way to toggle prone.
-- Arg One:		CUserCmd object, to set the impulse on.
function prone.SetImpulse(cmd)
	cmd:SetImpulse(PRONE_IMPULSE)
end

-----------------
-- prone.Request
-----------------
-- Desc:		Begins sending a prone impulse to the server.
local SendImpulse = false
function prone.Request()
	SendImpulse = true
end

-------------------
-- Bind key handler
-------------------
hook.Add("CreateMove", "prone.ReadBindKeys", function(cmd)
	local ply = LocalPlayer()
	if not IsValid(ply) then
		return
	end

	if SendImpulse then
		prone.SetImpulse(cmd)

		if cmd:TickCount() ~= 0 then
			SendImpulse = false
		end
	end
end)

-------------------
-- View Transitions
-------------------

-- Addons should use the prone.ShouldChangeCalcView and prone.ShouldChangeCalcViewModelView hooks instead of this cvar.
local enabledViewTransitions = CreateClientConVar("prone_disabletransitions", "0", true, false, "Disables the slide down and up of the get up/down animations.")

do
	local headPos, headAng
	hook.Add("CalcView", "prone.ViewTransitions", function(ply, pos)
		if ply ~= LocalPlayer() or enabledViewTransitions:GetBool() then
			return
		end

		local result = hook.Run("prone.ShouldChangeCalcView", ply)
		if result == false then
			return
		end

		local proneState = ply:GetProneAnimationState()
		if proneState ~= PRONE_GETTINGDOWN and proneState ~= PRONE_GETTINGUP then
			headPos = nil
			return
		end

		headPos, headAng = ply:GetBonePosition(ply:LookupBone("ValveBiped.Bip01_Head1"))
		return {origin = headPos}
	end)
	hook.Add("CalcViewModelView", "prone.ViewTransitions", function()
		local localply = LocalPlayer()

		if enabledViewTransitions:GetBool() then
			return
		end

		local result = hook.Run("prone.ShouldChangeCalcViewModelView", localply)
		if result == false then
			return
		end

		local proneState = localply:GetProneAnimationState()
		if proneState ~= PRONE_GETTINGDOWN and proneState ~= PRONE_GETTINGUP then
			headPos = nil
			return
		end

		if headPos then
			return headPos
		end
	end)
end